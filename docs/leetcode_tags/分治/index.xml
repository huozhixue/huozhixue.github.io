<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>分治 - 力扣标签 - 个人博客</title>
        <link>https://huozhixue.github.io/leetcode_tags/%E5%88%86%E6%B2%BB/</link>
        <description>分治 - 力扣标签 - 个人博客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 19 Feb 2022 23:00:00 &#43;0800</lastBuildDate><atom:link href="https://huozhixue.github.io/leetcode_tags/%E5%88%86%E6%B2%BB/" rel="self" type="application/rss+xml" /><item>
    <title>2179：统计数组中好三元组数目（2272 分）</title>
    <link>https://huozhixue.github.io/leetcode/2179/</link>
    <pubDate>Sat, 19 Feb 2022 23:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/2179/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/count-good-triplets-in-an-array/" target="_blank" rel="noopener noreffer">力扣第 72 场双周赛第 4 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给你两个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>nums1</code> 和 <code>nums2</code> ，两者都是 <code>[0, 1, ..., n - 1]</code> 的 <strong>排列</strong> 。</p>
<p><strong>好三元组 </strong>指的是 <code>3</code> 个 <strong>互不相同</strong> 的值，且它们在数组 <code>nums1</code> 和 <code>nums2</code> 中出现顺序保持一致。换句话说，如果我们将 <code>pos1<sub>v</sub></code> 记为值 <code>v</code> 在 <code>nums1</code> 中出现的位置，<code>pos2<sub>v</sub></code> 为值 <code>v</code> 在 <code>nums2</code> 中的位置，那么一个好三元组定义为 <code>0 &lt;= x, y, z &lt;= n - 1</code> ，且 <code>pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z</sub></code> 和 <code>pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub></code> 都成立的 <code>(x, y, z)</code> 。</p>]]></description>
</item><item>
    <title>1649：通过指令创建有序数组（2207 分）</title>
    <link>https://huozhixue.github.io/leetcode/1649/</link>
    <pubDate>Sun, 08 Nov 2020 11:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/1649/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/create-sorted-array-through-instructions/" target="_blank" rel="noopener noreffer">力扣第 214 场周赛第 4 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给你一个整数数组 <code>instructions</code> ，你需要根据 <code>instructions</code> 中的元素创建一个有序数组。一开始你有一个空的数组 <code>nums</code> ，你需要 <strong>从左到右</strong> 遍历 <code>instructions</code> 中的元素，将它们依次插入 <code>nums</code> 数组中。每一次插入操作的 <strong>代价</strong> 是以下两者的 <strong>较小值</strong> ：</p>]]></description>
</item><item>
    <title>0973：最接近原点的 K 个点（1213 分）</title>
    <link>https://huozhixue.github.io/leetcode/0973/</link>
    <pubDate>Sun, 13 Jan 2019 10:30:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/0973/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/k-closest-points-to-origin/" target="_blank" rel="noopener noreffer">力扣第 119 场周赛第 1 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给定一个数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <strong>X-Y</strong> 平面上的一个点，并且是一个整数 <code>k</code> ，返回离原点 <code>(0,0)</code> 最近的 <code>k</code> 个点。</p>
<p>这里，平面上两点之间的距离是 <strong>欧几里德距离</strong>（ <code>√(x<sub>1</sub> - x<sub>2</sub>)<sup>2</sup> + (y<sub>1</sub> - y<sub>2</sub>)<sup>2</sup></code> ）。</p>]]></description>
</item><item>
    <title>0918：环形子数组的最大和（1777 分）</title>
    <link>https://huozhixue.github.io/leetcode/0918/</link>
    <pubDate>Sun, 07 Oct 2018 09:40:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/0918/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener noreffer">力扣第 105 场周赛第 2 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong> <code>nums</code> ，返回<em> <code>nums</code> 的非空 <strong>子数组</strong> 的最大可能和 </em>。</p>
<p><strong>环形数组</strong><em> </em>意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code> 的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p>]]></description>
</item><item>
    <title>0912：排序数组（★）</title>
    <link>https://huozhixue.github.io/leetcode/0912/</link>
    <pubDate>Thu, 20 Sep 2018 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/0912/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/sort-an-array/" target="_blank" rel="noopener noreffer">力扣第 912 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p>
<ol>
</ol>
<p><strong>示例 1：</strong></p>
<pre>
<strong>输入：</strong>nums = [5,2,3,1]
<strong>输出：</strong>[1,2,3,5]
</pre>
<p><strong>示例 2：</strong></p>]]></description>
</item><item>
    <title>0889：根据前序和后序遍历构造二叉树（1731 分）</title>
    <link>https://huozhixue.github.io/leetcode/0889/</link>
    <pubDate>Sun, 19 Aug 2018 09:50:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/0889/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener noreffer">力扣第 98 场周赛第 3 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给定两个整数数组，<code>preorder</code> 和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p>]]></description>
</item><item>
    <title>0654：最大二叉树（★）</title>
    <link>https://huozhixue.github.io/leetcode/0654/</link>
    <pubDate>Sat, 15 Oct 2016 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/0654/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/maximum-binary-tree/" target="_blank" rel="noopener noreffer">力扣第 654 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p>
<ol>
<li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li>
<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <em><code>nums</code> 构建的 </em><strong><em>最大二叉树</em> </strong>。</p>]]></description>
</item><item>
    <title>0493：翻转对（★★）</title>
    <link>https://huozhixue.github.io/leetcode/0493/</link>
    <pubDate>Sat, 07 May 2016 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/0493/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/reverse-pairs/" target="_blank" rel="noopener noreffer">力扣第 493 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给定一个数组 <code>nums</code> ，如果 <code>i &lt; j</code> 且 <code>nums[i] &gt; 2*nums[j]</code> 我们就将 <code>(i, j)</code> 称作一个<strong><em>重要翻转对</em></strong>。</p>
<p>你需要返回给定数组中的重要翻转对的数量。</p>
<p><strong>示例 1:</strong></p>]]></description>
</item><item>
    <title>0427：建立四叉树（★）</title>
    <link>https://huozhixue.github.io/leetcode/0427/</link>
    <pubDate>Wed, 02 Mar 2016 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/0427/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/construct-quad-tree/" target="_blank" rel="noopener noreffer">力扣第 427 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给你一个 <code>n * n</code> 矩阵 <code>grid</code> ，矩阵由若干 <code>0</code> 和 <code>1</code> 组成。请你用四叉树表示该矩阵 <code>grid</code> 。</p>
<p>你需要返回能表示矩阵 <code>grid</code> 的 四叉树 的根结点。</p>]]></description>
</item><item>
    <title>0395：至少有 K 个重复字符的最长子串（★）</title>
    <link>https://huozhixue.github.io/leetcode/0395/</link>
    <pubDate>Sat, 30 Jan 2016 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://huozhixue.github.io/leetcode/0395/</guid>
    <description><![CDATA[<blockquote>
<p><u><strong><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener noreffer">力扣第 395 题</a></strong></u></p>
</blockquote>
<h2 id="题目">题目</h2>
<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p>]]></description>
</item></channel>
</rss>
