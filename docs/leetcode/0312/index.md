# 0312：戳气球（★★★）


## 题目

有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 
这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，
那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。

示例 1：

    输入：nums = [3,1,5,8]
    输出：167
    解释：
    nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
    coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

示例 2：

    输入：nums = [1,5]
    输出：10
	
提示：
- n == nums.length
- 1 <= n <= 500
- 0 <= nums[i] <= 100


## 分析

为了方便，在前后各加一个数字 1 的气球得到数组 A。问题转为求 A 戳破非边界气球能得到的最大硬币数。

假设最后戳破第 k 个气球，获得 A[0]*A[-1]*A[k] 个硬币，剩下的即转为 A[:k+1] 和 A[k:] 的递归子问题。

令 dp[i][j] 代表 A[i:j+1] 能得到的最大硬币数，则递推式为：

	dp[i][j] = max(A[k]*A[i]*A[j]+dp[i][k]+dp[k][j] for k in range(i+1, j))

## 解答

```python
def maxCoins(self, nums: List[int]) -> int:
    A = [1]+nums+[1]
    n = len(A)
    dp = [[0]*n for _ in range(n)]
    for i in range(n-3, -1, -1):
        for j in range(i+2, n):
            dp[i][j] = max(A[k]*A[i]*A[j]+dp[i][k]+dp[k][j] for k in range(i+1, j))
    return dp[0][-1]
```
时间复杂度 O(N^3)，2968 ms

