[{"categories":null,"content":"电影《深海》是田晓鹏导演继《大圣归来》后执导的原创动画长片新作，也是十月文化一次具有探索意义的三维动画创作。在近年来古风盛行的国漫作品中，《深海》将另辟蹊径，用独特的东方美学演绎一个现代背景的奇幻故事。\n\n电影《深海》构建了一个不同于以往的全新海底世界，讲述了一位少女在神秘海底世界中追寻探索，邂逅一段独特生命旅程的故事。海报中呈现的巨大旋涡、奇特鱼群、旋涡中的眼睛等意象，都展现出奇幻“深海”世界的冰山一角，而主角少女坚定地向旋涡深处游去的姿态，也刚好印证了海报上“心之所往，比海更深”的标语。","date":"2023-01-22","objectID":"/anime/deep_sea/","tags":null,"title":"深海","uri":"/anime/deep_sea/"},{"categories":null,"content":"简介 电影《深海》是田晓鹏导演继《大圣归来》后执导的原创动画长片新作，也是十月文化一次具有探索意义的三维动画创作。在近年来古风盛行的国漫作品中，《深海》将另辟蹊径，用独特的东方美学演绎一个现代背景的奇幻故事。 电影《深海》构建了一个不同于以往的全新海底世界，讲述了一位少女在神秘海底世界中追寻探索，邂逅一段独特生命旅程的故事。海报中呈现的巨大旋涡、奇特鱼群、旋涡中的眼睛等意象，都展现出奇幻“深海”世界的冰山一角，而主角少女坚定地向旋涡深处游去的姿态，也刚好印证了海报上“心之所往，比海更深”的标语。 制作人员： 导演：田晓鹏 製作：十月文化、光线影业 ","date":"2023-01-22","objectID":"/anime/deep_sea/:1:0","tags":null,"title":"深海","uri":"/anime/deep_sea/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 深海 2023-01-22 1 bilibili ","date":"2023-01-22","objectID":"/anime/deep_sea/:2:0","tags":null,"title":"深海","uri":"/anime/deep_sea/"},{"categories":null,"content":"MAD ","date":"2023-01-22","objectID":"/anime/deep_sea/:3:0","tags":null,"title":"深海","uri":"/anime/deep_sea/"},{"categories":null,"content":"作为网络吉他手“吉他英雄”而广受好评的后藤一里，在现实中却是个什么都不会的沟通障碍者。一里有着组建乐队的梦想，但因为不敢向人主动搭话而一直没有成功，直到一天在公园中被伊地知虹夏发现并邀请进入缺少吉他手的“结束乐队”。可是，完全没有和他人合作经历的一里，在人前完全发挥不出原本的实力。为了努力克服沟通障碍，一里与“结束乐队”的成员们一同开始努力……","date":"2022-10-08","objectID":"/anime/bocchi_the_rock/","tags":null,"title":"孤独摇滚！","uri":"/anime/bocchi_the_rock/"},{"categories":null,"content":"简介 作为网络吉他手“吉他英雄”而广受好评的后藤一里，在现实中却是个什么都不会的沟通障碍者。一里有着组建乐队的梦想，但因为不敢向人主动搭话而一直没有成功，直到一天在公园中被伊地知虹夏发现并邀请进入缺少吉他手的“结束乐队”。可是，完全没有和他人合作经历的一里，在人前完全发挥不出原本的实力。为了努力克服沟通障碍，一里与“结束乐队”的成员们一同开始努力…… 制作人员： 原作：滨路晶 导演：斋藤圭一郎 脚本：吉田惠里香 分镜：平峰义大、山本裕介、刈谷畅秀、川上雄介、藤原佳幸 ","date":"2022-10-08","objectID":"/anime/bocchi_the_rock/:1:0","tags":null,"title":"孤独摇滚！","uri":"/anime/bocchi_the_rock/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 后藤一里 后藤独、ごとう ひとり、Gotō Hitori、ぼっち、波奇、ギターヒーロー、吉他英雄 女 青山吉能 2 伊地知虹夏 いじち にじか、Ijichi Nijika 女 鈴代紗弓 3 山田凉 やまだ リョウ、Yamada Ryō 女 水野朔 4 喜多郁代 きた いくよ、Kita Ikuyo 女 長谷川育美 5 后藤直树 ごとう なおき 男 間島淳司 6 后藤美智代 ごとう みちよ 女 末柄里恵 7 后藤二里 后藤双、ごとう ふたり 女 和多田美咲 8 吉米亨 小岩井ことり ","date":"2022-10-08","objectID":"/anime/bocchi_the_rock/:2:0","tags":null,"title":"孤独摇滚！","uri":"/anime/bocchi_the_rock/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 孤独摇滚！ 2022-10-08 12 bilibili ","date":"2022-10-08","objectID":"/anime/bocchi_the_rock/:3:0","tags":null,"title":"孤独摇滚！","uri":"/anime/bocchi_the_rock/"},{"categories":null,"content":"MAD ","date":"2022-10-08","objectID":"/anime/bocchi_the_rock/:4:0","tags":null,"title":"孤独摇滚！","uri":"/anime/bocchi_the_rock/"},{"categories":null,"content":" 力扣第 313 场周赛第 1 题 ","date":"2022-10-02","objectID":"/leetcode/2427/:0:0","tags":null,"title":"2427：公因子的数目","uri":"/leetcode/2427/"},{"categories":null,"content":"题目 给你两个正整数 a 和 b ，返回 a 和 b 的 公 因子的数目。 如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个 公因子 。 示例 1： 输入：a = 12, b = 6 输出：4 解释：12 和 6 的公因子是 1、2、3、6 。 示例 2： 输入：a = 25, b = 30 输出：2 解释：25 和 30 的公因子是 1、5 。 提示： 1 \u003c= a, b \u003c= 1000 ","date":"2022-10-02","objectID":"/leetcode/2427/:1:0","tags":null,"title":"2427：公因子的数目","uri":"/leetcode/2427/"},{"categories":null,"content":"分析 等价于求 a 和 b 的最大公约数 x 的因子数，遍历到 $O(\\sqrt x)$ 即可。 ","date":"2022-10-02","objectID":"/leetcode/2427/:2:0","tags":null,"title":"2427：公因子的数目","uri":"/leetcode/2427/"},{"categories":null,"content":"解答 def commonFactors(self, a: int, b: int) -\u003e int: x = gcd(a, b) res, i = 0, 1 while i*i\u003c=x: if x%i==0: res += 1+(i*i!=x) i += 1 return res 36 ms ","date":"2022-10-02","objectID":"/leetcode/2427/:3:0","tags":null,"title":"2427：公因子的数目","uri":"/leetcode/2427/"},{"categories":null,"content":"《赛博朋克：浪客》是与《赛博朋克2077》共享同一世界观的原创动画项目，为一部十集的独立故事剧集，讲述了一名街头小子尝试在技术高度繁荣、人体改造盛行的未来城市中挣扎求生的故事。冒着失去一切的风险，他选择成为一名浪客 —— 游走于法外的雇佣兵。\n\n据介绍，该动画剧集将是一个与游戏《赛博朋克2077》剧情完全不同的独立故事，舞台依然是夜之城，但会有新的角色新的剧情，并非将游戏故事再演绎一次。","date":"2022-09-13","objectID":"/anime/cyberpunk/","tags":null,"title":"赛博浪客","uri":"/anime/cyberpunk/"},{"categories":null,"content":"简介 《赛博朋克：浪客》是与《赛博朋克2077》共享同一世界观的原创动画项目，为一部十集的独立故事剧集，讲述了一名街头小子尝试在技术高度繁荣、人体改造盛行的未来城市中挣扎求生的故事。冒着失去一切的风险，他选择成为一名浪客 —— 游走于法外的雇佣兵。 据介绍，该动画剧集将是一个与游戏《赛博朋克2077》剧情完全不同的独立故事，舞台依然是夜之城，但会有新的角色新的剧情，并非将游戏故事再演绎一次。 制作人员： 原作：CD Projekt 导演：今石洋之 脚本：宇佐义大、大冢雅彦 分镜：宫岛善博、金子祥之、雨宫哲、石崎寿夫、五十岚海 ","date":"2022-09-13","objectID":"/anime/cyberpunk/:1:0","tags":null,"title":"赛博浪客","uri":"/anime/cyberpunk/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 大卫･马丁内斯 ‎デイビッド･マルティネス 男 KENN 2 露西 Lucyna Kushinada、ルーシー 女 悠木碧 3 曼因 メイン 男 東地宏樹 4 丽贝卡 レベッカ 女 黒沢ともよ 5 ‎琦薇 キーウィ 女 本田貴子 6 多莉欧 ‎ドリオ 女 鷄冠井美智子 7 皮拉 ピラル 男 高木渉 8 法尔科 ファルコ 男 加瀬康之 ","date":"2022-09-13","objectID":"/anime/cyberpunk/:2:0","tags":null,"title":"赛博浪客","uri":"/anime/cyberpunk/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 赛博浪客 2022-09-13 10 樱花 ","date":"2022-09-13","objectID":"/anime/cyberpunk/:3:0","tags":null,"title":"赛博浪客","uri":"/anime/cyberpunk/"},{"categories":null,"content":"MAD ","date":"2022-09-13","objectID":"/anime/cyberpunk/:4:0","tags":null,"title":"赛博浪客","uri":"/anime/cyberpunk/"},{"categories":null,"content":" 力扣第 86 场双周赛第 4 题 ","date":"2022-09-03","objectID":"/leetcode/2398/:0:0","tags":null,"title":"2398：预算内的最多机器人数目（★★）","uri":"/leetcode/2398/"},{"categories":null,"content":"题目 你有 n 个机器人，给你两个下标从 0 开始的整数数组 chargeTimes 和 runningCosts ，两者长度都为 n 。第 i 个机器人充电时间为 chargeTimes[i] 单位时间，花费 runningCosts[i] 单位时间运行。再给你一个整数 budget 。 运行 k 个机器人 总开销 是 max(chargeTimes) + k * sum(runningCosts) ，其中 max(chargeTimes) 是这 k 个机器人中最大充电时间，sum(runningCosts) 是这 k 个机器人的运行时间之和。 请你返回在 不超过 budget 的前提下，你","date":"2022-09-03","objectID":"/leetcode/2398/:1:0","tags":null,"title":"2398：预算内的最多机器人数目（★★）","uri":"/leetcode/2398/"},{"categories":null,"content":"分析 典型的滑动窗口，维护窗口不超过 budget 即可。 其中，维护 chargeTimes 的窗口最大值即是问题 0239 ","date":"2022-09-03","objectID":"/leetcode/2398/:2:0","tags":null,"title":"2398：预算内的最多机器人数目（★★）","uri":"/leetcode/2398/"},{"categories":null,"content":"解答 def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -\u003e int: Q, s = deque(), 0 res, i = 0, 0 for j,(t,c) in enumerate(zip(chargeTimes, runningCosts)): while Q and Q[-1][-1]\u003c=t: Q.pop() Q.append((j, t)) s += runningCosts[j] while Q and Q[0][-1]+(j-i+1)*s\u003ebudget: if","date":"2022-09-03","objectID":"/leetcode/2398/:3:0","tags":null,"title":"2398：预算内的最多机器人数目（★★）","uri":"/leetcode/2398/"},{"categories":null,"content":" 力扣第 305 场周赛第 1 题 ","date":"2022-08-07","objectID":"/leetcode/2367/:0:0","tags":null,"title":"2367：算术三元组的数目","uri":"/leetcode/2367/"},{"categories":null,"content":"题目 给你一个下标从 0 开始、严格递增 的整数数组 nums 和一个正整数 diff 。如果满足下述全部条件，则三元组 (i, j, k) 就是一个 算术三元组 ： i \u003c j \u003c k ， nums[j] - nums[i] == diff 且 nums[k] - nums[j] == diff 返回不同 算术三元组 的数目。 示例 1： 输入：nums = [0,1,4,6,7,10], diff = 3 输出：2 解释： (1, 2, 4) 是算术三元组：7 - 4 == 3 且 4 - 1 == 3 。 (2, 4, 5) 是算术三元组：10 - 7 == 3 且 7 - 4 == 3","date":"2022-08-07","objectID":"/leetcode/2367/:1:0","tags":null,"title":"2367：算术三元组的数目","uri":"/leetcode/2367/"},{"categories":null,"content":"分析 nums 严格递增且 diff 大于 0，所以遍历 nums 的元素 x，判断 x-diff，x-2*diff 是否出现过即可。 ","date":"2022-08-07","objectID":"/leetcode/2367/:2:0","tags":null,"title":"2367：算术三元组的数目","uri":"/leetcode/2367/"},{"categories":null,"content":"解答 def arithmeticTriplets(self, nums: List[int], diff: int) -\u003e int: res, vis = 0, set() for x in nums: res += x-diff in vis and x-2*diff in vis vis.add(x) return res 36 ms ","date":"2022-08-07","objectID":"/leetcode/2367/:3:0","tags":null,"title":"2367：算术三元组的数目","uri":"/leetcode/2367/"},{"categories":null,"content":"2017年秋，敬文的舅舅17岁时被卡车撞上，从此陷入昏迷，直到17年后他奇迹般苏醒。\n敬文去医院探望舅舅，却只见他独自胡言乱语，宣称自己是从大巴哈马鲁异世界归来。\n......舅舅的脑袋显然是坏掉了。\n敬文不知所措，但舅舅却施展魔法，证明自己的确去过另一个时空。\n于是，敬文决定将舅舅接回公寓同住。一方面是没有其他亲戚肯帮忙，另一方面是他觉得可以利用舅舅的能力来赚钱。\n两人同住后，敬文也逐渐了解了舅舅奇幻精彩的冒险，以及他对SEGA的痴狂。然而，有时听着舅舅孤单又残酷的遭遇，让敬文在开心的同时，也为他感到难过。\n这部新颖刺激的异世界喜剧讲述了不同世代的舅甥俩，在公寓的一角拍摄视频，努力朝着网红之路迈进。","date":"2022-07-06","objectID":"/anime/isekai_ojisan/","tags":null,"title":"异世界舅舅","uri":"/anime/isekai_ojisan/"},{"categories":null,"content":"简介 2017年秋，敬文的舅舅17岁时被卡车撞上，从此陷入昏迷，直到17年后他奇迹般苏醒。 敬文去医院探望舅舅，却只见他独自胡言乱语，宣称自己是从大巴哈马鲁异世界归来。 ……舅舅的脑袋显然是坏掉了。 敬文不知所措，但舅舅却施展魔法，证明自己的确去过另一个时空。 于是，敬文决定将舅舅接回公寓同住。一方面是没有其他亲戚肯帮忙，另一方面是他觉得可以利用舅舅的能力来赚钱。 两人同住后，敬文也逐渐了解了舅舅奇幻精彩的冒险，以及他对SEGA的痴狂。然而，有时听着舅舅孤单又残酷的遭遇，让敬文在开心的同时，也为他感到难过。 这部新颖刺激的异世界喜剧讲述了不同世代的舅甥俩，在公寓的一角拍摄视频，努力朝着网红之路","date":"2022-07-06","objectID":"/anime/isekai_ojisan/:1:0","tags":null,"title":"异世界舅舅","uri":"/anime/isekai_ojisan/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 舅舅 岛㟢阳介、嶋㟢陽介、しばざき ようすけ、Shibazaki Yousuke 男 子安武人 2 敬文 高丘敬文、たかおか たかふみ、Takaoka Takafumi 男 福山潤 3 藤宫 藤宫澄夏、藤宮澄夏、ふじみや すみか、Fujimiya Sumika 女 小松未可子 4 精灵 ツンデレエルフ、スザイルギラーゼガルネルブゼギルレアグランゼルガ=エルガ、苏翠路奇拉泽加鲁涅尔鲁蕾娅阿格兰泽尔加·艾尔加、Elf、スイ/翠 女 戸松遥 5 梅贝尔 メイベル=レイベール、梅贝露·蕾贝露、梅贝尔·雷贝尔、Mabel 女 悠木碧 6 爱利希雅 アリシア=イーデルシ","date":"2022-07-06","objectID":"/anime/isekai_ojisan/:2:0","tags":null,"title":"异世界舅舅","uri":"/anime/isekai_ojisan/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 异世界舅舅 2022-07-06 13 bilibili ","date":"2022-07-06","objectID":"/anime/isekai_ojisan/:3:0","tags":null,"title":"异世界舅舅","uri":"/anime/isekai_ojisan/"},{"categories":null,"content":" 力扣第 80 场双周赛第 4 题 ","date":"2022-06-11","objectID":"/leetcode/2302/:0:0","tags":null,"title":"2302：统计得分小于 K 的子数组数目（★）","uri":"/leetcode/2302/"},{"categories":null,"content":"题目 一个数组的 分数 定义为数组之和 乘以 数组的长度。 比方说，[1, 2, 3, 4, 5] 的分数为 (1 + 2 + 3 + 4 + 5) * 5 = 75 。 给你一个正整数数组 nums 和一个整数 k ，请你返回 nums 中分数 严格小于 k 的 非空整数子数组数目。 子数组 是数组中的一个连续元素序列。 示例 1： 输入：nums = [2,1,4,3,5], k = 10 输出：6 解释： 有 6 个子数组的分数小于 10 ： - [2] 分数为 2 * 1 = 2 。 - [1] 分数为 1 * 1 = 1 。 - [4] 分数为 4 * 1 = 4 。 - [3] 分","date":"2022-06-11","objectID":"/leetcode/2302/:1:0","tags":null,"title":"2302：统计得分小于 K 的子数组数目（★）","uri":"/leetcode/2302/"},{"categories":null,"content":"分析 典型的滑动窗口。 ","date":"2022-06-11","objectID":"/leetcode/2302/:2:0","tags":null,"title":"2302：统计得分小于 K 的子数组数目（★）","uri":"/leetcode/2302/"},{"categories":null,"content":"解答 def countSubarrays(self, nums: List[int], k: int) -\u003e int: res = 0 s, i = 0, 0 for j,x in enumerate(nums): s += x while s*(j-i+1)\u003e=k: s-=nums[i] i+=1 res += j-i+1 return res 288 ms ","date":"2022-06-11","objectID":"/leetcode/2302/:3:0","tags":null,"title":"2302：统计得分小于 K 的子数组数目（★）","uri":"/leetcode/2302/"},{"categories":null,"content":" 力扣第 80 场双周赛第 2 题 ","date":"2022-06-11","objectID":"/leetcode/2300/:0:0","tags":null,"title":"2300：咒语和药水的成功对数（★）","uri":"/leetcode/2300/"},{"categories":null,"content":"题目 给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。 同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。 请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。 示例 1： 输入：spells = [5,1,3], potions = [1,2,3,4,5], success = 7 输出：[4,0,3] 解","date":"2022-06-11","objectID":"/leetcode/2300/:1:0","tags":null,"title":"2300：咒语和药水的成功对数（★）","uri":"/leetcode/2300/"},{"categories":null,"content":"分析 potions 排序后，针对每个咒语，二分查找即可。 ","date":"2022-06-11","objectID":"/leetcode/2300/:2:0","tags":null,"title":"2300：咒语和药水的成功对数（★）","uri":"/leetcode/2300/"},{"categories":null,"content":"解答 def successfulPairs(self, spells: List[int], potions: List[int], success: int) -\u003e List[int]: potions.sort() n = len(potions) return [n-bisect_left(potions, success/a) for a in spells] 324 MS ","date":"2022-06-11","objectID":"/leetcode/2300/:3:0","tags":null,"title":"2300：咒语和药水的成功对数（★）","uri":"/leetcode/2300/"},{"categories":null,"content":"每个人都有着不让任何人所看见的一面——\n这是一个世界各国在暗地里展开激烈情报战的时代。东国和西国已经处于冷战状态长达十余年之久。\n隶属于西国情报局对东科（WISE）的精英间谍“黄昏”，为了调查东国国家统一党总裁多诺万·德斯蒙这一威胁东西和平的危险人物的战争计划，黄昏被指派了一个绝密的任务。\n这个任务称之为“枭”作战。\n任务的内容是在一周内组建成一个家庭，潜入德斯蒙的儿子就读的名校，并解决掉德斯蒙。\n但是，黄昏所遇到的“女儿”是能读懂内心的超能力者，“妻子”则是暗杀者。三人为了彼此的利益而成为了一家人，并决定在隐藏真实身份的情况下共同生活。\n世界的和平被托付给了这个意外频出的临时家庭。","date":"2022-04-09","objectID":"/anime/spyfamily/","tags":null,"title":"间谍过家家","uri":"/anime/spyfamily/"},{"categories":null,"content":"简介 每个人都有着不让任何人所看见的一面—— 这是一个世界各国在暗地里展开激烈情报战的时代。东国和西国已经处于冷战状态长达十余年之久。 隶属于西国情报局对东科（WISE）的精英间谍“黄昏”，为了调查东国国家统一党总裁多诺万·德斯蒙这一威胁东西和平的危险人物的战争计划，黄昏被指派了一个绝密的任务。 这个任务称之为“枭”作战。 任务的内容是在一周内组建成一个家庭，潜入德斯蒙的儿子就读的名校，并解决掉德斯蒙。 但是，黄昏所遇到的“女儿”是能读懂内心的超能力者，“妻子”则是暗杀者。三人为了彼此的利益而成为了一家人，并决定在隐藏真实身份的情况下共同生活。 世界的和平被托付给了这个意外频出的临时家庭。 制","date":"2022-04-09","objectID":"/anime/spyfamily/:1:0","tags":null,"title":"间谍过家家","uri":"/anime/spyfamily/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 黄昏 / 罗伊德·弗杰 Loid Forger、Twilight 男 江口拓也 2 尤尔·布莱尔 Yor Briar、いばら姫 女 早見沙織 3 阿妮亚 阿尼亚、安妮亞、Anya 女 種﨑敦美 4 达米安·戴斯蒙德 Damian Desmond 男 藤原夏海 5 贝琪·布莱克贝尔 Becky Blackbell 女 加藤英美里 6 亨利·亨德森 Henry Henderson 男 山路和弘 7 尤里·布莱尔 Yuri Briar 男 小野賢章 8 弗兰基·弗兰克林 Franky Franklin 男 吉野裕行 ","date":"2022-04-09","objectID":"/anime/spyfamily/:2:0","tags":null,"title":"间谍过家家","uri":"/anime/spyfamily/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 间谍过家家 2022-04-09 12 bilibili 2 间谍过家家 第二部分 2022-10-01 13 bilibili ","date":"2022-04-09","objectID":"/anime/spyfamily/:3:0","tags":null,"title":"间谍过家家","uri":"/anime/spyfamily/"},{"categories":null,"content":"MAD ","date":"2022-04-09","objectID":"/anime/spyfamily/:4:0","tags":null,"title":"间谍过家家","uri":"/anime/spyfamily/"},{"categories":null,"content":" 力扣第 284 场周赛第 4 题 ","date":"2022-03-13","objectID":"/leetcode/2203/:0:0","tags":null,"title":"2203：得到要求路径的最小带权子图（★★★）","uri":"/leetcode/2203/"},{"categories":null,"content":"题目 给你一个整数 n ，它表示一个 带权有向 图的节点数，节点编号为 0 到 n - 1 。 同时给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi, weighti] ，表示从 fromi 到 toi 有一条边权为 weighti 的 有向 边。 最后，给你三个 互不相同 的整数 src1 ，src2 和 dest ，表示图中三个不同的点。 请你从图中选出一个 边权和最小 的子图，使得从 src1 和 src2 出发，在这个子图中，都 可以 到达 dest 。如果这样的子图不存在，请返回 -1 。 子图 中的点和边都应该属于原图的一部分。子图的边权和定义","date":"2022-03-13","objectID":"/leetcode/2203/:1:0","tags":null,"title":"2203：得到要求路径的最小带权子图（★★★）","uri":"/leetcode/2203/"},{"categories":null,"content":"分析 最终的子图一定是三岔路的形式（可以反证），而且由三条最短路组成。 因此遍历每个节点 x，使三条最短路之和最小即可。 注意是求所有节点 x 到 dest 的最短路，而不是求 dest 到所有节点的最短路。 一个巧妙的方法是将边全部反向，将问题转为求 dest 到所有节点的最短路。 ","date":"2022-03-13","objectID":"/leetcode/2203/:2:0","tags":null,"title":"2203：得到要求路径的最小带权子图（★★★）","uri":"/leetcode/2203/"},{"categories":null,"content":"解答 def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -\u003e int: def dij(root, nxt): d, pq = defaultdict(lambda: float('inf')), [(0, root)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, w2 in nxt[u]: if v not in d: heappush(pq, (w+w2, v)) return ","date":"2022-03-13","objectID":"/leetcode/2203/:3:0","tags":null,"title":"2203：得到要求路径的最小带权子图（★★★）","uri":"/leetcode/2203/"},{"categories":null,"content":" 力扣第 283 场周赛第 4 题 ","date":"2022-03-06","objectID":"/leetcode/2197/:0:0","tags":null,"title":"2197：替换数组中的非互质数（★★）","uri":"/leetcode/2197/"},{"categories":null,"content":"题目 给你一个整数数组 nums 。请你对数组执行下述操作： 从 nums 中找出 任意 两个 相邻 的 非互质 数。 如果不存在这样的数，终止 这一过程。 否则，删除这两个数，并 替换 为它们的 最小公倍数（Least Common Multiple，LCM）。 只要还能找出两个相邻的非互质数就继续 重复 这一过程。 返回修改后得到的 最终 数组。可以证明的是，以 任意 顺序替换相邻的非互质数都可以得到相同的结果。 生成的测试用例可以保证最终数组中的值 小于或者等于 108 。 两个数字 x 和 y 满足 非互质数 的条件是：GCD(x, y) \u003e 1 ，其中 GCD(x, y) 是 x 和","date":"2022-03-06","objectID":"/leetcode/2197/:1:0","tags":null,"title":"2197：替换数组中的非互质数（★★）","uri":"/leetcode/2197/"},{"categories":null,"content":"分析 因为顺序不影响，所以可以贪心操作。 遍历 nums，每轮将所有能替换的替换到。注意到这种策略下，替换只会发生在末尾，因此可以用栈。 ","date":"2022-03-06","objectID":"/leetcode/2197/:2:0","tags":null,"title":"2197：替换数组中的非互质数（★★）","uri":"/leetcode/2197/"},{"categories":null,"content":"解答 def replaceNonCoprimes(self, nums: List[int]) -\u003e List[int]: stack = [] for num in nums: stack.append(num) while len(stack)\u003e1 and gcd(stack[-2], stack[-1])\u003e1: stack.append(lcm(stack.pop(), stack.pop())) return stack 396 ms ","date":"2022-03-06","objectID":"/leetcode/2197/:3:0","tags":null,"title":"2197：替换数组中的非互质数（★★）","uri":"/leetcode/2197/"},{"categories":null,"content":" 力扣第 73 场双周赛第 3 题 ","date":"2022-03-05","objectID":"/leetcode/2192/:0:0","tags":null,"title":"2192：有向无环图中一个节点的所有祖先（★）","uri":"/leetcode/2192/"},{"categories":null,"content":"题目 给你一个正整数 n ，它表示一个 有向无环图 中节点的数目，节点编号为 0 到 n - 1 （包括两者）。 给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi] 表示图中一条从 fromi 到 toi 的单向边。 请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。 如果 u 通过一系列边，能够到达 v ，那么我们称节点 u 是节点 v 的 祖先 节点。 示例 1： 输入：n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6]","date":"2022-03-05","objectID":"/leetcode/2192/:1:0","tags":null,"title":"2192：有向无环图中一个节点的所有祖先（★）","uri":"/leetcode/2192/"},{"categories":null,"content":"分析 有向无环图可以直接递归。 ","date":"2022-03-05","objectID":"/leetcode/2192/:2:0","tags":null,"title":"2192：有向无环图中一个节点的所有祖先（★）","uri":"/leetcode/2192/"},{"categories":null,"content":"解答 def getAncestors(self, n: int, edges: List[List[int]]) -\u003e List[List[int]]: @lru_cache(None) def dfs(u): return sorted({vv for v in nxt[u] for vv in dfs(v)+[v]}) nxt = defaultdict(list) for v, u in edges: nxt[u].append(v) return [dfs(i) for i in range(n)] 164 ms ","date":"2022-03-05","objectID":"/leetcode/2192/:3:0","tags":null,"title":"2192：有向无环图中一个节点的所有祖先（★）","uri":"/leetcode/2192/"},{"categories":null,"content":" 力扣第 281 场周赛第 4 题 ","date":"2022-02-20","objectID":"/leetcode/2183/:0:0","tags":null,"title":"2183：统计可以被 K 整除的下标对数目（★★★）","uri":"/leetcode/2183/"},{"categories":null,"content":"题目 给你一个下标从 0 开始、长度为 n 的整数数组 nums 和一个整数 k ，返回满足下述条件的下标对 (i, j) 的数目： 0 \u003c= i \u003c j \u003c= n - 1 且\rnums[i] * nums[j] 能被 k 整除。\r示例 1： 输入：nums = [1,2,3,4,5], k = 2\r输出：7\r解释：\r共有 7 对下标的对应积可以被 2 整除：\r(0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4)\r它们的积分别是 2、4、6、8、10、12 和 20 。\r其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15","date":"2022-02-20","objectID":"/leetcode/2183/:1:0","tags":null,"title":"2183：统计可以被 K 整除的下标对数目（★★★）","uri":"/leetcode/2183/"},{"categories":null,"content":"分析 遍历所有下标对时间复杂度高。注意到 nums[i] 重要的是和 k 的公共因子，假如将 nums[i] 替换为 nums[i] 和 k 的最大公约数， 那么结果不会改变。 因此可以将 nums 替换后得到一个计数器 ct，注意到 k 的因子最多 $O(\\sqrt k)$ 个，那么二重循环即可。 注意当 x 满足 x*x%k==0 时，对应的下标对是 ct[x] * (ct[x]-1)//2 个 ","date":"2022-02-20","objectID":"/leetcode/2183/:2:0","tags":null,"title":"2183：统计可以被 K 整除的下标对数目（★★★）","uri":"/leetcode/2183/"},{"categories":null,"content":"解答 def countPairs(self, nums: List[int], k: int) -\u003e int: ct = Counter(gcd(num, k) for num in nums) return sum(ct[x]*(ct[y]-(x==y)) for x in ct for y in ct if x*y%k==0)//2 116 ms ","date":"2022-02-20","objectID":"/leetcode/2183/:3:0","tags":null,"title":"2183：统计可以被 K 整除的下标对数目（★★★）","uri":"/leetcode/2183/"},{"categories":null,"content":" 力扣第 72 场双周赛第 4 题 ","date":"2022-02-19","objectID":"/leetcode/2179/:0:0","tags":null,"title":"2179：统计数组中好三元组数目（★★★）","uri":"/leetcode/2179/"},{"categories":null,"content":"题目 给你两个下标从 0 开始且长度为 n 的整数数组 nums1 和 nums2 ，两者都是 [0, 1, ..., n - 1] 的 排列 。 好三元组 指的是 3 个 互不相同 的值，且它们在数组 nums1 和 nums2 中出现顺序保持一致。换句话说，如果我们将 pos1v 记为值 v 在 nums1 中出现的位置，pos2v 为值 v 在 nums2 中的位置，那么一个好三元组定义为 0 \u003c= x, y, z \u003c= n - 1 ，且 pos1x \u003c pos1y \u003c pos1z 和 pos2x \u003c pos2y \u003c pos2z 都成立的 (x, y, z) 。 请你返回好三元组的 总数","date":"2022-02-19","objectID":"/leetcode/2179/:1:0","tags":null,"title":"2179：统计数组中好三元组数目（★★★）","uri":"/leetcode/2179/"},{"categories":null,"content":"分析 将 nums1 的数映射为在 nums2 中的坐标，得到数组 A，问题转为求 A 中的递增三元组。 遍历每个中间数 y，找前面比 y 小的个数和后面比 y 大的个数即可求得 y 对应的三元组个数。 容易想到维护有序集合，二分查找即可。 ","date":"2022-02-19","objectID":"/leetcode/2179/:2:0","tags":null,"title":"2179：统计数组中好三元组数目（★★★）","uri":"/leetcode/2179/"},{"categories":null,"content":"解答 def goodTriplets(self, nums1: List[int], nums2: List[int]) -\u003e int: from sortedcontainers import SortedList d = {num: i for i, num in enumerate(nums2)} A = [d[num] for num in nums1] res, sl1, sl2 = 0, SortedList(), SortedList(A) for y in A: res += sl1.bisect_left(y)*(len(sl2)-sl2.bisect_right(y)) ","date":"2022-02-19","objectID":"/leetcode/2179/:3:0","tags":null,"title":"2179：统计数组中好三元组数目（★★★）","uri":"/leetcode/2179/"},{"categories":null,"content":" 力扣第 278 场周赛第 3 题 ","date":"2022-01-30","objectID":"/leetcode/2156/:0:0","tags":null,"title":"2156：查找给定哈希值的子串（★★）","uri":"/leetcode/2156/"},{"categories":null,"content":"题目 给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算： hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\r其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val('a') = 1 到 val('z') = 26 。 给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 k 的 子串 sub ，满足 hash(sub, power, modulo) =","date":"2022-01-30","objectID":"/leetcode/2156/:1:0","tags":null,"title":"2156：查找给定哈希值的子串（★★）","uri":"/leetcode/2156/"},{"categories":null,"content":"分析 典型的滚动哈希。 注意这里定义的哈希值在前面的是低位，和一般的滚动哈希相反。 因此考虑将 s 反向，找最后一个满足要求的子串，然后再反向返回即可。 ","date":"2022-01-30","objectID":"/leetcode/2156/:2:0","tags":null,"title":"2156：查找给定哈希值的子串（★★）","uri":"/leetcode/2156/"},{"categories":null,"content":"解答 def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -\u003e str: end, s = None, s[::-1] w, bL = 0, pow(power, k, modulo) for j, char in enumerate(s): w = w*power+ord(char)-ord('a')+1 if j\u003e=k: w -= (ord(s[j-k])-ord('a')+1)*bL w %= modulo if j\u003e=k-1 and w == hashValue: end = j r","date":"2022-01-30","objectID":"/leetcode/2156/:3:0","tags":null,"title":"2156：查找给定哈希值的子串（★★）","uri":"/leetcode/2156/"},{"categories":null,"content":"制作着女儿节娃娃，以成为娃娃工匠为目标的男高中生五条新菜。\n他专心一志地制作女儿娃娃，却也因此疏离的同世代的流行，迟迟无法融入班级。\n对这样的新菜来说，总是身处班上团体的中心，大受欢迎的喜多川海梦就像是不同世界的人一样。\n但就在某天，以意想不到的事情为契机，与海梦拥有了共同的秘密。\n原以为两人绝对不会有交集的世界开始转动了起来。","date":"2022-01-08","objectID":"/anime/my_dress-up_darling/","tags":null,"title":"更衣人偶坠入爱河","uri":"/anime/my_dress-up_darling/"},{"categories":null,"content":"简介 制作着女儿节娃娃，以成为娃娃工匠为目标的男高中生五条新菜。 他专心一志地制作女儿娃娃，却也因此疏离的同世代的流行，迟迟无法融入班级。 对这样的新菜来说，总是身处班上团体的中心，大受欢迎的喜多川海梦就像是不同世界的人一样。 但就在某天，以意想不到的事情为契机，与海梦拥有了共同的秘密。 原以为两人绝对不会有交集的世界开始转动了起来。 制作人员： 原作：福田晋一 导演：筱原启辅 脚本：富田赖子 分镜：山本裕介、平峰义大、川上雄介、牛岛新一郎、小室裕一郎 ","date":"2022-01-08","objectID":"/anime/my_dress-up_darling/:1:0","tags":null,"title":"更衣人偶坠入爱河","uri":"/anime/my_dress-up_darling/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 喜多川海梦 きたがわ まりん、Kitagawa Marin 女 直田姫奈 2 五条新菜 ごじょう わかな、Gojo Wakana 男 高柳知葉 3 乾纱寿叶 いぬい さじゅな、Inui Sajuna、ジュジュ 女 種﨑敦美 4 乾心寿 いぬい しんじゅ、Inui Shinju 女 羊宮妃那 5 五条薰 ごじょうかおる、Gojo Kaoru 男 斧アツシ 6 のばら 女 菅野真衣 7 菅谷乃羽 すがや のわ、Sugaya Nowa 女 武田羅梨沙多胡 8 大空 だいあ 女 雨宮夕夏 ","date":"2022-01-08","objectID":"/anime/my_dress-up_darling/:2:0","tags":null,"title":"更衣人偶坠入爱河","uri":"/anime/my_dress-up_darling/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 更衣人偶坠入爱河 2022-01-08 12 樱花 ","date":"2022-01-08","objectID":"/anime/my_dress-up_darling/:3:0","tags":null,"title":"更衣人偶坠入爱河","uri":"/anime/my_dress-up_darling/"},{"categories":null,"content":"MAD ","date":"2022-01-08","objectID":"/anime/my_dress-up_darling/:4:0","tags":null,"title":"更衣人偶坠入爱河","uri":"/anime/my_dress-up_darling/"},{"categories":null,"content":" 力扣第 68 场双周赛第 2 题 ","date":"2021-12-25","objectID":"/leetcode/2115/:0:0","tags":null,"title":"2115：从给定原材料中找到所有可以做出的菜（★）","uri":"/leetcode/2115/"},{"categories":null,"content":"题目 你有 n 道不同菜的信息。给你一个字符串数组 recipes 和一个二维字符串数组 ingredients 。第 i 道菜的名字为 recipes[i] ，如果你有它 所有 的原材料 ingredients[i] ，那么你可以 做出 这道菜。一道菜的原材料可能是 另一道 菜，也就是说 ingredients[i] 可能包含 recipes 中另一个字符串。 同时给你一个字符串数组 supplies ，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。 请你返回你可以做出的所有菜。你可以以 任意顺序 返回它们。 注意两道菜在它们的原材料中可能互相包含。 示例 1： 输入：recip","date":"2021-12-25","objectID":"/leetcode/2115/:1:0","tags":null,"title":"2115：从给定原材料中找到所有可以做出的菜（★）","uri":"/leetcode/2115/"},{"categories":null,"content":"分析 将材料和菜看作顶点，菜对材料的依赖关系看作边，那么就是典型的拓扑排序问题。 ","date":"2021-12-25","objectID":"/leetcode/2115/:2:0","tags":null,"title":"2115：从给定原材料中找到所有可以做出的菜（★）","uri":"/leetcode/2115/"},{"categories":null,"content":"解答 def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -\u003e List[str]: nxt, indeg = defaultdict(list), defaultdict(int) for r, ings in zip(recipes, ingredients): for ing in ings: nxt[ing].append(r) indeg[r] += 1 queue = deque(u for u in supplies if indeg[u]=","date":"2021-12-25","objectID":"/leetcode/2115/:3:0","tags":null,"title":"2115：从给定原材料中找到所有可以做出的菜（★）","uri":"/leetcode/2115/"},{"categories":null,"content":" 力扣第 270 场周赛第 4 题 ","date":"2021-12-05","objectID":"/leetcode/2097/:0:0","tags":null,"title":"2097：合法重新排列数对（★★★★）","uri":"/leetcode/2097/"},{"categories":null,"content":"题目 给你一个下标从 0 开始的二维整数数组 pairs ，其中 pairs[i] = [starti, endi] 。如果 pairs 的一个重新排列，满足对每一个下标 i （ 1 \u003c= i \u003c pairs.length ）都有 endi-1 == starti ，那么我们就认为这个重新排列是 pairs 的一个 合法重新排列 。 请你返回 任意一个 pairs 的合法重新排列。 注意：数据保证至少存在一个 pairs 的合法重新排列。 示例 1： 输入：pairs = [[5,1],[4,5],[11,9],[9,4]]\r输出：[[11,9],[9,4],[4,5],[5,1]]\r解释：\r","date":"2021-12-05","objectID":"/leetcode/2097/:1:0","tags":null,"title":"2097：合法重新排列数对（★★★★）","uri":"/leetcode/2097/"},{"categories":null,"content":"分析 将 start，end 看作点，pair 看作边，那么就是典型的欧拉通路问题。 数据保证存在欧拉通路，那么先找到起始节点 若存在点的出度比入度多 1，该点即是起始节点\r否则任一点都可作为起始节点\r然后用 Hierholzer 算法即可。 ","date":"2021-12-05","objectID":"/leetcode/2097/:2:0","tags":null,"title":"2097：合法重新排列数对（★★★★）","uri":"/leetcode/2097/"},{"categories":null,"content":"解答 def validArrangement(self, pairs: List[List[int]]) -\u003e List[List[int]]: def dfs(u): while nxt[u]: dfs(nxt[u].pop()) stack.append(u) nxt, ct = defaultdict(list), Counter() for u, v in pairs: nxt[u].append(v) ct[u] += 1 ct[v] -= 1 A = [u for u, _ in pairs if ct[u]==1] stack, start = [], A.pop() if A","date":"2021-12-05","objectID":"/leetcode/2097/:3:0","tags":null,"title":"2097：合法重新排列数对（★★★★）","uri":"/leetcode/2097/"},{"categories":null,"content":" 力扣第 264 场周赛第 4 题 ","date":"2021-10-24","objectID":"/leetcode/2050/:0:0","tags":null,"title":"2050：并行课程 III（★★）","uri":"/leetcode/2050/"},{"categories":null,"content":"题目 给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ，其中 relations[j] = [prevCoursej, nextCoursej] ，表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。 请你根据以下规则算出完成所有课程所需要的 最少 月份数： 如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。 你可以 同时 上 任意门课程 。 请","date":"2021-10-24","objectID":"/leetcode/2050/:1:0","tags":null,"title":"2050：并行课程 III（★★）","uri":"/leetcode/2050/"},{"categories":null,"content":"分析 有向无环图，可以直接递归求课程 u 的最早结束时间。 ","date":"2021-10-24","objectID":"/leetcode/2050/:2:0","tags":null,"title":"2050：并行课程 III（★★）","uri":"/leetcode/2050/"},{"categories":null,"content":"解答 def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -\u003e int: @lru_cache(None) def dfs(u): return max([dfs(v) for v in nxt[u]], default=0)+time[u] nxt = defaultdict(list) for v, u in relations: nxt[u-1].append(v-1) return max(dfs(u) for u in range(n)) 416 ms ","date":"2021-10-24","objectID":"/leetcode/2050/:3:0","tags":null,"title":"2050：并行课程 III（★★）","uri":"/leetcode/2050/"},{"categories":null,"content":" 力扣第 263 场周赛第 4 题 ","date":"2021-10-17","objectID":"/leetcode/2045/:0:0","tags":null,"title":"2045：到达目的地的第二短时间（★★★）","uri":"/leetcode/2045/"},{"categories":null,"content":"题目 城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 time 分钟。 每个节点都有一个交通信号灯，每 change 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。如果信号灯是 绿色 ，你 不能 在节点等待，","date":"2021-10-17","objectID":"/leetcode/2045/:1:0","tags":null,"title":"2045：到达目的地的第二短时间（★★★）","uri":"/leetcode/2045/"},{"categories":null,"content":"分析 容易写出求最短路径的 dijkastra 算法，本题要求次短路径，那么同时记录到每个顶点的最短路径和次短路径， 然后修改一下入堆的判定条件即可。 （因为边的权重相等，也可以直接 bfs，将堆改为队列即可，时间更少点。） ","date":"2021-10-17","objectID":"/leetcode/2045/:2:0","tags":null,"title":"2045：到达目的地的第二短时间（★★★）","uri":"/leetcode/2045/"},{"categories":null,"content":"解答 def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -\u003e int: nxt = defaultdict(list) for u, v in edges: nxt[u-1].append(v-1) nxt[v-1].append(u-1) d, pq = defaultdict(list), [(0, 0)] while pq: w, u = heappop(pq) if len(d[u]) == 2 or (len(d[u])==1 and d[u][0]==w): continu","date":"2021-10-17","objectID":"/leetcode/2045/:3:0","tags":null,"title":"2045：到达目的地的第二短时间（★★★）","uri":"/leetcode/2045/"},{"categories":null,"content":" 力扣第 258 场周赛第 4 题 ","date":"2021-09-12","objectID":"/leetcode/2003/:0:0","tags":null,"title":"2003：每棵子树内缺失的最小基因值（★★★）","uri":"/leetcode/2003/"},{"categories":null,"content":"题目 有一棵根节点为 0 的 家族树 ，总共包含 n 个节点，节点编号为 0 到 n - 1 。给你一个下标从 0 开始的整数数组 parents ，其中 parents[i] 是节点 i 的父节点。由于节点 0 是 根 ，所以 parents[0] == -1 。 总共有 105 个基因值，每个基因值都用 闭区间 [1, 105] 中的一个整数表示。给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是节点 i 的基因值，且基因值 互不相同 。 请你返回一个数组 ans ，长度为 n ，其中 ans[i] 是以节点 i 为根的子树内 缺失 的 最小 基因值。 节点 x 为根","date":"2021-09-12","objectID":"/leetcode/2003/:1:0","tags":null,"title":"2003：每棵子树内缺失的最小基因值（★★★）","uri":"/leetcode/2003/"},{"categories":null,"content":"分析 显然若基因值 1 不在树中，所有 ans 都为 1。 若基因值 1 在树中，对应的节点为 x，那么除了 x 和 x 的所有祖先，其它的 ans 都为 1。 然后可以递推 x 和 x 的祖先的 ans。 设 y 是 x 的父节点，那么从 ans[x] 遍历找到第一个不存在于 y 的子树的基因集合内的正整数即为 ans[y]。 在求 y 的子树的基因集合时，x 的子树无需再遍历。因此求基因集合的操作总共是 O(N) 时间。 递推 x 和 x 的祖先的 ans 时，ans 是递增的，因此遍历求 ans 的操作总共是 O(S) 时间（本题数据范围 S 等于节点个数范围 N) ","date":"2021-09-12","objectID":"/leetcode/2003/:2:0","tags":null,"title":"2003：每棵子树内缺失的最小基因值（★★★）","uri":"/leetcode/2003/"},{"categories":null,"content":"解答 def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -\u003e List[int]: n = len(nums) if 1 not in nums: return [1] * n nxt = defaultdict(list) for v, u in enumerate(parents): nxt[u].append(v) i = nums.index(1) ans, vis, cur = [1]*n, set(), 1 while i != -1: queue = [i] while queue","date":"2021-09-12","objectID":"/leetcode/2003/:3:0","tags":null,"title":"2003：每棵子树内缺失的最小基因值（★★★）","uri":"/leetcode/2003/"},{"categories":null,"content":" 力扣第 258 场周赛第 3 题 ","date":"2021-09-12","objectID":"/leetcode/2002/:0:0","tags":null,"title":"2002：两个回文子序列长度的最大乘积（★★）","uri":"/leetcode/2002/"},{"categories":null,"content":"题目 给你一个字符串 s ，请你找到 s 中两个 不相交回文子序列 ，使得它们长度的 乘积最大 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 不相交 的。 请你返回两个回文子序列长度可以达到的 最大乘积 。 子序列 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 回文字符串 。 示例 1： 输入：s = \"leetcodecom\"\r输出：9\r解释：最优方案是选择 \"ete\" 作为第一个子序列，\"cdc\" 作为第二个子序列。\r它们的乘积为 3 * 3 = 9 。\r示例 2：","date":"2021-09-12","objectID":"/leetcode/2002/:1:0","tags":null,"title":"2002：两个回文子序列长度的最大乘积（★★）","uri":"/leetcode/2002/"},{"categories":null,"content":"分析 数据规模很小，考虑暴力。 遍历所有子序列，如果是回文序列，那么将剩下的位置拼接为 s2，在 s2 中找最长的回文子序列即可。 求最长的回文子序列即是问题 0516 为了方便将 s 拆为两个子序列，可以用状态压缩。 ","date":"2021-09-12","objectID":"/leetcode/2002/:2:0","tags":null,"title":"2002：两个回文子序列长度的最大乘积（★★）","uri":"/leetcode/2002/"},{"categories":null,"content":"解答 def maxProduct(self, s: str) -\u003e int: def cal(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): dp[i][j] = 2 + dp[i + 1][j - 1] if s[i] == s[j] else max(dp[i + 1][j], dp[i][j - 1]) return dp[0][-1] res, n = 0, len(s) for state in ","date":"2021-09-12","objectID":"/leetcode/2002/:3:0","tags":null,"title":"2002：两个回文子序列长度的最大乘积（★★）","uri":"/leetcode/2002/"},{"categories":null,"content":" 力扣第 258 场周赛第 2 题 ","date":"2021-09-12","objectID":"/leetcode/2001/:0:0","tags":null,"title":"2001：可互换矩形的组数（★）","uri":"/leetcode/2001/"},{"categories":null,"content":"题目 用一个下标从 0 开始的二维整数数组 rectangles 来表示 n 个矩形，其中 rectangles[i] = [widthi, heighti] 表示第 i 个矩形的宽度和高度。 如果两个矩形 i 和 j（i \u003c j）的宽高比相同，则认为这两个矩形 可互换 。更规范的说法是，两个矩形满足 widthi/heighti == widthj/heightj（使用实数除法而非整数除法），则认为这两个矩形 可互换 。 计算并返回 rectangles 中有多少对 可互换 矩形。 示例 1： 输入：rectangles = [[4,8],[3,6],[10,20],[15,30]]\r输出：","date":"2021-09-12","objectID":"/leetcode/2001/:1:0","tags":null,"title":"2001：可互换矩形的组数（★）","uri":"/leetcode/2001/"},{"categories":null,"content":"分析 统计每个宽高比对应的矩形个数 x，其中任意两个矩形可互换，即有 x*(x-1)//2 对。 为了避免精度问题，可以用最简分数的形式来代表宽高比。可以用除以最大公约数的方法， 也可以直接调用 fractions.Fraction ","date":"2021-09-12","objectID":"/leetcode/2001/:2:0","tags":null,"title":"2001：可互换矩形的组数（★）","uri":"/leetcode/2001/"},{"categories":null,"content":"解答 def interchangeableRectangles(self, rectangles: List[List[int]]) -\u003e int: ct = Counter() for w, h in rectangles: g = gcd(w, h) ct[(w//g, h//g)]+=1 return sum(v*(v-1)//2 for v in ct.values()) 460 ms ","date":"2021-09-12","objectID":"/leetcode/2001/:3:0","tags":null,"title":"2001：可互换矩形的组数（★）","uri":"/leetcode/2001/"},{"categories":null,"content":" 力扣第 258 场周赛第 1 题 ","date":"2021-09-12","objectID":"/leetcode/2000/:0:0","tags":null,"title":"2000：反转单词前缀","uri":"/leetcode/2000/"},{"categories":null,"content":"题目 给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。 例如，如果 word = \"abcdefd\" 且 ch = \"d\" ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 \"dcbaefd\" 。\r返回 结果字符串 。 示例 1： 输入：word = \"abcdefd\", ch = \"d\"\r输出：\"dcbaefd\"\r解释：\"d\" 第一次出现在下标 3 。\r反转从下","date":"2021-09-12","objectID":"/leetcode/2000/:1:0","tags":null,"title":"2000：反转单词前缀","uri":"/leetcode/2000/"},{"categories":null,"content":"分析 找到 i 后，分割反转再合并即可。 当 ch 不存在时，word.find(ch)=-1，同样适用按位置 i 分割的操作。 ","date":"2021-09-12","objectID":"/leetcode/2000/:2:0","tags":null,"title":"2000：反转单词前缀","uri":"/leetcode/2000/"},{"categories":null,"content":"解答 def reversePrefix(self, word: str, ch: str) -\u003e str: i = word.find(ch) return word[:i+1][::-1] + word[i+1:] 36 ms ","date":"2021-09-12","objectID":"/leetcode/2000/:3:0","tags":null,"title":"2000：反转单词前缀","uri":"/leetcode/2000/"},{"categories":null,"content":" 力扣第 257 场周赛第 4 题 ","date":"2021-09-05","objectID":"/leetcode/1998/:0:0","tags":null,"title":"1998：数组的最大公因数排序（★★★）","uri":"/leetcode/1998/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，你可以在 nums 上执行下述操作 任意次 ： 如果 gcd(nums[i], nums[j]) \u003e 1 ，交换 nums[i] 和 nums[j] 的位置。其中 gcd(nums[i], nums[j]) 是 nums[i] 和 nums[j] 的最大公因数。\r如果能使用上述交换方式将 nums 按 非递减顺序 排列，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [7,21,3]\r输出：true\r解释：可以执行下述操作完成对 [7,21,3] 的排序：\r- 交换 7 和 21 因为 gcd(7,21) = 7 。nums =","date":"2021-09-05","objectID":"/leetcode/1998/:1:0","tags":null,"title":"1998：数组的最大公因数排序（★★★）","uri":"/leetcode/1998/"},{"categories":null,"content":"分析 观察发现，只要 a、b 不互质，b、c 不互质，那么 a、b、c 可交换为任意顺序。 将 a、b 不互质看作是顶点 a、b 之间连了一条边。那么只要 a、b 连通，a、b 就可交换。 因此遍历数据范围内的质数 p，将 nums 中 p 的倍数都连通。 最终判断 nums 和 sorted(nums) 相同位置上不同的数是否连通即可。 ","date":"2021-09-05","objectID":"/leetcode/1998/:2:0","tags":null,"title":"1998：数组的最大公因数排序（★★★）","uri":"/leetcode/1998/"},{"categories":null,"content":"解答 def gcdSort(self, nums: List[int]) -\u003e bool: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) M, vis = max(nums)+1, set(nums) f, flags = list(range(M)), [1] * M for p in range(2, M): if flags[p]: for x in range(p * 2, M, p): flags[x] = 0 if x in vis: u","date":"2021-09-05","objectID":"/leetcode/1998/:3:0","tags":null,"title":"1998：数组的最大公因数排序（★★★）","uri":"/leetcode/1998/"},{"categories":null,"content":" 力扣第 257 场周赛第 3 题 ","date":"2021-09-05","objectID":"/leetcode/1997/:0:0","tags":null,"title":"1997：访问完所有房间的第一天（★★★）","uri":"/leetcode/1997/"},{"categories":null,"content":"题目 你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。 最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定： 假设某一天，你访问 i 号房间。\r如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 \u003c= nextVisit[i] \u003c= i 。\r如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要","date":"2021-09-05","objectID":"/leetcode/1997/:1:0","tags":null,"title":"1997：访问完所有房间的第一天（★★★）","uri":"/leetcode/1997/"},{"categories":null,"content":"分析 观察发现，第一次访问房间 i 后，跳到房间 j=nextVisit[i]。 然后从 j 到 i 会重复之前第一次从 j 到 i 的过程。之后再移到房间 i+1。 因此考虑递推，令 dp[i] 代表第一次访问房间 i 的日期。那么 第一次从 j 到 i 的过程用了 dp[i]-dp[j] 天\rdp[i+1] = dp[i] + 1 + dp[i] - dp[j] + 1\r= 2*dp[i]-dp[j]+2\r最终 dp[-1] 即为所求。 ","date":"2021-09-05","objectID":"/leetcode/1997/:2:0","tags":null,"title":"1997：访问完所有房间的第一天（★★★）","uri":"/leetcode/1997/"},{"categories":null,"content":"解答 def firstDayBeenInAllRooms(self, nextVisit: List[int]) -\u003e int: n, mod = len(nextVisit), 10**9+7 dp = [0] * n for i in range(1, n): dp[i] = 2*dp[i-1]-dp[nextVisit[i-1]]+2 dp[i] %= mod return dp[-1] 228 ms ","date":"2021-09-05","objectID":"/leetcode/1997/:3:0","tags":null,"title":"1997：访问完所有房间的第一天（★★★）","uri":"/leetcode/1997/"},{"categories":null,"content":" 力扣第 257 场周赛第 2 题 ","date":"2021-09-05","objectID":"/leetcode/1996/:0:0","tags":null,"title":"1996：游戏中弱角色的数量（★★）","uri":"/leetcode/1996/"},{"categories":null,"content":"题目 你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj \u003e attacki 且 defensej \u003e defensei 。 返回 弱角色 的数量。 示例 1： 输入：properties = [[5,5],[6,3],[3,6]]\r输出：0\r","date":"2021-09-05","objectID":"/leetcode/1996/:1:0","tags":null,"title":"1996：游戏中弱角色的数量（★★）","uri":"/leetcode/1996/"},{"categories":null,"content":"分析 将角色按攻击排序，若攻击相同则防御较高的排前面。 令 A 代表排序后的防御数组，那么 A[i] 是弱角色等价于后面后面有角色的防御更高，即 A[i]\u003cmax(A[i+1:])。 那么倒序遍历 i 并维护 max(A[i+1:])，即可在 O(N) 时间得到弱角色数量。 ","date":"2021-09-05","objectID":"/leetcode/1996/:2:0","tags":null,"title":"1996：游戏中弱角色的数量（★★）","uri":"/leetcode/1996/"},{"categories":null,"content":"解答 def numberOfWeakCharacters(self, properties: List[List[int]]) -\u003e int: A = sorted(properties, key=lambda x: (x[0],-x[1])) res, M = 0, float('-inf') for _, x in A[::-1]: res += int(x \u003c M) M = max(M, x) return res 时间复杂度 O(N*logN)，600 ms ","date":"2021-09-05","objectID":"/leetcode/1996/:3:0","tags":null,"title":"1996：游戏中弱角色的数量（★★）","uri":"/leetcode/1996/"},{"categories":null,"content":" 力扣第 257 场周赛第 1 题 ","date":"2021-09-05","objectID":"/leetcode/1995/:0:0","tags":null,"title":"1995：统计特殊四元组","uri":"/leetcode/1995/"},{"categories":null,"content":"题目 给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ： nums[a] + nums[b] + nums[c] == nums[d] ，且\ra \u003c b \u003c c \u003c d\r示例 1： 输入：nums = [1,2,3,6]\r输出：1\r解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\r示例 2： 输入：nums = [3,3,6,4,5]\r输出：0\r解释：[3,3,6,4,5] 中不存在满足要求的四元组。\r示例 3： 输入：nums = [1,1,1,3,5]\r输出：4\r解释","date":"2021-09-05","objectID":"/leetcode/1995/:1:0","tags":null,"title":"1995：统计特殊四元组","uri":"/leetcode/1995/"},{"categories":null,"content":"分析 ","date":"2021-09-05","objectID":"/leetcode/1995/:2:0","tags":null,"title":"1995：统计特殊四元组","uri":"/leetcode/1995/"},{"categories":null,"content":"#1 最简单的就是固定 c 和 d，在 [0, c) 中求和等于 nums[d]-nums[c] 的二元组个数，可以用哈希表。 def countQuadruplets(self, nums: List[int]) -\u003e int: res, n = 0, len(nums) for d in range(n): for c in range(d): ct = Counter() for b in range(c): res += ct[nums[d]-nums[c]-nums[b]] ct[nums[b]] += 1 return res 时间复杂度 O(N^3)，628 ms ","date":"2021-09-05","objectID":"/leetcode/1995/:2:1","tags":null,"title":"1995：统计特殊四元组","uri":"/leetcode/1995/"},{"categories":null,"content":"#2 注意到数据范围很小，所以考虑直接统计 nums[:d] 中的 {三元组的和: 三元组的个数} 哈希表。 nums[:i+1] 的三元组计数显然可以由 nums[i] 和 nums[:i] 中 {二元组的和: 二元组的个数} 哈希表得到。 同理，nums[:i+1] 的二元组计数可以由 nums[i] 和 Counter(nums[:i]) 得到。 令 dp3[i]、dp2[i]、dp1[i] 分别代表 nums[:i+1] 的三元组计数、二元组计数、哈希表计数。那么： dp1[i], dp2[i], dp3[i] = dp1[i-1].copy(), dp2[i-1].copy(), d","date":"2021-09-05","objectID":"/leetcode/1995/:2:2","tags":null,"title":"1995：统计特殊四元组","uri":"/leetcode/1995/"},{"categories":null,"content":"解答 def countQuadruplets(self, nums: List[int]) -\u003e int: res, ct1, ct2, ct3 = 0, Counter(), Counter(), Counter() for num in nums: res += ct3[num] for x in ct2: ct3[x+num] += ct2[x] for x in ct1: ct2[x+num] += ct1[x] ct1[num] += 1 return res 时间复杂度 O(N*S)，116 ms ","date":"2021-09-05","objectID":"/leetcode/1995/:3:0","tags":null,"title":"1995：统计特殊四元组","uri":"/leetcode/1995/"},{"categories":null,"content":" 力扣第 60 场双周赛第 4 题 ","date":"2021-09-04","objectID":"/leetcode/1994/:0:0","tags":null,"title":"1994：好子集的数目（★★★）","uri":"/leetcode/1994/"},{"categories":null,"content":"题目 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。 比方说，如果 nums = [1, 2, 3, 4] ：\r[2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。\r[1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。\r请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。 nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能","date":"2021-09-04","objectID":"/leetcode/1994/:1:0","tags":null,"title":"1994：好子集的数目（★★★）","uri":"/leetcode/1994/"},{"categories":null,"content":"分析 注意到取值范围非常小，可以列举出能作为好子集元素的数的集合： A = [1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30]。 令 dp[i] 代表 nums 中 A[:i] 范围内的数能组成的 {好子集的乘积: 对应的个数} 哈希表。 为了方便，先将 1 组成的集合和空集也看作好子集。发现可以递推： dp[i+1] = dp[i].copy()\rfor x in dp[i]:\rif gcd(x, A[i]) == 1:\rdp[i+1][x*A[i]] += Counter(nums)[A[i]] * ","date":"2021-09-04","objectID":"/leetcode/1994/:2:0","tags":null,"title":"1994：好子集的数目（★★★）","uri":"/leetcode/1994/"},{"categories":null,"content":"解答 def numberOfGoodSubsets(self, nums: List[int]) -\u003e int: ct, mod = Counter(nums), 10**9+7 d = defaultdict(int) d[1] = (1 \u003c\u003c ct[1]) % mod for num in [2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30]: for x in list(d): if math.gcd(num, x) == 1: d[num*x] += ct[num]*d[x] d[num*x] %= m","date":"2021-09-04","objectID":"/leetcode/1994/:3:0","tags":null,"title":"1994：好子集的数目（★★★）","uri":"/leetcode/1994/"},{"categories":null,"content":" 力扣第 60 场双周赛第 3 题 ","date":"2021-09-04","objectID":"/leetcode/1993/:0:0","tags":null,"title":"1993：树上的操作（★★）","uri":"/leetcode/1993/"},{"categories":null,"content":"题目 给你一棵 n 个节点的树，编号从 0 到 n - 1 ，以父节点数组 parent 的形式给出，其中 parent[i] 是第 i 个节点的父节点。树的根节点为 0 号节点，所以 parent[0] = -1 ，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。 数据结构需要支持如下函数： Lock：指定用户给指定节点 上锁 ，上锁后其他用户将无法给同一节点上锁。只有当节点处于未上锁的状态下，才能进行上锁操作。\rUnlock：指定用户给指定节点 解锁 ，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。\rUpgrade：指定用户给指定节点 上锁 ，并","date":"2021-09-04","objectID":"/leetcode/1993/:1:0","tags":null,"title":"1993：树上的操作（★★）","uri":"/leetcode/1993/"},{"categories":null,"content":"分析 用 state 数组保存每个节点的 \u003c是否上锁,上锁的用户 id\u003e，然后模拟即可。 upgrade 时向上 dfs 确定没有上锁的祖先节点，然后向下 dfs 找所有上锁的子孙节点， 如果非空即代表符合条件，将它们解锁。 ","date":"2021-09-04","objectID":"/leetcode/1993/:2:0","tags":null,"title":"1993：树上的操作（★★）","uri":"/leetcode/1993/"},{"categories":null,"content":"解答 class LockingTree: def __init__(self, parent: List[int]): self.parent = parent self.nxt = defaultdict(list) for v, u in enumerate(parent): self.nxt[u].append(v) self.state = [(0, 0)] * len(parent) def lock(self, num: int, user: int) -\u003e bool: if self.state[num][0]: return False self.state[num] = (","date":"2021-09-04","objectID":"/leetcode/1993/:3:0","tags":null,"title":"1993：树上的操作（★★）","uri":"/leetcode/1993/"},{"categories":null,"content":" 力扣第 60 场双周赛第 2 题 ","date":"2021-09-04","objectID":"/leetcode/1992/:0:0","tags":null,"title":"1992：找到所有的农场组（★）","uri":"/leetcode/1992/"},{"categories":null,"content":"题目 给你一个下标从 0 开始，大小为 m x n 的二进制矩阵 land ，其中 0 表示一单位的森林土地，1 表示一单位的农场土地。 为了让农场保持有序，农场土地之间以矩形的 农场组 的形式存在。每一个农场组都 仅 包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 不会 与另一个农场组的任何一块土地在四个方向上相邻。 land 可以用坐标系统表示，其中 land 左上角坐标为 (0, 0) ，右下角坐标为 (m-1, n-1) 。请你找到所有 农场组 最左上角和最右下角的坐标。一个左上角坐标为 (r1, c1) 且右下角坐标为 (r2, c2) 的 农场组","date":"2021-09-04","objectID":"/leetcode/1992/:1:0","tags":null,"title":"1992：找到所有的农场组（★）","uri":"/leetcode/1992/"},{"categories":null,"content":"分析 先遍历找到所有农场的左上角（上和左都是 0 的土地位置），然后每个农场遍历找到右下角即可。 ","date":"2021-09-04","objectID":"/leetcode/1992/:2:0","tags":null,"title":"1992：找到所有的农场组（★）","uri":"/leetcode/1992/"},{"categories":null,"content":"解答 def findFarmland(self, land: List[List[int]]) -\u003e List[List[int]]: tmp, m, n = [], len(land), len(land[0]) for i, j in product(range(m), range(n)): if land[i][j] == 1 and (not i or land[i-1][j]==0) and (not j or land[i][j-1]==0): tmp.append([i, j]) res = [] for r1, c1 in tmp: r2, c2 = r1, c1 while","date":"2021-09-04","objectID":"/leetcode/1992/:3:0","tags":null,"title":"1992：找到所有的农场组（★）","uri":"/leetcode/1992/"},{"categories":null,"content":" 力扣第 60 场双周赛第 1 题 ","date":"2021-09-04","objectID":"/leetcode/1991/:0:0","tags":null,"title":"1991：找到数组的中间位置","uri":"/leetcode/1991/"},{"categories":null,"content":"题目 给你一个下标从 0 开始的整数数组 nums ，请你找到 最左边 的中间位置 middleIndex （也就是所有可能中间位置下标最小的一个）。 中间位置 middleIndex 是满足 nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1] 的数组下标。 如果 middleIndex == 0 ，左边部分的和定义为 0 。类似的，如果 middleIndex == nums.length - 1 ，右边部分","date":"2021-09-04","objectID":"/leetcode/1991/:1:0","tags":null,"title":"1991：找到数组的中间位置","uri":"/leetcode/1991/"},{"categories":null,"content":"分析 遍历找到第一个满足 sum(nums[:i])*2+nums[i] == sum(nums) 的 i 即可。 ","date":"2021-09-04","objectID":"/leetcode/1991/:2:0","tags":null,"title":"1991：找到数组的中间位置","uri":"/leetcode/1991/"},{"categories":null,"content":"解答 def findMiddleIndex(self, nums: List[int]) -\u003e int: s, cur = sum(nums), 0 for i, num in enumerate(nums): if cur == s-num-cur: return i cur += num return -1 40 ms ","date":"2021-09-04","objectID":"/leetcode/1991/:3:0","tags":null,"title":"1991：找到数组的中间位置","uri":"/leetcode/1991/"},{"categories":null,"content":" 力扣第 255 场周赛第 1 题 ","date":"2021-08-22","objectID":"/leetcode/1979/:0:0","tags":null,"title":"1979：找出数组的最大公约数","uri":"/leetcode/1979/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，返回数组中最大数和最小数的 最大公约数 。 两个数的 最大公约数 是能够被两个数整除的最大正整数。 示例 1： 输入：nums = [2,5,6,9,10]\r输出：2\r解释：\rnums 中最小的数是 2\rnums 中最大的数是 10\r2 和 10 的最大公约数是 2\r示例 2： 输入：nums = [7,5,6,8,3]\r输出：1\r解释：\rnums 中最小的数是 3\rnums 中最大的数是 8\r3 和 8 的最大公约数是 1\r示例 3： 输入：nums = [3,3]\r输出：3\r解释：\rnums 中最小的数是 3\rnums 中最大的数是 3\r3 和 3 的最","date":"2021-08-22","objectID":"/leetcode/1979/:1:0","tags":null,"title":"1979：找出数组的最大公约数","uri":"/leetcode/1979/"},{"categories":null,"content":"分析 模拟即可 ","date":"2021-08-22","objectID":"/leetcode/1979/:2:0","tags":null,"title":"1979：找出数组的最大公约数","uri":"/leetcode/1979/"},{"categories":null,"content":"解答 def findGCD(self, nums: List[int]) -\u003e int: return gcd(max(nums), min(nums)) 40 ms ","date":"2021-08-22","objectID":"/leetcode/1979/:3:0","tags":null,"title":"1979：找出数组的最大公约数","uri":"/leetcode/1979/"},{"categories":null,"content":" 力扣第 59 场双周赛第 3 题 ","date":"2021-08-21","objectID":"/leetcode/1976/:0:0","tags":null,"title":"1976：到达目的地的方案数（★★）","uri":"/leetcode/1976/"},{"categories":null,"content":"题目 你在一个城市里，城市由 n 个路口组成，路口编号为 0 到 n - 1 ，某些路口之间有 双向 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。 给你一个整数 n 和二维整数数组 roads ，其中 roads[i] = [ui, vi, timei] 表示在路口 ui 和 vi 之间有一条需要花费 timei 时间才能通过的道路。你想知道花费 最少时间 从路口 0 出发到达路口 n - 1 的方案数。 请返回花费 最少时间 到达目的地的 路径数目 。由于答案可能很大，将结果对 109 + 7 取余 后返回。 示例 1： 输入：n = 7, roads","date":"2021-08-21","objectID":"/leetcode/1976/:1:0","tags":null,"title":"1976：到达目的地的方案数（★★）","uri":"/leetcode/1976/"},{"categories":null,"content":"分析 可以先用 dijkstra 求出所有节点到 n-1 的最短时间 dis。 然后假如节点 u 和 v 相邻，权重 w，且 dis[u]-w=dis[v]，连一条有向边 \u003cu, v\u003e， 问题转为求新的有向无环图中 0 到 n-1 的路径。显然可以动态规划递推。 注意到 dijkstra 出堆节点的顺序和动态规划中递推的顺序其实是一致的，因此可以同时进行。 ","date":"2021-08-21","objectID":"/leetcode/1976/:2:0","tags":null,"title":"1976：到达目的地的方案数（★★）","uri":"/leetcode/1976/"},{"categories":null,"content":"解答 def countPaths(self, n: int, roads: List[List[int]]) -\u003e int: nxt = defaultdict(list) for u, v, w in roads: nxt[u].append((v, w)) nxt[v].append((u, w)) dp, mod = Counter({n-1: 1}), 10**9+7 d, pq = {}, [(0, n-1)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, w2 in nxt[u]: if v no","date":"2021-08-21","objectID":"/leetcode/1976/:3:0","tags":null,"title":"1976：到达目的地的方案数（★★）","uri":"/leetcode/1976/"},{"categories":null,"content":" 力扣第 252 场周赛第 3 题 ","date":"2021-08-01","objectID":"/leetcode/1954/:0:0","tags":null,"title":"1954：收集足够苹果的最小花园周长（★）","uri":"/leetcode/1954/"},{"categories":null,"content":"题目 给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 |i| + |j| 个苹果。 你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。 给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。 |x| 的值定义为： 如果 x \u003e= 0 ，那么值为 x 如果 x \u003c 0 ，那么值为 -x 示例 1： 输入：neededApples = 1 输出：8 解释：边长长度为 1 的正方形不包含任何苹果。 但是边长为 2 ","date":"2021-08-01","objectID":"/leetcode/1954/:1:0","tags":null,"title":"1954：收集足够苹果的最小花园周长（★）","uri":"/leetcode/1954/"},{"categories":null,"content":"分析 假设右上角坐标为 (n,n)，可以分别计算横纵坐标之和： 每一行的横坐标都是从 -n 到 n，和为 n(n+1) 共 2n+1 行，故所有横坐标之和为 n(n+1)(2n+1) 纵坐标同理 然后求最小的 n 使得 $2n(n+1)(2n+1)\u003c=neededApples$，即是典型的二分查找。 最后 8n 即是最小周长。 ","date":"2021-08-01","objectID":"/leetcode/1954/:2:0","tags":null,"title":"1954：收集足够苹果的最小花园周长（★）","uri":"/leetcode/1954/"},{"categories":null,"content":"解答 def minimumPerimeter(self, neededApples: int) -\u003e int: self.__class__.__getitem__ = lambda self,x:2*x*(x+1)*(2*x+1)\u003e=neededApples return 8*bisect_left(self, True, 0, neededApples) 52 ms ","date":"2021-08-01","objectID":"/leetcode/1954/:3:0","tags":null,"title":"1954：收集足够苹果的最小花园周长（★）","uri":"/leetcode/1954/"},{"categories":null,"content":"线段树（Segment Tree）是一种二叉树形数据结构。多用于区间查询。 相比于 前缀和 和 树状数组， 线段树更复杂，也更通用。 线段树可以区间修改、区间查询。而且线段树不仅能维护区间的和，还可以维护区间的 最小值、最大值、总和、最大公约数、最小公倍数等。 详解 ","date":"2021-07-21","objectID":"/algorithm-segment_tree/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（六）：线段树","uri":"/algorithm-segment_tree/"},{"categories":null,"content":"1 基础 0307 区域和检索 - 数组可修改 ","date":"2021-07-21","objectID":"/algorithm-segment_tree/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（六）：线段树","uri":"/algorithm-segment_tree/"},{"categories":null,"content":"2 进阶 ","date":"2021-07-21","objectID":"/algorithm-segment_tree/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（六）：线段树","uri":"/algorithm-segment_tree/"},{"categories":null,"content":"3 挑战 ","date":"2021-07-21","objectID":"/algorithm-segment_tree/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（六）：线段树","uri":"/algorithm-segment_tree/"},{"categories":null,"content":" 力扣第 250 场周赛第 4 题 ","date":"2021-07-18","objectID":"/leetcode/1938/:0:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"题目 给你一棵 n 个节点的有根树，节点编号从 0 到 n - 1 。每个节点的编号表示这个节点的 独一无二的基因值 （也就是说节点 x 的基因值为 x）。两个基因值的 基因差 是两者的 异或和 。给你整数数组 parents ，其中 parents[i] 是节点 i 的父节点。如果节点 x 是树的 根 ，那么 parents[x] == -1 。 给你查询数组 queries ，其中 queries[i] = [nodei, vali] 。对于查询 i ，请你找到 vali 和 pi 的 最大基因差 ，其中 pi 是节点 nodei 到根之间的任意节点（包含 nodei 和根节点）。更正式的","date":"2021-07-18","objectID":"/leetcode/1938/:1:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"分析 类似 1707，只不过限制条件从数组上界变为了树的路径。 考虑遍历树的节点 node 时动态维护哈希表或字典树，即可回答 node 对应的查询。 注意动态维护过程中不仅有添加，还有删除，因此需要维护前缀的计数。 这里用更简单的哈希表方法。 ","date":"2021-07-18","objectID":"/leetcode/1938/:2:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"解答 def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -\u003e List[int]: def find(x): ans = 0 for j in range(17, -1, -1): ans \u003c\u003c= 1 ans += 1 if A[j][(ans+1)^(x\u003e\u003ej)] else 0 return ans def dfs(u): for v in nxt[u]: for j in range(18): A[j][v \u003e\u003e j] += 1 for i, val in qr[v]: res[i] =","date":"2021-07-18","objectID":"/leetcode/1938/:3:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"*附加 字典树写法。 def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -\u003e List[int]: def find(x): ans, p = '', trie for bit in bin(x)[2:].zfill(18): bit_rev = str(int(bit)^1) ans += '1' if p[bit_rev].get('cnt') else '0' p = p[bit_rev] if p[bit_rev].get('cnt') else p[bit] return int(","date":"2021-07-18","objectID":"/leetcode/1938/:4:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"树状数组或二叉索引树（Binary Indexed Tree），又以其发明者命名为 Fenwick 树。 是一种解决动态数组区间查询问题的算法。 最简单的树状数组支持两种操作，都能在 O(logN) 时间完成： 单点修改：更改数组中一个元素的值 区间查询：查询一个区间内所有元素的和 详解 如果是区间修改，则考虑更通用的 线段树 方法。 ","date":"2021-07-11","objectID":"/algorithm-binary_indexed_tree/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（五）：树状数组","uri":"/algorithm-binary_indexed_tree/"},{"categories":null,"content":"1 基础 0307 区域和检索 - 数组可修改 ","date":"2021-07-11","objectID":"/algorithm-binary_indexed_tree/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（五）：树状数组","uri":"/algorithm-binary_indexed_tree/"},{"categories":null,"content":"2 进阶 0308 二维区域和检索 - 可变 ","date":"2021-07-11","objectID":"/algorithm-binary_indexed_tree/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（五）：树状数组","uri":"/algorithm-binary_indexed_tree/"},{"categories":null,"content":"3 挑战 ","date":"2021-07-11","objectID":"/algorithm-binary_indexed_tree/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（五）：树状数组","uri":"/algorithm-binary_indexed_tree/"},{"categories":null,"content":" 力扣第 248 场周赛第 4 题 ","date":"2021-07-04","objectID":"/leetcode/1923/:0:0","tags":null,"title":"1923：最长公共子路径（★★★★）","uri":"/leetcode/1923/"},{"categories":null,"content":"题目 一个国家由 n 个编号为 0 到 n - 1 的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。 总共有 m 个编号为 0 到 m - 1 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。 给你一个整数 n 和二维数组 paths ，其中 paths[i] 是一个整数数组，表示第 i 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。 一个 子路径 指","date":"2021-07-04","objectID":"/leetcode/1923/:1:0","tags":null,"title":"1923：最长公共子路径（★★★★）","uri":"/leetcode/1923/"},{"categories":null,"content":"分析 类似 0718，只不过从两个数组变成了多个数组。 元素种类最多 10^5，用到的窗口种类最多 10^6 级别，因此考虑 base 取 10^5+3，mod 取 10^12+39 ","date":"2021-07-04","objectID":"/leetcode/1923/:2:0","tags":null,"title":"1923：最长公共子路径（★★★★）","uri":"/leetcode/1923/"},{"categories":null,"content":"解答 def longestCommonSubpath(self, n: int, paths: List[List[int]]) -\u003e int: def gen(A, L): ans, w, bL = set(), 0, pow(base, L, mod) for j, a in enumerate(A): w = w*base+a if j\u003e=L: w -= A[j-L]*bL w %= mod if j\u003e=L-1: ans.add(w) return ans base, mod = 10**5+3, 10**12+39 self.__class__.__getitem__ = lambd","date":"2021-07-04","objectID":"/leetcode/1923/:3:0","tags":null,"title":"1923：最长公共子路径（★★★★）","uri":"/leetcode/1923/"},{"categories":null,"content":"*附加 也可以类似 0718，使用 后缀数组 判断是否存在长为 L 的公共路径 def longestCommonSubpath(self, n: int, paths: List[List[int]]) -\u003e int: def SA_IS(A): def equal(pos1, pos2): end1, end2 = LMS.find('*', pos1+1), LMS.find('*', pos2+1) return A[pos1:end1+1] == A[pos2:end2+1] def IS(stars): sa = [n] + [-1] * n tails = list(accumu","date":"2021-07-04","objectID":"/leetcode/1923/:4:0","tags":null,"title":"1923：最长公共子路径（★★★★）","uri":"/leetcode/1923/"},{"categories":null,"content":"字典树，又叫前缀树，是一种 N 叉树，用于高效地存储、查找字符串前缀。 python 中可以用 defaultdict 来实现。 ","date":"2021-07-01","objectID":"/algorithm-trie/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（四）：字典树","uri":"/algorithm-trie/"},{"categories":null,"content":"1 基础 0208 实现 Trie (前缀树) 0648 单词替换 ","date":"2021-07-01","objectID":"/algorithm-trie/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（四）：字典树","uri":"/algorithm-trie/"},{"categories":null,"content":"2 进阶 0211 添加与搜索单词 - 数据结构设计 0677 键值映射 ","date":"2021-07-01","objectID":"/algorithm-trie/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（四）：字典树","uri":"/algorithm-trie/"},{"categories":null,"content":"3 挑战 0212 单词搜索 II 0421 数组中两个数的最大异或值 1707 与数组中元素的最大异或值 1938 查询最大基因差 ","date":"2021-07-01","objectID":"/algorithm-trie/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（四）：字典树","uri":"/algorithm-trie/"},{"categories":null,"content":" 力扣第 247 场周赛第 4 题 ","date":"2021-06-27","objectID":"/leetcode/1916/:0:0","tags":null,"title":"1916：统计为蚁群构筑房间的不同顺序（★★★）","uri":"/leetcode/1916/"},{"categories":null,"content":"题目 你是一只蚂蚁，负责为蚁群构筑 n 间编号从 0 到 n-1 的新房间。给你一个 下标从 0 开始 且长度为 n 的整数数组 prevRoom 作为扩建计划。其中，prevRoom[i] 表示在构筑房间 i 之前，你必须先构筑房间 prevRoom[i] ，并且这两个房间必须 直接 相连。房间 0 已经构筑完成，所以 prevRoom[0] = -1 。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 0 可以访问到每个房间。 你一次只能构筑 一个 房间。你可以在 已经构筑好的 房间之间自由穿行，只要这些房间是 相连的 。如果房间 prevRoom[i] 已经构筑完成，那么你就","date":"2021-06-27","objectID":"/leetcode/1916/:1:0","tags":null,"title":"1916：统计为蚁群构筑房间的不同顺序（★★★）","uri":"/leetcode/1916/"},{"categories":null,"content":"分析 将 \u003cprevRoom[i],i\u003e 看作一条边，显然构成一棵根节点 0 的树。那么可以考虑递归。 令 dfs(u) 代表以 u 为根的树的方案数，那么除了子树自身的方案数的乘积以外，还要考虑子树之间的先后顺序。 假设子树 v1、v2、… 的节点数分别为 s1、s2、…，子树之间的先后顺序相当于求 s1 个 1、s2 个 2、… 的排列数， 根据排列组合的知识即可求解。 注意本题数很大，必须边乘除边求模，因此要用到乘法逆元 ","date":"2021-06-27","objectID":"/leetcode/1916/:2:0","tags":null,"title":"1916：统计为蚁群构筑房间的不同顺序（★★★）","uri":"/leetcode/1916/"},{"categories":null,"content":"解答 def waysToBuildRooms(self, prevRoom: List[int]) -\u003e int: def dfs(u): res, s = 1, 0 for v in nxt[u]: a, b = dfs(v) s += b res = res*a*inv[b]%mod return res*fac[s]%mod, s+1 n = len(prevRoom) nxt = defaultdict(list) for v, u in enumerate(prevRoom): nxt[u].append(v) fac, inv, mod = [1]*n, [1]*n, 10**9","date":"2021-06-27","objectID":"/leetcode/1916/:3:0","tags":null,"title":"1916：统计为蚁群构筑房间的不同顺序（★★★）","uri":"/leetcode/1916/"},{"categories":null,"content":"并查集（Union Find）也叫「不相交集合（Disjoint Set）」，是一种树型的数据结构， 专门用于 动态处理 不相交集合的「查询」与「合并」问题。 查询（Find），查询图中的两个顶点是不是在同一个集合中。 注意：并查集只回答两个顶点之间是否有一条路径连接，而不回答怎么连接。 合并（Union），将两个不相交集合进行合并。 并查集常常和图相关，比如「最小生成树」算法。 能用并查集的问题一般都可以用 bfs/dfs，但是并查集更简洁直观，而且一般更节省时间。 ","date":"2021-06-21","objectID":"/algorithm-union_find/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（三）：并查集","uri":"/algorithm-union_find/"},{"categories":null,"content":"1 基础 0200 岛屿数量 0547 省份数量 0684 冗余连接 0839 相似字符串组 0990 等式方程的可满足性 ","date":"2021-06-21","objectID":"/algorithm-union_find/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（三）：并查集","uri":"/algorithm-union_find/"},{"categories":null,"content":"2 进阶 0130 被围绕的区域 0695 岛屿的最大面积 0721 账户合并 0959 由斜杠划分区域 ","date":"2021-06-21","objectID":"/algorithm-union_find/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（三）：并查集","uri":"/algorithm-union_find/"},{"categories":null,"content":"3 挑战 0399 除法求值 0407 接雨水 II 0685 冗余连接 II 0803 打砖块 ","date":"2021-06-21","objectID":"/algorithm-union_find/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（三）：并查集","uri":"/algorithm-union_find/"},{"categories":null,"content":"很多问题需要维护一个有序的集合，根据操作不同，可以选择更优的数据结构。 访问 搜索 插入 删除 访问最值 插入最值 删除最值 数组 list O(1) O(logN) O(N) O(N) O(1) O(1) O(1) 队列 deque O(N) O(N) O(N) O(N) O(1) O(1) O(1) 堆 heapq O(N) O(N) O(logN) O(N) O(1) O(logN) O(logN) AVL/红黑树 O(logN) O(logN) O(logN) O(logN) O(logN) O(logN) O(logN) 若只需搜索操作，用 数组 即可。 若只需最值相关的操作，用 栈","date":"2021-06-11","objectID":"/algorithm-ordered_set/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（二）：有序集合","uri":"/algorithm-ordered_set/"},{"categories":null,"content":"1 基础 0239 滑动窗口最大值 0295 数据流的中位数 ","date":"2021-06-11","objectID":"/algorithm-ordered_set/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（二）：有序集合","uri":"/algorithm-ordered_set/"},{"categories":null,"content":"2 进阶 0218 天际线问题 0220 存在重复元素 III ","date":"2021-06-11","objectID":"/algorithm-ordered_set/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（二）：有序集合","uri":"/algorithm-ordered_set/"},{"categories":null,"content":"3 挑战 ","date":"2021-06-11","objectID":"/algorithm-ordered_set/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（二）：有序集合","uri":"/algorithm-ordered_set/"},{"categories":null,"content":"1 基础 0496 下一个更大元素 I 0739 每日温度 0901 股票价格跨度 ","date":"2021-06-01","objectID":"/algorithm-monotonic_stack/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（一）：单调栈和单调队列","uri":"/algorithm-monotonic_stack/"},{"categories":null,"content":"2 进阶 0084 柱状图中最大的矩形 0085 最大矩形 0907 子数组的最小值之和 ","date":"2021-06-01","objectID":"/algorithm-monotonic_stack/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（一）：单调栈和单调队列","uri":"/algorithm-monotonic_stack/"},{"categories":null,"content":"3 挑战 0456 132 模式 0962 最大宽度坡 0975 奇偶跳 1124 表现良好的最长时间段 1130 叶值的最小代价生成树 ","date":"2021-06-01","objectID":"/algorithm-monotonic_stack/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（一）：单调栈和单调队列","uri":"/algorithm-monotonic_stack/"},{"categories":null,"content":"*4 单调队列 0239 滑动窗口最大值 0862 和至少为 K 的最短子数组 0918 环形子数组的最大和 1425 带限制的子序列和 1438 绝对差不超过限制的最长连续子数组 1499 满足不等式的最大值 1696 跳跃游戏 VI ","date":"2021-06-01","objectID":"/algorithm-monotonic_stack/:4:0","tags":["算法"],"title":"力扣总结 数据结构进阶（一）：单调栈和单调队列","uri":"/algorithm-monotonic_stack/"},{"categories":null,"content":" 力扣第 240 场周赛第 4 题 ","date":"2021-05-09","objectID":"/leetcode/1857/:0:0","tags":null,"title":"1857：有向图中最大颜色值（★★★）","uri":"/leetcode/1857/"},{"categories":null,"content":"题目 给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。 给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边 。 图中一条有效 路径 是一个点序列 x1 -\u003e x2 -\u003e x3 -\u003e ... -\u003e xk ，对于所有 1 \u003c= i \u003c k ，从 xi 到 xi+1 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。 请你返回给定图中","date":"2021-05-09","objectID":"/leetcode/1857/:1:0","tags":null,"title":"1857：有向图中最大颜色值（★★★）","uri":"/leetcode/1857/"},{"categories":null,"content":"分析 要判断环，容易想到用拓扑排序。 若没有环，那么对于有向无环图，可以考虑用递归： 问题中要求路径中的最大颜色值，不好直接递归。容易递归的是每种颜色的最大值。 假设路径中的最大颜色值是 cnt，对应的颜色为 x，那么显然颜色 x 的最大值就是 cnt，其它颜色的最大值 \u003c= cnt。 因此 max(每种颜色的最大值) 即为所求。 注意到拓扑排序出队的顺序和递推的顺序其实是一致的，因此可以同时进行。 ","date":"2021-05-09","objectID":"/leetcode/1857/:2:0","tags":null,"title":"1857：有向图中最大颜色值（★★★）","uri":"/leetcode/1857/"},{"categories":null,"content":"解答 def largestPathValue(self, colors: str, edges: List[List[int]]) -\u003e int: n = len(colors) nxt, indeg = defaultdict(list), [0]*n for u, v in edges: nxt[u].append(v) indeg[v] += 1 res, dp = 0, [defaultdict(int) for _ in range(n)] queue = deque(u for u in range(n) if indeg[u]==0) while queue: u = queu","date":"2021-05-09","objectID":"/leetcode/1857/:3:0","tags":null,"title":"1857：有向图中最大颜色值（★★★）","uri":"/leetcode/1857/"},{"categories":null,"content":" 力扣第 239 场周赛第 4 题 ","date":"2021-05-02","objectID":"/leetcode/1851/:0:0","tags":null,"title":"1851：包含每个查询的最小区间（★★★）","uri":"/leetcode/1851/"},{"categories":null,"content":"题目 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。 再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti \u003c= queries[j] \u003c= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。 以数组形式返回对应查询的所有答案。 示例 1： 输入：intervals = [[1,4],[","date":"2021-05-02","objectID":"/leetcode/1851/:1:0","tags":null,"title":"1851：包含每个查询的最小区间（★★★）","uri":"/leetcode/1851/"},{"categories":null,"content":"分析 有点类似 0218，不过查询的不一定是边界，可能在区间中间。 考虑将查询也添加到边缘坐标中，然后遍历所有边缘坐标，维护区间长度集合 H，min(H) 即为查询答案。 注意到查询是满足闭区间即可，因此遍历到边缘坐标 x 时，要先将以 x 开始的区间添加到 H 中， 然后完成查询操作，最后将以 x 结束的区间移出 H。可以通过标记排序来实现。 ","date":"2021-05-02","objectID":"/leetcode/1851/:2:0","tags":null,"title":"1851：包含每个查询的最小区间（★★★）","uri":"/leetcode/1851/"},{"categories":null,"content":"解答 def minInterval(self, intervals: List[List[int]], queries: List[int]) -\u003e List[int]: from sortedcontainers import SortedList d = defaultdict(list) for a, b in intervals: h = b-a+1 d[a].append((0, h)) d[b].append((2, h)) for idx, q in enumerate(queries): d[q].append((1, idx)) res, H = [-1] * len(qu","date":"2021-05-02","objectID":"/leetcode/1851/:3:0","tags":null,"title":"1851：包含每个查询的最小区间（★★★）","uri":"/leetcode/1851/"},{"categories":null,"content":" 力扣第 51 场双周赛第 2 题 ","date":"2021-05-01","objectID":"/leetcode/1845/:0:0","tags":null,"title":"1845：座位预约管理系统（★）","uri":"/leetcode/1845/"},{"categories":null,"content":"题目 请你设计一个管理 n 个座位预约的系统，座位编号从 1 到 n 。 请你实现 SeatManager 类： SeatManager(int n) 初始化一个 SeatManager 对象，它管理从 1 到 n 编号的 n 个座位。所有座位初始都是可预约的。\rint reserve() 返回可以预约座位的 最小编号 ，此座位变为不可预约。\rvoid unreserve(int seatNumber) 将给定编号 seatNumber 对应的座位变成可以预约。\r示例 1： 输入：\r[\"SeatManager\", \"reserve\", \"reserve\", \"unreserve\", \"rese","date":"2021-05-01","objectID":"/leetcode/1845/:1:0","tags":null,"title":"1845：座位预约管理系统（★）","uri":"/leetcode/1845/"},{"categories":null,"content":"分析 典型的堆应用。 ","date":"2021-05-01","objectID":"/leetcode/1845/:2:0","tags":null,"title":"1845：座位预约管理系统（★）","uri":"/leetcode/1845/"},{"categories":null,"content":"解答 class SeatManager: def __init__(self, n: int): self.pq = list(range(1, n+1)) def reserve(self) -\u003e int: return heappop(self.pq) def unreserve(self, seatNumber: int) -\u003e None: heappush(self.pq, seatNumber) 584 ms ","date":"2021-05-01","objectID":"/leetcode/1845/:3:0","tags":null,"title":"1845：座位预约管理系统（★）","uri":"/leetcode/1845/"},{"categories":null,"content":" 力扣第 237 场周赛第 3 题 ","date":"2021-04-18","objectID":"/leetcode/1834/:0:0","tags":null,"title":"1834：单线程 CPU（★）","uri":"/leetcode/1834/"},{"categories":null,"content":"题目 给你一个二维数组 tasks ，用于表示 n​​​​​​ 项从 0 到 n - 1 编号的任务。其中 tasks[i] = [enqueueTimei, processingTimei] 意味着第 i​​​​​​​​​​ 项任务将会于 enqueueTimei 时进入任务队列，需要 processingTimei 的时长完成执行。 现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行： 如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。\r如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 执行时间最短","date":"2021-04-18","objectID":"/leetcode/1834/:1:0","tags":null,"title":"1834：单线程 CPU（★）","uri":"/leetcode/1834/"},{"categories":null,"content":"分析 模拟过程，可以用堆 pq 维护任务队列。为了保持堆顶为最优先的下一个任务，应该按 (执行时间, 下标) 入堆。 另外，可以维护还没进入任务队列的任务列表 remain，便于添加新任务。按 (开始时间, 执行时间, 下标) 排序即可。 从时间 t=1 或 remain[0][0] 开始，每轮将开始时间小于等于当前时间 t 的任务从 remain 弹出并入堆 pq。 然后弹出 pq[0]（若 pq 为空，就弹出 remain[0]） 作为要执行的任务，并更新当前时间 t 为该任务的结束时间。 重复 n 轮即可。 ","date":"2021-04-18","objectID":"/leetcode/1834/:2:0","tags":null,"title":"1834：单线程 CPU（★）","uri":"/leetcode/1834/"},{"categories":null,"content":"解答 def getOrder(self, tasks: List[List[int]]) -\u003e List[int]: n, remain = len(tasks), deque(sorted((e, p, i) for i, (e, p) in enumerate(tasks))) res, pq, t = [], [], remain[0][0] for _ in range(n): while remain and remain[0][0] \u003c= t: _, p, i = remain.popleft() heappush(pq, (p, i)) if pq: p, i = heappo","date":"2021-04-18","objectID":"/leetcode/1834/:3:0","tags":null,"title":"1834：单线程 CPU（★）","uri":"/leetcode/1834/"},{"categories":null,"content":" 力扣第 236 场周赛第 4 题 ","date":"2021-04-11","objectID":"/leetcode/1825/:0:0","tags":null,"title":"1825：求出 MK 平均值（★★★）","uri":"/leetcode/1825/"},{"categories":null,"content":"题目 给你两个整数 m 和 k ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 MK 平均值 。 MK 平均值 按照如下步骤计算： 如果数据流中的整数少于 m 个，MK 平均值 为 -1 ，否则将数据流中最后 m 个元素拷贝到一个独立的容器中。\r从这个容器中删除最小的 k 个数和最大的 k 个数。\r计算剩余元素的平均值，并 向下取整到最近的整数 。\r请你实现 MKAverage 类： MKAverage(int m, int k) 用一个空的数据流和两个整数 m 和 k 初始化 MKAverage 对象。\rvoid addElement(int num) 往数据流中插入一","date":"2021-04-11","objectID":"/leetcode/1825/:1:0","tags":null,"title":"1825：求出 MK 平均值（★★★）","uri":"/leetcode/1825/"},{"categories":null,"content":"分析 ","date":"2021-04-11","objectID":"/leetcode/1825/:2:0","tags":null,"title":"1825：求出 MK 平均值（★★★）","uri":"/leetcode/1825/"},{"categories":null,"content":"#1 考虑用数组 A 动态维护最后的 m 个元素并保持有序，MK 平均数即为 int(sum(A[k:-k])/(m-2*k))。 class MKAverage: def __init__(self, m: int, k: int): self.m = m self.k = k self.queue = deque() self.A = [] self.size = m - 2*k def addElement(self, num: int) -\u003e None: self.queue.append(num) if len(self.queue) == self.m: self.A = sort","date":"2021-04-11","objectID":"/leetcode/1825/:2:1","tags":null,"title":"1825：求出 MK 平均值（★★★）","uri":"/leetcode/1825/"},{"categories":null,"content":"#2 考虑能否动态维护 s=sum(A[k:-k])。弹出位置 i 的元素时，有： if i \u003c k A[i] 属于最小的 k 个数，弹出后 s 中的最小数 A[k] 补上， s -= A[k] elif i \u003e= len(A)-k A[i] 属于最大的 k 个数，弹出后 s 中的最大数 A[-k-1] 补上，s -= A[-k-1]\relse A[i] 属于 s， s -= A[i]\r同理，在位置 i 插入元素 num 时： if i \u003c k num 属于新的最小的 k 个数，原来的 A[k-1] 被挤出加入到 s，s += A[k-1]\relif i \u003e len(A)-k num 属于新的","date":"2021-04-11","objectID":"/leetcode/1825/:2:2","tags":null,"title":"1825：求出 MK 平均值（★★★）","uri":"/leetcode/1825/"},{"categories":null,"content":"解答 class MKAverage: def __init__(self, m: int, k: int): self.m = m self.k = k self.queue = deque() self.A = [] self.size = m - 2 * k self.s = 0 def addElement(self, num: int) -\u003e None: self.queue.append(num) if len(self.queue) == self.m: self.A = sorted(self.queue) self.s = sum(self.A[self.k:-self.k]","date":"2021-04-11","objectID":"/leetcode/1825/:3:0","tags":null,"title":"1825：求出 MK 平均值（★★★）","uri":"/leetcode/1825/"},{"categories":null,"content":"*附加 理论上来说，采用平衡有序二叉树来维护 A，能在 log N 时间内查找、插入、删除元素，可以降低时间复杂度。 但是 python 的列表操作非常快，所以一般不用树结构。库函数 sortedcontainers.SortedList 也是用 list 实现的。 ","date":"2021-04-11","objectID":"/leetcode/1825/:4:0","tags":null,"title":"1825：求出 MK 平均值（★★★）","uri":"/leetcode/1825/"},{"categories":null,"content":" 力扣第 236 场周赛第 2 题 ","date":"2021-04-11","objectID":"/leetcode/1823/:0:0","tags":null,"title":"1823：找出游戏的获胜者（★）","uri":"/leetcode/1823/"},{"categories":null,"content":"题目 共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 \u003c= i \u003c n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。 游戏遵循如下规则： 从第 1 名小伙伴所在位置 开始 。\r沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。\r你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。\r如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续","date":"2021-04-11","objectID":"/leetcode/1823/:1:0","tags":null,"title":"1823：找出游戏的获胜者（★）","uri":"/leetcode/1823/"},{"categories":null,"content":"分析 ","date":"2021-04-11","objectID":"/leetcode/1823/:2:0","tags":null,"title":"1823：找出游戏的获胜者（★）","uri":"/leetcode/1823/"},{"categories":null,"content":"#1 经典的约瑟夫环问题。 方便起见，编号变为从 0 到 n-1，显然问题等价。 令 help(n) 代表 n 个人玩游戏的获胜者编号。第一轮后，相当于从编号 k 开始的 n-1 名小伙伴玩游戏，这是一个递归子问题。 设 help(n-1) 的获胜者编号为 x，那么 help(n) 的获胜者相当于从 k 开始的第 x 个，编号即为 (k+x)%n。 最简单的子问题即是 n=1 时，显然获胜者编号为 0。 最终 help(n)+1 即为所求。 def findTheWinner(self, n: int, k: int) -\u003e int: def help(n): return 0 if n==1","date":"2021-04-11","objectID":"/leetcode/1823/:2:1","tags":null,"title":"1823：找出游戏的获胜者（★）","uri":"/leetcode/1823/"},{"categories":null,"content":"#2 可以改写成递推的形式。 ","date":"2021-04-11","objectID":"/leetcode/1823/:2:2","tags":null,"title":"1823：找出游戏的获胜者（★）","uri":"/leetcode/1823/"},{"categories":null,"content":"解答 def findTheWinner(self, n: int, k: int) -\u003e int: return reduce(lambda x, y: (x+k)%y, range(2, n+1), 0) + 1 32 ms ","date":"2021-04-11","objectID":"/leetcode/1823/:3:0","tags":null,"title":"1823：找出游戏的获胜者（★）","uri":"/leetcode/1823/"},{"categories":null,"content":"一些问题涉及到数学的几何知识，包括斜率、面积、凸包等。 相关的算法有 扫描线算法 等。 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:0:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":"1 基础 0223 矩形面积 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:1:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":"2 进阶 0149 直线上最多的点数 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:2:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":"3 挑战 0335 路径交叉 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:3:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":"*4 扫描线 0218 天际线问题 0391 完美矩形 0850 矩形面积 II 1851 包含每个查询的最小区间 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:4:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":" 力扣杯 2021 春季战队赛第 5 题 ","date":"2021-04-10","objectID":"/leetcode/lcp35/:0:0","tags":null,"title":"LCP 35：电动车游城市（★★）","uri":"/leetcode/lcp35/"},{"categories":null,"content":"题目 小明的电动车电量充满时可行驶距离为 cnt，每行驶 1 单位距离消耗 1 单位电量，且花费 1 单位时间。小明想选择电动车作为代步工具。地图上共有 N 个景点，景点编号为 0 ~ N-1。他将地图信息以 [城市 A 编号,城市 B 编号,两城市间距离] 格式整理在在二维数组 paths，表示城市 A、B 间存在双向通路。初始状态，电动车电量为 0。每个城市都设有充电桩，charge[i] 表示第 i 个城市每充 1 单位电量需要花费的单位时间。请返回小明最少需要花费多少单位时间从起点城市 start 抵达终点城市 end。 示例 1： 输入：paths = [[1,3,3],[3,2,1","date":"2021-04-10","objectID":"/leetcode/lcp35/:1:0","tags":null,"title":"LCP 35：电动车游城市（★★）","uri":"/leetcode/lcp35/"},{"categories":null,"content":"分析 将状态 (节点 u,电量 c) 看作顶点，那么对于通路 \u003cu,v,w\u003e，如果 c\u003e=w，则 (u, c) 到 (v, c-w) 连有向边，权重为 w。 额外的，(u, c) 到 (u, c+1) 连一条有向边，权重为 charge[u]。 那么问题就转为在新图中求 (start, 0) 到 (end, 0) 的最短路，可以用 dijkstra 算法。 ","date":"2021-04-10","objectID":"/leetcode/lcp35/:2:0","tags":null,"title":"LCP 35：电动车游城市（★★）","uri":"/leetcode/lcp35/"},{"categories":null,"content":"解答 def electricCarPlan(self, paths: List[List[int]], cnt: int, start: int, end: int, charge: List[int]) -\u003e int: nxt = defaultdict(list) for u, v, w in paths: nxt[u].append((v, w)) nxt[v].append((u, w)) d, pq = {}, [(0, start, 0)] while pq: w, u, c = heappop(pq) if (u, c) in d: continue if (u, c) == ","date":"2021-04-10","objectID":"/leetcode/lcp35/:3:0","tags":null,"title":"LCP 35：电动车游城市（★★）","uri":"/leetcode/lcp35/"},{"categories":null,"content":" 力扣杯 2021 春季个人赛第 5 题 ","date":"2021-04-05","objectID":"/leetcode/lcp32/:0:0","tags":null,"title":"LCP 32：批量处理任务（★★）","uri":"/leetcode/lcp32/"},{"categories":null,"content":"题目 某实验室计算机待处理任务以 [start,end,period] 格式记于二维数组 tasks，表示完成该任务的时间范围为起始时间 start 至结束时间 end 之间，需要计算机投入 period 的时长，注意： period 可为不连续时间 首尾时间均包含在内 处于开机状态的计算机可同时处理任意多个任务，请返回电脑最少开机多久，可处理完所有任务。 示例 1： 输入：tasks = [[1,3,2],[2,5,3],[5,6,2]] 输出：4 解释： tasks[0] 选择时间点 2、3； tasks[1] 选择时间点 2、3、5； tasks[2] 选择时间点 5、6； 因此计算机仅","date":"2021-04-05","objectID":"/leetcode/lcp32/:1:0","tags":null,"title":"LCP 32：批量处理任务（★★）","uri":"/leetcode/lcp32/"},{"categories":null,"content":"分析 ","date":"2021-04-05","objectID":"/leetcode/lcp32/:2:0","tags":null,"title":"LCP 32：批量处理任务（★★）","uri":"/leetcode/lcp32/"},{"categories":null,"content":"#1 为了方便，可以先将所有 end 加 1 变为左开右闭区间 [start, end)。 将 tasks 按结束时间 end 排序。直觉上，先结束的任务应该用尽可能晚的时间点，能够最大化地节省后续任务的时间。 简单证明一下： 假设最优方案的时间点集合为 T，首个任务 (s0, e0, p0) ，在最优方案中的时间点集合为 T0。 将 T0 变为最晚的区间 [e0-p0+1, e0)，任一后续任务 i 依然能完成： 若 si \u003c= s0 或者 si \u003e= e0 [si, ei] 内的时间点个数不变 若 s0 \u003c si \u003c e0 [si, ei] 内的时间点个数不变或变多 因此首个任务用尽可能晚","date":"2021-04-05","objectID":"/leetcode/lcp32/:2:1","tags":null,"title":"LCP 32：批量处理任务（★★）","uri":"/leetcode/lcp32/"},{"categories":null,"content":"#2 超时的原因是每次计算 already 都遍历 stack，最坏时间复杂度 $O(N^2)$。 要优化子数组计算，容易想到前缀和。考虑每次入栈时间区间 [xj, yj) 时，额外保存所有已确定的时间点总数 Sj。 那么计算任务的 already 时: 先二分查找找到第一个大于 start 的 yj stack[-1][2] - Sj 就是除了区间 [xj, yj) 以外任务已完成的时间点总数 区间 [xj, yj) 内任务已完成的时间点个数是 yj - max(xj, start) already = stack[-1][2] - Sj + yj - max(xj, start) 最终也无","date":"2021-04-05","objectID":"/leetcode/lcp32/:2:2","tags":null,"title":"LCP 32：批量处理任务（★★）","uri":"/leetcode/lcp32/"},{"categories":null,"content":"解答 def processTasks(self, tasks: List[List[int]]) -\u003e int: tasks.sort(key=lambda x: x[1]) self.__class__.__getitem__ = lambda self, i: stack[i][1]\u003estart stack = [] for start, end, period in tasks: end += 1 i = bisect_left(self, True, 0, len(stack)) already = 0 if i==len(stack) else stack[-1][2]-stack","date":"2021-04-05","objectID":"/leetcode/lcp32/:3:0","tags":null,"title":"LCP 32：批量处理任务（★★）","uri":"/leetcode/lcp32/"},{"categories":null,"content":"明明是熟悉的街道，这座城市却似乎有哪里变得不太一样了。\n出租车司机小户川每天平凡度日。他没有亲人，鲜少与人交流，是个有点孤僻木讷的怪人。兴趣是在睡前听落语和工作时听广播。姑且能称得上是他朋友的人，只有他的主治医生刚力，以及高中同学柿花而已。\n他载到的尽是些有点古怪的客人：一心想在网路上被疯传的大学生，桦泽；似乎有所隐情的护理师，白川；不太红的搞笑二人组，智人拍档；街头无赖，阴沟；正要开始走红的偶像女团，神秘之吻等。\n人与人之间百无聊赖的对话，最后竟与一位失踪少女扯上了关系。","date":"2021-04-05","objectID":"/anime/odd_taxi/","tags":null,"title":"奇巧计程车","uri":"/anime/odd_taxi/"},{"categories":null,"content":"简介 明明是熟悉的街道，这座城市却似乎有哪里变得不太一样了。 出租车司机小户川每天平凡度日。他没有亲人，鲜少与人交流，是个有点孤僻木讷的怪人。兴趣是在睡前听落语和工作时听广播。姑且能称得上是他朋友的人，只有他的主治医生刚力，以及高中同学柿花而已。 他载到的尽是些有点古怪的客人：一心想在网路上被疯传的大学生，桦泽；似乎有所隐情的护理师，白川；不太红的搞笑二人组，智人拍档；街头无赖，阴沟；正要开始走红的偶像女团，神秘之吻等。 人与人之间百无聊赖的对话，最后竟与一位失踪少女扯上了关系。 制作人员： 原作：P.I.C.S. 导演：木下麦 脚本：此元和津也 演出：粟井重纪、兴满录助、山井纱也香、沼山茉由","date":"2021-04-05","objectID":"/anime/odd_taxi/:1:0","tags":null,"title":"奇巧计程车","uri":"/anime/odd_taxi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小户川宏 小戸川 宏、おどかわ ひろし、Hiroshi Odokawa 男 花江夏樹 2 白川美保 しらかわ みほ、Miho Shirakawa 女 飯田里穂 3 刚力步 ごうりき、Gouriki 男 木村良平 4 柿花英二 かきはな えいじ、Eiji Kakihana 男 山口勝平 5 二阶堂瑠衣 二階堂 ルイ、にかいどう ルイ、Rui Nikaidou 女 三森すずこ 6 市村志帆 市村 しほ、いちむら しほ、Shiho Ichimura 女 小泉萌香 7 三矢雪 和田垣樱、和田垣さくら、わだがき さくら、Sakura Wadagaki 女 村上まなつ ","date":"2021-04-05","objectID":"/anime/odd_taxi/:2:0","tags":null,"title":"奇巧计程车","uri":"/anime/odd_taxi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 奇巧计程车 2021-04-05 13 bilibili ","date":"2021-04-05","objectID":"/anime/odd_taxi/:3:0","tags":null,"title":"奇巧计程车","uri":"/anime/odd_taxi/"},{"categories":null,"content":" 力扣第 235 场周赛第 4 题 ","date":"2021-04-04","objectID":"/leetcode/1819/:0:0","tags":null,"title":"1819：序列中不同最大公约数的数目（★★★）","uri":"/leetcode/1819/"},{"categories":null,"content":"题目 给你一个由正整数组成的数组 nums 。 数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。 例如，序列 [4,6,16] 的最大公约数是 2 。\r数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。 例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。\r计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。 示例 1： 输入：nums = [6,10,3]\r输出：5\r解释：上图显示了所有的非空子序列与各自的最大公约数。\r不同的最大公约数为 6 、10 、3 、2 和 1 。\r示例 2： 输","date":"2021-04-04","objectID":"/leetcode/1819/:1:0","tags":null,"title":"1819：序列中不同最大公约数的数目（★★★）","uri":"/leetcode/1819/"},{"categories":null,"content":"分析 要递推所有子序列的最大公约数时间复杂度高。注意到最大公约数不会超过 2*10^5， 因此可以反过来，判断每个数是否是某个子序列的最大公约数。 这样总时间不超过 N * 调和级数，时间复杂度 O(N*logN)。 ","date":"2021-04-04","objectID":"/leetcode/1819/:2:0","tags":null,"title":"1819：序列中不同最大公约数的数目（★★★）","uri":"/leetcode/1819/"},{"categories":null,"content":"解答 def countDifferentSubsequenceGCDs(self, nums: List[int]) -\u003e int: res, nums, Max = 0, set(nums), max(nums) for x in range(1, Max+1): g = None for y in range(x, Max+1, x): if y in nums: g = gcd(g, y) if g else y if g == x: res += 1 break return res 2656 ms ","date":"2021-04-04","objectID":"/leetcode/1819/:3:0","tags":null,"title":"1819：序列中不同最大公约数的数目（★★★）","uri":"/leetcode/1819/"},{"categories":null,"content":"一些问题涉及到数学的代数知识： 基础的四则运算、平方开根、进制转换等 排列组合、概率统计 数论知识，包括质数、同余、因式分解、乘法逆元等 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:0:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"1 运算 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:1:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"1.1 基础 0007 整数反转 0050 Pow(x, n) 0069 x 的平方根 0102 整数转罗马数字 0171 Excel 表列序号 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:1:1","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"1.2 进阶 0029 两数相除 0043 字符串相乘 0168 Excel 表列名称 0202 快乐数 0367 有效的完全平方数 0400 第 N 位数字 0829 连续整数求和 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:1:2","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"1.3 挑战 0166 分数到小数 0169 多数元素 0229 求众数 II 0273 整数转换英文表示 0343 整数拆分 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:1:3","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"2 排列组合 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:2:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"2.1 基础 0062 不同路径 0119 杨辉三角 II 0357 计算各个位数不同的数字个数 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:2:1","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"2.2 进阶 0060 排列序列 0096 不同的二叉搜索树 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:2:2","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"2.3 挑战 0902 最大为 N 的数字组合 1012 至少有 1 位重复的数字 1916 统计为蚁群构筑房间的不同顺序 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:2:3","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"3 概率统计 0382 链表随机节点 0384 打乱数组 0398 随机数索引 0470 用 Rand7() 实现 Rand10() 0478 在圆内随机生成点 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:3:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"4 数论 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:4:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"4.1 基础 0172 阶乘后的零 0231 2 的幂 0258 各位相加 0263 丑数 0914 卡牌分组 1250 检查「好数组」 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:4:1","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"4.2 进阶 0204 计数质数 0279 完全平方数 0319 灯泡开关 0365 水壶问题 0650 只有两个键的键盘 0866 回文素数 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:4:2","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"4.3 挑战 1819 序列中不同最大公约数的数目 2183 统计可以被 K 整除的下标对数目 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:4:3","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":" 力扣第 234 场周赛第 3 题 ","date":"2021-03-28","objectID":"/leetcode/1807/:0:0","tags":null,"title":"1807：替换字符串中的括号内容（★）","uri":"/leetcode/1807/"},{"categories":null,"content":"题目 给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。 比方说，字符串 \"(name)is(age)yearsold\" 中，有 两个 括号对，分别包含键 \"name\" 和 \"age\" 。\r你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。 你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要： 将 keyi 和括号用对应的值 valuei 替换。\r如果从 knowledge 中无法得知某个键对应的值，你","date":"2021-03-28","objectID":"/leetcode/1807/:1:0","tags":null,"title":"1807：替换字符串中的括号内容（★）","uri":"/leetcode/1807/"},{"categories":null,"content":"分析 将每个括号里的子串替换即可，可以用栈一趟实现。 ","date":"2021-03-28","objectID":"/leetcode/1807/:2:0","tags":null,"title":"1807：替换字符串中的括号内容（★）","uri":"/leetcode/1807/"},{"categories":null,"content":"解答 def evaluate(self, s: str, knowledge: List[List[str]]) -\u003e str: stack, d = [''], {k: v for k, v in knowledge} for char in s: if char == '(': stack.append('') elif char == ')': k = stack.pop() stack[-1] += d.get(k, '?') else: stack[-1] += char return stack[0] 216 ms ","date":"2021-03-28","objectID":"/leetcode/1807/:3:0","tags":null,"title":"1807：替换字符串中的括号内容（★）","uri":"/leetcode/1807/"},{"categories":null,"content":" 力扣第 233 场周赛第 2 题 ","date":"2021-03-21","objectID":"/leetcode/1801/:0:0","tags":null,"title":"1801：积压订单中的订单总数（★）","uri":"/leetcode/1801/"},{"categories":null,"content":"题目 给你一个二维整数数组 orders ，其中每个 orders[i] = [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。 订单类型 orderTypei 可以分为两种： 0 表示这是一批采购订单 buy\r1 表示这是一批销售订单 sell\r注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。 存在由未执行订单组成的 积压订单 。积压","date":"2021-03-21","objectID":"/leetcode/1801/:1:0","tags":null,"title":"1801：积压订单中的订单总数（★）","uri":"/leetcode/1801/"},{"categories":null,"content":"分析 用两个堆分别维护积压的采购订单和销售订单即可。注意采购订单应该用大顶堆，销售订单应该用小顶堆。 ","date":"2021-03-21","objectID":"/leetcode/1801/:2:0","tags":null,"title":"1801：积压订单中的订单总数（★）","uri":"/leetcode/1801/"},{"categories":null,"content":"解答 def getNumberOfBacklogOrders(self, orders: List[List[int]]) -\u003e int: buy, sell = [], [] for price, amount, orderType in orders: if orderType == 0: while amount and sell and sell[0][0] \u003c= price: x = min(sell[0][1], amount) sell[0][1] -= x amount -= x if sell[0][1] == 0: heappop(sell) if amount: hea","date":"2021-03-21","objectID":"/leetcode/1801/:3:0","tags":null,"title":"1801：积压订单中的订单总数（★）","uri":"/leetcode/1801/"},{"categories":null,"content":" 力扣第 232 场周赛第 3 题 ","date":"2021-03-14","objectID":"/leetcode/1792/:0:0","tags":null,"title":"1792：最大平均通过率（★★）","uri":"/leetcode/1792/"},{"categories":null,"content":"题目 一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。 给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。 一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人","date":"2021-03-14","objectID":"/leetcode/1792/:1:0","tags":null,"title":"1792：最大平均通过率（★★）","uri":"/leetcode/1792/"},{"categories":null,"content":"分析 每次分配到能提升最多通过率的班级即可。典型的堆应用。 ","date":"2021-03-14","objectID":"/leetcode/1792/:2:0","tags":null,"title":"1792：最大平均通过率（★★）","uri":"/leetcode/1792/"},{"categories":null,"content":"解答 def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -\u003e float: pq = [(p/t-(p+1)/(t+1), p, t) for p, t in classes] heapify(pq) for _ in range(extraStudents): _, p, t = heappop(pq) heappush(pq, ((p+1)/(t+1)-(p+2)/(t+2), p+1, t+1)) return sum(p/t for _, p, t in pq) / len(pq) 1980 ","date":"2021-03-14","objectID":"/leetcode/1792/:3:0","tags":null,"title":"1792：最大平均通过率（★★）","uri":"/leetcode/1792/"},{"categories":null,"content":" 力扣第 232 场周赛第 2 题 ","date":"2021-03-14","objectID":"/leetcode/1791/:0:0","tags":null,"title":"1791：找出星型图的中心节点","uri":"/leetcode/1791/"},{"categories":null,"content":"题目 有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。 给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。 示例 1： 输入：edges = [[1,2],[2,3],[4,2]]\r输出：2\r解释：如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。\r示例 2： 输入：edges = [[1,2],[5,1],[1,3],[1,4]]\r输出：1\r提","date":"2021-03-14","objectID":"/leetcode/1791/:1:0","tags":null,"title":"1791：找出星型图的中心节点","uri":"/leetcode/1791/"},{"categories":null,"content":"分析 显然任找两个边的公共点即可。 ","date":"2021-03-14","objectID":"/leetcode/1791/:2:0","tags":null,"title":"1791：找出星型图的中心节点","uri":"/leetcode/1791/"},{"categories":null,"content":"解答 def findCenter(self, edges: List[List[int]]) -\u003e int: return (set(edges[0])\u0026set(edges[1])).pop() 76 ms ","date":"2021-03-14","objectID":"/leetcode/1791/:3:0","tags":null,"title":"1791：找出星型图的中心节点","uri":"/leetcode/1791/"},{"categories":null,"content":"滚动哈希是一种针对固定长度的滑动窗口的哈希方法。 朴素的哈希需要对所有窗口单独求哈希值，时间复杂度和空间复杂度都和窗口长度相关。 用滚动哈希则可以递推求得相邻窗口的哈希值，优化为线性复杂度。 一般采用 Rabin-Karp 算法来实现滚动哈希。核心思想就是将窗口 W 看作是一个 base 进制的数： $$hash(W)=\\sum_{i=0}^{|W|-1}base^{|W|-(i+1)}*W[i]$$ base 取一个大于元素范围的数，该 base 进制的数就唯一对应一个窗口。 特别注意，当哈希值很大必须要取模时，为了尽量避免哈希冲突，base 取一个大于 元素种数 的 质数， 而mod 应该","date":"2021-03-11","objectID":"/algorithm-rolling_hash/:0:0","tags":["算法"],"title":"力扣总结 算法进阶（二）：滚动哈希","uri":"/algorithm-rolling_hash/"},{"categories":null,"content":"1 基础 0187 重复的DNA序列 ","date":"2021-03-11","objectID":"/algorithm-rolling_hash/:1:0","tags":["算法"],"title":"力扣总结 算法进阶（二）：滚动哈希","uri":"/algorithm-rolling_hash/"},{"categories":null,"content":"2 进阶 0718 最长重复子数组 1392 最长快乐前缀 ","date":"2021-03-11","objectID":"/algorithm-rolling_hash/:2:0","tags":["算法"],"title":"力扣总结 算法进阶（二）：滚动哈希","uri":"/algorithm-rolling_hash/"},{"categories":null,"content":"3 挑战 1044 最长重复子串 1316 不同的循环子字符串 1923 最长公共子路径 ","date":"2021-03-11","objectID":"/algorithm-rolling_hash/:3:0","tags":["算法"],"title":"力扣总结 算法进阶（二）：滚动哈希","uri":"/algorithm-rolling_hash/"},{"categories":null,"content":" 力扣第 231 场周赛第 3 题 ","date":"2021-03-07","objectID":"/leetcode/1786/:0:0","tags":null,"title":"1786：从第一个节点出发到最后一个节点的受限路径数（★★）","uri":"/leetcode/1786/"},{"categories":null,"content":"题目 现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [ui, vi, weighti] 表示存在一条位于节点 ui 和 vi 之间的边，这条边的权重为 weighti 。 从节点 start 出发到节点 end 的路径是一个形如 [z0, z1, z2, ..., zk] 的节点序列，满足 z0 = start 、zk = end 且在所有符合 0 \u003c= i \u003c= k-1 的节点 zi 和 zi+1 之间存在一条边。 路径的距离定义为这条路径上所有边的权重总和。用 distan","date":"2021-03-07","objectID":"/leetcode/1786/:1:0","tags":null,"title":"1786：从第一个节点出发到最后一个节点的受限路径数（★★）","uri":"/leetcode/1786/"},{"categories":null,"content":"分析 显然可以用 dijkstra 先得到所有节点到 n 的最短距离 dis。 然后假如节点 u 和 v 相邻且 dis[u]\u003edis[v]，连一条有向边 \u003cu, v\u003e，问题转为求新的有向无环图中 1 到 n 的路径。 显然可以动态规划递推。 注意到 dijkstra 出堆节点的顺序和动态规划中递推的顺序其实是一致的，因此可以同时进行。 ","date":"2021-03-07","objectID":"/leetcode/1786/:2:0","tags":null,"title":"1786：从第一个节点出发到最后一个节点的受限路径数（★★）","uri":"/leetcode/1786/"},{"categories":null,"content":"解答 def countRestrictedPaths(self, n: int, edges: List[List[int]]) -\u003e int: nxt = defaultdict(list) for u, v, w in edges: nxt[u].append((v, w)) nxt[v].append((u, w)) dp, mod = Counter({n: 1}), 10**9+7 d, pq = {}, [(0, n)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, w2 in nxt[u]: i","date":"2021-03-07","objectID":"/leetcode/1786/:3:0","tags":null,"title":"1786：从第一个节点出发到最后一个节点的受限路径数（★★）","uri":"/leetcode/1786/"},{"categories":null,"content":"前缀和是一种常用的解决区间查询问题的算法。 当数组固定时，根据前缀和即可在 O(1) 时间查询任意区间的和。 当数组动态变化时，则考虑用 树状数组、 线段树 等方法 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:0:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":"1 基础 0303 区域和检索 - 数组不可变 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:1:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":"2 进阶 0134 加油站 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:2:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":"3 挑战 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:3:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":"*4 二维前缀和 0304 二维区域和检索 - 矩阵不可变 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:4:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":" 力扣第 46 场双周赛第 2 题 ","date":"2021-02-20","objectID":"/leetcode/1764/:0:0","tags":null,"title":"1764：通过连接另一个数组的子数组得到一个数组（★）","uri":"/leetcode/1764/"},{"categories":null,"content":"题目 给你一个长度为 n 的二维整数数组 groups ，同时给你一个整数数组 nums 。 你是否可以从 nums 中选出 n 个 不相交 的子数组，使得第 i 个子数组与 groups[i] （下标从 0 开始）完全相同，且如果 i \u003e 0 ，那么第 (i-1) 个子数组在 nums 中出现的位置在第 i 个子数组前面。（也就是说，这些子数组在 nums 中出现的顺序需要与 groups 顺序相同） 如果你可以找出这样的 n 个子数组，请你返回 true ，否则返回 false 。 如果不存在下标为 k 的元素 nums[k] 属于不止一个子数组，就称这些子数组是 不相交 的。子数组指的是","date":"2021-02-20","objectID":"/leetcode/1764/:1:0","tags":null,"title":"1764：通过连接另一个数组的子数组得到一个数组（★）","uri":"/leetcode/1764/"},{"categories":null,"content":"分析 类似于判断子序列，在 nums 中依次找 groups[i] 即可。 ","date":"2021-02-20","objectID":"/leetcode/1764/:2:0","tags":null,"title":"1764：通过连接另一个数组的子数组得到一个数组（★）","uri":"/leetcode/1764/"},{"categories":null,"content":"解答 def canChoose(self, groups: List[List[int]], nums: List[int]) -\u003e bool: i, n = 0, len(nums) for g in groups: while i\u003cn and nums[i:i+len(g)] != g: i += 1 if i==n: return False i += len(g) return True 44 ms ","date":"2021-02-20","objectID":"/leetcode/1764/:3:0","tags":null,"title":"1764：通过连接另一个数组的子数组得到一个数组（★）","uri":"/leetcode/1764/"},{"categories":null,"content":"贪心算法是一种高效的搜索方法。在每一步，都选择当前最好的分支，最终即能得到最优解。 能用贪心算法解决的问题，对于贪心正确性的证明往往更加复杂。 因此很多时候需要依赖一定的直觉才能想到贪心策略，即先构造后证明。 而有些不能用贪心解决的问题，如果对用例的考虑不够周全，容易错误地采用贪心策略。 因此使用贪心一定要慎重。 ","date":"2021-02-11","objectID":"/algorithm-greedy/:0:0","tags":["算法"],"title":"力扣总结 常见算法（八）：贪心","uri":"/algorithm-greedy/"},{"categories":null,"content":"1 基础 0502 IPO 0871 最低加油次数 1642 可以到达的最远建筑 1792 最大平均通过率 ","date":"2021-02-11","objectID":"/algorithm-greedy/:1:0","tags":["算法"],"title":"力扣总结 常见算法（八）：贪心","uri":"/algorithm-greedy/"},{"categories":null,"content":"2 进阶 0402 移掉K位数字 0406 根据身高重建队列 1705 吃苹果的最大数目 ","date":"2021-02-11","objectID":"/algorithm-greedy/:2:0","tags":["算法"],"title":"力扣总结 常见算法（八）：贪心","uri":"/algorithm-greedy/"},{"categories":null,"content":"3 挑战 0316 去除重复字母 0321 拼接最大数 ","date":"2021-02-11","objectID":"/algorithm-greedy/:3:0","tags":["算法"],"title":"力扣总结 常见算法（八）：贪心","uri":"/algorithm-greedy/"},{"categories":null,"content":" 力扣第 227 场周赛第 2 题 ","date":"2021-02-07","objectID":"/leetcode/1753/:0:0","tags":null,"title":"1753：移除石子的最大得分（★）","uri":"/leetcode/1753/"},{"categories":null,"content":"题目 你正在玩一个单人游戏，面前放置着大小分别为 a​​​​​​、b 和 c​​​​​​ 的 三堆 石子。 每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。 给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。 示例 1： 输入：a = 2, b = 4, c = 6\r输出：6\r解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是：\r- 从第一和第三堆取，石子状态现在是 (1, 4, 5)\r- 从第一和第三堆取，石子状态现在是 (0, 4, 4)\r- 从第二和第三堆取，石子状态现在是 (0, 3, 3)\r- 从第","date":"2021-02-07","objectID":"/leetcode/1753/:1:0","tags":null,"title":"1753：移除石子的最大得分（★）","uri":"/leetcode/1753/"},{"categories":null,"content":"分析 容易找到规律。先排序使得 a \u003c= b \u003c= c，有两种情况： a+b \u003c= c​​​​​​ 每次都从 c 中取，能得到最大分 a+b\ra+b \u003e c 先从 a、b 中取，直到转为上一种情况，能得到最大分 (a+b+c) // 2\r","date":"2021-02-07","objectID":"/leetcode/1753/:2:0","tags":null,"title":"1753：移除石子的最大得分（★）","uri":"/leetcode/1753/"},{"categories":null,"content":"解答 def maximumScore(self, a: int, b: int, c: int) -\u003e int: a, b, c = sorted([a, b, c]) return a+b if a + b \u003c= c else (a+b+c)//2 36 ms ","date":"2021-02-07","objectID":"/leetcode/1753/:3:0","tags":null,"title":"1753：移除石子的最大得分（★）","uri":"/leetcode/1753/"},{"categories":null,"content":"居庙堂之高而忧苍生，处江湖之远而忧天下。 幼年丧父的何方知练就一身绝技，踏上了寻仇之路。从位于西北边陲十三年前全家被灭门的羊汤店，到山东临清州，又至浙江翠峰山，何方知跨越南北、抽丝剥茧，试图查到杀害父亲的幕后主使。复仇路上，何方知感觉到对手仿佛都是有情有义之辈，他们似乎在拼尽全力保护真正的主谋……","date":"2021-02-05","objectID":"/anime/zhen_dao_ge/","tags":null,"title":"枕刀歌：千里不留行","uri":"/anime/zhen_dao_ge/"},{"categories":null,"content":"简介 居庙堂之高而忧苍生，处江湖之远而忧天下。 幼年丧父的何方知练就一身绝技，踏上了寻仇之路。从位于西北边陲十三年前全家被灭门的羊汤店，到山东临清州，又至浙江翠峰山，何方知跨越南北、抽丝剥茧，试图查到杀害父亲的幕后主使。复仇路上，何方知感觉到对手仿佛都是有情有义之辈，他们似乎在拼尽全力保护真正的主谋…… 制作人员： 动画制作：广州更号三文化传播有限公司 ","date":"2021-02-05","objectID":"/anime/zhen_dao_ge/:1:0","tags":null,"title":"枕刀歌：千里不留行","uri":"/anime/zhen_dao_ge/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 枕刀歌：千里不留行 2021-02-05 12 片库网 2 枕刀歌 特别篇 2021-09-30 2 片库网 ","date":"2021-02-05","objectID":"/anime/zhen_dao_ge/:2:0","tags":null,"title":"枕刀歌：千里不留行","uri":"/anime/zhen_dao_ge/"},{"categories":null,"content":"动态规划是一种特殊的递归，适用于有重叠子问题的场景。 存在大量重叠的子问题时，普通的递归写法会重复计算这些子问题，浪费大量时间。 动态规划会保存所有子问题的结果，避免重复计算。 动态规划也有递归和非递归两种形式。递归形式的动态规划也叫记忆化递归， 非递归形式即是保存中间结果的递推。 python 在递归函数上加一个 @lru_cache(None) 的装饰器即可实现记忆化递归。 非递归形式一般初始化一个 k（动态参数个数）维的数组保存子问题的结果。 递归层数太多时容易爆栈，用非递归形式更好。 但有时所求问题只会用到稀疏的子问题，此时用递归形式更节省时间。 ","date":"2021-02-01","objectID":"/algorithm-dp/:0:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"1 单推 dp 有的问题结果完全依赖于几个初始值和递推式： 有时能用简洁的函数表达式直接表达，比如组合数 有的递推式可以用矩阵快速幂优化时间 ","date":"2021-02-01","objectID":"/algorithm-dp/:1:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"1.1 基础 0062 不同路径 0070 爬楼梯 0096 不同的二叉搜索树 0279 完全平方数 0397 整数替换 0509 斐波那契数 ","date":"2021-02-01","objectID":"/algorithm-dp/:1:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"1.2 进阶 0338 比特位计数 0343 整数拆分 0790 多米诺和托米诺平铺 ","date":"2021-02-01","objectID":"/algorithm-dp/:1:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"1.3 挑战 0552 学生出勤记录 II ","date":"2021-02-01","objectID":"/algorithm-dp/:1:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"2 线性 dp ","date":"2021-02-01","objectID":"/algorithm-dp/:2:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"2.1 基础 0091 解码方法 0322 零钱兑换 0377 组合总和 Ⅳ ","date":"2021-02-01","objectID":"/algorithm-dp/:2:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"2.2 进阶 0032 最长有效括号 0042 接雨水 0131 分割回文串 0403 青蛙过河 0639 解码方法 II 0801 使序列递增的最小交换次数 0823 带因子的二叉树 ","date":"2021-02-01","objectID":"/algorithm-dp/:2:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"2.3 挑战 0005 最长回文子串 0135 分发糖果 0264 丑数 II ","date":"2021-02-01","objectID":"/algorithm-dp/:2:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3 线性 dp 典型问题 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.1 子数组/子串 0053 最大子序和 0152 乘积最大子数组 0413 等差数列划分 0467 环绕字符串中唯一的子字符串 0689 三个无重叠子数组的最大和 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.2 子序列 0300 最长递增子序列 0354 俄罗斯套娃信封问题 0368 最大整除子集 0376 摆动序列 0673 最长递增子序列的个数 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.3 多串 dp 0044 通配符匹配 0097 交错字符串 0115 不同的子序列 0583 两个字符串的删除操作 0712 两个字符串的最小ASCII删除和 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.4 打家劫舍系列 0198 打家劫舍 0213 打家劫舍 II 0740 删除与获得点数 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:4","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.5 股票系列 0121 买卖股票的最佳时机 0122 买卖股票的最佳时机 II 0123 买卖股票的最佳时机 III 0188 买卖股票的最佳时机 IV 0309 最佳买卖股票时机含冷冻期 0714 买卖股票的最佳时机含手续费 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:5","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.6 背包 dp 0474 一和零 0518 零钱兑换 II 0638 大礼包 0691 贴纸拼词 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:6","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"4 矩阵 dp ","date":"2021-02-01","objectID":"/algorithm-dp/:4:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"4.1 基础 0063 不同路径 II 0064 最小路径和 0120 三角形最小路径和 ","date":"2021-02-01","objectID":"/algorithm-dp/:4:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"4.2 进阶 0329 矩阵中的最长递增路径 0576 出界的路径数 0688 骑士在棋盘上的概率 0764 最大加号标志 ","date":"2021-02-01","objectID":"/algorithm-dp/:4:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"4.3 挑战 0174 地下城游戏 0221 最大正方形 0741 摘樱桃 ","date":"2021-02-01","objectID":"/algorithm-dp/:4:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"5 区间 DP ","date":"2021-02-01","objectID":"/algorithm-dp/:5:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"5.1 基础 0005 最长回文子串 0516 最长回文子序列 ","date":"2021-02-01","objectID":"/algorithm-dp/:5:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"5.2 进阶 0087 扰乱字符串 0664 奇怪的打印机 ","date":"2021-02-01","objectID":"/algorithm-dp/:5:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"5.3 挑战 0312 戳气球 0375 猜数字大小 II 0546 移除盒子 0730 统计不同回文子序列 ","date":"2021-02-01","objectID":"/algorithm-dp/:5:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"6 哈希 dp 有时需要递推的不是单纯的值，而是集合/计数器 ","date":"2021-02-01","objectID":"/algorithm-dp/:6:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"6.1 基础 0416 分割等和子集 0494 目标和 ","date":"2021-02-01","objectID":"/algorithm-dp/:6:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"6.2 进阶 0241 为运算表达式设计优先级 ","date":"2021-02-01","objectID":"/algorithm-dp/:6:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"6.3 挑战 0446 等差数列划分 II - 子序列 ","date":"2021-02-01","objectID":"/algorithm-dp/:6:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"7 状压 dp 0416 分割等和子集 0473 火柴拼正方形 0526 优美的排列 0698 划分为k个相等的子集 0805 数组的均值分割 ","date":"2021-02-01","objectID":"/algorithm-dp/:7:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"8 数位 dp 0233 数字 1 的个数 0600 不含连续1的非负整数 0788 旋转数字 ","date":"2021-02-01","objectID":"/algorithm-dp/:8:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"9 图上 dp 0126 单词接龙 II ","date":"2021-02-01","objectID":"/algorithm-dp/:9:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"10 博弈 dp 0464 我能赢吗 0486 预测赢家 ","date":"2021-02-01","objectID":"/algorithm-dp/:10:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11 dp 优化 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.1 dp+上下界 0808 分汤 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.2 dp+前缀和 0629 K个逆序对数组 0813 最大平均值和的分组 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.3 dp+二分 0514 自由之路 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.4 dp+构造 0264 丑数 II 0300 最长递增子序列 0313 超级丑数 0673 最长递增子序列的个数 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:4","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.4 dp+折半搜索 0805 数组的均值分割 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:5","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"dfs（深度优先搜索算法）和 bfs（广度优先搜索算法）都是图形搜索方法， 不同的在于 dfs 先尽可能深的搜索一个分支，再尝试别的路径，而 bfs 按离起点的距离一层层搜索。 dfs 常借助递归实现，而 bfs 常借助队列实现。 dfs 的思想就是回溯，是一种暴力通用解法。有时可以提前判断分支不满足要求，提前返回，被称为剪枝。 树 和 图 常常要用到 dfs 或 bfs 来搜索，这里不涉及。 ","date":"2021-01-21","objectID":"/algorithm-dfs_bfs/:0:0","tags":["算法"],"title":"力扣总结 常见算法（六）：dfs 和 bfs","uri":"/algorithm-dfs_bfs/"},{"categories":null,"content":"1 基础 0022 括号生成 0045 跳跃游戏 II 0078 子集 0386 字典序排数 ","date":"2021-01-21","objectID":"/algorithm-dfs_bfs/:1:0","tags":["算法"],"title":"力扣总结 常见算法（六）：dfs 和 bfs","uri":"/algorithm-dfs_bfs/"},{"categories":null,"content":"2 进阶 0051 N 皇后 0079 单词搜索 0093 复原IP地址 0401 二进制手表 0994 腐烂的橘子 ","date":"2021-01-21","objectID":"/algorithm-dfs_bfs/:2:0","tags":["算法"],"title":"力扣总结 常见算法（六）：dfs 和 bfs","uri":"/algorithm-dfs_bfs/"},{"categories":null,"content":"3 挑战 0037 解数独 0127 单词接龙 0529 扫雷游戏 ","date":"2021-01-21","objectID":"/algorithm-dfs_bfs/:3:0","tags":["算法"],"title":"力扣总结 常见算法（六）：dfs 和 bfs","uri":"/algorithm-dfs_bfs/"},{"categories":null,"content":"二分查找是一种针对有序集合的高效查找算法，时间复杂度为 O(logN)。 二分查找每一轮通过检查中间元素，将查找范围缩小一半，本质上是一种分治。 很多情况下，python 中可以直接调用 bisect 来实现二分查找。 有时中间元素的判定较为复杂，不是直接比较，则可以结合 bisect 和 python 的魔法方法来实现。 ","date":"2021-01-11","objectID":"/algorithm-binary_search/:0:0","tags":["算法"],"title":"力扣总结 常见算法（五）：二分查找","uri":"/algorithm-binary_search/"},{"categories":null,"content":"1 基础 0034 在排序数组中查找元素的第一个和最后一个位置 0069 x 的平方根 0074 搜索二维矩阵 0278 第一个错误的版本 0374 猜数字大小 ","date":"2021-01-11","objectID":"/algorithm-binary_search/:1:0","tags":["算法"],"title":"力扣总结 常见算法（五）：二分查找","uri":"/algorithm-binary_search/"},{"categories":null,"content":"2 进阶 0033 搜索旋转排序数组 0081 搜索旋转排序数组 II 0153 寻找旋转排序数组中的最小值 0154 寻找旋转排序数组中的最小值 II 0162 寻找峰值 0222 完全二叉树的节点个数 ","date":"2021-01-11","objectID":"/algorithm-binary_search/:2:0","tags":["算法"],"title":"力扣总结 常见算法（五）：二分查找","uri":"/algorithm-binary_search/"},{"categories":null,"content":"3 挑战 0004 寻找两个正序数组的中位数 0209 长度最小的子数组 ","date":"2021-01-11","objectID":"/algorithm-binary_search/:3:0","tags":["算法"],"title":"力扣总结 常见算法（五）：二分查找","uri":"/algorithm-binary_search/"},{"categories":null,"content":"“我要在这个异世界拿出真本事！”\n34岁童贞且无职的家里蹲男子，在父母的葬礼当天被赶出家门后，在路上被一辆卡车所撞死。意识清醒后，他发现自己居然作为一个刚出生的婴儿转生到了剑与魔法的异世界！像废物一样活过了前世的男子，发誓要作为少年·鲁迪乌斯在异世界以认真的态度好好活下去！\n等待着鲁迪乌斯的是，与娇小魔术师、有着精灵长耳又很男孩子气的美少女、凶暴的傲娇大小姐以及其他性格各异的人们之间的邂逅，当然也还有残酷的冒险与战斗。\n新的人生就要开始了！“人生重来型”幻想冒险谭，在此开幕！","date":"2021-01-10","objectID":"/anime/jobless_reincarnation/","tags":null,"title":"无职转生 ～在异世界认真地活下去～","uri":"/anime/jobless_reincarnation/"},{"categories":null,"content":"简介 “我要在这个异世界拿出真本事！” 34岁童贞且无职的家里蹲男子，在父母的葬礼当天被赶出家门后，在路上被一辆卡车所撞死。意识清醒后，他发现自己居然作为一个刚出生的婴儿转生到了剑与魔法的异世界！像废物一样活过了前世的男子，发誓要作为少年·鲁迪乌斯在异世界以认真的态度好好活下去！ 等待着鲁迪乌斯的是，与娇小魔术师、有着精灵长耳又很男孩子气的美少女、凶暴的傲娇大小姐以及其他性格各异的人们之间的邂逅，当然也还有残酷的冒险与战斗。 新的人生就要开始了！“人生重来型”幻想冒险谭，在此开幕！ 制作人员： 原作：不讲理的痒痒挠 导演：冈本学 脚本：平野宏树、中本宗应、齐藤浩央 分镜：小林敦、重原克也、三盐","date":"2021-01-10","objectID":"/anime/jobless_reincarnation/:1:0","tags":null,"title":"无职转生 ～在异世界认真地活下去～","uri":"/anime/jobless_reincarnation/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鲁迪乌斯·格雷拉特 卢迪乌斯·格雷拉特、Rudeus Greyrat、鲁迪、泥沼 男 内山夕実 2 洛琪希·米格路迪亚·格雷拉特 Roxy Migurdia Greyrat、教育之神 女 小原好美 3 艾莉丝·格雷拉特 エリス・ボレアス・グレイラット、艾莉丝·伯雷亚斯·格雷拉特、Eris Greyrat、狂犬、狂剑王 女 加隈亜衣 4 希露菲叶特·格雷拉特 希露菲爱特·格雷拉特、Sylphiette Greyrat、希露弗、希露菲、沉默的菲兹 女 茅野愛衣 5 保罗·格雷拉特 Paul Greyrat 男 森川智之 6 塞妮丝·格雷拉特 Zenith Gre","date":"2021-01-10","objectID":"/anime/jobless_reincarnation/:2:0","tags":null,"title":"无职转生 ～在异世界认真地活下去～","uri":"/anime/jobless_reincarnation/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 无职转生 ～在异世界认真地活下去～ 2021-01-10 11 樱花 2 无职转生 ～在异世界认真地活下去～ 第二部分 2021-10-03 12 樱花 3 无职转生 ～在异世界认真地活下去～ OVA 2022-03-16 1 樱花 ","date":"2021-01-10","objectID":"/anime/jobless_reincarnation/:3:0","tags":null,"title":"无职转生 ～在异世界认真地活下去～","uri":"/anime/jobless_reincarnation/"},{"categories":null,"content":"双指针算法一般指两个指针在数组上相向移动来解决问题的算法。 双指针算法常应用在具有某种有序性质的问题上，本质上是一种减少了搜索范围的递归。 广义来说，用两个变量在线性结构上遍历来解决问题的方法都可以归为双指针算法。 比如链表上的快慢指针、部分滑动窗口问题。 用双指针来解决滑动窗口问题时，两个指针同向移动，常应用在某种限制条件下的窗口最值问题。 有些滑动窗口问题更加复杂，还需要用到 有序集合、 滚动哈希 等方法，这里暂不涉及。 ","date":"2021-01-01","objectID":"/algorithm-two_pointers/:0:0","tags":["算法"],"title":"力扣总结 常见算法（四）：双指针和滑动窗口","uri":"/algorithm-two_pointers/"},{"categories":null,"content":"1 基础 0003 无重复字符的最长子串 0167 两数之和 II - 输入有序数组 0209 长度最小的子数组 0345 反转字符串中的元音字母 0643 子数组最大平均数 I ","date":"2021-01-01","objectID":"/algorithm-two_pointers/:1:0","tags":["算法"],"title":"力扣总结 常见算法（四）：双指针和滑动窗口","uri":"/algorithm-two_pointers/"},{"categories":null,"content":"2 进阶 0011 盛最多水的容器 0016 最接近的三数之和 0424 替换后的最长重复字符 0438 找到字符串中所有字母异位词 0713 乘积小于K的子数组 ","date":"2021-01-01","objectID":"/algorithm-two_pointers/:2:0","tags":["算法"],"title":"力扣总结 常见算法（四）：双指针和滑动窗口","uri":"/algorithm-two_pointers/"},{"categories":null,"content":"3 挑战 0030 串联所有单词的子串 0042 接雨水 0076 最小覆盖子串 0992 K 个不同整数的子数组 ","date":"2021-01-01","objectID":"/algorithm-two_pointers/:3:0","tags":["算法"],"title":"力扣总结 常见算法（四）：双指针和滑动窗口","uri":"/algorithm-two_pointers/"},{"categories":null,"content":" 力扣第 221 场周赛第 4 题 ","date":"2020-12-27","objectID":"/leetcode/1707/:0:0","tags":null,"title":"1707：与数组中元素的最大异或值（★★★）","uri":"/leetcode/1707/"},{"categories":null,"content":"题目 给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。 第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] \u003c= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。 返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。 示例 1：","date":"2020-12-27","objectID":"/leetcode/1707/:1:0","tags":null,"title":"1707：与数组中元素的最大异或值（★★★）","uri":"/leetcode/1707/"},{"categories":null,"content":"分析 基于 0421 可知，先构建二进制前缀的哈希表或字典树， 即可在 31 步内求得 x 与 nums 中元素的最大异或值。 但本题限制了每轮 nums 的范围，只能取不超过 mi 的元素，所以固定的哈希表或字典树不可行。 有个巧妙的想法是将 nums 排序，在动态地构建哈希表或字典树的过程中， 便得到了任意 mi 所对应的哈希表或字典树。 注意到这种方法得到的 queries 的答案并不是按 queries 的顺序依次得到的。这被称为离线查询。 这里用哈希表方法，更简单。 ","date":"2020-12-27","objectID":"/leetcode/1707/:2:0","tags":null,"title":"1707：与数组中元素的最大异或值（★★★）","uri":"/leetcode/1707/"},{"categories":null,"content":"解答 def maximizeXor(self, nums: List[int], queries: List[List[int]]) -\u003e List[int]: def find(x): ans = 0 for j in range(30, -1, -1): ans \u003c\u003c= 1 ans += int((ans+1)^(x\u003e\u003ej) in A[j]) return ans nums = sorted(set(nums)) queries = sorted((m, idx, x) for idx, (x, m) in enumerate(queries)) A = [set() for _ in ","date":"2020-12-27","objectID":"/leetcode/1707/:3:0","tags":null,"title":"1707：与数组中元素的最大异或值（★★★）","uri":"/leetcode/1707/"},{"categories":null,"content":"*附加 字典树写法。 def maximizeXor(self, nums: List[int], queries: List[List[int]]) -\u003e List[int]: def find(x): ans, p = '', trie for bit in bin(x)[2:].zfill(31): bit_rev = str(int(bit)^1) ans += '1' if bit_rev in p else '0' p = p[bit_rev] if bit_rev in p else p[bit] return int(ans, 2) nums = sorted(set(nums","date":"2020-12-27","objectID":"/leetcode/1707/:4:0","tags":null,"title":"1707：与数组中元素的最大异或值（★★★）","uri":"/leetcode/1707/"},{"categories":null,"content":" 力扣第 221 场周赛第 2 题 ","date":"2020-12-27","objectID":"/leetcode/1705/:0:0","tags":null,"title":"1705：吃苹果的最大数目（★★）","uri":"/leetcode/1705/"},{"categories":null,"content":"题目 有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。 你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。 给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。 示例 1： 输入：apples = [1,2,3,5,2], days = [3","date":"2020-12-27","objectID":"/leetcode/1705/:1:0","tags":null,"title":"1705：吃苹果的最大数目（★★）","uri":"/leetcode/1705/"},{"categories":null,"content":"分析 直觉来说，每天应该先吃最早坏的苹果。（可以证明该策略每一步都不比最优策略差，因此就是最优策略） 可以用堆来维护有序列表，按 [腐烂时间, 苹果个数] 入堆，堆顶即是最早坏的苹果。 注意 n 天之后可以继续吃苹果，因此要遍历到第 max(i+d for i,d in enumerate(days)) 天。 ","date":"2020-12-27","objectID":"/leetcode/1705/:2:0","tags":null,"title":"1705：吃苹果的最大数目（★★）","uri":"/leetcode/1705/"},{"categories":null,"content":"解答 def eatenApples(self, apples: List[int], days: List[int]) -\u003e int: end = max(i+d for i, d in enumerate(days)) res, pq = 0, [] for i in range(end): if i \u003c len(days) and apples[i] \u003e 0: heappush(pq, [i+days[i], apples[i]]) while pq and pq[0][0] \u003c= i: heappop(pq) if pq: pq[0][1] -= 1 if pq[0][1] == 0:","date":"2020-12-27","objectID":"/leetcode/1705/:3:0","tags":null,"title":"1705：吃苹果的最大数目（★★）","uri":"/leetcode/1705/"},{"categories":null,"content":"递归是指函数自己调用自己的语法现象。 一般递归用于将问题不断转化为规模更小的子问题，直到变为可以直接求解的最简单子问题。 这也就是分治法的思想。 递归是许多算法和数据结构的基础。（这里暂不涉及） 排序 中的快速排序、归并排序，双指针， 二分查找，动态规划 等算法本质上都是分治的思想。 回溯法、dfs 一般借助递归来实现。 树 的定义即是递归的。 递归是自顶向下的，思考逻辑比较自然直接，但有时递归层数太多会爆栈。 所以还需要掌握非递归的写法，也就是自底向上的递推写法。 ","date":"2020-12-21","objectID":"/algorithm-recursion/:0:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":"1 基础 0050 Pow(x, n) 0078 子集 0779 第K个语法符号 ","date":"2020-12-21","objectID":"/algorithm-recursion/:1:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":"2 进阶 0060 排列序列 0301 删除无效的括号 0372 超级次方 0390 消除游戏 0395 至少有 K 个重复字符的最长子串 ","date":"2020-12-21","objectID":"/algorithm-recursion/:2:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":"3 挑战 0273 整数转换英文表示 1823 找出游戏的获胜者 ","date":"2020-12-21","objectID":"/algorithm-recursion/:3:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":"4 树上递归 ","date":"2020-12-21","objectID":"/algorithm-recursion/:4:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":" 力扣第 220 场周赛第 3 题 ","date":"2020-12-20","objectID":"/leetcode/1696/:0:0","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"题目 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。 一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。 你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。 请你返回你能得到的 最大得分 。 示例 1： 输入：nums = [1,-1,-2,4,-7,3], k = 2\r输出：7\r解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。\r示例 2： 输入：nums = [","date":"2020-12-20","objectID":"/leetcode/1696/:1:0","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"分析 ","date":"2020-12-20","objectID":"/leetcode/1696/:2:0","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"#1 类似 1425，令 dp[j] 代表到达位置 j 的最大得分，那么可以递推： dp[j] = nums[j]+max(dp[j-k:j])\r然后边递推边滑动 dp 数组，转为滑动窗口最大值问题。 def maxResult(self, nums: List[int], k: int) -\u003e int: from sortedcontainers import SortedList sl, dp = SortedList(), nums[:] for j, num in enumerate(nums): if j: dp[j] = num + sl[-1] sl.add(dp[j]) if ","date":"2020-12-20","objectID":"/leetcode/1696/:2:1","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"#2 也可以用单调队列的方法。 ","date":"2020-12-20","objectID":"/leetcode/1696/:2:2","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"解答 def maxResult(self, nums: List[int], k: int) -\u003e int: queue, dp = deque(), nums[:] for j, num in enumerate(nums): if j: dp[j] = num + queue[0][0] while queue and queue[-1][0]\u003c=dp[j]: queue.pop() queue.append((dp[j], j)) if queue[0][1] == j-k: queue.popleft() return dp[-1] 340 ms ","date":"2020-12-20","objectID":"/leetcode/1696/:3:0","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":" 力扣第 219 场周赛第 3 题 ","date":"2020-12-13","objectID":"/leetcode/1690/:0:0","tags":null,"title":"1690：石子游戏 VII（★★）","uri":"/leetcode/1690/"},{"categories":null,"content":"题目 石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，爱丽丝先开始 。 有 n 块石子排成一排。每个玩家的回合中，可以从行中 移除 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 和 相等的得分。当没有石头可移除时，得分较高者获胜。 鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 减小得分的差值 。爱丽丝的目标是最大限度地 扩大得分的差值 。 给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，如果爱丽丝和鲍勃都 发挥出最佳水平 ，请返回他们 得分的差值 。 示例 1： 输入：stones = [5,3,1,4,2]\r输出：6","date":"2020-12-13","objectID":"/leetcode/1690/:1:0","tags":null,"title":"1690：石子游戏 VII（★★）","uri":"/leetcode/1690/"},{"categories":null,"content":"分析 ","date":"2020-12-13","objectID":"/leetcode/1690/:2:0","tags":null,"title":"1690：石子游戏 VII（★★）","uri":"/leetcode/1690/"},{"categories":null,"content":"#1 先考虑递归。用辅助函数 help(i, j) 直接表示用 stones[i:j] 玩游戏爱丽丝和鲍勃能拿到的最大分数差。 爱丽丝先拿 i 位，最大分数差是 sum(stones[i+1:j])-help(i+1, j)（注意这里是减）\r爱丽丝先拿 j-1 位，最大分数差是 sum(stones[i:j-1])-help(i,j-1)（注意这里是减）\r比较两种情况即可\rdef stoneGameVII(self, stones: List[int]) -\u003e int: @lru_cache(None) def help(i, j): if j-i == 1: return 0 return ","date":"2020-12-13","objectID":"/leetcode/1690/:2:1","tags":null,"title":"1690：石子游戏 VII（★★）","uri":"/leetcode/1690/"},{"categories":null,"content":"#2 改写为动态规划试试。令 dp[i][j] 表示用 stones[i:j] 玩游戏爱丽丝和鲍勃能拿到的最大分数差。状态转移方程为： if j\u003c=i+1: dp[i][j] = 0\relse: dp[i][j] = max(sum(stones[i+1:j])-help(i+1, j), sum(stones[i:j-1])-help(i,j-1))\r可以先计算保存所有前缀和，以减少计算。 def stoneGameVII(self, stones: List[int]) -\u003e int: pre = [0] for stone in stones: pre.append(pre[-1]+st","date":"2020-12-13","objectID":"/leetcode/1690/:2:2","tags":null,"title":"1690：石子游戏 VII（★★）","uri":"/leetcode/1690/"},{"categories":null,"content":"#3 直觉来说应该有更简单的规律。观察发现，如果把爱丽丝先选、鲍勃后选合起来看成一轮，那么这一轮的得分之差其实就是鲍勃选的数字。 不管数组长度是奇数或偶数，最终的得分之差就是鲍勃选的数字之和。 所以爱丽丝和鲍勃的目标等价于使选的数字之和最小化，问题等价于求最终鲍勃选的数字之和。这非常类似 0486 了，只是最大化变成了最小化。 可以直接调用 0486 的代码。注意这里求出的是爱丽丝和鲍勃选的数字之和的差，需要结合 sum(stones) 求出鲍勃选出的数字之和。 ","date":"2020-12-13","objectID":"/leetcode/1690/:2:3","tags":null,"title":"1690：石子游戏 VII（★★）","uri":"/leetcode/1690/"},{"categories":null,"content":"解答 def stoneGameVII(self, stones: List[int]) -\u003e int: n = len(stones) dp = [0]*(n+1) for i in range(n-1, -1, -1): for j in range(i+1, n+1): dp[j] = min(stones[i]-dp[j], stones[j-1]-dp[j-1]) return (sum(stones)-dp[-1]) // 2 2256 ms ","date":"2020-12-13","objectID":"/leetcode/1690/:3:0","tags":null,"title":"1690：石子游戏 VII（★★）","uri":"/leetcode/1690/"},{"categories":null,"content":" 力扣第 41 场双周赛第 3 题 ","date":"2020-12-12","objectID":"/leetcode/1686/:0:0","tags":null,"title":"1686：石子游戏 VI（★★）","uri":"/leetcode/1686/"},{"categories":null,"content":"题目 Alice 和 Bob 轮流玩一个游戏，Alice 先手。 一堆石子里总共有 n 个石子，轮到某个玩家时，他可以 移出 一个石子并得到这个石子的价值。Alice 和 Bob 对石子价值有 不一样的的评判标准 。双方都知道对方的评判标准。 给你两个长度为 n 的整数数组 aliceValues 和 bobValues 。aliceValues[i] 和 bobValues[i] 分别表示 Alice 和 Bob 认为第 i 个石子的价值。 所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 最优策略 进行游戏。 请你推断游戏的结果，用如下的方式表示：","date":"2020-12-12","objectID":"/leetcode/1686/:1:0","tags":null,"title":"1686：石子游戏 VI（★★）","uri":"/leetcode/1686/"},{"categories":null,"content":"分析 递归显然较复杂，考虑是否有规律。 设 Alice 选择的石子位置是 $a_1, a_2, …, a_k$，k=(n+1)//2，那么 Alice 和 Bob 的分数之差为： $$ A[a_1]+A[a_2]+…+A[a_k]-(sum(B)-B[a_1]-B[a_2]-…-B[a_k]) $$ $$ = (A[a_1]+B[a_1])+(A[a_2]+B[a_2])+…+(A[a_k]+B[a_k]) - sum(B)$$ 因此 Alice 每次应选择使 A[i]+B[i] 尽量大的位置 i。 而 Bob 也是同理。所以二人会按照 A[i]+B[i] 排序的位置依次选择 i。计算分数之差","date":"2020-12-12","objectID":"/leetcode/1686/:2:0","tags":null,"title":"1686：石子游戏 VI（★★）","uri":"/leetcode/1686/"},{"categories":null,"content":"解答 def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -\u003e int: pairs = sorted([a+b for a,b in zip(aliceValues, bobValues)], reverse=True) res = sum(pairs[::2]) - sum(bobValues) return 1 if res \u003e 0 else (-1 if res \u003c 0 else 0) 140 ms ","date":"2020-12-12","objectID":"/leetcode/1686/:3:0","tags":null,"title":"1686：石子游戏 VI（★★）","uri":"/leetcode/1686/"},{"categories":null,"content":"位运算是计算机最基础的运算，包括位模式或二进制数的一元和二元操作（\u0026、|、^、~、«、»）。 很多位运算的问题具有较强的技巧性，需要很熟悉各个位运算符的性质。 ","date":"2020-12-11","objectID":"/algorithm-bit/:0:0","tags":["算法"],"title":"力扣总结 常见算法（二）：位运算和状态压缩","uri":"/algorithm-bit/"},{"categories":null,"content":"1 基础 0136 只出现一次的数字 0191 位1的个数 ","date":"2020-12-11","objectID":"/algorithm-bit/:1:0","tags":["算法"],"title":"力扣总结 常见算法（二）：位运算和状态压缩","uri":"/algorithm-bit/"},{"categories":null,"content":"2 进阶 0201 数字范围按位与 0260 只出现一次的数字 III 0338 比特位计数 ","date":"2020-12-11","objectID":"/algorithm-bit/:2:0","tags":["算法"],"title":"力扣总结 常见算法（二）：位运算和状态压缩","uri":"/algorithm-bit/"},{"categories":null,"content":"3 挑战 0137 只出现一次的数字 II ","date":"2020-12-11","objectID":"/algorithm-bit/:3:0","tags":["算法"],"title":"力扣总结 常见算法（二）：位运算和状态压缩","uri":"/algorithm-bit/"},{"categories":null,"content":"排序算法是非常经典的一类算法，常作为算法教程的第一章。 最常用的是快速排序、归并排序、堆排序，其思想也不仅应用在排序中。 特别的，当数据范围相对于数据规模较小时，计数排序可能更快。 而桶排序的应用较为灵活，能巧妙地解决一些问题。 python 中一般直接调用 sort 函数来排序，采用的是 TimSort算法， 一种结合了归并排序和插入排序的混合排序算法。 解决很多数组问题时，都可以先排序。比如取不重复元组的问题，通用方法是： 先排序，然后每轮取元素时，相同的数跳过，即可保证元组不重复 ","date":"2020-12-01","objectID":"/algorithm-sort/:0:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":"1 基础 0021 合并两个有序链表 0506 相对名次 0912 排序数组 1030 距离顺序排列矩阵单元格 ","date":"2020-12-01","objectID":"/algorithm-sort/:1:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":"2 进阶 0023 合并K个升序链表 0147 对链表进行插入排序 0148 排序链表 0274 H 指数 0853 车队 ","date":"2020-12-01","objectID":"/algorithm-sort/:2:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":"3 挑战 0179 最大数 0215 数组中的第K个最大元素 ","date":"2020-12-01","objectID":"/algorithm-sort/:3:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":"*4 桶排序 0164 最大间距 0220 存在重复元素 III ","date":"2020-12-01","objectID":"/algorithm-sort/:4:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":" 力扣第 217 场周赛第 2 题 ","date":"2020-11-29","objectID":"/leetcode/1673/:0:0","tags":null,"title":"1673：找出最具竞争力的子序列（★★）","uri":"/leetcode/1673/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。 数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。 在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。 示例 1： 输入：nums = [3,5,2,6], k = 2\r输出：[2,6]\r解释：在所有可能的子序列集合 {[3,5], [3,2], [3","date":"2020-11-29","objectID":"/leetcode/1673/:1:0","tags":null,"title":"1673：找出最具竞争力的子序列（★★）","uri":"/leetcode/1673/"},{"categories":null,"content":"分析 类似 0402 ，只是从字符串变成了数组。 ","date":"2020-11-29","objectID":"/leetcode/1673/:2:0","tags":null,"title":"1673：找出最具竞争力的子序列（★★）","uri":"/leetcode/1673/"},{"categories":null,"content":"解答 def mostCompetitive(self, nums: List[int], k: int) -\u003e List[int]: stack, k = [], len(nums) - k for num in nums: while k and stack and stack[-1] \u003e num: stack.pop() k -= 1 stack.append(num) return stack[:-k] if k else stack 276 ms ","date":"2020-11-29","objectID":"/leetcode/1673/:3:0","tags":null,"title":"1673：找出最具竞争力的子序列（★★）","uri":"/leetcode/1673/"},{"categories":null,"content":" 力扣第 40 场双周赛第 1 题 ","date":"2020-11-28","objectID":"/leetcode/1668/:0:0","tags":null,"title":"1668：最大重复子字符串","uri":"/leetcode/1668/"},{"categories":null,"content":"题目 给你一个字符串 sequence ，如果字符串 word 连续重复 k 次形成的字符串是 sequence 的一个子字符串，那么单词 word 的 重复值为 k 。单词 word 的 最大重复值 是单词 word 在 sequence 中最大的重复值。如果 word 不是 sequence 的子串，那么重复值 k 为 0 。 给你一个字符串 sequence 和 word ，请你返回 最大重复值 k 。 示例 1： 输入：sequence = \"ababc\", word = \"ab\"\r输出：2\r解释：\"abab\" 是 \"ababc\" 的子字符串。\r示例 2： 输入：sequence = ","date":"2020-11-28","objectID":"/leetcode/1668/:1:0","tags":null,"title":"1668：最大重复子字符串","uri":"/leetcode/1668/"},{"categories":null,"content":"分析 ","date":"2020-11-28","objectID":"/leetcode/1668/:2:0","tags":null,"title":"1668：最大重复子字符串","uri":"/leetcode/1668/"},{"categories":null,"content":"#1 设 sequence 长度 m，word 长度 n，显然 k 不超过 m//n，从大到小遍历判断即可。 def maxRepeating(self, sequence: str, word: str) -\u003e int: m, n = len(sequence), len(word) for x in range(m//n, 0, -1): if word*x in sequence: return x return 0 32 ms ","date":"2020-11-28","objectID":"/leetcode/1668/:2:1","tags":null,"title":"1668：最大重复子字符串","uri":"/leetcode/1668/"},{"categories":null,"content":"#2 令 check(x) 代表 x*word 是否为 sequence 的子串。显然 check(x) 具有单调性，因此可以用二分查找优化时间。 ","date":"2020-11-28","objectID":"/leetcode/1668/:2:2","tags":null,"title":"1668：最大重复子字符串","uri":"/leetcode/1668/"},{"categories":null,"content":"解答 def maxRepeating(self, sequence: str, word: str) -\u003e int: self.__class__.__getitem__ = lambda self, x: word*x not in sequence return bisect_left(self, True, 1, len(sequence)//len(word)+1)-1 32 ms ","date":"2020-11-28","objectID":"/leetcode/1668/:3:0","tags":null,"title":"1668：最大重复子字符串","uri":"/leetcode/1668/"},{"categories":null,"content":"图是一种比树形结构更复杂的非线性数据结构。 树形结构中的结点是一对多的关系，且有明显的层次关系。 图中的顶点是多对多的关系，无明显的层次关系。 按顶点连线（边）是否有方向，可以将图分为有向图和无向图。 有些图的边还附带数据信息（权），被称为网或网络。 图的遍历和树的遍历相似，但图中可能出现回路，因此常用一个辅助数组或哈希表 vis 记录访问过的顶点。 图最常见的问题有： 最小生成树，常用算法 并查集 拓扑排序，常用算法 bfs 最短路径，常用算法 dijkstra、Bellman-Ford、floyd 割点和桥，常用算法 tarjan 欧拉图，常用算法 Hierholzer ","date":"2020-11-11","objectID":"/algorithm-graph/:0:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"1 基础 0133 克隆图 0797 所有可能的路径 0841 钥匙和房间 0997 找到小镇的法官 ","date":"2020-11-11","objectID":"/algorithm-graph/:1:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"2 拓扑排序 ","date":"2020-11-11","objectID":"/algorithm-graph/:2:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"2.1 基础 0207 课程表 0210 课程表 II 0684 冗余连接 ","date":"2020-11-11","objectID":"/algorithm-graph/:2:1","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"2.2 进阶 0310 最小高度树 0802 找到最终的安全状态 2115 从给定原材料中找到所有可以做出的菜 ","date":"2020-11-11","objectID":"/algorithm-graph/:2:2","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"2.3 挑战 1203 项目管理 1591 奇怪的打印机 II 1857 有向图中最大颜色值 ","date":"2020-11-11","objectID":"/algorithm-graph/:2:3","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"3 最短路径 ","date":"2020-11-11","objectID":"/algorithm-graph/:3:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"3.1 基础 0743 网络延迟时间 1334 阈值距离内邻居最少的城市 1514 概率最大的路径 ","date":"2020-11-11","objectID":"/algorithm-graph/:3:1","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"3.2 进阶 0787 K 站中转内最便宜的航班 0847 访问所有节点的最短路径 0882 细分图中的可到达结点 1368 使网格图至少有一条有效路径的最小代价 lcp35 电动车游城市 ","date":"2020-11-11","objectID":"/algorithm-graph/:3:2","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"3.3 挑战 1786 从第一个节点出发到最后一个节点的受限路径数 1976 到达目的地的方案数 2045 到达目的地的第二短时间 2203 得到要求路径的最小带权子图 ","date":"2020-11-11","objectID":"/algorithm-graph/:3:3","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"4 最小生成树 1584 连接所有点的最小费用 ","date":"2020-11-11","objectID":"/algorithm-graph/:4:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"*5 欧拉图 0332 重新安排行程 0753 破解保险箱 2097 合法重新排列数对 ","date":"2020-11-11","objectID":"/algorithm-graph/:5:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"*6 割点和桥 1192 查找集群内的「关键连接」 1489 找到最小生成树里的关键边和伪关键边 1568 使陆地分离的最少天数 ","date":"2020-11-11","objectID":"/algorithm-graph/:6:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":" 力扣第 214 场周赛第 4 题 ","date":"2020-11-08","objectID":"/leetcode/1649/:0:0","tags":null,"title":"1649：通过指令创建有序数组（★★★）","uri":"/leetcode/1649/"},{"categories":null,"content":"题目 给你一个整数数组 instructions ，你需要根据 instructions 中的元素创建一个有序数组。一开始你有一个空的数组 nums ，你需要 从左到右 遍历 instructions 中的元素，将它们依次插入 nums 数组中。每一次插入操作的 代价 是以下两者的 较小值 ： nums 中 严格小于 instructions[i] 的数字数目。\rnums 中 严格大于 instructions[i] 的数字数目。\r比方说，如果要将 3 插入到 nums = [1,2,3,5] ，那么插入操作的 代价 为 min(2, 1) (元素 1 和 2 小于 3 ，元素 5 大于 3 ","date":"2020-11-08","objectID":"/leetcode/1649/:1:0","tags":null,"title":"1649：通过指令创建有序数组（★★★）","uri":"/leetcode/1649/"},{"categories":null,"content":"分析 容易想到维护一个 nums 的有序集合，然后二分查找即可。 ","date":"2020-11-08","objectID":"/leetcode/1649/:2:0","tags":null,"title":"1649：通过指令创建有序数组（★★★）","uri":"/leetcode/1649/"},{"categories":null,"content":"解答 def createSortedArray(self, instructions: List[int]) -\u003e int: from sortedcontainers import SortedList res, sl = 0, SortedList() for x in instructions: res += min(sl.bisect_left(x),len(sl)-sl.bisect_right(x)) sl.add(x) return res % (10**9+7) 3908 ms ","date":"2020-11-08","objectID":"/leetcode/1649/:3:0","tags":null,"title":"1649：通过指令创建有序数组（★★★）","uri":"/leetcode/1649/"},{"categories":null,"content":" 力扣第 213 场周赛第 3 题 ","date":"2020-11-01","objectID":"/leetcode/1642/:0:0","tags":null,"title":"1642：可以到达的最远建筑（★★）","uri":"/leetcode/1642/"},{"categories":null,"content":"题目 给你一个整数数组 heights ，表示建筑物的高度。另有一些砖块 bricks 和梯子 ladders 。 你从建筑物 0 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。 当从建筑物 i 移动到建筑物 i+1（下标 从 0 开始 ）时： 如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块\r如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 (h[i+1] - h[i]) 个砖块\r如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 从 0 开始 ）。\r示例 1： 输入：heights = [4,2,7,6,9,1","date":"2020-11-01","objectID":"/leetcode/1642/:1:0","tags":null,"title":"1642：可以到达的最远建筑（★★）","uri":"/leetcode/1642/"},{"categories":null,"content":"分析 显然应该用梯子解决最大的高度差，剩下的用砖块。因此遍历位置 i，记录所有需要攀爬的高度差，去掉 ladders 个最大值， 判断剩下的能否用砖块解决。若无法解决，就返回位置 i-1 即可。 可以用堆来维护 ladders 个最大值来节省时间。 ","date":"2020-11-01","objectID":"/leetcode/1642/:2:0","tags":null,"title":"1642：可以到达的最远建筑（★★）","uri":"/leetcode/1642/"},{"categories":null,"content":"解答 def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -\u003e int: n, pq = len(heights), [] for i in range(1, n): if heights[i] - heights[i-1] \u003e 0: heappush(pq, heights[i] - heights[i-1]) if len(pq) \u003e ladders: bricks -= heappop(pq) if bricks \u003c 0: return i-1 return n - 1 176 ms ","date":"2020-11-01","objectID":"/leetcode/1642/:3:0","tags":null,"title":"1642：可以到达的最远建筑（★★）","uri":"/leetcode/1642/"},{"categories":null,"content":"堆 是一种特别的完全二叉树，每一个节点的值都大于等于或小于等于其孩子节点的值。 堆可以在 O(logN) 时间内插入元素、删除根节点，在 O(1) 时间获得最大值或最小值。一般用于有序弹出元素的场景。 python 中一般直接用内置库 heapq 表示（list 实现的），默认是小顶堆，即堆顶元素是最小值。 额外地，图里面有个重要的 dijkstra 算法常借助堆实现，这里先不涉及。 ","date":"2020-11-01","objectID":"/algorithm-heap/:0:0","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"1 基础 ","date":"2020-11-01","objectID":"/algorithm-heap/:1:0","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"1.1 设计 0703 数据流中的第 K 大元素 1845 座位预约管理系统 ","date":"2020-11-01","objectID":"/algorithm-heap/:1:1","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"1.2 应用 0023 合并K个升序链表 0692 前K个高频单词 1046 最后一块石头的重量 ","date":"2020-11-01","objectID":"/algorithm-heap/:1:2","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"2 进阶 ","date":"2020-11-01","objectID":"/algorithm-heap/:2:0","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"2.1 设计 0295 数据流的中位数 0355 设计推特 ","date":"2020-11-01","objectID":"/algorithm-heap/:2:1","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"2.2 应用 0373 查找和最小的 K 对数字 0786 第 K 个最小的素数分数 1801 积压订单中的订单总数 1834 单线程 CPU ","date":"2020-11-01","objectID":"/algorithm-heap/:2:2","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"3 挑战 0407 接雨水 II 0857 雇佣 K 名工人的最低成本 1439 有序矩阵中的第 k 个最小数组和 ","date":"2020-11-01","objectID":"/algorithm-heap/:3:0","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":" 力扣第 212 场周赛第 4 题 ","date":"2020-10-25","objectID":"/leetcode/1632/:0:0","tags":null,"title":"1632：矩阵转换后的秩（★★★）","uri":"/leetcode/1632/"},{"categories":null,"content":"题目 给你一个 m x n 的矩阵 matrix ，请你返回一个新的矩阵 answer ，其中 answer[row][col] 是 matrix[row][col] 的秩。 每个元素的 秩 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算： 秩是从 1 开始的一个整数。\r如果两个元素 p 和 q 在 同一行 或者 同一列 ，那么：\r如果 p \u003c q ，那么 rank(p) \u003c rank(q)\r如果 p == q ，那么 rank(p) == rank(q)\r如果 p \u003e q ，那么 rank(p) \u003e rank(q)\r秩 需要越 小 越好。\r题目保证按照上面规则 answ","date":"2020-10-25","objectID":"/leetcode/1632/:1:0","tags":null,"title":"1632：矩阵转换后的秩（★★★）","uri":"/leetcode/1632/"},{"categories":null,"content":"分析 先考虑简化情形：没有相同的元素。那么显然最小的元素的秩为 1，第二小的元素则要考虑是否和最小元素同行或同列。 于是得到贪心解法： 从小到大遍历元素，并维护每行/列的最大秩，该元素的秩即为同行/列的最大秩加 1\r存在相同元素时则较为复杂，假设两个相同元素同行/列，那么就要考虑到两个元素分别对应的 行/列 的最大秩。 同时还可能出现连动，比如元素 a 和 b 同行，b 和 c 同列，那么要同时考虑这三个元素。 这种连动容易想到并查集，于是用并查集将相同元素分为几个连通块，对于每个连通块， 里面所有元素对应的 行/列 最大秩 加 1，即为该连通块内所有元素的秩。 ","date":"2020-10-25","objectID":"/leetcode/1632/:2:0","tags":null,"title":"1632：矩阵转换后的秩（★★★）","uri":"/leetcode/1632/"},{"categories":null,"content":"解答 def matrixRankTransform(self, matrix: List[List[int]]) -\u003e List[List[int]]: def find(x): if f.setdefault(x, x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) m, n = len(matrix), len(matrix[0]) d = defaultdict(list) for i, j in product(range(m), range(n)): d[matrix[i][j]]","date":"2020-10-25","objectID":"/leetcode/1632/:3:0","tags":null,"title":"1632：矩阵转换后的秩（★★★）","uri":"/leetcode/1632/"},{"categories":null,"content":"树是一种非线性的数据结构，本质是节点的有限集。其定义是递归的： 有且仅有一个特定的称为根（root）的节点 当节点数量 \u003e 1 时，其余节点可分为若干个互不相交的有限集，其中每个集合也可以看作一颗树，称之为根的子树。 从图的观点来看，树也可视为一个拥有 N 个节点和 N-1 条边的一个有向无环图。 树的应用非常广泛，也常和其它数据结构和算法有联系，尤其是递归。 ","date":"2020-10-21","objectID":"/algorithm-tree/:0:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"1 基础 ","date":"2020-10-21","objectID":"/algorithm-tree/:1:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"1.1 遍历 0094 二叉树的中序遍历 0103 二叉树的锯齿形层序遍历 0144 二叉树的前序遍历 0145 二叉树的后序遍历 0872 叶子相似的树 ","date":"2020-10-21","objectID":"/algorithm-tree/:1:1","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"1.2 递归 0101 对称二叉树 0226 翻转二叉树 0508 出现次数最多的子树元素和 0606 根据二叉树创建字符串 0671 二叉树中第二小的节点 0814 二叉树剪枝 ","date":"2020-10-21","objectID":"/algorithm-tree/:1:2","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"2 进阶 ","date":"2020-10-21","objectID":"/algorithm-tree/:2:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"2.1 遍历 0112 路径总和 0113 路径总和 II 0116 填充每个节点的下一个右侧节点指针 0117 填充每个节点的下一个右侧节点指针 II 0655 输出二叉树 0662 二叉树最大宽度 ","date":"2020-10-21","objectID":"/algorithm-tree/:2:1","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"2.2 递归 0106 从中序与后序遍历序列构造二叉树 0110 平衡二叉树 0124 二叉树中的最大路径和 0236 二叉树的最近公共祖先 0337 打家劫舍 III ","date":"2020-10-21","objectID":"/algorithm-tree/:2:2","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"3 挑战 0834 树中距离之和 0889 根据前序和后序遍历构造二叉树 ","date":"2020-10-21","objectID":"/algorithm-tree/:3:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"*4 二叉搜索树 ","date":"2020-10-21","objectID":"/algorithm-tree/:4:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"4.1 基础 0098 验证二叉搜索树 0108 将有序数组转换为二叉搜索树 0173 二叉搜索树迭代器 0235 二叉搜索树的最近公共祖先 0669 修剪二叉搜索树 0701 二叉搜索树中的插入操作 ","date":"2020-10-21","objectID":"/algorithm-tree/:4:1","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"4.2 进阶 0096 不同的二叉搜索树 0095 不同的二叉搜索树 II 0450 删除二叉搜索树中的节点 0501 二叉搜索树中的众数 0530 二叉搜索树的最小绝对差 0538 把二叉搜索树转换为累加树 ","date":"2020-10-21","objectID":"/algorithm-tree/:4:2","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"4.3 挑战 0099 恢复二叉搜索树 ","date":"2020-10-21","objectID":"/algorithm-tree/:4:3","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"*5 树哈希 0297 二叉树的序列化与反序列化 0449 序列化和反序列化二叉搜索树 0572 另一个树的子树 0652 寻找重复的子树 ","date":"2020-10-21","objectID":"/algorithm-tree/:5:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":" 力扣第 211 场周赛第 4 题 ","date":"2020-10-18","objectID":"/leetcode/1627/:0:0","tags":null,"title":"1627：带阈值的图连通性（★★★）","uri":"/leetcode/1627/"},{"categories":null,"content":"题目 有 n 座城市，编号从 1 到 n 。编号为 x 和 y 的两座城市直接连通的前提是： x 和 y 的公因数中，至少有一个 严格大于 某个阈值 threshold 。更正式地说，如果存在整数 z ，且满足以下所有条件，则编号 x 和 y 的城市之间有一条道路： x % z == 0\ry % z == 0\rz \u003e threshold\r给你两个整数 n 和 threshold ，以及一个待查询数组，请你判断每个查询 queries[i] = [ai, bi] 指向的城市 ai 和 bi 是否连通（即，它们之间是否存在一条路径）。 返回数组 answer ，其中answer.length ==","date":"2020-10-18","objectID":"/leetcode/1627/:1:0","tags":null,"title":"1627：带阈值的图连通性（★★★）","uri":"/leetcode/1627/"},{"categories":null,"content":"分析 关于连通的问题容易想到并查集。遍历大于 threshold 的数 i，将所有是 i 的倍数的编号连通即可。 如果 i 已经被连通过，就可以直接跳过，以节省时间。 ","date":"2020-10-18","objectID":"/leetcode/1627/:2:0","tags":null,"title":"1627：带阈值的图连通性（★★★）","uri":"/leetcode/1627/"},{"categories":null,"content":"解答 def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -\u003e List[bool]: def find(i): if p[i] != i: p[i] = find(p[i]) return p[i] def union(i, j): p[find(i)] = find(j) p, vis = list(range(n+1)), set() for i in range(threshold+1, n+1): if i not in vis: for j in range(i+i, n+1, i): v","date":"2020-10-18","objectID":"/leetcode/1627/:3:0","tags":null,"title":"1627：带阈值的图连通性（★★★）","uri":"/leetcode/1627/"},{"categories":null,"content":" 力扣第 210 场周赛第 1 题 ","date":"2020-10-11","objectID":"/leetcode/1614/:0:0","tags":null,"title":"1614：括号的最大嵌套深度","uri":"/leetcode/1614/"},{"categories":null,"content":"题目 如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）： 字符串是一个空字符串 \"\"，或者是一个不为 \"(\" 或 \")\" 的单字符。\r字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。\r字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。\r类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)： depth(\"\") = 0\rdepth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 \"(\" 或者 \")\"\rdepth(A + B) = max(","date":"2020-10-11","objectID":"/leetcode/1614/:1:0","tags":null,"title":"1614：括号的最大嵌套深度","uri":"/leetcode/1614/"},{"categories":null,"content":"分析 ","date":"2020-10-11","objectID":"/leetcode/1614/:2:0","tags":null,"title":"1614：括号的最大嵌套深度","uri":"/leetcode/1614/"},{"categories":null,"content":"#1 用栈判断有效括号时，根据栈的长度即可得到每个括号所处的深度。最大的即是 s 的嵌套深度。 def maxDepth(self, s: str) -\u003e int: res, stack = 0, [] for char in s: if char == '(': stack.append(char) res = max(res, len(stack)) elif char == ')': stack.pop() return res 24 ms ","date":"2020-10-11","objectID":"/leetcode/1614/:2:1","tags":null,"title":"1614：括号的最大嵌套深度","uri":"/leetcode/1614/"},{"categories":null,"content":"#2 注意到过程中其实只关心栈的长度。所以可以用一个变量来维护，而无需真正地进行栈操作。 ","date":"2020-10-11","objectID":"/leetcode/1614/:2:2","tags":null,"title":"1614：括号的最大嵌套深度","uri":"/leetcode/1614/"},{"categories":null,"content":"解答 def maxDepth(self, s: str) -\u003e int: res, size = 0, 0 for char in s: size += 1 if char == '(' else -1 if char == ')' else 0 res = max(res, size) return res 32 ms ","date":"2020-10-11","objectID":"/leetcode/1614/:3:0","tags":null,"title":"1614：括号的最大嵌套深度","uri":"/leetcode/1614/"},{"categories":null,"content":"栈是一个后入先出的数据结构，插入和删除都在末尾进行。python 中一般直接用 list 表示。 队列是一个先入先出的数据结构，插入在末尾，删除在开头。python 中一般直接用内置库 deque 表示。 额外地，dfs 常借助栈实现，bfs 常借助队列实现，这里先不涉及。 ","date":"2020-10-11","objectID":"/algorithm-stack/:0:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"1 基础 ","date":"2020-10-11","objectID":"/algorithm-stack/:1:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"1.1 设计 0225 用队列实现栈 0232 用栈实现队列 0622 设计循环队列 0641 设计循环双端队列 ","date":"2020-10-11","objectID":"/algorithm-stack/:1:1","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"1.2 应用 0071 简化路径 0150 逆波兰表达式求值 0682 棒球比赛 0946 验证栈序列 1441 用栈操作构建数组 ","date":"2020-10-11","objectID":"/algorithm-stack/:1:2","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"2 进阶 ","date":"2020-10-11","objectID":"/algorithm-stack/:2:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"2.1 设计 0155 最小栈 0341 扁平化嵌套列表迭代器 0895 最大频率栈 1381 设计一个支持增量操作的栈 ","date":"2020-10-11","objectID":"/algorithm-stack/:2:1","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"2.2 应用 0385 迷你语法分析器 0394 字符串解码 0636 函数的独占时间 0735 行星碰撞 0880 索引处的解码字符串 ","date":"2020-10-11","objectID":"/algorithm-stack/:2:2","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"3 挑战 0224 基本计算器 0227 基本计算器 II 0726 原子的数量 0770 基本计算器 IV ","date":"2020-10-11","objectID":"/algorithm-stack/:3:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"*4 括号系列 ","date":"2020-10-11","objectID":"/algorithm-stack/:4:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"4.1 基础 0020 有效的括号 1021 删除最外层的括号 1249 移除无效的括号 0921 使括号有效的最少添加 1614 括号的最大嵌套深度 ","date":"2020-10-11","objectID":"/algorithm-stack/:4:1","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"4.2 进阶 0032 最长有效括号 0301 删除无效的括号 0856 括号的分数 1111 有效括号的嵌套深度 1190 反转每对括号间的子串 ","date":"2020-10-11","objectID":"/algorithm-stack/:4:2","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"4.3 挑战 0678 有效的括号字符串 1541 平衡括号字符串的最少插入次数 ","date":"2020-10-11","objectID":"/algorithm-stack/:4:3","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"在某个地方有一位旅人。她的名字叫伊蕾娜。\n她是年纪轻轻就成为了最上位的“魔女”的才女。\n憧憬着小时候读过的旅行的故事，\n顺其自然地持续着随心所欲的长途旅行。\n在广大的世界里自由地穿行 ，遇见莫名其妙、可笑的人，\n或是见证到某人的美丽的日常，\n她作为旅人，也没有什么目的，\n重复着和各种各样的国家和人的相遇。\n以及相同数量的——\n\n“请别管我。我就是个旅人，\n必须赶路了。”\n这样的魔女伊蕾娜所编织的离别的物语。","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"简介 在某个地方有一位旅人。她的名字叫伊蕾娜。 她是年纪轻轻就成为了最上位的“魔女”的才女。 憧憬着小时候读过的旅行的故事， 顺其自然地持续着随心所欲的长途旅行。 在广大的世界里自由地穿行 ，遇见莫名其妙、可笑的人， 或是见证到某人的美丽的日常， 她作为旅人，也没有什么目的， 重复着和各种各样的国家和人的相遇。 以及相同数量的—— “请别管我。我就是个旅人， 必须赶路了。” 这样的魔女伊蕾娜所编织的离别的物语。 制作人员： 原作：白石定规 导演：洼冈俊之 脚本：笔安一幸 分镜：平池芳正、板井宽树、高桥顺、西野武志、博多正寿 ","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/:1:0","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊蕾娜 灰之魔女、Elaina、灰の魔女 女 本渡楓 2 芙兰 星尘魔女、Fran、星屑の魔女 女 花澤香菜 3 沙耶 炭之魔女、炭の魔女、Saya 女 黒沢ともよ 4 アムネシア 女 小原好美 5 席拉 Sheila 女 日笠陽子 6 米菈罗赛 女 Lynn 7 艾赫米娅 女 佐藤利奈 8 维多利加 ニケ、妮可、维多莉佳、Vikutorika 女 伊藤静 ","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/:2:0","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔女之旅 2020-10-02 12 bilibili ","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/:3:0","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"MAD ","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/:4:0","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"哈希表是针对查询，空间换时间的一种数据结构，一般能够在 O(1) 时间内插入、查询、删除元素， 但不能通过下标访问元素。 哈希表分为哈希集合和哈希映射，哈希集合存储非重复值，哈希映射存储 key 唯一的 (key,value) 对。 python 中一般直接用内置库 set 和 dict 表示哈希集合和哈希映射。 另外还有一些特定用途的内置库，比如 Counter, defaultdict, OrderedDict。 ","date":"2020-10-01","objectID":"/algorithm-hash/:0:0","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1 基础 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:0","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.1 设计 0705 设计哈希集合 0706 设计哈希映射 0535 设计哈希映射 TinyURL 的加密与解密 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:1","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.2 哈希集合 0217 存在重复元素 0349 两个数组的交集 0500 键盘行 0575 分糖果 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:2","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.3 哈希映射 0001 两数之和 0205 同构字符串 0219 存在重复元素 II 0599 两个列表的最小索引总和 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:3","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.4 设计键 0036 有效的数独 0049 字母异位词分组 0318 最大单词长度乘积 0676 实现一个魔法字典 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:4","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.5 Counter 0350 两个数组的交集 II 0409 最长回文串 0532 数组中的 k-diff 数对 0594 最长和谐子序列 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:5","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"2 进阶 ","date":"2020-10-01","objectID":"/algorithm-hash/:2:0","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"2.1 设计 0146 LRU 缓存机制 0380 常数时间插入、删除和获取随机元素 0381 O(1) 时间插入、删除和获取随机元素 - 允许重复 ","date":"2020-10-01","objectID":"/algorithm-hash/:2:1","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"2.2 应用 0015 三数之和 0299 猜数字游戏 0447 回旋镖的数量 0454 四数相加 II 0554 砖墙 ","date":"2020-10-01","objectID":"/algorithm-hash/:2:2","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"3 挑战 ","date":"2020-10-01","objectID":"/algorithm-hash/:3:0","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"3.1 设计 0432 全 O(1) 的数据结构 0460 LFU 缓存 0710 黑名单中的随机数 ","date":"2020-10-01","objectID":"/algorithm-hash/:3:1","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"3.2 应用 0149 直线上最多的点数 0166 分数到小数 0336 回文对 1178 猜字谜 ","date":"2020-10-01","objectID":"/algorithm-hash/:3:2","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":" 力扣第 208 场周赛第 1 题 ","date":"2020-09-27","objectID":"/leetcode/1598/:0:0","tags":null,"title":"1598：文件夹操作日志搜集器","uri":"/leetcode/1598/"},{"categories":null,"content":"题目 每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。 下面给出对变更操作的说明： \"../\" ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。\r\"./\" ：继续停留在当前文件夹。\r\"x/\" ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。\r给你一个字符串列表 logs ，其中 logs[i] 是用户在 ith 步执行的操作。 文件系统启动时位于主文件夹，然后执行 logs 中的操作。 执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。 示例 1： 输入：logs = [\"d1/\",\"d2/\",","date":"2020-09-27","objectID":"/leetcode/1598/:1:0","tags":null,"title":"1598：文件夹操作日志搜集器","uri":"/leetcode/1598/"},{"categories":null,"content":"分析 用栈保存目录，最后返回栈的长度即可。 ","date":"2020-09-27","objectID":"/leetcode/1598/:2:0","tags":null,"title":"1598：文件夹操作日志搜集器","uri":"/leetcode/1598/"},{"categories":null,"content":"解答 def minOperations(self, logs: List[str]) -\u003e int: stack = [] for log in logs: if log == '../': if stack: stack.pop() elif log != './': stack.append(log) return len(stack) 40 ms ","date":"2020-09-27","objectID":"/leetcode/1598/:3:0","tags":null,"title":"1598：文件夹操作日志搜集器","uri":"/leetcode/1598/"},{"categories":null,"content":"字符串和数组很相似，具有索引，且元素在内存中是连续存储的。不同的是： 字符串更关心整体或子串，而非单个元素。 字符串可以整体比较，还可以按字典序等来排序。 python 中的字符串是不可变的，不能直接修改、添加、删除元素，而应该用切片。 经典的问题有： 字符串匹配，常用 KMP算法、正则表达式。 回文串，常用 Manacher 算法。 额外的，还常用 字典树 解决多字符串匹配问题，这里暂不涉及 ","date":"2020-09-21","objectID":"/algorithm-string/:0:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"1 基础 0009 回文数 0165 比较版本号 0392 判断子序列 0831 隐藏个人信息 1169 查询无效交易 ","date":"2020-09-21","objectID":"/algorithm-string/:1:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"2 进阶 0068 文本左右对齐 0393 UTF-8 编码验证 0459 重复的子字符串 0686 重复叠加字符串匹配 0833 字符串中的查找与替换 ","date":"2020-09-21","objectID":"/algorithm-string/:2:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"3 挑战 0564 寻找最近的回文数 0866 回文素数 ","date":"2020-09-21","objectID":"/algorithm-string/:3:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"4 正则表达式 0008 字符串转换整数 (atoi) 0044 通配符匹配 0065 有效数字 1023 驼峰式匹配 ","date":"2020-09-21","objectID":"/algorithm-string/:4:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"*5 字符串匹配 0005 最长回文子串 0028 实现 strStr() 0214 最短回文串 1392 最长快乐前缀 ","date":"2020-09-21","objectID":"/algorithm-string/:5:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":" 力扣第 35 场双周赛第 4 题 ","date":"2020-09-19","objectID":"/leetcode/1591/:0:0","tags":null,"title":"1591：奇怪的打印机 II（★★★）","uri":"/leetcode/1591/"},{"categories":null,"content":"题目 给你一个奇怪的打印机，它有如下两个特殊的打印规则： 每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。 一旦矩形根据上面的规则使用了一种颜色，那么 相同的颜色不能再被使用 。 给你一个初始没有颜色的 m x n 的矩形 targetGrid ，其中 targetGrid[row][col] 是位置 (row, col) 的颜色。 如果你能按照上述规则打印出矩形 targetGrid ，请你返回 true ，否则返回 false 。 示例 1： 输入：targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1","date":"2020-09-19","objectID":"/leetcode/1591/:1:0","tags":null,"title":"1591：奇怪的打印机 II（★★★）","uri":"/leetcode/1591/"},{"categories":null,"content":"分析 一种颜色只能打印一次，因此每种颜色打印的矩形必然包括了该颜色的所有点。 因此，某种颜色所有点的边界即对应了打印的矩形（更大没有意义）。确定了每种颜色的打印矩形，问题只在于打印顺序。 假如某个颜色 c 的矩形包含了其它颜色 c2，那么 c 必须在 c2 之前打印。如果不包含其它颜色，那么 c 可以最后打印。 于是转为拓扑排序问题，判断是否存在拓扑顺序即可。 ","date":"2020-09-19","objectID":"/leetcode/1591/:2:0","tags":null,"title":"1591：奇怪的打印机 II（★★★）","uri":"/leetcode/1591/"},{"categories":null,"content":"解答 def isPrintable(self, targetGrid: List[List[int]]) -\u003e bool: m, n = len(targetGrid), len(targetGrid[0]) d = defaultdict(lambda: defaultdict(set)) for i, j in product(range(m), range(n)): c = targetGrid[i][j] d[c]['X'].add(i) d[c]['Y'].add(j) nxt, indeg = defaultdict(set), defaultdict(int) for c in","date":"2020-09-19","objectID":"/leetcode/1591/:3:0","tags":null,"title":"1591：奇怪的打印机 II（★★★）","uri":"/leetcode/1591/"},{"categories":null,"content":" 力扣第 206 场周赛第 3 题 ","date":"2020-09-13","objectID":"/leetcode/1584/:0:0","tags":null,"title":"1584：连接所有点的最小费用（★★）","uri":"/leetcode/1584/"},{"categories":null,"content":"题目 给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。 请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。 示例 1： 输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\r输出：20\r解释：\r我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。\r注意到任意两个点之间只","date":"2020-09-13","objectID":"/leetcode/1584/:1:0","tags":null,"title":"1584：连接所有点的最小费用（★★）","uri":"/leetcode/1584/"},{"categories":null,"content":"分析 典型的最小生成树问题，按费用排序，依次判断是否添加边即可。 ","date":"2020-09-13","objectID":"/leetcode/1584/:2:0","tags":null,"title":"1584：连接所有点的最小费用（★★）","uri":"/leetcode/1584/"},{"categories":null,"content":"解答 def minCostConnectPoints(self, points: List[List[int]]) -\u003e int: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def cal(p1, p2): return abs(p1[0]-p2[0])+abs(p1[1]-p2[1]) n = len(points) A = [[cal(points[i], points[j]), i, j] for i in range(n) for j i","date":"2020-09-13","objectID":"/leetcode/1584/:3:0","tags":null,"title":"1584：连接所有点的最小费用（★★）","uri":"/leetcode/1584/"},{"categories":null,"content":"链表和数组是最基本的数据结构，是其他数据结构的基础。 链表和数组都是线性结构，但在内存中，数组的元素是连续的，而链表不是。 所以链表是把一些分离独立的元素按引用链接到一起。 链表能在 O(1) 时间插入、删除元素，但需要 O(N) 时间访问到元素，与数组相反。 python 中的内置库 deque 即是用双向链表实现的。 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:0:0","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"1 基础 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:1:0","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"1.1 设计 0707 设计链表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:1:1","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"1.2 操作 0002 两数相加 0024 两两交换链表中的节点 0082 删除排序链表中的重复元素 II 0237 删除链表中的节点 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:1:2","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"2 进阶 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:2:0","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"2.1 操作 0061 旋转链表 0086 分隔链表 0328 奇偶链表 0725 分隔链表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:2:1","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"2.2 快慢指针 0019 删除链表的倒数第 N 个结点 0141 环形链表 0142 环形链表 II 0160 相交链表 0876 链表的中间结点 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:2:2","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"2.3 排序 0021 合并两个有序链表 0023 合并K个升序链表 0147 对链表进行插入排序 0148 排序链表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:2:3","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"3 挑战 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:3:0","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"3.1 设计 0138 复制带随机指针的链表 0430 扁平化多级双向链表 0432 全 O(1) 的数据结构 1206 设计跳表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:3:1","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"3.2 操作 0206 反转链表 0092 反转链表 II 0025 K 个一组翻转链表 0143 重排链表 0234 回文链表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:3:2","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"链表和数组是最基本的数据结构，是其他数据结构的基础。 数组和链表的区别 数组和链表都是线性数据结构，区别在于数组具有索引，数组中的元素在内存中是连续存储的。 数组能在 O(1) 时间内访问到元素，但需要 O(N) 时间插入、删除元素，与链表相反。 数组相关的数据结构 基本的 栈、堆 可以用数组表示以外 一些进阶的数据结构比如 并查集、树状数组、 线段树 也可以用数组来表示 数组可以嵌套数组，得到多维数组 数组相关的算法（现在暂不涉及） 有序数组常和 排序、二分查找、 双指针 相关 二维数组常和 dfs、bfs 相关 子数组/子序列常和 滑动窗口、 动态规划 相关 区间计算常和 前缀和、树状数组","date":"2020-09-01","objectID":"/algorithm-array/:0:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":"1 基础 0080 删除排序数组中的重复项 II 0283 移动零 0448 找到所有数组中消失的数字 0485 最大连续 1 的个数 0724 寻找数组的中心下标 ","date":"2020-09-01","objectID":"/algorithm-array/:1:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":"2 进阶 0075 颜色分类 0128 最长连续序列 0189 旋转数组 0238 除自身以外数组的乘积 ","date":"2020-09-01","objectID":"/algorithm-array/:2:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":"3 挑战 0041 缺失的第一个正数 0284 顶端迭代器 0287 寻找重复数 ","date":"2020-09-01","objectID":"/algorithm-array/:3:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":"*4 二维数组 0048 旋转图像 0054 螺旋矩阵 0059 螺旋矩阵 II 0073 矩阵置零 0289 生命游戏 0463 岛屿的周长 0835 图像重叠 1992 找到所有的农场组 ","date":"2020-09-01","objectID":"/algorithm-array/:4:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":" 力扣第 204 场周赛第 3 题 ","date":"2020-08-30","objectID":"/leetcode/1568/:0:0","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"题目 给你一个大小为 m x n ，由若干 0 和 1 组成的二维网格 grid ，其中 1 表示陆地， 0 表示水。岛屿 由水平方向或竖直方向上相邻的 1 （陆地）连接形成。 如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。 一天内，可以将 任何单个 陆地单元（1）更改为水单元（0）。 返回使陆地分离的最少天数。 示例 1： 输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\r输出：2\r解释：至少需要 2 天才能得到分离的陆地。\r将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。\r示例 2： 输入","date":"2020-08-30","objectID":"/leetcode/1568/:1:0","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"分析 ","date":"2020-08-30","objectID":"/leetcode/1568/:2:0","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"#1 观察发现，只要岛屿有对角相连的网格，那么将该 2x2 的区域内的其它网格置 0，即可让岛屿分离。 因此最多需要两天。那么： 假如一开始就没有岛屿或者多个岛屿，返回 0\r遍历岛屿网格，若置为 0 后岛屿分离，返回 1\r其它情况，返回 2 计算岛屿数量，用并查集即可。 def minDays(self, grid: List[List[int]]) -\u003e int: def find(x): if f.setdefault(x,x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def cal","date":"2020-08-30","objectID":"/leetcode/1568/:2:1","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"#2 找某个岛屿网格，使得去掉后岛屿分离，这其实就是找无向图的割点，可以用 tarjan 算法。 注意特殊情况，岛屿只有一个网格时，没有割点，但只需要 1 天 ","date":"2020-08-30","objectID":"/leetcode/1568/:2:2","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"解答 def minDays(self, grid: List[List[int]]) -\u003e int: def find(x): if f.setdefault(x,x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def cal(A): f.clear() for i, j in A: for x, y in [(i-1, j), (i, j-1), (i+1, j), (i, j+1)]: if (x, y) in A: union((i, j), (x, y)) return len(","date":"2020-08-30","objectID":"/leetcode/1568/:3:0","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":" 力扣第 203 场周赛第 4 题 ","date":"2020-08-23","objectID":"/leetcode/1563/:0:0","tags":null,"title":"1563：石子游戏 V（★★）","uri":"/leetcode/1563/"},{"categories":null,"content":"题目 几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。 游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。 只 剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。 返回 Alice 能够获得的最大分数 。 示例 1： 输入：stoneValue = [6,2,3,4,5,5]\r输出：18\r解释：在第","date":"2020-08-23","objectID":"/leetcode/1563/:1:0","tags":null,"title":"1563：石子游戏 V（★★）","uri":"/leetcode/1563/"},{"categories":null,"content":"分析 ","date":"2020-08-23","objectID":"/leetcode/1563/:2:0","tags":null,"title":"1563：石子游戏 V（★★）","uri":"/leetcode/1563/"},{"categories":null,"content":"#1 依然考虑递归。令辅助函数 help(A) 代表在数组 A 玩游戏 Alice 能得到的最大分数。 假设 Alice 在 i 处分割，即分为 A[:i] 和 A[i:]，根据两个子数组的和的大小，可转为不同的递归子问题。\r若 sum(A[:i]) \u003c sum(A[i:])，此时 Alice 能获得的最大分数为 sum(A[:i])+help(A[:i])\r若 sum(A[:i]) \u003e sum(A[i:])，此时 Alice 能获得的最大分数为 sum(A[i:])+help(A[i:])\r若 sum(A[:i]) == sum(A[i:])，此时 Alice 能获得的最大分数为 sum(A","date":"2020-08-23","objectID":"/leetcode/1563/:2:1","tags":null,"title":"1563：石子游戏 V（★★）","uri":"/leetcode/1563/"},{"categories":null,"content":"#2 ","date":"2020-08-23","objectID":"/leetcode/1563/:2:2","tags":null,"title":"1563：石子游戏 V（★★）","uri":"/leetcode/1563/"},{"categories":null,"content":"解答 ","date":"2020-08-23","objectID":"/leetcode/1563/:3:0","tags":null,"title":"1563：石子游戏 V（★★）","uri":"/leetcode/1563/"},{"categories":null,"content":" 力扣第 33 场双周赛第 2 题 ","date":"2020-08-22","objectID":"/leetcode/1557/:0:0","tags":null,"title":"1557：可以到达所有点的最少点数目（★）","uri":"/leetcode/1557/"},{"categories":null,"content":"题目 给你一个 有向无环图 ， n 个节点编号为 0 到 n-1 ，以及一个边数组 edges ，其中 edges[i] = [fromi, toi] 表示一条从点 fromi 到点 toi 的有向边。 找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。 你可以以任意顺序返回这些节点编号。 示例 1： 输入：n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\r输出：[0,3]\r解释：从单个节点出发无法到达所有节点。从 0 出发我们可以到达 [0,1,2,5] 。从 3 出发我们可以到达 [3,4,2,5] 。所以我们输出 [0,3]","date":"2020-08-22","objectID":"/leetcode/1557/:1:0","tags":null,"title":"1557：可以到达所有点的最少点数目（★）","uri":"/leetcode/1557/"},{"categories":null,"content":"分析 显然入度为 0 的节点无法由其他节点到达，所以必须在结果点集中。入度不为 0 的节点可以由其它节点到达，因此不需要添加。 所以返回所有入度为 0 的节点即可。 ","date":"2020-08-22","objectID":"/leetcode/1557/:2:0","tags":null,"title":"1557：可以到达所有点的最少点数目（★）","uri":"/leetcode/1557/"},{"categories":null,"content":"解答 def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -\u003e List[int]: Set = set(b for _, b in edges) return [i for i in range(n) if i not in Set] 124 ms ","date":"2020-08-22","objectID":"/leetcode/1557/:3:0","tags":null,"title":"1557：可以到达所有点的最少点数目（★）","uri":"/leetcode/1557/"},{"categories":null,"content":" 力扣第 201 场周赛第 1 题 ","date":"2020-08-09","objectID":"/leetcode/1544/:0:0","tags":null,"title":"1544：整理字符串","uri":"/leetcode/1544/"},{"categories":null,"content":"题目 给你一个由大小写英文字母组成的字符串 s 。 一个整理好的字符串中，两个相邻字符 s[i] 和 s[i+1]，其中 0\u003c= i \u003c= s.length-2 ，要满足如下条件: 若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。\r若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。\r请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。 请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。 注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。 示例 1： 输入：s = ","date":"2020-08-09","objectID":"/leetcode/1544/:1:0","tags":null,"title":"1544：整理字符串","uri":"/leetcode/1544/"},{"categories":null,"content":"分析 类似 1047 ，只不过删除条件从重复变成了大小写对应。 ","date":"2020-08-09","objectID":"/leetcode/1544/:2:0","tags":null,"title":"1544：整理字符串","uri":"/leetcode/1544/"},{"categories":null,"content":"解答 def makeGood(self, s: str) -\u003e str: stack = [] for char in s: if stack and abs(ord(stack[-1])-ord(char)) == 32: stack.pop() else: stack.append(char) return ''.join(stack) 32 ms ","date":"2020-08-09","objectID":"/leetcode/1544/:3:0","tags":null,"title":"1544：整理字符串","uri":"/leetcode/1544/"},{"categories":null,"content":" 力扣第 32 场双周赛第 3 题 ","date":"2020-08-08","objectID":"/leetcode/1541/:0:0","tags":null,"title":"1541：平衡括号字符串的最少插入次数（★）","uri":"/leetcode/1541/"},{"categories":null,"content":"题目 给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足： 任何左括号 '(' 必须对应两个连续的右括号 '))' 。\r左括号 '(' 必须在对应的连续两个右括号 '))' 之前。\r比方说 \"())\"， \"())(())))\" 和 \"(())())))\" 都是平衡的， \")()\"， \"()))\" 和 \"(()))\" 都是不平衡的。 你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。 请你返回让 s 平衡的最少插入次数。 示例 1： 输入：s = \"(()))\"\r输出：1\r解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右","date":"2020-08-08","objectID":"/leetcode/1541/:1:0","tags":null,"title":"1541：平衡括号字符串的最少插入次数（★）","uri":"/leetcode/1541/"},{"categories":null,"content":"分析 ","date":"2020-08-08","objectID":"/leetcode/1541/:2:0","tags":null,"title":"1541：平衡括号字符串的最少插入次数（★）","uri":"/leetcode/1541/"},{"categories":null,"content":"#1 1249 的升级版，只不过需要考虑更多情况。 顺序遍历遇到 ')' 时，假如 ')' 无效，前面必须执行一次添加 '(' 的操作。\r假如 ')' 后面不是 ')'，还需要执行一次添加 ')' 的操作。\r假如 ')' 后面是 ')'，需要跳过该 ')'\r最终剩下的无效 '('，每个必须执行两次添加 ')' 的操作。\rdef minInsertions(self, s: str) -\u003e int: res, stack, i = 0, [], 0 while i \u003c len(s): if s[i] == '(': stack.append('(') else: if not stack: re","date":"2020-08-08","objectID":"/leetcode/1541/:2:1","tags":null,"title":"1541：平衡括号字符串的最少插入次数（★）","uri":"/leetcode/1541/"},{"categories":null,"content":"#2 注意到过程中其实只关心栈的长度。所以可以用一个变量来维护，而无需真正地进行栈操作。 ","date":"2020-08-08","objectID":"/leetcode/1541/:2:2","tags":null,"title":"1541：平衡括号字符串的最少插入次数（★）","uri":"/leetcode/1541/"},{"categories":null,"content":"解答 def minInsertions(self, s: str) -\u003e int: res, size, i = 0, 0, 0 while i \u003c len(s): size += 1 if s[i] == '(' else -1 if size \u003c 0: res, size = res + 1, 0 if s[i] == ')': if i \u003c len(s)-1 and s[i+1] == ')': i += 1 else: res += 1 i += 1 return res + 2*size 216 ms ","date":"2020-08-08","objectID":"/leetcode/1541/:3:0","tags":null,"title":"1541：平衡括号字符串的最少插入次数（★）","uri":"/leetcode/1541/"},{"categories":null,"content":" 力扣第 200 场周赛第 2 题 ","date":"2020-08-02","objectID":"/leetcode/1535/:0:0","tags":null,"title":"1535：找出数组游戏的赢家（★）","uri":"/leetcode/1535/"},{"categories":null,"content":"题目 给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。 每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。 返回赢得比赛的整数。 题目数据 保证 游戏存在赢家。 示例 1： 输入：arr = [2,1,3,5,4,6,7], k = 2\r输出：5\r解释：一起看一下本场游戏每回合的情况：\r因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。\r示例","date":"2020-08-02","objectID":"/leetcode/1535/:1:0","tags":null,"title":"1535：找出数组游戏的赢家（★）","uri":"/leetcode/1535/"},{"categories":null,"content":"分析 显然第 i 回合比较的是 arr[i] 和上一回合的胜者，所以每一回合的胜者可以递推得到，记录连胜次数即可。 注意边界条件，第 len(arr)-1 回合的胜者必然是 max(arr)，后面必然一直赢，无需再递推了。 ","date":"2020-08-02","objectID":"/leetcode/1535/:2:0","tags":null,"title":"1535：找出数组游戏的赢家（★）","uri":"/leetcode/1535/"},{"categories":null,"content":"解答 def getWinner(self, arr: List[int], k: int) -\u003e int: pre, cnt = arr[0], 0 for i in range(1, len(arr)): if arr[i] \u003c pre: cnt += 1 else: pre, cnt = arr[i], 1 if cnt==k: return pre return pre 92 ms ","date":"2020-08-02","objectID":"/leetcode/1535/:3:0","tags":null,"title":"1535：找出数组游戏的赢家（★）","uri":"/leetcode/1535/"},{"categories":null,"content":"上古时期妖兽纵横，一位神秘道人分别授予了阴阳五行的特殊能力给金木水火土五个家族来抵抗妖兽。他们将妖兽驱赶到神隐雾山之中，设立结界。雾山之中另有强大灵力的麒麟兽常常吸引来那些想要提升妖力突破结界，因此自愿被封印于巨阙神盾之中。火行使者闻人翊悬为救其母私自打开了巨阙神盾，小麒麟趁机偷溜出来，妖兽界将掀起一股腥风血雨……","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":"简介 上古时期妖兽纵横，一位神秘道人分别授予了阴阳五行的特殊能力给金木水火土五个家族来抵抗妖兽。他们将妖兽驱赶到神隐雾山之中，设立结界。雾山之中另有强大灵力的麒麟兽常常吸引来那些想要提升妖力突破结界，因此自愿被封印于巨阙神盾之中。火行使者闻人翊悬为救其母私自打开了巨阙神盾，小麒麟趁机偷溜出来，妖兽界将掀起一股腥风血雨…… 制作人员： 导演：林魂 製作：bilibili ","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/:1:0","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 闻人翊悬 男 郭盛 2 嗔兽孔雀 男（人形状态） 郝祥海 3 苏小安 女 阎么么 4 白义 男 刘琮 5 申屠子夜 水行 男 郝祥海 6 山子 男 宝木中阳 7 渠黄 男 陈喆 8 水冠 林魂 ","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/:2:0","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 雾山五行 2020-07-26 3 bilibili ","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/:3:0","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":"MAD ","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/:4:0","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":" 力扣第 197 场周赛第 3 题 ","date":"2020-07-12","objectID":"/leetcode/1514/:0:0","tags":null,"title":"1514：概率最大的路径（★★）","uri":"/leetcode/1514/"},{"categories":null,"content":"题目 给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。 指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。 如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。 示例 1： 输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5","date":"2020-07-12","objectID":"/leetcode/1514/:1:0","tags":null,"title":"1514：概率最大的路径（★★）","uri":"/leetcode/1514/"},{"categories":null,"content":"分析 类似于最短路，只不过权重从相加改为了相乘，依然可以用 dijkstra 算法。 python 自带的是小顶堆，因此将初始权重设为 -1，最终结果再取反即可。 ","date":"2020-07-12","objectID":"/leetcode/1514/:2:0","tags":null,"title":"1514：概率最大的路径（★★）","uri":"/leetcode/1514/"},{"categories":null,"content":"解答 def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -\u003e float: nxt = defaultdict(list) for (u, v), w in zip(edges, succProb): nxt[u].append((v, w)) nxt[v].append((u, w)) d, pq = {}, [(-1, start)] while pq: w, u = heappop(pq) if u == end: return -w ","date":"2020-07-12","objectID":"/leetcode/1514/:3:0","tags":null,"title":"1514：概率最大的路径（★★）","uri":"/leetcode/1514/"},{"categories":null,"content":" 力扣第 30 场双周赛第 4 题 ","date":"2020-07-11","objectID":"/leetcode/1510/:0:0","tags":null,"title":"1510：石子游戏 IV（★）","uri":"/leetcode/1510/"},{"categories":null,"content":"题目 Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。 一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。 如果石子堆里没有石子了，则无法操作的玩家输掉游戏。 给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。 示例 1： 输入：n = 1\r输出：true\r解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。\r示例 2： 输入：n = 2\r输出：false\r解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个","date":"2020-07-11","objectID":"/leetcode/1510/:1:0","tags":null,"title":"1510：石子游戏 IV（★）","uri":"/leetcode/1510/"},{"categories":null,"content":"分析 依然是考虑递归，递推式很显然： help(n) = any(not help(n-i*i) for i in range(1, int(sqrt(n))+1))\r遍历 i 时可以反序，以提前排除 n 是平方数的情况。 ","date":"2020-07-11","objectID":"/leetcode/1510/:2:0","tags":null,"title":"1510：石子游戏 IV（★）","uri":"/leetcode/1510/"},{"categories":null,"content":"解答 @lru_cache(None) def winnerSquareGame(self, n: int) -\u003e bool: if n==0: return False return any(not self.winnerSquareGame(n-i*i) for i in range(int(sqrt(n)), 0, -1)) 324 ms ","date":"2020-07-11","objectID":"/leetcode/1510/:3:0","tags":null,"title":"1510：石子游戏 IV（★）","uri":"/leetcode/1510/"},{"categories":null,"content":" 力扣第 195 场周赛第 4 题 ","date":"2020-06-28","objectID":"/leetcode/1499/:0:0","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"题目 给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 points[i] = [xi, yi] ，并且在 1 \u003c= i \u003c j \u003c= points.length 的前提下， xi \u003c xj 总成立。 请你找出 yi + yj + |xi - xj| 的 最大值，其中 |xi - xj| \u003c= k 且 1 \u003c= i \u003c j \u003c= points.length。 题目测试数据保证至少存在一对能够满足 |xi - xj| \u003c= k 的点。 示例 1： 输入：points = [[1,3],[2,0],[5,10],[","date":"2020-06-28","objectID":"/leetcode/1499/:1:0","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"分析 ","date":"2020-06-28","objectID":"/leetcode/1499/:2:0","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"#1 显然可以遍历 j，然后在满足 xj-k\u003c=xi\u003cxj 的 i 中，找最大的 yi-xi。 那么是典型的滑动窗口问题，而维护 yi-xi 的最大值则可以用有序集合。 def findMaxValueOfEquation(self, points: List[List[int]], k: int) -\u003e int: from sortedcontainers import SortedList sl = SortedList() res, i = float('-inf'), 0 for j, (x, y) in enumerate(points): while points[i][0]\u003cx-","date":"2020-06-28","objectID":"/leetcode/1499/:2:1","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"#2 还可以用单调队列维护窗口的最大值。 ","date":"2020-06-28","objectID":"/leetcode/1499/:2:2","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"解答 def findMaxValueOfEquation(self, points: List[List[int]], k: int) -\u003e int: res, queue = float('-inf'), deque() for x, y in points: while queue and queue[0][0]\u003cx-k: queue.popleft() if queue: res = max(res, queue[0][1]+x+y) while queue and queue[-1][1]\u003c=y-x: queue.pop() queue.append((x, y-x)) return","date":"2020-06-28","objectID":"/leetcode/1499/:3:0","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"2018年10月，Google 发布 BERT 模型，然后 BERT 横扫了 NLP 的各个任务： 文本分类、序列标注、文本摘要、信息检索、问答系统、阅读理解等等。 到如今，BERT 及其变种几乎一统了 NLU（Natural Language Understanding，自然语言理解）领域， 只有 GPT 模型依托 NLG（Natural Language Generation，自然语言生成）领域能与之周旋。 而细究下来，GPT 与 BERT 的结构其实只有一处不同。 不夸张地说，这是属于 BERT 的时代。因此，本文对 BERT 及其之后的发展作一个粗略的小结，以供参考。 ","date":"2020-06-21","objectID":"/nlp-bert_family/:0:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"BERT：一切之始 BERT，全称 Bidirectional Encoder Representation from Transformers， 融合了前辈 GPT 和 ELMO 的优点，是 NLP 模型的一个里程碑。 BERT 模型结构 BERT的核心特点在于： 1）两阶段的预训练过程。第一阶段利用语言模型进行预训练；第二阶段是迁移学习， 将预训练网络结构中的高层特征用于下游任务，进行微调。与以前的 Word2Vec 的区别在于， 下游任务不仅利用了预训练网络的 Word Embedding 层，还利用了更高层的特征。这个结构来源于 GPT； 2）采用 双向的 Transformer 提取","date":"2020-06-21","objectID":"/nlp-bert_family/:1:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"后 BERT 时代：八仙过海 BERT 点燃了 NLP 的新一轮热潮，各大公司开始堆人堆钱各显神通，不断刷新热点。其中的进展可以粗略地分为三个方向。 ","date":"2020-06-21","objectID":"/nlp-bert_family/:2:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"一、大：有钱任性，大力出奇迹 其实从工程的视角来看，BERT 本身已可算为巨型模型。BERT-Large 的预训练语料共 16 G，模型参数 3.4 亿， 整个预训练过程用 64 块 TPU 芯片跑了 4 天。 然而，或许是 BERT 的成功带来了启发，各大巨头在烧钱的路上一去不返。 2019年2月，OpenAI 发布 GPT 升级版 GPT-2，预训练语料用了 800 万个网页，总共 40 G，而模型参数也增加到 15 亿 2019年6月，谷歌提出 XLNET，预训练语料增长为 113 G 2019年7月，facebook 发布 BERT 升级版 RoBERTa，预训练语料 160 G 20","date":"2020-06-21","objectID":"/nlp-bert_family/:2:1","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"二、小：落地为王，浓缩才是精华 虽然原始的 BERT 在各个怪物面前不算啥，但想要工程落地，依然过于笨重。因此在模型压缩的方向，也有不少的努力和尝试。 Compressing BERT：利用剪枝技术，去掉模型中影响较小的参数或层 Q-BERT：利用量化技术，用低精度取代高精度模型 ALBERT：利用参数共享技术，将所有 transformer 层的参数共享，减少训练时间 DistilBERT / TinyBERT：利用知识蒸馏技术，将大型模型的知识蒸馏到小型模型 FastBERT：利用自适应推理技术，减少简单样本的推理时间 ······ 目前，这些尝试或许不尽如人意，很难保证模型的效果，但这个","date":"2020-06-21","objectID":"/nlp-bert_family/:2:2","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"三、改：创新与微创新，哪里能改改哪里 BERT模型虽然效果很好，但其设计也有明显的缺陷，即预训练过程的任务是MLM而微调过程的下游任务大多是自回归语言模型。 两个过程的不一致导致了部分信息的损失，也使得BERT不适合NLG任务。因此，如何改进设计就举足轻重。 而在细节方面，自然也有不断的尝试。 ERNIE / BERT-WWM：针对中文模型，改进 mask 方式，ERNIE mask 掉实体和短语，BERT-WWM mask 掉词 StructBERT：新添了词序重建和句序判定两个预训练任务，即预测出句子中正确的词语顺序和文章中正确的句子对顺序 MASS / T5：将 BERT 的 Trans","date":"2020-06-21","objectID":"/nlp-bert_family/:2:3","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"展望：路漫漫其修远兮 未来 BERT 的发展之快其实已超出很多人的想象，然而往前看，NLP 的道路依然十分漫长。 从工程上讲，如何得到效果更好的轻量模型，如何解决实际项目中样本不足的困境，依然是巨大的挑战。 从学术上讲，BERT 哪怕利用到极限，似乎离 NLP 的真正目标——让机器理解自然语言，还是隔着天堑。 希望下一个里程碑，能够尽快到来。 ","date":"2020-06-21","objectID":"/nlp-bert_family/:3:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"参考文献 1.Pre-trained Models for Natural Language Processing: A Survey, Xipeng Qiu, 2020. 2.Deep contextualized word representations, Matthew E. Peters, NAACL 2018. (ELMo) 3.Improving Language Understanding by Generative Pre-Training, Alec Radford, 2018 (GPT) 4.BERT: Pre-training of Deep Bidirectional ","date":"2020-06-21","objectID":"/nlp-bert_family/:4:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":" 力扣第 194 场周赛第 4 题 ","date":"2020-06-21","objectID":"/leetcode/1489/:0:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":"题目 给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组 edges ，其中 edges[i] = [fromi, toi, weighti] 表示在 fromi 和 toi 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。 请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。 请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标","date":"2020-06-21","objectID":"/leetcode/1489/:1:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":"分析 先求出 MST 的代价 s。如果去掉某条边，不存在 MST 或者 s 变大，即说明是关键边。 如果先连某条边，s 不变，说明该边出现在 MST 中，那么它要么是关键边，要么是伪关键边。 ","date":"2020-06-21","objectID":"/leetcode/1489/:2:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":"解答 def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -\u003e List[List[int]]: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def cal(A): f[:], s, cnt = list(range(n)), 0, 0 for w, u, v, idx in A: if find(u) != find(v): union(u, v)","date":"2020-06-21","objectID":"/leetcode/1489/:3:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":"*附加 本题还有更优的算法。 假设边的权重各不相同，那么显然生成 MST 的每一步都是确定的，MST 唯一。因此该唯一的 MST 中的都是关键边，不存在伪关键边。 存在相同权重的边时，情况复杂很多。假设生成 MST 的过程遍历到权重 w，权重等于 w 的边的集合是 A。 并设此时的并查集状态是 U0，将 A 的边都相连后的并查集状态是 U1。 那么 A 中的边有三种情况： 假如边的两个顶点在 U0 状态下已连通，该边多余\r假如去掉该边后，U1 状态变化，该边是关键边\r否则该边是伪关键边\r然后有个巧妙的想法，将 U0 状态下的连通块看作是点，将 A 的边都相连后得到一个图 G，那么 A 中的边的","date":"2020-06-21","objectID":"/leetcode/1489/:4:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":" 力扣第 192 场周赛第 4 题 ","date":"2020-06-07","objectID":"/leetcode/1473/:0:0","tags":null,"title":"1473：粉刷房子 III（★★）","uri":"/leetcode/1473/"},{"categories":null,"content":"题目 在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不可以被重新涂色。 我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区 [{1}, {2,2}, {3,3}, {2}, {1,1}] 。） 给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中： houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。\rcost[i][j]：是将第 i 个房子涂成","date":"2020-06-07","objectID":"/leetcode/1473/:1:0","tags":null,"title":"1473：粉刷房子 III（★★）","uri":"/leetcode/1473/"},{"categories":null,"content":"分析 用辅助函数 help(i, j, t) 表示对 houses[i:] 涂色且 houses[i] 涂成颜色 j，恰好组成 t 个社区的最小花费。 若不可能则返回正无穷，便可以写出递推式。 ","date":"2020-06-07","objectID":"/leetcode/1473/:2:0","tags":null,"title":"1473：粉刷房子 III（★★）","uri":"/leetcode/1473/"},{"categories":null,"content":"解答 def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -\u003e int: @lru_cache(None) def help(i, j, t): if houses[i] not in [0, j] or t \u003c 1: return float('inf') c = cost[i][j - 1] if houses[i] == 0 else 0 if i == m - 1: return c if t == 1 else float('inf') return c + ","date":"2020-06-07","objectID":"/leetcode/1473/:3:0","tags":null,"title":"1473：粉刷房子 III（★★）","uri":"/leetcode/1473/"},{"categories":null,"content":" 力扣第 27 场双周赛第 3 题 ","date":"2020-05-30","objectID":"/leetcode/1462/:0:0","tags":null,"title":"1462：课程表 IV（★）","uri":"/leetcode/1462/"},{"categories":null,"content":"题目 你总共需要上 numCourses 门课，课程编号依次为 0 到 numCourses-1 。你会得到一个数组 prerequisite ，其中 prerequisites[i] = [ai, bi] 表示如果你想选 bi 课程，你 必须 先选 ai 课程。 有的课会有直接的先修课程，比如如果想上课程 1 ，你必须先上课程 0 ，那么会以 [0,1] 数对的形式给出先修课程数对。\r先决条件也可以是 间接 的。如果课程 a 是课程 b 的先决条件，课程 b 是课程 c 的先决条件，那么课程 a 就是课程 c 的先决条件。 你也得到一个数组 queries ，其中 queries[j] = ","date":"2020-05-30","objectID":"/leetcode/1462/:1:0","tags":null,"title":"1462：课程表 IV（★）","uri":"/leetcode/1462/"},{"categories":null,"content":"分析 有向无环图，可以直接递归求课程 u 的所有先决条件。 ","date":"2020-05-30","objectID":"/leetcode/1462/:2:0","tags":null,"title":"1462：课程表 IV（★）","uri":"/leetcode/1462/"},{"categories":null,"content":"解答 def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -\u003e List[bool]: @lru_cache(None) def dfs(u): return reduce(or_, [dfs(v) for v in nxt[u]], set(nxt[u])) nxt = defaultdict(list) for v, u in prerequisites: nxt[u].append(v) return [u in dfs(v) fo","date":"2020-05-30","objectID":"/leetcode/1462/:3:0","tags":null,"title":"1462：课程表 IV（★）","uri":"/leetcode/1462/"},{"categories":null,"content":" 力扣第 27 场双周赛第 2 题 ","date":"2020-05-30","objectID":"/leetcode/1461/:0:0","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★）","uri":"/leetcode/1461/"},{"categories":null,"content":"题目 给你一个二进制字符串 s 和一个整数 k 。如果所有长度为 k 的二进制字符串都是 s 的子串，请返回 true ，否则请返回 false 。 示例 1： 输入：s = \"00110110\", k = 2 输出：true 解释：长度为 2 的二进制串包括 \"00\"，\"01\"，\"10\" 和 \"11\"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。 示例 2： 输入：s = \"0110\", k = 1 输出：true 解释：长度为 1 的二进制串包括 \"0\" 和 \"1\"，显然它们都是 s 的子串。 示例 3： 输入：s = \"0110\", k = 2 输出：false ","date":"2020-05-30","objectID":"/leetcode/1461/:1:0","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★）","uri":"/leetcode/1461/"},{"categories":null,"content":"分析 ","date":"2020-05-30","objectID":"/leetcode/1461/:2:0","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★）","uri":"/leetcode/1461/"},{"categories":null,"content":"#1 最简单的就是看所有长度 k 的子串集合是否有 2^k 个即可。 def hasAllCodes(self, s: str, k: int) -\u003e bool: return len({s[i:i+k] for i in range(len(s)-k+1)})==(1\u003c\u003ck) 356 ms ","date":"2020-05-30","objectID":"/leetcode/1461/:2:1","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★）","uri":"/leetcode/1461/"},{"categories":null,"content":"#2 注意到如果将子串用对应的十进制值代替，那么相邻的子串的值可以递推，从而节省时间。 这其实就是滚动哈希的思想。 ","date":"2020-05-30","objectID":"/leetcode/1461/:2:2","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★）","uri":"/leetcode/1461/"},{"categories":null,"content":"解答 def hasAllCodes(self, s: str, k: int) -\u003e bool: res, w = set(), 0 for j, char in enumerate(s): w = w*2+(char=='1') if j\u003e=k: w -= (s[j-k]=='1')*(1\u003c\u003ck) if j\u003e=k-1: res.add(w) return len(res)==(1\u003c\u003ck) 600 ms ","date":"2020-05-30","objectID":"/leetcode/1461/:3:0","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★）","uri":"/leetcode/1461/"},{"categories":null,"content":" 力扣第 190 场周赛第 2 题 ","date":"2020-05-24","objectID":"/leetcode/1456/:0:0","tags":null,"title":"1456：定长子串中元音的最大数目","uri":"/leetcode/1456/"},{"categories":null,"content":"题目 给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。 示例 1： 输入：s = \"abciiidef\", k = 3 输出：3 解释：子字符串 \"iii\" 包含 3 个元音字母。 示例 2： 输入：s = \"aeiou\", k = 2 输出：2 解释：任意长度为 2 的子字符串都包含 2 个元音字母。 示例 3： 输入：s = \"leetcode\", k = 3 输出：2 解释：\"lee\"、\"eet\" 和 \"ode\" 都包含 2 个元音字母。 示例 4： 输入：s = \"rhyt","date":"2020-05-24","objectID":"/leetcode/1456/:1:0","tags":null,"title":"1456：定长子串中元音的最大数目","uri":"/leetcode/1456/"},{"categories":null,"content":"分析 维护 k 大小的窗口中元音字母数即可。 ","date":"2020-05-24","objectID":"/leetcode/1456/:2:0","tags":null,"title":"1456：定长子串中元音的最大数目","uri":"/leetcode/1456/"},{"categories":null,"content":"解答 def maxVowels(self, s: str, k: int) -\u003e int: res, cnt = 0, 0 for j, c in enumerate(s): if c in 'aeiou': cnt += 1 if j\u003e=k: cnt -= s[j-k] in 'aeiou' if j\u003e=k-1: res = max(res, cnt) return res 160 ms ","date":"2020-05-24","objectID":"/leetcode/1456/:3:0","tags":null,"title":"1456：定长子串中元音的最大数目","uri":"/leetcode/1456/"},{"categories":null,"content":" 力扣第 190 场周赛第 1 题 ","date":"2020-05-24","objectID":"/leetcode/1455/:0:0","tags":null,"title":"1455：检查单词是否为句中其他单词的前缀","uri":"/leetcode/1455/"},{"categories":null,"content":"题目 给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。 如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。如果 searchWord 不是任何单词的前缀，则返回 -1 。 字符串 s 的 前缀 是 s 的任何前导连续子字符串。 示例 1： 输入：sentence = \"i lo","date":"2020-05-24","objectID":"/leetcode/1455/:1:0","tags":null,"title":"1455：检查单词是否为句中其他单词的前缀","uri":"/leetcode/1455/"},{"categories":null,"content":"分析 遍历判断即可。 ","date":"2020-05-24","objectID":"/leetcode/1455/:2:0","tags":null,"title":"1455：检查单词是否为句中其他单词的前缀","uri":"/leetcode/1455/"},{"categories":null,"content":"解答 def isPrefixOfWord(self, sentence: str, searchWord: str) -\u003e int: for i, w in enumerate(sentence.split()): if w.startswith(searchWord): return i+1 return -1 40 ms ","date":"2020-05-24","objectID":"/leetcode/1455/:3:0","tags":null,"title":"1455：检查单词是否为句中其他单词的前缀","uri":"/leetcode/1455/"},{"categories":null,"content":" 力扣第 26 场双周赛第 2 题 ","date":"2020-05-16","objectID":"/leetcode/1447/:0:0","tags":null,"title":"1447：最简分数","uri":"/leetcode/1447/"},{"categories":null,"content":"题目 给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 n 的 最简 分数 。分数可以以 任意 顺序返回。 示例 1： 输入：n = 2\r输出：[\"1/2\"]\r解释：\"1/2\" 是唯一一个分母小于等于 2 的最简分数。\r示例 2： 输入：n = 3\r输出：[\"1/2\",\"1/3\",\"2/3\"]\r示例 3： 输入：n = 4\r输出：[\"1/2\",\"1/3\",\"1/4\",\"2/3\",\"3/4\"]\r解释：\"2/4\" 不是最简分数，因为它可以化简为 \"1/2\" 。\r示例 4： 输入：n = 1\r输出：[]\r提示： 1 \u003c= n \u003c= 100\r","date":"2020-05-16","objectID":"/leetcode/1447/:1:0","tags":null,"title":"1447：最简分数","uri":"/leetcode/1447/"},{"categories":null,"content":"分析 遍历所有 0\u003c分子\u003c分母\u003c=n 的分数，判断是否是最简分数即可。 ","date":"2020-05-16","objectID":"/leetcode/1447/:2:0","tags":null,"title":"1447：最简分数","uri":"/leetcode/1447/"},{"categories":null,"content":"解答 def simplifiedFractions(self, n: int) -\u003e List[str]: return ['%d/%d'%(x,y) for y in range(2, n+1) for x in range(1, y) if gcd(x, y)==1] 72 ms ","date":"2020-05-16","objectID":"/leetcode/1447/:3:0","tags":null,"title":"1447：最简分数","uri":"/leetcode/1447/"},{"categories":null,"content":" 力扣第 188 场周赛第 1 题 ","date":"2020-05-10","objectID":"/leetcode/1441/:0:0","tags":null,"title":"1441：用栈操作构建数组","uri":"/leetcode/1441/"},{"categories":null,"content":"题目 给你一个数组 target 和一个整数 n。每次迭代，需要从 list = { 1 , 2 , 3 ..., n } 中依次读取一个数字。 请使用下述操作来构建目标数组 target ： \"Push\"：从 list 中读取一个新元素， 并将其推入数组中。\r\"Pop\"：删除数组中的最后一个元素。\r如果目标数组构建完成，就停止读取更多元素。\r题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。 请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。 示例 1： 输入：target = [1,3], n = 3\r输出：[\"Push\",\"Push\",\"Pop\",\"P","date":"2020-05-10","objectID":"/leetcode/1441/:1:0","tags":null,"title":"1441：用栈操作构建数组","uri":"/leetcode/1441/"},{"categories":null,"content":"分析 显然 target 中存在的数经过了 Push 操作，而中间空缺的数都经过了 Push 和 Pop 操作。 比如示例 1 中 1 和 3 之间的空缺 2，必然是加入又马上删除了。 因此用 pre 记录上一个数，遍历 target，先添加 target-pre-1 次 Push 和 Pop，再添加 1 次 Push 即可。 ","date":"2020-05-10","objectID":"/leetcode/1441/:2:0","tags":null,"title":"1441：用栈操作构建数组","uri":"/leetcode/1441/"},{"categories":null,"content":"解答 def buildArray(self, target: List[int], n: int) -\u003e List[str]: res, pre = [], 0 for num in target: res.extend(['Push', 'Pop']*(num-pre-1) + ['Push']) pre = num return res 28 ms ","date":"2020-05-10","objectID":"/leetcode/1441/:3:0","tags":null,"title":"1441：用栈操作构建数组","uri":"/leetcode/1441/"},{"categories":null,"content":" 力扣第 187 场周赛第 4 题 ","date":"2020-05-03","objectID":"/leetcode/1439/:0:0","tags":null,"title":"1439：有序矩阵中的第 k 个最小数组和（★★）","uri":"/leetcode/1439/"},{"categories":null,"content":"题目 给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列。 你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 最小 数组和。 示例 1： 输入：mat = [[1,3,11],[2,4,6]], k = 5\r输出：7\r解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：\r[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。 示例 2： 输入：mat = [[1,3,11],[2,4,6]], k = 9\r输出：17\r示例 3： 输入：mat = [[1,10,10],[1,","date":"2020-05-03","objectID":"/leetcode/1439/:1:0","tags":null,"title":"1439：有序矩阵中的第 k 个最小数组和（★★）","uri":"/leetcode/1439/"},{"categories":null,"content":"分析 ","date":"2020-05-03","objectID":"/leetcode/1439/:2:0","tags":null,"title":"1439：有序矩阵中的第 k 个最小数组和（★★）","uri":"/leetcode/1439/"},{"categories":null,"content":"#1 类似 0373，只不过从两行推广到了 m 行。 显然直接遍历所有可能非常耗时，注意到 k 很小，有个巧妙的想法是逐步求解。 由前 i 行的前 k 个最小数组和，可以递推求前 i+1 行的前 k 个最小数组和。递推到前 m 行即可。 def kthSmallest(self, mat: List[List[int]], k: int) -\u003e int: return reduce(lambda x, y: nsmallest(k, map(sum, product(x, y))), mat)[-1] 304 ms ","date":"2020-05-03","objectID":"/leetcode/1439/:2:1","tags":null,"title":"1439：有序矩阵中的第 k 个最小数组和（★★）","uri":"/leetcode/1439/"},{"categories":null,"content":"#2 也可以用归并排序的方法，每次取最小的数组和，遍历 m 维坐标的每一维，将该维增 1 后的坐标添加到候选中即可。 为了防止重复添加，可以用 set 记录下。 ","date":"2020-05-03","objectID":"/leetcode/1439/:2:2","tags":null,"title":"1439：有序矩阵中的第 k 个最小数组和（★★）","uri":"/leetcode/1439/"},{"categories":null,"content":"解答 def kthSmallest(self, mat: List[List[int]], k: int) -\u003e int: m, n = len(mat), len(mat[0]) pq, vis = [(sum(mat[i][0] for i in range(m)), (0,)*m)], {(0,)*m} for _ in range(k-1): s, p = heappop(pq) for i in range(m): new_p = p[:i] + (p[i]+1,) + p[i + 1:] if p[i]+1 \u003c n and new_p not in vis: vis.add(ne","date":"2020-05-03","objectID":"/leetcode/1439/:3:0","tags":null,"title":"1439：有序矩阵中的第 k 个最小数组和（★★）","uri":"/leetcode/1439/"},{"categories":null,"content":" 力扣第 187 场周赛第 3 题 ","date":"2020-05-03","objectID":"/leetcode/1438/:0:0","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★）","uri":"/leetcode/1438/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。 如果不存在满足条件的子数组，则返回 0 。 示例 1： 输入：nums = [8,2,4,7], limit = 4 输出：2 解释：所有子数组如下： [8] 最大绝对差 |8-8| = 0 \u003c= 4. [8,2] 最大绝对差 |8-2| = 6 \u003e 4. [8,2,4] 最大绝对差 |8-2| = 6 \u003e 4. [8,2,4,7] 最大绝对差 |8-2| = 6 \u003e 4. [2] 最大绝对差 |2-2| = 0 \u003c= 4. ","date":"2020-05-03","objectID":"/leetcode/1438/:1:0","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★）","uri":"/leetcode/1438/"},{"categories":null,"content":"分析 ","date":"2020-05-03","objectID":"/leetcode/1438/:2:0","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★）","uri":"/leetcode/1438/"},{"categories":null,"content":"#1 显然可以遍历结尾下标 j，找最小的 i 使得 max(nums[i:j+1])-min(nums[i:j+1])\u003c=limit。 注意到随着 j 递增，i 必然不递减，因此是一个滑动窗口问题。 要维护 nums[i:j+1] 的最大值和最小值，考虑用有序集合。 def longestSubarray(self, nums: List[int], limit: int) -\u003e int: from sortedcontainers import SortedList sl = SortedList() res, i = 0, 0 for j, num in enumerate(nums): ","date":"2020-05-03","objectID":"/leetcode/1438/:2:1","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★）","uri":"/leetcode/1438/"},{"categories":null,"content":"#2 也可以用两个单调队列分别维护窗口的最大/小值。 ","date":"2020-05-03","objectID":"/leetcode/1438/:2:2","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★）","uri":"/leetcode/1438/"},{"categories":null,"content":"解答 def longestSubarray(self, nums: List[int], limit: int) -\u003e int: que1, que2 = deque(), deque() res, i = 0, 0 for j, num in enumerate(nums): while que1 and que1[-1][0]\u003c=num: que1.pop() while que2 and que2[-1][0]\u003e=num: que2.pop() que1.append((num, j)) que2.append((num, j)) while que1[0][0]-que2[0][0]","date":"2020-05-03","objectID":"/leetcode/1438/:3:0","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★）","uri":"/leetcode/1438/"},{"categories":null,"content":" 力扣第 25 场双周赛第 1 题 ","date":"2020-05-02","objectID":"/leetcode/1431/:0:0","tags":null,"title":"1431：拥有最多糖果的孩子","uri":"/leetcode/1431/"},{"categories":null,"content":"题目 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1： 输入：candies = [2,3,5,1,3], extraCandies = 3 输出：[true,true,true,false,true] 解释： 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。 孩子 ","date":"2020-05-02","objectID":"/leetcode/1431/:1:0","tags":null,"title":"1431：拥有最多糖果的孩子","uri":"/leetcode/1431/"},{"categories":null,"content":"分析 模拟即可。 ","date":"2020-05-02","objectID":"/leetcode/1431/:2:0","tags":null,"title":"1431：拥有最多糖果的孩子","uri":"/leetcode/1431/"},{"categories":null,"content":"解答 def kidsWithCandies(self, candies: List[int], extraCandies: int) -\u003e List[bool]: M = max(candies) return [c+extraCandies\u003e=M for c in candies] 48 ms ","date":"2020-05-02","objectID":"/leetcode/1431/:3:0","tags":null,"title":"1431：拥有最多糖果的孩子","uri":"/leetcode/1431/"},{"categories":null,"content":"Ian 的个人博客（github | netlify），专注于 MAD、动画、游戏、 力扣。 ","date":"2020-05-01","objectID":"/about/:0:0","tags":[],"title":"关于","uri":"/about/"},{"categories":null,"content":"今日歌单 ","date":"2020-05-01","objectID":"/about/:0:1","tags":[],"title":"关于","uri":"/about/"},{"categories":null,"content":"今日MAD ","date":"2020-05-01","objectID":"/about/:0:2","tags":[],"title":"关于","uri":"/about/"},{"categories":null,"content":" 力扣第 186 场周赛第 4 题 ","date":"2020-04-26","objectID":"/leetcode/1425/:0:0","tags":null,"title":"1425：带限制的子序列和（★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和 j 满足 i \u003c j 且 j - i \u003c= k 。 数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。 示例 1： 输入：nums = [10,2,-10,5,20], k = 2 输出：37 解释：子序列为 [10, 2, 5, 20] 。 示例 2： 输入：nums = [-1,-2,-3], k = 1 输出：-1 解释：子序列必须是非空","date":"2020-04-26","objectID":"/leetcode/1425/:1:0","tags":null,"title":"1425：带限制的子序列和（★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"分析 ","date":"2020-04-26","objectID":"/leetcode/1425/:2:0","tags":null,"title":"1425：带限制的子序列和（★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"#1 令 dp[j] 代表以 nums[j] 结尾的满足要求的最大子序列和，那么显然可以递推： dp[j] = nums[j]+max(dp[j-k:j]+[0]) 但是这样时间复杂度为 O(N*K)，会超时。 注意到递推式中本质是在求滑动窗口的最大值，因此类似 0239，可以用有序集合解决。 本题滑动窗口的区别在于，数组并不是一开始就给定的，而是边递推边滑动的。 def constrainedSubsetSum(self, nums: List[int], k: int) -\u003e int: from sortedcontainers import SortedList sl, dp = Sor","date":"2020-04-26","objectID":"/leetcode/1425/:2:1","tags":null,"title":"1425：带限制的子序列和（★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"#2 也可以采用 0239 的单调队列方法。 ","date":"2020-04-26","objectID":"/leetcode/1425/:2:2","tags":null,"title":"1425：带限制的子序列和（★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"解答 def constrainedSubsetSum(self, nums: List[int], k: int) -\u003e int: queue, dp = deque(), nums[:] for j, num in enumerate(nums): dp[j] = num + max(0, queue[0][0] if queue else 0) while queue and queue[-1][0]\u003c=dp[j]: queue.pop() queue.append((dp[j], j)) if queue[0][1] == j-k: queue.popleft() return max","date":"2020-04-26","objectID":"/leetcode/1425/:3:0","tags":null,"title":"1425：带限制的子序列和（★★）","uri":"/leetcode/1425/"},{"categories":null,"content":" 力扣第 186 场周赛第 3 题 ","date":"2020-04-26","objectID":"/leetcode/1424/:0:0","tags":null,"title":"1424：对角线遍历 II（★）","uri":"/leetcode/1424/"},{"categories":null,"content":"题目 给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。 示例 1： 输入：nums = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,4,2,7,5,3,8,6,9] 示例 2： 输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]] 输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] 示例 3： 输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]] 输出：[1,4","date":"2020-04-26","objectID":"/leetcode/1424/:1:0","tags":null,"title":"1424：对角线遍历 II（★）","uri":"/leetcode/1424/"},{"categories":null,"content":"分析 ","date":"2020-04-26","objectID":"/leetcode/1424/:2:0","tags":null,"title":"1424：对角线遍历 II（★）","uri":"/leetcode/1424/"},{"categories":null,"content":"#1 类似 0498 ，可以先保存每一条对角线的列表，然后再拼接。 一开始遍历 nums 可以反向遍历行，最终拼接时就无需再反转了。 def findDiagonalOrder(self, nums: List[List[int]]) -\u003e List[int]: m, n = len(nums), len(nums) and max(map(len, nums)) tmp = [[] for _ in range(m+n-1)] for i in range(m-1, -1, -1): for j in range(len(nums[i])): tmp[i+j].append(nums[i][","date":"2020-04-26","objectID":"/leetcode/1424/:2:1","tags":null,"title":"1424：对角线遍历 II（★）","uri":"/leetcode/1424/"},{"categories":null,"content":"#2 还有种巧妙的方法，将所有元素按 (i+j, j) 排序即可。 ","date":"2020-04-26","objectID":"/leetcode/1424/:2:2","tags":null,"title":"1424：对角线遍历 II（★）","uri":"/leetcode/1424/"},{"categories":null,"content":"解答 def findDiagonalOrder(self, nums: List[List[int]]) -\u003e List[int]: return [t[-1] for t in sorted((i+j, j, num) for i, row in enumerate(nums) for j, num in enumerate(row))] 184 ms ","date":"2020-04-26","objectID":"/leetcode/1424/:3:0","tags":null,"title":"1424：对角线遍历 II（★）","uri":"/leetcode/1424/"},{"categories":null,"content":" 力扣第 186 场周赛第 2 题 ","date":"2020-04-26","objectID":"/leetcode/1423/:0:0","tags":null,"title":"1423：可获得的最大点数（★）","uri":"/leetcode/1423/"},{"categories":null,"content":"题目 几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例 1： 输入：cardPoints = [1,2,3,4,5,6,1], k = 3 输出：12 解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 输入：c","date":"2020-04-26","objectID":"/leetcode/1423/:1:0","tags":null,"title":"1423：可获得的最大点数（★）","uri":"/leetcode/1423/"},{"categories":null,"content":"分析 显然最终只能拿头部的连续一段加上尾部的连续一段 设尾部拿了 i 个，头部就拿了 k-i 个，用前缀和即可快速求出两段的区间和 因此遍历 i 从 0 到 k，求最大的区间和即可。 ","date":"2020-04-26","objectID":"/leetcode/1423/:2:0","tags":null,"title":"1423：可获得的最大点数（★）","uri":"/leetcode/1423/"},{"categories":null,"content":"解答 def maxScore(self, cardPoints: List[int], k: int) -\u003e int: pre = list(accumulate([0]+cardPoints)) return max(pre[k-i]+pre[-1]-pre[-1-i] for i in range(k+1)) 72 ms ","date":"2020-04-26","objectID":"/leetcode/1423/:3:0","tags":null,"title":"1423：可获得的最大点数（★）","uri":"/leetcode/1423/"},{"categories":null,"content":" 力扣第 184 场周赛第 3 题 ","date":"2020-04-12","objectID":"/leetcode/1410/:0:0","tags":null,"title":"1410：HTML 实体解析器（★）","uri":"/leetcode/1410/"},{"categories":null,"content":"题目 「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。 HTML 里这些特殊字符和它们对应的字符实体包括： 双引号：字符实体为 \u0026quot; ，对应的字符是 \" 。\r单引号：字符实体为 \u0026apos; ，对应的字符是 ' 。\r与符号：字符实体为 \u0026amp; ，对应对的字符是 \u0026 。\r大于号：字符实体为 \u0026gt; ，对应的字符是 \u003e 。\r小于号：字符实体为 \u0026lt; ，对应的字符是 \u003c 。\r斜线号：字符实体为 \u0026frasl; ，对应的字符是 / 。\r给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后","date":"2020-04-12","objectID":"/leetcode/1410/:1:0","tags":null,"title":"1410：HTML 实体解析器（★）","uri":"/leetcode/1410/"},{"categories":null,"content":"分析 替换即可。注意最后再替换 \u0026 为 \u0026，否则 \u0026 可能参与到其它替换，比如 “\u0026gt;” 。 ","date":"2020-04-12","objectID":"/leetcode/1410/:2:0","tags":null,"title":"1410：HTML 实体解析器（★）","uri":"/leetcode/1410/"},{"categories":null,"content":"解答 def entityParser(self, text: str) -\u003e str: for x, y in zip(['\u0026quot;', '\u0026apos;', '\u0026gt;', '\u0026lt;', '\u0026frasl;', '\u0026amp;'], '\"\\'\u003e\u003c/\u0026'): text = text.replace(x, y) return text 60 ms ","date":"2020-04-12","objectID":"/leetcode/1410/:3:0","tags":null,"title":"1410：HTML 实体解析器（★）","uri":"/leetcode/1410/"},{"categories":null,"content":" 力扣第 184 场周赛第 1 题 ","date":"2020-04-12","objectID":"/leetcode/1408/:0:0","tags":null,"title":"1408：数组中的字符串匹配","uri":"/leetcode/1408/"},{"categories":null,"content":"题目 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。 如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 words[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。 示例 1： 输入：words = [\"mass\",\"as\",\"hero\",\"superhero\"]\r输出：[\"as\",\"hero\"]\r解释：\"as\" 是 \"mass\" 的子字符串，\"hero\" 是 \"superhero\" 的子字符串。\r[\"hero\",\"as\"] 也是有效的答案。\r示例 ","date":"2020-04-12","objectID":"/leetcode/1408/:1:0","tags":null,"title":"1408：数组中的字符串匹配","uri":"/leetcode/1408/"},{"categories":null,"content":"分析 遍历判断 word 是否是另一个单词的子串即可。 ","date":"2020-04-12","objectID":"/leetcode/1408/:2:0","tags":null,"title":"1408：数组中的字符串匹配","uri":"/leetcode/1408/"},{"categories":null,"content":"解答 def stringMatching(self, words: List[str]) -\u003e List[str]: return [w for w in words if any(w2!=w and w in w2 for w2 in words)] 40 ms ","date":"2020-04-12","objectID":"/leetcode/1408/:3:0","tags":null,"title":"1408：数组中的字符串匹配","uri":"/leetcode/1408/"},{"categories":null,"content":" 力扣第 183 场周赛第 4 题 ","date":"2020-04-05","objectID":"/leetcode/1406/:0:0","tags":null,"title":"1406：石子游戏 III（★★）","uri":"/leetcode/1406/"},{"categories":null,"content":"题目 Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。 Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。 每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。 假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 \"Alice\" ，Bob 赢了就返回 \"Bob\"，平局（分","date":"2020-04-05","objectID":"/leetcode/1406/:1:0","tags":null,"title":"1406：石子游戏 III（★★）","uri":"/leetcode/1406/"},{"categories":null,"content":"分析 ","date":"2020-04-05","objectID":"/leetcode/1406/:2:0","tags":null,"title":"1406：石子游戏 III（★★）","uri":"/leetcode/1406/"},{"categories":null,"content":"#1 类似 1140 ，考虑递归。用辅助函数表示 help(i) 表示用 stoneValue[i:] 玩游戏 Alice 最多能拿到的分数。 亚历克斯先拿 X 堆石子，转为求递归子问题 help(i+X)。\rhelp(i+X) 等价于剩下的石子中 bob 最多能拿到的分数。\r两个人一共拿的分数是固定的 sum(stoneValue[i:])，因此遍历 X 找到最小的 help(i+X) 即可。\r再注意边界条件即可写出递归解法。 def stoneGameIII(self, stoneValue: List[int]) -\u003e str: @lru_cache(None) def help(i):","date":"2020-04-05","objectID":"/leetcode/1406/:2:1","tags":null,"title":"1406：石子游戏 III（★★）","uri":"/leetcode/1406/"},{"categories":null,"content":"#2 改写成动态规划。令 dp[i] 代表用 stoneValue[i:] 玩游戏 Alice 最多能拿到的分数。状态转移方程为： if i \u003e= len(stoneValue): dp[i] = 0\relse: dp[i] = sum(stoneValue[i:]) - min(dp[i+1:i+4])\r后缀和可以递推得到 def stoneGameIII(self, stoneValue: List[int]) -\u003e str: n = len(stoneValue) dp, suf = [0] * (n+1), 0 for i in range(n-1, -1, -1): suf += s","date":"2020-04-05","objectID":"/leetcode/1406/:2:2","tags":null,"title":"1406：石子游戏 III（★★）","uri":"/leetcode/1406/"},{"categories":null,"content":"#3 因为递推式只和前三个状态有关，可以只用三个参数保存状态。 ","date":"2020-04-05","objectID":"/leetcode/1406/:2:3","tags":null,"title":"1406：石子游戏 III（★★）","uri":"/leetcode/1406/"},{"categories":null,"content":"解答 def stoneGameIII(self, stoneValue: List[int]) -\u003e str: n = len(stoneValue) x = y = z = suf = 0 for i in range(n-1, -1, -1): suf += stoneValue[i] x, y, z = suf-min(x,y,z), x, y a, b = x, suf - x return 'Alice' if a \u003e b else ('Bob' if a \u003c b else 'Tie') 368 ms ","date":"2020-04-05","objectID":"/leetcode/1406/:3:0","tags":null,"title":"1406：石子游戏 III（★★）","uri":"/leetcode/1406/"},{"categories":null,"content":"       大学毕业后没有固定工作，在便利店打工的陆生。在没什么目标、对将来怀着焦躁感生活的陆生面前，某天出现了一位带着乌鸦的神秘少女——晴。就在陆生对她那前所未见的举止感到困惑的同时，他得知自己曾经憧憬的同级生榀子回到了东京。","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":"简介 大学毕业后没有固定工作，在便利店打工的陆生。在没什么目标、对将来怀着焦躁感生活的陆生面前，某天出现了一位带着乌鸦的神秘少女——晴。就在陆生对她那前所未见的举止感到困惑的同时，他得知自己曾经憧憬的同级生榀子回到了东京。 制作人员： 原作：冬目景 导演：藤原佳幸 脚本：田中仁 分镜：堀口和树、小泽一浩、原口浩、田中雄一、伊藤良太 ","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/:1:0","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鱼住陆生 うおずみ りくお、Uozumi Rikuo、リクオ 男 小林親弘 2 野中晴 のなか はる、ハル 女 宮本侑芽 3 森之目榀子 もりのめ しなこ 女 花澤香菜 4 早川浪 男 花江夏樹 5 凑航一 湊 航一、みなと こういち、Minato Koichi 男 小野友樹 6 柚原千佳 柚原知花、柚原 チカ、ゆずはら チカ、Yuzuhara Chika 女 喜多村英梨 7 狭山杏子 狭山 杏子、さやま きょうこ、Sayama Kyōko 女 坂本真綾 8 福田孝则 福田タカノリ、ふくだ たかのり 男 寺島拓篤 ","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/:2:0","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 昨日之歌 2020-04-04 12 bilibili ","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/:3:0","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":"MAD ","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/:4:0","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":" 力扣第 181 场周赛第 4 题 ","date":"2020-03-22","objectID":"/leetcode/1392/:0:0","tags":null,"title":"1392：最长快乐前缀（★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"题目 「快乐前缀」 是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。 给你一个字符串 s，请你返回它的 最长快乐前缀。如果不存在满足题意的前缀，则返回一个空字符串 \"\" 。 示例 1： 输入：s = \"level\"\r输出：\"l\"\r解释：不包括 s 自己，一共有 4 个前缀（\"l\", \"le\", \"lev\", \"leve\"）和 4 个后缀（\"l\", \"el\", \"vel\", \"evel\"）。最长的既是前缀也是后缀的字符串是 \"l\" 。\r示例 2： 输入：s = \"ababab\"\r输出：\"abab\"\r解释：\"abab\" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符","date":"2020-03-22","objectID":"/leetcode/1392/:1:0","tags":null,"title":"1392：最长快乐前缀（★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"分析 ","date":"2020-03-22","objectID":"/leetcode/1392/:2:0","tags":null,"title":"1392：最长快乐前缀（★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"#1 暴力法就是直接遍历 L 判断 s[:L] 和 s[-L:] 是否相等。 要优化判断子串相等的时间，容易想到用滚动哈希。 元素种类最多 26，窗口种类最多 10^5 级别，因此考虑 base 取 31，mod 取 10^11+3 def longestPrefix(self, s: str) -\u003e str: res, n = -1, len(s) base, mod = 31, 10**11+3 w1, w2, bL = 0, 0, 1 for i in range(n-1): w1 = (w1*base+ord(s[i])-ord('a')+1)%mod w2 = (w2+(ord(s[","date":"2020-03-22","objectID":"/leetcode/1392/:2:1","tags":null,"title":"1392：最长快乐前缀（★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"#2 求最长的既是前缀又是后缀的子串，容易想到 KMP，KMP 中的 nxt[i] 即是 s[:i] 的快乐前缀长度。 ","date":"2020-03-22","objectID":"/leetcode/1392/:2:2","tags":null,"title":"1392：最长快乐前缀（★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"解答 def longestPrefix(self, s: str) -\u003e str: nxt, j, n = [-1], -1, len(s) for i in range(n): while j \u003e= 0 and s[i] != s[j]: j = nxt[j] j += 1 nxt.append(j) return s[:nxt[-1]] 228 ms ","date":"2020-03-22","objectID":"/leetcode/1392/:3:0","tags":null,"title":"1392：最长快乐前缀（★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-15","objectID":"/hugo-shortcodes/","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-15","objectID":"/hugo-shortcodes/:0:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"1 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel","date":"2020-03-15","objectID":"/hugo-shortcodes/:1:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"2 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. t","date":"2020-03-15","objectID":"/hugo-shortcodes/:2:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"3 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是","date":"2020-03-15","objectID":"/hugo-shortcodes/:3:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:1","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:2","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3,","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:3","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:4","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:5","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:6","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:7","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"5 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": ","date":"2020-03-15","objectID":"/hugo-shortcodes/:5:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"6 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是","date":"2020-03-15","objectID":"/hugo-shortcodes/:6:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"https://hugoloveit.com/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"http://p1.music.126.net/ehaqke","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:1","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://y.qq.com/n/yqq/album/001Di11N41SEdY.html\" \u003e}} 或者 {{\u003c music \"https://y.qq.com/n/yqq/album/001Di11N41SEdY.html\" \u003e}} 呈","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:2","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"neteas","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:3","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #aaaaaa. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:4","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"8 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV15t411E7hf \u003e}} 或者 {{\u003c bilibili id=BV15t411E7hf \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.","date":"2020-03-15","objectID":"/hugo-shortcodes/:8:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"9 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-15","objectID":"/hugo-shortcodes/:9:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"9.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... ","date":"2020-03-15","objectID":"/hugo-shortcodes/:9:1","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"9.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:9:2","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"9.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:9:3","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":" 力扣第 180 场周赛第 2 题 ","date":"2020-03-15","objectID":"/leetcode/1381/:0:0","tags":null,"title":"1381：设计一个支持增量操作的栈","uri":"/leetcode/1381/"},{"categories":null,"content":"题目 请你设计一个支持对其元素进行增量操作的栈。 实现自定义栈类 CustomStack ： CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量。 void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。 int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。 void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。 示例： 输入： [\"CustomStack\",\"pus","date":"2020-03-15","objectID":"/leetcode/1381/:1:0","tags":null,"title":"1381：设计一个支持增量操作的栈","uri":"/leetcode/1381/"},{"categories":null,"content":"分析 ","date":"2020-03-15","objectID":"/leetcode/1381/:2:0","tags":null,"title":"1381：设计一个支持增量操作的栈","uri":"/leetcode/1381/"},{"categories":null,"content":"#1 最简单的就是暴力操作即可。 class CustomStack: def __init__(self, maxSize: int): self.size = maxSize self.stack = [] def push(self, x: int) -\u003e None: if len(self.stack) \u003c self.size: self.stack.append(x) def pop(self) -\u003e int: return self.stack.pop() if self.stack else -1 def increment(self, k: int, val: int) -\u003e ","date":"2020-03-15","objectID":"/leetcode/1381/:2:1","tags":null,"title":"1381：设计一个支持增量操作的栈","uri":"/leetcode/1381/"},{"categories":null,"content":"#2 有个巧妙的方法可以减少 increment 的时间。 入栈时添加一个变量 add 表示额外增加的值。increment 操作时将 stack[k-1] 的 add 增加 val，pop 操作时将 add 累加到 stack[-1] 中即可。 ","date":"2020-03-15","objectID":"/leetcode/1381/:2:2","tags":null,"title":"1381：设计一个支持增量操作的栈","uri":"/leetcode/1381/"},{"categories":null,"content":"解答 class CustomStack: def __init__(self, maxSize: int): self.size = maxSize self.stack = [] def push(self, x: int) -\u003e None: if len(self.stack) \u003c self.size: self.stack.append([x, 0]) def pop(self) -\u003e int: if not self.stack: return -1 res, add = self.stack.pop() if self.stack: self.stack[-1][1] += add","date":"2020-03-15","objectID":"/leetcode/1381/:3:0","tags":null,"title":"1381：设计一个支持增量操作的栈","uri":"/leetcode/1381/"},{"categories":null,"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-10","objectID":"/hugo-content/","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-10","objectID":"/hugo-content/:0:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录","date":"2020-03-10","objectID":"/hugo-content/:1:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: --- title: \"我的第一篇文章\" subtitle: \"\" date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true author: \"\" authorLink: \"\" description: \"\" license: \"\"","date":"2020-03-10","objectID":"/hugo-content/:2:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览 ","date":"2020-03-10","objectID":"/hugo-content/:3:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-10","objectID":"/hugo-content/:3:1","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-10","objectID":"/hugo-content/:3:2","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-10","objectID":"/hugo-content/:3:3","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2020-03-10","objectID":"/hugo-content/:3:4","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-10","objectID":"/hugo-content/:3:5","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"4 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-10","objectID":"/hugo-content/:4:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"数学公式 LoveIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈","date":"2020-03-10","objectID":"/hugo-content/:4:1","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-10","objectID":"/hugo-content/:4:2","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-10","objectID":"/hugo-content/:4:3","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-10","objectID":"/hugo-content/:4:4","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/hugo-basics/:0:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06","objectID":"/hugo-basics/:1:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/hugo-basics/:2:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/hugo-basics/:2:1","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.g","date":"2020-03-06","objectID":"/hugo-basics/:2:2","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 vers","date":"2020-03-06","objectID":"/hugo-basics/:2:3","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06","objectID":"/hugo-basics/:2:4","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/hugo-basics/:2:5","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"/hugo-basics/:2:6","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"3 配置 ","date":"2020-03-06","objectID":"/hugo-basics/:3:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，","date":"2020-03-06","objectID":"/hugo-basics/:3:1","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfi","date":"2020-03-06","objectID":"/hugo-basics/:3:2","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"3.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026di","date":"2020-03-06","objectID":"/hugo-basics/:3:3","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换 ","date":"2020-03-06","objectID":"/hugo-basics/:4:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2020-03-06","objectID":"/hugo-basics/:4:1","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" ","date":"2020-03-06","objectID":"/hugo-basics/:4:2","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/hugo-basics/:4:3","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"/hugo-basics/:5:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/hugo-basics/:5:1","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"e","date":"2020-03-06","objectID":"/hugo-basics/:5:2","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":" 力扣第 178 场周赛第 4 题 ","date":"2020-03-01","objectID":"/leetcode/1368/:0:0","tags":null,"title":"1368：使网格图至少有一条有效路径的最小代价（★★）","uri":"/leetcode/1368/"},{"categories":null,"content":"题目 给你一个 m x n 的网格图 grid 。 grid 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况： 1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1] 2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1] 3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j] 4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j] 注意网格图中可能会有 无效数字 ，因为它们可能指向 gri","date":"2020-03-01","objectID":"/leetcode/1368/:1:0","tags":null,"title":"1368：使网格图至少有一条有效路径的最小代价（★★）","uri":"/leetcode/1368/"},{"categories":null,"content":"分析 将每个格子看作顶点，相邻格子的路径看作边，如果边的方向顺着数字，看作权重 0，否则权重 1。 那么就是典型的最短路问题，用 dijkstra 或者 01bfs 即可。 ","date":"2020-03-01","objectID":"/leetcode/1368/:2:0","tags":null,"title":"1368：使网格图至少有一条有效路径的最小代价（★★）","uri":"/leetcode/1368/"},{"categories":null,"content":"解答 def minCost(self, grid: List[List[int]]) -\u003e int: m, n = len(grid), len(grid[0]) Q, d = deque([(0, 0, 0)]), {} while Q: i, j, w = Q.popleft() if (i,j)==(m-1,n-1): return w if (i, j) in d: continue d[(i,j)] = w for x, y, k in [(i, j+1, 1), (i, j-1, 2), (i+1, j, 3), (i-1, j, 4)]: if 0\u003c=x\u003cm and 0\u003c=y\u003c","date":"2020-03-01","objectID":"/leetcode/1368/:3:0","tags":null,"title":"1368：使网格图至少有一条有效路径的最小代价（★★）","uri":"/leetcode/1368/"},{"categories":null,"content":" 力扣第 20 场双周赛第 3 题 ","date":"2020-02-22","objectID":"/leetcode/1358/:0:0","tags":null,"title":"1358：包含所有三种字符的子字符串数目（★）","uri":"/leetcode/1358/"},{"categories":null,"content":"题目 给你一个字符串 s ，它只包含三种字符 a, b 和 c 。 请你返回 a，b 和 c 都 至少 出现过一次的子字符串数目。 示例 1： 输入：s = \"abcabc\" 输出：10 解释：包含 a，b 和 c 各至少一次的子字符串为 \"abc\", \"abca\", \"abcab\", \"abcabc\", \"bca\", \"bcab\", \"bcabc\", \"cab\", \"cabc\" 和 \"abc\" (相同字符串算多次)。 示例 2： 输入：s = \"aaacb\" 输出：3 解释：包含 a，b 和 c 各至少一次的子字符串为 \"aaacb\", \"aacb\" 和 \"acb\" 。 示例 3： 输入：s","date":"2020-02-22","objectID":"/leetcode/1358/:1:0","tags":null,"title":"1358：包含所有三种字符的子字符串数目（★）","uri":"/leetcode/1358/"},{"categories":null,"content":"分析 子字符串的总数很好求，因此可以反过来求不同时包含 a、b、c 的子字符串个数。这即是典型的滑动窗口问题。 ","date":"2020-02-22","objectID":"/leetcode/1358/:2:0","tags":null,"title":"1358：包含所有三种字符的子字符串数目（★）","uri":"/leetcode/1358/"},{"categories":null,"content":"解答 def numberOfSubstrings(self, s: str) -\u003e int: res,i,ct = 0,0,Counter() for j,c in enumerate(s): ct[c] += 1 while ct['a'] and ct['b'] and ct['c']: ct[s[i]] -= 1 i += 1 res += i return res 212 ms ","date":"2020-02-22","objectID":"/leetcode/1358/:3:0","tags":null,"title":"1358：包含所有三种字符的子字符串数目（★）","uri":"/leetcode/1358/"},{"categories":null,"content":" 力扣第 173 场周赛第 3 题 ","date":"2020-01-26","objectID":"/leetcode/1334/:0:0","tags":null,"title":"1334：阈值距离内邻居最少的城市（★★）","uri":"/leetcode/1334/"},{"categories":null,"content":"题目 有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。 返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。 注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。 示例 1： 输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1","date":"2020-01-26","objectID":"/leetcode/1334/:1:0","tags":null,"title":"1334：阈值距离内邻居最少的城市（★★）","uri":"/leetcode/1334/"},{"categories":null,"content":"分析 典型的最短路问题，可以直接用 floyd 算法。 ","date":"2020-01-26","objectID":"/leetcode/1334/:2:0","tags":null,"title":"1334：阈值距离内邻居最少的城市（★★）","uri":"/leetcode/1334/"},{"categories":null,"content":"解答 def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -\u003e int: dis = [[float('inf')]*n for _ in range(n)] for i in range(n): dis[i][i] = 0 for u, v, w in edges: dis[u][v] = dis[v][u] = w for x, u, v in product(range(n), range(n), range(n)): dis[u][v] = min(dis[u][v], dis[u]","date":"2020-01-26","objectID":"/leetcode/1334/:3:0","tags":null,"title":"1334：阈值距离内邻居最少的城市（★★）","uri":"/leetcode/1334/"},{"categories":null,"content":" 力扣第 173 场周赛第 2 题 ","date":"2020-01-26","objectID":"/leetcode/1333/:0:0","tags":null,"title":"1333：餐厅过滤器（★）","uri":"/leetcode/1333/"},{"categories":null,"content":"题目 给你一个餐馆信息数组 restaurants，其中 restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]。你必须使用以下三个过滤器来过滤这些餐馆信息。 其中素食者友好过滤器 veganFriendly 的值可以为 true 或者 false，如果为 true 就意味着你应该只包括 veganFriendlyi 为 true 的餐馆，为 false 则意味着可以包括任何餐馆。此外，我们还有最大价格 maxPrice 和最大距离 maxDistance 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。 ","date":"2020-01-26","objectID":"/leetcode/1333/:1:0","tags":null,"title":"1333：餐厅过滤器（★）","uri":"/leetcode/1333/"},{"categories":null,"content":"分析 按题意筛出并排序即可。为了方便排序，筛出时可以将值取反。 ","date":"2020-01-26","objectID":"/leetcode/1333/:2:0","tags":null,"title":"1333：餐厅过滤器（★）","uri":"/leetcode/1333/"},{"categories":null,"content":"解答 def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -\u003e List[int]: res = [] for id, rating, vegan, price, dis in restaurants: if veganFriendly in [0, vegan] and price\u003c=maxPrice and dis\u003c=maxDistance: res.append((-rating, -id)) return [-id f","date":"2020-01-26","objectID":"/leetcode/1333/:3:0","tags":null,"title":"1333：餐厅过滤器（★）","uri":"/leetcode/1333/"},{"categories":null,"content":" 力扣第 173 场周赛第 1 题 ","date":"2020-01-26","objectID":"/leetcode/1332/:0:0","tags":null,"title":"1332：删除回文子序列（★）","uri":"/leetcode/1332/"},{"categories":null,"content":"题目 给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。 返回删除给定字符串中所有字符（字符串为空）的最小删除次数。 「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。 「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 示例 1： 输入：s = \"ababa\" 输出：1 解释：字符串本身就是回文序列，只需要删除一次。 示例 2： 输入：s = \"abb\" 输出：2 解释：\"abb\" -\u003e \"bb\" -\u003e \"\". 先删除回文子序列 \"a","date":"2020-01-26","objectID":"/leetcode/1332/:1:0","tags":null,"title":"1332：删除回文子序列（★）","uri":"/leetcode/1332/"},{"categories":null,"content":"分析 因为 s 只含有 ‘a’ 和 ‘b’，所以只要先删所有 ‘a’，再删所有 ‘b’ ，最多两次就能删完。 再考虑下 s 为空和 s 只用删一次的情况即可。 ","date":"2020-01-26","objectID":"/leetcode/1332/:2:0","tags":null,"title":"1332：删除回文子序列（★）","uri":"/leetcode/1332/"},{"categories":null,"content":"解答 def removePalindromeSub(self, s: str) -\u003e int: return 0 if not s else (1 if s==s[::-1] else 2) 36 ms ","date":"2020-01-26","objectID":"/leetcode/1332/:3:0","tags":null,"title":"1332：删除回文子序列（★）","uri":"/leetcode/1332/"},{"categories":null,"content":" 力扣第 18 场双周赛第 2 题 ","date":"2020-01-25","objectID":"/leetcode/1328/:0:0","tags":null,"title":"1328：破坏回文串（★）","uri":"/leetcode/1328/"},{"categories":null,"content":"题目 给你一个由小写英文字母组成的回文字符串 palindrome ，请你将其中 一个 字符用任意小写英文字母替换，使得结果字符串的 字典序最小 ，且 不是 回文串。 请你返回结果字符串。如果无法做到，则返回一个 空串 。 如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符严格小于 b 中的对应字符。例如，\"abcc” 字典序比 \"abcd\" 小，因为不同的第一个位置是在第四个字符，显然 'c' 比 'd' 小。 示例 1： 输入：palindrome = \"abccba\" 输出：\"aaccba\" 解释：存在","date":"2020-01-25","objectID":"/leetcode/1328/:1:0","tags":null,"title":"1328：破坏回文串（★）","uri":"/leetcode/1328/"},{"categories":null,"content":"分析 假如长度 1，显然无法做到，返回空 要使字典序最小，考虑尽可能前面的某位变为 ‘a’ 因此遍历前半部分（不包括中心位置），找到第一个不为 ‘a’ 的位置，变为 ‘a’ 即可 如果全为 ‘a’，那么将最后一位变为 ‘b’ 即可 ","date":"2020-01-25","objectID":"/leetcode/1328/:2:0","tags":null,"title":"1328：破坏回文串（★）","uri":"/leetcode/1328/"},{"categories":null,"content":"解答 def breakPalindrome(self, palindrome: str) -\u003e str: s = palindrome n = len(s) if n==1: return '' for i in range(n//2): if s[i] != 'a': return s[:i]+'a'+s[i+1:] return s[:-1]+'b' 36 ms ","date":"2020-01-25","objectID":"/leetcode/1328/:3:0","tags":null,"title":"1328：破坏回文串（★）","uri":"/leetcode/1328/"},{"categories":null,"content":" 力扣第 172 场周赛第 2 题 ","date":"2020-01-19","objectID":"/leetcode/1324/:0:0","tags":null,"title":"1324：竖直打印单词","uri":"/leetcode/1324/"},{"categories":null,"content":"题目 给你一个字符串 s。请你按照单词在 s 中的出现顺序将它们全部竖直返回。 单词应该以字符串列表的形式返回，必要时用空格补位，但输出尾部的空格需要删除（不允许尾随空格）。 每个单词只能放在一列上，每一列中也只能有一个单词。 示例 1： 输入：s = \"HOW ARE YOU\" 输出：[\"HAY\",\"ORO\",\"WEU\"] 解释：每个单词都应该竖直打印。 \"HAY\" \"ORO\" \"WEU\" 示例 2： 输入：s = \"TO BE OR NOT TO BE\" 输出：[\"TBONTB\",\"OEROOE\",\" T\"] 解释：题目允许使用空格补位，但不允许输出末尾出现空格。 \"TBONTB\" \"OE","date":"2020-01-19","objectID":"/leetcode/1324/:1:0","tags":null,"title":"1324：竖直打印单词","uri":"/leetcode/1324/"},{"categories":null,"content":"分析 模拟即可。python 可以用 zip_longest 方便地提取每列。 ","date":"2020-01-19","objectID":"/leetcode/1324/:2:0","tags":null,"title":"1324：竖直打印单词","uri":"/leetcode/1324/"},{"categories":null,"content":"解答 def printVertically(self, s: str) -\u003e List[str]: return [''.join(col).rstrip() for col in zip_longest(*s.split(), fillvalue=' ')] 40 ms ","date":"2020-01-19","objectID":"/leetcode/1324/:3:0","tags":null,"title":"1324：竖直打印单词","uri":"/leetcode/1324/"},{"categories":null,"content":" 力扣第 171 场周赛第 1 题 ","date":"2020-01-12","objectID":"/leetcode/1317/:0:0","tags":null,"title":"1317：将整数转换为两个无零整数的和","uri":"/leetcode/1317/"},{"categories":null,"content":"题目 「无零整数」是十进制表示中 不含任何 0 的正整数。 给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足： A 和 B 都是无零整数 A + B = n 题目数据保证至少有一个有效的解决方案。 如果存在多个有效解决方案，你可以返回其中任意一个。 示例 1： 输入：n = 2 输出：[1,1] 解释：A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。 示例 2： 输入：n = 11 输出：[2,9] 示例 3： 输入：n = 10000 输出：[1,9999] 示例 4： 输入：n = 69 输出：[1,68] 示例","date":"2020-01-12","objectID":"/leetcode/1317/:1:0","tags":null,"title":"1317：将整数转换为两个无零整数的和","uri":"/leetcode/1317/"},{"categories":null,"content":"分析 遍历即可。 ","date":"2020-01-12","objectID":"/leetcode/1317/:2:0","tags":null,"title":"1317：将整数转换为两个无零整数的和","uri":"/leetcode/1317/"},{"categories":null,"content":"解答 def getNoZeroIntegers(self, n: int) -\u003e List[int]: for a in range(n//2+1): b = n-a if '0' not in str(a)+str(b): return [a, b] 28 ms ","date":"2020-01-12","objectID":"/leetcode/1317/:3:0","tags":null,"title":"1317：将整数转换为两个无零整数的和","uri":"/leetcode/1317/"},{"categories":null,"content":" 力扣第 17 场双周赛第 4 题 ","date":"2020-01-11","objectID":"/leetcode/1316/:0:0","tags":null,"title":"1316：不同的循环子字符串（★★）","uri":"/leetcode/1316/"},{"categories":null,"content":"题目 给你一个字符串 text ，请你返回满足下述条件的 不同 非空子字符串的数目： 可以写成某个字符串与其自身相连接的形式（即，可以写为 a + a，其中 a 是某个字符串）。 例如，abcabc 就是 abc 和它自身连接形成的。 示例 1： 输入：text = \"abcabcabc\" 输出：3 解释：3 个子字符串分别为 \"abcabc\"，\"bcabca\" 和 \"cabcab\" 。 示例 2： 输入：text = \"leetcodeleetcode\" 输出：2 解释：2 个子字符串为 \"ee\" 和 \"leetcodeleetcode\" 。 提示： 1 \u003c= text.length \u003c= ","date":"2020-01-11","objectID":"/leetcode/1316/:1:0","tags":null,"title":"1316：不同的循环子字符串（★★）","uri":"/leetcode/1316/"},{"categories":null,"content":"分析 暴力法就是直接遍历 i 和 L 判断 text[i:i+L] 和 text[i+L:i+2*L] 是否相等。 要优化判断子串相等的时间，容易想到用滚动哈希。 可以先求出 text 所有前缀的哈希值，然后类似前缀和，可以快速得到任一子串的哈希值。 元素种类最多 26，窗口种类最多 2*10^6 级别，因此考虑 base 取 31，mod 取 10^13+37 ","date":"2020-01-11","objectID":"/leetcode/1316/:2:0","tags":null,"title":"1316：不同的循环子字符串（★★）","uri":"/leetcode/1316/"},{"categories":null,"content":"解答 def distinctEchoSubstrings(self, text: str) -\u003e int: base, mod = 31, 10**13+37 pre = [0] for char in text: w = pre[-1]*base+ord(char)-ord('a')+1 pre.append(w % mod) res, n = set(), len(text) for L in range(1, n//2+1): bL = pow(base, L, mod) for i in range(n-2*L+1): w1 = (pre[i+L]-pre[i]*bL)%mod w2","date":"2020-01-11","objectID":"/leetcode/1316/:3:0","tags":null,"title":"1316：不同的循环子字符串（★★）","uri":"/leetcode/1316/"},{"categories":null,"content":" 力扣第 170 场周赛第 3 题 ","date":"2020-01-05","objectID":"/leetcode/1311/:0:0","tags":null,"title":"1311：获取你好友已观看的视频（★）","uri":"/leetcode/1311/"},{"categories":null,"content":"题目 有 n 个人，每个人都有一个 0 到 n-1 的唯一 id 。 给你数组 watchedVideos 和 friends ，其中 watchedVideos[i] 和 friends[i] 分别表示 id = i 的人观看过的视频列表和他的好友列表。 Level 1 的视频包含所有你好友观看过的视频，level 2 的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 k 的视频包含所有从你出发，最短距离为 k 的好友观看过的视频。 给定你的 id 和一个 level 值，请你找出所有指定 level 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们","date":"2020-01-05","objectID":"/leetcode/1311/:1:0","tags":null,"title":"1311：获取你好友已观看的视频（★）","uri":"/leetcode/1311/"},{"categories":null,"content":"分析 bfs 得到所有最短距离 k 的朋友，再统计视频即可。 ","date":"2020-01-05","objectID":"/leetcode/1311/:2:0","tags":null,"title":"1311：获取你好友已观看的视频（★）","uri":"/leetcode/1311/"},{"categories":null,"content":"解答 def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -\u003e List[str]: Q, vis = deque([id]), {id} for _ in range(level): tmp = [] for i in Q: for j in friends[i]: if j not in vis: tmp.append(j) vis.add(j) Q = tmp ct = Counter() for i in Q: fo","date":"2020-01-05","objectID":"/leetcode/1311/:3:0","tags":null,"title":"1311：获取你好友已观看的视频（★）","uri":"/leetcode/1311/"},{"categories":null,"content":"利用检测杀意的系统“罔象女”搜查犯罪事件的组织，通称“仓”。\n然后，神探·酒井户身为“罔象女”的驾驶员进入犯人的深层心理“杀意世界（井）”，对事件进行推理。\n他不断追寻着频繁发生、谜团重重的凶恶事件，以及在其中若隐若现的连续杀人鬼制造者“约翰·沃克”的影子。","date":"2020-01-05","objectID":"/anime/id_invaded/","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"简介 利用检测杀意的系统“罔象女”搜查犯罪事件的组织，通称“仓”。 然后，神探·酒井户身为“罔象女”的驾驶员进入犯人的深层心理“杀意世界（井）”，对事件进行推理。 他不断追寻着频繁发生、谜团重重的凶恶事件，以及在其中若隐若现的连续杀人鬼制造者“约翰·沃克”的影子。 制作人员： 导演：青木英 脚本：舞城王太郎 分镜：久保田雄大、碇谷敦、又贺大介、下平佑一、青柳隆平 ","date":"2020-01-05","objectID":"/anime/id_invaded/:1:0","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 名侦探酒井户 Brilliant detective Sakaido、鳴瓢秋人、鸣瓢秋人、なりひさご あきひと、Narihisago Akihito 男 津田健次郎 2 佳爱瑠 佳爱琉、Asukai Kiki、あすかい きき、飞鸟井木记、Kaeru、飛鳥井木記 女 宮本侑芽 3 冬川浩二 花火師（はなびし）、ふゆかわ こうじ、Fuyukawa Kouji 男 平川大輔 4 百贵船太郎 ももき ふねたろう、Momoki Funetarou 男 細谷佳正 5 本堂町小春 ほんどうまち こはる、Hondoumachi Koharu、Hijiriido Miyo、名","date":"2020-01-05","objectID":"/anime/id_invaded/:2:0","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 ID:INVADED 2020-01-05 13 bilibili ","date":"2020-01-05","objectID":"/anime/id_invaded/:3:0","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"MAD ","date":"2020-01-05","objectID":"/anime/id_invaded/:4:0","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"　　高中1年级学生浅草绿，是强调“设定即生命”的动画迷。在素描本上描绘积累各种各样的想法，却因不能一个人行动做事而无法迈出走向动画制作的一步。对于浅草这种才能，拥有制片人气质的金森沙耶香很快注意到了。同时，得知同学兼新星读者模特的水崎燕，其实希望将来成为动画人，3人为了展现脑内“最强的世界”而设立了映像研……","date":"2020-01-05","objectID":"/anime/keep_your_hands_off_eizouken/","tags":null,"title":"别对映像研出手！","uri":"/anime/keep_your_hands_off_eizouken/"},{"categories":null,"content":"简介 高中1年级学生浅草绿，是强调“设定即生命”的动画迷。在素描本上描绘积累各种各样的想法，却因不能一个人行动做事而无法迈出走向动画制作的一步。对于浅草这种才能，拥有制片人气质的金森沙耶香很快注意到了。同时，得知同学兼新星读者模特的水崎燕，其实希望将来成为动画人，3人为了展现脑内“最强的世界”而设立了映像研…… 制作人员： 原作：大童澄瞳 导演：汤浅政明 脚本：木户雄一郎 分镜：伊东伸高、山代风我、佐佐木勅嘉、五十岚祐贵、长屋诚志郎、木下绘李 ","date":"2020-01-05","objectID":"/anime/keep_your_hands_off_eizouken/:1:0","tags":null,"title":"别对映像研出手！","uri":"/anime/keep_your_hands_off_eizouken/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 浅草绿 Asakusa Midori 女 伊藤沙莉 2 水崎燕 Mizusaki Tsubame 女 松岡美里 3 金森沙耶香 Kanamori Sayaka 女 田村睦心 4 百目鬼 どうめき 女 花守ゆみり ","date":"2020-01-05","objectID":"/anime/keep_your_hands_off_eizouken/:2:0","tags":null,"title":"别对映像研出手！","uri":"/anime/keep_your_hands_off_eizouken/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 别对映像研出手！ 2020-01-05 12 acfun ","date":"2020-01-05","objectID":"/anime/keep_your_hands_off_eizouken/:3:0","tags":null,"title":"别对映像研出手！","uri":"/anime/keep_your_hands_off_eizouken/"},{"categories":null,"content":"2019 动画年终盘点，包括 MAD、短片、音乐等","date":"2019-12-31","objectID":"/anime/2019/","tags":null,"title":"2019 年终盘点","uri":"/anime/2019/"},{"categories":null,"content":"\r","date":"2019-12-31","objectID":"/anime/2019/:0:0","tags":null,"title":"2019 年终盘点","uri":"/anime/2019/"},{"categories":null,"content":"MAD ","date":"2019-12-31","objectID":"/anime/2019/:1:0","tags":null,"title":"2019 年终盘点","uri":"/anime/2019/"},{"categories":null,"content":"单素材 ","date":"2019-12-31","objectID":"/anime/2019/:1:1","tags":null,"title":"2019 年终盘点","uri":"/anime/2019/"},{"categories":null,"content":"多素材 ","date":"2019-12-31","objectID":"/anime/2019/:1:2","tags":null,"title":"2019 年终盘点","uri":"/anime/2019/"},{"categories":null,"content":"短片 ","date":"2019-12-31","objectID":"/anime/2019/:2:0","tags":null,"title":"2019 年终盘点","uri":"/anime/2019/"},{"categories":null,"content":"原创 ","date":"2019-12-31","objectID":"/anime/2019/:2:1","tags":null,"title":"2019 年终盘点","uri":"/anime/2019/"},{"categories":null,"content":"同人 ","date":"2019-12-31","objectID":"/anime/2019/:2:2","tags":null,"title":"2019 年终盘点","uri":"/anime/2019/"},{"categories":null,"content":" 力扣第 169 场周赛第 3 题 ","date":"2019-12-29","objectID":"/leetcode/1306/:0:0","tags":null,"title":"1306：跳跃游戏 III","uri":"/leetcode/1306/"},{"categories":null,"content":"题目 这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。 请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。 注意，不管是什么情况下，你都无法跳到数组之外。 示例 1： 输入：arr = [4,2,3,0,3,1,2], start = 5 输出：true 解释： 到达值为 0 的下标 3 有以下可能方案： 下标 5 -\u003e 下标 4 -\u003e 下标 1 -\u003e 下标 3 下标 5 -\u003e 下标 6 -\u003e 下标 4 -\u003e 下标 1 -\u003e 下标 3 示例 2： 输入：arr = [4","date":"2019-12-29","objectID":"/leetcode/1306/:1:0","tags":null,"title":"1306：跳跃游戏 III","uri":"/leetcode/1306/"},{"categories":null,"content":"分析 从 start 开始 bfs 或 dfs 遍历即可。 ","date":"2019-12-29","objectID":"/leetcode/1306/:2:0","tags":null,"title":"1306：跳跃游戏 III","uri":"/leetcode/1306/"},{"categories":null,"content":"解答 def canReach(self, arr: List[int], start: int) -\u003e bool: n = len(arr) Q, vis = deque([start]), set() while Q: i = Q.popleft() if arr[i] == 0: return True for j in [i+arr[i], i-arr[i]]: if 0\u003c=j\u003cn and j not in vis: Q.append(j) vis.add(j) return False 64 ms ","date":"2019-12-29","objectID":"/leetcode/1306/:3:0","tags":null,"title":"1306：跳跃游戏 III","uri":"/leetcode/1306/"},{"categories":null,"content":" 力扣第 167 场周赛第 2 题 ","date":"2019-12-15","objectID":"/leetcode/1291/:0:0","tags":null,"title":"1291：顺次数","uri":"/leetcode/1291/"},{"categories":null,"content":"题目 我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。 请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。 示例 1： 输出：low = 100, high = 300 输出：[123,234] 示例 2： 输出：low = 1000, high = 13000 输出：[1234,2345,3456,4567,5678,6789,12345] 提示： 10 \u003c= low \u003c= high \u003c= 10^9 ","date":"2019-12-15","objectID":"/leetcode/1291/:1:0","tags":null,"title":"1291：顺次数","uri":"/leetcode/1291/"},{"categories":null,"content":"分析 顺次数很少，所以直接遍历构造即可。 ","date":"2019-12-15","objectID":"/leetcode/1291/:2:0","tags":null,"title":"1291：顺次数","uri":"/leetcode/1291/"},{"categories":null,"content":"解答 def sequentialDigits(self, low: int, high: int) -\u003e List[int]: res = [] for L in range(len(str(low)), len(str(high))+1): for i in range(1, 11-L): x = int(''.join(map(str, range(i, i+L)))) if low\u003c=x\u003c=high: res.append(x) return res 28 ms ","date":"2019-12-15","objectID":"/leetcode/1291/:3:0","tags":null,"title":"1291：顺次数","uri":"/leetcode/1291/"},{"categories":null,"content":" 力扣第 15 场双周赛第 2 题 ","date":"2019-12-14","objectID":"/leetcode/1288/:0:0","tags":null,"title":"1288：删除被覆盖区间","uri":"/leetcode/1288/"},{"categories":null,"content":"题目 给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。 只有当 c \u003c= a 且 b \u003c= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。 在完成所有删除操作后，请你返回列表中剩余区间的数目。 示例： 输入：intervals = [[1,4],[3,6],[2,8]] 输出：2 解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。 提示：​​​​​​ 1 \u003c= intervals.length \u003c= 1000 0 \u003c= intervals[i][0] \u003c intervals[i][1] \u003c= 10^5 对于所有的 i != j：intervals[i] ","date":"2019-12-14","objectID":"/leetcode/1288/:1:0","tags":null,"title":"1288：删除被覆盖区间","uri":"/leetcode/1288/"},{"categories":null,"content":"分析 将区间按 \u003c左端点从小到大，右端点从大到小\u003e 排序，遍历每个区间，判断右端点是否\u003c=上一个区间的右端点即可。 ","date":"2019-12-14","objectID":"/leetcode/1288/:2:0","tags":null,"title":"1288：删除被覆盖区间","uri":"/leetcode/1288/"},{"categories":null,"content":"解答 def removeCoveredIntervals(self, intervals: List[List[int]]) -\u003e int: res, pre = 0, -1 for a, b in sorted(intervals, key=lambda x: (x[0], -x[1])): if b\u003epre: pre = b res += 1 return res 36 ms ","date":"2019-12-14","objectID":"/leetcode/1288/:3:0","tags":null,"title":"1288：删除被覆盖区间","uri":"/leetcode/1288/"},{"categories":null,"content":" 力扣第 15 场双周赛第 1 题 ","date":"2019-12-14","objectID":"/leetcode/1287/:0:0","tags":null,"title":"1287：有序数组中出现次数超过25%的元素","uri":"/leetcode/1287/"},{"categories":null,"content":"题目 给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。 请你找到并返回这个整数 示例： 输入：arr = [1,2,2,6,6,6,6,7,10] 输出：6 提示： 1 \u003c= arr.length \u003c= 10^4 0 \u003c= arr[i] \u003c= 10^5 ","date":"2019-12-14","objectID":"/leetcode/1287/:1:0","tags":null,"title":"1287：有序数组中出现次数超过25%的元素","uri":"/leetcode/1287/"},{"categories":null,"content":"分析 题目明确有且仅有1个，因此返回频数最大的即可。 ","date":"2019-12-14","objectID":"/leetcode/1287/:2:0","tags":null,"title":"1287：有序数组中出现次数超过25%的元素","uri":"/leetcode/1287/"},{"categories":null,"content":"解答 def findSpecialInteger(self, arr: List[int]) -\u003e int: return Counter(arr).most_common(1)[0][0] 44 ms ","date":"2019-12-14","objectID":"/leetcode/1287/:3:0","tags":null,"title":"1287：有序数组中出现次数超过25%的元素","uri":"/leetcode/1287/"},{"categories":null,"content":" 力扣第 166 场周赛第 3 题 ","date":"2019-12-08","objectID":"/leetcode/1283/:0:0","tags":null,"title":"1283：使结果不超过阈值的最小除数（★）","uri":"/leetcode/1283/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个正整数 threshold ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。 请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。 每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。 示例 1： 输入：nums = [1,2,5,9], threshold = 6 输出：5 解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。 如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。","date":"2019-12-08","objectID":"/leetcode/1283/:1:0","tags":null,"title":"1283：使结果不超过阈值的最小除数（★）","uri":"/leetcode/1283/"},{"categories":null,"content":"分析 典型的二分查找。 假设解为 x，针对所有 y\u003e=x 都满足阈值，针对所有 y\u003cx 都不满足。 ","date":"2019-12-08","objectID":"/leetcode/1283/:2:0","tags":null,"title":"1283：使结果不超过阈值的最小除数（★）","uri":"/leetcode/1283/"},{"categories":null,"content":"解答 def smallestDivisor(self, nums: List[int], threshold: int) -\u003e int: def check(x): return sum(ceil(a/x) for a in nums)\u003c=threshold self.__class__.__getitem__ = lambda self, x: check(x) return bisect_left(self, True, 1, max(nums)) 180 ms ","date":"2019-12-08","objectID":"/leetcode/1283/:3:0","tags":null,"title":"1283：使结果不超过阈值的最小除数（★）","uri":"/leetcode/1283/"},{"categories":null,"content":" 力扣第 165 场周赛第 4 题 ","date":"2019-12-01","objectID":"/leetcode/1278/:0:0","tags":null,"title":"1278：分割回文串 III（★★）","uri":"/leetcode/1278/"},{"categories":null,"content":"题目 给你一个由小写字母组成的字符串 s，和一个整数 k。 请你按下面的要求分割字符串： 首先，你可以将 s 中的部分字符修改为其他的小写英文字母。 接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。 请返回以这种方式分割字符串所需修改的最少字符数。 示例 1： 输入：s = \"abc\", k = 2 输出：1 解释：你可以把字符串分割成 \"ab\" 和 \"c\"，并修改 \"ab\" 中的 1 个字符，将它变成回文串。 示例 2： 输入：s = \"aabbc\", k = 3 输出：0 解释：你可以把字符串分割成 \"aa\"、\"bb\" 和 \"c\"，它们都是回文串。 示例 3：","date":"2019-12-01","objectID":"/leetcode/1278/:1:0","tags":null,"title":"1278：分割回文串 III（★★）","uri":"/leetcode/1278/"},{"categories":null,"content":"分析 ","date":"2019-12-01","objectID":"/leetcode/1278/:2:0","tags":null,"title":"1278：分割回文串 III（★★）","uri":"/leetcode/1278/"},{"categories":null,"content":"#1 和系列的前两题相比，不能遍历前缀回文子串了，只能遍历每一个位置，但还是能用递归。 对每个位置 i ，分别计算 s[:i] 变成回文的最少修改数、s[i:] 分割 k-1 个回文子串的最少修改数，取和的最小值即可。 @lru_cache(None) def palindromePartition(self, s: str, k: int) -\u003e int: cost = lambda s: sum(s[i] != s[-1-i] for i in range(len(s)//2)) if k == 1 or len(s) == 1: return cost(s) return min(cos","date":"2019-12-01","objectID":"/leetcode/1278/:2:1","tags":null,"title":"1278：分割回文串 III（★★）","uri":"/leetcode/1278/"},{"categories":null,"content":"#2 可以改写成动态规划了。用 dp[i][k] 表示 s 的后缀子串 s[i:] 分成 k 个回文子串的最少分割数，状态转移方程为： if k==1: dp[i][k] = cost(s[i:]) elif n-i\u003ck: dp[i][k] = float('inf') else: dp[i][k] = min(cost(s[i:j+1])+dp[j+1][k-1] for j in range(i, n-k+1)) def palindromePartition(self, s: str, k: int) -\u003e int: cost = lambda s: sum(s[i] != s[-1-i","date":"2019-12-01","objectID":"/leetcode/1278/:2:2","tags":null,"title":"1278：分割回文串 III（★★）","uri":"/leetcode/1278/"},{"categories":null,"content":"#3 可以预先保存 s 所有子串的 cost 值，节省时间。 def palindromePartition(self, s: str, k: int) -\u003e int: cost = lambda s: sum(s[i] != s[-1-i] for i in range(len(s)//2)) n = len(s) costs = [[cost(s[l:r+1]) for r in range(n)] for l in range(n)] dp = [[float('inf')]*(k+1) for _ in range(n)] for i in range(n-1, -1, -1): dp","date":"2019-12-01","objectID":"/leetcode/1278/:2:3","tags":null,"title":"1278：分割回文串 III（★★）","uri":"/leetcode/1278/"},{"categories":null,"content":"#4 cost 的计算也可以用动态规划，状态转移方程为： if l\u003e=r: costs[l][r] = 0 elif s[l]==s[r]: costs[l][r] = costs[l+1][r-1] else: osts[l][r] = costs[l+1][r-1] + 1 ","date":"2019-12-01","objectID":"/leetcode/1278/:2:4","tags":null,"title":"1278：分割回文串 III（★★）","uri":"/leetcode/1278/"},{"categories":null,"content":"解答 def palindromePartition(self, s: str, k: int) -\u003e int: n = len(s) costs = [[0]*n for _ in range(n)] for span in range(1, n): for l in range(n-span): r = l+span costs[l][r] = costs[l+1][r-1]+(0 if s[l]==s[r] else 1) dp = [[float('inf')]*(k+1) for _ in range(n)] for i in range(n-1, -1, -1): dp[i][1]","date":"2019-12-01","objectID":"/leetcode/1278/:3:0","tags":null,"title":"1278：分割回文串 III（★★）","uri":"/leetcode/1278/"},{"categories":null,"content":" 力扣第 165 场周赛第 2 题 ","date":"2019-12-01","objectID":"/leetcode/1276/:0:0","tags":null,"title":"1276：不浪费原料的汉堡制作方案","uri":"/leetcode/1276/"},{"categories":null,"content":"题目 圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。 给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下： 巨无霸汉堡：4 片番茄和 1 片奶酪 小皇堡：2 片番茄和 1 片奶酪 请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。 如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlic","date":"2019-12-01","objectID":"/leetcode/1276/:1:0","tags":null,"title":"1276：不浪费原料的汉堡制作方案","uri":"/leetcode/1276/"},{"categories":null,"content":"分析 经典的鸡兔同笼问题。 ","date":"2019-12-01","objectID":"/leetcode/1276/:2:0","tags":null,"title":"1276：不浪费原料的汉堡制作方案","uri":"/leetcode/1276/"},{"categories":null,"content":"解答 def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -\u003e List[int]: x = tomatoSlices-2*cheeseSlices if x\u003c0 or x\u00261 or x//2\u003echeeseSlices: return [] return [x//2, cheeseSlices-x//2] 36 ms ","date":"2019-12-01","objectID":"/leetcode/1276/:3:0","tags":null,"title":"1276：不浪费原料的汉堡制作方案","uri":"/leetcode/1276/"},{"categories":null,"content":" 力扣第 164 场周赛第 3 题 ","date":"2019-11-24","objectID":"/leetcode/1268/:0:0","tags":null,"title":"1268：搜索推荐系统（★）","uri":"/leetcode/1268/"},{"categories":null,"content":"题目 给你一个产品数组 products 和一个字符串 searchWord ，products 数组中每个产品都是一个字符串。 请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。 请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。 示例 1： 输入：products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWor","date":"2019-11-24","objectID":"/leetcode/1268/:1:0","tags":null,"title":"1268：搜索推荐系统（★）","uri":"/leetcode/1268/"},{"categories":null,"content":"分析 典型的字典树，在每个节点都保存该前缀的产品列表即可。 ","date":"2019-11-24","objectID":"/leetcode/1268/:2:0","tags":null,"title":"1268：搜索推荐系统（★）","uri":"/leetcode/1268/"},{"categories":null,"content":"解答 def suggestedProducts(self, products: List[str], searchWord: str) -\u003e List[List[str]]: T = lambda: defaultdict(T) trie = T() for w in products: p = trie for c in w: p = p[c] p['#'] = p.get('#', [])+[w] res, p = [], trie for c in searchWord: p = p[c] res.append(nsmallest(3, p.get('#', []))) return ","date":"2019-11-24","objectID":"/leetcode/1268/:3:0","tags":null,"title":"1268：搜索推荐系统（★）","uri":"/leetcode/1268/"},{"categories":null,"content":"*附加 还有个巧妙的方法： 将 products 排序后，某个前缀的产品列表必然是连续的 因此，在 products 中二分查找前缀的位置 i，判断 [i,i+2] 的产品是否符合即可 def suggestedProducts(self, products: List[str], searchWord: str) -\u003e List[List[str]]: products.sort() res, q = [], '' for c in searchWord: q += c pos = bisect_left(products, q) res.append([s for s in product","date":"2019-11-24","objectID":"/leetcode/1268/:4:0","tags":null,"title":"1268：搜索推荐系统（★）","uri":"/leetcode/1268/"},{"categories":null,"content":" 力扣第 162 场周赛第 2 题 ","date":"2019-11-10","objectID":"/leetcode/1253/:0:0","tags":null,"title":"1253：重构 2 行二进制矩阵（★）","uri":"/leetcode/1253/"},{"categories":null,"content":"题目 给你一个 2 行 n 列的二进制数组： 矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 0 就是 1。 第 0 行的元素之和为 upper。 第 1 行的元素之和为 lower。 第 i 列（从 0 开始编号）的元素之和为 colsum[i]，colsum 是一个长度为 n 的整数数组。 你需要利用 upper，lower 和 colsum 来重构这个矩阵，并以二维整数数组的形式返回它。 如果有多个不同的答案，那么任意一个都可以通过本题。 如果不存在符合要求的答案，就请返回一个空的二维数组。 示例 1： 输入：upper = 2, lower = 1, colsum = [1,1,1","date":"2019-11-10","objectID":"/leetcode/1253/:1:0","tags":null,"title":"1253：重构 2 行二进制矩阵（★）","uri":"/leetcode/1253/"},{"categories":null,"content":"分析 python 贪心 列和为 0 或 2 时，显然只有一种分法 列和为 1 时，优先分 upper 和 lower 中较大的 用了后，更新 upper 和 lower 遍历完毕后，upper 和 lower 都刚好分完，即是答案，否则返回空 ","date":"2019-11-10","objectID":"/leetcode/1253/:2:0","tags":null,"title":"1253：重构 2 行二进制矩阵（★）","uri":"/leetcode/1253/"},{"categories":null,"content":"解答 def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -\u003e List[List[int]]: res = [[], []] for x in colsum: a,b = (x//2,x//2) if x!=1 else (1,0) if upper\u003e=lower else (0,1) upper,lower = upper-a,lower-b res[0].append(a) res[1].append(b) return res if upper==lower==0 else [] 124 ms ","date":"2019-11-10","objectID":"/leetcode/1253/:3:0","tags":null,"title":"1253：重构 2 行二进制矩阵（★）","uri":"/leetcode/1253/"},{"categories":null,"content":" 力扣第 161 场周赛第 4 题 ","date":"2019-11-03","objectID":"/leetcode/1250/:0:0","tags":null,"title":"1250：检查「好数组」（★★）","uri":"/leetcode/1250/"},{"categories":null,"content":"题目 给你一个正整数数组 nums，你需要从中任选一些子集，然后将子集中每一个数乘以一个 任意整数，并求出他们的和。 假如该和结果为 1，那么原数组就是一个「好数组」，则返回 True；否则请返回 False。 示例 1： 输入：nums = [12,5,7,23] 输出：true 解释：挑选数字 5 和 7。 5*3 + 7*(-2) = 1 示例 2： 输入：nums = [29,6,10] 输出：true 解释：挑选数字 29, 6 和 10。 29*1 + 6*(-3) + 10*(-1) = 1 示例 3： 输入：nums = [3,6] 输出：false 提示： 1 \u003c= nums","date":"2019-11-03","objectID":"/leetcode/1250/:1:0","tags":null,"title":"1250：检查「好数组」（★★）","uri":"/leetcode/1250/"},{"categories":null,"content":"分析 根据裴蜀定理，只要存在子集的最大公约数为 1，即可满足条件。 而存在子集的最大公约数为 1 等价于 nums 的最大公约数为 1，判断即可。 ","date":"2019-11-03","objectID":"/leetcode/1250/:2:0","tags":null,"title":"1250：检查「好数组」（★★）","uri":"/leetcode/1250/"},{"categories":null,"content":"解答 def isGoodArray(self, nums: List[int]) -\u003e bool: return reduce(gcd, nums)==1 56 ms ","date":"2019-11-03","objectID":"/leetcode/1250/:3:0","tags":null,"title":"1250：检查「好数组」（★★）","uri":"/leetcode/1250/"},{"categories":null,"content":" 力扣第 161 场周赛第 3 题 ","date":"2019-11-03","objectID":"/leetcode/1249/:0:0","tags":null,"title":"1249：移除无效的括号（★）","uri":"/leetcode/1249/"},{"categories":null,"content":"题目 给你一个由 '('、')' 和小写字母组成的字符串 s。 你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。 请返回任意一个合法字符串。 有效「括号字符串」应当符合以下 任意一条 要求： 空字符串或只包含小写字母的字符串 可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」 可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」 示例 1： 输入：s = \"lee(t(c)o)de)\" 输出：\"lee(t(c)o)de\" 解释：\"lee(t(co)de)\" , \"lee(t(c)ode","date":"2019-11-03","objectID":"/leetcode/1249/:1:0","tags":null,"title":"1249：移除无效的括号（★）","uri":"/leetcode/1249/"},{"categories":null,"content":"分析 借助栈可以一趟得到不属于有效子串的括号的位置： 遇到 '(' 入栈，遇到 ')' 弹出栈顶的 '('，若栈空则该 ')' 是无效的。 若最后栈非空，还剩下的 '(' 也是无效的。 无效的 '(' 必然在无效的 ')' 后面，因此无需再排序。 显然每次遇到无效括号时，必须执行一次删除操作（不一定是当前的括号），最后才可能变为有效。 那么直接将这些无效括号去掉，即是一种最少删除数的方案。 ","date":"2019-11-03","objectID":"/leetcode/1249/:2:0","tags":null,"title":"1249：移除无效的括号（★）","uri":"/leetcode/1249/"},{"categories":null,"content":"解答 def minRemoveToMakeValid(self, s: str) -\u003e str: stack, invalid = [], set() for i, char in enumerate(s): if char == '(': stack.append(i) elif char == ')': if stack: stack.pop() else: invalid.add(i) invalid |= set(stack) return ''.join(char for i, char in enumerate(s) if i not in invalid) 88 ms ","date":"2019-11-03","objectID":"/leetcode/1249/:3:0","tags":null,"title":"1249：移除无效的括号（★）","uri":"/leetcode/1249/"},{"categories":null,"content":" 力扣第 1226 题 ","date":"2019-10-15","objectID":"/leetcode/1226/:0:0","tags":null,"title":"1226：哲学家进餐（★）","uri":"/leetcode/1226/"},{"categories":null,"content":"题目 5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子） 所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。 假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。 设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思","date":"2019-10-15","objectID":"/leetcode/1226/:1:0","tags":null,"title":"1226：哲学家进餐（★）","uri":"/leetcode/1226/"},{"categories":null,"content":"分析 典型的并发问题，可以用互斥锁+信号量解决。 为了防止死锁，最多允许 4 个哲学家同时拿叉子。考虑到效率，可以设置最多 3 个哲学家同时拿叉子。 ","date":"2019-10-15","objectID":"/leetcode/1226/:2:0","tags":null,"title":"1226：哲学家进餐（★）","uri":"/leetcode/1226/"},{"categories":null,"content":"解答 from threading import Lock, Semaphore class DiningPhilosophers: def __init__(self,): self.limit = Semaphore(3) self.forks = [Lock() for _ in range(5)] # call the functions directly to execute, for example, eat() def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightF","date":"2019-10-15","objectID":"/leetcode/1226/:3:0","tags":null,"title":"1226：哲学家进餐（★）","uri":"/leetcode/1226/"},{"categories":null,"content":" 力扣第 158 场周赛第 2 题 ","date":"2019-10-13","objectID":"/leetcode/1222/:0:0","tags":null,"title":"1222：可以攻击国王的皇后（★）","uri":"/leetcode/1222/"},{"categories":null,"content":"题目 在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。 给定一个由整数坐标组成的数组 queens ，表示黑皇后的位置；以及一对坐标 king ，表示白国王的位置，返回所有可以攻击国王的皇后的坐标(任意顺序)。 示例 1： 输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0] 输出：[[0,1],[1,0],[3,3]] 解释： [0,1] 的皇后可以攻击到国王，因为他们在同一行上。 [1,0] 的皇后可以攻击到国王，因为他们在同一列上。 [3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。 [0","date":"2019-10-13","objectID":"/leetcode/1222/:1:0","tags":null,"title":"1222：可以攻击国王的皇后（★）","uri":"/leetcode/1222/"},{"categories":null,"content":"分析 从国王出发往8个方向找皇后即可。 ","date":"2019-10-13","objectID":"/leetcode/1222/:2:0","tags":null,"title":"1222：可以攻击国王的皇后（★）","uri":"/leetcode/1222/"},{"categories":null,"content":"解答 def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -\u003e List[List[int]]: res, vis = [], {(a,b) for a,b in queens} for dx, dy in [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]: x, y = king while 0\u003c=x\u003c8 and 0\u003c=y\u003c8: x, y = x+dx, y+dy if (x, y) in vis: res.append([x,y]) br","date":"2019-10-13","objectID":"/leetcode/1222/:3:0","tags":null,"title":"1222：可以攻击国王的皇后（★）","uri":"/leetcode/1222/"},{"categories":null,"content":"肉食兽与草食兽共存的世界。\n食肉被视为重罪，然而在全宿制的名门高校·切里顿学园却发生了学生惨遭吞噬的“食杀事件”。\n\n在蔓延不安的校内，演剧部的怪人·灰狼雷格西过着与“庞大的身躯”与“锐利的尖牙”不符的平静生活。然而与小巧的兔子女学生·春的相遇，使雷格西的内心产生动摇。\n\n“我追求她的心情，是恋爱？还是食欲？”\n\n他真正遇到的事物，那是他自身的本能——","date":"2019-10-09","objectID":"/anime/beastars/","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":"简介 肉食兽与草食兽共存的世界。 食肉被视为重罪，然而在全宿制的名门高校·切里顿学园却发生了学生惨遭吞噬的“食杀事件”。 在蔓延不安的校内，演剧部的怪人·灰狼雷格西过着与“庞大的身躯”与“锐利的尖牙”不符的平静生活。然而与小巧的兔子女学生·春的相遇，使雷格西的内心产生动摇。 “我追求她的心情，是恋爱？还是食欲？” 他真正遇到的事物，那是他自身的本能—— 制作人员： 原作：板垣巴留 导演：松见真一 脚本：樋口七海 分镜：寸田笃志、武藤健司、佐藤真二、下司泰弘、石井俊匡 ","date":"2019-10-09","objectID":"/anime/beastars/:1:0","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雷格西 ♂ 小林親弘 2 春 哈鲁 ♀ 千本木彩花 3 路易 ♂ 小野友樹 4 茱诺 ♀ 種﨑敦美 5 杰克 ♂ 榎木淳弥 6 米古诺 ♂ 内田雄馬 7 克洛 ♂ 大塚剛央 8 德拉姆 ♂ 小林直人 ","date":"2019-10-09","objectID":"/anime/beastars/:2:0","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 动物狂想曲 2019-10-09 12 bilibili 2 BEASTARS 2nd Season 2021-01-06 12 bilibili ","date":"2019-10-09","objectID":"/anime/beastars/:3:0","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":"MAD ","date":"2019-10-09","objectID":"/anime/beastars/:4:0","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":" 力扣第 156 场周赛第 3 题 ","date":"2019-09-29","objectID":"/leetcode/1209/:0:0","tags":null,"title":"1209：删除字符串中的所有相邻重复项 II（★）","uri":"/leetcode/1209/"},{"categories":null,"content":"题目 给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。 你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。 在执行完所有删除操作后，返回最终得到的字符串。 本题答案保证唯一。 示例 1： 输入：s = \"abcd\", k = 2 输出：\"abcd\" 解释：没有要删除的内容。 示例 2： 输入：s = \"deeedbbcccbdaa\", k = 3 输出：\"aa\" 解释： 先删除 \"eee\" 和 \"ccc\"，得到 \"ddbbbdaa\" 再删除 \"bbb\"，得到 \"dddaa\" 最后删除 \"ddd","date":"2019-09-29","objectID":"/leetcode/1209/:1:0","tags":null,"title":"1209：删除字符串中的所有相邻重复项 II（★）","uri":"/leetcode/1209/"},{"categories":null,"content":"分析 和 1047 的区别在于相邻重复个数从 2 变为了 k。可以每次判断 stack 的后 k 项，也可以在入栈时添加一个变量 cnt 表示当前字符重复次数。 ","date":"2019-09-29","objectID":"/leetcode/1209/:2:0","tags":null,"title":"1209：删除字符串中的所有相邻重复项 II（★）","uri":"/leetcode/1209/"},{"categories":null,"content":"解答 def removeDuplicates(self, s: str, k: int) -\u003e str: stack = [] for char in s: if not stack or stack[-1][0] != char: stack.append((char, 1)) elif stack[-1][1] == k-1: for _ in range(k-1): stack.pop() else: stack.append((char, stack[-1][1] + 1)) return ''.join(char for char, cnt in stack) 124 ms ","date":"2019-09-29","objectID":"/leetcode/1209/:3:0","tags":null,"title":"1209：删除字符串中的所有相邻重复项 II（★）","uri":"/leetcode/1209/"},{"categories":null,"content":" 力扣第 156 场周赛第 2 题 ","date":"2019-09-29","objectID":"/leetcode/1208/:0:0","tags":null,"title":"1208：尽可能使字符串相等（★）","uri":"/leetcode/1208/"},{"categories":null,"content":"题目 给你两个长度相同的字符串，s 和 t。 将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。 用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。 如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。 如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。 示例 1： 输入：s = \"abcd\", t = \"bcdf\", maxCost = 3 输出：3 解","date":"2019-09-29","objectID":"/leetcode/1208/:1:0","tags":null,"title":"1208：尽可能使字符串相等（★）","uri":"/leetcode/1208/"},{"categories":null,"content":"分析 令 A[i] 代表第 i 个字符的开销，问题转化为求 A 的最长子串，其和不超过预算。 这就是典型的滑动窗口问题。 ","date":"2019-09-29","objectID":"/leetcode/1208/:2:0","tags":null,"title":"1208：尽可能使字符串相等（★）","uri":"/leetcode/1208/"},{"categories":null,"content":"解答 def equalSubstring(self, s: str, t: str, maxCost: int) -\u003e int: A = [abs(ord(a)-ord(b)) for a,b in zip(s, t)] res, tot, i = 0, 0, 0 for j, a in enumerate(A): tot += a while tot\u003emaxCost: tot -= A[i] i += 1 res = max(res, j-i+1) return res 76 ms ","date":"2019-09-29","objectID":"/leetcode/1208/:3:0","tags":null,"title":"1208：尽可能使字符串相等（★）","uri":"/leetcode/1208/"},{"categories":null,"content":" 力扣第 1206 题 ","date":"2019-09-25","objectID":"/leetcode/1206/:0:0","tags":null,"title":"1206：设计跳表（★★）","uri":"/leetcode/1206/"},{"categories":null,"content":"题目 不使用任何库函数，设计一个 跳表 。 跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。 例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作： Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons 跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n","date":"2019-09-25","objectID":"/leetcode/1206/:1:0","tags":null,"title":"1206：设计跳表（★★）","uri":"/leetcode/1206/"},{"categories":null,"content":"分析 跳表教程 为了方便，可以将叠在一起的看成是一个节点。 ","date":"2019-09-25","objectID":"/leetcode/1206/:2:0","tags":null,"title":"1206：设计跳表（★★）","uri":"/leetcode/1206/"},{"categories":null,"content":"解答 class Node: def __init__(self, val, nxt=[]): self.val = val self.nxt = nxt class Skiplist: def __init__(self): self.tail = Node(float('inf')) self.head = Node(-float('inf'), [self.tail]) self.H = 0 def search(self, target: int) -\u003e bool: cur = self.head for h in range(self.H, -1, -1): while cur.nx","date":"2019-09-25","objectID":"/leetcode/1206/:3:0","tags":null,"title":"1206：设计跳表（★★）","uri":"/leetcode/1206/"},{"categories":null,"content":" 力扣第 155 场周赛第 4 题 ","date":"2019-09-22","objectID":"/leetcode/1203/:0:0","tags":null,"title":"1203：项目管理（★★★）","uri":"/leetcode/1203/"},{"categories":null,"content":"题目 有 n 个项目，每个项目或者不属于任何小组，或者属于 m 个小组之一。group[i] 表示第 i 个项目所属的小组，如果第 i 个项目不属于任何小组，则 group[i] 等于 -1。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。 请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表： 同一小组的项目，排序后在列表中彼此相邻。 项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。 如果存在多个解决方案，只需要返回","date":"2019-09-22","objectID":"/leetcode/1203/:1:0","tags":null,"title":"1203：项目管理（★★★）","uri":"/leetcode/1203/"},{"categories":null,"content":"分析 将依赖关系看作有向边，显然是一个拓扑排序问题。 同一小组的必须相邻，那么可以将小组也看作顶点，小组间要满足拓扑顺序。 小组排好后，每个小组内部也要满足拓扑顺序。因此要用双层拓扑排序。 具体来说： 预处理： 将不属于任何小组的项目分给一个单独的虚拟小组，方便统一解决 建图： 对每个小组建立虚拟顶点，将项目顶点分给对应的小组 将边分为组间边和组内边，并且组内边分给对应的小组 双层拓扑： 根据小组虚拟顶点和组间边对小组进行拓扑排序 按拓扑顺序遍历小组，根据小组内的项目顶点和边进行拓扑排序 ","date":"2019-09-22","objectID":"/leetcode/1203/:2:0","tags":null,"title":"1203：项目管理（★★★）","uri":"/leetcode/1203/"},{"categories":null,"content":"解答 def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -\u003e List[int]: def topo(V, E): nxt, indeg = defaultdict(list), defaultdict(int) for u, v in E: nxt[u].append(v) indeg[v] += 1 res, queue = [], deque(u for u in V if indeg[u]==0) while queue: u = queue.popleft() res","date":"2019-09-22","objectID":"/leetcode/1203/:3:0","tags":null,"title":"1203：项目管理（★★★）","uri":"/leetcode/1203/"},{"categories":null,"content":" 力扣第 155 场周赛第 2 题 ","date":"2019-09-22","objectID":"/leetcode/1201/:0:0","tags":null,"title":"1201：丑数 III（★★）","uri":"/leetcode/1201/"},{"categories":null,"content":"题目 给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。 丑数是可以被 a 或 b 或 c 整除的 正整数 。 示例 1： 输入：n = 3, a = 2, b = 3, c = 5 输出：4 解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2： 输入：n = 4, a = 2, b = 3, c = 4 输出：6 解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。 示例 3： 输入：n = 5, a = 2, b = 11, c = 13 输出：10 解释：丑数序列为","date":"2019-09-22","objectID":"/leetcode/1201/:1:0","tags":null,"title":"1201：丑数 III（★★）","uri":"/leetcode/1201/"},{"categories":null,"content":"分析 观察数据范围容易想到用二分查找。 令 check(x) 代表小于等于 x 的丑数个数是否大于等于 n，那么二分查找第一个满足 check(x) 的 x 即可。 具体求小于等于 x 的丑数个数，则可以用到集合的知识。 ","date":"2019-09-22","objectID":"/leetcode/1201/:2:0","tags":null,"title":"1201：丑数 III（★★）","uri":"/leetcode/1201/"},{"categories":null,"content":"解答 def nthUglyNumber(self, n: int, a: int, b: int, c: int) -\u003e int: def check(x): return x//a+x//b+x//c-x//lcm(a,b)-x//lcm(a,c)-x//lcm(b,c)+x//reduce(lcm, [a,b,c])\u003e=n self.__class__.__getitem__ = lambda self, x: check(x) return bisect_left(self, True, 0, a*n) 40 ms ","date":"2019-09-22","objectID":"/leetcode/1201/:3:0","tags":null,"title":"1201：丑数 III（★★）","uri":"/leetcode/1201/"},{"categories":null,"content":" 力扣第 1195 题 ","date":"2019-09-18","objectID":"/leetcode/1195/:0:0","tags":null,"title":"1195：交替打印字符串（★）","uri":"/leetcode/1195/"},{"categories":null,"content":"题目 编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是： 如果这个数字可以被 3 整除，输出 \"fizz\"。 如果这个数字可以被 5 整除，输出 \"buzz\"。 如果这个数字可以同时被 3 和 5 整除，输出 \"fizzbuzz\"。 例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。 假设有这么一个类： class FizzBuzz { public FizzBuzz(int n) { ... } // constructor public void f","date":"2019-09-18","objectID":"/leetcode/1195/:1:0","tags":null,"title":"1195：交替打印字符串（★）","uri":"/leetcode/1195/"},{"categories":null,"content":"分析 典型的并发问题，可以用互斥锁解决。 ","date":"2019-09-18","objectID":"/leetcode/1195/:2:0","tags":null,"title":"1195：交替打印字符串（★）","uri":"/leetcode/1195/"},{"categories":null,"content":"解答 from threading import Lock class FizzBuzz: def __init__(self, n: int): self.n = n self.lock_f = Lock() self.lock_b = Lock() self.lock_fb = Lock() self.lock_n = Lock() self.lock_f.acquire() self.lock_b.acquire() self.lock_fb.acquire() # printFizz() outputs \"fizz\" def fizz(self, printFizz: 'Callabl","date":"2019-09-18","objectID":"/leetcode/1195/:3:0","tags":null,"title":"1195：交替打印字符串（★）","uri":"/leetcode/1195/"},{"categories":null,"content":" 力扣第 154 场周赛第 4 题 ","date":"2019-09-15","objectID":"/leetcode/1192/:0:0","tags":null,"title":"1192：查找集群内的关键连接（★★）","uri":"/leetcode/1192/"},{"categories":null,"content":"题目 力扣数据中心有 n 台服务器，分别按从 0 到 n-1 的方式进行了编号。它们之间以 服务器到服务器 的形式相互连接组成了一个内部集群，连接是无向的。用 connections 表示集群网络，connections[i] = [a, b] 表示服务器 a 和 b 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。 关键连接 是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。 请你以任意顺序返回该集群内的所有 关键连接 。 示例 1： 输入：n = 4, connections = [[0,1],[1,2],[2,0],[1,3]] 输出","date":"2019-09-15","objectID":"/leetcode/1192/:1:0","tags":null,"title":"1192：查找集群内的关键连接（★★）","uri":"/leetcode/1192/"},{"categories":null,"content":"分析 tarjan 算法模版题，求无向图的桥。 ","date":"2019-09-15","objectID":"/leetcode/1192/:2:0","tags":null,"title":"1192：查找集群内的关键连接（★★）","uri":"/leetcode/1192/"},{"categories":null,"content":"解答 def criticalConnections(self, n: int, connections: List[List[int]]) -\u003e List[List[int]]: def tarjan(p, fa): dfn[p] = low[p] = self.t = self.t+1 for q in nxt[p]: if q not in dfn: tarjan(q, p) low[p] = min(low[p], low[q]) if low[q] \u003e dfn[p]: bridge.append([p, q]) elif q != fa: low[p] = min(low[p], d","date":"2019-09-15","objectID":"/leetcode/1192/:3:0","tags":null,"title":"1192：查找集群内的关键连接（★★）","uri":"/leetcode/1192/"},{"categories":null,"content":" 力扣第 154 场周赛第 2 题 ","date":"2019-09-15","objectID":"/leetcode/1190/:0:0","tags":null,"title":"1190：反转每对括号间的子串（★）","uri":"/leetcode/1190/"},{"categories":null,"content":"题目 给出一个字符串 s（仅含有小写英文字母和括号）。 请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。 注意，您的结果中 不应 包含任何括号。 示例 1： 输入：s = \"(abcd)\"\r输出：\"dcba\"\r示例 2： 输入：s = \"(u(love)i)\"\r输出：\"iloveu\"\r解释：先反转子字符串 \"love\" ，然后反转整个字符串。\r示例 3： 输入：s = \"(ed(et(oc))el)\"\r输出：\"leetcode\"\r解释：先反转子字符串 \"oc\" ，接着反转 \"etco\" ，然后反转整个字符串。\r示例 4： 输入：s = \"a(bcdefghijkl","date":"2019-09-15","objectID":"/leetcode/1190/:1:0","tags":null,"title":"1190：反转每对括号间的子串（★）","uri":"/leetcode/1190/"},{"categories":null,"content":"分析 ","date":"2019-09-15","objectID":"/leetcode/1190/:2:0","tags":null,"title":"1190：反转每对括号间的子串（★）","uri":"/leetcode/1190/"},{"categories":null,"content":"#1 显然 s 递归地由子串反转后得到。可以用栈模拟这个过程，一趟解决。 def reverseParentheses(self, s: str) -\u003e str: stack = [''] for char in s: if char == '(': stack.append('') elif char == ')': x = stack.pop() stack[-1] += x[::-1] else: stack[-1] += char return stack[0] 36 ms ","date":"2019-09-15","objectID":"/leetcode/1190/:2:1","tags":null,"title":"1190：反转每对括号间的子串（★）","uri":"/leetcode/1190/"},{"categories":null,"content":"#2 上面的解法每次出栈时有反转操作，最坏时间复杂度为 O(N^2)。有个巧妙的想法能优化至 O(N)。 假如知道了每对 ‘()’ 的位置，那么就可以按最后的顺序依次访问字符。比如示例 2： 初始 s[0]='('，对应的')'位置为 9 跳到位置 9-1，开始反向遍历\rs[8]='i' 添加到结果中\rs[7]=')'，对应的'('位置为2 跳到位置 2+1，再次反转方向\rs[3:7]='love' 添加到结果中\rs[7]=')'，对应的'('位置为2 跳到位置 2-1，再次反转方向\rs[1]=='u' 添加到结果中\rs[0]='('，对应的')'位置为 9 跳到位置 9+1，再次反转方向\r位","date":"2019-09-15","objectID":"/leetcode/1190/:2:2","tags":null,"title":"1190：反转每对括号间的子串（★）","uri":"/leetcode/1190/"},{"categories":null,"content":"解答 def reverseParentheses(self, s: str) -\u003e str: stack, d = [], {} for j, char in enumerate(s): if char == '(': stack.append(j) elif char == ')': i = stack.pop() d[i], d[j] = j, i res, i, flag = '', 0, 1 while i \u003c len(s): if s[i] in '()': flag *= -1 i = d[i]+flag else: res += s[i] i += flag return re","date":"2019-09-15","objectID":"/leetcode/1190/:3:0","tags":null,"title":"1190：反转每对括号间的子串（★）","uri":"/leetcode/1190/"},{"categories":null,"content":" 力扣第 152 场周赛第 4 题 ","date":"2019-09-01","objectID":"/leetcode/1178/:0:0","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"题目 外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。\r单词 word 中的每一个字母都可以在谜面 puzzle 中找到。 例如，如果字谜的谜面是 \"abcdefg\"，那么可以作为谜底的单词有 \"faced\", \"cabbage\", 和 \"baggage\"；而 \"beefed\"（不含字母 \"a\"）以及 \"based\"（其中的 \"s\" 没有出现在谜面中）都不能作为谜底。\r返回一个答案数组 answer，数组中的每","date":"2019-09-01","objectID":"/leetcode/1178/:1:0","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"分析 ","date":"2019-09-01","objectID":"/leetcode/1178/:2:0","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"#1 先试试暴力解法，对每个 puzzle，遍历每个 word 判断是否满足条件即可。 def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -\u003e List[int]: res, words = [], [set(word) for word in words] for puzzle in puzzles: puz = set(puzzle) cnt = sum(puzzle[0] in word and puz \u003e= word for word in words) res.append(cnt) return ","date":"2019-09-01","objectID":"/leetcode/1178/:2:1","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"#2 puzzles 和 words 可能的个数太多了，全部遍历很耗时，考虑限制搜索范围。 可以直接把 key=''.join(sorted(set(word))) 作为表示 word 的唯一 key，保存在哈希表。\r那么 word 可以作为 puzzle 的谜底，等价于 word 的 key 是 puzzle 的某个含有 puzzle[0] 的子序列的 key。\r因此对于某个 puzzle，遍历含有 puzzle[0] 的子序列 sub，累计 key 相同的 word 个数即可。\r生成字符串的所有子序列类似于 0078 ，可以递推得到。 ","date":"2019-09-01","objectID":"/leetcode/1178/:2:2","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"解答 def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -\u003e List[int]: res, d = [], defaultdict(int) gen_key = lambda x: ''.join(sorted(x)) for word in words: d[gen_key(set(word))] += 1 for puzzle in puzzles: subs = [puzzle[0]] for char in puzzle[1:]: subs += [sub+char for sub in subs]","date":"2019-09-01","objectID":"/leetcode/1178/:3:0","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":" 力扣第 152 场周赛第 1 题 ","date":"2019-09-01","objectID":"/leetcode/1175/:0:0","tags":null,"title":"1175：质数排列（★）","uri":"/leetcode/1175/"},{"categories":null,"content":"题目 请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。 让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。 由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。 示例 1： 输入：n = 5 输出：12 解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。 示例 2： 输入：n = 100 输出：682289015 提示： 1 \u003c","date":"2019-09-01","objectID":"/leetcode/1175/:1:0","tags":null,"title":"1175：质数排列（★）","uri":"/leetcode/1175/"},{"categories":null,"content":"分析 显然是一个排列问题。如果质数个数为 k，那么结果应该为 k!*(n-k)!。求质数个数可以直接调用 0204 的代码。 ","date":"2019-09-01","objectID":"/leetcode/1175/:2:0","tags":null,"title":"1175：质数排列（★）","uri":"/leetcode/1175/"},{"categories":null,"content":"解答 def numPrimeArrangements(self, n: int) -\u003e int: def countPrimes(n): flags = [0] * 2 + [1] * (n-2) for i in range(2, int(sqrt(n))+1): if flags[i]: flags[i*i:n:i] = [0] * ((n-1-i*i)//i + 1) return sum(flags) k, M = countPrimes(n+1), 10**9+7 return reduce(lambda x, y: x*y % M, list(range(2, k+1))+lis","date":"2019-09-01","objectID":"/leetcode/1175/:3:0","tags":null,"title":"1175：质数排列（★）","uri":"/leetcode/1175/"},{"categories":null,"content":" 力扣第 151 场周赛第 4 题 ","date":"2019-08-25","objectID":"/leetcode/1172/:0:0","tags":null,"title":"1172：餐盘栈（★★）","uri":"/leetcode/1172/"},{"categories":null,"content":"题目 我们把无限数量 ∞ 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量 capacity 都相同。 实现一个叫「餐盘」的类 DinnerPlates： DinnerPlates(int capacity) - 给出栈的最大容量 capacity。\rvoid push(int val) - 将给出的正整数 val 推入 从左往右第一个 没有满的栈。\rint pop() - 返回 从右往左第一个 非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回 -1。\rint popAtStack(int index) - 返回编号 index 的栈顶部的值，并将其从栈中删除；","date":"2019-08-25","objectID":"/leetcode/1172/:1:0","tags":null,"title":"1172：餐盘栈（★★）","uri":"/leetcode/1172/"},{"categories":null,"content":"分析 考虑用数组 A 动态维护所有栈的信息（保证末尾是非空栈），那么 pop 时： 若 len(A[-1]) \u003e 1，直接 pop A[-1] 即可\r若 len(A[-1]) == 1，pop A[-1] 并去掉末尾所有空栈\r每个非末尾的空栈至少对应了一个 push 和 popAtStack 操作\r因此平摊下来 pop 时间复杂度 O(1)\r然后为了方便 push，考虑用堆 pq 维护没有满的栈下标集合，那么： 若 pq 空或 pq[0]\u003e=len(A)\r说明 A 中的栈的都满了，末尾添加一个栈并 push\r否则\r得到没有满的最小下标 i=pq[0]，往 A[i] push\r注意在所有操作中都","date":"2019-08-25","objectID":"/leetcode/1172/:2:0","tags":null,"title":"1172：餐盘栈（★★）","uri":"/leetcode/1172/"},{"categories":null,"content":"解答 class DinnerPlates: def __init__(self, capacity: int): self.size = capacity self.pq = [] self.A = [] def push(self, val: int) -\u003e None: if not self.pq or self.pq[0] \u003e= len(self.A): self.A.append([val]) self.pq = [len(self.A)-1] if self.size \u003e 1 else [] else: i = self.pq[0] self.A[i].append(val) if","date":"2019-08-25","objectID":"/leetcode/1172/:3:0","tags":null,"title":"1172：餐盘栈（★★）","uri":"/leetcode/1172/"},{"categories":null,"content":" 力扣第 151 场周赛第 3 题 ","date":"2019-08-25","objectID":"/leetcode/1171/:0:0","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★）","uri":"/leetcode/1171/"},{"categories":null,"content":"题目 给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。 删除完毕后，请你返回最终结果链表的头节点。 你可以返回任何满足题目要求的答案。 （注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。） 示例 1： 输入：head = [1,2,-3,3,1]\r输出：[3,1]\r提示：答案 [1,2,1] 也是正确的。\r示例 2： 输入：head = [1,2,3,-3,4]\r输出：[1,2,4]\r示例 3： 输入：head = [1,2,3,-3,-2]\r输出：[1]\r提示： 给你的链表中可能有 1 到","date":"2019-08-25","objectID":"/leetcode/1171/:1:0","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★）","uri":"/leetcode/1171/"},{"categories":null,"content":"分析 ","date":"2019-08-25","objectID":"/leetcode/1171/:2:0","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★）","uri":"/leetcode/1171/"},{"categories":null,"content":"#1 区间和为 0，容易想到转为找相等的前缀和。 遍历时，用哈希表 d 维护 {前缀和: 对应的节点}，若节点 p 处的前缀和 s 出现过，就将节点 d[s] 到节点 p 的部分删去即可。 注意删去节点时，要同步将哈希表中对应的前缀和也删去。 def removeZeroSumSublists(self, head: ListNode) -\u003e ListNode: dummy = p = ListNode(next=head) d, s = {}, 0 while p: s += p.val if s in d: q, _s = d[s].next, s while q != p: _s += ","date":"2019-08-25","objectID":"/leetcode/1171/:2:1","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★）","uri":"/leetcode/1171/"},{"categories":null,"content":"#2 有个巧妙的想法是先一趟得到哈希表 d，保存 {前缀和: 对应的最后一个节点}。 然后再遍历节点 p，得到对应前缀和 s ，将节点 p 到节点 d[s] 的部分删去即可。 ","date":"2019-08-25","objectID":"/leetcode/1171/:2:2","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★）","uri":"/leetcode/1171/"},{"categories":null,"content":"解答 def removeZeroSumSublists(self, head: ListNode) -\u003e ListNode: dummy = p = ListNode(next=head) d, s = {}, 0 while p: s += p.val d[s] = p p = p.next p, s = dummy, 0 while p: s += p.val p.next = d[s].next p = p.next return dummy.next 40 ms ","date":"2019-08-25","objectID":"/leetcode/1171/:3:0","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★）","uri":"/leetcode/1171/"},{"categories":null,"content":" 力扣第 151 场周赛第 2 题 ","date":"2019-08-25","objectID":"/leetcode/1170/:0:0","tags":null,"title":"1170：比较字符串最小字母出现频次（★）","uri":"/leetcode/1170/"},{"categories":null,"content":"题目 定义一个函数 f(s)，统计 s 中（按字典序比较）最小字母的出现频次 ，其中 s 是一个非空字符串。 例如，若 s = \"dcce\"，那么 f(s) = 2，因为字典序最小字母是 \"c\"，它出现了 2 次。 现在，给你两个字符串数组待查表 queries 和词汇表 words 。对于每次查询 queries[i] ，需统计 words 中满足 f(queries[i]) \u003c f(W) 的 词的数目 ，W 表示词汇表 words 中的每个词。 请你返回一个整数数组 answer 作为答案，其中每个 answer[i] 是第 i 次查询的结果。 示例 1： 输入：queries = [\"c","date":"2019-08-25","objectID":"/leetcode/1170/:1:0","tags":null,"title":"1170：比较字符串最小字母出现频次（★）","uri":"/leetcode/1170/"},{"categories":null,"content":"分析 用数组 A 记录词汇表中每个 f 值对应的词个数，那么每次查询即是求 sum(A[f(queries[i])+1:])。 容易想到用前缀和。不过本题 f 值最多为 10，直接求和即可。 ","date":"2019-08-25","objectID":"/leetcode/1170/:2:0","tags":null,"title":"1170：比较字符串最小字母出现频次（★）","uri":"/leetcode/1170/"},{"categories":null,"content":"解答 def numSmallerByFrequency(self, queries: List[str], words: List[str]) -\u003e List[int]: A = [0] * 11 for w in words: cnt = w.count(min(w)) A[cnt] += 1 res = [] for q in queries: cnt = q.count(min(q)) res.append(sum(A[cnt+1:])) return res 36 ms ","date":"2019-08-25","objectID":"/leetcode/1170/:3:0","tags":null,"title":"1170：比较字符串最小字母出现频次（★）","uri":"/leetcode/1170/"},{"categories":null,"content":" 力扣第 151 场周赛第 1 题 ","date":"2019-08-25","objectID":"/leetcode/1169/:0:0","tags":null,"title":"1169：查询无效交易（★）","uri":"/leetcode/1169/"},{"categories":null,"content":"题目 如果出现下述两种情况，交易 可能无效： 交易金额超过 $1000\r或者，它和 另一个城市 中 同名 的另一笔交易相隔不超过 60 分钟（包含 60 分钟整）\r给定字符串数组交易清单 transaction 。每个交易字符串 transactions[i] 由一些用逗号分隔的值组成，这些值分别表示交易的名称，时间（以分钟计），金额以及城市。 返回 transactions，返回可能无效的交易列表。你可以按 任何顺序 返回答案。 示例 1： 输入：transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\r输出：[\"alice,20,","date":"2019-08-25","objectID":"/leetcode/1169/:1:0","tags":null,"title":"1169：查询无效交易（★）","uri":"/leetcode/1169/"},{"categories":null,"content":"分析 数据范围不大，可以直接两重遍历判断每个交易是否有效。 ","date":"2019-08-25","objectID":"/leetcode/1169/:2:0","tags":null,"title":"1169：查询无效交易（★）","uri":"/leetcode/1169/"},{"categories":null,"content":"解答 def invalidTransactions(self, transactions: List[str]) -\u003e List[str]: def check(tr): name, time, amount, city = tr.split(',') if int(amount) \u003e 1000: return True for tr2 in transactions: name2, time2, _, city2 = tr2.split(',') if name == name2 and city != city2 and abs(int(time) - int(time2)) \u003c= 60","date":"2019-08-25","objectID":"/leetcode/1169/:3:0","tags":null,"title":"1169：查询无效交易（★）","uri":"/leetcode/1169/"},{"categories":null,"content":" 力扣第 149 场周赛第 1 题 ","date":"2019-08-11","objectID":"/leetcode/1154/:0:0","tags":null,"title":"1154：一年中的第几天","uri":"/leetcode/1154/"},{"categories":null,"content":"题目 给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。返回该日期是当年的第几天。 示例 1： 输入：date = \"2019-01-09\" 输出：9 解释：给定日期是2019年的第九天。 示例 2： 输入：date = \"2019-02-10\" 输出：41 提示： date.length == 10 date[4] == date[7] == '-'，其他的 date[i] 都是数字 date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日 ","date":"2019-08-11","objectID":"/leetcode/1154/:1:0","tags":null,"title":"1154：一年中的第几天","uri":"/leetcode/1154/"},{"categories":null,"content":"分析 可以直接调库，time或者datetime。 ","date":"2019-08-11","objectID":"/leetcode/1154/:2:0","tags":null,"title":"1154：一年中的第几天","uri":"/leetcode/1154/"},{"categories":null,"content":"解答 def dayOfYear(self, date: str) -\u003e int: import datetime y, m, d = map(int, date.split('-')) return (datetime.date(y, m, d)-datetime.date(y, 1, 1)).days+1 48 ms ","date":"2019-08-11","objectID":"/leetcode/1154/:3:0","tags":null,"title":"1154：一年中的第几天","uri":"/leetcode/1154/"},{"categories":null,"content":" 力扣第 148 场周赛第 3 题 ","date":"2019-08-04","objectID":"/leetcode/1146/:0:0","tags":null,"title":"1146：快照数组（★）","uri":"/leetcode/1146/"},{"categories":null,"content":"题目 实现支持下列接口的「快照数组」- SnapshotArray： SnapshotArray(int length) - 初始化一个与指定长度相等的 类数组 的数据结构。初始时，每个元素都等于 0。 void set(index, val) - 会将指定索引 index 处的元素设置为 val。 int snap() - 获取该数组的快照，并返回快照的编号 snap_id（快照号是调用 snap() 的总次数减去 1）。 int get(index, snap_id) - 根据指定的 snap_id 选择快照，并返回该快照指定索引 index 的值。 示例： 输入：[\"SnapshotAr","date":"2019-08-04","objectID":"/leetcode/1146/:1:0","tags":null,"title":"1146：快照数组（★）","uri":"/leetcode/1146/"},{"categories":null,"content":"分析 set 时保存此时的快照号和值，get 时二分查找到即可。 ","date":"2019-08-04","objectID":"/leetcode/1146/:2:0","tags":null,"title":"1146：快照数组（★）","uri":"/leetcode/1146/"},{"categories":null,"content":"解答 class SnapshotArray: def __init__(self, length: int): self.sid = 0 self.d = defaultdict(list) def set(self, index: int, val: int) -\u003e None: self.d[index].append((self.sid, val)) def snap(self) -\u003e int: self.sid += 1 return self.sid-1 def get(self, index: int, snap_id: int) -\u003e int: pos = bisect_righ","date":"2019-08-04","objectID":"/leetcode/1146/:3:0","tags":null,"title":"1146：快照数组（★）","uri":"/leetcode/1146/"},{"categories":null,"content":" 力扣第 1143 题 ","date":"2019-07-31","objectID":"/leetcode/1143/:0:0","tags":null,"title":"1143：最长公共子序列（★）","uri":"/leetcode/1143/"},{"categories":null,"content":"题目 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例 1： 输入：text1 = \"abcde\", text2 = \"ace\" 输出：3 解释：最长公共子序列是 \"ace\" ，它的长度为 3 。 示例 2： ","date":"2019-07-31","objectID":"/leetcode/1143/:1:0","tags":null,"title":"1143：最长公共子序列（★）","uri":"/leetcode/1143/"},{"categories":null,"content":"分析 ","date":"2019-07-31","objectID":"/leetcode/1143/:2:0","tags":null,"title":"1143：最长公共子序列（★）","uri":"/leetcode/1143/"},{"categories":null,"content":"#1 先考虑递归。 若 text1[0]==text2[0] 转为递归子问题 text1[1:] 和 text2[1:] 的最长公共序列长度 如果不等，那公共序列必然是两种情况之一： 不包含 text1[0] 等价于递归子问题 text1[1:] 和 text2 的最长公共序列长度 不包含 text2[0] 等价于递归子问题 text1 和 text2[1:] 的最长公共序列长度 再考虑边界条件，即可写出递归解法。 @lru_cache(None) def longestCommonSubsequence(self, text1: str, text2: str) -\u003e int: if not","date":"2019-07-31","objectID":"/leetcode/1143/:2:1","tags":null,"title":"1143：最长公共子序列（★）","uri":"/leetcode/1143/"},{"categories":null,"content":"#2 改写为动态规划，令 dp[i][j] 表示 text1[:i] 和 text2[:j] 的最长公共序列长度，则： if i==0 or j==0: dp[i][j] = 0 elif text1[i-1]==text2[j-1]: dp[i][j] = 1+dp[i-1][j-1] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) ","date":"2019-07-31","objectID":"/leetcode/1143/:2:2","tags":null,"title":"1143：最长公共子序列（★）","uri":"/leetcode/1143/"},{"categories":null,"content":"解答 def longestCommonSubsequence(self, text1: str, text2: str) -\u003e int: m, n = len(text1), len(text2) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): dp[i][j] = 1+dp[i-1][j-1] if text1[i-1]==text2[j-1] else max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1] 384 ms ","date":"2019-07-31","objectID":"/leetcode/1143/:3:0","tags":null,"title":"1143：最长公共子序列（★）","uri":"/leetcode/1143/"},{"categories":null,"content":" 力扣第 147 场周赛第 4 题 ","date":"2019-07-28","objectID":"/leetcode/1140/:0:0","tags":null,"title":"1140：石子游戏 II（★★）","uri":"/leetcode/1140/"},{"categories":null,"content":"题目 爱丽丝和鲍勃继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。 爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初，M = 1。 在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 \u003c= X \u003c= 2M。然后，令 M = max(M, X)。 游戏一直持续到所有石子都被拿走。 假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。 示例 1： 输入：piles = [2,7,9,4,4] 输出：10 解释：如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 +","date":"2019-07-28","objectID":"/leetcode/1140/:1:0","tags":null,"title":"1140：石子游戏 II（★★）","uri":"/leetcode/1140/"},{"categories":null,"content":"分析 这类问题先考虑能否递归。类似 0486 ，但发现 M 会影响过程。 所以用辅助函数 help(i, m) 表示初始 M=m，用 piles[i:] 玩游戏亚历克斯最多能拿到石头的数量。 亚历克斯先拿 X 堆石子，M 变为 max(m,X)，转为求递归子问题 help(i+X, max(m, X))。 help(i+X, max(m, X)) 等价于剩下的石子中李最多拿到的石头个数。 两个人一共拿的石子是固定的 sum(piles[i:])，因此遍历 X 找到最小的 help(i+X, max(m, X)) 即可。 再考虑下边界条件，剩下的堆数 \u003c= 2*m 时，全部拿走即可。便可以写出递","date":"2019-07-28","objectID":"/leetcode/1140/:2:0","tags":null,"title":"1140：石子游戏 II（★★）","uri":"/leetcode/1140/"},{"categories":null,"content":"解答 def stoneGameII(self, piles: List[int]) -\u003e int: @lru_cache(None) def help(i, m): res = sum(piles[i:]) if len(piles)-i \u003e 2*m: res -= min(help(i+X,max(X,m)) for X in range(1, 2*m+1)) return res return help(0, 1) 196 ms ","date":"2019-07-28","objectID":"/leetcode/1140/:3:0","tags":null,"title":"1140：石子游戏 II（★★）","uri":"/leetcode/1140/"},{"categories":null,"content":"*附加 可以改写成动态规划。令 dp[i][j] 代表初始 M=j，用 piles[i:] 玩游戏亚历克斯最多能拿到石头的数量。 状态转移方程为： if len(piles)-i \u003c= 2*j: dp[i][j] = sum(piles[i:]) else: dp[i][j] = sum(piles[i:]) - min(dp[i+X][max(X,j)] for X in range(1, 2*j+1)) 显然遍历时 i 应该倒序。 def stoneGameII(self, piles: List[int]) -\u003e int: n = len(piles) dp, total = [[0]*","date":"2019-07-28","objectID":"/leetcode/1140/:4:0","tags":null,"title":"1140：石子游戏 II（★★）","uri":"/leetcode/1140/"},{"categories":null,"content":"　　天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间。元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？ ","date":"2019-07-26","objectID":"/anime/ne_zha/","tags":null,"title":"哪吒之魔童降世","uri":"/anime/ne_zha/"},{"categories":null,"content":"简介 天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间。元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？ 制作人员： 导演：杨宇 音乐：朱芸编 製作：霍尔果斯彩条屋影业有限公司、北京深海十月传媒有限公司、北京光线影业有限公司 动画制作：成都可可豆动画影视","date":"2019-07-26","objectID":"/anime/ne_zha/:1:0","tags":null,"title":"哪吒之魔童降世","uri":"/anime/ne_zha/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哪吒之魔童降世 2019-07-26 01:49:59 片库网 ","date":"2019-07-26","objectID":"/anime/ne_zha/:2:0","tags":null,"title":"哪吒之魔童降世","uri":"/anime/ne_zha/"},{"categories":null,"content":" 力扣第 146 场周赛第 3 题 ","date":"2019-07-21","objectID":"/leetcode/1130/:0:0","tags":null,"title":"1130：叶值的最小代价生成树（★★）","uri":"/leetcode/1130/"},{"categories":null,"content":"题目 给你一个正整数数组 arr，考虑所有满足以下条件的二叉树： 每个节点都有 0 个或是 2 个子节点。\r数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）\r每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。\r在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。 示例： 输入：arr = [6,2,4]\r输出：32\r解释：\r有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。\r24 24\r/ \\ / \\\r12 4 6 8\r/ \\ / \\\r6 2 ","date":"2019-07-21","objectID":"/leetcode/1130/:1:0","tags":null,"title":"1130：叶值的最小代价生成树（★★）","uri":"/leetcode/1130/"},{"categories":null,"content":"分析 ","date":"2019-07-21","objectID":"/leetcode/1130/:2:0","tags":null,"title":"1130：叶值的最小代价生成树（★★）","uri":"/leetcode/1130/"},{"categories":null,"content":"#1 数据规模很小，考虑直接递归。满足条件的二叉树必然是以 arr[:i] 为左子树，arr[i:] 为右子树。 并且如果 len(arr) \u003e 1，左子树和右子树都至少有一个节点。 因此遍历位置 0\u003ci\u003clen(arr)，根节点的值为 max(arr[:i]) * max(arr[i:])，剩下的即为递归子问题。 def mctFromLeafValues(self, arr: List[int]) -\u003e int: @lru_cache(None) def help(i, j): if i == j-1: return 0 return min(help(i, k)+help(k, j)+m","date":"2019-07-21","objectID":"/leetcode/1130/:2:1","tags":null,"title":"1130：叶值的最小代价生成树（★★）","uri":"/leetcode/1130/"},{"categories":null,"content":"#2 本题有个很巧妙的单调栈解法。 本题可以等价于一个数组问题：每一轮从 arr 中选择两个相邻的数，得到一个乘积，并删除较小的那个数，直到数组长度小于 2，求最小的乘积之和。 如果存在 arr[i-1] \u003e= arr[i] \u003c= arr[i+1]，最终 arr[i] 必然是要被删除的（或者等价于 arr[i] 被删除）。 假设最优方略是在删除了 arr[i-1] 或 arr[i+1] 之后才删除的 arr[i]，arr[i] 相邻的两个数会相等或更大。那么改成先删除 arr[i]，不会比最优方案差。 因此遇到 arr[i-1] \u003e= arr[i] \u003c= arr[i+1] 时，即可先将 arr","date":"2019-07-21","objectID":"/leetcode/1130/:2:2","tags":null,"title":"1130：叶值的最小代价生成树（★★）","uri":"/leetcode/1130/"},{"categories":null,"content":"解答 def mctFromLeafValues(self, arr: List[int]) -\u003e int: res, stack = 0, [] for num in arr: while stack and stack[-1] \u003c= num: x = stack.pop() y = min(stack[-1], num) if stack else num res += x * y stack.append(num) while len(stack) \u003e 1: res += stack.pop() * stack[-1] return res 48 ms ","date":"2019-07-21","objectID":"/leetcode/1130/:3:0","tags":null,"title":"1130：叶值的最小代价生成树（★★）","uri":"/leetcode/1130/"},{"categories":null,"content":"「想要试着去往那道光芒当中」\n\n高中一年级的夏天。从离岛离家出走，来到东京的帆高。\n他的生活立刻变得困窘，在度过孤独的每一天之后终于找到的工作，\n是为古怪的超自然杂志撰稿。\n\n如同预示着他接下来的命运一般，连日不断降下雨水。\n此时，在人潮熙熙攘攘的都市一角，帆高遇到了一位少女。\n\n由于某些缘故，和弟弟两个人一起坚强生活的少女·阳菜。\n她拥有不可思议的能力。\n\n「呐，现在开始就要放晴了哦」\n\n雨水逐渐停止，街道笼罩在美丽的光芒中。\n那是，仅仅在心中祈祷，就能让天空放晴的力量——","date":"2019-07-19","objectID":"/anime/tenki_no_ko/","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":"简介 「想要试着去往那道光芒当中」 高中一年级的夏天。从离岛离家出走，来到东京的帆高。 他的生活立刻变得困窘，在度过孤独的每一天之后终于找到的工作， 是为古怪的超自然杂志撰稿。 如同预示着他接下来的命运一般，连日不断降下雨水。 此时，在人潮熙熙攘攘的都市一角，帆高遇到了一位少女。 由于某些缘故，和弟弟两个人一起坚强生活的少女·阳菜。 她拥有不可思议的能力。 「呐，现在开始就要放晴了哦」 雨水逐渐停止，街道笼罩在美丽的光芒中。 那是，仅仅在心中祈祷，就能让天空放晴的力量—— 制作人员： 原作：新海诚 演出：居村健治、德野悠我 音乐：RADWIMPS 人物设定：田中将贺、田村笃 ","date":"2019-07-19","objectID":"/anime/tenki_no_ko/:1:0","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天野阳菜 あまの ひな、Amano Hina 女 森七菜 2 森岛帆高 もりしま ほだか、Morishima Hodaka 男 醍醐虎汰朗 3 須贺圭介 すが けいすけ、Suga Keisuke 男 小栗旬 4 须贺夏美 すが なつみ、Suga Natsumi 女 本田翼 5 立花富美 たちばな ふみ、Tachibana Fumi 女 倍賞千恵子 6 天野凪 あまの なぎ、Amano Nagi 男 吉柳咲良 7 安井 男 平泉成 8 高井高司 高井高司、たかい たかし、Takai Takashi、高井刑事 男 梶裕貴 ","date":"2019-07-19","objectID":"/anime/tenki_no_ko/:2:0","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天气之子 2019-07-19 112m bilibili ","date":"2019-07-19","objectID":"/anime/tenki_no_ko/:3:0","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":"MAD ","date":"2019-07-19","objectID":"/anime/tenki_no_ko/:4:0","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":" 力扣第 145 场周赛第 3 题 ","date":"2019-07-14","objectID":"/leetcode/1124/:0:0","tags":null,"title":"1124：表现良好的最长时间段（★★）","uri":"/leetcode/1124/"},{"categories":null,"content":"题目 给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。 示例 1： 输入：hours = [9,9,6,0,6,6,9] 输出：3 解释：最长的表现良好时间段是 [9,9,6]。 示例 2： 输入：hours = [6,6,6] 输出：0 提示： 1 \u003c= hours.length \u003c= 104 0 \u003c= hours[i] \u003c= 16 ","date":"2019-07-14","objectID":"/leetcode/1124/:1:0","tags":null,"title":"1124：表现良好的最长时间段（★★）","uri":"/leetcode/1124/"},{"categories":null,"content":"分析 数据规模是 10^4，直接暴力会超时。为了方便，可以将大于 8 的位置赋值 1，其它的位置赋值 -1。问题即是求最长的子数组，其和大于 0。 有关子数组的和的问题，首先想到前缀和。得到前缀数组 pre 后，问题即是求最大的 j-i 使得 pre[i] \u003c pre[j]。 现在的问题非常类似 0962 ，用单调栈即可在 O(N) 时间解决。 ","date":"2019-07-14","objectID":"/leetcode/1124/:2:0","tags":null,"title":"1124：表现良好的最长时间段（★★）","uri":"/leetcode/1124/"},{"categories":null,"content":"解答 def longestWPI(self, hours: List[int]) -\u003e int: pre = list(accumulate([0]+hours, lambda x, y: x+(1 if y \u003e 8 else -1))) stack, n = [], len(pre) for i in range(n): if not stack or pre[stack[-1]] \u003e pre[i]: stack.append(i) res = 0 for j in range(n-1, -1, -1): while stack and pre[stack[-1]] \u003c pre[j]: r","date":"2019-07-14","objectID":"/leetcode/1124/:3:0","tags":null,"title":"1124：表现良好的最长时间段（★★）","uri":"/leetcode/1124/"},{"categories":null,"content":" 力扣第 1117 题 ","date":"2019-07-13","objectID":"/leetcode/1117/:0:0","tags":null,"title":"1117：H2O 生成（★）","uri":"/leetcode/1117/"},{"categories":null,"content":"题目 现在有两种线程，氧 oxygen 和氢 hydrogen，你的目标是组织这两种线程来产生水分子。 存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。 氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。 这些线程应该三三成组突破屏障并能立即组合产生一个水分子。 你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。 换句话说: 如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。 如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到","date":"2019-07-13","objectID":"/leetcode/1117/:1:0","tags":null,"title":"1117：H2O 生成（★）","uri":"/leetcode/1117/"},{"categories":null,"content":"分析 典型的并发问题，可以用信号量控制数量。 ","date":"2019-07-13","objectID":"/leetcode/1117/:2:0","tags":null,"title":"1117：H2O 生成（★）","uri":"/leetcode/1117/"},{"categories":null,"content":"解答 from threading import Semaphore class H2O: def __init__(self): self.h = Semaphore(2) self.o = Semaphore(1) def hydrogen(self, releaseHydrogen: 'Callable[[], None]') -\u003e None: self.h.acquire() # releaseHydrogen() outputs \"H\". Do not change or remove this line. releaseHydrogen() if self.h._value == ","date":"2019-07-13","objectID":"/leetcode/1117/:3:0","tags":null,"title":"1117：H2O 生成（★）","uri":"/leetcode/1117/"},{"categories":null,"content":" 力扣第 1116 题 ","date":"2019-07-12","objectID":"/leetcode/1116/:0:0","tags":null,"title":"1116：打印零与奇偶数（★）","uri":"/leetcode/1116/"},{"categories":null,"content":"题目 现有函数 printNumber 可以用一个整数参数调用，并输出该整数到控制台。 例如，调用 printNumber(7) 将会输出 7 到控制台。 给你类 ZeroEvenOdd 的一个实例，该类中有三个函数：zero、even 和 odd 。ZeroEvenOdd 的相同实例将会传递给三个不同线程： 线程 A：调用 zero() ，只输出 0 线程 B：调用 even() ，只输出偶数 线程 C：调用 odd() ，只输出奇数 修改给出的类，以输出序列 \"010203040506...\" ，其中序列的长度必须为 2n 。 实现 ZeroEvenOdd 类： ZeroEvenOdd(i","date":"2019-07-12","objectID":"/leetcode/1116/:1:0","tags":null,"title":"1116：打印零与奇偶数（★）","uri":"/leetcode/1116/"},{"categories":null,"content":"分析 典型的并发问题，最常用的是互斥锁。 ","date":"2019-07-12","objectID":"/leetcode/1116/:2:0","tags":null,"title":"1116：打印零与奇偶数（★）","uri":"/leetcode/1116/"},{"categories":null,"content":"解答 from threading import Lock class ZeroEvenOdd: def __init__(self, n): self.n = n self.lock0 = Lock() self.lock1 = Lock() self.lock2 = Lock() self.lock1.acquire() self.lock2.acquire() def zero(self, printNumber: 'Callable[[int], None]') -\u003e None: for i in range(self.n): self.lock0.acquire() printNum","date":"2019-07-12","objectID":"/leetcode/1116/:3:0","tags":null,"title":"1116：打印零与奇偶数（★）","uri":"/leetcode/1116/"},{"categories":null,"content":" 力扣第 1115 题 ","date":"2019-07-11","objectID":"/leetcode/1115/:0:0","tags":null,"title":"1115：交替打印 FooBar（★）","uri":"/leetcode/1115/"},{"categories":null,"content":"题目 给你一个类： class FooBar { public void foo() { for (int i = 0; i \u003c n; i++) { print(\"foo\"); } } public void bar() { for (int i = 0; i \u003c n; i++) { print(\"bar\"); } } } 两个不同的线程将会共用一个 FooBar 实例： 线程 A 将会调用 foo() 方法，而 线程 B 将会调用 bar() 方法 请设计修改程序，以确保 \"foobar\" 被输出 n 次。 示例 1： 输入：n = 1 输出：\"foobar\" 解释：这里有两个线程被异步启动","date":"2019-07-11","objectID":"/leetcode/1115/:1:0","tags":null,"title":"1115：交替打印 FooBar（★）","uri":"/leetcode/1115/"},{"categories":null,"content":"分析 典型的并发问题，最常用的是互斥锁。 ","date":"2019-07-11","objectID":"/leetcode/1115/:2:0","tags":null,"title":"1115：交替打印 FooBar（★）","uri":"/leetcode/1115/"},{"categories":null,"content":"解答 from threading import Lock class FooBar: def __init__(self, n): self.n = n self.lock1 = Lock() self.lock2 = Lock() self.lock2.acquire() def foo(self, printFoo: 'Callable[[], None]') -\u003e None: for i in range(self.n): self.lock1.acquire() printFoo() self.lock2.release() def bar(self, printBar: 'Call","date":"2019-07-11","objectID":"/leetcode/1115/:3:0","tags":null,"title":"1115：交替打印 FooBar（★）","uri":"/leetcode/1115/"},{"categories":null,"content":" 力扣第 1114 题 ","date":"2019-07-10","objectID":"/leetcode/1114/:0:0","tags":null,"title":"1114：按序打印","uri":"/leetcode/1114/"},{"categories":null,"content":"题目 给你一个类： public class Foo { public void first() { print(\"first\"); } public void second() { print(\"second\"); } public void third() { print(\"third\"); } } 三个不同的线程 A、B、C 将会共用一个 Foo 实例。 线程 A 将会调用 first() 方法 线程 B 将会调用 second() 方法 线程 C 将会调用 third() 方法 请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 s","date":"2019-07-10","objectID":"/leetcode/1114/:1:0","tags":null,"title":"1114：按序打印","uri":"/leetcode/1114/"},{"categories":null,"content":"分析 典型的并发问题，最常用的是互斥锁。 ","date":"2019-07-10","objectID":"/leetcode/1114/:2:0","tags":null,"title":"1114：按序打印","uri":"/leetcode/1114/"},{"categories":null,"content":"解答 from threading import Lock class Foo: def __init__(self): self.lock1 = Lock() self.lock2 = Lock() self.lock1.acquire() self.lock2.acquire() def first(self, printFirst: 'Callable[[], None]') -\u003e None: printFirst() self.lock1.release() def second(self, printSecond: 'Callable[[], None]') -\u003e None: wit","date":"2019-07-10","objectID":"/leetcode/1114/:3:0","tags":null,"title":"1114：按序打印","uri":"/leetcode/1114/"},{"categories":null,"content":" 力扣第 144 场周赛第 4 题 ","date":"2019-07-07","objectID":"/leetcode/1111/:0:0","tags":null,"title":"1111：有效括号的嵌套深度（★）","uri":"/leetcode/1111/"},{"categories":null,"content":"题目 有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。 嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。 有效括号字符串类型与对应的嵌套深度计算方法如下图所示： 给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。 不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。 A 或 B 中的元素在原字符串中可以不连续。 A.length + B","date":"2019-07-07","objectID":"/leetcode/1111/:1:0","tags":null,"title":"1111：有效括号的嵌套深度（★）","uri":"/leetcode/1111/"},{"categories":null,"content":"分析 ","date":"2019-07-07","objectID":"/leetcode/1111/:2:0","tags":null,"title":"1111：有效括号的嵌套深度（★）","uri":"/leetcode/1111/"},{"categories":null,"content":"#1 根据 1614 可以得到每个括号所处的深度。 为了使拆分后的深度最小，可以将深度为奇数的都给 A，偶数的都给 B，从而尽量接近最大深度的一半。 def maxDepthAfterSplit(self, seq: str) -\u003e List[int]: res, size = [], 0 for char in seq: size += 1 if char == '(' else -1 res.append(size\u00261 if char == '(' else size\u00261^1) return res 32 ms ","date":"2019-07-07","objectID":"/leetcode/1111/:2:1","tags":null,"title":"1111：有效括号的嵌套深度（★）","uri":"/leetcode/1111/"},{"categories":null,"content":"#2 观察可知，size+=1 和 size-=1 其实对深度的奇偶性没有影响。所以可以直接用位置 i 代替 size。 ","date":"2019-07-07","objectID":"/leetcode/1111/:2:2","tags":null,"title":"1111：有效括号的嵌套深度（★）","uri":"/leetcode/1111/"},{"categories":null,"content":"解答 def maxDepthAfterSplit(self, seq: str) -\u003e List[int]: return [i\u00261 if char=='(' else i\u00261^1 for i, char in enumerate(seq)] 44 ms ","date":"2019-07-07","objectID":"/leetcode/1111/:3:0","tags":null,"title":"1111：有效括号的嵌套深度（★）","uri":"/leetcode/1111/"},{"categories":null,"content":"公元10世纪末期，以战争掠夺为生的最强民族·维京人席卷世界。\n被讴歌为最强战士的儿子·托尔芬，自小便生活在战场上，并向往着梦幻大陆“文兰（VINLAND）”——\n这是一个发生在激荡时代的，真正的战士物语。","date":"2019-07-07","objectID":"/anime/vinland_saga/","tags":null,"title":"冰海战记","uri":"/anime/vinland_saga/"},{"categories":null,"content":"简介 公元10世纪末期，以战争掠夺为生的最强民族·维京人席卷世界。 被讴歌为最强战士的儿子·托尔芬，自小便生活在战场上，并向往着梦幻大陆“文兰（VINLAND）”—— 这是一个发生在激荡时代的，真正的战士物语。 制作人员： 原作：幸村诚 导演：薮田修平 脚本：猪原健太、濑古浩司 分镜：村田和也、小林敦、佐野隆史、长沼范裕、大桥誉志光 ","date":"2019-07-07","objectID":"/anime/vinland_saga/:1:0","tags":null,"title":"冰海战记","uri":"/anime/vinland_saga/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 托尔芬 Thorfinn Thordarson 男 上村祐翔 2 阿谢拉德 Lucius Artorius Castus、ルキウス・アルトリウス・カストゥス、卢修斯·阿托利乌斯·卡斯图斯、阿谢拉特、Askeladd 男 内田直哉 3 托尔兹 Toles 男 松田健一郎 4 克努特 Canute 男 小野賢章 5 托鲁克尔 Thorkell 男 大塚明夫 6 表伦 比约恩、Bjorn 男 安元洋貴 7 弗洛基 Floki 男 斧アツシ 8 雷夫 雷夫·埃里克森、Leif Ericson 男 上田燿司 ","date":"2019-07-07","objectID":"/anime/vinland_saga/:2:0","tags":null,"title":"冰海战记","uri":"/anime/vinland_saga/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 冰海战记 2019-07-07 24 bilibili 2 冰海战记 第二季 2023-01-09 24 樱花 ","date":"2019-07-07","objectID":"/anime/vinland_saga/:3:0","tags":null,"title":"冰海战记","uri":"/anime/vinland_saga/"},{"categories":null,"content":"MAD ","date":"2019-07-07","objectID":"/anime/vinland_saga/:4:0","tags":null,"title":"冰海战记","uri":"/anime/vinland_saga/"},{"categories":null,"content":"被浪费的青春——\n偏差值差不多的田中（通称“笨蛋”）、沉迷于BL的菊池（通称：“御宅”）、面无表情的才女・鹭宫（通称“机”）。个性十足的女高中生们无所事事的日常校园生活——","date":"2019-07-05","objectID":"/anime/jyoshi_muda/","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":"简介 被浪费的青春—— 偏差值差不多的田中（通称“笨蛋”）、沉迷于BL的菊池（通称：“御宅”）、面无表情的才女・鹭宫（通称“机”）。个性十足的女高中生们无所事事的日常校园生活—— 制作人员： 原作：ビーノ 导演：三瓶圣 脚本：坂井史世、横谷昌宏、福田裕子 分镜：神谷智大、铃木吉男、石黑达也、橘纱央莉 ","date":"2019-07-05","objectID":"/anime/jyoshi_muda/:1:0","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 田中望 笨蛋、たなか のぞむ、Tanaka Nozomu、バカ 女 赤﨑千夏 2 菊池茜 阿宅、きくち あかね、Kikuchi Akane、ヲタ 女 戸松遥 3 鹭宫栞 机器人、さぎのみや しおり、Saginomiya Shiori、ロボ 女 豊崎愛生 4 百井咲久 萝莉、ももい さく、Momoi Saku、ロリ 女 長縄まりあ 5 山本美波 有病、やまもと みなみ、Yamamoto Minami、ヤマイ 女 富田美憂 6 一奏 死认真、にのまえ かなで、Ninomae Kanade、マジメ 女 高橋李依 7 染谷莉莉 百合、そめや リリィ、Someya L","date":"2019-07-05","objectID":"/anime/jyoshi_muda/:2:0","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 女高中生的无所事事 2019-07-05 12 bilibili ","date":"2019-07-05","objectID":"/anime/jyoshi_muda/:3:0","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":"MAD ","date":"2019-07-05","objectID":"/anime/jyoshi_muda/:4:0","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":" 力扣第 143 场周赛第 2 题 ","date":"2019-06-30","objectID":"/leetcode/1104/:0:0","tags":null,"title":"1104：二叉树寻路（★）","uri":"/leetcode/1104/"},{"categories":null,"content":"题目 在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。 如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记； 而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。 给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。 示例 1： 输入：label = 14\r输出：[1,3,4,14]\r示例 2： 输入：label = 26\r输出：[1,2,6,10,26]\r提示： 1 \u003c= label \u003c= 10^6\r","date":"2019-06-30","objectID":"/leetcode/1104/:1:0","tags":null,"title":"1104：二叉树寻路（★）","uri":"/leetcode/1104/"},{"categories":null,"content":"分析 如果是原本的满二叉树，节点 x 的父节点就是 x//2，递推即可。 本题在偶数行反转了序号，因此需要找到 x 在该层对应的镜像节点 y，才是原本的序号。 第 h 层的序号范围是 [2^(h-1), 2^h-1]，因此 y = 2^(h-1)+2^h-1-x。 每层递推即可。 ","date":"2019-06-30","objectID":"/leetcode/1104/:2:0","tags":null,"title":"1104：二叉树寻路（★）","uri":"/leetcode/1104/"},{"categories":null,"content":"解答 def pathInZigZagTree(self, label: int) -\u003e List[int]: res = [label] while label \u003e 1: label = ((1 \u003c\u003c (label.bit_length() - 1)) * 3 - 1 - label) // 2 res.append(label) return res[::-1] 24 ms ","date":"2019-06-30","objectID":"/leetcode/1104/:3:0","tags":null,"title":"1104：二叉树寻路（★）","uri":"/leetcode/1104/"},{"categories":null,"content":" 力扣第 142 场周赛第 3 题 ","date":"2019-06-23","objectID":"/leetcode/1095/:0:0","tags":null,"title":"1095：山脉数组中查找目标值（★★）","uri":"/leetcode/1095/"},{"categories":null,"content":"题目 （这是一个 交互式问题 ） 给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。 如果不存在这样的下标 index，就请返回 -1。 何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件： 首先，A.length \u003e= 3 其次，在 0 \u003c i \u003c A.length - 1 条件下，存在 i 使得： A[0] \u003c A[1] \u003c ... A[i-1] \u003c A[i]\rA[i] \u003e A[i+1] \u003e ... \u003e A[A.length - 1]\r你将 不能直接访问该山脉数组，必须","date":"2019-06-23","objectID":"/leetcode/1095/:1:0","tags":null,"title":"1095：山脉数组中查找目标值（★★）","uri":"/leetcode/1095/"},{"categories":null,"content":"分析 可以先二分查找到山顶坐标 mid（第一个满足 A[i]\u003eA[i+1] 的 i)，然后 [0, mid], [mid, n-1] 区间都是单调的， 可以分别二分查找 target。 ","date":"2019-06-23","objectID":"/leetcode/1095/:2:0","tags":null,"title":"1095：山脉数组中查找目标值（★★）","uri":"/leetcode/1095/"},{"categories":null,"content":"解答 def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -\u003e int: n = mountain_arr.length() self.__class__.__getitem__ = lambda self, i: mountain_arr.get(i)\u003emountain_arr.get(i+1) mid = bisect_left(self, True, 1, n-2) self.__class__.__getitem__ = lambda self, i: mountain_arr.get(i)","date":"2019-06-23","objectID":"/leetcode/1095/:3:0","tags":null,"title":"1095：山脉数组中查找目标值（★★）","uri":"/leetcode/1095/"},{"categories":null,"content":"向水日奈子因考上大学而搬来海边城镇居住，她非常喜欢冲浪，觉得自己只要站在海浪之上就无所畏惧。但其实，她是一个对自己未来没有什么自信的人。因为某场火灾，日奈子和消防员雏罂粟港相遇。通过一起冲浪等经历，日奈子开始被总是为了别人着想的港所吸引。而港的心中，也萌发了对日奈子的特殊情感。","date":"2019-06-21","objectID":"/anime/kimi_nami/","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":"简介 向水日奈子因考上大学而搬来海边城镇居住，她非常喜欢冲浪，觉得自己只要站在海浪之上就无所畏惧。但其实，她是一个对自己未来没有什么自信的人。因为某场火灾，日奈子和消防员雏罂粟港相遇。通过一起冲浪等经历，日奈子开始被总是为了别人着想的港所吸引。而港的心中，也萌发了对日奈子的特殊情感。 制作人员： 导演：汤浅政明 脚本：吉田玲子 音乐：大岛满 人物设定：小岛崇史 美术监督：赤井文尚 色彩设计：中村绚郁 摄影监督：福士享 原画：前场健次 ","date":"2019-06-21","objectID":"/anime/kimi_nami/:1:0","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雏罂粟港 雛罌粟 港、ひなげし みなと、Hinageshi Minato 男 山崎智史 2 向水日奈子 むかいみず ひなこ、Mukaizumi Hinako 女 木野日菜 3 雏罂粟洋子 ひなげし ようこ、Hinageshi Yoko 女 松本穂香 4 川村山葵 かわむら わさび、Kawamura Wasabi 男 伊藤健太郎 ","date":"2019-06-21","objectID":"/anime/kimi_nami/:2:0","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 若能与你共乘海浪之上 2019-06-21 95m bilibili ","date":"2019-06-21","objectID":"/anime/kimi_nami/:3:0","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":"MAD ","date":"2019-06-21","objectID":"/anime/kimi_nami/:4:0","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":" 力扣第 141 场周赛第 3 题 ","date":"2019-06-16","objectID":"/leetcode/1091/:0:0","tags":null,"title":"1091：二进制矩阵中的最短路径（★）","uri":"/leetcode/1091/"},{"categories":null,"content":"题目 给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。 二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求： 路径途经的所有单元格都的值都是 0 。 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。 畅通路径的长度 是该路径途经的单元格总数。 示例 1： 输入：grid = [[0,1],[1,0]] 输出：2 示例 2： 输入：grid = [[0,0,0],[","date":"2019-06-16","objectID":"/leetcode/1091/:1:0","tags":null,"title":"1091：二进制矩阵中的最短路径（★）","uri":"/leetcode/1091/"},{"categories":null,"content":"分析 典型的 bfs。 ","date":"2019-06-16","objectID":"/leetcode/1091/:2:0","tags":null,"title":"1091：二进制矩阵中的最短路径（★）","uri":"/leetcode/1091/"},{"categories":null,"content":"解答 def shortestPathBinaryMatrix(self, grid: List[List[int]]) -\u003e int: if grid[0][0]: return -1 n = len(grid) Q, vis = deque([(0, 0, 1)]), {(0, 0)} while Q: r,c,k = Q.popleft() if r==c==n-1: return k for x,y in product(range(r-1, r+2), range(c-1, c+2)): if 0\u003c=x\u003cn and 0\u003c=y\u003cn and grid[x][y]==0 and (x,y)","date":"2019-06-16","objectID":"/leetcode/1091/:3:0","tags":null,"title":"1091：二进制矩阵中的最短路径（★）","uri":"/leetcode/1091/"},{"categories":null,"content":" 力扣第 140 场周赛第 4 题 ","date":"2019-06-09","objectID":"/leetcode/1081/:0:0","tags":null,"title":"1081：不同字符的最小子序列（★★）","uri":"/leetcode/1081/"},{"categories":null,"content":"题目 返回 s 字典序最小的子序列，该子序列包含 s 的所有不同字符，且只包含一次。 注意：该题与 316 https://leetcode.com/problems/remove-duplicate-letters/ 相同 示例 1： 输入：s = \"bcabc\" 输出：\"abc\" 示例 2： 输入：s = \"cbacdcbc\" 输出：\"acdb\" 提示： 1 \u003c= s.length \u003c= 1000 s 由小写英文字母组成 ","date":"2019-06-09","objectID":"/leetcode/1081/:1:0","tags":null,"title":"1081：不同字符的最小子序列（★★）","uri":"/leetcode/1081/"},{"categories":null,"content":"分析 与 0316 完全相同。 ","date":"2019-06-09","objectID":"/leetcode/1081/:2:0","tags":null,"title":"1081：不同字符的最小子序列（★★）","uri":"/leetcode/1081/"},{"categories":null,"content":"解答 def smallestSubsequence(self, s: str) -\u003e str: tmp = '' for i, char in enumerate(s): if char not in tmp: while tmp and tmp[-1]\u003echar and s.find(tmp[-1], i)!=-1: tmp = tmp[:-1] tmp += char return tmp 40 ms ","date":"2019-06-09","objectID":"/leetcode/1081/:3:0","tags":null,"title":"1081：不同字符的最小子序列（★★）","uri":"/leetcode/1081/"},{"categories":null,"content":" 力扣第 140 场周赛第 3 题 ","date":"2019-06-09","objectID":"/leetcode/1080/:0:0","tags":null,"title":"1080：根到叶路径上的不足节点（★★）","uri":"/leetcode/1080/"},{"categories":null,"content":"题目 给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点） 假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。 请你删除所有不足节点，并返回生成的二叉树的根。 示例 1： 输入：root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1 输出：[1,2,3,4,null,null,7,8,9,null,14] 示例 2： 输入：root = [5,4,8,11,null,","date":"2019-06-09","objectID":"/leetcode/1080/:1:0","tags":null,"title":"1080：根到叶路径上的不足节点（★★）","uri":"/leetcode/1080/"},{"categories":null,"content":"分析 典型的递归问题。令 dfs(node, s) 代表限制为 s 时 node 删除得到的树： 叶子节点如果值小于 s，返回空即可 否则，递归得到左右子树 dfs(node.left,s-node.val), dfs(node.right,s-node.val) 如果左右子树都为空，则返回空 ","date":"2019-06-09","objectID":"/leetcode/1080/:2:0","tags":null,"title":"1080：根到叶路径上的不足节点（★★）","uri":"/leetcode/1080/"},{"categories":null,"content":"解答 def sufficientSubset(self, root: Optional[TreeNode], limit: int) -\u003e Optional[TreeNode]: def dfs(node, s): if not node: return if not node.left and not node.right: return None if node.val\u003cs else node node.left = dfs(node.left, s-node.val) node.right = dfs(node.right, s-node.val) return node if nod","date":"2019-06-09","objectID":"/leetcode/1080/:3:0","tags":null,"title":"1080：根到叶路径上的不足节点（★★）","uri":"/leetcode/1080/"},{"categories":null,"content":"海洋生物发出光芒的同时，从地球的各个角落群聚而来。庞大的座头鲸奏着“歌曲”的同时，缓缓消失于海底之中。迎接“重头戏”的到来，海洋的一切一切开始移动了――\n不擅于以言语表达自己所思所想的中学生琉花，在暑假初日的社团活动中与队友发生争执。炎炎夏日之中，与母亲保持距离的她在校内、在家里都失去了自己的立足之所。她走到父亲工作的水族馆，伫立于大水槽前回想着过往与父母的一点一滴之际，遇上了在眼前与鱼群一同游泳的神秘少年“海”和他的哥哥“空”。\n“他们呢，是儒艮养大的。”琉花的爸爸说――\n性格开朗又天真无邪的“海”、以及像是能够看穿一切的“空”。琉花就像被他们引导着，一步一步接触她从没看到过的不可思议的世界。适逢三人的相遇，地球上同时出现了各式各样的异变。夜空中闪烁的流星突然坠落大海，海洋的所有生物开始往日本移动；甚至连庞大的座头鲸都出现，奏着“歌曲”向所有海洋生物传递“祭典的重头戏就快来了”的信息。知晓“海”与“空”两兄弟与各种超自然现象有关系、并打算加以利用他们的人；即使如此还是努力守护两兄弟的海洋学者吉姆和安格拉。各种思绪交错的人们，究竟能解开生命的种种谜团吗？“海”与“空”究竟从哪里而来，“重头戏”又是什么？\n这是琉花所接触到，一段“生命”的故事。","date":"2019-06-07","objectID":"/anime/children_of_the_sea/","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":"简介 海洋生物发出光芒的同时，从地球的各个角落群聚而来。庞大的座头鲸奏着“歌曲”的同时，缓缓消失于海底之中。迎接“重头戏”的到来，海洋的一切一切开始移动了―― 不擅于以言语表达自己所思所想的中学生琉花，在暑假初日的社团活动中与队友发生争执。炎炎夏日之中，与母亲保持距离的她在校内、在家里都失去了自己的立足之所。她走到父亲工作的水族馆，伫立于大水槽前回想着过往与父母的一点一滴之际，遇上了在眼前与鱼群一同游泳的神秘少年“海”和他的哥哥“空”。 “他们呢，是儒艮养大的。”琉花的爸爸说―― 性格开朗又天真无邪的“海”、以及像是能够看穿一切的“空”。琉花就像被他们引导着，一步一步接触她从没看到过的不可思议","date":"2019-06-07","objectID":"/anime/children_of_the_sea/:1:0","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安海琉花 女 芦田愛菜 2 海 男 石橋陽彩 3 空 男 浦上晟周 4 アングラード 男 森崎ウィン 5 ジム・キューザック 男 田中泯 6 安海加奈子 女 蒼井優 7 安海正明 男 稲垣吾郎 8 蒂蒂 女 富司純子 ","date":"2019-06-07","objectID":"/anime/children_of_the_sea/:2:0","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海兽之子 2019-06-07 01:51:18 bilibili ","date":"2019-06-07","objectID":"/anime/children_of_the_sea/:3:0","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":"MAD ","date":"2019-06-07","objectID":"/anime/children_of_the_sea/:4:0","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":" 力扣第 139 场周赛第 3 题 ","date":"2019-06-02","objectID":"/leetcode/1073/:0:0","tags":null,"title":"1073：负二进制数相加（★★）","uri":"/leetcode/1073/"},{"categories":null,"content":"题目 给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。 数字以 数组形式 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，arr = [1,1,0,1] 表示数字 (-2)^3 + (-2)^2 + (-2)^0 = -3。数组形式 中的数字 arr 也同样不含前导零：即 arr == [0] 或 arr[0] == 1。 返回相同表示形式的 arr1 和 arr2 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。 示例 1： 输入：arr1 = [1,1,1,1,1], arr2 = [1,0,1] 输出：[1,","date":"2019-06-02","objectID":"/leetcode/1073/:1:0","tags":null,"title":"1073：负二进制数相加（★★）","uri":"/leetcode/1073/"},{"categories":null,"content":"分析 模拟进位加法即可，因为是负进制，所以进位数 carry 要取反。 最后注意要去掉前导0。 ","date":"2019-06-02","objectID":"/leetcode/1073/:2:0","tags":null,"title":"1073：负二进制数相加（★★）","uri":"/leetcode/1073/"},{"categories":null,"content":"解答 def addNegabinary(self, arr1: List[int], arr2: List[int]) -\u003e List[int]: res, carry = [], 0 while arr1 or arr2 or carry: a, b = arr1.pop() if arr1 else 0, arr2.pop() if arr2 else 0 carry, r = divmod(a+b-carry, 2) res.append(r) while len(res)\u003e1 and res[-1]==0: res.pop() return res[::-1] 36 ms ","date":"2019-06-02","objectID":"/leetcode/1073/:3:0","tags":null,"title":"1073：负二进制数相加（★★）","uri":"/leetcode/1073/"},{"categories":null,"content":" 力扣第 139 场周赛第 2 题 ","date":"2019-06-02","objectID":"/leetcode/1072/:0:0","tags":null,"title":"1072：按列翻转得到最大值等行数（★）","uri":"/leetcode/1072/"},{"categories":null,"content":"题目 给定 m x n 矩阵 matrix 。 你可以从中选出任意数量的列并翻转其上的 每个 单元格。（即翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。） 返回 经过一些翻转后，行与行之间所有值都相等的最大行数 。 示例 1： 输入：matrix = [[0,1],[1,1]] 输出：1 解释：不进行翻转，有 1 行所有值都相等。 示例 2： 输入：matrix = [[0,1],[1,0]] 输出：2 解释：翻转第一列的值之后，这两行都由相等的值组成。 示例 3： 输入：matrix = [[0,0,0],[0,0,1],[1,1,0]] 输出：2 解释：翻转前两列的值之后，后","date":"2019-06-02","objectID":"/leetcode/1072/:1:0","tags":null,"title":"1072：按列翻转得到最大值等行数（★）","uri":"/leetcode/1072/"},{"categories":null,"content":"分析 假设翻转一些列后，行 r 变为全等，那么只有和 r 完全相同或刚好每位都与 r 相反的 r‘，才能也变为全等。 因此，将 r 和 r’ 中较大的作为 key，统计出现最多的次数即可。 ","date":"2019-06-02","objectID":"/leetcode/1072/:2:0","tags":null,"title":"1072：按列翻转得到最大值等行数（★）","uri":"/leetcode/1072/"},{"categories":null,"content":"解答 def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -\u003e int: ct = Counter() for row in matrix: key = tuple(row) if row[0] else tuple(x^1 for x in row) ct[key] += 1 return max(ct.values()) 128 ms ","date":"2019-06-02","objectID":"/leetcode/1072/:3:0","tags":null,"title":"1072：按列翻转得到最大值等行数（★）","uri":"/leetcode/1072/"},{"categories":null,"content":" 力扣第 138 场周赛第 4 题 ","date":"2019-05-26","objectID":"/leetcode/1054/:0:0","tags":null,"title":"1054：距离相等的条形码（★）","uri":"/leetcode/1054/"},{"categories":null,"content":"题目 在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。 请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。 示例 1： 输入：barcodes = [1,1,1,2,2,2]\r输出：[2,1,2,1,2,1]\r示例 2： 输入：barcodes = [1,1,1,1,2,2,3,3]\r输出：[1,3,1,3,2,1,2,1]\r提示： 1 \u003c= barcodes.length \u003c= 10000\r1 \u003c= barcodes[i] \u003c= 10000\r","date":"2019-05-26","objectID":"/leetcode/1054/:1:0","tags":null,"title":"1054：距离相等的条形码（★）","uri":"/leetcode/1054/"},{"categories":null,"content":"分析 与 0767 非常相似，贪心即可。 ","date":"2019-05-26","objectID":"/leetcode/1054/:2:0","tags":null,"title":"1054：距离相等的条形码（★）","uri":"/leetcode/1054/"},{"categories":null,"content":"解答 def rearrangeBarcodes(self, barcodes: List[int]) -\u003e List[int]: n, ct = len(barcodes), Counter(barcodes) res, cur = [0] * n, 1 for num, freq in ct.items(): if freq == (n+1) // 2 and not res[0]: res[0::2] = [num] * freq else: for _ in range(freq): res[cur] = num cur = cur + 2 if cur + 2 \u003c n else 0 ","date":"2019-05-26","objectID":"/leetcode/1054/:3:0","tags":null,"title":"1054：距离相等的条形码（★）","uri":"/leetcode/1054/"},{"categories":null,"content":" 力扣第 138 场周赛第 2 题 ","date":"2019-05-26","objectID":"/leetcode/1052/:0:0","tags":null,"title":"1052：爱生气的书店老板（★）","uri":"/leetcode/1052/"},{"categories":null,"content":"题目 有一个书店老板，他的书店开了 n 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 n 的整数数组 customers ，其中 customers[i] 是在第 i 分钟开始时进入商店的顾客数量，所有这些顾客在第 i 分钟结束后离开。 在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 minutes 分钟不生气，但却只能使用一次。 请你返回 这一天营业下来，最多有多少客户","date":"2019-05-26","objectID":"/leetcode/1052/:1:0","tags":null,"title":"1052：爱生气的书店老板（★）","uri":"/leetcode/1052/"},{"categories":null,"content":"分析 不使用技巧的话，满意的客户数量是 sum(cus*(1-gru) for cus,gru in zip(customers, grumpy))。 假设在区间 [i, i+X) 使用技巧，那么能增多的数量是 sum(customers[j]*grumpy[j] for j in range(i, i+X))。 因此遍历区间找最大值即可。 ","date":"2019-05-26","objectID":"/leetcode/1052/:2:0","tags":null,"title":"1052：爱生气的书店老板（★）","uri":"/leetcode/1052/"},{"categories":null,"content":"解答 def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -\u003e int: res, tmp = 0, 0 for j, cus in enumerate(customers): tmp += cus*grumpy[j] if j \u003e= X: tmp -= customers[j-X]*grumpy[j-X] res = max(res, tmp) res += sum(cus*(1-gru) for cus,gru in zip(customers, grumpy)) return res 316 ms","date":"2019-05-26","objectID":"/leetcode/1052/:3:0","tags":null,"title":"1052：爱生气的书店老板（★）","uri":"/leetcode/1052/"},{"categories":null,"content":"世界大燃烧——全世界的一半化为了焦土。引发了这未曾有过的事态的是，突然变异而诞生的能够操纵火焰的人种“燃烧者”的出现。\n在那之后过去了30年——有着攻击性的一部分自称“疯狂燃烧者”的燃烧者，再度对世界发动了攻击。\n专门对应燃烧者之特殊火焰的高机动救命消防队——“烈焰救火队”。有着燃烧的消火魂的新人队员·加洛与“疯狂燃烧者”的首领·里欧。\n炽热灵魂的激烈冲撞，两人的战斗的结末是。","date":"2019-05-24","objectID":"/anime/promare/","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":"简介 世界大燃烧——全世界的一半化为了焦土。引发了这未曾有过的事态的是，突然变异而诞生的能够操纵火焰的人种“燃烧者”的出现。 在那之后过去了30年——有着攻击性的一部分自称“疯狂燃烧者”的燃烧者，再度对世界发动了攻击。 专门对应燃烧者之特殊火焰的高机动救命消防队——“烈焰救火队”。有着燃烧的消火魂的新人队员·加洛与“疯狂燃烧者”的首领·里欧。 炽热灵魂的激烈冲撞，两人的战斗的结末是。 制作人员： 原作：中岛一基、TRIGGER 导演：今石洋之 分镜：小仓陈利、石崎寿夫、小松田大全、吉成曜 ","date":"2019-05-24","objectID":"/anime/promare/:1:0","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 加洛·提莫斯 Galo Thymos 男 松山ケンイチ 2 里欧·弗提亚 Lio Fotia 男 早乙女太一 3 艾娜·阿尔德比特 Aina Ardebit 女 佐倉綾音 4 露琪亚·菲克斯 Lucia Fex 女 新谷真弓 5 瓦里斯·特拉斯 Varys Truss 男 稲田徹 6 雷米·普古纳 Remi Puguna 男 吉野裕行 7 伊格尼斯·艾克斯 Ignis Ex 男 小山力也 8 维尼 Vinny ケンドーコバヤシ ","date":"2019-05-24","objectID":"/anime/promare/:2:0","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Promare 2019-05-24 111m bilibili ","date":"2019-05-24","objectID":"/anime/promare/:3:0","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":"MAD ","date":"2019-05-24","objectID":"/anime/promare/:4:0","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":" 力扣第 137 场周赛第 2 题 ","date":"2019-05-19","objectID":"/leetcode/1047/:0:0","tags":null,"title":"1047：删除字符串中的所有相邻重复项","uri":"/leetcode/1047/"},{"categories":null,"content":"题目 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 输入：\"abbaca\"\r输出：\"ca\"\r解释：\r例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。\r提示： 1 \u003c= S.length \u003c= 20000\rS 仅由小写英文字母组成。\r","date":"2019-05-19","objectID":"/leetcode/1047/:1:0","tags":null,"title":"1047：删除字符串中的所有相邻重复项","uri":"/leetcode/1047/"},{"categories":null,"content":"分析 典型的栈应用。 ","date":"2019-05-19","objectID":"/leetcode/1047/:2:0","tags":null,"title":"1047：删除字符串中的所有相邻重复项","uri":"/leetcode/1047/"},{"categories":null,"content":"解答 def removeDuplicates(self, S: str) -\u003e str: stack = [] for char in S: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack) 92 ms ","date":"2019-05-19","objectID":"/leetcode/1047/:3:0","tags":null,"title":"1047：删除字符串中的所有相邻重复项","uri":"/leetcode/1047/"},{"categories":null,"content":" 力扣第 137 场周赛第 1 题 ","date":"2019-05-19","objectID":"/leetcode/1046/:0:0","tags":null,"title":"1046：最后一块石头的重量","uri":"/leetcode/1046/"},{"categories":null,"content":"题目 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u003c= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎；\r如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。\r最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。 示例： 输入：[2,7,4,1,8,1]\r输出：1\r解释：\r先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，\r再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1","date":"2019-05-19","objectID":"/leetcode/1046/:1:0","tags":null,"title":"1046：最后一块石头的重量","uri":"/leetcode/1046/"},{"categories":null,"content":"分析 典型的堆问题，删除两个最大值，插入差值。python 默认的是小顶堆，要实现大顶堆，就将元素取负再插入即可。 因为 python 的 list 插入非常快，因此也可以直接排序，然后二分查找插入差值。 ","date":"2019-05-19","objectID":"/leetcode/1046/:2:0","tags":null,"title":"1046：最后一块石头的重量","uri":"/leetcode/1046/"},{"categories":null,"content":"解答 def lastStoneWeight(self, stones: List[int]) -\u003e int: stones = [-stone for stone in stones] heapify(stones) while len(stones) \u003e 1: y, x = heappop(stones), heappop(stones) heappush(stones, y-x) return -stones[0] 40 ms ","date":"2019-05-19","objectID":"/leetcode/1046/:3:0","tags":null,"title":"1046：最后一块石头的重量","uri":"/leetcode/1046/"},{"categories":null,"content":" 力扣第 136 场周赛第 4 题 ","date":"2019-05-12","objectID":"/leetcode/1044/:0:0","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"题目 给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。 返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 \"\" 。 示例 1： 输入：s = \"banana\" 输出：\"ana\" 示例 2： 输入：s = \"abcd\" 输出：\"\" 提示： 2 \u003c= s.length \u003c= 3 * 104 s 由小写英文字母组成 ","date":"2019-05-12","objectID":"/leetcode/1044/:1:0","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"分析 类似 0718，可以用二分查找+滚动哈希解决。 元素种数最多 26，用到的窗口种数最多 5*10^5 级别，因此考虑 base 取 29，mod 取 10^11+3 ","date":"2019-05-12","objectID":"/leetcode/1044/:2:0","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"解答 def longestDupSubstring(self, s: str) -\u003e str: def check(L): vis, w, bL = set(), 0, pow(base, L, mod) for j, char in enumerate(s): w = w*base+ord(char)-ord('a') if j\u003e=L: w -= (ord(s[j-L])-ord('a'))*bL w %= mod if j\u003e=L-1: if w in vis: return False, s[j-L+1:j+1] vis.add(w) return True, '' base, mod ","date":"2019-05-12","objectID":"/leetcode/1044/:3:0","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"*附加 滚动哈希只要存在 mod，就有针对性的数据使其出错。而后缀数组算法则能保证一定正确。所以本题可以用来练习 后缀数组 算法。 ","date":"2019-05-12","objectID":"/leetcode/1044/:4:0","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"#1 后缀数组有几种实现方法，最好理解的是 倍增法。 直接用 sort，时间复杂度 $O(N * log^2N)$，用基数排序，时间复杂度 $O(N * logN)$。 求得后缀数组后，可以在 O(N) 时间得到 height 数组，即可求解。 def longestDupSubstring(self, s: str) -\u003e str: def SA(A): n, size = len(A), 1 rk, sa = [0] * n, sorted((A[i], i) for i in range(n)) while True: prev, cnt = None, 0 for x, i in sa","date":"2019-05-12","objectID":"/leetcode/1044/:4:1","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"#2 最快的实现则是 诱导排序 方法，但理解难度较大， 最好结合讲解，实际运行每一步，观察每一步的输入输出。 这里给出一种模板（尽量精简了。。。） def longestDupSubstring(self, s: str) -\u003e str: def SA_IS(A): def equal(pos1, pos2): end1, end2 = LMS.find('*', pos1+1), LMS.find('*', pos2+1) return A[pos1:end1+1] == A[pos2:end2+1] def IS(stars): sa = [n] + [-1] * n tails = li","date":"2019-05-12","objectID":"/leetcode/1044/:4:2","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":" 力扣第 136 场周赛第 1 题 ","date":"2019-05-12","objectID":"/leetcode/1041/:0:0","tags":null,"title":"1041：困于环中的机器人（★）","uri":"/leetcode/1041/"},{"categories":null,"content":"题目 在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。注意: 北方向 是y轴的正方向。 南方向 是y轴的负方向。 东方向 是x轴的正方向。 西方向 是x轴的负方向。 机器人可以接受下列三条指令之一： \"G\"：直走 1 个单位 \"L\"：左转 90 度 \"R\"：右转 90 度 机器人按顺序执行指令 instructions，并一直重复它们。 只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。 示例 1： 输入：instructions = \"GGLLGG\" 输出：true 解释：机器人最初在(0,0)处，面向北方。 “G”:移动一步。位置:(0,1)方","date":"2019-05-12","objectID":"/leetcode/1041/:1:0","tags":null,"title":"1041：困于环中的机器人（★）","uri":"/leetcode/1041/"},{"categories":null,"content":"分析 先模拟走完一轮： 假如回到原点，显然进入循环 假如走到另外一个点 \u003ci,j\u003e，方向依然向北，显然没有循环 假如方向不再向北，那么走四轮就会回到原点（比如下图） ","date":"2019-05-12","objectID":"/leetcode/1041/:2:0","tags":null,"title":"1041：困于环中的机器人（★）","uri":"/leetcode/1041/"},{"categories":null,"content":"解答 def isRobotBounded(self, instructions: str) -\u003e bool: x, y, dx, dy = 0, 0, -1, 0 for c in instructions: if c=='G': x, y = x+dx, y+dy else: dx, dy = (dy, -dx) if c=='R' else (-dy, dx) return x==y==0 or (dx,dy)!=(-1, 0) 36 ms ","date":"2019-05-12","objectID":"/leetcode/1041/:3:0","tags":null,"title":"1041：困于环中的机器人（★）","uri":"/leetcode/1041/"},{"categories":null,"content":" 力扣第 135 场周赛第 2 题 ","date":"2019-05-05","objectID":"/leetcode/1038/:0:0","tags":null,"title":"1038：从二叉搜索树到更大和树","uri":"/leetcode/1038/"},{"categories":null,"content":"题目 给定一个二叉搜索树 root (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。 提醒一下， 二叉搜索树 满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 示例 1： 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2： 输入：root = [0,null,1] 输出：[1,null,1]","date":"2019-05-05","objectID":"/leetcode/1038/:1:0","tags":null,"title":"1038：从二叉搜索树到更大和树","uri":"/leetcode/1038/"},{"categories":null,"content":"分析 和 0538 相同。 ","date":"2019-05-05","objectID":"/leetcode/1038/:2:0","tags":null,"title":"1038：从二叉搜索树到更大和树","uri":"/leetcode/1038/"},{"categories":null,"content":"解答 def bstToGst(self, root: TreeNode) -\u003e TreeNode: stack, pre = [(root, 0)], 0 while stack: node, flag = stack.pop() if flag: node.val += pre pre = node.val elif node: stack.extend([(node.left, 0), (node, 1), (node.right, 0)]) return root 48 ms ","date":"2019-05-05","objectID":"/leetcode/1038/:3:0","tags":null,"title":"1038：从二叉搜索树到更大和树","uri":"/leetcode/1038/"},{"categories":null,"content":" 力扣第 133 场周赛第 2 题 ","date":"2019-04-21","objectID":"/leetcode/1030/:0:0","tags":null,"title":"1030：距离顺序排列矩阵单元格（★）","uri":"/leetcode/1030/"},{"categories":null,"content":"题目 给定四个整数 rows , cols , rCenter 和 cCenter 。有一个 rows x cols 的矩阵，你在单元格上的坐标是 (rCenter, cCenter) 。 返回矩阵中的所有单元格的坐标，并按与 (rCenter, cCenter) 的 距离 从最小到最大的顺序排。你可以按 任何 满足此条件的顺序返回答案。 单元格(r1, c1) 和 (r2, c2) 之间的距离为|r1 - r2| + |c1 - c2|。 示例 1： 输入：rows = 1, cols = 2, rCenter = 0, cCenter = 0 输出：[[0,0],[0,1]] 解释：从 (","date":"2019-04-21","objectID":"/leetcode/1030/:1:0","tags":null,"title":"1030：距离顺序排列矩阵单元格（★）","uri":"/leetcode/1030/"},{"categories":null,"content":"分析 ","date":"2019-04-21","objectID":"/leetcode/1030/:2:0","tags":null,"title":"1030：距离顺序排列矩阵单元格（★）","uri":"/leetcode/1030/"},{"categories":null,"content":"#1 直接将所有坐标按距离排序即可。 def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -\u003e List[List[int]]: return sorted(product(range(rows), range(cols)), key=lambda p: abs(p[0]-rCenter)+abs(p[1]-cCenter)) 60 ms ","date":"2019-04-21","objectID":"/leetcode/1030/:2:1","tags":null,"title":"1030：距离顺序排列矩阵单元格（★）","uri":"/leetcode/1030/"},{"categories":null,"content":"#2 距离的范围较小，可以用桶排序。 ","date":"2019-04-21","objectID":"/leetcode/1030/:2:2","tags":null,"title":"1030：距离顺序排列矩阵单元格（★）","uri":"/leetcode/1030/"},{"categories":null,"content":"解答 def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -\u003e List[List[int]]: bucket = defaultdict(list) for x, y in product(range(rows), range(cols)): bucket[abs(x-rCenter)+abs(y-cCenter)].append([x, y]) res = [] for dis in range(201): res.extend(bucket[dis]) return res 52 ms","date":"2019-04-21","objectID":"/leetcode/1030/:3:0","tags":null,"title":"1030：距离顺序排列矩阵单元格（★）","uri":"/leetcode/1030/"},{"categories":null,"content":" 力扣第 132 场周赛第 4 题 ","date":"2019-04-14","objectID":"/leetcode/1028/:0:0","tags":null,"title":"1028：从先序遍历还原二叉树（★）","uri":"/leetcode/1028/"},{"categories":null,"content":"题目 我们从二叉树的根节点 root 开始进行深度优先搜索。 在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。 如果节点只有一个子节点，那么保证该子节点为左子节点。 给出遍历输出 S，还原树并返回其根节点 root。 示例 1： 输入：\"1-2--3--4-5--6--7\" 输出：[1,2,5,3,4,6,7] 示例 2： 输入：\"1-2--3---4-5--6---7\" 输出：[1,2,5,3,null,6,null,4,null,7] 示例 3： 输入：\"1-40","date":"2019-04-14","objectID":"/leetcode/1028/:1:0","tags":null,"title":"1028：从先序遍历还原二叉树（★）","uri":"/leetcode/1028/"},{"categories":null,"content":"分析 先正则提取出每个节点的值和深度，然后模拟： 遍历时，假如当前节点刚好比上个节点的深度大 1 显然当前节点即为上个节点的子节点，应该接到上个节点的下面 如果上个节点还没有左子树，就接到左边，否则接到右边 否则，去掉上个节点直到找到深度比当前节点深度大 1 的节点，转为上一步 这个过程显然可以用栈。 ","date":"2019-04-14","objectID":"/leetcode/1028/:2:0","tags":null,"title":"1028：从先序遍历还原二叉树（★）","uri":"/leetcode/1028/"},{"categories":null,"content":"解答 def recoverFromPreorder(self, traversal: str) -\u003e Optional[TreeNode]: stack = [] for w,x in re.findall('(\\-*)(\\d+)', traversal): w,x = len(w),TreeNode(int(x)) while stack and stack[-1][1]!=w-1: stack.pop() if stack: y = stack[-1][0] if not y.left: y.left = x else: y.right = x stack.append((x,w)) r","date":"2019-04-14","objectID":"/leetcode/1028/:3:0","tags":null,"title":"1028：从先序遍历还原二叉树（★）","uri":"/leetcode/1028/"},{"categories":null,"content":" 力扣第 132 场周赛第 1 题 ","date":"2019-04-14","objectID":"/leetcode/1025/:0:0","tags":null,"title":"1025：除数博弈（★）","uri":"/leetcode/1025/"},{"categories":null,"content":"题目 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 n 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 \u003c x \u003c n 且 n % x == 0 。 用 n - x 替换黑板上的数字 n 。 如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 true 。假设两个玩家都以最佳状态参与游戏。 示例 1： 输入：n = 2 输出：true 解释：爱丽丝选择 1，鲍勃无法进行操作。 示例 2： 输入：n = 3 输出：false 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 提示： 1 \u003c= n \u003c=","date":"2019-04-14","objectID":"/leetcode/1025/:1:0","tags":null,"title":"1025：除数博弈（★）","uri":"/leetcode/1025/"},{"categories":null,"content":"分析 ","date":"2019-04-14","objectID":"/leetcode/1025/:2:0","tags":null,"title":"1025：除数博弈（★）","uri":"/leetcode/1025/"},{"categories":null,"content":"#1 先考虑递归。任选 N 的一个小于 N 的因数 i，转为递归子问题用 N-i 玩游戏。 @lru_cache(None) def divisorGame(self, N: int) -\u003e bool: if N \u003c 2: return False return any(N % i==0 and not self.divisorGame(N-i) for i in range(1, N//2+1)) 64 ms ","date":"2019-04-14","objectID":"/leetcode/1025/:2:1","tags":null,"title":"1025：除数博弈（★）","uri":"/leetcode/1025/"},{"categories":null,"content":"#2 还有个巧妙的想法。若 N 是偶数，则爱丽丝取 1，那么不管鲍勃怎么选，留给爱丽丝的仍然是偶数。 这样到最后必然是鲍勃面对 1，爱丽丝获胜。 若 N 是奇数，同理鲍勃每次取 1 就必胜。因此答案只跟 N 的奇偶性相关。 ","date":"2019-04-14","objectID":"/leetcode/1025/:2:2","tags":null,"title":"1025：除数博弈（★）","uri":"/leetcode/1025/"},{"categories":null,"content":"解答 def divisorGame(self, N: int) -\u003e bool: return N % 2 == 0 32 ms ","date":"2019-04-14","objectID":"/leetcode/1025/:3:0","tags":null,"title":"1025：除数博弈（★）","uri":"/leetcode/1025/"},{"categories":null,"content":"「《异世界四重奏》由STUDIO PUYUKAI负责制作，是将《OVERLORD》、《为美好的世界献上祝福！》、《Re：从零开始的异世界生活》、《幼女战记》四部异世界轻小说的角色Q版化的电视动画作品。\n\n此次的企划是由曾经手其中三部作品迷你动画的STUDIO PUYUKAI所推动，而监督当然也是负责这几部迷你动画的芦名实。虽然只是2头身的阳春画面，但监督和编剧的确相当了解迷你动画的重点，演出节奏相当紧凑，几乎每隔5秒就有一个笑点出现。\n\n而比起制作部分，此次配音的部分可以说是一场大乱斗。除了完整集合了四部作品动画总共20多位的主力配音演员外，甚至有高桥李依这种一人分饰两作主要角色的状况出现，阵容可说是相当豪华。\n\n总结而言，该作其实可以说是角川版异世界的《幻想嘉年华》。短短十多分钟内塞满了各式的高强度搞笑和槽点，再加上满满的原作捏他，作为粉丝向作品可说是再完美不过了。","date":"2019-04-09","objectID":"/anime/isekai_quartet/","tags":null,"title":"异世界四重奏","uri":"/anime/isekai_quartet/"},{"categories":null,"content":"简介 「《异世界四重奏》由STUDIO PUYUKAI负责制作，是将《OVERLORD》、《为美好的世界献上祝福！》、《Re：从零开始的异世界生活》、《幼女战记》四部异世界轻小说的角色Q版化的电视动画作品。 此次的企划是由曾经手其中三部作品迷你动画的STUDIO PUYUKAI所推动，而监督当然也是负责这几部迷你动画的芦名实。虽然只是2头身的阳春画面，但监督和编剧的确相当了解迷你动画的重点，演出节奏相当紧凑，几乎每隔5秒就有一个笑点出现。 而比起制作部分，此次配音的部分可以说是一场大乱斗。除了完整集合了四部作品动画总共20多位的主力配音演员外，甚至有高桥李依这种一人分饰两作主要角色的状况出现，","date":"2019-04-09","objectID":"/anime/isekai_quartet/:1:0","tags":null,"title":"异世界四重奏","uri":"/anime/isekai_quartet/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安兹·乌尔·恭 铃木悟、莫莫伽、飞鼠、ainz ooal gown、モモンガ、拥有骷髅外表的最强魔法吟唱者 男 日野聡 2 雅儿贝德 albedo、温柔体贴的纯白恶魔 女 原由実 3 佐藤和真 佐藤 和真、サトウ カズマ、Satou Kazuma 男 福島潤 4 阿克娅 阿库娅、Aqua、アクア、Akua、茶包 女 雨宮天 5 菜月昴 なつき・すばる、Natsuki Subaru 男 小林裕介 6 艾米莉娅 爱蜜莉雅、Emilia、EMT 女 高橋李依 7 谭雅·提古雷查夫 Tanya Degurechaff 女 悠木碧 8 维夏 维多利亚·伊娃诺娃·谢列布","date":"2019-04-09","objectID":"/anime/isekai_quartet/:2:0","tags":null,"title":"异世界四重奏","uri":"/anime/isekai_quartet/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 异世界四重奏 2019-04-09 12 樱花 2 异世界四重奏2 2020-01-14 12 樱花 3 剧场版 异世界四重奏 ～Another World～ 2022-06-10 1 bilibili ","date":"2019-04-09","objectID":"/anime/isekai_quartet/:3:0","tags":null,"title":"异世界四重奏","uri":"/anime/isekai_quartet/"},{"categories":null,"content":" 力扣第 131 场周赛第 3 题 ","date":"2019-04-07","objectID":"/leetcode/1023/:0:0","tags":null,"title":"1023：驼峰式匹配（★）","uri":"/leetcode/1023/"},{"categories":null,"content":"题目 如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。（我们可以在任何位置插入每个字符，也可以插入 0 个字符。） 给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。 示例 1： 输入：queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FB","date":"2019-04-07","objectID":"/leetcode/1023/:1:0","tags":null,"title":"1023：驼峰式匹配（★）","uri":"/leetcode/1023/"},{"categories":null,"content":"分析 ","date":"2019-04-07","objectID":"/leetcode/1023/:2:0","tags":null,"title":"1023：驼峰式匹配（★）","uri":"/leetcode/1023/"},{"categories":null,"content":"#1 当 pattern 是 query 的子序列且包含了 query 的所有大写字母时，即匹配。 可以直接用正则。 def camelMatch(self, queries: List[str], pattern: str) -\u003e List[bool]: reg = '[a-z]*?'.join(['']+list(pattern)+[''])+'$' return [bool(re.match(reg, q)) for q in queries] 44 ms ","date":"2019-04-07","objectID":"/leetcode/1023/:2:1","tags":null,"title":"1023：驼峰式匹配（★）","uri":"/leetcode/1023/"},{"categories":null,"content":"#2 也可以遍历判断。 ","date":"2019-04-07","objectID":"/leetcode/1023/:2:2","tags":null,"title":"1023：驼峰式匹配（★）","uri":"/leetcode/1023/"},{"categories":null,"content":"解答 def camelMatch(self, queries: List[str], pattern: str) -\u003e List[bool]: def check(q): i = 0 for char in q: if i\u003cn and char == pattern[i]: i += 1 elif char.isupper(): return False return i==n n = len(pattern) return [check(q) for q in queries] 36 ms ","date":"2019-04-07","objectID":"/leetcode/1023/:3:0","tags":null,"title":"1023：驼峰式匹配（★）","uri":"/leetcode/1023/"},{"categories":null,"content":" 力扣第 131 场周赛第 1 题 ","date":"2019-04-07","objectID":"/leetcode/1021/:0:0","tags":null,"title":"1021：删除最外层的括号","uri":"/leetcode/1021/"},{"categories":null,"content":"题目 有效括号字符串为空 \"\"、\"(\" + A + \")\" 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。 例如，\"\"，\"()\"，\"(())()\" 和 \"(()(()))\" 都是有效的括号字符串。\r如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。 对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返","date":"2019-04-07","objectID":"/leetcode/1021/:1:0","tags":null,"title":"1021：删除最外层的括号","uri":"/leetcode/1021/"},{"categories":null,"content":"分析 ","date":"2019-04-07","objectID":"/leetcode/1021/:2:0","tags":null,"title":"1021：删除最外层的括号","uri":"/leetcode/1021/"},{"categories":null,"content":"#1 用栈判断有效括号时，显然栈空时添加的 ‘(’ 和对应的 ‘)’ 即是原语的最外层括号，不添加到结果即可。 def removeOuterParentheses(self, s: str) -\u003e str: res, stack = '', [] for char in s: if char == '(': if stack: res += char stack.append(char) else: stack.pop() if stack: res += char return res 36 ms ","date":"2019-04-07","objectID":"/leetcode/1021/:2:1","tags":null,"title":"1021：删除最外层的括号","uri":"/leetcode/1021/"},{"categories":null,"content":"#2 注意到判断时，其实只关心栈的长度。所以可以用一个变量来维护，而无需真正地进行栈操作。 ","date":"2019-04-07","objectID":"/leetcode/1021/:2:2","tags":null,"title":"1021：删除最外层的括号","uri":"/leetcode/1021/"},{"categories":null,"content":"解答 def removeOuterParentheses(self, s: str) -\u003e str: res, size = '', 0 for char in s: res += char if size \u003e 1 or (size == 1 and char == '(') else '' size += 1 if char == '(' else -1 return res 56 ms ","date":"2019-04-07","objectID":"/leetcode/1021/:3:0","tags":null,"title":"1021：删除最外层的括号","uri":"/leetcode/1021/"},{"categories":null,"content":"大正时期、日本。\n卖炭的心地善良的少年·炭治郎，有一天被鬼杀死了家人。\n而唯一幸存下来的妹妹祢豆子变成了鬼。\n被绝望的现实打垮的炭治郎，为了让妹妹变回人类并讨伐杀害家人的鬼，决心沿着“鬼杀队”的道路前进。\n人与鬼交织的悲哀的兄妹的故事，现在开始！","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":"简介 大正时期、日本。 卖炭的心地善良的少年·炭治郎，有一天被鬼杀死了家人。 而唯一幸存下来的妹妹祢豆子变成了鬼。 被绝望的现实打垮的炭治郎，为了让妹妹变回人类并讨伐杀害家人的鬼，决心沿着“鬼杀队”的道路前进。 人与鬼交织的悲哀的兄妹的故事，现在开始！ 制作人员： 原作：吾峠呼世晴 导演：外崎春雄 脚本：ufotable 分镜：南野纯一、野中卓也、寺尾优一、栖原隆史、竹内将 ","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/:1:0","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 灶门炭治郎 竈門 炭治郎、かまど たんじろう、Kamado Tanjirou 男 佐藤聡美 2 灶门祢豆子 竈門 禰豆子、かまど ねずこ、Kamado Nezuko 女 鬼頭明里 3 我妻善逸 我妻 善逸、あがつま ぜんいつ、Agatsuma Zenitsu、懶覺丸 男 下野紘 4 嘴平伊之助 嘴平 伊之助、はしびら いのすけ、Hashibira Inosuke 男 松岡禎丞 5 富冈义勇 冨岡 義勇、とみおか ぎゆう、Tomioka Giyuu 男 櫻井孝宏 6 蝴蝶忍 胡蝶 しのぶ、こちょう しのぶ、Kochou Shinobu 女 早見沙織 7 炼狱杏","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/:2:0","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 鬼灭之刃 2019-04-06 26 bilibili 2 剧场版 鬼灭之刃 无限列车篇 2020-10-16 1 樱花 3 鬼灭之刃 无限列车篇 2021-10-10 7 bilibili 4 鬼灭之刃 游郭篇 2021-12-05 11 bilibili ","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/:3:0","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":"MAD ","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/:4:0","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":" 力扣第 130 场周赛第 3 题 ","date":"2019-03-31","objectID":"/leetcode/1019/:0:0","tags":null,"title":"1019：链表中的下一个更大节点（★）","uri":"/leetcode/1019/"},{"categories":null,"content":"题目 给定一个长度为 n 的链表 head 对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。 返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。 示例 1： 输入：head = [2,1,5]\r输出：[5,5,0]\r示例 2： 输入：head = [2,7,4,3,5]\r输出：[7,0,5,5,0]\r提示： 链表中节点数为 n\r1 \u003c= n \u003c= 104\r1 \u003c= No","date":"2019-03-31","objectID":"/leetcode/1019/:1:0","tags":null,"title":"1019：链表中的下一个更大节点（★）","uri":"/leetcode/1019/"},{"categories":null,"content":"分析 类似 0739 ，可以用单调栈解决。事先不知道链表长度，因此边遍历边维护结果数组即可。 ","date":"2019-03-31","objectID":"/leetcode/1019/:2:0","tags":null,"title":"1019：链表中的下一个更大节点（★）","uri":"/leetcode/1019/"},{"categories":null,"content":"解答 def nextLargerNodes(self, head: ListNode) -\u003e List[int]: res, stack, i = [], [], 0 while head: while stack and stack[-1][1] \u003c head.val: res[stack.pop()[0]] = head.val stack.append((i, head.val)) res.append(0) head = head.next i += 1 return res 324 ms ","date":"2019-03-31","objectID":"/leetcode/1019/:3:0","tags":null,"title":"1019：链表中的下一个更大节点（★）","uri":"/leetcode/1019/"},{"categories":null,"content":" 力扣第 130 场周赛第 2 题 ","date":"2019-03-31","objectID":"/leetcode/1017/:0:0","tags":null,"title":"1017：负二进制转换（★）","uri":"/leetcode/1017/"},{"categories":null,"content":"题目 给你一个整数 n ，以二进制字符串的形式返回该整数的 负二进制（base -2）表示。 注意，除非字符串就是 \"0\"，否则返回的字符串中不能含有前导零。 示例 1： 输入：n = 2 输出：\"110\" 解释：(-2)2 + (-2)1 = 2 示例 2： 输入：n = 3 输出：\"111\" 解释：(-2)2 + (-2)1 + (-2)0 = 3 示例 3： 输入：n = 4 输出：\"100\" 解释：(-2)2 = 4 提示： 0 \u003c= n \u003c= 109 ","date":"2019-03-31","objectID":"/leetcode/1017/:1:0","tags":null,"title":"1017：负二进制转换（★）","uri":"/leetcode/1017/"},{"categories":null,"content":"分析 类似二进制转换，每步将商取负即可。 ","date":"2019-03-31","objectID":"/leetcode/1017/:2:0","tags":null,"title":"1017：负二进制转换（★）","uri":"/leetcode/1017/"},{"categories":null,"content":"解答 def baseNeg2(self, n: int) -\u003e str: res = '' while n: n, r = -(n//2), n%2 res = str(r)+res return res or '0' 40 ms ","date":"2019-03-31","objectID":"/leetcode/1017/:3:0","tags":null,"title":"1017：负二进制转换（★）","uri":"/leetcode/1017/"},{"categories":null,"content":" 力扣第 128 场周赛第 4 题 ","date":"2019-03-17","objectID":"/leetcode/1012/:0:0","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"题目 给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。 示例 1： 输入：n = 20\r输出：1\r解释：具有至少 1 位重复数字的正数（\u003c= 20）只有 11 。\r示例 2： 输入：n = 100\r输出：10\r解释：具有至少 1 位重复数字的正数（\u003c= 100）有 11，22，33，44，55，66，77，88，99 和 100 。\r示例 3： 输入：n = 1000\r输出：262\r提示： 1 \u003c= n \u003c= 109\r","date":"2019-03-17","objectID":"/leetcode/1012/:1:0","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"分析 ","date":"2019-03-17","objectID":"/leetcode/1012/:2:0","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"#1 可以先求 [0, n] 范围内数字不重复的个数，再用 n+1 减去即可。 求范围内数字满足某种性质的个数，容易想到用数位 dp，令 dfs(pos, state, bound) 代表某个状态下的结果： 遍历到 n 的第 pos 位 前面取的数的集合状态是 state bound 代表前面取的数是否贴着 n 的上界 即可递归。 特别注意前置 0 不应该加入到 state 中。 def numDupDigitsAtMostN(self, n: int) -\u003e int: @lru_cache(None) def dfs(pos, state, bound): if pos==len(s): r","date":"2019-03-17","objectID":"/leetcode/1012/:2:1","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"#2 也可以利用排列组合知识直接分段计算。例如对于 n=8382： [0, 1000) 的数字不重复的个数：9*(perm(9,0)+perm(9,1)+perm(9,2)) [1000, 8000) 的对应个数：7*perm(9,3) [8000, 8300) 的对应个数：3*perm(8,2) [8300, 8380) 的对应个数：7*perm(7,1) [8380, 8382) 的对应个数：0 具体实现时，假设 s=str(n) 的长度为 m： 先计算 0-10^(m-1) 的对应个数 然后遍历 i，在 s[:i] 不变的情况下，求 s[i] 能取的值，即在 [0, 原 s[i]) 区间","date":"2019-03-17","objectID":"/leetcode/1012/:2:2","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"解答 def numDupDigitsAtMostN(self, n: int) -\u003e int: s = str(n) m = len(s) res = 9*sum(perm(9, k) for k in range(m-1)) vis = set() for i in range(m): cur = int(s[i]) cand = set(range(int(i==0), cur+int(i==m-1)))-vis res += len(cand)*perm(9-i, m-i-1) if cur in vis: break vis.add(cur) return n-res 36 ms ","date":"2019-03-17","objectID":"/leetcode/1012/:3:0","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"这个 NSFW 动画系列剧中充满了可怕的生物、令人惊讶的情节以及黑色幽默，由蒂姆·米勒和大卫·芬奇打造。","date":"2019-03-15","objectID":"/anime/love_death_and_robots/","tags":null,"title":"爱、死亡 \u0026 机器人","uri":"/anime/love_death_and_robots/"},{"categories":null,"content":"简介 这个 NSFW 动画系列剧中充满了可怕的生物、令人惊讶的情节以及黑色幽默，由蒂姆·米勒和大卫·芬奇打造。 制作人员： 分镜：Robert Valley 製作：网飞 执行制片人：大卫·芬奇 ","date":"2019-03-15","objectID":"/anime/love_death_and_robots/:1:0","tags":null,"title":"爱、死亡 \u0026 机器人","uri":"/anime/love_death_and_robots/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 爱、死亡 \u0026 机器人 2019-03-15 18 樱花 2 爱、死亡 \u0026 机器人 第二季 2021-05-14 8 樱花 3 爱、死亡 \u0026 机器人 第三季 2022-05-20 9 樱花 ","date":"2019-03-15","objectID":"/anime/love_death_and_robots/:2:0","tags":null,"title":"爱、死亡 \u0026 机器人","uri":"/anime/love_death_and_robots/"},{"categories":null,"content":" 力扣第 127 场周赛第 2 题 ","date":"2019-03-10","objectID":"/leetcode/1006/:0:0","tags":null,"title":"1006：笨阶乘（★）","uri":"/leetcode/1006/"},{"categories":null,"content":"题目 通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。 相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。 例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。 另外，","date":"2019-03-10","objectID":"/leetcode/1006/:1:0","tags":null,"title":"1006：笨阶乘（★）","uri":"/leetcode/1006/"},{"categories":null,"content":"分析 ","date":"2019-03-10","objectID":"/leetcode/1006/:2:0","tags":null,"title":"1006：笨阶乘（★）","uri":"/leetcode/1006/"},{"categories":null,"content":"#1 先考虑递归： clumsy(N-4) = (N-4) * (N-5) // (N-6) + (N-7) - (N-8) * (N-9) // (N-10) + ...\rclumsy(N) = N * (N-1) // (N-2) + (N-3) - (N-4) * (N-5) // (N-6) + (N-7) - (N-8) * (N-9) // (N-10) + ...\r= clumsy(N-4) + N * (N-1) // (N-2) + (N-3) - (N-4) * (N-5) // (N-6) * 2\r当 N \u003e= 7 时递推式成立，因此再考虑 N \u003c= 6 的情况即可。 d","date":"2019-03-10","objectID":"/leetcode/1006/:2:1","tags":null,"title":"1006：笨阶乘（★）","uri":"/leetcode/1006/"},{"categories":null,"content":"#2 还有个巧妙的想法，N * (N-1) // (N-2) 能直接算出来。 N * (N - 1) // (N - 2) = (N * N - N ) // (N - 2)\r= ((N - 2) * (N + 1) + 2) // (N - 2)\r= N + 1 + 2 // (N - 2)\r故 N \u003e= 5 时， N * (N-1) // (N-2) = N + 1。\r因此： 对于 N \u003e= 9: clumsy(N) = clumsy(N-4) + (N+1) + (N-3) - (N-3) * 2 = clumsy(N-4) + 4\r对于 N = 5、9、13、... clumsy(N)","date":"2019-03-10","objectID":"/leetcode/1006/:2:2","tags":null,"title":"1006：笨阶乘（★）","uri":"/leetcode/1006/"},{"categories":null,"content":"解答 def clumsy(self, N: int) -\u003e int: return [1, 2, 6, 7][N-1] if N \u003c= 4 else N + [1, 2, 2, -1][N % 4] 36 ms ","date":"2019-03-10","objectID":"/leetcode/1006/:3:0","tags":null,"title":"1006：笨阶乘（★）","uri":"/leetcode/1006/"},{"categories":null,"content":" 力扣第 126 场周赛第 3 题 ","date":"2019-03-03","objectID":"/leetcode/1004/:0:0","tags":null,"title":"1004：最大连续1的个数 III（★）","uri":"/leetcode/1004/"},{"categories":null,"content":"题目 给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。 示例 1： 输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2\r输出：6\r解释：[1,1,1,0,0,1,1,1,1,1,1]\r粗体数字从 0 翻转到 1，最长的子数组长度为 6。\r示例 2： 输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\r输出：10\r解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\r粗体数字从 0 翻转到 1，最长的子数组","date":"2019-03-03","objectID":"/leetcode/1004/:1:0","tags":null,"title":"1004：最大连续1的个数 III（★）","uri":"/leetcode/1004/"},{"categories":null,"content":"分析 和 0424 类似，还要更简单一些。 ","date":"2019-03-03","objectID":"/leetcode/1004/:2:0","tags":null,"title":"1004：最大连续1的个数 III（★）","uri":"/leetcode/1004/"},{"categories":null,"content":"解答 def longestOnes(self, A: List[int], K: int) -\u003e int: i = 0 for j, num in enumerate(A): if num==0: K -= 1 if K \u003c 0: if A[i] == 0: K += 1 i += 1 return j-i+1 588 ms ","date":"2019-03-03","objectID":"/leetcode/1004/:3:0","tags":null,"title":"1004：最大连续1的个数 III（★）","uri":"/leetcode/1004/"},{"categories":null,"content":" 力扣第 125 场周赛第 1 题 ","date":"2019-02-24","objectID":"/leetcode/0997/:0:0","tags":null,"title":"0997：找到小镇的法官","uri":"/leetcode/0997/"},{"categories":null,"content":"题目 小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。 如果小镇法官真的存在，那么： 小镇法官不会信任任何人。\r每个人（除了小镇法官）都信任这位小镇法官。\r只有一个人同时满足属性 1 和属性 2 。\r给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。 如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。 示例 1： 输入：n = 2, trust = [[1,2]]\r输出：2\r示例 2： 输入：n = 3, trust = [[1,3],[2,3]]\r输出：","date":"2019-02-24","objectID":"/leetcode/0997/:1:0","tags":null,"title":"0997：找到小镇的法官","uri":"/leetcode/0997/"},{"categories":null,"content":"分析 显然法官被 N-1 个人信任且自己信任 0 人，所以记录每个人被多少人信任和自己信任多少人即可。 本题也可以看作是一个图问题。将人作为顶点，信任关系作为边，即是求有向图中入度 N-1 且出度 0 的节点。 ","date":"2019-02-24","objectID":"/leetcode/0997/:2:0","tags":null,"title":"0997：找到小镇的法官","uri":"/leetcode/0997/"},{"categories":null,"content":"解答 def findJudge(self, n: int, trust: List[List[int]]) -\u003e int: indeg, outdeg = [0] * (n+1), [0] * (n+1) for u, v in trust: indeg[v] += 1 outdeg[u] += 1 for i in range(1, n+1): if indeg[i] == n-1 and outdeg[i] == 0: return i return -1 120 ms ","date":"2019-02-24","objectID":"/leetcode/0997/:3:0","tags":null,"title":"0997：找到小镇的法官","uri":"/leetcode/0997/"},{"categories":null,"content":" 力扣第 124 场周赛第 2 题 ","date":"2019-02-17","objectID":"/leetcode/0994/:0:0","tags":null,"title":"0994：腐烂的橘子（★）","uri":"/leetcode/0994/"},{"categories":null,"content":"题目 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一： 值 0 代表空单元格；\r值 1 代表新鲜橘子；\r值 2 代表腐烂的橘子。\r每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。 返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。 示例 1： 输入：grid = [[2,1,1],[1,1,0],[0,1,1]]\r输出：4\r示例 2： 输入：grid = [[2,1,1],[0,1,1],[1,0,1]]\r输出：-1\r解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。\r示例 ","date":"2019-02-17","objectID":"/leetcode/0994/:1:0","tags":null,"title":"0994：腐烂的橘子（★）","uri":"/leetcode/0994/"},{"categories":null,"content":"分析 典型的广度优先搜索。模拟过程，每分钟保存腐烂橘子相邻的新鲜橘子，作为下一分钟的腐烂橘子，直到没有相邻的新鲜橘子为止。 最后再判断是否存在新鲜橘子即可。 为了方便，可以把橘子的腐烂时间也保存起来。 ","date":"2019-02-17","objectID":"/leetcode/0994/:2:0","tags":null,"title":"0994：腐烂的橘子（★）","uri":"/leetcode/0994/"},{"categories":null,"content":"解答 def orangesRotting(self, grid: List[List[int]]) -\u003e int: m, n = len(grid), len(grid[0]) queue = deque((i, j, 0) for i in range(m) for j in range(n) if grid[i][j]==2) t = 0 while queue: i, j, t = queue.popleft() for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0\u003c=x\u003cm and 0\u003c=y\u003cn and grid[x][","date":"2019-02-17","objectID":"/leetcode/0994/:3:0","tags":null,"title":"0994：腐烂的橘子（★）","uri":"/leetcode/0994/"},{"categories":null,"content":" 力扣第 123 场周赛第 4 题 ","date":"2019-02-10","objectID":"/leetcode/0992/:0:0","tags":null,"title":"0992：K 个不同整数的子数组（★★★）","uri":"/leetcode/0992/"},{"categories":null,"content":"题目 给定一个正整数数组 nums和一个整数 \u0008k ，返回 num 中 「好子数组」 的数目。 如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。 例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。\r子数组 是数组的 连续 部分。 示例 1： 输入：nums = [1,2,1,2,3], k = 2\r输出：7\r解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\r示例 2： 输入：nums = [1,","date":"2019-02-10","objectID":"/leetcode/0992/:1:0","tags":null,"title":"0992：K 个不同整数的子数组（★★★）","uri":"/leetcode/0992/"},{"categories":null,"content":"分析 ","date":"2019-02-10","objectID":"/leetcode/0992/:2:0","tags":null,"title":"0992：K 个不同整数的子数组（★★★）","uri":"/leetcode/0992/"},{"categories":null,"content":"#1 有个巧妙的想法是找到含最多 K 个不同整数的子数组个数，再找到含最多 K-1 个不同正数的子数组个数，相减即为所求。 对于转化后的问题，可以遍历结尾位置 j，找到满足条件的最小开头位置 i，得到以 j 结尾的子数组个数。 def subarraysWithKDistinct(self, A: List[int], K: int) -\u003e int: def help(A, K): res, ct, i = 0, Counter(), 0 for j, num in enumerate(A): ct[num] += 1 while len(ct) \u003e K: ct[A[i]] -= 1 if c","date":"2019-02-10","objectID":"/leetcode/0992/:2:1","tags":null,"title":"0992：K 个不同整数的子数组（★★★）","uri":"/leetcode/0992/"},{"categories":null,"content":"#2 也可以一次遍历解决。遍历结尾位置 j，找到满足条件的开头位置范围 [l,r)，则以 j 结尾的子数组个数是 r-l 。 假设已知位置 j 对应的开头位置范围是 [l,r)，那么： if l\u003c=i\u003cr: len(set(A[i:j]))==K\relif i==r: len(set(A[i:j]))==K-1\r显然 set(A[r:j]) 比 set(A[l:j]) 少的就是 A[r-1]。 对于结尾位置 j+1，有三种情况： if len(set(A[r:j+1]))==K-1：新加的元素在 set(A[l:j]) 和 set(A[r:j]) 中，不影响 l 和 r\relif A[j]==","date":"2019-02-10","objectID":"/leetcode/0992/:2:2","tags":null,"title":"0992：K 个不同整数的子数组（★★★）","uri":"/leetcode/0992/"},{"categories":null,"content":"解答 def subarraysWithKDistinct(self, A: List[int], K: int) -\u003e int: ct, res, l, r = Counter(), 0, 0, 0 for num in A: ct[num] += 1 if len(ct)==K: if r and num != A[r-1]: l = r while len(ct)==K: ct[A[r]] -= 1 if ct[A[r]]==0: ct.pop(A[r]) r += 1 res += r-l return res 456 ms ","date":"2019-02-10","objectID":"/leetcode/0992/:3:0","tags":null,"title":"0992：K 个不同整数的子数组（★★★）","uri":"/leetcode/0992/"},{"categories":null,"content":" 力扣第 123 场周赛第 2 题 ","date":"2019-02-10","objectID":"/leetcode/0990/:0:0","tags":null,"title":"0990：等式方程的可满足性（★）","uri":"/leetcode/0990/"},{"categories":null,"content":"题目 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：\"a==b\" 或 \"a!=b\"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1： 输入：[\"a==b\",\"b!=a\"]\r输出：false\r解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。\r示例 2： 输入：[\"b==a\",\"a==b\"]\r输出：true\r解","date":"2019-02-10","objectID":"/leetcode/0990/:1:0","tags":null,"title":"0990：等式方程的可满足性（★）","uri":"/leetcode/0990/"},{"categories":null,"content":"分析 典型的并查集应用。先将所有等号两边的变量连通，然后再判断所有不等号两边的变量不连通即可。 ","date":"2019-02-10","objectID":"/leetcode/0990/:2:0","tags":null,"title":"0990：等式方程的可满足性（★）","uri":"/leetcode/0990/"},{"categories":null,"content":"解答 def equationsPossible(self, equations: List[str]) -\u003e bool: def find(i): if p.setdefault(i, i) != i: p[i] = find(p[i]) return p[i] def union(i, j): p[find(i)] = find(j) p = {} for eq in equations: if eq[1:-1] == '==': union(eq[0], eq[-1]) return all(find(eq[0]) != find(eq[-1]) for eq in equations ","date":"2019-02-10","objectID":"/leetcode/0990/:3:0","tags":null,"title":"0990：等式方程的可满足性（★）","uri":"/leetcode/0990/"},{"categories":null,"content":" 力扣第 123 场周赛第 1 题 ","date":"2019-02-10","objectID":"/leetcode/0989/:0:0","tags":null,"title":"0989：数组形式的整数加法","uri":"/leetcode/0989/"},{"categories":null,"content":"题目 整数的 数组形式 num 是按照从左到右的顺序表示其数字的数组。 例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\r给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。 示例 1： 输入：num = [1,2,0,0], k = 34\r输出：[1,2,3,4]\r解释：1200 + 34 = 1234\r示例 2： 输入：num = [2,7,4], k = 181\r输出：[4,5,5]\r解释：274 + 181 = 455\r示例 3： 输入：num = [2,1,5], k = 806\r输出：[1,0,2,1]\r解释：215 ","date":"2019-02-10","objectID":"/leetcode/0989/:1:0","tags":null,"title":"0989：数组形式的整数加法","uri":"/leetcode/0989/"},{"categories":null,"content":"分析 ","date":"2019-02-10","objectID":"/leetcode/0989/:2:0","tags":null,"title":"0989：数组形式的整数加法","uri":"/leetcode/0989/"},{"categories":null,"content":"#1 最简单的就是把 A 变回 X，相加后再把结果变为数组形式 def addToArrayForm(self, A: List[int], K: int) -\u003e List[int]: X = int(''.join(map(str, A))) return list(map(int, str(X+K))) 368 ms ","date":"2019-02-10","objectID":"/leetcode/0989/:2:1","tags":null,"title":"0989：数组形式的整数加法","uri":"/leetcode/0989/"},{"categories":null,"content":"#2 也可以模拟进位加法，和 0415 相似 ","date":"2019-02-10","objectID":"/leetcode/0989/:2:2","tags":null,"title":"0989：数组形式的整数加法","uri":"/leetcode/0989/"},{"categories":null,"content":"解答 def addToArrayForm(self, A: List[int], K: int) -\u003e List[int]: res, carry, i = [], 0, len(A)-1 while i\u003e=0 or K\u003e0 or carry: x = A[i] if i\u003e=0 else 0 y = K%10 s = x+y+carry res.append(s%10) carry = s//10 i -= 1 K //= 10 return res[::-1] 316 ms ","date":"2019-02-10","objectID":"/leetcode/0989/:3:0","tags":null,"title":"0989：数组形式的整数加法","uri":"/leetcode/0989/"},{"categories":null,"content":" 力扣第 120 场周赛第 4 题 ","date":"2019-01-20","objectID":"/leetcode/0980/:0:0","tags":null,"title":"0980：不同路径 III（★★）","uri":"/leetcode/0980/"},{"categories":null,"content":"题目 在二维网格 grid 上，有 4 种类型的方格： 1 表示起始方格。且只有一个起始方格。\r2 表示结束方格，且只有一个结束方格。\r0 表示我们可以走过的空方格。\r-1 表示我们无法跨越的障碍。\r返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。 每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。 示例 1： 输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\r输出：2\r解释：我们有以下两条路径：\r1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),","date":"2019-01-20","objectID":"/leetcode/0980/:1:0","tags":null,"title":"0980：不同路径 III（★★）","uri":"/leetcode/0980/"},{"categories":null,"content":"分析 显然应该用 dfs。先记录下空方格加结束方格的个数 cnt，然后从起始方格开始深度遍历。 遍历时标记走过的方格以免重复，当到达结束方格且经过方格个数为 cnt 时即为所求。 ","date":"2019-01-20","objectID":"/leetcode/0980/:2:0","tags":null,"title":"0980：不同路径 III（★★）","uri":"/leetcode/0980/"},{"categories":null,"content":"解答 def uniquePathsIII(self, grid: List[List[int]]) -\u003e int: def dfs(i, j, cnt): if grid[i][j] == 5 and cnt==0: self.res += 1 for x, y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]: if 0\u003c=x\u003cm and 0\u003c=y\u003cn and grid[x][y] in [0, 2]: grid[x][y] += 3 dfs(x,y,cnt-1) grid[x][y] -= 3 m, n = len(grid), len(grid[0]) i0, ","date":"2019-01-20","objectID":"/leetcode/0980/:3:0","tags":null,"title":"0980：不同路径 III（★★）","uri":"/leetcode/0980/"},{"categories":null,"content":" 力扣第 119 场周赛第 4 题 ","date":"2019-01-13","objectID":"/leetcode/0975/:0:0","tags":null,"title":"0975：奇偶跳（★★）","uri":"/leetcode/0975/"},{"categories":null,"content":"题目 给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。 你可以按以下方式从索引 i 向后跳转到索引 j（其中 i \u003c j）： 在进行奇数跳跃时（如，第 1，3，5... 次跳跃），你将会跳到索引 j，使得 A[i] \u003c= A[j]，A[j] 是可能的最小值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。\r在进行偶数跳跃时（如，第 2，4，6... 次跳跃），你将会跳到索引 j，使得 A[i] \u003e= A[j]，A[j] 是可能的最大值。如果存在多个这样的索引 ","date":"2019-01-13","objectID":"/leetcode/0975/:1:0","tags":null,"title":"0975：奇偶跳（★★）","uri":"/leetcode/0975/"},{"categories":null,"content":"分析 ","date":"2019-01-13","objectID":"/leetcode/0975/:2:0","tags":null,"title":"0975：奇偶跳（★★）","uri":"/leetcode/0975/"},{"categories":null,"content":"#1 显然每个位置的奇数跳和偶数跳都是确定的，考虑先求出来。 奇数跳是先在 i 右边找到最接近的较大值，再从中选最接近的位置。 容易想到，可以维护一个有序列表 tmp，将位置 [i+1, n-1] 按 (值 A[x] 升序、位置 x 升序）排序，然后二分查找第一个大于等于 A[i] 的位置 tmp[pos] 即可。 找到后，将 i 插入到 tmp 的 pos 处即可维护 tmp。 同理，对于偶数跳，维护 tmp 将位置 [i+1, n-1] 按 (值 A[x] 升序、位置 x 降序）排序，然后二分查找最后一个小于等于 A[i] 的位置 tmp[pos]。 将 i 插入到 tmp 的 pos+1","date":"2019-01-13","objectID":"/leetcode/0975/:2:1","tags":null,"title":"0975：奇偶跳（★★）","uri":"/leetcode/0975/"},{"categories":null,"content":"#2 求奇数跳和偶数跳有个巧妙的单调栈解法。 先将位置 [0, n-1] 按 (值 A[x] 升序、位置 x 升序）排序得到 tmp，那么奇数跳就是求每个元素 在 tmp 中的下一个更大元素。 同理，将位置 [0, n-1] 按 (值 A[x] 降序、位置 x 升序）排序得到 tmp，那么偶数跳就是求每个元素 在 tmp 中的下一个更大元素。 找下一个更大元素，即是单调栈的典型应用，类似 0739。 ","date":"2019-01-13","objectID":"/leetcode/0975/:2:2","tags":null,"title":"0975：奇偶跳（★★）","uri":"/leetcode/0975/"},{"categories":null,"content":"解答 def oddEvenJumps(self, arr: List[int]) -\u003e int: def nxt(A): res, stack = [n] * n, [] for i in A: while stack and stack[-1] \u003c i: res[stack.pop()] = i stack.append(i) return res n = len(arr) odd = nxt(sorted(range(n), key=lambda i: arr[i])) even = nxt(sorted(range(n), key=lambda i: -arr[i])) dp = [[","date":"2019-01-13","objectID":"/leetcode/0975/:3:0","tags":null,"title":"0975：奇偶跳（★★）","uri":"/leetcode/0975/"},{"categories":null,"content":" 力扣第 119 场周赛第 3 题 ","date":"2019-01-13","objectID":"/leetcode/0974/:0:0","tags":null,"title":"0974：和可被 K 整除的子数组（★）","uri":"/leetcode/0974/"},{"categories":null,"content":"题目 给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的（连续、非空） 子数组 的数目。 子数组 是数组的 连续 部分。 示例 1： 输入：nums = [4,5,0,-2,-3,1], k = 5\r输出：7\r解释：\r有 7 个子数组满足其元素之和可被 k = 5 整除：\r[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\r示例 2: 输入: nums = [5], k = 9\r输出: 0\r提示: 1 \u003c= nums.length \u003c= 3 * 104\r-104 ","date":"2019-01-13","objectID":"/leetcode/0974/:1:0","tags":null,"title":"0974：和可被 K 整除的子数组（★）","uri":"/leetcode/0974/"},{"categories":null,"content":"分析 类似 0523 和 0560 ，用哈希表保存前缀和的个数即可。 ","date":"2019-01-13","objectID":"/leetcode/0974/:2:0","tags":null,"title":"0974：和可被 K 整除的子数组（★）","uri":"/leetcode/0974/"},{"categories":null,"content":"解答 def subarraysDivByK(self, A: List[int], K: int) -\u003e int: res, s, d = 0, 0, defaultdict(int) for num in A: d[s] += 1 s = (s+num) % K if K else s+num res += d[s] return res 324 ms ","date":"2019-01-13","objectID":"/leetcode/0974/:3:0","tags":null,"title":"0974：和可被 K 整除的子数组（★）","uri":"/leetcode/0974/"},{"categories":null,"content":" 力扣第 119 场周赛第 1 题 ","date":"2019-01-13","objectID":"/leetcode/0973/:0:0","tags":null,"title":"0973：最接近原点的 K 个点","uri":"/leetcode/0973/"},{"categories":null,"content":"题目 给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点 (0,0) 最近的 k 个点。 这里，平面上两点之间的距离是 欧几里德距离（ √(x1 - x2)2 + (y1 - y2)2 ）。 你可以按 任何顺序 返回答案。除了点坐标的顺序之外，答案 确保 是 唯一 的。 示例 1： 输入：points = [[1,3],[-2,2]], k = 1\r输出：[[-2,2]]\r解释： (1, 3) 和原点之间的距离为 sqrt(10)，\r(-2, 2) 和原点之间的距离为 sqrt(8)，\r由于 sqrt(8","date":"2019-01-13","objectID":"/leetcode/0973/:1:0","tags":null,"title":"0973：最接近原点的 K 个点","uri":"/leetcode/0973/"},{"categories":null,"content":"分析 按距离排序或者用 heapq.nsmallest 即可。 ","date":"2019-01-13","objectID":"/leetcode/0973/:2:0","tags":null,"title":"0973：最接近原点的 K 个点","uri":"/leetcode/0973/"},{"categories":null,"content":"解答 def kClosest(self, points: List[List[int]], k: int) -\u003e List[List[int]]: return nsmallest(k, points, key=lambda x: x[0]*x[0]+x[1]*x[1]) 172 ms ","date":"2019-01-13","objectID":"/leetcode/0973/:3:0","tags":null,"title":"0973：最接近原点的 K 个点","uri":"/leetcode/0973/"},{"categories":null,"content":"家庭背景与人品都很棒！！一大群有前途的秀才所聚集的秀知院学园！！在那里的学生会相遇的副会长·四宫辉夜与会长·白银御行原本应该是彼此受到了对方吸引…但想不到都过半年了却仍然什么事情也没发生！！最麻烦的是这两个自尊心超强、无法坦率的家伙，居然开始想着要“设法让对方向自己告白”！？\n直到恋情有下落之前会很欢乐的故事！！新感觉“斗智”爱情喜剧、就此开战！！","date":"2019-01-12","objectID":"/anime/kaguya_love/","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"简介 家庭背景与人品都很棒！！一大群有前途的秀才所聚集的秀知院学园！！在那里的学生会相遇的副会长·四宫辉夜与会长·白银御行原本应该是彼此受到了对方吸引…但想不到都过半年了却仍然什么事情也没发生！！最麻烦的是这两个自尊心超强、无法坦率的家伙，居然开始想着要“设法让对方向自己告白”！？ 直到恋情有下落之前会很欢乐的故事！！新感觉“斗智”爱情喜剧、就此开战！！ 制作人员： 原作：赤坂明 导演：小俣真一 脚本：中西泰大、菅原雪绘 分镜：藤泽俊幸、中村哲治、及川启、齐藤哲人、十的一发 ","date":"2019-01-12","objectID":"/anime/kaguya_love/:1:0","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 四宫辉夜 しのみや かぐや、Shinomiya Kaguya 女 古賀葵 2 白银御行 しろがね みゆき、Shirogane Miyuki 男 古川慎 3 藤原千花 ふじわら ちか、Fujiwara Chika 女 小原好美 4 石上优 いしがみ ゆう 男 鈴木崚汰 5 早坂爱 はやさか あい、Hayasaka Ai 女 花守ゆみり 6 柏木渚 かしわぎ なぎさ 女 麻倉もも 7 田沼翼 柏木的男友、柏木の彼氏、たぬま つばさ、Tamema Tsubasa、男子生徒 男 八代拓 8 白银圭 しろがね けい、Shirogane Kei 女 鈴代紗弓 ","date":"2019-01-12","objectID":"/anime/kaguya_love/:2:0","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 辉夜大小姐想让我告白～天才们的恋爱头脑战～ 2019-01-12 12 bilibili 2 辉夜大小姐想让我告白？～天才们的恋爱头脑战～ 2020-04-11 12 bilibili 3 辉夜大小姐想让我告白-超级浪漫- 2022-04-08 13 bilibili ","date":"2019-01-12","objectID":"/anime/kaguya_love/:3:0","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"MAD ","date":"2019-01-12","objectID":"/anime/kaguya_love/:4:0","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"晚唐年间，国师发动民众大量捕蛇。前去刺杀国师的白蛇意外失忆，被捕蛇村少年救下。为帮助少女找回记忆，两人踏上了一段冒险旅程。冒险的过程让两人感情迅速升温，但少女蛇妖的身份也逐渐显露，另一边国师与蛇族之间不可避免的大战也即将打响，两人的爱情将要接受巨大考验。","date":"2019-01-11","objectID":"/anime/white_snake/","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"简介 晚唐年间，国师发动民众大量捕蛇。前去刺杀国师的白蛇意外失忆，被捕蛇村少年救下。为帮助少女找回记忆，两人踏上了一段冒险旅程。冒险的过程让两人感情迅速升温，但少女蛇妖的身份也逐渐显露，另一边国师与蛇族之间不可避免的大战也即将打响，两人的爱情将要接受巨大考验。 制作人员： 导演：赵霁 脚本：王微 主题歌演出：周深 製作：华纳兄弟娱乐公司、追光人动画设计（北京）有限公司 ","date":"2019-01-11","objectID":"/anime/white_snake/:1:0","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小白 ハク 女 三森すずこ 2 阿宣 セン 男 杨天翔 3 肚兜 はらまき 杉田智和 4 小青 セイ 女 佐倉綾音 5 宝青坊主 宝青坊の主、ホウセイボウノヌシ 女 悠木碧 6 道士 ドウシ 男 石川界人 7 蛇母 ジャボ 本田貴子 8 国师 国師、コクシ 男 柴田秀勝 ","date":"2019-01-11","objectID":"/anime/white_snake/:2:0","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 白蛇：缘起 2019-01-11 99m 其它 ","date":"2019-01-11","objectID":"/anime/white_snake/:3:0","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"MAD ","date":"2019-01-11","objectID":"/anime/white_snake/:4:0","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"2018 动画年终盘点，包括 MAD、短片、音乐等","date":"2018-12-31","objectID":"/anime/2018/","tags":null,"title":"2018 年终盘点","uri":"/anime/2018/"},{"categories":null,"content":"\r","date":"2018-12-31","objectID":"/anime/2018/:0:0","tags":null,"title":"2018 年终盘点","uri":"/anime/2018/"},{"categories":null,"content":"MAD ","date":"2018-12-31","objectID":"/anime/2018/:1:0","tags":null,"title":"2018 年终盘点","uri":"/anime/2018/"},{"categories":null,"content":"单素材 ","date":"2018-12-31","objectID":"/anime/2018/:1:1","tags":null,"title":"2018 年终盘点","uri":"/anime/2018/"},{"categories":null,"content":"多素材 ","date":"2018-12-31","objectID":"/anime/2018/:1:2","tags":null,"title":"2018 年终盘点","uri":"/anime/2018/"},{"categories":null,"content":"短片 ","date":"2018-12-31","objectID":"/anime/2018/:2:0","tags":null,"title":"2018 年终盘点","uri":"/anime/2018/"},{"categories":null,"content":" 力扣第 117 场周赛第 3 题 ","date":"2018-12-30","objectID":"/leetcode/0966/:0:0","tags":null,"title":"0966：元音拼写检查器（★）","uri":"/leetcode/0966/"},{"categories":null,"content":"题目 在给定单词列表 wordlist 的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。 对于给定的查询单词 query，拼写检查器将会处理两类拼写错误： 大小写：如果查询匹配单词列表中的某个单词（不区分大小写），则返回的正确单词与单词列表中的大小写相同。 例如：wordlist = [\"yellow\"], query = \"YellOw\": correct = \"yellow\" 例如：wordlist = [\"Yellow\"], query = \"yellow\": correct = \"Yellow\" 例如：wordlist = [\"yellow\"], query = \"y","date":"2018-12-30","objectID":"/leetcode/0966/:1:0","tags":null,"title":"0966：元音拼写检查器（★）","uri":"/leetcode/0966/"},{"categories":null,"content":"分析 依次将 “单词本身、单词小写形式、单词元音替换为’*’ “分别作为 key 保存在哈希表中，查询时也依此顺序的 key 查找即可。 查询只需要返回第一个，因此哈希表每个 key 也只保存第一个即可。 ","date":"2018-12-30","objectID":"/leetcode/0966/:2:0","tags":null,"title":"0966：元音拼写检查器（★）","uri":"/leetcode/0966/"},{"categories":null,"content":"解答 def spellchecker(self, wordlist: List[str], queries: List[str]) -\u003e List[str]: vis = set(wordlist) d = {} for w in wordlist: w2 = w.lower() d.setdefault(w2, w) w3 = ''.join('*' if c in 'aeiou' else c for c in w2) d.setdefault(w3, w) def find(q): if q in vis: return q q2 = q.lower() if q2 in d: ret","date":"2018-12-30","objectID":"/leetcode/0966/:3:0","tags":null,"title":"0966：元音拼写检查器（★）","uri":"/leetcode/0966/"},{"categories":null,"content":" 力扣第 116 场周赛第 2 题 ","date":"2018-12-23","objectID":"/leetcode/0962/:0:0","tags":null,"title":"0962：最大宽度坡（★）","uri":"/leetcode/0962/"},{"categories":null,"content":"题目 给定一个整数数组 A，坡是元组 (i, j)，其中 i \u003c j 且 A[i] \u003c= A[j]。这样的坡的宽度为 j - i。 找出 A 中的坡的最大宽度，如果不存在，返回 0 。 示例 1： 输入：[6,0,8,2,1,5] 输出：4 解释： 最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5. 示例 2： 输入：[9,8,1,0,1,9,4,0,4,1] 输出：7 解释： 最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1. 提示： 2 \u003c= A.length \u003c= 50000 0 \u003c= A[i] \u003c= 500","date":"2018-12-23","objectID":"/leetcode/0962/:1:0","tags":null,"title":"0962：最大宽度坡（★）","uri":"/leetcode/0962/"},{"categories":null,"content":"分析 ","date":"2018-12-23","objectID":"/leetcode/0962/:2:0","tags":null,"title":"0962：最大宽度坡（★）","uri":"/leetcode/0962/"},{"categories":null,"content":"#1 暴力法就是遍历位置 j，在 A[:j] 中找最小的 i 使得 A[i] \u003c= A[j]。 注意到如果 x \u003c y 且 A[x] \u003c= A[y]，显然 y 不可能是答案。 因此可以维护一个严格递减的列表 tmp，保存有用的位置。 然后每轮在 tmp 中二分查找第一个小于等于 A[j] 的位置即可。 def maxWidthRamp(self, A: List[int]) -\u003e int: res, tmp = 0, [] self.__class__.__getitem__ = lambda self, x: A[tmp[x]] \u003c= A[j] for j in range(len(A)):","date":"2018-12-23","objectID":"/leetcode/0962/:2:1","tags":null,"title":"0962：最大宽度坡（★）","uri":"/leetcode/0962/"},{"categories":null,"content":"#2 还有个巧妙地单调栈解法。 先一趟遍历得到完整的 tmp，最大宽度坡的开头必然在 tmp 中。 然后反向遍历 j，对于 tmp 中满足 A[i] \u003c= A[j] 的位置 i， i 能对应的最大宽度坡的结尾即为 j，可以弹出 i。 ","date":"2018-12-23","objectID":"/leetcode/0962/:2:2","tags":null,"title":"0962：最大宽度坡（★）","uri":"/leetcode/0962/"},{"categories":null,"content":"解答 def maxWidthRamp(self, A: List[int]) -\u003e int: stack, n = [], len(A) for i in range(n): if not stack or A[i] \u003c A[stack[-1]]: stack.append(i) res = 0 for j in range(n-1, -1, -1): while stack and A[stack[-1]] \u003c= A[j]: res = max(res, j-stack.pop()) return res 308 ms ","date":"2018-12-23","objectID":"/leetcode/0962/:3:0","tags":null,"title":"0962：最大宽度坡（★）","uri":"/leetcode/0962/"},{"categories":null,"content":" 力扣第 115 场周赛第 3 题 ","date":"2018-12-16","objectID":"/leetcode/0959/:0:0","tags":null,"title":"0959：由斜杠划分区域（★★）","uri":"/leetcode/0959/"},{"categories":null,"content":"题目 在由 1 x 1 方格组成的 n x n 网格 grid 中，每个 1 x 1 方块由 '/'、'\\' 或空格构成。这些字符会将方块划分为一些共边的区域。 给定网格 grid 表示为一个字符串数组，返回 区域的数量 。 请注意，反斜杠字符是转义的，因此 '\\' 用 '\\\\' 表示。 示例 1： 输入：grid = [\" /\",\"/ \"] 输出：2 示例 2： 输入：grid = [\" /\",\" \"] 输出：1 示例 3： 输入：grid = [\"/\\\\\",\"\\\\/\"] 输出：5 解释：回想一下，因为 \\ 字符是转义的，所以 \"/\\\\\" 表示 /\\，而 \"\\\\/\" 表示 \\/。 提示： n","date":"2018-12-16","objectID":"/leetcode/0959/:1:0","tags":null,"title":"0959：由斜杠划分区域（★★）","uri":"/leetcode/0959/"},{"categories":null,"content":"分析 区域数量其实就是连通块的数量，考虑用并查集。 ‘/’ 和 ‘' 将方格分为四小块，遍历并连通即可。 注意方格 (i, j) 左小块和 (i, j-1) 右小块必然连通， 方格 (i, j) 上小块和 (i-1, j) 下小块必然连通。 ","date":"2018-12-16","objectID":"/leetcode/0959/:2:0","tags":null,"title":"0959：由斜杠划分区域（★★）","uri":"/leetcode/0959/"},{"categories":null,"content":"解答 def regionsBySlashes(self, grid: List[str]) -\u003e int: def find(x): if f.setdefault(x, x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) n, f = len(grid), {} for i, j in product(range(n), range(n)): if i: union((i, j, 0), (i-1, j, 2)) if j: union((i, j, 3), (i, j-1, 1)) if","date":"2018-12-16","objectID":"/leetcode/0959/:3:0","tags":null,"title":"0959：由斜杠划分区域（★★）","uri":"/leetcode/0959/"},{"categories":null,"content":"蜘蛛侠不止一个！漫威首部超英动画巨制《蜘蛛侠：平行宇宙》将经典漫画与CGI技术完美呈现，讲述了普通高中生迈尔斯·莫拉斯如何师从蜘蛛侠彼得·帕克，成长为新一代超级英雄的故事。影片中迈尔斯和从其它平行宇宙中穿越而来的彼得、女蜘蛛侠格温、暗影蜘蛛侠、潘妮·帕克和蜘猪侠集结成团，六位蜘蛛侠首次同框大银幕，对抗蜘蛛侠宇宙最强反派。","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":"简介 蜘蛛侠不止一个！漫威首部超英动画巨制《蜘蛛侠：平行宇宙》将经典漫画与CGI技术完美呈现，讲述了普通高中生迈尔斯·莫拉斯如何师从蜘蛛侠彼得·帕克，成长为新一代超级英雄的故事。影片中迈尔斯和从其它平行宇宙中穿越而来的彼得、女蜘蛛侠格温、暗影蜘蛛侠、潘妮·帕克和蜘猪侠集结成团，六位蜘蛛侠首次同框大银幕，对抗蜘蛛侠宇宙最强反派。 制作人员： 原作：斯坦·李、漫威娱乐 特效：索尼图形图像运作公司 制作：索尼影视娱乐 ","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/:1:0","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 蜘蛛侠 蜘蛛人、スパイダーマン 男 2 潘妮·帕克 蜘蛛机甲战士（SP//dr） 女 高橋李依 ","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/:2:0","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 蜘蛛侠：平行宇宙 2018-12-14 01:45:24 樱花 ","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/:3:0","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":"MAD ","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/:4:0","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":" 力扣第 114 场周赛第 3 题 ","date":"2018-12-09","objectID":"/leetcode/0955/:0:0","tags":null,"title":"0955：删列造序 II（★★）","uri":"/leetcode/0955/"},{"categories":null,"content":"题目 给定由 n 个字符串组成的数组 strs，其中每个字符串长度相等。 选取一个删除索引序列，对于 strs 中的每个字符串，删除对应每个索引处的字符。 比如，有 strs = [\"abcdef\", \"uvwxyz\"]，删除索引序列 {0, 2, 3}，删除后 strs 为[\"bef\", \"vyz\"]。 假设，我们选择了一组删除索引 answer，那么在执行删除操作之后，最终得到的数组的元素是按 字典序（strs[0] \u003c= strs[1] \u003c= strs[2] ... \u003c= strs[n - 1]）排列的，然后请你返回 answer.length 的最小可能值。 示例 1： 输入：strs","date":"2018-12-09","objectID":"/leetcode/0955/:1:0","tags":null,"title":"0955：删列造序 II（★★）","uri":"/leetcode/0955/"},{"categories":null,"content":"分析 ","date":"2018-12-09","objectID":"/leetcode/0955/:2:0","tags":null,"title":"0955：删列造序 II（★★）","uri":"/leetcode/0955/"},{"categories":null,"content":"#1 假如第一列是按字典序排列的，那么应该保留第一列，可以反证： 假如去掉第一列之后的最佳方案是保留成数组 A，按字典序排列 将第一列加到数组 A 上，依然保持字典序，矛盾 同理可以递推后面的情况，于是得到贪心策略： 维护当前保留的数组 A 遍历到某一列，假如 A 加上这一列后维持字典序，就保留，否则删除 def minDeletionSize(self, strs: List[str]) -\u003e int: res, A = 0, ['']*len(strs) for col in zip(*strs): B = [x+y for x,y in zip(A,col)] if B != sorte","date":"2018-12-09","objectID":"/leetcode/0955/:3:0","tags":null,"title":"0955：删列造序 II（★★）","uri":"/leetcode/0955/"},{"categories":null,"content":"#2 还可以优化： 对于当前保留的数组 A，假如 A[i] 严格小于 A[i+1]，那么后面的列就无需再比较此位置 因此维护当前无需再比较的位置 cut，在列内比较其它位置即可 ","date":"2018-12-09","objectID":"/leetcode/0955/:4:0","tags":null,"title":"0955：删列造序 II（★★）","uri":"/leetcode/0955/"},{"categories":null,"content":"解答 def minDeletionSize(self, strs: List[str]) -\u003e int: res, cut, n = 0, set(), len(strs) for col in zip(*strs): if all(i in cut or col[i]\u003c=col[i+1] for i in range(n-1)): cut |= {i for i in range(n-1) if col[i]\u003ccol[i+1]} else: res += 1 return res 48 ms ","date":"2018-12-09","objectID":"/leetcode/0955/:5:0","tags":null,"title":"0955：删列造序 II（★★）","uri":"/leetcode/0955/"},{"categories":null,"content":" 力扣第 113 场周赛第 3 题 ","date":"2018-12-02","objectID":"/leetcode/0950/:0:0","tags":null,"title":"0950：按递增顺序显示卡牌（★）","uri":"/leetcode/0950/"},{"categories":null,"content":"题目 牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。 最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。 现在，重复执行以下步骤，直到显示所有卡牌为止： 从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。 如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。 如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。 返回能以递增顺序显示卡牌的牌组顺序。 答案中的第一张牌被认为处于牌堆顶部。 示例： 输入：[17,13,11,2,3,5,7] 输出：[2,13,3,11,5,17,7] 解释： 我们得到的牌组顺序为 [17,13,11,2,3,5,7]","date":"2018-12-02","objectID":"/leetcode/0950/:1:0","tags":null,"title":"0950：按递增顺序显示卡牌（★）","uri":"/leetcode/0950/"},{"categories":null,"content":"分析 可以模拟过程，记录下每次移除的牌在原数组中的位置，依次赋值即可。 ","date":"2018-12-02","objectID":"/leetcode/0950/:2:0","tags":null,"title":"0950：按递增顺序显示卡牌（★）","uri":"/leetcode/0950/"},{"categories":null,"content":"解答 def deckRevealedIncreasing(self, deck: List[int]) -\u003e List[int]: n = len(deck) res, idxs = [0]*n, deque(range(n)) for card in sorted(deck): res[idxs.popleft()] = card if idxs: idxs.append(idxs.popleft()) return res 60 ","date":"2018-12-02","objectID":"/leetcode/0950/:3:0","tags":null,"title":"0950：按递增顺序显示卡牌（★）","uri":"/leetcode/0950/"},{"categories":null,"content":" 力扣第 112 场周赛第 2 题 ","date":"2018-11-25","objectID":"/leetcode/0946/:0:0","tags":null,"title":"0946：验证栈序列（★）","uri":"/leetcode/0946/"},{"categories":null,"content":"题目 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例 1： 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\r输出：true\r解释：我们可以按以下顺序执行：\rpush(1), push(2), push(3), push(4), pop() -\u003e 4,\rpush(5), pop() -\u003e 5, pop() -\u003e 3, pop() -\u003e 2, pop() -\u003e 1\r示例 2： 输入：pushed ","date":"2018-11-25","objectID":"/leetcode/0946/:1:0","tags":null,"title":"0946：验证栈序列（★）","uri":"/leetcode/0946/"},{"categories":null,"content":"分析 模拟过程，判断是否栈空即可。 ","date":"2018-11-25","objectID":"/leetcode/0946/:2:0","tags":null,"title":"0946：验证栈序列（★）","uri":"/leetcode/0946/"},{"categories":null,"content":"解答 def validateStackSequences(self, pushed: List[int], popped: List[int]) -\u003e bool: stack, j, n = [], 0, len(pushed) for num in pushed: stack.append(num) while stack and j \u003c n and stack[-1] == popped[j]: stack.pop() j += 1 return not stack 56 ms ","date":"2018-11-25","objectID":"/leetcode/0946/:3:0","tags":null,"title":"0946：验证栈序列（★）","uri":"/leetcode/0946/"},{"categories":null,"content":" 力扣第 109 场周赛第 1 题 ","date":"2018-11-04","objectID":"/leetcode/0933/:0:0","tags":null,"title":"0933：最近的请求次数","uri":"/leetcode/0933/"},{"categories":null,"content":"题目 写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请你实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。\rint ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。\r保证 每次对 ping 的调用都使用比之前更大的 t 值。 示例 1： 输入：\r[\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"]\r[[], [1]","date":"2018-11-04","objectID":"/leetcode/0933/:1:0","tags":null,"title":"0933：最近的请求次数","uri":"/leetcode/0933/"},{"categories":null,"content":"分析 维护一个队列，将小于 t-3000 的元素弹出即可。 ","date":"2018-11-04","objectID":"/leetcode/0933/:2:0","tags":null,"title":"0933：最近的请求次数","uri":"/leetcode/0933/"},{"categories":null,"content":"解答 class RecentCounter: def __init__(self): self.queue = deque() def ping(self, t: int) -\u003e int: self.queue.append(t) while self.queue[0] \u003c t-3000: self.queue.popleft() return len(self.queue) 256 ms ","date":"2018-11-04","objectID":"/leetcode/0933/:3:0","tags":null,"title":"0933：最近的请求次数","uri":"/leetcode/0933/"},{"categories":null,"content":" 力扣第 106 场周赛第 2 题 ","date":"2018-10-14","objectID":"/leetcode/0921/:0:0","tags":null,"title":"0921：使括号有效的最少添加","uri":"/leetcode/0921/"},{"categories":null,"content":"题目 只有满足下面几点之一，括号字符串才是有效的： 它是一个空字符串，或者\r它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者\r它可以被写作 (A)，其中 A 是有效字符串。\r给定一个括号字符串 s ，在每一次操作中，你都可以在字符串的任何位置插入一个括号 例如，如果 s = \"()))\" ，你可以插入一个开始括号为 \"(()))\" 或结束括号为 \"())))\" 。\r返回 为使结果字符串 s 有效而必须添加的最少括号数。 示例 1： 输入：s = \"())\"\r输出：1\r示例 2： 输入：s = \"(((\"\r输出：3\r提示： 1 \u003c= s.length \u003c= 10","date":"2018-10-14","objectID":"/leetcode/0921/:1:0","tags":null,"title":"0921：使括号有效的最少添加","uri":"/leetcode/0921/"},{"categories":null,"content":"分析 1249 的镜像版。顺序遍历遇到无效括号时，显然必须执行一次添加操作，最后才可能变为有效。 因此最少添加数就是 1249 中的最少删除数。 ","date":"2018-10-14","objectID":"/leetcode/0921/:2:0","tags":null,"title":"0921：使括号有效的最少添加","uri":"/leetcode/0921/"},{"categories":null,"content":"解答 def minAddToMakeValid(self, s: str) -\u003e int: ans, size = 0, 0 for char in s: size += 1 if char == '(' else -1 if char == ')' else 0 if size \u003c 0: ans, size = ans+1, 0 return ans + size 24 ms ","date":"2018-10-14","objectID":"/leetcode/0921/:3:0","tags":null,"title":"0921：使括号有效的最少添加","uri":"/leetcode/0921/"},{"categories":null,"content":" 力扣第 105 场周赛第 2 题 ","date":"2018-10-07","objectID":"/leetcode/0918/:0:0","tags":null,"title":"0918：环形子数组的最大和（★）","uri":"/leetcode/0918/"},{"categories":null,"content":"题目 给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。 环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。 子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i \u003c= k1, k2 \u003c= j 其中 k1 % n == k2 % n 。 示例 1： 输入：nums = [1,-2,3,","date":"2018-10-07","objectID":"/leetcode/0918/:1:0","tags":null,"title":"0918：环形子数组的最大和（★）","uri":"/leetcode/0918/"},{"categories":null,"content":"分析 ","date":"2018-10-07","objectID":"/leetcode/0918/:2:0","tags":null,"title":"0918：环形子数组的最大和（★）","uri":"/leetcode/0918/"},{"categories":null,"content":"#1 涉及到子数组的和，首先想到前缀和。因为是环形数组，所以考虑求 nums*2 的前缀和。 得到前缀和数组 pre 后，问题转为：求最大的 pre[j]-pre[i] 满足 j-i\u003c=len(nums)。 那么遍历 j，维护 pre[j-n:j] 的最小值即可。这类似于 0239，可以用有序集合解决。 def maxSubarraySumCircular(self, nums: List[int]) -\u003e int: from sortedcontainers import SortedList pre = list(accumulate([0]+nums*2)) sl, n = Sorted","date":"2018-10-07","objectID":"/leetcode/0918/:2:1","tags":null,"title":"0918：环形子数组的最大和（★）","uri":"/leetcode/0918/"},{"categories":null,"content":"#2 也可以采用 0239 的单调队列方法。 ","date":"2018-10-07","objectID":"/leetcode/0918/:2:2","tags":null,"title":"0918：环形子数组的最大和（★）","uri":"/leetcode/0918/"},{"categories":null,"content":"解答 def maxSubarraySumCircular(self, nums: List[int]) -\u003e int: pre = list(accumulate([0]+nums*2)) queue, n = deque(), len(nums) res = float('-inf') for j, x in enumerate(pre): if j: res = max(res, x-queue[0][0]) while queue and queue[-1][0]\u003e=x: queue.pop() queue.append((x, j)) if queue[0][1]==j-n: que","date":"2018-10-07","objectID":"/leetcode/0918/:3:0","tags":null,"title":"0918：环形子数组的最大和（★）","uri":"/leetcode/0918/"},{"categories":null,"content":"居住在踯躅台的高中1年级学生响裕太，某天醒来后失去了记忆。之后，裕太与旧电脑里显现出来的“Hyper Agent Gridman”相遇了。\nGridman告诉裕太“去完成使命”，而裕太则开始寻找这番话的意义以及自己的记忆。虽然对这一突发事件感到困惑，裕太仍然在同班同学内海将以及宝多六花、新条茜等人的帮助下过着每一天。然而，平稳的日子被突然现身的怪兽轻易地踏碎——","date":"2018-10-06","objectID":"/anime/ssss.gridman/","tags":null,"title":"SSSS.古立特","uri":"/anime/ssss.gridman/"},{"categories":null,"content":"简介 居住在踯躅台的高中1年级学生响裕太，某天醒来后失去了记忆。之后，裕太与旧电脑里显现出来的“Hyper Agent Gridman”相遇了。 Gridman告诉裕太“去完成使命”，而裕太则开始寻找这番话的意义以及自己的记忆。虽然对这一突发事件感到困惑，裕太仍然在同班同学内海将以及宝多六花、新条茜等人的帮助下过着每一天。然而，平稳的日子被突然现身的怪兽轻易地踏碎—— 制作人员： 导演：雨宫哲 脚本：长谷川圭一 分镜：久场良忠、中园真登、五十岚海、宫岛善博、藤井辰己、奥居久明 ","date":"2018-10-06","objectID":"/anime/ssss.gridman/:1:0","tags":null,"title":"SSSS.古立特","uri":"/anime/ssss.gridman/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 响裕太 ひびき ゆうた、Hibiki Yuta 男 広瀬裕也 2 古立特 GRIDMAN 男 緑川光 3 内海将 うつみ しょう、Utsumi Sho 男 斉藤壮馬 4 宝多六花 たからだ りっか、Takarada Rikka 女 宮本侑芽 5 新条茜 しんじょう アカネ、Shinjo Akane 女 上田麗奈 6 アレクシス・ケリヴ ALEXIS・KERIB 男 稲田徹 7 武士圣剑 SAMURAI・CALIBUR 男 高橋良輔 8 マックス MAX 小西克幸 ","date":"2018-10-06","objectID":"/anime/ssss.gridman/:2:0","tags":null,"title":"SSSS.古立特","uri":"/anime/ssss.gridman/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 SSSS.古立特 2018-10-06 12 樱花 2 SSSS.电光机王 2021-04-02 12 樱花 ","date":"2018-10-06","objectID":"/anime/ssss.gridman/:3:0","tags":null,"title":"SSSS.古立特","uri":"/anime/ssss.gridman/"},{"categories":null,"content":"MAD ","date":"2018-10-06","objectID":"/anime/ssss.gridman/:4:0","tags":null,"title":"SSSS.古立特","uri":"/anime/ssss.gridman/"},{"categories":null,"content":"“我不拯救世界，只管杀哥布林。”\n据说这间边境公会里，有个只靠讨伐哥布林升上了银等级（位列第三位）的罕见存在……一名女神官成为冒险者后，首次加入团队，就在冒险中陷入了危机。而拯救了她的，正是这名被称为“哥布林杀手”的男子。\n他不择手段，不辞劳苦，只致力于扫荡哥布林。 在他身边，有着饱受折腾的女神官、自己非常感激的柜台小姐，等待着他青梅竹马的牧牛少女。一名森人（妖精）少女听闻他的事迹，也前来委托任务——。","date":"2018-10-06","objectID":"/anime/goblin_slayer/","tags":null,"title":"哥布林杀手","uri":"/anime/goblin_slayer/"},{"categories":null,"content":"简介 “我不拯救世界，只管杀哥布林。” 据说这间边境公会里，有个只靠讨伐哥布林升上了银等级（位列第三位）的罕见存在……一名女神官成为冒险者后，首次加入团队，就在冒险中陷入了危机。而拯救了她的，正是这名被称为“哥布林杀手”的男子。 他不择手段，不辞劳苦，只致力于扫荡哥布林。 在他身边，有着饱受折腾的女神官、自己非常感激的柜台小姐，等待着他青梅竹马的牧牛少女。一名森人（妖精）少女听闻他的事迹，也前来委托任务——。 制作人员： 原作：蝸牛くも 导演：尾崎隆晴 脚本：仓田英之、黑田洋介 分镜：神谷纯、迫井政行、古贺一臣、小泽一浩 ","date":"2018-10-06","objectID":"/anime/goblin_slayer/:1:0","tags":null,"title":"哥布林杀手","uri":"/anime/goblin_slayer/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哥布林杀手 Goblin Slayer 男 松田颯水 2 女神官 Priestess 女 小倉唯 3 妖精弓手 High Elf Archer 女 東山奈央 4 矿人道士 Dwarf Shaman 男 中村悠一 5 蜥蜴僧侣 Lizard Priest 男 杉田智和 6 牧牛妹 Cow Girl 女 井口裕香 7 柜台小姐 Guild Girl 女 内田真礼 8 剑之圣女 Sword Maiden 女 遠藤綾 ","date":"2018-10-06","objectID":"/anime/goblin_slayer/:2:0","tags":null,"title":"哥布林杀手","uri":"/anime/goblin_slayer/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哥布林杀手 2018-10-06 12 樱花 2 哥布林杀手：哥布林的王冠 2020-02-01 1 樱花 ","date":"2018-10-06","objectID":"/anime/goblin_slayer/:3:0","tags":null,"title":"哥布林杀手","uri":"/anime/goblin_slayer/"},{"categories":null,"content":"女主出场不到两分钟，光速去世；为了拯救没落的佐贺县，7位僵尸小姐姐站了出来，决定成为偶像……","date":"2018-10-04","objectID":"/anime/zombie_land_saga/","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"简介 女主出场不到两分钟，光速去世；为了拯救没落的佐贺县，7位僵尸小姐姐站了出来，决定成为偶像…… 制作人员： 导演：境宗久 脚本：村越繁、增本拓也 分镜：后藤康徳、石田贵史、清水久敏、伊藤达文、宇田钢之介、佐藤威 ","date":"2018-10-04","objectID":"/anime/zombie_land_saga/:1:0","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 巽幸太郎 たつみ こうたろう、Tatsumi Kotaro 男 宮野真守 2 源樱 みなもと さくら、Minamoto Sakura 女 本渡楓 3 二阶堂咲 二阶堂笑、にかいどう さき、Nikaido Saki 女 田野アサミ 4 水野爱 みずの あい、Mizuno Ai 女 種田梨沙 5 绀野纯子 こんの じゅんこ、Konno Junko 女 河瀬茉希 6 夕雾 Yugiri 女 衣川里佳 7 星川莉莉 豪正雄、Hoshikawa Lily、ほしかわ リリィ、Hoshikawa Ririi、正雄哥 田中美海 8 山田多惠 山田妙、やまだ たえ、Yamad","date":"2018-10-04","objectID":"/anime/zombie_land_saga/:2:0","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 佐贺偶像是传奇 2018-10-04 12 acfun 2 佐贺偶像是传奇 复仇 2021-04-08 12 bilibili ","date":"2018-10-04","objectID":"/anime/zombie_land_saga/:3:0","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"MAD ","date":"2018-10-04","objectID":"/anime/zombie_land_saga/:4:0","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"思春期症候群——这是一种只发生在易敏感和不稳定的青春期的、不可思议的现象。\n例如，在梓川咲太面前出现的野生兔女郎。\n她的真实身份是高中高年级学生，明星活动休止的女演员樱岛麻衣。她迷人的身姿，不知为何在周围的人眼里看不出来。\n咲太决定解开这一谜题。在于麻衣一起度过的时间里，咲太知道了她秘密的想法……\n女主人公们一个接一个地出现在咲太的周围，她们都有着“青春期症候群”。在天空和大海都很闪耀的小镇上，开始了令人激动的故事。","date":"2018-10-03","objectID":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/","tags":null,"title":"青春笨蛋少年不做兔女郎学姐的梦","uri":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/"},{"categories":null,"content":"简介 思春期症候群——这是一种只发生在易敏感和不稳定的青春期的、不可思议的现象。 例如，在梓川咲太面前出现的野生兔女郎。 她的真实身份是高中高年级学生，明星活动休止的女演员樱岛麻衣。她迷人的身姿，不知为何在周围的人眼里看不出来。 咲太决定解开这一谜题。在于麻衣一起度过的时间里，咲太知道了她秘密的想法…… 女主人公们一个接一个地出现在咲太的周围，她们都有着“青春期症候群”。在天空和大海都很闪耀的小镇上，开始了令人激动的故事。 制作人员： 原作：鸭志田一 导演：增井壮一 脚本：横谷昌宏 分镜：小野龙太、宫尾佳和、平牧大辅、岩田和也、堀口和树、倉川英揚 ","date":"2018-10-03","objectID":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/:1:0","tags":null,"title":"青春笨蛋少年不做兔女郎学姐的梦","uri":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 梓川咲太 梓川 咲太、あずさがわ さくた、Azusagawa Sakuta 男 石川界人 2 樱岛麻衣 さくらじま まい、Sakurajima Mai 女 瀬戸麻沙美 3 古贺朋绘 古賀 朋絵、こが ともえ、Koga Tomoe 女 東山奈央 4 双叶理央 双葉 理央、ふたば りお、Futaba Rio 女 種﨑敦美 5 丰滨和花 丰滨和香、とよはま のどか、Toyohama Nodoka 女 内田真礼 6 梓川枫 梓川 かえで、あずさがわ かえで、Azusagawa Kaede 女 久保ユリカ 7 牧之原翔子 まきのはら しょうこ、Makinohara S","date":"2018-10-03","objectID":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/:2:0","tags":null,"title":"青春笨蛋少年不做兔女郎学姐的梦","uri":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 青春笨蛋少年不做兔女郎学姐的梦 2018-10-03 13 bilibili 2 青春笨蛋少年不做怀梦美少女的梦 2019-06-15 1 bilibili ","date":"2018-10-03","objectID":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/:3:0","tags":null,"title":"青春笨蛋少年不做兔女郎学姐的梦","uri":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/"},{"categories":null,"content":"夜晚。如同逃跑一般奔驰在城市中的藏原走。他的侧面，突然有辆自行车冲来。素不相识的男子，对阿走发问了。“喂！你很喜欢跑步吧！”\n男子的名字是清濑灰二。 就这样，阿走在灰二的引导下，到达了名为竹青庄的老旧公寓。9名个性丰富的住民住在那里。阿走来到最后的空房间，虽然感到困惑，却仍然被强行留下。他怎么也没有想到，自己会成为这里的“第10个男人”……。","date":"2018-10-02","objectID":"/anime/run_with_the_wind/","tags":null,"title":"强风吹拂","uri":"/anime/run_with_the_wind/"},{"categories":null,"content":"简介 夜晚。如同逃跑一般奔驰在城市中的藏原走。他的侧面，突然有辆自行车冲来。素不相识的男子，对阿走发问了。“喂！你很喜欢跑步吧！” 男子的名字是清濑灰二。 就这样，阿走在灰二的引导下，到达了名为竹青庄的老旧公寓。9名个性丰富的住民住在那里。阿走来到最后的空房间，虽然感到困惑，却仍然被强行留下。他怎么也没有想到，自己会成为这里的“第10个男人”……。 制作人员： 原作：三浦紫苑 导演：野村和也 脚本：喜安浩平 分镜：板津匡览、江副仁美、笹木信作、佐藤雅子、町谷俊辅、中谷亚沙美 ","date":"2018-10-02","objectID":"/anime/run_with_the_wind/:1:0","tags":null,"title":"强风吹拂","uri":"/anime/run_with_the_wind/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藏原走 蔵原 走、クラハラ カケル、Kurahara Kakeru、カケル 男 大塚剛央 2 清濑灰二 キヨセ ハイジ、Kiyose Haiji、ハイジ 男 豊永利行 3 杉山高志 スギヤマ タカシ、Sugiyama Takashi、神童 男 内山昂輝 4 柏崎茜 柏崎 茜、カシワザキ アカネ、Kashiwazaki Akane、王子 男 入野自由 5 城太郎 城 太郎、ジョウ タロウ、Jo Taro、ジョータ 男 榎木淳弥 6 城次郎 城 次郎、ジョウ ジロウ、Jo Jiro、ジョージ 男 上村祐翔 7 岩仓雪彦 イワクラ ユキヒコ、Iwakura Yuk","date":"2018-10-02","objectID":"/anime/run_with_the_wind/:2:0","tags":null,"title":"强风吹拂","uri":"/anime/run_with_the_wind/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 强风吹拂 2018-10-02 23 bilibili ","date":"2018-10-02","objectID":"/anime/run_with_the_wind/:3:0","tags":null,"title":"强风吹拂","uri":"/anime/run_with_the_wind/"},{"categories":null,"content":"MAD ","date":"2018-10-02","objectID":"/anime/run_with_the_wind/:4:0","tags":null,"title":"强风吹拂","uri":"/anime/run_with_the_wind/"},{"categories":null,"content":" 力扣第 104 场周赛第 1 题 ","date":"2018-09-30","objectID":"/leetcode/0914/:0:0","tags":null,"title":"0914：卡牌分组","uri":"/leetcode/0914/"},{"categories":null,"content":"题目 给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X \u003e= 2 时返回 true。 示例 1： 输入：deck = [1,2,3,4,4,3,2,1] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2： 输入：deck = [1,1,1,2,2,2,3,3] 输出：false 解释：没有满足要求的分组。 提示： 1 \u003c= deck.length \u003c= 104 0 \u003c= deck[i] \u003c 104 ","date":"2018-09-30","objectID":"/leetcode/0914/:1:0","tags":null,"title":"0914：卡牌分组","uri":"/leetcode/0914/"},{"categories":null,"content":"分析 先将相同的牌分到一组，发现如果所有组的牌数有一个大于 1 的最大公约数，则可行。 ","date":"2018-09-30","objectID":"/leetcode/0914/:2:0","tags":null,"title":"0914：卡牌分组","uri":"/leetcode/0914/"},{"categories":null,"content":"解答 def hasGroupsSizeX(self, deck: List[int]) -\u003e bool: return reduce(gcd, Counter(deck).values())\u003e1 36 ms ","date":"2018-09-30","objectID":"/leetcode/0914/:3:0","tags":null,"title":"0914：卡牌分组","uri":"/leetcode/0914/"},{"categories":null,"content":" 力扣第 912 题 ","date":"2018-09-20","objectID":"/leetcode/0912/:0:0","tags":null,"title":"0912：排序数组（★）","uri":"/leetcode/0912/"},{"categories":null,"content":"题目 给你一个整数数组 nums，请你将该数组升序排列。 示例 1： 输入：nums = [5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：nums = [5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 \u003c= nums.length \u003c= 5 * 104 -5 * 104 \u003c= nums[i] \u003c= 5 * 104 ","date":"2018-09-20","objectID":"/leetcode/0912/:1:0","tags":null,"title":"0912：排序数组（★）","uri":"/leetcode/0912/"},{"categories":null,"content":"分析 ","date":"2018-09-20","objectID":"/leetcode/0912/:2:0","tags":null,"title":"0912：排序数组（★）","uri":"/leetcode/0912/"},{"categories":null,"content":"#1 最直接的当然是调库。 def sortArray(self, nums: List[int]) -\u003e List[int]: return sorted(nums) 48 ms ","date":"2018-09-20","objectID":"/leetcode/0912/:2:1","tags":null,"title":"0912：排序数组（★）","uri":"/leetcode/0912/"},{"categories":null,"content":"#2 可以把经典的排序方法都试一下。 其中选择排序、冒泡排序、插入排序的时间复杂度 O(N^2)，会超时。 归并排序： def sortArray(self, nums: List[int]) -\u003e List[int]: def merge(A, B): res, i, j = [], 0, 0 while i \u003c len(A) and j \u003c len(B): if A[i] \u003c= B[j]: res.append(A[i]) i += 1 else: res.append(B[j]) j += 1 return res + A[i:] + B[j:] n = len(nums) return","date":"2018-09-20","objectID":"/leetcode/0912/:2:2","tags":null,"title":"0912：排序数组（★）","uri":"/leetcode/0912/"},{"categories":null,"content":"#3 本题的数据范围相对于数组长度来说不大，适合用计数排序。 ","date":"2018-09-20","objectID":"/leetcode/0912/:2:3","tags":null,"title":"0912：排序数组（★）","uri":"/leetcode/0912/"},{"categories":null,"content":"解答 def sortArray(self, nums: List[int]) -\u003e List[int]: res, ct = [], Counter(nums) for val in range(min(ct), max(ct)+1): res.extend([val]*ct[val]) return res 100 ms ","date":"2018-09-20","objectID":"/leetcode/0912/:3:0","tags":null,"title":"0912：排序数组（★）","uri":"/leetcode/0912/"},{"categories":null,"content":" 力扣第 102 场周赛第 3 题 ","date":"2018-09-16","objectID":"/leetcode/0907/:0:0","tags":null,"title":"0907：子数组的最小值之和（★★）","uri":"/leetcode/0907/"},{"categories":null,"content":"题目 给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。 由于答案可能很大，因此 返回答案模 10^9 + 7 。 示例 1： 输入：arr = [3,1,2,4] 输出：17 解释： 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 示例 2： 输入：arr = [11,81,94,43,3] 输出：444 提示： 1 \u003c= arr.length \u003c= 3 * 104 1 \u003c= arr[i] \u003c","date":"2018-09-16","objectID":"/leetcode/0907/:1:0","tags":null,"title":"0907：子数组的最小值之和（★★）","uri":"/leetcode/0907/"},{"categories":null,"content":"分析 ","date":"2018-09-16","objectID":"/leetcode/0907/:2:0","tags":null,"title":"0907：子数组的最小值之和（★★）","uri":"/leetcode/0907/"},{"categories":null,"content":"#1 直接遍历所有区间会超时，有个巧妙的想法是遍历可能的最小值，计算其个数。 显然最小值只可能是 arr 的元素，而对应的个数可以根据左右最大能覆盖的区间来计算。 为了避免重复计算，假如区间有多个最小元素，令该区间属于最右边的那个。 那么，对于 arr[i]，找到左边第一个小于 arr[i] 的位置 left，找到右边第一个小于等于 arr[i] 的位置 right。 arr[i] 覆盖的区间个数就是 （i-left) * (right-i)。 找上一个更小元素和下一个更小元素，容易想到单调栈，类似 0084。 def sumSubarrayMins(self, arr: List[int])","date":"2018-09-16","objectID":"/leetcode/0907/:2:1","tags":null,"title":"0907：子数组的最小值之和（★★）","uri":"/leetcode/0907/"},{"categories":null,"content":"#2 类似 0084，可以一趟解决。 令栈中严格递增（也就是计算 left 的过程），遍历到位置 i 时，对于栈中满足 arr[j] \u003e= arr[i] 的位置 j 来说， j 的上一个更小元素就是 stack[-1]，而 j 的下一个小于等于 arr[j] 的元素就是 arr[i]。因此，直接就能得到 arr[j] 覆盖的区间个数。 注意最后栈中可能还剩余元素，需要遍历计算。一个更简单的做法是在 arr 末尾加一个极小值，让所有元素都出栈。 ","date":"2018-09-16","objectID":"/leetcode/0907/:2:2","tags":null,"title":"0907：子数组的最小值之和（★★）","uri":"/leetcode/0907/"},{"categories":null,"content":"解答 def sumSubarrayMins(self, arr: List[int]) -\u003e int: res, stack, M = 0, [], 10 ** 9 + 7 arr += [0] for i in range(len(arr)): while stack and arr[stack[-1]] \u003e= arr[i]: j = stack.pop() left = stack[-1] if stack else -1 res += arr[j] * (j-left) * (i-j) res %= M stack.append(i) return res 172 ms ","date":"2018-09-16","objectID":"/leetcode/0907/:3:0","tags":null,"title":"0907：子数组的最小值之和（★★）","uri":"/leetcode/0907/"},{"categories":null,"content":" 力扣第 101 场周赛第 3 题 ","date":"2018-09-09","objectID":"/leetcode/0902/:0:0","tags":null,"title":"0902：最大为 N 的数字组合（★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"题目 给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = ['1','3','5']，我们可以写数字，如 '13', '551', 和 '1351315'。 返回 可以生成的小于或等于给定整数 n 的正整数的个数 。 示例 1： 输入：digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\r输出：20\r解释：\r可写出的 20 个数字是：\r1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\r示例 2","date":"2018-09-09","objectID":"/leetcode/0902/:1:0","tags":null,"title":"0902：最大为 N 的数字组合（★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"分析 ","date":"2018-09-09","objectID":"/leetcode/0902/:2:0","tags":null,"title":"0902：最大为 N 的数字组合（★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"#1 求范围内数字满足某种性质的个数，容易想到用数位 dp，令 dfs(pos, state, bound) 代表某个状态下的结果： 遍历到 n 的第 pos 位 state 代表前面是否取了数 bound 代表前面取的数是否贴着 n 的上界 即可递归。 特别注意，“什么也不取”也被计算了，最后需要减去。 def atMostNGivenDigitSet(self, digits: List[str], n: int) -\u003e int: @lru_cache(None) def dfs(pos, state, bound): if pos==len(s): return 1 res, cur =","date":"2018-09-09","objectID":"/leetcode/0902/:2:1","tags":null,"title":"0902：最大为 N 的数字组合（★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"#2 也可以利用排列组合知识直接分段计算。例如对于 n=7382，digits=[“1”,“3”,“5”,“7”]： [0, 1000) 的对应个数：4+4^2+4^3 [1000, 7000) 的对应个数：3*4^3 [7000, 7300) 的对应个数：1*4^2 [7300, 7380) 的对应个数：4*4 [7380, 7382) 的对应个数：0 具体实现时，假设 s=str(n) 的长度为 m： 先计算 0-10^(m-1) 的对应个数 然后遍历 i，在 s[:i] 不变的情况下，求 s[i] 能取的值，即 digits 中比 s[i] 小的值， 然后求 s[i+1:] 的可能排列个","date":"2018-09-09","objectID":"/leetcode/0902/:2:2","tags":null,"title":"0902：最大为 N 的数字组合（★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"解答 def atMostNGivenDigitSet(self, digits: List[str], n: int) -\u003e int: s = str(n+1) m, k = len(s), len(digits) res = (k**m-k)//(k-1) if k\u003e1 else k*(m-1) for i, cur in enumerate(s): cand = [x for x in digits if x\u003ccur] res += len(cand)*pow(k, m-1-i) if cur not in digits: break return res 40 ms ","date":"2018-09-09","objectID":"/leetcode/0902/:3:0","tags":null,"title":"0902：最大为 N 的数字组合（★★）","uri":"/leetcode/0902/"},{"categories":null,"content":" 力扣第 101 场周赛第 2 题 ","date":"2018-09-09","objectID":"/leetcode/0901/:0:0","tags":null,"title":"0901：股票价格跨度（★）","uri":"/leetcode/0901/"},{"categories":null,"content":"题目 设计一个算法收集某些股票的每日报价，并返回该股票当日价格的 跨度 。 当日股票价格的 跨度 被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。 例如，如果未来 7 天股票的价格是 [100,80,60,70,60,75,85]，那么股票跨度将是 [1,1,1,2,1,4,6] 。 实现 StockSpanner 类： StockSpanner() 初始化类对象。\rint next(int price) 给出今天的股价 price ，返回该股票当日价格的 跨度 。\r示例： 输入：\r[\"StockSpanner\", \"next\", \"next\", \"next\",","date":"2018-09-09","objectID":"/leetcode/0901/:1:0","tags":null,"title":"0901：股票价格跨度（★）","uri":"/leetcode/0901/"},{"categories":null,"content":"分析 往前遍历，如果某天价格小于等于今天，显然该天的股票跨度对应的日期也小于等于今天。因此维护一个单调栈，每次保存该天的价格和股票跨度即可。 ","date":"2018-09-09","objectID":"/leetcode/0901/:2:0","tags":null,"title":"0901：股票价格跨度（★）","uri":"/leetcode/0901/"},{"categories":null,"content":"解答 class StockSpanner: def __init__(self): self.stack = [] def next(self, price: int) -\u003e int: cnt = 1 while self.stack and self.stack[-1][0] \u003c= price: cnt += self.stack.pop()[1] self.stack.append((price, cnt)) return cnt 520 ms ","date":"2018-09-09","objectID":"/leetcode/0901/:3:0","tags":null,"title":"0901：股票价格跨度（★）","uri":"/leetcode/0901/"},{"categories":null,"content":" 力扣第 99 场周赛第 4 题 ","date":"2018-08-26","objectID":"/leetcode/0895/:0:0","tags":null,"title":"0895：最大频率栈（★★）","uri":"/leetcode/0895/"},{"categories":null,"content":"题目 设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。 实现 FreqStack 类: FreqStack() 构造一个空的堆栈。\rvoid push(int val) 将一个整数 val 压入栈顶。\rint pop() 删除并返回堆栈中出现频率最高的元素。\r如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。\r示例 1： 输入：\r[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"pop\"],\r[[],[5],[7],[5],[7],[4],[5],[],[","date":"2018-08-26","objectID":"/leetcode/0895/:1:0","tags":null,"title":"0895：最大频率栈（★★）","uri":"/leetcode/0895/"},{"categories":null,"content":"分析 有点类似 0460 LFU缓存，不过没有 value，也没有查询操作，因此要简单很多。 令字典 freq 保存每个元素的频数，令 d 字典保存每个频数对应的元素列表。push 元素 x 时，freq[x] += 1，d[freq[x]].append(x)。 显然对于最大频数 maxFreq，d[maxFreq] 中的顺序即是元素最后一次入栈的顺序，所以 pop 时，x = d[maxFreq].pop()，freq[x] -= 1 即可。 可以维护 maxFreq 以节省时间。pop 时，若 d[maxFreq] 为空，则 maxFreq -= 1。 ","date":"2018-08-26","objectID":"/leetcode/0895/:2:0","tags":null,"title":"0895：最大频率栈（★★）","uri":"/leetcode/0895/"},{"categories":null,"content":"解答 class FreqStack: def __init__(self): self.d = defaultdict(list) self.freq = defaultdict(int) self.maxFreq = 0 def push(self, val: int) -\u003e None: self.freq[val] += 1 self.maxFreq = max(self.maxFreq, self.freq[val]) self.d[self.freq[val]].append(val) def pop(self) -\u003e int: x = self.d[self.maxFreq].po","date":"2018-08-26","objectID":"/leetcode/0895/:3:0","tags":null,"title":"0895：最大频率栈（★★）","uri":"/leetcode/0895/"},{"categories":null,"content":" 力扣第 99 场周赛第 3 题 ","date":"2018-08-26","objectID":"/leetcode/0894/:0:0","tags":null,"title":"0894：所有可能的真二叉树（★）","uri":"/leetcode/0894/"},{"categories":null,"content":"题目 给你一个整数 n ，请你找出所有可能含 n 个节点的 真二叉树 ，并以列表形式返回。答案中每棵树的每个节点都必须符合 Node.val == 0 。 答案的每个元素都是一棵真二叉树的根节点。你可以按 任意顺序 返回最终的真二叉树列表。 真二叉树 是一类二叉树，树中每个节点恰好有 0 或 2 个子节点。 示例 1： 输入：n = 7\r输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,n","date":"2018-08-26","objectID":"/leetcode/0894/:1:0","tags":null,"title":"0894：所有可能的真二叉树（★）","uri":"/leetcode/0894/"},{"categories":null,"content":"分析 按左右子树分别有多少个节点，可以转为递归子问题。 最简单的子问题即是 n=1，只有根节点。 注意满二叉树的节点数必然是奇数，可以节省时间。 ","date":"2018-08-26","objectID":"/leetcode/0894/:2:0","tags":null,"title":"0894：所有可能的真二叉树（★）","uri":"/leetcode/0894/"},{"categories":null,"content":"解答 def allPossibleFBT(self, n: int) -\u003e List[TreeNode]: if n % 2 == 0: return [] if n == 1: return [TreeNode(0)] res = [] for i in range(1, n-1, 2): for left in self.allPossibleFBT(i): for right in self.allPossibleFBT(n-1-i): res.append(TreeNode(0, left, right)) return res 128 ms ","date":"2018-08-26","objectID":"/leetcode/0894/:3:0","tags":null,"title":"0894：所有可能的真二叉树（★）","uri":"/leetcode/0894/"},{"categories":null,"content":" 力扣第 99 场周赛第 2 题 ","date":"2018-08-26","objectID":"/leetcode/0893/:0:0","tags":null,"title":"0893：特殊等价字符串组（★）","uri":"/leetcode/0893/"},{"categories":null,"content":"题目 给你一个字符串数组 words。 一步操作中，你可以交换字符串 words[i] 的任意两个偶数下标对应的字符或任意两个奇数下标对应的字符。 对两个字符串 words[i] 和 words[j] 而言，如果经过任意次数的操作，words[i] == words[j] ，那么这两个字符串是 特殊等价 的。 例如，words[i] = \"zzxy\" 和 words[j] = \"xyzz\" 是一对 特殊等价 字符串，因为可以按 \"zzxy\" -\u003e \"xzzy\" -\u003e \"xyzz\" 的操作路径使 words[i] == words[j] 。\r现在规定，words 的 一组特殊等价字符串 就是 w","date":"2018-08-26","objectID":"/leetcode/0893/:1:0","tags":null,"title":"0893：特殊等价字符串组（★）","uri":"/leetcode/0893/"},{"categories":null,"content":"分析 偶数下标可以任意交换，因此固定奇数下标，只要 ‘’.join(sorted(s[::2])) 相同即特殊等价。 同理，固定偶数下标，’’.join(sorted(s[1::2])) 相同即特殊等价。 综合一下，特殊等价相当于 key=’’.join(sorted(a[::2])+sorted(a[1::2])) 相同。因此只需要计算不同 key 的数量即可。 ","date":"2018-08-26","objectID":"/leetcode/0893/:2:0","tags":null,"title":"0893：特殊等价字符串组（★）","uri":"/leetcode/0893/"},{"categories":null,"content":"解答 def numSpecialEquivGroups(self, A: List[str]) -\u003e int: return len(set(''.join(sorted(a[::2])+sorted(a[1::2])) for a in A)) 40 ms ","date":"2018-08-26","objectID":"/leetcode/0893/:3:0","tags":null,"title":"0893：特殊等价字符串组（★）","uri":"/leetcode/0893/"},{"categories":null,"content":" 力扣第 98 场周赛第 3 题 ","date":"2018-08-19","objectID":"/leetcode/0889/:0:0","tags":null,"title":"0889：根据前序和后序遍历构造二叉树（★）","uri":"/leetcode/0889/"},{"categories":null,"content":"题目 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。 如果存在多个答案，您可以返回其中 任何 一个。 示例 1： 输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1] 输出：[1,2,3,4,5,6,7] 示例 2: 输入: preorder = [1], postorder = [1] 输出: [1] 提示： 1 \u003c= preorder.length \u003c= 30 1 \u003c= preorder","date":"2018-08-19","objectID":"/leetcode/0889/:1:0","tags":null,"title":"0889：根据前序和后序遍历构造二叉树（★）","uri":"/leetcode/0889/"},{"categories":null,"content":"分析 和 0105 类似的思路。pre[0] 和 pos[-1] 是根节点，pre[1] 有两种情况： 存在左子树，pre[1] 代表左子树 不存在左子树，pre[1] 代表右子树 这里有个巧妙的想法。将右子树所有节点移到左子树，二叉树的前序和后序遍历不变。因此可以令 pre[1] 代表左子树。 在 post 中找到 pre[1] 的位置 i，那么 post[:i+1]、post[i+1:-1] 分别代表左子树、右子树。 对应的 pre[1:i+2]、pre[i+2:] 分别代表左子树、右子树。即可递归。 ","date":"2018-08-19","objectID":"/leetcode/0889/:2:0","tags":null,"title":"0889：根据前序和后序遍历构造二叉树（★）","uri":"/leetcode/0889/"},{"categories":null,"content":"解答 def constructFromPrePost(self, pre: List[int], post: List[int]) -\u003e TreeNode: if not pre: return None if len(pre) == 1: return TreeNode(pre[0]) i = post.index(pre[1]) return TreeNode(pre[0], self.constructFromPrePost(pre[1:i+2], post[:i+1]), self.constructFromPrePost(pre[i+2:], post[i+1:-1])) 60 m","date":"2018-08-19","objectID":"/leetcode/0889/:3:0","tags":null,"title":"0889：根据前序和后序遍历构造二叉树（★）","uri":"/leetcode/0889/"},{"categories":null,"content":" 力扣第 96 场周赛第 4 题 ","date":"2018-08-05","objectID":"/leetcode/0882/:0:0","tags":null,"title":"0882：细分图中的可到达节点（★★★）","uri":"/leetcode/0882/"},{"categories":null,"content":"题目 给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。 图用由边组成的二维数组 edges 表示，其中 edges[i] = [ui, vi, cnti] 表示原始图中节点 ui 和 vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti == 0 表示边不可细分。 要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti 个新节点。新节点为 x1, x2, ..., xcnti ，新边为 [ui, x1], [x1, x2], [x2,","date":"2018-08-05","objectID":"/leetcode/0882/:1:0","tags":null,"title":"0882：细分图中的可到达节点（★★★）","uri":"/leetcode/0882/"},{"categories":null,"content":"分析 将 cnt+1 条新边看作是原边的权重，那么可以用 dijkstra 计算出每个原节点到 0 的距离。 原节点距离不超过 maxMoves 即可倒达，新的细分节点则可以根据最近的原节点来判断。 ","date":"2018-08-05","objectID":"/leetcode/0882/:2:0","tags":null,"title":"0882：细分图中的可到达节点（★★★）","uri":"/leetcode/0882/"},{"categories":null,"content":"解答 def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -\u003e int: nxt = defaultdict(list) for u, v, cnt in edges: nxt[u].append((v, cnt+1)) nxt[v].append((u, cnt+1)) d, pq = defaultdict(lambda: float('inf')), [(0, 0)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, ","date":"2018-08-05","objectID":"/leetcode/0882/:3:0","tags":null,"title":"0882：细分图中的可到达节点（★★★）","uri":"/leetcode/0882/"},{"categories":null,"content":" 力扣第 96 场周赛第 3 题 ","date":"2018-08-05","objectID":"/leetcode/0880/:0:0","tags":null,"title":"0880：索引处的解码字符串（★★）","uri":"/leetcode/0880/"},{"categories":null,"content":"题目 给定一个编码字符串 S。请你找出 解码字符串 并将其写入磁带。解码时，从编码字符串中 每次读取一个字符 ，并采取以下步骤： 如果所读的字符是字母，则将该字母写在磁带上。\r如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写 d-1 次。\r现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第 K 个字母。 示例 1： 输入：S = \"leet2code3\", K = 10\r输出：\"o\"\r解释：\r解码后的字符串为 \"leetleetcodeleetleetcodeleetleetcode\"。\r字符串中的第 10 个字母是 \"o\"。\r示例 2： 输入：S = \"ha","date":"2018-08-05","objectID":"/leetcode/0880/:1:0","tags":null,"title":"0880：索引处的解码字符串（★★）","uri":"/leetcode/0880/"},{"categories":null,"content":"分析 直接模拟会超时，因为解码后的字符串可能非常长，比如示例 3。 用 tmp 表示解码后的字符串。观察示例 3 发现，如果某一步 tmp 长度为 size \u003c K，遇到数字 d，长度变为 size * d \u003e K， 那么在 tmp * d 的第 K 位就是 tmp 的第 K % size 位。 因此遇到数字 d 时，可以不保存重复部分，重复部分的信息可以向前查到。 用栈保存解码字符串每一步的 size 和对应字母即可。比如示例 2： ha [(1, h), (2, a)] ha2 [(1, h), (2, a), (4, a)]\rha22 [(1, h), (2, a), (4, a), (","date":"2018-08-05","objectID":"/leetcode/0880/:2:0","tags":null,"title":"0880：索引处的解码字符串（★★）","uri":"/leetcode/0880/"},{"categories":null,"content":"解答 def decodeAtIndex(self, S: str, K: int) -\u003e str: stack, size = [], 0 for char in S: size = size * int(char) if char.isdigit() else size + 1 stack.append((size, stack[-1][1] if char.isdigit() else char)) while K % stack[-1][0]: K %= stack.pop()[0] return stack[-1][1] 40 ms ","date":"2018-08-05","objectID":"/leetcode/0880/:3:0","tags":null,"title":"0880：索引处的解码字符串（★★）","uri":"/leetcode/0880/"},{"categories":null,"content":" 力扣第 95 场周赛第 2 题 ","date":"2018-07-29","objectID":"/leetcode/0877/:0:0","tags":null,"title":"0877：石子游戏（★）","uri":"/leetcode/0877/"},{"categories":null,"content":"题目 Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。 Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。 示例 1： 输入：piles = [5,3,4,5] 输出：tr","date":"2018-07-29","objectID":"/leetcode/0877/:1:0","tags":null,"title":"0877：石子游戏（★）","uri":"/leetcode/0877/"},{"categories":null,"content":"分析 ","date":"2018-07-29","objectID":"/leetcode/0877/:2:0","tags":null,"title":"0877：石子游戏（★）","uri":"/leetcode/0877/"},{"categories":null,"content":"#1 本题是 0486 的子问题，可以直接套用代码： def stoneGame(self, piles: List[int]) -\u003e bool: n = len(piles) dp = [0]*(n+1) for i in range(n-1, -1, -1): for j in range(i+1, n+1): dp[j] = max(piles[i]-dp[j], piles[j-1]-dp[j-1]) return dp[-1] \u003e= 0 236 ms ","date":"2018-07-29","objectID":"/leetcode/0877/:2:1","tags":null,"title":"0877：石子游戏（★）","uri":"/leetcode/0877/"},{"categories":null,"content":"#2 还有个巧妙的想法，将数组中位置为偶数的标记为白色，位置为奇数的标记为黑色，那么先手能保证拿到所有白色或所有黑色。 因此先手必胜，拿和较大的颜色即可。 ","date":"2018-07-29","objectID":"/leetcode/0877/:2:2","tags":null,"title":"0877：石子游戏（★）","uri":"/leetcode/0877/"},{"categories":null,"content":"解答 def stoneGame(self, piles: List[int]) -\u003e bool: return True 36 ms ","date":"2018-07-29","objectID":"/leetcode/0877/:3:0","tags":null,"title":"0877：石子游戏（★）","uri":"/leetcode/0877/"},{"categories":null,"content":" 力扣第 95 场周赛第 1 题 ","date":"2018-07-29","objectID":"/leetcode/0876/:0:0","tags":null,"title":"0876：链表的中间结点","uri":"/leetcode/0876/"},{"categories":null,"content":"题目 给你单链表的头结点 head ，请你找出并返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：head = [1,2,3,4,5]\r输出：[3,4,5]\r解释：链表只有一个中间结点，值为 3 。\r示例 2： 输入：head = [1,2,3,4,5,6]\r输出：[4,5,6]\r解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\r提示： 链表的结点数范围是 [1, 100]\r1 \u003c= Node.val \u003c= 100\r","date":"2018-07-29","objectID":"/leetcode/0876/:1:0","tags":null,"title":"0876：链表的中间结点","uri":"/leetcode/0876/"},{"categories":null,"content":"分析 ","date":"2018-07-29","objectID":"/leetcode/0876/:2:0","tags":null,"title":"0876：链表的中间结点","uri":"/leetcode/0876/"},{"categories":null,"content":"#1 最简单的就是先遍历得到链表长度 n，然后从序号 n//2 的节点即为所求。 def middleNode(self, head: ListNode) -\u003e ListNode: n, p = 0, head while p: p = p.next n += 1 for _ in range(n//2): head = head.next return head 40 ms ","date":"2018-07-29","objectID":"/leetcode/0876/:2:1","tags":null,"title":"0876：链表的中间结点","uri":"/leetcode/0876/"},{"categories":null,"content":"#2 还有个巧妙的想法，可以用两个指针同时从 head 出发，每轮一个指针移动两步，另一个指针移动一步。 当快指针越界时，慢指针即为所求。 这就是链表中经典的快慢指针法。 ","date":"2018-07-29","objectID":"/leetcode/0876/:2:2","tags":null,"title":"0876：链表的中间结点","uri":"/leetcode/0876/"},{"categories":null,"content":"解答 def middleNode(self, head: ListNode) -\u003e ListNode: slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next return slow 36 ms ","date":"2018-07-29","objectID":"/leetcode/0876/:3:0","tags":null,"title":"0876：链表的中间结点","uri":"/leetcode/0876/"},{"categories":null,"content":" 力扣第 94 场周赛第 1 题 ","date":"2018-07-22","objectID":"/leetcode/0872/:0:0","tags":null,"title":"0872：叶子相似的树","uri":"/leetcode/0872/"},{"categories":null,"content":"题目 请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。 举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。 如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。 如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。 示例 1： 输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\r输出：true\r示例 2： ","date":"2018-07-22","objectID":"/leetcode/0872/:1:0","tags":null,"title":"0872：叶子相似的树","uri":"/leetcode/0872/"},{"categories":null,"content":"分析 前序遍历中保存叶子的值即得到叶值序列。 ","date":"2018-07-22","objectID":"/leetcode/0872/:2:0","tags":null,"title":"0872：叶子相似的树","uri":"/leetcode/0872/"},{"categories":null,"content":"解答 def leafSimilar(self, root1: TreeNode, root2: TreeNode) -\u003e bool: def leaf(root): res, stack = [], [root] while stack: node = stack.pop() if node: if not node.left and not node.right: res.append(node.val) stack.extend([node.right, node.left]) return res return leaf(root1) == leaf(root2) 48 ms ","date":"2018-07-22","objectID":"/leetcode/0872/:3:0","tags":null,"title":"0872：叶子相似的树","uri":"/leetcode/0872/"},{"categories":null,"content":" 力扣第 93 场周赛第 4 题 ","date":"2018-07-15","objectID":"/leetcode/0871/:0:0","tags":null,"title":"0871：最低加油次数（★★）","uri":"/leetcode/0871/"},{"categories":null,"content":"题目 汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。 沿途有加油站，用数组 stations 表示。其中 stations[i] = [positioni, fueli] 表示第 i 个加油站位于出发位置东面 positioni 英里处，并且有 fueli 升汽油。 假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。 注意：如果汽车到达加油站时剩余燃料为 ","date":"2018-07-15","objectID":"/leetcode/0871/:1:0","tags":null,"title":"0871：最低加油次数（★★）","uri":"/leetcode/0871/"},{"categories":null,"content":"分析 每轮在能用的加油站中选汽油最多的，然后更新能到达的位置，直到达到 target 为止。 具体实现时，可以用大顶堆维护能到达但还没有用过的加油站，若还没到 target 但堆空就返回 -1。 ","date":"2018-07-15","objectID":"/leetcode/0871/:2:0","tags":null,"title":"0871：最低加油次数（★★）","uri":"/leetcode/0871/"},{"categories":null,"content":"解答 def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -\u003e int: res, cur, pq, stations = 0, startFuel, [], deque(stations) while cur \u003c target: while stations and stations[0][0] \u003c= cur: heappush(pq, -stations.popleft()[1]) if not pq: return -1 cur -= heappop(pq) res += 1 r","date":"2018-07-15","objectID":"/leetcode/0871/:3:0","tags":null,"title":"0871：最低加油次数（★★）","uri":"/leetcode/0871/"},{"categories":null,"content":"以1990年代为背景，描述热衷于格斗游戏的小学生“矢口春雄”，某次在电玩店与女主角“大野晶”因互相较量\n《街头霸王2》而认识。故事中除了街机文化之外，也有恋爱要素。由于身份上的差距，毫无交集的春雄和晶，偶然发现有着共同兴趣，\n原本只是互相切磋技术的好对手，不知不觉间，两人的关系开始有了变化……","date":"2018-07-13","objectID":"/anime/hi_score_girl/","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"简介 以1990年代为背景，描述热衷于格斗游戏的小学生“矢口春雄”，某次在电玩店与女主角“大野晶”因互相较量 《街头霸王2》而认识。故事中除了街机文化之外，也有恋爱要素。由于身份上的差距，毫无交集的春雄和晶，偶然发现有着共同兴趣， 原本只是互相切磋技术的好对手，不知不觉间，两人的关系开始有了变化…… 制作人员： 原作：押切莲介 导演：山川吉树 脚本：浦畑达彦、石野敦夫、富田赖子 分镜：松井仁之、佐山圣子 演出：樱美胜志 ","date":"2018-07-13","objectID":"/anime/hi_score_girl/:1:0","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 矢口春雄 矢口 春雄、やぐち はるお、Yaguchi Haruo 男 天﨑滉平 2 大野晶 大野 晶、おおの あきら、Oono Akira 女 鈴代紗弓 3 日高小春 日高 小春、ひだか こはる、Hidaka Koharu 女 広瀬ゆうき 4 大野真 Ono Makoto 女 赤﨑千夏 5 宫尾光太郎 Kataro Miyao 男 興津和幸 6 土井玄太 Genta Ooi 男 山下大輝 7 业田萌美 Goda Moemi 女 伊藤静 8 爷爷 Ziiya 男 チョー ","date":"2018-07-13","objectID":"/anime/hi_score_girl/:2:0","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 高分少女 2018-07-13 12 樱花 2 高分少女 EXTRA STAGE 2019-03-20 3 樱花 3 高分少女 第二季 2019-10-25 9 bilibili ","date":"2018-07-13","objectID":"/anime/hi_score_girl/:3:0","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"MAD ","date":"2018-07-13","objectID":"/anime/hi_score_girl/:4:0","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"“舞台少女”——那是以未来的舞台女演员为目标，光芒四溢的少女们。\n\n某天，她们收到了一封邮件。“请去取得吧　你所希望的那颗星”为了摘取闪耀的星星，而聚集于选拔会场的9名舞台少女。\n\n追求光芒的心意、执着、命运——在舞台上交错。\n\n现在，正是拉开Revue的序幕之时。","date":"2018-07-12","objectID":"/anime/revue_starlight/","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":"简介 “舞台少女”——那是以未来的舞台女演员为目标，光芒四溢的少女们。 某天，她们收到了一封邮件。“请去取得吧　你所希望的那颗星”为了摘取闪耀的星星，而聚集于选拔会场的9名舞台少女。 追求光芒的心意、执着、命运——在舞台上交错。 现在，正是拉开Revue的序幕之时。 制作人员： 原作：Bushiroad、KINEMA CITRUS 导演：古川知宏 脚本：樋口达人 分镜：光田史亮、小出卓史、佐伯昭志、黑田结花 ","date":"2018-07-12","objectID":"/anime/revue_starlight/:1:0","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 爱城华恋 愛城 華恋、あいじょう かれん、Karen Aijo 女 小山百代 2 神乐光 神楽 ひかり、かぐら ひかり、Hikari Kagura 女 三森すずこ 3 天堂真矢 天堂 真矢、てんどう まや、Maya Tendo 女 富田麻帆 4 星见纯那 星見 純那、ほしみ じゅんな、Junna Hoshimi 女 佐藤日向 5 露崎真昼 露崎 まひる、つゆざき まひる、Mahiru Tsuyuzaki 女 岩田陽葵 6 大场奈奈 大場 なな、だいば なな、Daiba Nana、ばなな，バナナ 女 小泉萌香 7 西条克洛迪娜 西條 クロディーヌ、さいじょう ","date":"2018-07-12","objectID":"/anime/revue_starlight/:2:0","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 少女☆歌剧 Revue Starlight 2018-07-12 12 bilibili 2 剧场版 少女☆歌剧 Revue Starlight 2021-06-04 1 樱花 ","date":"2018-07-12","objectID":"/anime/revue_starlight/:3:0","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":"MAD ","date":"2018-07-12","objectID":"/anime/revue_starlight/:4:0","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":" 力扣第 92 场周赛第 3 题 ","date":"2018-07-08","objectID":"/leetcode/0866/:0:0","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"题目 求出大于或等于 N 的最小回文素数。 回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是素数。 例如，2，3，5，7，11 以及 13 是素数。 回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是回文数。 例如，12321 是回文数。 示例 1： 输入：6 输出：7 示例 2： 输入：8 输出：11 示例 3： 输入：13 输出：101 提示： 1 \u003c= N \u003c= 10^8 答案肯定存在，且小于 2 * 10^8。 ","date":"2018-07-08","objectID":"/leetcode/0866/:1:0","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"分析 ","date":"2018-07-08","objectID":"/leetcode/0866/:2:0","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"#1 有点类似 0564 ，可以基于某数并镜像的方法得到回文数，例如 10 镜像后得到两个回文数 101、1001。 而长度为 L 的回文数也必然可以基于前 (L+1)//2 个数字镜像得到，把它称作 L 的回文根。 因此，只要遍历回文根从 1 到 $10^5$，就可以得到所有从 1 到 $10^9$ 的回文数。 注意遍历顺序和两种镜像方式的顺序，即可从小到大得到回文数。具体为： 先从 1 位回文根通过两种镜像方式依次得到 1 位、2 位回文数 再从 2 位回文根通过两种镜像方式依次得到 3 位、4 位回文数 依此类推 再判断是否 \u003e= N 且是质数即可。 def primePalindrom","date":"2018-07-08","objectID":"/leetcode/0866/:2:1","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"#2 还有个巧妙的优化。可以证明偶数位回文数必然是 11 的倍数。 首先证明 一个数是 11 的倍数 等价于 奇位数字之和与偶位数字之和的差是 11 的倍数。 设一个数 x 表示为 $\\overline{…a_5 a_4 a_3 a_2 a_1}$，那么： $$x = a_1 + 10 * a_2 + 100 * a_3 + 1000 * a_4 + 10000 * a_5 + … $$ $$x = a_1 + (11-1) * a_2 + (99+1) * a_3 + (1001-1) * a_4 + (9999+1) * a_5 + … $$ $$x = (a_1 - a_2 + a_3 ","date":"2018-07-08","objectID":"/leetcode/0866/:2:2","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"解答 def primePalindrome(self, N): def is_prime(n): return n \u003e= 2 and all(n%i for i in range(2, int(n**0.5) + 1)) if 8\u003c=N\u003c=11: return 11 L = len(str(N)) h = int(str(N)[:(L+1)//2]) for half in range(h, 10**6): n = int(str(half) + str(half)[-2::-1]) if n \u003e= N and is_prime(n): return n 56 ms ","date":"2018-07-08","objectID":"/leetcode/0866/:3:0","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"生在日本长在日本、完全不会说英语的金发美少女·奥莉薇，性格认真、知性洋溢、完全不会说英语的短发眼镜娘·香纯，以及虽然性格开朗却无法成为现充的下双马尾少女·华子，三名初中女生创造出来的是“游戏研究会”！？超级可爱有趣、令人捧腹绝倒的JC女生喜剧现在开幕！","date":"2018-07-08","objectID":"/anime/asobi_asobase/","tags":null,"title":"来玩游戏吧","uri":"/anime/asobi_asobase/"},{"categories":null,"content":"简介 生在日本长在日本、完全不会说英语的金发美少女·奥莉薇，性格认真、知性洋溢、完全不会说英语的短发眼镜娘·香纯，以及虽然性格开朗却无法成为现充的下双马尾少女·华子，三名初中女生创造出来的是“游戏研究会”！？超级可爱有趣、令人捧腹绝倒的JC女生喜剧现在开幕！ 制作人员： 原作：凉川铃 导演：岸诚二 脚本：柿原优子 分镜：濑村俊一郎、木野目优 演出：滨田将太、铃木芳成、大矢雄嗣、真野玲 ","date":"2018-07-08","objectID":"/anime/asobi_asobase/:1:0","tags":null,"title":"来玩游戏吧","uri":"/anime/asobi_asobase/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 本田华子 ほんだ はなこ、Honda Hanako 女 木野日菜 2 奥莉薇 Olivia 女 長江里加 3 野村香纯 のむら かすみ、Nomura Kasumi 女 小原好美 4 前多 まえだ、Maeda 男 置鮎龍太郎 5 学生会长 女 井上ほの花 6 冈露 おか るう、Oka Ruu、岡さん 女 金澤まい 7 阿格里帕 间桐安栗、間桐 あぐり、まとう あぐり、Matō Aguri 女 戸田めぐみ 8 青空鸫 あおぞら つぐみ、Aozora Tsugumi 悠木碧 ","date":"2018-07-08","objectID":"/anime/asobi_asobase/:2:0","tags":null,"title":"来玩游戏吧","uri":"/anime/asobi_asobase/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 来玩游戏吧 2018-07-08 12 樱花 ","date":"2018-07-08","objectID":"/anime/asobi_asobase/:3:0","tags":null,"title":"来玩游戏吧","uri":"/anime/asobi_asobase/"},{"categories":null,"content":" 力扣第 91 场周赛第 4 题 ","date":"2018-07-01","objectID":"/leetcode/0862/:0:0","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。 子数组 是数组中 连续 的一部分。 示例 1： 输入：nums = [1], k = 1\r输出：1\r示例 2： 输入：nums = [1,2], k = 4\r输出：-1\r示例 3： 输入：nums = [2,-1,2], k = 3\r输出：3\r提示： 1 \u003c= nums.length \u003c= 105\r-105 \u003c= nums[i] \u003c= 105\r1 \u003c= k \u003c= 109\r","date":"2018-07-01","objectID":"/leetcode/0862/:1:0","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"分析 ","date":"2018-07-01","objectID":"/leetcode/0862/:2:0","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"#1 涉及到子数组的和，首先想到前缀和。得到前缀和数组 pre 后，问题转为： 求最小的 j-i 使得 pre[i]\u003c=pre[j]-K。 暴力法就是遍历位置 j，在 pre[:j] 中找最大的满足要求的 i。 注意到如果 x \u003c y 且 pre[x] \u003e= pre[y]，那么 y 比 x 更优，在后面的遍历中都可以排除 x。 因此可以维护一个严格递增的栈 stack，保存有用的位置和值。 然后就可以二分查找最大的 i 了。 def shortestSubarray(self, nums: List[int], k: int) -\u003e int: pre = list(accumulate([0]","date":"2018-07-01","objectID":"/leetcode/0862/:2:1","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"#2 还有个巧妙的想法。对于栈中的 i，当遍历到第一个 j 使得 pre[i]\u003c=pre[j]-K，那么以 i 开头的最短子数组就是 pre[i:j+1]，可以弹出 i 并更新结果。 因此，可以维护一个单调队列。 ","date":"2018-07-01","objectID":"/leetcode/0862/:2:2","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"解答 def shortestSubarray(self, nums: List[int], k: int) -\u003e int: pre = list(accumulate([0]+nums)) res, queue = float('inf'), deque() for j,x in enumerate(pre): while queue and queue[-1][0]\u003e=x: queue.pop() while queue and queue[0][0]\u003c=x-k: res = min(res, j-queue.popleft()[1]) queue.append((x, j)) retur","date":"2018-07-01","objectID":"/leetcode/0862/:3:0","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":" 力扣第 90 场周赛第 4 题 ","date":"2018-06-24","objectID":"/leetcode/0857/:0:0","tags":null,"title":"0857：雇佣 K 名工人的最低成本（★★★）","uri":"/leetcode/0857/"},{"categories":null,"content":"题目 有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。 现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资： 对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。\r工资组中的每名工人至少应当得到他们的最低期望工资。\r给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。在实际答案的 10-5 以内的答案将被接受。。 示例 1： 输入： quality = [10,20,5], wage = [","date":"2018-06-24","objectID":"/leetcode/0857/:1:0","tags":null,"title":"0857：雇佣 K 名工人的最低成本（★★★）","uri":"/leetcode/0857/"},{"categories":null,"content":"分析 ","date":"2018-06-24","objectID":"/leetcode/0857/:2:0","tags":null,"title":"0857：雇佣 K 名工人的最低成本（★★★）","uri":"/leetcode/0857/"},{"categories":null,"content":"#1 定义期望单价 = 工人期望工资 / 工作质量，实际单价 = 工人实际工资 / 工作质量。对于任意 K 名工人，按照规则应该有： K 名工人的 实际单价 相等\r每名工人的 实际单价 大于等于 期望单价\r因此实际单价最小为 ratio=max(每名工人的期望单价)，这 K 名工人最少花费 ratio * 工作质量总和 显然遍历 K 名工人的集合太费时间，有个巧妙的想法是最终 ratio 必然是某个工人的期望单价，所以可以遍历 ratio。 而 ratio 固定时，显然应该找期望单价小于等于 ratio 且工作质量最小的工人，使花费最少。 可以先将工人按 ratio 排序，遍历时从前面找工作质","date":"2018-06-24","objectID":"/leetcode/0857/:2:1","tags":null,"title":"0857：雇佣 K 名工人的最低成本（★★★）","uri":"/leetcode/0857/"},{"categories":null,"content":"#2 显然每次重新求工作质量最小的 K 个工人有很多重复计算，可以用 list 或者大顶堆来维护。 还可以添加一个变量 s 维护元素之和。 ","date":"2018-06-24","objectID":"/leetcode/0857/:2:2","tags":null,"title":"0857：雇佣 K 名工人的最低成本（★★★）","uri":"/leetcode/0857/"},{"categories":null,"content":"解答 def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -\u003e float: A = sorted((w/q, q) for q, w in zip(quality, wage)) res, pq, s = float('inf'), [], 0 for i in range(len(A)): heappush(pq, -A[i][1]) s += A[i][1] if i \u003e= K: s += heappop(pq) if i \u003e= K-1: res = min(res, A[i][0] * ","date":"2018-06-24","objectID":"/leetcode/0857/:3:0","tags":null,"title":"0857：雇佣 K 名工人的最低成本（★★★）","uri":"/leetcode/0857/"},{"categories":null,"content":" 力扣第 90 场周赛第 2 题 ","date":"2018-06-24","objectID":"/leetcode/0856/:0:0","tags":null,"title":"0856：括号的分数（★）","uri":"/leetcode/0856/"},{"categories":null,"content":"题目 给定一个平衡括号字符串 S，按下述规则计算该字符串的分数： () 得 1 分。\rAB 得 A + B 分，其中 A 和 B 是平衡括号字符串。\r(A) 得 2 * A 分，其中 A 是平衡括号字符串。\r示例 1： 输入： \"()\"\r输出： 1\r示例 2： 输入： \"(())\"\r输出： 2\r示例 3： 输入： \"()()\"\r输出： 2\r示例 4： 输入： \"(()(()))\"\r输出： 6\r提示： S 是平衡括号字符串，且只含有 ( 和 ) 。\r2 \u003c= S.length \u003c= 50\r","date":"2018-06-24","objectID":"/leetcode/0856/:1:0","tags":null,"title":"0856：括号的分数（★）","uri":"/leetcode/0856/"},{"categories":null,"content":"分析 显然 s 递归地等于子串的和或 2 倍。可以用栈模拟这个过程，一趟解决。 遇到 ‘(’ 时入栈 0，代表下一层的初始分数，遇到 ‘)’ 出栈当前层的分数添加到上一层即可。 注意按规则，若当前层是最简单的 ‘()’，应该为 1 分而不是 0 分。 ","date":"2018-06-24","objectID":"/leetcode/0856/:2:0","tags":null,"title":"0856：括号的分数（★）","uri":"/leetcode/0856/"},{"categories":null,"content":"解答 def scoreOfParentheses(self, s: str) -\u003e int: stack = [0] for char in s: if char == '(': stack.append(0) else: x = stack.pop() stack[-1] += max(2*x, 1) return stack[0] 24 ms ","date":"2018-06-24","objectID":"/leetcode/0856/:3:0","tags":null,"title":"0856：括号的分数（★）","uri":"/leetcode/0856/"},{"categories":null,"content":" 力扣第 89 场周赛第 2 题 ","date":"2018-06-17","objectID":"/leetcode/0853/:0:0","tags":null,"title":"0853：车队（★）","uri":"/leetcode/0853/"},{"categories":null,"content":"题目 在一条单行道上，有 n 辆车开往同一目的地。目的地是几英里以外的 target 。 给定两个整数数组 position 和 speed ，长度都是 n ，其中 position[i] 是第 i 辆车的位置， speed[i] 是第 i 辆车的速度(单位是英里/小时)。 一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车 以相同的速度 紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。 车队 是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。 即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。 返","date":"2018-06-17","objectID":"/leetcode/0853/:1:0","tags":null,"title":"0853：车队（★）","uri":"/leetcode/0853/"},{"categories":null,"content":"分析 令 t[i] 代表如果车 i 速度不变到达目的地的时间，T[i] 代表车 i 实际到达目的地的时间。 显然若车 i 在车 j 前面，且 T[i] \u003c t[j]，则车 j 无法追上车 i，最终 T[j] = t[j]。 反之，若 T[i] \u003e= t[j]，则车 j 能追上车 i，最终 T[j] = T[i]。 另外，一开始在最前面的车 x，显然有 T[x] = t[x]。 因此，将车按初始位置从大到小排序，即可递推求出 T[i]，从而得到车队个数。 ","date":"2018-06-17","objectID":"/leetcode/0853/:2:0","tags":null,"title":"0853：车队（★）","uri":"/leetcode/0853/"},{"categories":null,"content":"解答 def carFleet(self, target: int, position: List[int], speed: List[int]) -\u003e int: res, prev = 0, (target+1, 1) for pos, sp in sorted(zip(position, speed), reverse=True): if (target-pos)*prev[1] \u003e (target-prev[0])*sp: res += 1 prev = (pos, sp) return res 196 ms ","date":"2018-06-17","objectID":"/leetcode/0853/:3:0","tags":null,"title":"0853：车队（★）","uri":"/leetcode/0853/"},{"categories":null,"content":" 力扣第 88 场周赛第 4 题 ","date":"2018-06-10","objectID":"/leetcode/0850/:0:0","tags":null,"title":"0850：矩形面积 II（★★★）","uri":"/leetcode/0850/"},{"categories":null,"content":"题目 我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle[i] = [xi1, yi1, xi2, yi2]，表示第 i 个矩形的坐标， (xi1, yi1) 是该矩形 左下角 的坐标， (xi2, yi2) 是该矩形 右上角 的坐标。 计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。 返回 总面积 。因为答案可能太大，返回 109 + 7 的 模 。 示例 1： 输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\r输出：6\r解释：如图所示，三个矩形覆盖","date":"2018-06-10","objectID":"/leetcode/0850/:1:0","tags":null,"title":"0850：矩形面积 II（★★★）","uri":"/leetcode/0850/"},{"categories":null,"content":"分析 有点类似 0218，不过遍历坐标 x 时，要维护的不是高度集合，而是区间集合。 每一轮根据当前横坐标 cur_x 、上一轮横坐标 prev_x，上一轮区间集合覆盖的长度 prev_h， 即可计算出 cur_x 和 prev_x 之间覆盖的面积。然后更新 prev_x 和 prev_h 即可。 ","date":"2018-06-10","objectID":"/leetcode/0850/:2:0","tags":null,"title":"0850：矩形面积 II（★★★）","uri":"/leetcode/0850/"},{"categories":null,"content":"解答 def rectangleArea(self, rectangles: List[List[int]]) -\u003e int: def cal(A): res, end = 0, 0 for s, e in A: res += max(end, e) - max(s, end) end = max(end, e) return res from sortedcontainers import SortedList d = defaultdict(list) for x1, y1, x2, y2 in rectangles: d[x1].append((y1, y2, 1)) d[x2].app","date":"2018-06-10","objectID":"/leetcode/0850/:3:0","tags":null,"title":"0850：矩形面积 II（★★★）","uri":"/leetcode/0850/"},{"categories":null,"content":" 力扣第 88 场周赛第 3 题 ","date":"2018-06-10","objectID":"/leetcode/0851/:0:0","tags":null,"title":"0851：喧闹和富有（★）","uri":"/leetcode/0851/"},{"categories":null,"content":"题目 有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 \"person x \"。 给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自洽（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的","date":"2018-06-10","objectID":"/leetcode/0851/:1:0","tags":null,"title":"0851：喧闹和富有（★）","uri":"/leetcode/0851/"},{"categories":null,"content":"分析 将人看作顶点，richer 看作边，显然是一个有向无环图，因此可以直接递归。 ","date":"2018-06-10","objectID":"/leetcode/0851/:2:0","tags":null,"title":"0851：喧闹和富有（★）","uri":"/leetcode/0851/"},{"categories":null,"content":"解答 def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -\u003e List[int]: @lru_cache(None) def dfs(u): return min([dfs(v) for v in nxt[u]]+[u], key=quiet.__getitem__) nxt = defaultdict(list) for v, u in richer: nxt[u].append(v) return [dfs(i) for i in range(len(quiet))] 72 ms ","date":"2018-06-10","objectID":"/leetcode/0851/:3:0","tags":null,"title":"0851：喧闹和富有（★）","uri":"/leetcode/0851/"},{"categories":null,"content":" 力扣第 87 场周赛第 4 题 ","date":"2018-06-03","objectID":"/leetcode/0847/:0:0","tags":null,"title":"0847：访问所有节点的最短路径（★★★）","uri":"/leetcode/0847/"},{"categories":null,"content":"题目 存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。 给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。 返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。 示例 1： 输入：graph = [[1,2,3],[0],[0],[0]]\r输出：4\r解释：一种可能的路径为 [1,0,2,0,3]\r示例 2： 输入：graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\r输出：4\r解释：一种可能的路径为 [0,1,4,2,3]\r","date":"2018-06-03","objectID":"/leetcode/0847/:1:0","tags":null,"title":"0847：访问所有节点的最短路径（★★★）","uri":"/leetcode/0847/"},{"categories":null,"content":"分析 遍历时关心的状态其实是 (节点 u, 访问过的节点集合 s) 二元组。那么类似 0787，可以构造新图。 对于原边 \u003cu, v\u003e，从 (u, s) 到 (u, s|{v}) 连有向边，权重 1。 问题转为在新图中求任意 (u, {u}) 到任意 (v, 所有节点集合) 的最短路。 因为边的权重相等，所以可以用 bfs 解决。具体实现时不需要真的构造出新图。 注意 set 类型不能作为哈希的键，因此考虑用状态压缩来表示节点集合。 ","date":"2018-06-03","objectID":"/leetcode/0847/:2:0","tags":null,"title":"0847：访问所有节点的最短路径（★★★）","uri":"/leetcode/0847/"},{"categories":null,"content":"解答 def shortestPathLength(self, graph: List[List[int]]) -\u003e int: n = len(graph) queue = deque([(0, u, 1\u003c\u003cu) for u in range(n)]) vis = {(u, 1\u003c\u003cu) for u in range(n)} while queue: w, u, s = queue.popleft() if s == (1\u003c\u003cn)-1: return w for v in graph[u]: s2 = s|(1\u003c\u003cv) if (v, s2) not in vis: vis.add((v, s2)","date":"2018-06-03","objectID":"/leetcode/0847/:3:0","tags":null,"title":"0847：访问所有节点的最短路径（★★★）","uri":"/leetcode/0847/"},{"categories":null,"content":" 力扣第 87 场周赛第 1 题 ","date":"2018-06-03","objectID":"/leetcode/0844/:0:0","tags":null,"title":"0844：比较含退格的字符串","uri":"/leetcode/0844/"},{"categories":null,"content":"题目 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。 注意：如果对空文本输入退格字符，文本继续为空。 示例 1： 输入：s = \"ab#c\", t = \"ad#c\"\r输出：true\r解释：s 和 t 都会变成 \"ac\"。\r示例 2： 输入：s = \"ab##\", t = \"c#d#\"\r输出：true\r解释：s 和 t 都会变成 \"\"。\r示例 3： 输入：s = \"a#c\", t = \"b\"\r输出：false\r解释：s 会变成 \"c\"，但 t 仍然是 \"b\"。\r提示： 1 \u003c= s.length, t.length \u003c= 2","date":"2018-06-03","objectID":"/leetcode/0844/:1:0","tags":null,"title":"0844：比较含退格的字符串","uri":"/leetcode/0844/"},{"categories":null,"content":"分析 ","date":"2018-06-03","objectID":"/leetcode/0844/:2:0","tags":null,"title":"0844：比较含退格的字符串","uri":"/leetcode/0844/"},{"categories":null,"content":"#1 最简单的就是用栈模拟，然后比较即可。 def backspaceCompare(self, s: str, t: str) -\u003e bool: def help(s): stack = [] for char in s: if char != '#': stack.append(char) elif stack: stack.pop() return stack return help(s) == help(t) 52 ms ","date":"2018-06-03","objectID":"/leetcode/0844/:2:1","tags":null,"title":"0844：比较含退格的字符串","uri":"/leetcode/0844/"},{"categories":null,"content":"#2 题目要求空间复杂度 O(1)。考虑用双指针反向遍历，遇到 ‘#’ 时用 cnt 记录，并跳过相应个数的普通字符，找到下一个有效字符，再进行比较即可。 具体实现时，用辅助函数 nxt(i, s) 表示从当前的有效字符位置 i，反向遍历找到 s 中的下一个有效字符位置。那么初始令 i=len(s), j=len(t), 然后不断调用 nxt(i, s) 和 nxt(j, t) 并比较即可。 ","date":"2018-06-03","objectID":"/leetcode/0844/:2:2","tags":null,"title":"0844：比较含退格的字符串","uri":"/leetcode/0844/"},{"categories":null,"content":"解答 def backspaceCompare(self, s: str, t: str) -\u003e bool: def nxt(i, s): i, cnt = i-1, 0 while i \u003e= 0: if s[i] != '#' and cnt == 0: break cnt += 1 if s[i] == '#' else -1 i -= 1 return i i, j = len(s), len(t) while i \u003e= 0 and j \u003e= 0: i, j = nxt(i, s), nxt(j, t) if not (i \u003e= 0 and j \u003e= 0 and s[i] == t[j]","date":"2018-06-03","objectID":"/leetcode/0844/:3:0","tags":null,"title":"0844：比较含退格的字符串","uri":"/leetcode/0844/"},{"categories":null,"content":" 力扣第 86 场周赛第 4 题 ","date":"2018-05-27","objectID":"/leetcode/0843/:0:0","tags":null,"title":"0843：猜猜这个单词（★★）","uri":"/leetcode/0843/"},{"categories":null,"content":"题目 给你一个由 不同 字符串组成的单词列表 words ，其中 words[i] 长度均为 6 。words 中的一个单词将被选作秘密单词 secret 。 另给你一个辅助对象 Master ，你可以调用 Master.guess(word) 来猜单词，其中参数 word 长度为 6 且必须是 words 中的字符串。 Master.guess(word) 将会返回如下结果： 如果 word 不是 words 中的字符串，返回 -1 ，或者\r一个整数，表示你所猜测的单词 word 与 秘密单词 secret 的准确匹配（值和位置同时匹配）的数目。\r每组测试用例都会包含一个参数 allowed","date":"2018-05-27","objectID":"/leetcode/0843/:1:0","tags":null,"title":"0843：猜猜这个单词（★★）","uri":"/leetcode/0843/"},{"categories":null,"content":"分析 ","date":"2018-05-27","objectID":"/leetcode/0843/:2:0","tags":null,"title":"0843：猜猜这个单词（★★）","uri":"/leetcode/0843/"},{"categories":null,"content":"#1 可以发现任何方法都不能保证在 10 次内一定猜出来，比如 [‘aaaaaa’, ‘bbbbbb’, … ‘zzzzzz’] 26 个单词的列表， 必须要猜 26 次才能保证猜中。 因此只考虑 match=guess(word) 是有用信息的情况。那么可以通过 match 缩小查找范围 words。 比如示例 1 中，若选择了单词 word=‘ccbazz’，那么可以根据 guess(word)=3， 更新 words 为与该单词匹配 3 项的单词列表 [‘acckzz’]。依此类推，直到猜中。 def findSecretWord(self, wordlist: List[str], m","date":"2018-05-27","objectID":"/leetcode/0843/:2:1","tags":null,"title":"0843：猜猜这个单词（★★）","uri":"/leetcode/0843/"},{"categories":null,"content":"#2 现在每次随机选单词，有时能 AC 有时不能。考虑能否去掉随机。 显然希望每一步得到的 words 范围更小，也就是选择 A 后更新得到的 words 长度最小。 但 match 是未知的，所以只能遍历 match 考虑最坏情形。 ","date":"2018-05-27","objectID":"/leetcode/0843/:2:2","tags":null,"title":"0843：猜猜这个单词（★★）","uri":"/leetcode/0843/"},{"categories":null,"content":"解答 def findSecretWord(self, wordlist: List[str], master: 'Master') -\u003e None: def cal(A): return max(sum(sum(a==b for a,b in zip(A, B))==i for B in words) for i in range(6)) words = set(wordlist) for _ in range(10): A = min(words, key=cal) match = master.guess(A) if match == 6: return words = [B for B","date":"2018-05-27","objectID":"/leetcode/0843/:3:0","tags":null,"title":"0843：猜猜这个单词（★★）","uri":"/leetcode/0843/"},{"categories":null,"content":" 力扣第 86 场周赛第 2 题 ","date":"2018-05-27","objectID":"/leetcode/0841/:0:0","tags":null,"title":"0841：钥匙和房间（★）","uri":"/leetcode/0841/"},{"categories":null,"content":"题目 有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。 当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。 给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。 示例 1： 输入：rooms = [[1],[2],[3],[]]\r输出：true\r解释：\r我们从 0 号房间开始，拿到钥匙 ","date":"2018-05-27","objectID":"/leetcode/0841/:1:0","tags":null,"title":"0841：钥匙和房间（★）","uri":"/leetcode/0841/"},{"categories":null,"content":"分析 房间看作顶点，钥匙看作有向边，问题转为：判断顶点 0 出发能否达到所有顶点。 顶点 0 开始遍历即可。 ","date":"2018-05-27","objectID":"/leetcode/0841/:2:0","tags":null,"title":"0841：钥匙和房间（★）","uri":"/leetcode/0841/"},{"categories":null,"content":"解答 def canVisitAllRooms(self, rooms: List[List[int]]) -\u003e bool: queue, vis = deque([0]), {0} while queue: u = queue.popleft() for v in rooms[u]: if v not in vis: vis.add(v) queue.append(v) return len(vis)==len(rooms) 16 ms ","date":"2018-05-27","objectID":"/leetcode/0841/:3:0","tags":null,"title":"0841：钥匙和房间（★）","uri":"/leetcode/0841/"},{"categories":null,"content":" 力扣第 85 场周赛第 4 题 ","date":"2018-05-20","objectID":"/leetcode/0839/:0:0","tags":null,"title":"0839：相似字符串组（★★）","uri":"/leetcode/0839/"},{"categories":null,"content":"题目 如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。 例如，\"tars\" 和 \"rats\" 是相似的 (交换 0 与 2 的位置)； \"rats\" 和 \"arts\" 也是相似的，但是 \"star\" 不与 \"tars\"，\"rats\"，或 \"arts\" 相似。 总之，它们通过相似性形成了两个关联组：{\"tars\", \"rats\", \"arts\"} 和 {\"star\"}。注意，\"tars\" 和 \"arts\" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个","date":"2018-05-20","objectID":"/leetcode/0839/:1:0","tags":null,"title":"0839：相似字符串组（★★）","uri":"/leetcode/0839/"},{"categories":null,"content":"分析 典型的并查集应用。将相似的字符串连通，分到一组，最后统计有多少组即可。 ","date":"2018-05-20","objectID":"/leetcode/0839/:2:0","tags":null,"title":"0839：相似字符串组（★★）","uri":"/leetcode/0839/"},{"categories":null,"content":"解答 def numSimilarGroups(self, strs: List[str]) -\u003e int: def find(i): if p[i] != i: p[i] = find(p[i]) return p[i] def union(i, j): p[find(i)] = find(j) def is_sim(s1, s2): cnt = 0 for x, y in zip(s1, s2): cnt += (x != y) if cnt \u003e 2: return False return True n = len(strs) p = list(range(n)) for i in ra","date":"2018-05-20","objectID":"/leetcode/0839/:3:0","tags":null,"title":"0839：相似字符串组（★★）","uri":"/leetcode/0839/"},{"categories":null,"content":" 力扣第 84 场周赛第 4 题 ","date":"2018-05-13","objectID":"/leetcode/0834/:0:0","tags":null,"title":"0834：树中距离之和（★★）","uri":"/leetcode/0834/"},{"categories":null,"content":"题目 给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。 给定整数 n 和数组 edges ， edges[i] = [ai, bi]表示树中的节点 ai 和 bi 之间有一条边。 返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。 示例 1: 输入: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] 输出: [8,12,6,10,10,10] 解释: 树如图所示。 我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3","date":"2018-05-13","objectID":"/leetcode/0834/:1:0","tags":null,"title":"0834：树中距离之和（★★）","uri":"/leetcode/0834/"},{"categories":null,"content":"分析 为了方便，考虑节点 0 为根的树形式。显然相邻节点对应的答案有很大联系，考虑递推。 若 u 是 v 的父节点，那么对于任意 v 的子节点 x（包括 v），dist(v,x)=dist(u,x)-1。 对于其它节点 x （包括 u），dist(v,x)=dist(u,x)+1。 因此令 cnt[v] 代表 v 的子节点个数，则 ans[v]=ans[u]-cnt[v]+(n-cnt[v])。 那么先一遍 dfs 从下往上求出 ans[0] 和 cnt 数组，再一遍 dfs 从上往下即可求出 ans 数组。 ","date":"2018-05-13","objectID":"/leetcode/0834/:2:0","tags":null,"title":"0834：树中距离之和（★★）","uri":"/leetcode/0834/"},{"categories":null,"content":"解答 def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -\u003e List[int]: def dfs1(u, f): for v in nxt[u]: if v != f: dfs1(v, u) ans[u] += ans[v] + cnt[v] cnt[u] += cnt[v] def dfs2(u, f): for v in nxt[u]: if v != f: ans[v] = ans[u] + n - 2 * cnt[v] dfs2(v, u) nxt = defaultdict(list) for u, v i","date":"2018-05-13","objectID":"/leetcode/0834/:3:0","tags":null,"title":"0834：树中距离之和（★★）","uri":"/leetcode/0834/"},{"categories":null,"content":" 力扣第 84 场周赛第 3 题 ","date":"2018-05-13","objectID":"/leetcode/0835/:0:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":"题目 给你两个图像 img1 和 img2 ，两个图像的大小都是 n x n ，用大小相同的二进制正方形矩阵表示。二进制矩阵仅由若干 0 和若干 1 组成。 转换 其中一个图像，将所有的 1 向左，右，上，或下滑动任何数量的单位；然后把它放在另一个图像的上面。该转换的 重叠 是指两个图像 都 具有 1 的位置的数目。 请注意，转换 不包括 向任何方向旋转。越过矩阵边界的 1 都将被清除。 最大可能的重叠数量是多少？ 示例 1： 输入：img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\r输出：3\r解释：将 img1","date":"2018-05-13","objectID":"/leetcode/0835/:1:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":"分析 数据范围较小，考虑暴力遍历。 令 x 代表 img1 水平滑动的单位，y 代表 img1 竖直滑动的单位，范围都是 [-(n-1), n-1]。 遍历 \u003cx, y\u003e，求重叠的 1 的数目即可。 ","date":"2018-05-13","objectID":"/leetcode/0835/:2:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":"解答 def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -\u003e int: def cal(x, y): return sum(0\u003c=i+x\u003cn and 0\u003c=j+y\u003cn and img2[i+x][j+y]==1 for i, j in points) n = len(img1) points = [(i, j) for i in range(n) for j in range(n) if img1[i][j]] return max(cal(x, y) for x in range(-n+1, n) f","date":"2018-05-13","objectID":"/leetcode/0835/:3:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":"*附加 还可以用另一种方式计算重叠的 1 的数目：将重叠部分对应的两个数相乘，并全部求和。 这其实就类似于卷积，因此调用 scipy.signal.correlate2d 即可求出每种滑动方式对应的重叠的 1 的数目。 def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -\u003e int: from scipy.signal import correlate2d return int(correlate2d(img1, img2).max()) 284 ms ","date":"2018-05-13","objectID":"/leetcode/0835/:4:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":" 力扣第 84 场周赛第 2 题 ","date":"2018-05-13","objectID":"/leetcode/0833/:0:0","tags":null,"title":"0833：字符串中的查找与替换（★）","uri":"/leetcode/0833/"},{"categories":null,"content":"题目 你会得到一个字符串 s (索引从 0 开始)，你必须对它执行 k 个替换操作。替换操作以三个长度均为 k 的并行数组给出：indices, sources, targets。 要完成第 i 个替换操作: 检查 子字符串 sources[i] 是否出现在 原字符串 s 的索引 indices[i] 处。\r如果没有出现， 什么也不做 。\r如果出现，则用 targets[i] 替换 该子字符串。\r例如，如果 s = \"abcd\" ， indices[i] = 0 , sources[i] = \"ab\"， targets[i] = \"eee\" ，那么替换的结果将是 \"eeecd\" 。 所有替换操","date":"2018-05-13","objectID":"/leetcode/0833/:1:0","tags":null,"title":"0833：字符串中的查找与替换（★）","uri":"/leetcode/0833/"},{"categories":null,"content":"分析 为了使替换操作互不干扰，考虑按索引逆序来替换。 ","date":"2018-05-13","objectID":"/leetcode/0833/:2:0","tags":null,"title":"0833：字符串中的查找与替换（★）","uri":"/leetcode/0833/"},{"categories":null,"content":"解答 def findReplaceString(self, s: str, indices: List[int], sources: List[str], targets: List[str]) -\u003e str: s = list(s) for idx, x, y in sorted(zip(indices, sources, targets), reverse=True): if s[idx:idx+len(x)]==list(x): s[idx:idx+len(x)] = list(y) return ''.join(s) 36 ms ","date":"2018-05-13","objectID":"/leetcode/0833/:3:0","tags":null,"title":"0833：字符串中的查找与替换（★）","uri":"/leetcode/0833/"},{"categories":null,"content":" 力扣第 84 场周赛第 1 题 ","date":"2018-05-13","objectID":"/leetcode/0832/:0:0","tags":null,"title":"0832：翻转图像","uri":"/leetcode/0832/"},{"categories":null,"content":"题目 给定一个 n x n 的二进制矩阵 image ，先 水平 翻转图像，然后 反转 图像并返回 结果 。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。 例如，水平翻转 [1,1,0] 的结果是 [0,1,1]。\r反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。 例如，反转 [0,1,1] 的结果是 [1,0,0]。\r示例 1： 输入：image = [[1,1,0],[1,0,1],[0,0,0]]\r输出：[[1,0,0],[0,1,0],[1,1,1]]\r解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\r然后反转图片: [[1,0","date":"2018-05-13","objectID":"/leetcode/0832/:1:0","tags":null,"title":"0832：翻转图像","uri":"/leetcode/0832/"},{"categories":null,"content":"分析 每行逆序后再将每个元素与 1 异或即可。 ","date":"2018-05-13","objectID":"/leetcode/0832/:2:0","tags":null,"title":"0832：翻转图像","uri":"/leetcode/0832/"},{"categories":null,"content":"解答 def flipAndInvertImage(self, image: List[List[int]]) -\u003e List[List[int]]: return [[val^1 for val in row[::-1]] for row in image] 28 ms ","date":"2018-05-13","objectID":"/leetcode/0832/:3:0","tags":null,"title":"0832：翻转图像","uri":"/leetcode/0832/"},{"categories":null,"content":" 力扣第 83 场周赛第 4 题 ","date":"2018-05-06","objectID":"/leetcode/0828/:0:0","tags":null,"title":"0828：统计子串中的唯一字符（★★）","uri":"/leetcode/0828/"},{"categories":null,"content":"题目 我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。 例如：s = \"LEETCODE\" ，则其中 \"L\", \"T\",\"C\",\"O\",\"D\" 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 。 本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。输入用例保证返回值为 32 位整数。 注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。 示例 1","date":"2018-05-06","objectID":"/leetcode/0828/:1:0","tags":null,"title":"0828：统计子串中的唯一字符（★★）","uri":"/leetcode/0828/"},{"categories":null,"content":"分析 可以对每个字符统计其作为唯一字符的次数。 令 left[i] 代表 s[i] 上一次出现的位置，right[i] 代表 s[i] 下一次出现的位置。 显然对于 [left[i], right[i]] 范围内包含 s[i] 的子串，s[i] 都是唯一字符。 这样的子串个数即为 (i-left[i])*(right[i]-i)。 借助哈希表可以一趟得到所有的 left[i] 和 right[i]。 ","date":"2018-05-06","objectID":"/leetcode/0828/:2:0","tags":null,"title":"0828：统计子串中的唯一字符（★★）","uri":"/leetcode/0828/"},{"categories":null,"content":"解答 def uniqueLetterString(self, s: str) -\u003e int: n = len(s) left, right = [-1]*n, [n]*n d = {} for i, char in enumerate(s): if char in d: j = d[char] left[i] = j right[j] = i d[char] = i res, mod = 0, 10**9+7 for i in range(n): res += (i-left[i])*(right[i]-i) res %= mod return res 236 ms ","date":"2018-05-06","objectID":"/leetcode/0828/:3:0","tags":null,"title":"0828：统计子串中的唯一字符（★★）","uri":"/leetcode/0828/"},{"categories":null,"content":" 力扣第 83 场周赛第 3 题 ","date":"2018-05-06","objectID":"/leetcode/0829/:0:0","tags":null,"title":"0829：连续整数求和（★）","uri":"/leetcode/0829/"},{"categories":null,"content":"题目 给定一个正整数 n，返回 连续正整数满足所有数字之和为 n 的组数 。 示例 1: 输入: n = 5\r输出: 2\r解释: 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。\r示例 2: 输入: n = 9\r输出: 3\r解释: 9 = 4 + 5 = 2 + 3 + 4\r示例 3: 输入: n = 15\r输出: 4\r解释: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\r提示: 1 \u003c= n \u003c= 109​​​​​​​\r","date":"2018-05-06","objectID":"/leetcode/0829/:1:0","tags":null,"title":"0829：连续整数求和（★）","uri":"/leetcode/0829/"},{"categories":null,"content":"分析 ","date":"2018-05-06","objectID":"/leetcode/0829/:2:0","tags":null,"title":"0829：连续整数求和（★）","uri":"/leetcode/0829/"},{"categories":null,"content":"#1 假设某组连续正整数的第一个数是 x，共有 k 个数，那么根据数学的求和公式有： $$ N = \\frac {(x+x+k-1)*k} 2 $$ $$ x = (\\frac {2 * N}k+1-k) / 2 $$ 那么遍历 k，只要对应的 x 是正整数，即得到一组答案。 而显然 k * k\u003c 2 * N，因此 $O(\\sqrt n)$ 时间即可完成遍历。 def consecutiveNumbersSum(self, n: int) -\u003e int: return sum(2 * n % k == 0 and (2 * n // k + 1 - k) % 2 == 0 and (2 * n","date":"2018-05-06","objectID":"/leetcode/0829/:2:1","tags":null,"title":"0829：连续整数求和（★）","uri":"/leetcode/0829/"},{"categories":null,"content":"#2 公式还可以变形为： $$x = \\frac {N-k*(k-1)/2} k $$ 遍历 k 时，分子增加 1，分母减少 k，判断能否整除即可。 ","date":"2018-05-06","objectID":"/leetcode/0829/:2:2","tags":null,"title":"0829：连续整数求和（★）","uri":"/leetcode/0829/"},{"categories":null,"content":"解答 def consecutiveNumbersSum(self, n: int) -\u003e int: res, k = 0, 1 while n \u003e 0: res += int(n % k == 0) n -= k k += 1 return res 140 ms ","date":"2018-05-06","objectID":"/leetcode/0829/:3:0","tags":null,"title":"0829：连续整数求和（★）","uri":"/leetcode/0829/"},{"categories":null,"content":" 力扣第 83 场周赛第 2 题 ","date":"2018-05-06","objectID":"/leetcode/0831/:0:0","tags":null,"title":"0831：隐藏个人信息（★）","uri":"/leetcode/0831/"},{"categories":null,"content":"题目 给你一条个人信息字符串 s ，可能表示一个 邮箱地址 ，也可能表示一串 电话号码 。返回按如下规则 隐藏 个人信息后的结果： 电子邮件地址： 一个电子邮件地址由以下部分组成： 一个 名字 ，由大小写英文字母组成，后面跟着 一个 '@' 字符，后面跟着 一个 域名 ，由大小写英文字母和一个位于中间的 '.' 字符组成。'.' 不会是域名的第一个或者最后一个字符。 要想隐藏电子邮件地址中的个人信息： 名字 和 域名 部分的大写英文字母应当转换成小写英文字母。 名字 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 \"*****\" 替换。 电话号码： 一个电话号码应当按下述格式组成： ","date":"2018-05-06","objectID":"/leetcode/0831/:1:0","tags":null,"title":"0831：隐藏个人信息（★）","uri":"/leetcode/0831/"},{"categories":null,"content":"分析 邮箱转为小写再转换 ‘@’ 前的名字即可。电话号码则根据长度判断是否包含国际号码，分类转换即可。 ","date":"2018-05-06","objectID":"/leetcode/0831/:2:0","tags":null,"title":"0831：隐藏个人信息（★）","uri":"/leetcode/0831/"},{"categories":null,"content":"解答 def maskPII(self, s: str) -\u003e str: if '@' in s: name1, suf = s.lower().split('@') return name1[0]+'*'*5+name1[-1]+'@'+suf s = re.sub('[-+() ]', '', s) n = len(s) return ('+'+'*'*(n-10)+'-')*int(n\u003e10)+'***-***-'+s[-4:] 28 ms ","date":"2018-05-06","objectID":"/leetcode/0831/:3:0","tags":null,"title":"0831：隐藏个人信息（★）","uri":"/leetcode/0831/"},{"categories":null,"content":" 力扣第 83 场周赛第 1 题 ","date":"2018-05-06","objectID":"/leetcode/0830/:0:0","tags":null,"title":"0830：较大分组的位置","uri":"/leetcode/0830/"},{"categories":null,"content":"题目 在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 s = \"abbxxxxzyy\" 中，就含有 \"a\", \"bb\", \"xxxx\", \"z\" 和 \"yy\" 这样的一些分组。 分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 \"xxxx\" 分组用区间表示为 [3,6] 。 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。 示例 1： 输入：s = \"abbxxxxzzy\" 输出：[[3,6]","date":"2018-05-06","objectID":"/leetcode/0830/:1:0","tags":null,"title":"0830：较大分组的位置","uri":"/leetcode/0830/"},{"categories":null,"content":"分析 遍历得到每一段，若长度大于等于 3 就将区间添加到结果即可。 ","date":"2018-05-06","objectID":"/leetcode/0830/:2:0","tags":null,"title":"0830：较大分组的位置","uri":"/leetcode/0830/"},{"categories":null,"content":"解答 def largeGroupPositions(self, s: str) -\u003e List[List[int]]: res, i = [], 0 for j in range(len(s)): if j == len(s)-1 or s[j] != s[j+1]: if j - i \u003e= 2: res.append([i, j]) i = j+1 return res 40 ms ","date":"2018-05-06","objectID":"/leetcode/0830/:3:0","tags":null,"title":"0830：较大分组的位置","uri":"/leetcode/0830/"},{"categories":null,"content":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。他平日是个热爱理发事业的理发师，善用剪刀，而剪刀也是他的刺杀武器——没错，伍六七背地里做着刺客生意。 伍六七是他的经纪人鸡大保从海边“捡”回来的，当时他重伤昏迷，失去了记忆，他的过去成了一个谜。鸡大保根据理发店门牌号给他取了个名字：伍六七。为了维持生计，鸡大保作为他的经纪人，以理发店为据点，替伍六七承接各种刺杀任务。初入刺客行当，伍六七排名靠后，因此接到的都是些奇葩的刺杀任务。在完成任务的过程中，他常与刺杀对象发生一系列有趣可笑的意外事件，每次任务都被搞得乱七八糟。伍六七从来没有成功完成过刺杀任务，但却每次都能意外的化解雇主的仇恨。也正因如此，他没拿到过任何报酬，行情越发低落，只能混迹于刺客行业的底层，生活穷困潦倒。 在这些奇葩任务的执行过程中，他看到了很多人，经历了很多事，开始渐渐的认清自我。伍六七身世之谜也渐渐浮出水面……","date":"2018-04-25","objectID":"/anime/killer_seven/","tags":null,"title":"刺客伍六七","uri":"/anime/killer_seven/"},{"categories":null,"content":"简介 在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。他平日是个热爱理发事业的理发师，善用剪刀，而剪刀也是他的刺杀武器——没错，伍六七背地里做着刺客生意。 伍六七是他的经纪人鸡大保从海边“捡”回来的，当时他重伤昏迷，失去了记忆，他的过去成了一个谜。鸡大保根据理发店门牌号给他取了个名字：伍六七。为了维持生计，鸡大保作为他的经纪人，以理发店为据点，替伍六七承接各种刺杀任务。初入刺客行当，伍六七排名靠后，因此接到的都是些奇葩的刺杀任务。在完成任务的过程中，他常与刺杀对象发生一系列有趣可笑的意外事件，每次任务都被搞得乱七八糟。伍六七从来没有成功完成过刺杀任务，但却每次都能意外的化解雇主的","date":"2018-04-25","objectID":"/anime/killer_seven/:1:0","tags":null,"title":"刺客伍六七","uri":"/anime/killer_seven/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伍六七 柒 男 何小疯 2 梅花十三 女 段艺璇 3 小飞鸡 鸡小飞 4 江惠莲 江主任 女 刘晓倩 5 可乐 女 朱蓉蓉 6 何大春 男 斑马 ","date":"2018-04-25","objectID":"/anime/killer_seven/:2:0","tags":null,"title":"刺客伍六七","uri":"/anime/killer_seven/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 刺客伍六七 2018-04-25 14 bilibili 2 伍六七之最强发型师 2019-10-23 10 bilibili 3 伍六七之玄武国篇 2021-01-27 10 bilibili ","date":"2018-04-25","objectID":"/anime/killer_seven/:3:0","tags":null,"title":"刺客伍六七","uri":"/anime/killer_seven/"},{"categories":null,"content":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴走的雏，不论在组里还是在学校都为所欲为。新田为此头痛不已，但由于自己那老好人的性格而陷入总是要照顾她的境地。究竟这种生活会变得怎样呢？\n老好人不法之徒与任性超能力少女的危险而热闹的日常开始了！","date":"2018-04-06","objectID":"/anime/hina_matsuri/","tags":null,"title":"黑社会的超能力女儿","uri":"/anime/hina_matsuri/"},{"categories":null,"content":"简介 支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！ 容易暴走的雏，不论在组里还是在学校都为所欲为。新田为此头痛不已，但由于自己那老好人的性格而陷入总是要照顾她的境地。究竟这种生活会变得怎样呢？ 老好人不法之徒与任性超能力少女的危险而热闹的日常开始了！ 制作人员： 原作：大武政夫 导演：及川启 脚本：大知庆一郎 演出：平井义通、中田诚、名和宗则、山田晃、佐佐木达也 ","date":"2018-04-06","objectID":"/anime/hina_matsuri/:1:0","tags":null,"title":"黑社会的超能力女儿","uri":"/anime/hina_matsuri/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 新田雏 ヒナ 女 田中貴子 2 新田义史 にった よしふみ、Nitta Yoshifumi 男 中島ヨシキ 3 三岛瞳 みしま ひとみ、Mishima Hitomi 女 本渡楓 4 杏子 Anzu 女 村川梨衣 5 诗子 うたこ、Utako 女 日笠陽子 6 真绪 Mao 女 小澤亜李 7 少主 馬場 清、ばば きよし 男 小山剛志 8 跟班 阿三 男 河西健吾 ","date":"2018-04-06","objectID":"/anime/hina_matsuri/:2:0","tags":null,"title":"黑社会的超能力女儿","uri":"/anime/hina_matsuri/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 黑社会的超能力女儿 2018-04-06 12 bilibili ","date":"2018-04-06","objectID":"/anime/hina_matsuri/:3:0","tags":null,"title":"黑社会的超能力女儿","uri":"/anime/hina_matsuri/"},{"categories":null,"content":"将肉体与“外骨骼技术”融合的究极格斗技——“MEGALO BOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“Junk Dog”。虽然具备实力，却只有靠比赛造假赚钱这一条生存之道，他为自己的“现在”感到心焦。\n但，他与孤高的冠军·勇利相遇，作为MEGALO拳击手，作为男人，向自己的“现在”发起挑战——。 ","date":"2018-04-05","objectID":"/anime/megalo_box/","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":"简介 将肉体与“外骨骼技术”融合的究极格斗技——“MEGALO BOX”，将自己的全部赌在上面的男人们的热血战斗开始！ 今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“Junk Dog”。虽然具备实力，却只有靠比赛造假赚钱这一条生存之道，他为自己的“现在”感到心焦。 但，他与孤高的冠军·勇利相遇，作为MEGALO拳击手，作为男人，向自己的“现在”发起挑战——。 制作人员： 导演：森山洋 脚本：真边克彦、小嶋健作 分镜：金井次郎、矢野博之、寺冈岩、佐山圣子、桥口淳一郎 ","date":"2018-04-05","objectID":"/anime/megalo_box/:1:0","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 JNK DOG JOE、NOMAD、Junk Dog、Gearless Joe 男 細谷佳正 2 勇利 Yuri、キング・オブ・キングス(King of Kings) 男 安元洋貴 3 白都有希子 しらと ゆきこ、Shirato Yukiko 女 森なな子 4 南部赝作 なんぶ がんさく、Nanbu Gansaku 男 斎藤志郎 5 荒垣 Aragaki 男 田村真 6 白都树生 しらと みきお、Shirato Mikio 男 鈴木達央 7 桑塔 男 種市桃子 8 奥乔 Oicho 女 内藤有海 ","date":"2018-04-05","objectID":"/anime/megalo_box/:2:0","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 MEGALO BOX 2018-04-05 13 bilibili 2 NOMAD MEGALO BOX 2 2021-04-04 13 bilibili ","date":"2018-04-05","objectID":"/anime/megalo_box/:3:0","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":"MAD ","date":"2018-04-05","objectID":"/anime/megalo_box/:4:0","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":"地球是蓝的。哥俩是蠢的。\n在人类将生活领域和自身欲望扩张到宇宙的时代，寻求自由的人们移民到宇宙中居住，他们的睿智孕育出发达的文明，不知不觉转变为对地球的一种威胁。\n宇宙历0156年，地球联邦政府经历了与祖母星格兰地玛斯有史以来的第四次接触（4th note），也正是从这一年开始，联邦政府与【梅杜斯子民】之间的对抗正式拉开帷幕。\n战争永无止境，牺牲不断增加……\n为了打开战局，联邦政府派出一名英姿飒爽的青年加入战局。年轻人名叫斯巴鲁·一之濑，不仅长相帅气、成绩优异，而且是宇宙战舰【提拉米斯】的王牌驾驶员。\n全人类的希望都寄托在他的身上。\n——然而，他实际上是个难以融入提拉米斯舰内集体生活，整日将自己关在专用机“杜兰德尔”驾驶舱内的“窝里蹲”……","date":"2018-04-02","objectID":"/anime/space_battleship_tiramisu/","tags":null,"title":"宇宙战舰提拉米斯","uri":"/anime/space_battleship_tiramisu/"},{"categories":null,"content":"简介 地球是蓝的。哥俩是蠢的。 在人类将生活领域和自身欲望扩张到宇宙的时代，寻求自由的人们移民到宇宙中居住，他们的睿智孕育出发达的文明，不知不觉转变为对地球的一种威胁。 宇宙历0156年，地球联邦政府经历了与祖母星格兰地玛斯有史以来的第四次接触（4th note），也正是从这一年开始，联邦政府与【梅杜斯子民】之间的对抗正式拉开帷幕。 战争永无止境，牺牲不断增加…… 为了打开战局，联邦政府派出一名英姿飒爽的青年加入战局。年轻人名叫斯巴鲁·一之濑，不仅长相帅气、成绩优异，而且是宇宙战舰【提拉米斯】的王牌驾驶员。 全人类的希望都寄托在他的身上。 ——然而，他实际上是个难以融入提拉米斯舰内集体生活，整","date":"2018-04-02","objectID":"/anime/space_battleship_tiramisu/:1:0","tags":null,"title":"宇宙战舰提拉米斯","uri":"/anime/space_battleship_tiramisu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 斯巴鲁·一之濑 Subaru Ichinose 男 石川界人 2 五十铃·一之濑 Isuzu Ichinose 男 櫻井孝宏 3 伏尔加·悍马 Vulgar Hummer 男 諏訪部順一 4 斯巴鲁·彼洋德 Subaru Beyond、スバルB、Subaru B 男 江口拓也 5 文图瑞·勒罗伊 Venturi Leory 男 土師孝也 6 莉裘·勒罗伊 Ligier Leory 女 遠藤綾 7 茂子·本田 Shigeruko Honda 女 新井里美 8 阴毛 THE UNDER HAIR、いんもう、Inmou ♂？ 中田譲治 ","date":"2018-04-02","objectID":"/anime/space_battleship_tiramisu/:2:0","tags":null,"title":"宇宙战舰提拉米斯","uri":"/anime/space_battleship_tiramisu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 宇宙战舰提拉米斯 2018-04-02 13 bilibili 2 宇宙战舰提拉米斯 2 2018-10-01 13 bilibili ","date":"2018-04-02","objectID":"/anime/space_battleship_tiramisu/:3:0","tags":null,"title":"宇宙战舰提拉米斯","uri":"/anime/space_battleship_tiramisu/"},{"categories":null,"content":"这是从异世界传承下光辉的姓名与竞跑能力的“马娘”、自久以来与人类共存着的世界的故事。\n从乡下转学到大都市的训中学园的马娘·特别周，与同学们互相切磋、赌上“日本第一马娘”的称号，目标：在“Twinkle系列”中的胜利！","date":"2018-04-01","objectID":"/anime/pretty_derby/","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"简介 这是从异世界传承下光辉的姓名与竞跑能力的“马娘”、自久以来与人类共存着的世界的故事。 从乡下转学到大都市的训中学园的马娘·特别周，与同学们互相切磋、赌上“日本第一马娘”的称号，目标：在“Twinkle系列”中的胜利！ 制作人员： 原作：Cygames 导演：及川启 脚本：米内山阳子、杉浦理史、池田亮 分镜：今泉贤一、增井壮一、高村彰 ","date":"2018-04-01","objectID":"/anime/pretty_derby/:1:0","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 特别周 特別週、Special Week 女 和氣あず未 2 无声铃鹿 無聲鈴鹿、Silence Suzuka 女 高野麻里佳 3 东海帝皇 东海帝王、Tokai Teio 女 Machico 4 伏特加 Vodka 女 大橋彩香 5 大和赤骥 大和赤驥、Daiwa Scarlet 女 木村千咲 6 黄金船 Gold Ship 女 上田瞳 7 目白麦昆 Mejiro McQueen 女 大西沙織 8 神鹰 神鷹、El Condor Pasa 女 髙橋ミナミ ","date":"2018-04-01","objectID":"/anime/pretty_derby/:2:0","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 赛马娘 Pretty Derby 2018-04-01 13 bilibili 2 赛马娘 Pretty Derby 第二季 2021-01-04 13 bilibili ","date":"2018-04-01","objectID":"/anime/pretty_derby/:3:0","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"MAD ","date":"2018-04-01","objectID":"/anime/pretty_derby/:4:0","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"舞台是架空的大陆·努纳西亚。悠久的历史记载着无数的国家和文明的兴起、繁荣、战争、灭亡。\n住在绿意盎然的边境村落·丹德拉的凛，是个稍有些贪吃、充满精神的女孩子。与可靠又温柔的姐姐·梅尔、以世界第一的科学家为目标的科学宅少年·阿尔、严格但满怀关爱的爷爷一起过着平稳的生活。\n另一边，住在华丽的王都、被人民爱戴着的歌姬·菲妮丝。她虽然作为某位将要继承王位的王子的王妃候补，却在被重重墙壁包围的深宫中孤独度日。\n这两人有着其他人类所不具备的特殊力量。她们能够演唱出产生治愈伤口、创造出水、点火等各种各样奇迹的歌声。 ……命运将拥有歌之力量的这两人，分别引导到了残酷的旅程上。\n当战争的阴影笼罩王国时，即使是奇迹之歌的光辉也被染上了血色。所爱之人的生命被夺走，无声的悲鸣响彻石牢。\n两人的命运交汇，最后唱出的歌是希望？是绝望？还是……","date":"2018-03-31","objectID":"/anime/lost_song/","tags":null,"title":"失落的歌谣","uri":"/anime/lost_song/"},{"categories":null,"content":"简介 舞台是架空的大陆·努纳西亚。悠久的历史记载着无数的国家和文明的兴起、繁荣、战争、灭亡。 住在绿意盎然的边境村落·丹德拉的凛，是个稍有些贪吃、充满精神的女孩子。与可靠又温柔的姐姐·梅尔、以世界第一的科学家为目标的科学宅少年·阿尔、严格但满怀关爱的爷爷一起过着平稳的生活。 另一边，住在华丽的王都、被人民爱戴着的歌姬·菲妮丝。她虽然作为某位将要继承王位的王子的王妃候补，却在被重重墙壁包围的深宫中孤独度日。 这两人有着其他人类所不具备的特殊力量。她们能够演唱出产生治愈伤口、创造出水、点火等各种各样奇迹的歌声。 ……命运将拥有歌之力量的这两人，分别引导到了残酷的旅程上。 当战争的阴影笼罩王国时，即","date":"2018-03-31","objectID":"/anime/lost_song/:1:0","tags":null,"title":"失落的歌谣","uri":"/anime/lost_song/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 琳 Rin 女 鈴木このみ 2 菲妮丝 Finis 女 田村ゆかり 3 阿尔 男 久野美咲 4 波妮·古德莱特 女 たかはし智秋 5 亨利·利奥波德 男 山下誠一郎 6 阿琉·路克斯 女 瀬戸麻沙美 7 莫妮卡·路克斯 女 芹澤優 ","date":"2018-03-31","objectID":"/anime/lost_song/:2:0","tags":null,"title":"失落的歌谣","uri":"/anime/lost_song/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 失落的歌谣 2018-03-31 12 bilibili ","date":"2018-03-31","objectID":"/anime/lost_song/:3:0","tags":null,"title":"失落的歌谣","uri":"/anime/lost_song/"},{"categories":null,"content":"遥远的未来，因人类过度抽取地球资源，地球变得荒芜，不再适合居住，人类只好居住在移动要塞都市内，但时常需要外出获取无法产出的资源「熔岩燃料」，「熔岩燃料」的开采会吸引来半机械生命体「叫龙」，此时就轮到人类操对抗叫龙的「FranXX」机械人的出场了。究竟这些「叫龙」是敌是友，无从得知。\n少年阿广，驾驶部队代号016。他在少年时期被称作神童，如今却因无法驾驶「FranXX」，驾驶员生涯跌落谷底，是不被人需要的存在。在这样的广面前，某天，一位被称作02的神秘少女出现了。她的额头，长着两根艳丽的角。少女对广说：「终于找到你了，我的DARLING」。以此次偶遇为契机，广对驾驶机械人重新燃起了信心。","date":"2018-01-13","objectID":"/anime/darling_in_the_franxx/","tags":null,"title":"DARLING in the FRANXX","uri":"/anime/darling_in_the_franxx/"},{"categories":null,"content":"简介 遥远的未来，因人类过度抽取地球资源，地球变得荒芜，不再适合居住，人类只好居住在移动要塞都市内，但时常需要外出获取无法产出的资源「熔岩燃料」，「熔岩燃料」的开采会吸引来半机械生命体「叫龙」，此时就轮到人类操对抗叫龙的「FranXX」机械人的出场了。究竟这些「叫龙」是敌是友，无从得知。 少年阿广，驾驶部队代号016。他在少年时期被称作神童，如今却因无法驾驶「FranXX」，驾驶员生涯跌落谷底，是不被人需要的存在。在这样的广面前，某天，一位被称作02的神秘少女出现了。她的额头，长着两根艳丽的角。少女对广说：「终于找到你了，我的DARLING」。以此次偶遇为契机，广对驾驶机械人重新燃起了信心。 ","date":"2018-01-13","objectID":"/anime/darling_in_the_franxx/:1:0","tags":null,"title":"DARLING in the FRANXX","uri":"/anime/darling_in_the_franxx/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 广 CODE:016、HIRO 男 小清水亜美 2 02 CODE:002、ZERO TWO、パートナー殺し / 搭档杀手 女 戸松遥 3 五郎 CODE:056、GORO 男 梅原裕一郎 4 莓 CODE:015、ICHIGO 女 市ノ瀬加那 5 纯位数 CODE:666、揃目、ZOROME 男 田村睦心 6 未来 CODE:390、MIKU 女 山下七海 7 满 CODE:326、充、MITSURU 男 早見沙織 8 心 CODE:556、KOKORO 女 早見沙織 ","date":"2018-01-13","objectID":"/anime/darling_in_the_franxx/:2:0","tags":null,"title":"DARLING in the FRANXX","uri":"/anime/darling_in_the_franxx/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 DARLING in the FRANXX 2018-01-13 24 樱花 ","date":"2018-01-13","objectID":"/anime/darling_in_the_franxx/:3:0","tags":null,"title":"DARLING in the FRANXX","uri":"/anime/darling_in_the_franxx/"},{"categories":null,"content":"平凡的大学生·野本裕也，与神秘少女·瞳相遇了。\n在没有人烟的废弃场，野本目击到了她变成野兽的模样，\n与狮子怪物展开死战的一幕。\n他们的真实身份，是同时拥有人类的头脑与野兽的獠牙的“兽斗士”。\n并且，瞳是隐藏着最强斗争本能的兽斗士“蜜獾”。\n兽斗士们被自古以来支配日本经济的四大财阀三门、八菱、角供、石田所雇佣，\n并作为其代理人展开决斗，争夺霸权。之后，野本通过再次与瞳相遇，\n被卷入了这些兽斗士们的炽烈战斗“牙斗”当中——。 ","date":"2018-01-12","objectID":"/anime/killing_bites/","tags":null,"title":"牙斗","uri":"/anime/killing_bites/"},{"categories":null,"content":"简介 平凡的大学生·野本裕也，与神秘少女·瞳相遇了。 在没有人烟的废弃场，野本目击到了她变成野兽的模样， 与狮子怪物展开死战的一幕。 他们的真实身份，是同时拥有人类的头脑与野兽的獠牙的“兽斗士”。 并且，瞳是隐藏着最强斗争本能的兽斗士“蜜獾”。 兽斗士们被自古以来支配日本经济的四大财阀三门、八菱、角供、石田所雇佣， 并作为其代理人展开决斗，争夺霸权。之后，野本通过再次与瞳相遇， 被卷入了这些兽斗士们的炽烈战斗“牙斗”当中——。 制作人员： 原作：隅田かずあさ、村田真哉 导演：西片康人 脚本：朱白葵、风埜隼人、小柳启伍 分镜：中川淳、阿部记之、山内爱弥 ","date":"2018-01-12","objectID":"/anime/killing_bites/:1:0","tags":null,"title":"牙斗","uri":"/anime/killing_bites/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宇崎瞳 うざき ひとみ、Uzaki Hitomi、蜜獾、ラーテル、Ratel 女 雨宮天 2 野本裕也 のもと ゆうや、Nomoto Yuya 男 羽多野渉 3 中西获座 なかにし えるざ、Nakanishi Elza 女 内田真礼 4 稻叶初 いなば うい、Inaba Ui、兔、兎、ラビ、Rabi 女 上坂すみれ 5 祠堂零一 祠堂 零一、しどう れいいち、Shidoh Reiichi 男 小山力也 6 筱崎舞 篠崎 舞、しのざき まい、Shinozaki Mai 女 赤﨑千夏 7 冈岛壹之助 岡島 壱之助、おかじま いちのすけ、Okajima Ichin","date":"2018-01-12","objectID":"/anime/killing_bites/:2:0","tags":null,"title":"牙斗","uri":"/anime/killing_bites/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 牙斗 2018-01-12 12 樱花 ","date":"2018-01-12","objectID":"/anime/killing_bites/:3:0","tags":null,"title":"牙斗","uri":"/anime/killing_bites/"},{"categories":null,"content":"哈库梅伊与蜜珂析。\n住在绿意盎然的森林中的，两位小小的女孩子。\n在树洞里建造家、把树叶当做伞、坐在昆虫或鸟的背上……\n身高9厘米的话，这种事情也是能做得到的。\n不去悄悄地偷看一下吗？\n她们那安详而愉快，十分可爱的生活。","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"简介 哈库梅伊与蜜珂析。 住在绿意盎然的森林中的，两位小小的女孩子。 在树洞里建造家、把树叶当做伞、坐在昆虫或鸟的背上…… 身高9厘米的话，这种事情也是能做得到的。 不去悄悄地偷看一下吗？ 她们那安详而愉快，十分可爱的生活。 制作人员： 原作：樫木祐人 导演：安藤正臣 脚本：大河内一楼、吉田玲子、国泽真理子 分镜：名村英敏、木野目优、大桥明代、夕澄庆英 ","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/:1:0","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哈库梅伊 白明 女 松田利冴 2 蜜珂析 御子地 女 下地紫野 3 康居 女 悠木碧 4 千 女 安済知佳 5 鰯谷 男 松風雅也 6 マヤ マスター 女 緒方恵美 7 伽达 女 新谷真弓 8 亚由音 女 生天目仁美 ","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/:2:0","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 妖精森林的小不点 2018-01-12 13 bilibili ","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/:3:0","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"MAD ","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/:4:0","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界逐渐走向了和平。\n在战争中、作为军人而战斗的薇尔莉特·伊芙加登离开了军队，来到了大港口城市。怀抱着战场上一个对她而言比谁都重要的人告诉了她“某个话语”――。\n街道上人群踊跃，有轨电车在排列着煤气灯的马路上穿梭着。薇尔莉特在街道上找到了“代写书信”的工作。那是根据委托人的想法来组织出相应语言的工作。\n她直面着委托人、触碰着委托人内心深处的坦率感情。与此同时，薇尔莉特在记录书信时，那一天所告知的那句话的意思也逐渐接近了。","date":"2018-01-10","objectID":"/anime/violet_evergarden/","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"简介 某个大陆的、某个时代。 大陆南北分割的战争结束了，世界逐渐走向了和平。 在战争中、作为军人而战斗的薇尔莉特·伊芙加登离开了军队，来到了大港口城市。怀抱着战场上一个对她而言比谁都重要的人告诉了她“某个话语”――。 街道上人群踊跃，有轨电车在排列着煤气灯的马路上穿梭着。薇尔莉特在街道上找到了“代写书信”的工作。那是根据委托人的想法来组织出相应语言的工作。 她直面着委托人、触碰着委托人内心深处的坦率感情。与此同时，薇尔莉特在记录书信时，那一天所告知的那句话的意思也逐渐接近了。 制作人员： 原作：晓佳奈 导演：石立太一 脚本：吉田玲子、浦畑达彦、铃木贵昭 分镜：藤田春香、河浪荣作、木上益治、小川","date":"2018-01-10","objectID":"/anime/violet_evergarden/:1:0","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 薇尔莉特·伊芙加登 Violet Evergarden 女 石川由依 2 基尔伯特·布甘比利亚 Gilbert Bougainvillea 男 浪川大輔 3 克劳迪亚·霍金斯 Claudia Hodgins 男 子安武人 4 嘉德丽雅·波德莱尔 Cattleya Baudelaire 女 遠藤綾 5 贝内迪克特·布卢 Benedict Blue 男 内山昂輝 6 艾丽卡·布朗 埃丽卡·布朗、Erica Brown 女 茅原実里 7 爱丽丝·卡娜莉 艾丽斯·卡纳利、Iris Cannary 女 戸松遥 8 蒂法尼·伊芙加登 Tiffany Evergarden","date":"2018-01-10","objectID":"/anime/violet_evergarden/:2:0","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 紫罗兰永恒花园 2018-01-10 13 bilibili 2 紫罗兰永恒花园 外传 - 永远与自动手记人偶 - 2019-09-06 1 bilibili 3 剧场版 紫罗兰永恒花园 2020-09-18 1 bilibili ","date":"2018-01-10","objectID":"/anime/violet_evergarden/:3:0","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"MAD ","date":"2018-01-10","objectID":"/anime/violet_evergarden/:4:0","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"玄关门一打开，眼前冒出了一位小学女生——\n“我依照约定来了，请收我为弟子！”\n年仅十六岁便拥有将棋界最高头衔“龙王”的九头龙八一家里，出现一位名叫雏鹤爱的小学三年级生，九岁。\n“什么？……弟子？你在说什么？”\n“……您不记得了吗？”\n八一对自己答应过的事情完全没有印象，却展开了与小学女生同居的生活。受到爱直率的热情影响，八一也逐渐取回险些丧失的热忱——","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"简介 玄关门一打开，眼前冒出了一位小学女生—— “我依照约定来了，请收我为弟子！” 年仅十六岁便拥有将棋界最高头衔“龙王”的九头龙八一家里，出现一位名叫雏鹤爱的小学三年级生，九岁。 “什么？……弟子？你在说什么？” “……您不记得了吗？” 八一对自己答应过的事情完全没有印象，却展开了与小学女生同居的生活。受到爱直率的热情影响，八一也逐渐取回险些丧失的热忱—— 制作人员： 原作：白鸟士郎 导演：柳伸亮 脚本：金子祐介、志茂文彦、杉泽悟 分镜：奥村吉昭、岛津裕行、福岛利规、岩田和也 ","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/:1:0","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 九头龙八一 くずりゅう やいち、Kuzuryu Yaichi 男 内田雄馬 2 雏鹤爱 ひなづる あい、Hinazuru Ai 女 日高里菜 3 夜叉神天衣 やしゃじん あい、Yashajin Ai、天ちゃん 女 佐倉綾音 4 空银子 そら ぎんこ、Sora Ginko 女 金元寿子 5 清泷桂香 きよたき けいか、Kiyotaki Keika 女 茅野愛衣 6 水越澪 みずこし みお、Mizukoshi Mio 女 久保ユリカ 7 贞任绫乃 さだとう あやの、Sadato Ayano 女 橋本ちなみ 8 夏绿蒂·伊索亚尔 Charlotte Izoard ","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/:2:0","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙王的工作！ 2018-01-08 12 bilibili ","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/:3:0","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"MAD ","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/:4:0","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"永远的“6时59分”开始了——\n在佑河家有着代代相传的止界术，使用止界术，能够进入森罗万象尽数停止的“止界”。某天，主人公树里的外甥和哥哥，被诱拐犯绑架了。她为了救出他们而不得已使用了“止界术”，却遭到不应存在于那里的、除自己以外的“会动的”人类袭击。他们是尊崇止界术的「真纯实爱会」。围绕着使用止界术时所必需的“石头”，止界之谜、佑河家之谜逐渐浮出水面……","date":"2018-01-07","objectID":"/anime/kokkoku/","tags":null,"title":"刻刻","uri":"/anime/kokkoku/"},{"categories":null,"content":"简介 永远的“6时59分”开始了—— 在佑河家有着代代相传的止界术，使用止界术，能够进入森罗万象尽数停止的“止界”。某天，主人公树里的外甥和哥哥，被诱拐犯绑架了。她为了救出他们而不得已使用了“止界术”，却遭到不应存在于那里的、除自己以外的“会动的”人类袭击。他们是尊崇止界术的「真纯实爱会」。围绕着使用止界术时所必需的“石头”，止界之谜、佑河家之谜逐渐浮出水面…… 制作人员： 原作：堀尾省太 导演：大桥誉志光 脚本：猪爪慎一、木村畅、高木圣子 分镜：汤川敦之、寺冈岩、难波日登志 ","date":"2018-01-07","objectID":"/anime/kokkoku/:1:0","tags":null,"title":"刻刻","uri":"/anime/kokkoku/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佑河树里 佑河 樹里、ゆかわ じゅり、Yukawa Juri 女 安済知佳 2 爷爷 男 山路和弘 3 间岛翔子 間島 翔子、まじま しょうこ、Majima Shoko 女 瀬戸麻沙美 4 佐河顺治 佐河 順治、さがわ じゅんじ、Sagawa Junji 男 郷田ほづみ 5 佑河贵文 佑河 貴文、ゆかわ たかふみ、Yukawa Sakafumi 男 辻谷耕史 6 佑河翼 佑河 翼、ゆかわ つばさ、Yukawa Tsubasa 男 野島裕史 7 佑河真 佑河 真、ゆかわ まこと、Yukawa Makoto 男 岩田龍門 8 迫 さこ、Sako 男 吉野裕行 ","date":"2018-01-07","objectID":"/anime/kokkoku/:2:0","tags":null,"title":"刻刻","uri":"/anime/kokkoku/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 刻刻 2018-01-07 12 bilibili ","date":"2018-01-07","objectID":"/anime/kokkoku/:3:0","tags":null,"title":"刻刻","uri":"/anime/kokkoku/"},{"categories":null,"content":"随着恶魔觉醒，人类世界陷入混乱。性格温柔的男孩与恶魔合体，在神秘好友飞鸟了的指引下，卷入一场残酷、堕落的对抗邪恶之战。","date":"2018-01-05","objectID":"/anime/devilman_crybaby/","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":"简介 随着恶魔觉醒，人类世界陷入混乱。性格温柔的男孩与恶魔合体，在神秘好友飞鸟了的指引下，卷入一场残酷、堕落的对抗邪恶之战。 制作人员： 原作：永井豪 导演：汤浅政明 脚本：大河内一楼 分镜：筱原启辅、许平康、Abel Gongora、柴田胜纪、霜山朋久 ","date":"2018-01-05","objectID":"/anime/devilman_crybaby/:1:0","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 不动明 ふどう あきら、Fudou Akira 男 内山昂輝 2 飞鸟了 あすか りょう、Asuka Ryo 男 村瀬歩 3 牧村美树 牧村ミキ、まきむら みき、Makimura Miki 女 潘めぐみ 4 美子 黒田美樹、Mi-ko 女 小清水亜美 5 死丽濡 Silene 女 田中敦子 6 槐梦 Kaimu 男 小山力也 7 ゼノン Zenon 男 アヴちゃん 8 长崎光司 ながさき こうじ、Nagasaki Kōji 男 津田健次郎 ","date":"2018-01-05","objectID":"/anime/devilman_crybaby/:2:0","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 恶魔人 crybaby 2018-01-05 10 樱花 ","date":"2018-01-05","objectID":"/anime/devilman_crybaby/:3:0","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":"MAD ","date":"2018-01-05","objectID":"/anime/devilman_crybaby/:4:0","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":"这是，某个冬日的故事。\n从静冈搬家到山梨的女高中生·抚子，为了观赏“在千圆纸币上都有图案的富士山”而骑着自行车来到本栖湖，但不巧天气是阴天。没能看到富士山，十分疲倦的抚子当场进入了梦乡。当她醒来的时候，时间已是深夜。在这初来乍到的地方，连回去的路都不知道。拯救了不安而害怕的抚子的是，一位爱好露营的女孩子·凛。为了让寒冷的身体取暖而点燃篝火的两人。噼啪噼啪的柴火爆音，沁入湖畔的静寂之中。围着篝火，一边啜着咖喱面一边对话的抚子和凛。终于，两人期盼已久的瞬间到来。\n“看到了……富士山……”\n抚子与凛，从这两人的相遇开始的户外系Girls Story。","date":"2018-01-04","objectID":"/anime/yuru_camp/","tags":null,"title":"摇曳露营△","uri":"/anime/yuru_camp/"},{"categories":null,"content":"简介 这是，某个冬日的故事。 从静冈搬家到山梨的女高中生·抚子，为了观赏“在千圆纸币上都有图案的富士山”而骑着自行车来到本栖湖，但不巧天气是阴天。没能看到富士山，十分疲倦的抚子当场进入了梦乡。当她醒来的时候，时间已是深夜。在这初来乍到的地方，连回去的路都不知道。拯救了不安而害怕的抚子的是，一位爱好露营的女孩子·凛。为了让寒冷的身体取暖而点燃篝火的两人。噼啪噼啪的柴火爆音，沁入湖畔的静寂之中。围着篝火，一边啜着咖喱面一边对话的抚子和凛。终于，两人期盼已久的瞬间到来。 “看到了……富士山……” 抚子与凛，从这两人的相遇开始的户外系Girls Story。 制作人员： 原作：中村祥启 导演：京极义昭","date":"2018-01-04","objectID":"/anime/yuru_camp/:1:0","tags":null,"title":"摇曳露营△","uri":"/anime/yuru_camp/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 齐藤惠那 斉藤 恵那、さいとう えな、Saitō Ena 女 高橋李依 2 志摩凛 志摩 リン、しま リン、Shima Rin、芝麻凛 女 東山奈央 3 各务原抚子 各務原 なでしこ、かがみはら なでしこ、Kagamihara Nadeshiko 女 花守ゆみり 4 大垣千明 大垣 千明、おおがき ちあき、Ōgaki Chiaki 女 原紗友里 5 犬山葵 犬山 あおい、いぬやま あおい、Inuyama Aoi 女 豊崎愛生 6 各务原樱 各務原 桜、かがみはら さくら、Kagamihara Sakura 女 井上麻里奈 7 鸟羽美波 鳥羽 美波、とば みな","date":"2018-01-04","objectID":"/anime/yuru_camp/:2:0","tags":null,"title":"摇曳露营△","uri":"/anime/yuru_camp/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 摇曳露营△ 2018-01-04 12 acfun 2 摇曳露营△ 第二季 2021-01-07 13 acfun 3 电影 摇曳露营△ 2022-07-01 1 bilibili ","date":"2018-01-04","objectID":"/anime/yuru_camp/:3:0","tags":null,"title":"摇曳露营△","uri":"/anime/yuru_camp/"},{"categories":null,"content":"小男孩米格（安东尼·冈萨雷斯 Anthony Gonzalez 配音）一心梦想成为音乐家，更希望自己能和偶像歌神德拉库斯（本杰明·布拉特 Benjamin Bratt 配音）一样，创造出打动人心的音乐，但他的家族却世代禁止族人接触音乐。米格痴迷音乐，无比渴望证明自己的音乐才能，却因为一系列怪事，来到了五彩斑斓又光怪陆离的神秘世界。在那里，米格遇见了魅力十足的落魄乐手埃克托（盖尔·加西亚·贝纳尔 Gael García Bernal 配音），他们一起踏上了探寻米格家族不为人知往事的奇妙之旅，并开启了一段震撼心灵、感动非凡、永生难忘的旅程。","date":"2017-11-22","objectID":"/anime/coco/","tags":null,"title":"寻梦环游记","uri":"/anime/coco/"},{"categories":null,"content":"简介 小男孩米格（安东尼·冈萨雷斯 Anthony Gonzalez 配音）一心梦想成为音乐家，更希望自己能和偶像歌神德拉库斯（本杰明·布拉特 Benjamin Bratt 配音）一样，创造出打动人心的音乐，但他的家族却世代禁止族人接触音乐。米格痴迷音乐，无比渴望证明自己的音乐才能，却因为一系列怪事，来到了五彩斑斓又光怪陆离的神秘世界。在那里，米格遇见了魅力十足的落魄乐手埃克托（盖尔·加西亚·贝纳尔 Gael García Bernal 配音），他们一起踏上了探寻米格家族不为人知往事的奇妙之旅，并开启了一段震撼心灵、感动非凡、永生难忘的旅程。 制作人员： 制作：迪士尼电影公司 动画制作：皮克斯","date":"2017-11-22","objectID":"/anime/coco/:1:0","tags":null,"title":"寻梦环游记","uri":"/anime/coco/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 米格尔 男 Anthony Gonzalez ","date":"2017-11-22","objectID":"/anime/coco/:2:0","tags":null,"title":"寻梦环游记","uri":"/anime/coco/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 寻梦环游记 2017-11-22 1 樱花 ","date":"2017-11-22","objectID":"/anime/coco/:3:0","tags":null,"title":"寻梦环游记","uri":"/anime/coco/"},{"categories":null,"content":"「如果有妹妹的话就能拥有最棒的人生了，为什么我却没有妹妹呢……？」\n专写妹系作品的妹控小说家羽岛伊月，身边聚集着各式各样不同个性的人物。有天才变态作家可儿那由多、女大学生白川京、插画家屁桃，以及鬼畜税务师大野艾希莉等等。\n伊月等人虽然各自有着不同的烦恼，但还是一边写着小说，玩着电玩，喝着酒，申报所得税，过着喧闹的日常生活。\n在一旁温暖守护着伊月等人的，是伊月的继弟千寻。然而，千寻竟藏着一个天大的秘密……\n欢乐又锥心，由天才、凡人与怪咖所展开的多重路线青春恋爱喜剧，现在开演！","date":"2017-10-08","objectID":"/anime/a_sisters_all_you_need/","tags":null,"title":"如果有妹妹就好了。","uri":"/anime/a_sisters_all_you_need/"},{"categories":null,"content":"简介 「如果有妹妹的话就能拥有最棒的人生了，为什么我却没有妹妹呢……？」 专写妹系作品的妹控小说家羽岛伊月，身边聚集着各式各样不同个性的人物。有天才变态作家可儿那由多、女大学生白川京、插画家屁桃，以及鬼畜税务师大野艾希莉等等。 伊月等人虽然各自有着不同的烦恼，但还是一边写着小说，玩着电玩，喝着酒，申报所得税，过着喧闹的日常生活。 在一旁温暖守护着伊月等人的，是伊月的继弟千寻。然而，千寻竟藏着一个天大的秘密…… 欢乐又锥心，由天才、凡人与怪咖所展开的多重路线青春恋爱喜剧，现在开演！ 制作人员： 原作：平坂读 导演：大沼心 分镜：宇根信也、渡边慎一、二瓶勇一、玉村仁、泽井幸次、凑未来 ","date":"2017-10-08","objectID":"/anime/a_sisters_all_you_need/:1:0","tags":null,"title":"如果有妹妹就好了。","uri":"/anime/a_sisters_all_you_need/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 羽岛伊月 はしま いつき、Hashima Itsuki 男 小林裕介 2 羽岛千寻 はしま ちひろ、Hashima Chihiro 女 山本希望 3 可儿那由多 かに なゆた、Kani Nayuta、螃蟹公、本田和子、ほんでんかずこ、羽岛和子 女 金元寿子 4 白川京 しらかわ みやこ、Shirakawa Miyako 女 加隈亜衣 5 不破春斗 松尾晴彦、ふわ はると、Fuwa Haruto 男 日野聡 6 土岐健次郎 とき けんじろう、Toki Kenjirō 男 鳥海浩輔 7 惠那刹那 恵那 刹那、えな せつな、Ena Setsuna 男 代永翼 8 ","date":"2017-10-08","objectID":"/anime/a_sisters_all_you_need/:2:0","tags":null,"title":"如果有妹妹就好了。","uri":"/anime/a_sisters_all_you_need/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 如果有妹妹就好了。 2017-10-08 12 樱花 ","date":"2017-10-08","objectID":"/anime/a_sisters_all_you_need/:3:0","tags":null,"title":"如果有妹妹就好了。","uri":"/anime/a_sisters_all_you_need/"},{"categories":null,"content":"这是成长的故事——\n宝石中最年少的磷叶石，仅有3.5的脆弱硬度，韧性也很弱，因而不适于战斗。此外，也没有对其他工作的适应性。被看做是只会出一张嘴，完完全全的吊车尾。这样的磷叶石，在即将满三百岁时终于被交付了第一件工作。那是，名为编纂博物志的工作。磷叶石对这不起眼的工作感到不满，但他在通过自己的双眼看见世界，经历各种各样事情的同时，接连被巨大的波澜吞没。之后，他终于获得了梦寐以求的“强大”，却并非是以自己所期望的形式——\n\n这是友情的故事——\n拥有比磷叶石更为特殊的体质的辰砂。仅仅是在那里，身体就会散播毒液的辰砂，为了不给周围人添麻烦，而在夜晚独自将自己关在室内，并封锁了心灵。某天，就在即将被月人掳走时被辰砂所救的磷叶石，和他做了“接下来就该我来救你了”的约定。磷叶石一边为编纂博物志而奔走，一边为了将辰砂带往光明的世界而寻找着适合他的工作。究竟磷叶石的想法能否传达给辰砂呢？两人的约定究竟会不会有实现的一天呢——？\n\n这是战斗的故事——\n从月球飞来的神秘敌人“月人”。他们将宝石作为装饰品，特别中意美丽的宝石，将宝石们一个接一个地掳走，真实身份不明。而且被掳走的宝石被加工成为武器，反过来加害于宝石。得到月人的不断改良，变得更加强力。面对接连现身的月人，二十八位宝石能否赢得胜利？他们的真正目的是什么？这场无止境的战斗，能否画下终止符？","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"简介 这是成长的故事—— 宝石中最年少的磷叶石，仅有3.5的脆弱硬度，韧性也很弱，因而不适于战斗。此外，也没有对其他工作的适应性。被看做是只会出一张嘴，完完全全的吊车尾。这样的磷叶石，在即将满三百岁时终于被交付了第一件工作。那是，名为编纂博物志的工作。磷叶石对这不起眼的工作感到不满，但他在通过自己的双眼看见世界，经历各种各样事情的同时，接连被巨大的波澜吞没。之后，他终于获得了梦寐以求的“强大”，却并非是以自己所期望的形式—— 这是友情的故事—— 拥有比磷叶石更为特殊的体质的辰砂。仅仅是在那里，身体就会散播毒液的辰砂，为了不给周围人添麻烦，而在夜晚独自将自己关在室内，并封锁了心灵。某天，就在即将","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/:1:0","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 磷叶石 法斯、Phosphophyllite 黒沢ともよ 2 辰砂 朱砂、Cinnabar 小松未可子 3 钻石 Diamond 茅野愛衣 4 圆粒金刚石 波尔茨、Bort 佐倉綾音 5 摩根石 Morganite 田村睦心 6 透绿柱石 Goshenite 早見沙織 7 金红石 Rutile 内山夕実 8 翡翠 Jade 高垣彩陽 ","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/:2:0","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 宝石之国 2017-10-07 12 bilibili ","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/:3:0","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"MAD ","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/:4:0","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"距离极尽繁荣与荣华的人类文明迎来末日，已经经过了漫长的岁月。人类几乎死绝，就连生物都消失的迎来末日的世界。复杂建造的都市化作宛如迷宫的废墟，无从整备的机械也渐渐停止了动作。是何时结束的呢，是从何时开始结束的呢，就连这种想法也不复存在的终末世界中，有两位少女漫无目的地持续着旅行。千户与尤莉，今天也乘着爱车Kettenkrad，在废墟当中彷徨。\n在终末世界中温暖地求生的后启示录幻想剧，就此开幕。","date":"2017-10-06","objectID":"/anime/girls_last_tour/","tags":null,"title":"少女终末旅行","uri":"/anime/girls_last_tour/"},{"categories":null,"content":"简介 距离极尽繁荣与荣华的人类文明迎来末日，已经经过了漫长的岁月。人类几乎死绝，就连生物都消失的迎来末日的世界。复杂建造的都市化作宛如迷宫的废墟，无从整备的机械也渐渐停止了动作。是何时结束的呢，是从何时开始结束的呢，就连这种想法也不复存在的终末世界中，有两位少女漫无目的地持续着旅行。千户与尤莉，今天也乘着爱车Kettenkrad，在废墟当中彷徨。 在终末世界中温暖地求生的后启示录幻想剧，就此开幕。 制作人员： 原作：月水 导演：尾崎隆晴 脚本：笔安一幸 分镜：迫井政行、小泽一浩、川村贤一 演出：三上喜子 ","date":"2017-10-06","objectID":"/anime/girls_last_tour/:1:0","tags":null,"title":"少女终末旅行","uri":"/anime/girls_last_tour/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 千户 千都、Chito 女 水瀬いのり 2 尤莉 优梨、Yūri 女 久保ユリカ 3 金泽 Kanazawa 男 石田彰 4 石井 Ishii 女 三石琴乃 5 自律机械 じりつ きかい、Jiritsu-kikai 梶裕貴 6 锚 猫、Nuko 花澤香菜 ","date":"2017-10-06","objectID":"/anime/girls_last_tour/:2:0","tags":null,"title":"少女终末旅行","uri":"/anime/girls_last_tour/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 少女终末旅行 2017-10-06 12 bilibili ","date":"2017-10-06","objectID":"/anime/girls_last_tour/:3:0","tags":null,"title":"少女终末旅行","uri":"/anime/girls_last_tour/"},{"categories":null,"content":"       高中三年级的冬天、剩下没多久的高中生活，大家都认为会在毫无变化的情况下迎来毕业之日……但在某一天，他突然回来了，在中学时搬到遥远城镇的同学，变成不合时节的转学生再次相会，伴随着某种不确定的感情、转变开始的信号微弱的发出了声响……","date":"2017-10-05","objectID":"/anime/just_because/","tags":null,"title":"Just Because!","uri":"/anime/just_because/"},{"categories":null,"content":"简介 高中三年级的冬天、剩下没多久的高中生活，大家都认为会在毫无变化的情况下迎来毕业之日……但在某一天，他突然回来了，在中学时搬到遥远城镇的同学，变成不合时节的转学生再次相会，伴随着某种不确定的感情、转变开始的信号微弱的发出了声响…… 制作人员： 导演：小林敦 脚本：鸭志田一 分镜：吉田泰三、羽多野浩平、冲田宫奈、长井春树、川畑荣郎、林直孝 ","date":"2017-10-05","objectID":"/anime/just_because/:1:0","tags":null,"title":"Just Because!","uri":"/anime/just_because/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 泉瑛太 いずみ えいた、Izumi Eita 男 市川蒼 2 夏目美绪 なつめ みお、Natsume Mio 女 礒部花凜 3 相马阳斗 そうま ようと、Sōma Haruto 男 村田太志 4 森川叶月 もりかわ はつき、Morikawa Hazuki 女 芳野由奈 5 小宫惠那 こみや えな、Komiya Ena 女 Lynn 6 乾依子 Inui Yoriko 女 櫻庭有紗 7 高桥早苗 Takahashi Sanae 女 貫井柚佳 8 铃木桃花 Suzuki Momoka 女 近藤玲奈 ","date":"2017-10-05","objectID":"/anime/just_because/:2:0","tags":null,"title":"Just Because!","uri":"/anime/just_because/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Just Because! 2017-10-05 12 bilibili ","date":"2017-10-05","objectID":"/anime/just_because/:3:0","tags":null,"title":"Just Because!","uri":"/anime/just_because/"},{"categories":null,"content":"每十二年举办一次的，第十二回“十二大战”。\n持有干支之名的十二名狞猛战士，以自己的性命与灵魂为赌注的战斗。\n参加者是『子』『丑』『寅』『卯』『辰』『巳』『午』『未』『申』『酉』『戌』『亥』的十二位异样的战士们。\n\n摘得这场战争的胜果的人，任何愿望都可以成真，但数额只有一个。\n无论如何都想要成真的、那仅此一个的愿望——\n\n最后活下来的会是谁？在谋策与杀戮的战场漩涡之中，流下的是谁的泪水？\n震撼灵魂的盛大战斗，即将开战。","date":"2017-10-03","objectID":"/anime/juni_taisen/","tags":null,"title":"十二大战","uri":"/anime/juni_taisen/"},{"categories":null,"content":"简介 每十二年举办一次的，第十二回“十二大战”。 持有干支之名的十二名狞猛战士，以自己的性命与灵魂为赌注的战斗。 参加者是『子』『丑』『寅』『卯』『辰』『巳』『午』『未』『申』『酉』『戌』『亥』的十二位异样的战士们。 摘得这场战争的胜果的人，任何愿望都可以成真，但数额只有一个。 无论如何都想要成真的、那仅此一个的愿望—— 最后活下来的会是谁？在谋策与杀戮的战场漩涡之中，流下的是谁的泪水？ 震撼灵魂的盛大战斗，即将开战。 制作人员： 原作：西尾维新 导演：细田直人 脚本：高桥龙也、高木登、山田哲弥、村井贞之 分镜：牧原亮太郎、原博 ","date":"2017-10-03","objectID":"/anime/juni_taisen/:1:0","tags":null,"title":"十二大战","uri":"/anime/juni_taisen/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 寝住 ねずみ、墨野継義（すみの つぎよし） 男 堀江瞬 2 失井 うしい、樫井栄児（かしい えいじ） 男 梅原裕一郎 3 妬良 姶良香奈江（あいら かなえ）、とら 女 五十嵐裕美 4 郁城 うさぎ 男 岡本信彦 5 断罪·兄 積田長幸（つみた ながゆき）、たつみ 男 江口拓也 6 断罪·弟 積田剛保（つみた たけやす）、たつみ 男 鳥海浩輔 7 迂迂真 早間好実（そうま よしみ）、ううま 男 緑川光 8 必爷 辻家純彦（つじいえ すみひこ）、ひつじい 男 チョー ","date":"2017-10-03","objectID":"/anime/juni_taisen/:2:0","tags":null,"title":"十二大战","uri":"/anime/juni_taisen/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 十二大战 2017-10-03 12 樱花 ","date":"2017-10-03","objectID":"/anime/juni_taisen/:3:0","tags":null,"title":"十二大战","uri":"/anime/juni_taisen/"},{"categories":null,"content":"塔利班残酷统治下的阿富汗，平民百姓尤其是女性过着水深火热犹如地狱一般的生活。倔强的小女孩帕瓦娜（莎拉·乔德利 Saara Chaudry 配音）随父亲（Ali Rizvi Badshah 配音）外出挣钱养家，不仅目睹了父亲被昔日的学生辱骂羞辱，更和家人目击了父亲遭到非法逮捕的一幕。家中有病弱的母亲、成年的姐姐以及嗷嗷待哺的弟弟，年幼的帕瓦娜只能剪去秀发，伪装成男孩走出家门，踏上生死未卜的养家之路。在此过程中，她遇到了同样扮成男孩的昔日伙伴，也与一名沉默魁梧的塔利班分子成为朋友。当战争的阴影再度逼近时，帕瓦娜想方设法要找到下落不明的父亲，将他带回家中……  \n\n本片根据黛博拉·艾里斯的同名小说改编。","date":"2017-09-08","objectID":"/anime/the_breadwinner/","tags":null,"title":"养家之人","uri":"/anime/the_breadwinner/"},{"categories":null,"content":"简介 塔利班残酷统治下的阿富汗，平民百姓尤其是女性过着水深火热犹如地狱一般的生活。倔强的小女孩帕瓦娜（莎拉·乔德利 Saara Chaudry 配音）随父亲（Ali Rizvi Badshah 配音）外出挣钱养家，不仅目睹了父亲被昔日的学生辱骂羞辱，更和家人目击了父亲遭到非法逮捕的一幕。家中有病弱的母亲、成年的姐姐以及嗷嗷待哺的弟弟，年幼的帕瓦娜只能剪去秀发，伪装成男孩走出家门，踏上生死未卜的养家之路。在此过程中，她遇到了同样扮成男孩的昔日伙伴，也与一名沉默魁梧的塔利班分子成为朋友。当战争的阴影再度逼近时，帕瓦娜想方设法要找到下落不明的父亲，将他带回家中…… 本片根据黛博拉·艾里斯的同名小说改","date":"2017-09-08","objectID":"/anime/the_breadwinner/:1:0","tags":null,"title":"养家之人","uri":"/anime/the_breadwinner/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 养家之人 2017-09-08 01:32:55 樱花 ","date":"2017-09-08","objectID":"/anime/the_breadwinner/:2:0","tags":null,"title":"养家之人","uri":"/anime/the_breadwinner/"},{"categories":null,"content":"暑假，某个海边小镇。在烟花晚会之前，热热闹闹的聊着“升空的烟花从侧面看是圆的？还是平的？”这样的话题的同班同学。\n与此同时，典道暗恋着的荠，因为荠的母亲的再婚对象已确定所以要转学了。\n\n「我们私奔、吧」\n荠向典道发出了一起逃出小镇的邀请，却在那之前被母亲带走了。\n而典道只是眼睁睁地看着这一切。\n\n「如果，那时候我……」\n没有救下荠的典道，因为心中的苛责而丢出了荠在海中捡到的不可思议的珠子。就这样，不知何时起，时间被倒回到了荠被带走之前的时候……。\n一次又一次被重复的一天，荠与典道的命运会……？","date":"2017-08-18","objectID":"/anime/fireworks/","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"简介 暑假，某个海边小镇。在烟花晚会之前，热热闹闹的聊着“升空的烟花从侧面看是圆的？还是平的？”这样的话题的同班同学。 与此同时，典道暗恋着的荠，因为荠的母亲的再婚对象已确定所以要转学了。 「我们私奔、吧」 荠向典道发出了一起逃出小镇的邀请，却在那之前被母亲带走了。 而典道只是眼睁睁地看着这一切。 「如果，那时候我……」 没有救下荠的典道，因为心中的苛责而丢出了荠在海中捡到的不可思议的珠子。就这样，不知何时起，时间被倒回到了荠被带走之前的时候……。 一次又一次被重复的一天，荠与典道的命运会……？ 制作人员： 原作：岩井俊二 导演：武内宣之 脚本：大根仁 演出：铃木利正、宫本幸裕、城所圣明、塚田","date":"2017-08-18","objectID":"/anime/fireworks/:1:0","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 及川荠 及川奈砂、及川 なずな、おいかわ なずな、Oikawa Nazuna、及川菜津奈 女 広瀬すず 2 岛田典道 男 菅田将暉 3 安昙祐介 男 宮野真守 4 纯一 男 浅沼晋太郎 5 和弘 男 豊永利行 6 稔 男 梶裕貴 7 荠母亲的再婚对象 奈砂母亲的再婚对象 男 三木眞一郎 8 三浦老师 女 花澤香菜 ","date":"2017-08-18","objectID":"/anime/fireworks/:2:0","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 烟花 2017-08-18 01:30:00 bilibili ","date":"2017-08-18","objectID":"/anime/fireworks/:3:0","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"MAD ","date":"2017-08-18","objectID":"/anime/fireworks/:4:0","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"“……和我一起，试着加入游戏部怎样？”兴趣是游戏，除此之外毫无显眼的特征，仅仅是个龙套的游戏玩家雨野景太，某天突然被学园第一的美少女，游戏部部长天道花怜搭话了。\n由此开始，景太的日常为之一转，开始了与喜爱游戏的美少女们共度的恋爱喜剧展开的日子……本以为如此！？只有游戏的价值观不同，特立独行的女子玩家星之守千秋。班上的中心人物，虽然有女友却私下里爱好游戏的残念现充上原祐。祐的女友，毫无游戏知识的亚玖璃。\n将这些人物一并卷入，重复着互相误会、徒劳无功、陷入迷途，乱成一团的游戏玩家们带来的“擦肩而过青春错综系恋爱喜剧”开幕！","date":"2017-07-13","objectID":"/anime/gamers/","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"简介 “……和我一起，试着加入游戏部怎样？”兴趣是游戏，除此之外毫无显眼的特征，仅仅是个龙套的游戏玩家雨野景太，某天突然被学园第一的美少女，游戏部部长天道花怜搭话了。 由此开始，景太的日常为之一转，开始了与喜爱游戏的美少女们共度的恋爱喜剧展开的日子……本以为如此！？只有游戏的价值观不同，特立独行的女子玩家星之守千秋。班上的中心人物，虽然有女友却私下里爱好游戏的残念现充上原祐。祐的女友，毫无游戏知识的亚玖璃。 将这些人物一并卷入，重复着互相误会、徒劳无功、陷入迷途，乱成一团的游戏玩家们带来的“擦肩而过青春错综系恋爱喜剧”开幕！ 制作人员： 原作：葵关南 导演：冈本学 脚本：内田裕基 分镜：川村贤","date":"2017-07-13","objectID":"/anime/gamers/:1:0","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雨野景太 雨野 景太、あまの けいた、Amano Keita 男 潘めぐみ 2 天道花怜 天道 花憐、てんどう かれん、Tendou Karen 女 金元寿子 3 星之守千秋 星ノ守 千秋、ほしのもり ちあき、Hoshinomori Chiaki 女 石見舞菜香 4 樱野亚玖璃 桜野 亜玖璃、さくらの あぐり、Sakurano Aguri 女 大久保瑠美 5 上原祐 うえはら　たすく、uehara tasuku 男 豊永利行 6 星之守心春 ほしのもり　このは 女 桑原由気 7 三角瑛一 みすみ　えいいち 男 花江夏樹 8 加濑岳人 男 内匠靖明 ","date":"2017-07-13","objectID":"/anime/gamers/:2:0","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 GAMERS电玩咖 2017-07-13 12 bilibili ","date":"2017-07-13","objectID":"/anime/gamers/:3:0","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"MAD ","date":"2017-07-13","objectID":"/anime/gamers/:4:0","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"住在湾岸城镇樱渊市的少年反田野良，在某个春日的上学途中，看到了一位美少女。这位名叫帕特莉西亚的少女乃是冥界的皇女，为了将野良等人所居住的地上生物灭绝而来。当天中午，野良由于某起事件而与帕特莉西亚接吻了。紧接着，野良的身体就变成了一只黑猫。由于帕特莉西亚所拥有的魔力，野良成为了她的眷属。数日后，野良终于可以变回人类的样子，但在那之后他又几次重复变成猫和恢复人形的过程。","date":"2017-07-12","objectID":"/anime/nora_to_oujo_to_noraneko_heart/","tags":null,"title":"野良和皇女和流浪猫之心","uri":"/anime/nora_to_oujo_to_noraneko_heart/"},{"categories":null,"content":"简介 住在湾岸城镇樱渊市的少年反田野良，在某个春日的上学途中，看到了一位美少女。这位名叫帕特莉西亚的少女乃是冥界的皇女，为了将野良等人所居住的地上生物灭绝而来。当天中午，野良由于某起事件而与帕特莉西亚接吻了。紧接着，野良的身体就变成了一只黑猫。由于帕特莉西亚所拥有的魔力，野良成为了她的眷属。数日后，野良终于可以变回人类的样子，但在那之后他又几次重复变成猫和恢复人形的过程。 制作人员： 原作：HARUKAZE 导演：森井健史郎 脚本：はと 分镜：衣谷早知、宫岛星矢、藤森苍、磐田麒麟、雏田悠一、かけひなな ","date":"2017-07-12","objectID":"/anime/nora_to_oujo_to_noraneko_heart/:1:0","tags":null,"title":"野良和皇女和流浪猫之心","uri":"/anime/nora_to_oujo_to_noraneko_heart/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 反田野良 Nora Handa 朝井彩加 2 帕特里夏·奥夫·恩德 Patricia of End 女 高森奈津美 3 黑木未知 黒木 未知、くろき みち、Kuroki Michi 女 仙台エリ 4 夕莉夏琪 夕莉 シャチ、ゆうり しゃち、Yūri Shachi 女 浅川悠 5 明日原优纪 明日原优希、明日原 ユウキ、あすはら ゆうき、Asuhara Yūki 女 種﨑敦美 6 高田信千奈 高田 ノブチナ、たかだ のぶちな、Takada Nobuchina 女 山岡ゆり 7 露西亚·奥夫·恩德 Lucia of End 女 大地葉 8 尤菈夏·奥夫·恩德 E","date":"2017-07-12","objectID":"/anime/nora_to_oujo_to_noraneko_heart/:2:0","tags":null,"title":"野良和皇女和流浪猫之心","uri":"/anime/nora_to_oujo_to_noraneko_heart/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 野良和皇女和流浪猫之心 2017-07-12 12 9anime ","date":"2017-07-12","objectID":"/anime/nora_to_oujo_to_noraneko_heart/:3:0","tags":null,"title":"野良和皇女和流浪猫之心","uri":"/anime/nora_to_oujo_to_noraneko_heart/"},{"categories":null,"content":"这里是梦世界。\n是欲望、希望、绝望成形的，意识与无意识的夹缝间。\n在总是做梦的自己的房间里，再次陷入睡眠的月城遥人，偶然进入了他人的梦境。那是，心灵被囚禁在这梦世界里的魔女们的梦。陷入拒绝现实、逃往梦境、持续睡眠的“睡美人病”当中的，她们的梦的姿态。\n迷失在魔女的梦世界中的遥人，寻找着出口的门，并和她们打着招呼。","date":"2017-07-07","objectID":"/anime/18if/","tags":null,"title":"18if","uri":"/anime/18if/"},{"categories":null,"content":"简介 这里是梦世界。 是欲望、希望、绝望成形的，意识与无意识的夹缝间。 在总是做梦的自己的房间里，再次陷入睡眠的月城遥人，偶然进入了他人的梦境。那是，心灵被囚禁在这梦世界里的魔女们的梦。陷入拒绝现实、逃往梦境、持续睡眠的“睡美人病”当中的，她们的梦的姿态。 迷失在魔女的梦世界中的遥人，寻找着出口的门，并和她们打着招呼。 制作人员： 导演：吉川志我津、大原实、藤井俊郎、高桥幸雄、千明孝一、石山贵明、西森章、森本晃司、数井浩子 ","date":"2017-07-07","objectID":"/anime/18if/:1:0","tags":null,"title":"18if","uri":"/anime/18if/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 月城遥人 Tsukishiro Haruto 男 島﨑信長 2 神崎カツミ Kanzaki Katsumi 男 子安武人 3 リリィ Lily 女 名塚佳織 ","date":"2017-07-07","objectID":"/anime/18if/:2:0","tags":null,"title":"18if","uri":"/anime/18if/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 18if 2017-07-07 13 bilibili ","date":"2017-07-07","objectID":"/anime/18if/:3:0","tags":null,"title":"18if","uri":"/anime/18if/"},{"categories":null,"content":"       在每一个角落都被探索完毕的世界中，唯一残留的秘境——大洞穴“深渊”。不知道延续到何方，深不见底的巨大纵向洞穴，栖息着各种奇妙奇怪的生物们，沉眠着现在的人类无法制造的贵重遗物。“深渊”那充满了不可思议的姿态吸引了人们，并驱使人们展开冒险。如此，多次挑战大洞穴的冒险者们，陆续得到了“探窟家”的名号。\n       住在建造于深渊边缘的城镇“奥斯”的孤儿莉可，梦想着有朝一日成为母亲那样伟大的探窟家，并解开深渊的谜团。这样的某一天，莉可在探索深渊的途中，捡到了有着少年样貌的机器人…？","date":"2017-07-07","objectID":"/anime/made_in_abyss/","tags":null,"title":"来自深渊","uri":"/anime/made_in_abyss/"},{"categories":null,"content":"简介 在每一个角落都被探索完毕的世界中，唯一残留的秘境——大洞穴“深渊”。不知道延续到何方，深不见底的巨大纵向洞穴，栖息着各种奇妙奇怪的生物们，沉眠着现在的人类无法制造的贵重遗物。“深渊”那充满了不可思议的姿态吸引了人们，并驱使人们展开冒险。如此，多次挑战大洞穴的冒险者们，陆续得到了“探窟家”的名号。 住在建造于深渊边缘的城镇“奥斯”的孤儿莉可，梦想着有朝一日成为母亲那样伟大的探窟家，并解开深渊的谜团。这样的某一天，莉可在探索深渊的途中，捡到了有着少年样貌的机器人…？ 制作人员： 原作：土笔章人 导演：小岛正幸 脚本：仓田英之、小柳启伍 分镜：饭野慎也、阿保孝雄 演出：孙承希、森贤 ","date":"2017-07-07","objectID":"/anime/made_in_abyss/:1:0","tags":null,"title":"来自深渊","uri":"/anime/made_in_abyss/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 莉可 梨子、Riko、デコメガネ 女 富田美憂 2 雷格 雷古、Reg 男 伊瀬茉莉也 3 娜娜奇 奈奈祈、Nanachi 不明 井澤詩織 4 波多尔多 黎明卿、新しきボンドルド、邦多尔多、Bondrewd 男 森川智之 5 米蒂 咪蒂、Mitty 女 喜多村英梨 6 莱莎 殲滅卿、殲滅のライザ、莱萨、Lyza 女 坂本真綾 7 西奇 Shiggy 男 沼倉愛美 8 纳特 纳多、纳豆、Nat 男 田村睦心 ","date":"2017-07-07","objectID":"/anime/made_in_abyss/:2:0","tags":null,"title":"来自深渊","uri":"/anime/made_in_abyss/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 来自深渊 2017-07-07 13 樱花 2 来自深渊 深邃的魂之黎明 2020-01-17 1 bilibili 3 来自深渊 烈日的黄金乡 2022-07-06 12 樱花 ","date":"2017-07-07","objectID":"/anime/made_in_abyss/:3:0","tags":null,"title":"来自深渊","uri":"/anime/made_in_abyss/"},{"categories":null,"content":"MAD ","date":"2017-07-07","objectID":"/anime/made_in_abyss/:4:0","tags":null,"title":"来自深渊","uri":"/anime/made_in_abyss/"},{"categories":null,"content":"文藏高中新生欢迎会。\n1年级的越山识，意外地被猜谜研究会要求参加了“新生抢答大赛”。\n就在爱好读书且不喜欢引人注目的识感到慌张的时候，同班的深见真理在谜题读完之前就接连按下按钮，压倒周围的人们。\n“知道答案后再按下去就太迟了。抢答在0.01秒的差距下，就能分出胜败”\n在看着这样的真理的途中，识注意到了“在猜谜当中有着能确定答案的要点”……。\n与猜谜研究会的前辈及伙伴、以及拥有压倒性强大的对手·御来屋千智的相遇，正解时的喜悦，无法按下按钮时的悔恨……\n并不只是知识，也要磨炼各种技术，并与同伴一同以胜利为目标的“竞技猜谜”的世界当中，越山识以猜谜拼上青春的每一天开始了。","date":"2017-07-04","objectID":"/anime/fastest_finger_first/","tags":null,"title":"猜谜王","uri":"/anime/fastest_finger_first/"},{"categories":null,"content":"简介 文藏高中新生欢迎会。 1年级的越山识，意外地被猜谜研究会要求参加了“新生抢答大赛”。 就在爱好读书且不喜欢引人注目的识感到慌张的时候，同班的深见真理在谜题读完之前就接连按下按钮，压倒周围的人们。 “知道答案后再按下去就太迟了。抢答在0.01秒的差距下，就能分出胜败” 在看着这样的真理的途中，识注意到了“在猜谜当中有着能确定答案的要点”……。 与猜谜研究会的前辈及伙伴、以及拥有压倒性强大的对手·御来屋千智的相遇，正解时的喜悦，无法按下按钮时的悔恨…… 并不只是知识，也要磨炼各种技术，并与同伴一同以胜利为目标的“竞技猜谜”的世界当中，越山识以猜谜拼上青春的每一天开始了。 制作人员： 原作：杉","date":"2017-07-04","objectID":"/anime/fastest_finger_first/:1:0","tags":null,"title":"猜谜王","uri":"/anime/fastest_finger_first/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 越山识 こしやま しき、Koshiyama Shiki 男 堀江瞬 2 深见真理 ふかみ まり、Fukami Mari 女 川島海荷 3 御来屋千智 みくりやちさと、Mikuriya Chisato 男 石川界人 4 笹岛学人 ささじま がくと、Sasajima Gakuto 男 佐藤拓也 5 井上大将 井上 大将、いのうえ だいすけ、Inoue Daisuke 男 畠中祐 6 笹岛迅子 笹島 迅子、ささじま じんこ、Sasajima Jinko 女 松田颯水 7 苑原明良 苑原 明良、そのはら あきら、Sonohara Akira 男 永塚拓馬 8 上月由","date":"2017-07-04","objectID":"/anime/fastest_finger_first/:2:0","tags":null,"title":"猜谜王","uri":"/anime/fastest_finger_first/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 猜谜王 2017-07-04 12 樱花 ","date":"2017-07-04","objectID":"/anime/fastest_finger_first/:3:0","tags":null,"title":"猜谜王","uri":"/anime/fastest_finger_first/"},{"categories":null,"content":"住在寂静的渔港小镇日无町的初中少年海，与父亲以及在做阳伞师傅的祖父三人一起生活。他原本住在东京，但随着双亲的离婚而移居到了父母的故乡日无町。无法说出对于父母的复杂心思，海就这么怀着郁闷的心情，在学校也十分地消极。他唯一的生活寄托，就是将自己作曲的音乐上传到网络上。\n一天，他被同班同学国男和游步邀请参加他们组成的乐队“Siren”。他勉强地前往练习地点人鱼岛，在那里，人鱼少女·露出现在3人的面前。显得很愉快地歌唱、天真无邪地起舞的露。随着每天与这样的露共同行动，海也逐渐变得能够将自己的心情说出口了。\n但是，在日无町，人鱼自古以来就是带来灾祸的存在。由于偶然的事件，露与镇民之间产生了巨大的隔阂。随即，危机造访了小镇。海发自内心的呐喊，究竟能否拯救小镇呢？","date":"2017-05-19","objectID":"/anime/lu_over_the_wall/","tags":null,"title":"宣告黎明的露之歌","uri":"/anime/lu_over_the_wall/"},{"categories":null,"content":"简介 住在寂静的渔港小镇日无町的初中少年海，与父亲以及在做阳伞师傅的祖父三人一起生活。他原本住在东京，但随着双亲的离婚而移居到了父母的故乡日无町。无法说出对于父母的复杂心思，海就这么怀着郁闷的心情，在学校也十分地消极。他唯一的生活寄托，就是将自己作曲的音乐上传到网络上。 一天，他被同班同学国男和游步邀请参加他们组成的乐队“Siren”。他勉强地前往练习地点人鱼岛，在那里，人鱼少女·露出现在3人的面前。显得很愉快地歌唱、天真无邪地起舞的露。随着每天与这样的露共同行动，海也逐渐变得能够将自己的心情说出口了。 但是，在日无町，人鱼自古以来就是带来灾祸的存在。由于偶然的事件，露与镇民之间产生了巨大的隔","date":"2017-05-19","objectID":"/anime/lu_over_the_wall/:1:0","tags":null,"title":"宣告黎明的露之歌","uri":"/anime/lu_over_the_wall/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 露 Lu 女 谷花音 2 足元海 Kai 男 下田翔大 3 ルーのパパ 男 篠原信一 4 海老名游步 Yuho 女 寿美菜子 5 国夫 Kunio 男 斉藤壮馬 6 海的祖父 男 柄本明 7 足元照夫 男 鈴村健一 8 伊佐木 女 伊藤静 ","date":"2017-05-19","objectID":"/anime/lu_over_the_wall/:2:0","tags":null,"title":"宣告黎明的露之歌","uri":"/anime/lu_over_the_wall/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 宣告黎明的露之歌 2017-05-19 01:52:13 bilibili ","date":"2017-05-19","objectID":"/anime/lu_over_the_wall/:3:0","tags":null,"title":"宣告黎明的露之歌","uri":"/anime/lu_over_the_wall/"},{"categories":null,"content":"       被称作妖精兵器的少女们与残存的准勇者之间的虚幻而痛切的物语。\n       地上遭到正体不明的怪物“兽”的蹂躏，包括人类在内的多种族被毁灭之后的世界。\n       勉强残存的种族离开地面，移居到名为浮游大陆群（Regulu Ere）的空中群岛上生活。\n       在500年后的空中醒来的威廉·克梅修，在无法守护自己本欲守护之物，甚至仅剩自己一人的绝望之中度过着与世隔绝的生活，但在出乎意料地开展的兵器管理工作当中，他与少女们相遇了。","date":"2017-04-11","objectID":"/anime/world_end/","tags":null,"title":"末日时在做什么？有没有空？可以来拯救吗？","uri":"/anime/world_end/"},{"categories":null,"content":"简介 被称作妖精兵器的少女们与残存的准勇者之间的虚幻而痛切的物语。 地上遭到正体不明的怪物“兽”的蹂躏，包括人类在内的多种族被毁灭之后的世界。 勉强残存的种族离开地面，移居到名为浮游大陆群（Regulu Ere）的空中群岛上生活。 在500年后的空中醒来的威廉·克梅修，在无法守护自己本欲守护之物，甚至仅剩自己一人的绝望之中度过着与世隔绝的生活，但在出乎意料地开展的兵器管理工作当中，他与少女们相遇了。 制作人员： 原作：枯野瑛 导演：和田纯一 脚本：望月真里子、永井真吾、根元岁三 分镜：佐藤英一、池下博纪、安田贤司 ","date":"2017-04-11","objectID":"/anime/world_end/:1:0","tags":null,"title":"末日时在做什么？有没有空？可以来拯救吗？","uri":"/anime/world_end/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 威廉·克梅修 Willem-Kmetsch 男 新井良平 2 珂朵莉·诺塔·瑟尼欧里斯 Chtholly-Nota-Seniorious 女 田所あずさ 3 艾瑟雅·麦杰·瓦尔卡利斯 Ithea-Myse-Valgulious 女 Machico 4 奈芙莲·卢可·因萨尼亚 Nephren Ruq Insania 女 上原あかり 5 兰朵露可·伊瑟利·赫斯托利亚 Rhantolk-Ytri-Historia 女 荒浪和沙 6 诺夫特·K·迪斯佩拉提奥 Nopht-Keh-Desperatio 女 水瀬いのり 7 缇亚特 Tiat 女 水間友美 8 潘丽宝 P","date":"2017-04-11","objectID":"/anime/world_end/:2:0","tags":null,"title":"末日时在做什么？有没有空？可以来拯救吗？","uri":"/anime/world_end/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 末日时在做什么？有没有空？可以来拯救吗？ 2017-04-11 12 樱花 ","date":"2017-04-11","objectID":"/anime/world_end/:3:0","tags":null,"title":"末日时在做什么？有没有空？可以来拯救吗？","uri":"/anime/world_end/"},{"categories":null,"content":"MAD ","date":"2017-04-11","objectID":"/anime/world_end/:4:0","tags":null,"title":"末日时在做什么？有没有空？可以来拯救吗？","uri":"/anime/world_end/"},{"categories":null,"content":"I-MACHINE——这是在极限环境之中进行作业的大型机器人的总称。\n联盟学院的学生·三栗麻耶在使用I-MACHINE时被卷入了一场事故，幸而被同样使用I-MACHINE来采掘“欧利哈尔特矿石”的一批人救下，并坐上了他们的宇宙船。\n就这样成为了实际上等同于宇宙海盗的埃斯卡维特公司的“职员”之一……。","date":"2017-04-09","objectID":"/anime/id-0/","tags":null,"title":"ID-0","uri":"/anime/id-0/"},{"categories":null,"content":"简介 I-MACHINE——这是在极限环境之中进行作业的大型机器人的总称。 联盟学院的学生·三栗麻耶在使用I-MACHINE时被卷入了一场事故，幸而被同样使用I-MACHINE来采掘“欧利哈尔特矿石”的一批人救下，并坐上了他们的宇宙船。 就这样成为了实际上等同于宇宙海盗的埃斯卡维特公司的“职员”之一……。 制作人员： 导演：谷口悟朗 脚本：黑田洋介 分镜：须永司、大桥誉志光、林直孝 演出：松下周平、久保田雄大、野上和男 ","date":"2017-04-09","objectID":"/anime/id-0/:1:0","tags":null,"title":"ID-0","uri":"/anime/id-0/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊度 伊德、Ido、イド機 男 興津和幸 2 三栗麻耶 ミクリ マヤ、Mikuri Maya 女 津田美波 3 柯莱雅·北条 Clair Hojo、クレア ホウジョウ 女 金元寿子 4 谜之少女 女 上田麗奈 5 里克·艾尔 Rick Ayer、リック機、リック エイヤー 男 松風雅也 6 卡菈·米拉·福登 Karla Milla-Foden、カーラ機 女 大原さやか 7 格雷曼 Grayman、グレイマン機 男 小山力也 8 法路泽 Fa-Loser、ファルザ機 小澤亜李 ","date":"2017-04-09","objectID":"/anime/id-0/:2:0","tags":null,"title":"ID-0","uri":"/anime/id-0/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 ID-0 2017-04-09 12 bilibili ","date":"2017-04-09","objectID":"/anime/id-0/:3:0","tags":null,"title":"ID-0","uri":"/anime/id-0/"},{"categories":null,"content":"对学妹“黑发少女”一见倾心的“前辈”，今天也是进行着名为『尽可能进入她的眼帘』的作战——简称“尽(进)她眼作战”。\n春之先斗町、夏之旧书市、秋之学园祭、而后是冬天的到来…。在京都这个城市中，在被卷入充满个性的同伴们所引发的一个个奇妙事件的同时，季节流转。\n只能埋藏于内心的“前辈”的恋心，到底会去向何方！？","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"简介 对学妹“黑发少女”一见倾心的“前辈”，今天也是进行着名为『尽可能进入她的眼帘』的作战——简称“尽(进)她眼作战”。 春之先斗町、夏之旧书市、秋之学园祭、而后是冬天的到来…。在京都这个城市中，在被卷入充满个性的同伴们所引发的一个个奇妙事件的同时，季节流转。 只能埋藏于内心的“前辈”的恋心，到底会去向何方！？ 制作人员： 原作：森见登美彦 导演：汤浅政明 脚本：上田诚 分镜：崔恩映、夏目真悟、大平晋也 演出：许平康 ","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/:1:0","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 前辈 男 星野源 2 黑发少女 女 花澤香菜 3 学园祭事务局长 男 神谷浩史 4 内裤大头目 内裤总番长 男 秋山竜次 5 樋口清太郎 樋口 清太郎、樋口師匠 男 中井和哉 6 羽贯凉子 羽貫さん、羽貫 涼子 女 甲斐田裕子 7 旧书市集之神 古书市的神 男 吉野裕行 8 纪子 須田紀子、須田 紀子 女 新妻聖子 ","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/:2:0","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 春宵苦短，少女前进吧！ 2017-04-07 01:32:35 bilibili ","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/:3:0","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"MAD ","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/:4:0","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"茜与小太郎。\n初三时第一次被分到同班，相识的两人。\n同班同学、社团伙伴、教师、父母……与周围的关联，自己的成长。\n在那个一边被变化与不安追着，一边慌慌张张地向前飞奔的季节之中，稚嫩而又令人眩目的青春期之恋。","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"简介 茜与小太郎。 初三时第一次被分到同班，相识的两人。 同班同学、社团伙伴、教师、父母……与周围的关联，自己的成长。 在那个一边被变化与不安追着，一边慌慌张张地向前飞奔的季节之中，稚嫩而又令人眩目的青春期之恋。 制作人员： 导演：岸诚二 脚本：柿原优子 分镜：及川启、岩崎光洋、浅井义之、平井义通、斋藤德明、平峰义大 ","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/:1:0","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安昙小太郎 あずみ こたろう、Azumi Kotaro 男 千葉翔也 2 水野茜 みずの あかね、Mizuno Akane 女 小原好美 3 比良拓海 ひら たくみ、Hira Takumi 男 田丸篤志 4 西尾千夏 にしお ちなつ、Nishio Chinatsu 女 村川梨衣 5 泷泽葵 たきざわ あおい、Takizawa Aoi 女 白石晴香 6 山科浪漫 やましな ろまん、Yamashina Roman 男 筆村栄心 7 小笠原大地 Daichi Ogasawara 男 金子誠 8 宫本心咲 Aira Miyamoto 女 石見舞菜香 ","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/:2:0","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 月色真美 2017-04-06 12 bilibili ","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/:3:0","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"MAD ","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/:4:0","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"半数居民都拥有特殊能力的街道，咲良田。在负责监视能力者的“管理局”管理下，居民过着和平的生活。“想要消去眼前之人的泪水”、“想要将声音传达给某人”。伴随着这种温柔而又细微的“愿望”，这条街道的能力诞生了。\n拥有能够回想起过去体验过的全部记忆的“记忆保持”能力的浅井惠，以及拥有“最大能够将世界倒带3天”的“重启”能力的春埼美空。她自身也受到“重启”的影响而失去了记忆，但通过与决不会忘记任何事情的惠齐心协力，两人得以将过去重来，并改变现在——\n但，也存在着即使是这样的两人也无法重来的“过去”。那是，两年前同级生相麻堇受到“重启”的影响而消失的事情。\n两人从属于名为“服务社团”的社团活动，一边过着完成学生们各种各样委托的每一天，一边寻找着能够让相麻堇复活的方法。这样的他们收到了一件委托——“希望让死去的猫复活”。\n为了消除在过去发生的“悲哀”，少年与少女穿越时间，前去改变世界——","date":"2017-04-05","objectID":"/anime/sagrada_reset/","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":"简介 半数居民都拥有特殊能力的街道，咲良田。在负责监视能力者的“管理局”管理下，居民过着和平的生活。“想要消去眼前之人的泪水”、“想要将声音传达给某人”。伴随着这种温柔而又细微的“愿望”，这条街道的能力诞生了。 拥有能够回想起过去体验过的全部记忆的“记忆保持”能力的浅井惠，以及拥有“最大能够将世界倒带3天”的“重启”能力的春埼美空。她自身也受到“重启”的影响而失去了记忆，但通过与决不会忘记任何事情的惠齐心协力，两人得以将过去重来，并改变现在—— 但，也存在着即使是这样的两人也无法重来的“过去”。那是，两年前同级生相麻堇受到“重启”的影响而消失的事情。 两人从属于名为“服务社团”的社团活动，一边","date":"2017-04-05","objectID":"/anime/sagrada_reset/:1:0","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 浅井惠 浅井 ケイ、あさい ケイ、Asai Kei 男 石川界人 2 春埼美空 春埼 美空、はるき みそら、Haruki Misora 女 花澤香菜 3 相麻堇 相麻 菫、そうま すみれ、Souma Sumire 女 悠木碧 4 仓川真理 Kurakawa Mari 女 久野美咲 5 中野智树 中野 智樹、なかの ともき、Nakano Tomoki 男 江口拓也 6 皆实未来 皆実 未来、みなみ みらい、Minami Mirai 女 山田悠希 7 村濑阳香 村瀬 陽香、むらせ ようか、Murase Youka 女 牧野由依 8 野之尾盛夏 野ノ尾 盛夏、のの","date":"2017-04-05","objectID":"/anime/sagrada_reset/:2:0","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 重启咲良田 2017-04-05 24 bilibili ","date":"2017-04-05","objectID":"/anime/sagrada_reset/:3:0","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":"MAD ","date":"2017-04-05","objectID":"/anime/sagrada_reset/:4:0","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":" 力扣第 823 题 ","date":"2017-04-02","objectID":"/leetcode/0823/:0:0","tags":null,"title":"0823：带因子的二叉树（★★）","uri":"/leetcode/0823/"},{"categories":null,"content":"题目 给出一个含有不重复整数元素的数组 arr ，每个整数 arr[i] 均大于 1。 用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。 满足条件的二叉树一共有多少个？答案可能很大，返回 对 109 + 7 取余 的结果。 示例 1: 输入: arr = [2, 4]\r输出: 3\r解释: 可以得到这些二叉树: [2], [4], [4, 2, 2]\r示例 2: 输入: arr = [2, 4, 5, 10]\r输出: 7\r解释: 可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [","date":"2017-04-02","objectID":"/leetcode/0823/:1:0","tags":null,"title":"0823：带因子的二叉树（★★）","uri":"/leetcode/0823/"},{"categories":null,"content":"分析 非叶节点显然大于子节点，于是考虑将 arr 排序，然后遍历 arr[j] 作为根节点的情况。 arr[j] 为根节点，然后遍历前面的 arr[i]，如果 arr[j]/arr[i] 也在 arr 中存在，即可转为递归子问题。 为了方便递归，令 dp[x] 代表根节点值为 x 的二叉树个数。x 的值稀疏，因此用哈希表存储。 ","date":"2017-04-02","objectID":"/leetcode/0823/:2:0","tags":null,"title":"0823：带因子的二叉树（★★）","uri":"/leetcode/0823/"},{"categories":null,"content":"解答 def numFactoredBinaryTrees(self, arr: List[int]) -\u003e int: res, mod = 0, 10**9+7 d = defaultdict(lambda: 1) for x in sorted(arr): for y in list(d): if x%y==0 and x//y in d: d[x] = (d[x]+d[y]*d[x//y])%mod res = (res+d[x])%mod return res 240 ms ","date":"2017-04-02","objectID":"/leetcode/0823/:3:0","tags":null,"title":"0823：带因子的二叉树（★★）","uri":"/leetcode/0823/"},{"categories":null,"content":" 力扣第 822 题 ","date":"2017-04-01","objectID":"/leetcode/0822/:0:0","tags":null,"title":"0822：翻转卡片游戏（★）","uri":"/leetcode/0822/"},{"categories":null,"content":"题目 在桌子上有 N 张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。 我们可以先翻转任意张卡片，然后选择其中一张卡片。 如果选中的那张卡片背面的数字 X 与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。 哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0。 其中, fronts[i] 和 backs[i] 分别代表第 i 张卡片的正面和背面的数字。 如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。 示例： 输入：fronts = [1,2,4,4,7","date":"2017-04-01","objectID":"/leetcode/0822/:1:0","tags":null,"title":"0822：翻转卡片游戏（★）","uri":"/leetcode/0822/"},{"categories":null,"content":"分析 先想想暴力做法。比如示例中，先看 fronts+backs 中最小的数 1，发现第一张卡片正面数字必然是 1，故无法满足。 继续看第二小的数 2，发现每张卡片都可以让正面不为 2，故即为所求。 观察发现，对于数字 x，只要一张卡片不是正反面都为 x，那么就可以让正面不为 x。反之，若有一张卡片正反面都为 x，x 必然不满足要求。 因此，只需要去掉所有 fronts[i]==backs[i] 的数字，取剩下的最小数字即可。 ","date":"2017-04-01","objectID":"/leetcode/0822/:2:0","tags":null,"title":"0822：翻转卡片游戏（★）","uri":"/leetcode/0822/"},{"categories":null,"content":"解答 def flipgame(self, fronts: List[int], backs: List[int]) -\u003e int: same = set(front for front, back in zip(fronts, backs) if front==back) tmp = [num for num in fronts+backs if num not in same] return min(tmp) if tmp else 0 时间复杂度 O(N)，120 ms ","date":"2017-04-01","objectID":"/leetcode/0822/:3:0","tags":null,"title":"0822：翻转卡片游戏（★）","uri":"/leetcode/0822/"},{"categories":null,"content":" 力扣第 817 题 ","date":"2017-03-27","objectID":"/leetcode/0817/:0:0","tags":null,"title":"0817：链表组件（★）","uri":"/leetcode/0817/"},{"categories":null,"content":"题目 给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表 nums，该列表是上述链表中整型值的一个子集。 返回列表 nums 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 nums 中）构成的集合。 示例 1： 输入: head = [0,1,2,3], nums = [0,1,3]\r输出: 2\r解释: 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。\r示例 2： 输入: head = [0,1,2,3,4], nums = [0,3","date":"2017-03-27","objectID":"/leetcode/0817/:1:0","tags":null,"title":"0817：链表组件（★）","uri":"/leetcode/0817/"},{"categories":null,"content":"分析 遍历链表，计数连续的段数即可，这里连续的定义是相邻节点都在 G 中。 ","date":"2017-03-27","objectID":"/leetcode/0817/:2:0","tags":null,"title":"0817：链表组件（★）","uri":"/leetcode/0817/"},{"categories":null,"content":"解答 def numComponents(self, head: ListNode, nums: List[int]) -\u003e int: cnt, nums = 0, set(nums) while head: if head.val in nums: cnt += 1 while head.next and head.next.val in nums: head = head.next head = head.next return cnt 96 ms ","date":"2017-03-27","objectID":"/leetcode/0817/:3:0","tags":null,"title":"0817：链表组件（★）","uri":"/leetcode/0817/"},{"categories":null,"content":" 力扣第 814 题 ","date":"2017-03-24","objectID":"/leetcode/0814/:0:0","tags":null,"title":"0814：二叉树剪枝","uri":"/leetcode/0814/"},{"categories":null,"content":"题目 给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。 返回移除了所有不包含 1 的子树的原二叉树。 节点 node 的子树为 node 本身加上所有 node 的后代。 示例 1： 输入：root = [1,null,0,0,1]\r输出：[1,null,0,null,1]\r解释：\r只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。\r示例 2： 输入：root = [1,0,1,0,0,0,1]\r输出：[1,null,1,null,1]\r示例 3： 输入：root = [1,1,0,1,1,0,1,0]\r输出：[1,1,0,1,1,null,1","date":"2017-03-24","objectID":"/leetcode/0814/:1:0","tags":null,"title":"0814：二叉树剪枝","uri":"/leetcode/0814/"},{"categories":null,"content":"分析 递归即可，若 node 剪枝后的左子树或右子树非空或者根节点为 1，则代表 node 包含 1，否则返回 None。 ","date":"2017-03-24","objectID":"/leetcode/0814/:2:0","tags":null,"title":"0814：二叉树剪枝","uri":"/leetcode/0814/"},{"categories":null,"content":"解答 def pruneTree(self, root: TreeNode) -\u003e TreeNode: def help(node): if not node: return None node.left, node.right = help(node.left), help(node.right) return node if node.left or node.right or node.val==1 else None return help(root) 32 ms ","date":"2017-03-24","objectID":"/leetcode/0814/:3:0","tags":null,"title":"0814：二叉树剪枝","uri":"/leetcode/0814/"},{"categories":null,"content":" 力扣第 813 题 ","date":"2017-03-23","objectID":"/leetcode/0813/:0:0","tags":null,"title":"0813：最大平均值和的分组（★★）","uri":"/leetcode/0813/"},{"categories":null,"content":"题目 给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。 注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。 返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。 示例 1: 输入: nums = [9,1,2,3,9], k = 3\r输出: 20.00000\r解释:\rnums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20.\r我们也可以把 nums 分成[9, 1]","date":"2017-03-23","objectID":"/leetcode/0813/:1:0","tags":null,"title":"0813：最大平均值和的分组（★★）","uri":"/leetcode/0813/"},{"categories":null,"content":"分析 按最后一组的长度即可转为递归子问题。 可以用前缀和优化递推过程。 ","date":"2017-03-23","objectID":"/leetcode/0813/:2:0","tags":null,"title":"0813：最大平均值和的分组（★★）","uri":"/leetcode/0813/"},{"categories":null,"content":"解答 def largestSumOfAverages(self, nums: List[int], k: int) -\u003e float: @lru_cache(None) def dfs(j, k): if j == 0: return 0 if k == 0: return float('-inf') return max((pre[j]-pre[i])/(j-i)+dfs(i, k-1) for i in range(j)) n, pre = len(nums), list(accumulate([0]+nums)) return dfs(n, k) 232 ms ","date":"2017-03-23","objectID":"/leetcode/0813/:3:0","tags":null,"title":"0813：最大平均值和的分组（★★）","uri":"/leetcode/0813/"},{"categories":null,"content":" 力扣第 810 题 ","date":"2017-03-20","objectID":"/leetcode/0810/:0:0","tags":null,"title":"0810：黑板异或游戏（★★★）","uri":"/leetcode/0810/"},{"categories":null,"content":"题目 黑板上写着一个非负整数数组 nums[i] 。 Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。 并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0 ，这个玩家获胜。 假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。 示例 1： 输入: nums = [1,1,2] 输出: false 解释: Alice 有两个选择: 擦掉数字 1 或 2。 如果","date":"2017-03-20","objectID":"/leetcode/0810/:1:0","tags":null,"title":"0810：黑板异或游戏（★★★）","uri":"/leetcode/0810/"},{"categories":null,"content":"分析 先考虑最终状态，设 f(nums) 代表 nums 所有数字的异或结果，最后一轮没擦之前的数字列表是 A。 那么胜利条件是 f(A)==0。失败条件则是任选一数字，剩下的异或运算为 0，等价于： all(f(A+[a])==0 for a in A) 此时必然有 f(A*len(A)+[a for a in A]) == 0 即 f(A*(len(A)+1)) == 0 len(A) 为奇数时式子成立，可能满足失败条件 len(A) 为偶数时左侧 = f(A)，若 f(A)==0 直接就胜利了，若 f(A)!=0 也不满足失败条件。 因此 len(A) 为偶数时，不可能是最后的失败状态。","date":"2017-03-20","objectID":"/leetcode/0810/:2:0","tags":null,"title":"0810：黑板异或游戏（★★★）","uri":"/leetcode/0810/"},{"categories":null,"content":"解答 def xorGame(self, nums: List[int]) -\u003e bool: return len(nums)%2==0 or reduce(lambda x,y: x^y, nums)==0 80 ms ","date":"2017-03-20","objectID":"/leetcode/0810/:3:0","tags":null,"title":"0810：黑板异或游戏（★★★）","uri":"/leetcode/0810/"},{"categories":null,"content":" 力扣第 808 题 ","date":"2017-03-18","objectID":"/leetcode/0808/:0:0","tags":null,"title":"0808：分汤（★★★）","uri":"/leetcode/0808/"},{"categories":null,"content":"题目 有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作： 提供 100ml 的 汤A 和 0ml 的 汤B 。\r提供 75ml 的 汤A 和 25ml 的 汤B 。\r提供 50ml 的 汤A 和 50ml 的 汤B 。\r提供 25ml 的 汤A 和 75ml 的 汤B 。\r当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。 注意 不存在先分配 100 ml 汤B 的操作。 需要返回的值： 汤A 先分配完的概率 + 汤A和汤B ","date":"2017-03-18","objectID":"/leetcode/0808/:1:0","tags":null,"title":"0808：分汤（★★★）","uri":"/leetcode/0808/"},{"categories":null,"content":"分析 容易想到用递归，令 dfs(a, b) 代表初始汤 A、B 分别 a、b 毫升时对应的概率，即可递归。 问题在于 n 的范围较大，会超时。观察发现，当 n 够大时，结果会趋近于 1。 于是找到 n=5000 时，结果与 1 的差别不超过 10^-5，所以不需要计算 n\u003e=5000 的情况。 ","date":"2017-03-18","objectID":"/leetcode/0808/:2:0","tags":null,"title":"0808：分汤（★★★）","uri":"/leetcode/0808/"},{"categories":null,"content":"解答 def soupServings(self, n: int) -\u003e float: @lru_cache(None) def dfs(a, b): if a==0 or b==0: return 0.5 if a==b==0 else int(a==0) return sum(dfs(max(0, a-(4-x)*25), max(0, b-x*25)) for x in range(4)) / 4 return dfs(n, n) if n\u003c5000 else 1.0 52 ms ","date":"2017-03-18","objectID":"/leetcode/0808/:3:0","tags":null,"title":"0808：分汤（★★★）","uri":"/leetcode/0808/"},{"categories":null,"content":" 力扣第 805 题 ","date":"2017-03-15","objectID":"/leetcode/0805/:0:0","tags":null,"title":"0805：数组的均值分割（★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"题目 给定你一个整数数组 nums 我们要将 nums 数组中的每个元素移动到 A 数组 或者 B 数组中，使得 A 数组和 B 数组不为空，并且 average(A) == average(B) 。 如果可以完成则返回true ， 否则返回 false 。 注意：对于数组 arr , average(arr) 是 arr 的所有元素的和除以 arr 长度。 示例 1: 输入: nums = [1,2,3,4,5,6,7,8]\r输出: true\r解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。\r示例 2: 输入: nums = [3,1]\r输","date":"2017-03-15","objectID":"/leetcode/0805/:1:0","tags":null,"title":"0805：数组的均值分割（★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"分析 ","date":"2017-03-15","objectID":"/leetcode/0805/:2:0","tags":null,"title":"0805：数组的均值分割（★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"#1 类似 0416，不过分割条件从和相等变成了平均数相等。 什么情况下两者等价？平均数为 0 的时候。于是有个巧妙的想法： 将 nums 的数都减去平均数得到新数组 A，问题就等价于将 A 分割为和相等的两部分。 注意平均数可能为浮点数，为了精确，可以将 nums 的数都先乘以一个合适的 mul 使得平均数为整数。 转换完成后递推子集和的集合找 0 即可。 注意不能选取整个 A，因此考虑只遍历 A[:-1]，假如没有得到 0，即非真。证明： 假如 A[:-1] 的子集和都不为 0，那么 A[:-1] 的任意真子集 A’ 的和不等于 sum(A[:-1])（因为 A[:-1]-A’ 的和不为 ","date":"2017-03-15","objectID":"/leetcode/0805/:2:1","tags":null,"title":"0805：数组的均值分割（★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"#2 还可以类似 0416 的状压优化方法，将集合状态压缩为一个数 state，优化递推时间。 这里有个问题是集合中有负数，不能压缩到 state 中。一个巧妙的想法是： 先遍历正数，再遍历负数 那么遇到某个子集和为负数时，必然已经遍历到负数，那么后面不可能变为 0 了，无需保存 所以只维护非负数的集合即可，可以压缩为 state ","date":"2017-03-15","objectID":"/leetcode/0805/:2:2","tags":null,"title":"0805：数组的均值分割（★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"解答 def splitArraySameAverage(self, nums: List[int]) -\u003e bool: n, s = len(nums), sum(nums) mul = n//gcd(n, s) A = [num*mul-mul*s//n for num in nums] st = 0 for x in sorted(A[:-1], reverse=True): st |= (st|1)\u003c\u003cx if x\u003e=0 else st\u003e\u003e(-x) if st \u0026 1: return True return False 36 ms ","date":"2017-03-15","objectID":"/leetcode/0805/:3:0","tags":null,"title":"0805：数组的均值分割（★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"*附加 本题还有个经典的优化方法，折半搜索： 先遍历 A 的前半部分 B=A[:n//2]，得到所有子集和的集合 S 如果 S 中没有 0，再遍历 A 的后半部分 C=A[n//2:]，得到所有子集和的集合 S2 如果 S2 中也没有 0，那遍历 S2 中 的 x，判断 -x 是否在 S 中即可。 注意不能选取整个 A，所以不考虑 x=sum(C) 的情况。证明： C 的子集和都不为 0，那么 C 的任意真子集的和不等于 sum(C) 因此 x=sum(C) 必然对应整个 C B 的子集和都不为 0，那么 B 的任意真子集的和不等于 sum(B) 因此 -x=sum(B) 必然对应整个 B d","date":"2017-03-15","objectID":"/leetcode/0805/:4:0","tags":null,"title":"0805：数组的均值分割（★★）","uri":"/leetcode/0805/"},{"categories":null,"content":" 力扣第 803 题 ","date":"2017-03-13","objectID":"/leetcode/0803/:0:0","tags":null,"title":"0803：打砖块（★★★★）","uri":"/leetcode/0803/"},{"categories":null,"content":"题目 有一个 m x n 的二元网格 grid ，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是： 一块砖直接连接到网格的顶部，或者\r至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时\r给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而 掉落 。一旦砖块掉落，它会 立即 从网格 grid 中消失（即，它不会落在其他稳定的砖块上）。 返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。 ","date":"2017-03-13","objectID":"/leetcode/0803/:1:0","tags":null,"title":"0803：打砖块（★★★★）","uri":"/leetcode/0803/"},{"categories":null,"content":"分析 ","date":"2017-03-13","objectID":"/leetcode/0803/:2:0","tags":null,"title":"0803：打砖块（★★★★）","uri":"/leetcode/0803/"},{"categories":null,"content":"解答 ","date":"2017-03-13","objectID":"/leetcode/0803/:3:0","tags":null,"title":"0803：打砖块（★★★★）","uri":"/leetcode/0803/"},{"categories":null,"content":" 力扣第 802 题 ","date":"2017-03-12","objectID":"/leetcode/0802/:0:0","tags":null,"title":"0802：找到最终的安全状态（★★）","uri":"/leetcode/0802/"},{"categories":null,"content":"题目 有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph表示， graph[i]是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i]中的每个节点都有一条边。 如果一个节点没有连出的有向边，则它是 终端节点 。如果没有出边，则节点为终端节点。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。 返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。 示例 1： 输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]\r输","date":"2017-03-12","objectID":"/leetcode/0802/:1:0","tags":null,"title":"0802：找到最终的安全状态（★★）","uri":"/leetcode/0802/"},{"categories":null,"content":"分析 安全节点就是不会走到环上的节点。和环有关容易想到拓扑排序，观察发现将边全部反向后，拓扑排序出队的节点即为所求。 ","date":"2017-03-12","objectID":"/leetcode/0802/:2:0","tags":null,"title":"0802：找到最终的安全状态（★★）","uri":"/leetcode/0802/"},{"categories":null,"content":"解答 def eventualSafeNodes(self, graph: List[List[int]]) -\u003e List[int]: n = len(graph) nxt, indeg = defaultdict(list), [0] * n for v in range(n): for u in graph[v]: nxt[u].append(v) indeg[v] += 1 queue = deque(u for u in range(n) if indeg[u] == 0) while queue: u = queue.popleft() for v in nxt[u]: indeg","date":"2017-03-12","objectID":"/leetcode/0802/:3:0","tags":null,"title":"0802：找到最终的安全状态（★★）","uri":"/leetcode/0802/"},{"categories":null,"content":" 力扣第 801 题 ","date":"2017-03-11","objectID":"/leetcode/0801/:0:0","tags":null,"title":"0801：使序列递增的最小交换次数（★★）","uri":"/leetcode/0801/"},{"categories":null,"content":"题目 我们有两个长度相等且不为空的整型数组 nums1 和 nums2 。在一次操作中，我们可以交换 nums1[i] 和 nums2[i]的元素。 例如，如果 nums1 = [1,2,3,8] ， nums2 =[5,6,7,4] ，你可以交换 i = 3 处的元素，得到 nums1 =[1,2,3,4] 和 nums2 =[5,6,7,8] 。\r返回 使 nums1 和 nums2 严格递增 所需操作的最小次数 。 数组 arr 严格递增 且 arr[0] \u003c arr[1] \u003c arr[2] \u003c ... \u003c arr[arr.length - 1] 。 注意： 用例保证可以实现操作。\r示例","date":"2017-03-11","objectID":"/leetcode/0801/:1:0","tags":null,"title":"0801：使序列递增的最小交换次数（★★）","uri":"/leetcode/0801/"},{"categories":null,"content":"分析 最后一对元素交换/不交换是否有效只与倒数第二对元素的状态有关。 为了方便递推，令： dp[i][0] 代表第 i 对不交换的情况下使前 i 对有效的最小次数 dp[i][1] 代表第 i 对交换的情况下使前 i 对有效的最小次数 即可由 dp[i] 递推得到 dp[i+1]。还可以用滚动数组优化。 ","date":"2017-03-11","objectID":"/leetcode/0801/:2:0","tags":null,"title":"0801：使序列递增的最小交换次数（★★）","uri":"/leetcode/0801/"},{"categories":null,"content":"解答 def minSwap(self, nums1: List[int], nums2: List[int]) -\u003e int: n = len(nums1) a, b = 0, 1 for i in range(1, n): a2 = b2 = float('inf') if nums1[i]\u003enums1[i-1] and nums2[i]\u003enums2[i-1]: a2, b2 = min(a2, a), min(b2, b+1) if nums1[i]\u003enums2[i-1] and nums2[i]\u003enums1[i-1]: a2, b2 = min(a2, b), min(b2, a+1)","date":"2017-03-11","objectID":"/leetcode/0801/:3:0","tags":null,"title":"0801：使序列递增的最小交换次数（★★）","uri":"/leetcode/0801/"},{"categories":null,"content":" 力扣第 800 题 ","date":"2017-03-10","objectID":"/leetcode/0800/:0:0","tags":null,"title":"0800：相似 RGB 颜色（★）","uri":"/leetcode/0800/"},{"categories":null,"content":"题目 RGB 颜色 \"#AABBCC\" 可以简写成 \"#ABC\" 。 例如，\"#15c\" 其实是 \"#1155cc\" 的简写。 现在，假如我们分别定义两个颜色 \"#ABCDEF\" 和 \"#UVWXYZ\"，则他们的相似度可以通过这个表达式 -(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2 来计算。 那么给你一个按 \"#ABCDEF\" 形式定义的字符串 color 表示 RGB 颜色，请你以字符串形式，返回一个与它相似度最大且可以简写的颜色。（比如，可以表示成类似 \"#XYZ\" 的形式） 任何 具有相同的（最大）相似度的答案都会被视为正确答案。 示例 1： 输入：c","date":"2017-03-10","objectID":"/leetcode/0800/:1:0","tags":null,"title":"0800：相似 RGB 颜色（★）","uri":"/leetcode/0800/"},{"categories":null,"content":"分析 显然 XYZ 的取值是相互独立的。对于 AB，在 (A-1)%16,A,(A+1)%16 中找 X 使得 XX 和 AB 最近即可。 ","date":"2017-03-10","objectID":"/leetcode/0800/:2:0","tags":null,"title":"0800：相似 RGB 颜色（★）","uri":"/leetcode/0800/"},{"categories":null,"content":"解答 def similarRGB(self, color: str) -\u003e str: def find(pair): a, b = int(pair[0], 16), int(pair[1], 16) x = min([a,(a-1)%16,(a+1)%16], key=lambda x: abs(x*16+x-a*16-b)) return hex(x)[2:]*2 return '#'+find(color[1:3])+find(color[3:5])+find(color[5:]) 28 ms ","date":"2017-03-10","objectID":"/leetcode/0800/:3:0","tags":null,"title":"0800：相似 RGB 颜色（★）","uri":"/leetcode/0800/"},{"categories":null,"content":" 力扣第 799 题 ","date":"2017-03-09","objectID":"/leetcode/0799/:0:0","tags":null,"title":"0799：香槟塔（★★）","uri":"/leetcode/0799/"},{"categories":null,"content":"题目 我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。 从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上） 例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边","date":"2017-03-09","objectID":"/leetcode/0799/:1:0","tags":null,"title":"0799：香槟塔（★★）","uri":"/leetcode/0799/"},{"categories":null,"content":"分析 模拟递推即可。 ","date":"2017-03-09","objectID":"/leetcode/0799/:2:0","tags":null,"title":"0799：香槟塔（★★）","uri":"/leetcode/0799/"},{"categories":null,"content":"解答 def champagneTower(self, poured: int, query_row: int, query_glass: int) -\u003e float: dp = [[0]*(i+1) for i in range(query_row+1)] dp[0][0] = poured for i in range(query_row): for j in range(i+1): x = (dp[i][j]-1) / 2 if x\u003e0: dp[i+1][j] += x dp[i+1][j+1] += x return min(1, dp[-1][query_glass]) 108 ms","date":"2017-03-09","objectID":"/leetcode/0799/:3:0","tags":null,"title":"0799：香槟塔（★★）","uri":"/leetcode/0799/"},{"categories":null,"content":" 力扣第 797 题 ","date":"2017-03-07","objectID":"/leetcode/0797/:0:0","tags":null,"title":"0797：所有可能的路径","uri":"/leetcode/0797/"},{"categories":null,"content":"题目 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序） graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。 示例 1： 输入：graph = [[1,2],[3],[3],[]]\r输出：[[0,1,3],[0,2,3]]\r解释：有两条路径 0 -\u003e 1 -\u003e 3 和 0 -\u003e 2 -\u003e 3\r示例 2： 输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]\r输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,","date":"2017-03-07","objectID":"/leetcode/0797/:1:0","tags":null,"title":"0797：所有可能的路径","uri":"/leetcode/0797/"},{"categories":null,"content":"分析 因为无环，所以可以直接递归。 ","date":"2017-03-07","objectID":"/leetcode/0797/:2:0","tags":null,"title":"0797：所有可能的路径","uri":"/leetcode/0797/"},{"categories":null,"content":"解答 def allPathsSourceTarget(self, graph: List[List[int]]) -\u003e List[List[int]]: def dfs(i): if i==n-1: return [[n-1]] return [[i]+path for j in graph[i] for path in dfs(j)] n = len(graph) return dfs(0) 72 ms ","date":"2017-03-07","objectID":"/leetcode/0797/:3:0","tags":null,"title":"0797：所有可能的路径","uri":"/leetcode/0797/"},{"categories":null,"content":" 力扣第 796 题 ","date":"2017-03-06","objectID":"/leetcode/0796/:0:0","tags":null,"title":"0796：旋转字符串","uri":"/leetcode/0796/"},{"categories":null,"content":"题目 给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。 s 的 旋转操作 就是将 s 最左边的字符移动到最右边。 例如, 若 s = 'abcde'，在旋转一次之后结果就是'bcdea' 。\r示例 1: 输入: s = \"abcde\", goal = \"cdeab\"\r输出: true\r示例 2: 输入: s = \"abcde\", goal = \"abced\"\r输出: false\r提示: 1 \u003c= s.length, goal.length \u003c= 100\rs 和 goal 由小写英文字母组成\r","date":"2017-03-06","objectID":"/leetcode/0796/:1:0","tags":null,"title":"0796：旋转字符串","uri":"/leetcode/0796/"},{"categories":null,"content":"分析 每种旋转都等价于 s+s 的一个长为 len(s) 的子串，因此直接判断 goal 是否长 len(s) 且是 s+s 的子串即可。 ","date":"2017-03-06","objectID":"/leetcode/0796/:2:0","tags":null,"title":"0796：旋转字符串","uri":"/leetcode/0796/"},{"categories":null,"content":"解答 def rotateString(self, s: str, goal: str) -\u003e bool: return len(s)==len(goal) and goal in s*2 48 ms ","date":"2017-03-06","objectID":"/leetcode/0796/:3:0","tags":null,"title":"0796：旋转字符串","uri":"/leetcode/0796/"},{"categories":null,"content":" 力扣第 790 题 ","date":"2017-02-28","objectID":"/leetcode/0790/:0:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":"题目 有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 \"L\" 的托米诺形。两种形状都可以旋转。 给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。 平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。 示例 1: 输入: n = 3 输出: 5 解释: 五种不同的方法如上所示。 示例 2: 输入: n = 1 输出: 1 提示： 1 \u003c= n \u003c= 1000 ","date":"2017-02-28","objectID":"/leetcode/0790/:1:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":"分析 假设最后一列竖着铺 1x2，显然转为递归子问题，横着铺两个 1x2，也同理。 假如最后一列铺 ‘L’ 性，则要求平铺 2x(n-1) 但最后一列只铺一个的方法数。 为了方便递推，令： dp[i][0] 代表平铺 i-1 列的方法数 dp[i][1] 代表平铺 i 列但最后一列只铺一个的方法数 dp[i][2] 代表平铺 i 列的方法数 即可由 dp[i] 递推出 dp[i+1]。还可以优化为 3 个变量。 ","date":"2017-02-28","objectID":"/leetcode/0790/:2:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":"解答 def numTilings(self, n: int) -\u003e int: a, b, c, mod = 0, 0, 1, 10**9+7 for _ in range(n): a, b, c = c, (2*a+b)%mod, (a+b+c)%mod return c 36 ms ","date":"2017-02-28","objectID":"/leetcode/0790/:3:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":"*附加 这是完全的线性递推关系，因此可以用矩阵快速幂优化。 注意在矩阵乘法时也取模即可。 def numTilings(self, n: int) -\u003e int: def mpow(mat, n): res = mat for bit in bin(n)[3:]: res = res*res%mod if bit=='1': res = res*mat%mod return res import numpy as np mod = 10**9+7 A = np.mat([[0,0,1],[2,1,0],[1,1,1]]) dp = np.mat([[0],[0],[1]]) dp = mpow","date":"2017-02-28","objectID":"/leetcode/0790/:4:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":" 力扣第 788 题 ","date":"2017-02-26","objectID":"/leetcode/0788/:0:0","tags":null,"title":"0788：旋转数字","uri":"/leetcode/0788/"},{"categories":null,"content":"题目 我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 示例： 输入: 10 输出: 4 解释: 在[1, 10]中有四个好数： 2, 5, 6,","date":"2017-02-26","objectID":"/leetcode/0788/:1:0","tags":null,"title":"0788：旋转数字","uri":"/leetcode/0788/"},{"categories":null,"content":"分析 暴力做法是遍历 1 到 N，判断是否不含 ‘347’ 且至少有一个 ‘2569’ 即可。 不过这是求范围内数字满足某种性质的个数，典型的数位 dp 问题，能极大优化时间。 令 dfs(pos, st, bound) 代表： 遍历到 n 的第 pos 位 st 代表前面是否至少有一个 ‘2569’ bound 代表前面取的数是否贴着 n 的上界 即可递归。 ","date":"2017-02-26","objectID":"/leetcode/0788/:2:0","tags":null,"title":"0788：旋转数字","uri":"/leetcode/0788/"},{"categories":null,"content":"解答 def rotatedDigits(self, n: int) -\u003e int: @lru_cache(None) def dfs(pos, st, bound): if pos == len(s): return int(st) res, cur = 0, int(s[pos]) up = cur if bound else 9 for x in range(up+1): if x not in [3,4,7]: res += dfs(pos+1, st or x in [2,5,6,9], bound and x==cur) return res s = str(n) return d","date":"2017-02-26","objectID":"/leetcode/0788/:3:0","tags":null,"title":"0788：旋转数字","uri":"/leetcode/0788/"},{"categories":null,"content":" 力扣第 787 题 ","date":"2017-02-25","objectID":"/leetcode/0787/:0:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★）","uri":"/leetcode/0787/"},{"categories":null,"content":"题目 有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。 示例 1： 输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 输","date":"2017-02-25","objectID":"/leetcode/0787/:1:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★）","uri":"/leetcode/0787/"},{"categories":null,"content":"分析 ","date":"2017-02-25","objectID":"/leetcode/0787/:2:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★）","uri":"/leetcode/0787/"},{"categories":null,"content":"#1 限制了路径长度的可以先考虑动态规划。 用 dp[i][j] 代表从 src 到 i 最多飞 j 次的最低价格，即可递推。 def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -\u003e int: dp = [[float('inf')]*(k+2) for _ in range(n)] dp[src] = [0] * (k+2) for j in range(k+1): for u, v, w in flights: dp[v][j+1] = min(dp[v][j+","date":"2017-02-25","objectID":"/leetcode/0787/:2:1","tags":null,"title":"0787：K 站中转内最便宜的航班（★）","uri":"/leetcode/0787/"},{"categories":null,"content":"#2 可以优化为一维数组。观察发现，这本质上就是 Bellman-Ford 算法。 区别在于必须保存上一轮的距离数组，保证每轮只多松弛一次 ","date":"2017-02-25","objectID":"/leetcode/0787/:2:2","tags":null,"title":"0787：K 站中转内最便宜的航班（★）","uri":"/leetcode/0787/"},{"categories":null,"content":"解答 def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -\u003e int: dp = [float('inf')] * n dp[src] = 0 for _ in range(k + 1): prev, flag = dp[:], True for u, v, w in flights: if prev[u]+w \u003c dp[v]: dp[v] = prev[u]+w flag = False if flag: break res = dp[dst] return re","date":"2017-02-25","objectID":"/leetcode/0787/:3:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★）","uri":"/leetcode/0787/"},{"categories":null,"content":"*附加 还有个巧妙的解法。 将状态 (城市 u，飞行次数 c) 看作顶点，如果 c \u003ck+1，那么对于航班 \u003cu,v,w\u003e，从 (u, c) 到 (v, c+1) 连有向边，权重 w。 问题即转为在新图中求 (src, 0) 到 (dst, 0\u003c=c\u003c=k+1) 的最短路，可以用 dijkstra 算法。 具体实现时不需要真的构造出新图。 ","date":"2017-02-25","objectID":"/leetcode/0787/:3:1","tags":null,"title":"0787：K 站中转内最便宜的航班（★）","uri":"/leetcode/0787/"},{"categories":null,"content":"解答 def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -\u003e int: nxt = defaultdict(list) for u, v, w in flights: nxt[u].append((v, w)) d, pq = {}, [(0, src, 0)] while pq: w, u, c = heappop(pq) if (u, c) in d: continue if u == dst: return w d[(u, c)] = w if c \u003c k +","date":"2017-02-25","objectID":"/leetcode/0787/:4:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★）","uri":"/leetcode/0787/"},{"categories":null,"content":" 力扣第 786 题 ","date":"2017-02-24","objectID":"/leetcode/0786/:0:0","tags":null,"title":"0786：第 K 个最小的素数分数（★★）","uri":"/leetcode/0786/"},{"categories":null,"content":"题目 给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数 组成，且其中所有整数互不相同。 对于每对满足 0 \u003c= i \u003c j \u003c arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。 那么第 k 个最小的分数是多少呢? 以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。 示例 1： 输入：arr = [1,2,3,5], k = 3 输出：[2,5] 解释：已构造好的分数,排序后如下所示: 1/5, 1/3, 2/5, 1/2, 3/5,","date":"2017-02-24","objectID":"/leetcode/0786/:1:0","tags":null,"title":"0786：第 K 个最小的素数分数（★★）","uri":"/leetcode/0786/"},{"categories":null,"content":"分析 ","date":"2017-02-24","objectID":"/leetcode/0786/:2:0","tags":null,"title":"0786：第 K 个最小的素数分数（★★）","uri":"/leetcode/0786/"},{"categories":null,"content":"#1 显然固定 i，分数随 j 增大而递减。所以按 i 将分数分为 n-1 个列表，反向归并排序取第 k 项即可。 类似 0378。 def kthSmallestPrimeFraction(self, arr: List[int], k: int) -\u003e List[int]: n = len(arr) pq = [(arr[i]/arr[-1], i, n-1) for i in range(min(n-1, k))] for _ in range(k-1): _, i, j = heappop(pq) if j-1 \u003e i: heappush(pq, (arr[i]/arr[j-1], i","date":"2017-02-24","objectID":"/leetcode/0786/:2:1","tags":null,"title":"0786：第 K 个最小的素数分数（★★）","uri":"/leetcode/0786/"},{"categories":null,"content":"#2 类似 0378，也可以用二分查找。 ","date":"2017-02-24","objectID":"/leetcode/0786/:2:2","tags":null,"title":"0786：第 K 个最小的素数分数（★★）","uri":"/leetcode/0786/"},{"categories":null,"content":"解答 ","date":"2017-02-24","objectID":"/leetcode/0786/:3:0","tags":null,"title":"0786：第 K 个最小的素数分数（★★）","uri":"/leetcode/0786/"},{"categories":null,"content":" 力扣第 785 题 ","date":"2017-02-23","objectID":"/leetcode/0785/:0:0","tags":null,"title":"0785：判断二分图（★）","uri":"/leetcode/0785/"},{"categories":null,"content":"题目 存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性： 不存在自环（graph[u] 不包含 u）。 不存在平行边（graph[u] 不包含重复值）。 如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图） 这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼","date":"2017-02-23","objectID":"/leetcode/0785/:1:0","tags":null,"title":"0785：判断二分图（★）","uri":"/leetcode/0785/"},{"categories":null,"content":"分析 分组问题，想到用并查集。对于每个顶点 u，将其所有相邻顶点分到一组。如果 u 和某个相邻顶点在同一组，就不是二分图。 ","date":"2017-02-23","objectID":"/leetcode/0785/:2:0","tags":null,"title":"0785：判断二分图（★）","uri":"/leetcode/0785/"},{"categories":null,"content":"解答 def isBipartite(self, graph: List[List[int]]) -\u003e bool: def find(i): if p[i] != i: p[i] = find(p[i]) return p[i] def union(i, j): p[find(i)] = find(j) n = len(graph) p = list(range(n)) for u in range(n): if any(find(u)==find(v) for v in graph[u]): return False for v in graph[u][1:]: union(v, graph","date":"2017-02-23","objectID":"/leetcode/0785/:3:0","tags":null,"title":"0785：判断二分图（★）","uri":"/leetcode/0785/"},{"categories":null,"content":" 力扣第 783 题 ","date":"2017-02-21","objectID":"/leetcode/0783/:0:0","tags":null,"title":"0783：二叉搜索树节点最小距离","uri":"/leetcode/0783/"},{"categories":null,"content":"题目 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 示例 1： 输入：root = [4,2,6,1,3] 输出：1 示例 2： 输入：root = [1,0,48,null,null,12,49] 输出：1 提示： 树中节点的数目范围是 [2, 100] 0 \u003c= Node.val \u003c= 105 注意：本题与 530：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ 相同 ","date":"2017-02-21","objectID":"/leetcode/0783/:1:0","tags":null,"title":"0783：二叉搜索树节点最小距离","uri":"/leetcode/0783/"},{"categories":null,"content":"分析 与 0530 完全相同。 ","date":"2017-02-21","objectID":"/leetcode/0783/:2:0","tags":null,"title":"0783：二叉搜索树节点最小距离","uri":"/leetcode/0783/"},{"categories":null,"content":"解答 def minDiffInBST(self, root: TreeNode) -\u003e int: res = float('inf') stack, pre = [root], float('-inf') while stack: node = stack.pop() if isinstance(node, int): res, pre = min(res, node - pre), node elif node: stack.extend([node.right, node.val, node.left]) return res 40 ms ","date":"2017-02-21","objectID":"/leetcode/0783/:3:0","tags":null,"title":"0783：二叉搜索树节点最小距离","uri":"/leetcode/0783/"},{"categories":null,"content":" 力扣第 781 题 ","date":"2017-02-19","objectID":"/leetcode/0781/:0:0","tags":null,"title":"0781：森林中的兔子（★）","uri":"/leetcode/0781/"},{"categories":null,"content":"题目 森林中有未知数量的兔子。提问其中若干只兔子 \"还有多少只兔子与你（指被提问的兔子）颜色相同?\" ，将答案收集到一个整数数组 answers 中，其中 answers[i] 是第 i 只兔子的回答。 给你数组 answers ，返回森林中兔子的最少数量。 示例 1： 输入：answers = [1,1,2]\r输出：5\r解释：\r两只回答了 \"1\" 的兔子可能有相同的颜色，设为红色。\r之后回答了 \"2\" 的兔子不会是红色，否则他们的回答会相互矛盾。\r设回答了 \"2\" 的兔子为蓝色。\r此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。\r因此森林中兔子的最少数量是 5 只：3 只回答的","date":"2017-02-19","objectID":"/leetcode/0781/:1:0","tags":null,"title":"0781：森林中的兔子（★）","uri":"/leetcode/0781/"},{"categories":null,"content":"分析 显然相同颜色的兔子的回答相同，且等于该颜色兔子个数减 1。 因此若回答某一数字 x 的频数 freq 大于 x+1，不可能是同一颜色，至少应该有 (freq-1)//(x+1) + 1 种颜色。 于是数字 x 至少对应 ((freq-1)//(x+1) + 1) * (x+1) 只兔子。 而回答不同数字的兔子必然是不同颜色。因此遍历不同数字，求和即可。 ","date":"2017-02-19","objectID":"/leetcode/0781/:2:0","tags":null,"title":"0781：森林中的兔子（★）","uri":"/leetcode/0781/"},{"categories":null,"content":"解答 def numRabbits(self, answers: List[int]) -\u003e int: return sum((freq+x)//(x+1)*(x+1) for x, freq in Counter(answers).items()) 52 ms ","date":"2017-02-19","objectID":"/leetcode/0781/:3:0","tags":null,"title":"0781：森林中的兔子（★）","uri":"/leetcode/0781/"},{"categories":null,"content":"那个国家中栖息着龙——\n神话中说，古时的人与龙定下了契约，龙帮助人，人帮助龙……\n舞台是“龙之国”。\n主人公是为国之守护神“龙”清理蛀牙菌的新手牙医——野野子。\n与邻国的战争日趋激烈，某天她在龙的牙上发现了昏倒的敌国少年兵。\n少年的名字是贝尔。\n他在被称作巨大灾难前会出现的不可思议现象中，于巨大的牙齿中复活了。\n贝尔对自己的处境感到茫然。为了鼓励他，野野子将他接纳为龙的牙医。\n虽然被卷入了激烈的战争，两人不久将去接受自己的命运……\n这是一场前所未有的雄壮、奇幻冒险！","date":"2017-02-18","objectID":"/anime/the_dragon_dentist/","tags":null,"title":"龙的牙医","uri":"/anime/the_dragon_dentist/"},{"categories":null,"content":"简介 那个国家中栖息着龙—— 神话中说，古时的人与龙定下了契约，龙帮助人，人帮助龙…… 舞台是“龙之国”。 主人公是为国之守护神“龙”清理蛀牙菌的新手牙医——野野子。 与邻国的战争日趋激烈，某天她在龙的牙上发现了昏倒的敌国少年兵。 少年的名字是贝尔。 他在被称作巨大灾难前会出现的不可思议现象中，于巨大的牙齿中复活了。 贝尔对自己的处境感到茫然。为了鼓励他，野野子将他接纳为龙的牙医。 虽然被卷入了激烈的战争，两人不久将去接受自己的命运…… 这是一场前所未有的雄壮、奇幻冒险！ 制作人员： 原作：舞城王太郎 导演：鹤卷和哉 脚本：榎户洋司 分镜：寺冈岩、片山一良、鬼冢大辅、吉崎响 ","date":"2017-02-18","objectID":"/anime/the_dragon_dentist/:1:0","tags":null,"title":"龙的牙医","uri":"/anime/the_dragon_dentist/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 岸井野野子 Kishii Nonoko、きしい ののこ 女 清水富美加 2 ベルナール・オクタビアス 男 岡本信彦 3 悟堂ヨ世夫 男 山寺宏一 4 夏目柴名 女 林原めぐみ 5 サルバトール・ブランコ 男 松尾スズキ 6 有栖川カンネ 女 名塚佳織 7 佐藤修三 男 徳本恭敏 8 家村宗达 男 高木渉 ","date":"2017-02-18","objectID":"/anime/the_dragon_dentist/:2:0","tags":null,"title":"龙的牙医","uri":"/anime/the_dragon_dentist/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙的牙医 2017-02-18 01:32:00 bilibili ","date":"2017-02-18","objectID":"/anime/the_dragon_dentist/:3:0","tags":null,"title":"龙的牙医","uri":"/anime/the_dragon_dentist/"},{"categories":null,"content":" 力扣第 779 题 ","date":"2017-02-17","objectID":"/leetcode/0779/:0:0","tags":null,"title":"0779：第K个语法符号（★）","uri":"/leetcode/0779/"},{"categories":null,"content":"题目 我们构建了一个包含 n 行( 索引从 1 开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。 例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。\r给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始） 示例 1: 输入: n = 1, k = 1\r输出: 0\r解释: 第一行：0\r示例 2: 输入: n = 2, k = 1\r输出: 0\r解释:\r第一行: 0\r第二行: 01\r示例 3: 输入: n = 2, k = 2\r输出: 1\r解释:\r第一行: 0\r第二行: 01\r提","date":"2017-02-17","objectID":"/leetcode/0779/:1:0","tags":null,"title":"0779：第K个语法符号（★）","uri":"/leetcode/0779/"},{"categories":null,"content":"分析 ","date":"2017-02-17","objectID":"/leetcode/0779/:2:0","tags":null,"title":"0779：第K个语法符号（★）","uri":"/leetcode/0779/"},{"categories":null,"content":"#1 为了方便，令 x = k - 1 使得从 0 开始。 第 n 行的第 x 位由第 n-1 行的第 x//2 位生成。如果 x 是偶数，则该字符与原字符相同，否则是原字符取反。 因此考虑递归。最简单的子问题是 n = 1 时，显然为 0。 def kthGrammar(self, n: int, k: int) -\u003e int: def help(n, x): return 0 if n == 1 else help(n - 1, x // 2) ^ (x % 2) return help(n, k - 1) 16 ms ","date":"2017-02-17","objectID":"/leetcode/0779/:2:1","tags":null,"title":"0779：第K个语法符号（★）","uri":"/leetcode/0779/"},{"categories":null,"content":"#2 因为异或运算满足结合律。所以递归过程等价于将 x 的二进制的每一位异或。 因此根据 x 的二进制的 1 的个数即可得到结果。 ","date":"2017-02-17","objectID":"/leetcode/0779/:2:2","tags":null,"title":"0779：第K个语法符号（★）","uri":"/leetcode/0779/"},{"categories":null,"content":"解答 def kthGrammar(self, n: int, k: int) -\u003e int: return bin(k-1).count('1') % 2 24 ms ","date":"2017-02-17","objectID":"/leetcode/0779/:3:0","tags":null,"title":"0779：第K个语法符号（★）","uri":"/leetcode/0779/"},{"categories":null,"content":" 力扣第 770 题 ","date":"2017-02-08","objectID":"/leetcode/0770/:0:0","tags":null,"title":"0770：基本计算器 IV（★★★★）","uri":"/leetcode/0770/"},{"categories":null,"content":"题目 给定一个表达式如 expression = \"e + 8 - a + 5\" 和一个求值映射，如 {\"e\": 1}（给定的形式为 evalvars = [\"e\"] 和 evalints = [1]），返回表示简化表达式的标记列表，例如 [\"-1*a\",\"14\"] 表达式交替使用块和符号，每个块和符号之间有一个空格。\r块要么是括号中的表达式，要么是变量，要么是非负整数。\r变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像 \"2x\" 或 \"-x\" 这样的前导系数或一元运算符 。\r表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。 例","date":"2017-02-08","objectID":"/leetcode/0770/:1:0","tags":null,"title":"0770：基本计算器 IV（★★★★）","uri":"/leetcode/0770/"},{"categories":null,"content":"分析 本质上是多项式的计算。为了方便，考虑用 Counter() 存储变量和系数。 为了合并同类项，考虑用变量的有序元组来作为 key。常数项直接用空的元组作为 key。 比如 5 + a * b + bb * cc 表示为 {(): 5, (a, b): 1, (bb, cc): 1}。 具体实现时，括号内是 List(Counter) 的形式，先按顺序计算乘法，再按顺序计算加减，得到一个 Counter。 然后用栈模拟递归即可。 计算完毕后，所有单项式按 (元组长度, 元组本身) 排序，转为要求的字符串格式即可。 ","date":"2017-02-08","objectID":"/leetcode/0770/:2:0","tags":null,"title":"0770：基本计算器 IV（★★★★）","uri":"/leetcode/0770/"},{"categories":null,"content":"解答 def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -\u003e List[str]: def mul(ct0, ct1): res = Counter() for k0, k1 in product(ct0, ct1): res[tuple(sorted(k0 + k1))] += ct0[k0] * ct1[k1] return res def cal(A): stack = [] for item in A: if isinstance(item, dict) and ","date":"2017-02-08","objectID":"/leetcode/0770/:3:0","tags":null,"title":"0770：基本计算器 IV（★★★★）","uri":"/leetcode/0770/"},{"categories":null,"content":"*附加 本题不含正负号，所以和 0227 类似，可以用更通用的方法。 遍历到某个运算符时，将前面优先级更高的先运算了。 def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -\u003e List[str]: def mul(ct0, ct1): tmp = ct0.copy() ct0.clear() for k0, k1 in product(tmp, ct1): ct0[tuple(sorted(k0 + k1))] += tmp[k0] * ct1[k1] func = {'","date":"2017-02-08","objectID":"/leetcode/0770/:4:0","tags":null,"title":"0770：基本计算器 IV（★★★★）","uri":"/leetcode/0770/"},{"categories":null,"content":" 力扣第 767 题 ","date":"2017-02-05","objectID":"/leetcode/0767/:0:0","tags":null,"title":"0767：重构字符串（★）","uri":"/leetcode/0767/"},{"categories":null,"content":"题目 给定一个字符串 s ，检查是否能重新排布其中的字母，使得两相邻的字符不同。 返回 s 的任意可能的重新排列。若不可行，返回空字符串 \"\" 。 示例 1: 输入: s = \"aab\"\r输出: \"aba\"\r示例 2: 输入: s = \"aaab\"\r输出: \"\"\r提示: 1 \u003c= s.length \u003c= 500\rs 只包含小写字母\r","date":"2017-02-05","objectID":"/leetcode/0767/:1:0","tags":null,"title":"0767：重构字符串（★）","uri":"/leetcode/0767/"},{"categories":null,"content":"分析 ","date":"2017-02-05","objectID":"/leetcode/0767/:2:0","tags":null,"title":"0767：重构字符串（★）","uri":"/leetcode/0767/"},{"categories":null,"content":"#1 先用 Counter 计数，然后最大频数 maxFreq 大于 (len(S)+1) // 2，则该字母必然有两个相邻，不可行。 反之，则存在可行的贪心方案。按频数从大到小遍历字符，先从 0 开始在偶数位置上依此放字符，如果越界了就从 1 开始在奇数位置上依次放字符。 显然，放某个字符 char 时，因为频数小于 (len(S)+1) // 2，必然不会相邻。 def reorganizeString(self, S: str) -\u003e str: n, ct = len(S), Counter(S) if max(ct.values()) \u003e (n+1) // 2: return '' r","date":"2017-02-05","objectID":"/leetcode/0767/:2:1","tags":null,"title":"0767：重构字符串（★）","uri":"/leetcode/0767/"},{"categories":null,"content":"#2 观察发现其实排序只有当 maxFreq == (len(S)+1) // 2 是必要的，此时若不排序，贪心策略可能会让该频数的字符相邻。 有个巧妙的方法来解决，先占奇数位置，遇到第一个 freq == (len(S)+1) // 2 时，让其占偶数位置即可。 ","date":"2017-02-05","objectID":"/leetcode/0767/:2:2","tags":null,"title":"0767：重构字符串（★）","uri":"/leetcode/0767/"},{"categories":null,"content":"解答 def reorganizeString(self, S: str) -\u003e str: n, ct = len(S), Counter(S) if max(ct.values()) \u003e (n+1) // 2: return '' res, cur = [''] * n, 1 for char, freq in ct.items(): if freq == (n+1) // 2 and not res[0]: res[0::2] = [char] * freq else: for _ in range(freq): res[cur] = char cur = cur + 2 if cur +","date":"2017-02-05","objectID":"/leetcode/0767/:3:0","tags":null,"title":"0767：重构字符串（★）","uri":"/leetcode/0767/"},{"categories":null,"content":" 力扣第 764 题 ","date":"2017-02-02","objectID":"/leetcode/0764/:0:0","tags":null,"title":"0764：最大加号标志（★）","uri":"/leetcode/0764/"},{"categories":null,"content":"题目 在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。mines[i] = [xi, yi]表示 grid[xi][yi] == 0 返回 grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。 一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。 示例 1： 输入: n = 5, mines = [[","date":"2017-02-02","objectID":"/leetcode/0764/:1:0","tags":null,"title":"0764：最大加号标志（★）","uri":"/leetcode/0764/"},{"categories":null,"content":"分析 分别递推找到 (i,j) 往四个方向的臂长即可。 ","date":"2017-02-02","objectID":"/leetcode/0764/:2:0","tags":null,"title":"0764：最大加号标志（★）","uri":"/leetcode/0764/"},{"categories":null,"content":"解答 def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -\u003e int: mines = {(x, y) for x,y in mines} A = [[int((x,y) not in mines) for y in range(n)] for x in range(n)] cal = lambda row: list(accumulate(row, lambda x,y:(x+y)*y)) L = [cal(row) for row in A] R = [cal(row[::-1])[::-1] for row ","date":"2017-02-02","objectID":"/leetcode/0764/:3:0","tags":null,"title":"0764：最大加号标志（★）","uri":"/leetcode/0764/"},{"categories":null,"content":" 力扣第 762 题 ","date":"2017-01-31","objectID":"/leetcode/0762/:0:0","tags":null,"title":"0762：二进制表示中质数个计算置位","uri":"/leetcode/0762/"},{"categories":null,"content":"题目 给你两个整数 left 和 right ，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。 计算置位位数 就是二进制表示中 1 的个数。 例如， 21 的二进制表示 10101 有 3 个计算置位。\r示例 1： 输入：left = 6, right = 10\r输出：4\r解释：\r6 -\u003e 110 (2 个计算置位，2 是质数)\r7 -\u003e 111 (3 个计算置位，3 是质数)\r9 -\u003e 1001 (2 个计算置位，2 是质数)\r10-\u003e 1010 (2 个计算置位，2 是质数)\r共计 4 个计算置位为质数的数字。\r示例 2： 输入：left = 1","date":"2017-01-31","objectID":"/leetcode/0762/:1:0","tags":null,"title":"0762：二进制表示中质数个计算置位","uri":"/leetcode/0762/"},{"categories":null,"content":"分析 遍历数判断 1 的个数是否质数即可。因为最大为 $10^6\u003c2^20$，所以只需考虑 20 以下的质数。 ","date":"2017-01-31","objectID":"/leetcode/0762/:2:0","tags":null,"title":"0762：二进制表示中质数个计算置位","uri":"/leetcode/0762/"},{"categories":null,"content":"解答 def countPrimeSetBits(self, L: int, R: int) -\u003e int: return sum(bin(x).count('1') in [2, 3, 5, 7, 11, 13, 17, 19] for x in range(L, R+1)) 220 ms ","date":"2017-01-31","objectID":"/leetcode/0762/:3:0","tags":null,"title":"0762：二进制表示中质数个计算置位","uri":"/leetcode/0762/"},{"categories":null,"content":" 力扣第 760 题 ","date":"2017-01-29","objectID":"/leetcode/0760/:0:0","tags":null,"title":"0760：找出变位映射","uri":"/leetcode/0760/"},{"categories":null,"content":"题目 给定两个列表 Aand B，并且 B 是 A 的变位（即 B 是由 A 中的元素随机排列后组成的新列表）。 我们希望找出一个从 A 到 B 的索引映射 P 。一个映射 P[i] = j 指的是列表 A 中的第 i 个元素出现于列表 B 中的第 j 个元素上。 列表 A 和 B 可能出现重复元素。如果有多于一种答案，输出任意一种。 例如，给定 A = [12, 28, 46, 32, 50] B = [50, 12, 32, 46, 28] 需要返回 [1, 4, 3, 2, 0] P[0] = 1 ，因为 A 中的第 0 个元素出现于 B[1]，而且 P[1] = 4 因为 A 中第 1","date":"2017-01-29","objectID":"/leetcode/0760/:1:0","tags":null,"title":"0760：找出变位映射","uri":"/leetcode/0760/"},{"categories":null,"content":"分析 哈希表记录 B 中元素对应的位置即可。 ","date":"2017-01-29","objectID":"/leetcode/0760/:2:0","tags":null,"title":"0760：找出变位映射","uri":"/leetcode/0760/"},{"categories":null,"content":"解答 def anagramMappings(self, nums1: List[int], nums2: List[int]) -\u003e List[int]: d = {x: i for i,x in enumerate(nums2)} return [d[x] for x in nums1] 28 ms ","date":"2017-01-29","objectID":"/leetcode/0760/:3:0","tags":null,"title":"0760：找出变位映射","uri":"/leetcode/0760/"},{"categories":null,"content":" 力扣第 753 题 ","date":"2017-01-22","objectID":"/leetcode/0753/:0:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":"题目 有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位都是范围 [0, k - 1] 中的一个数字。 保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 最后 n 位输入 ，如果匹配，则能够打开保险箱。 例如，正确的密码是 \"345\" ，并且你输入的是 \"012345\" ：\r输入 0 之后，最后 3 位输入是 \"0\" ，不正确。\r输入 1 之后，最后 3 位输入是 \"01\" ，不正确。\r输入 2 之后，最后 3 位输入是 \"012\" ，不正确。\r输入 3 之后，最后 3 位输入是 \"123\" ，不正确。\r输入 4 之后，最后 3 位输入是 \"234\" ，不","date":"2017-01-22","objectID":"/leetcode/0753/:1:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":"分析 本题有个非常巧妙的方法。将所有 n-1 位数作为顶点，如果 u 的后 n-2 位和 v 的前 n-2 位相同，就添加一条边 u 指向 v。 那么输入的字符串可以看作是有向图中的一条路径。字符串要覆盖所有密码，等价于图中的路径要经过所有边。 因此问题转化为求最短的经过所有边的路径。 该图中所有顶点的入度和出度相同，因此是欧拉图。用 Hierholzer 算法求欧拉回路即可。注意 n==1 的特殊情况。 ","date":"2017-01-22","objectID":"/leetcode/0753/:2:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":"解答 def crackSafe(self, n: int, k: int) -\u003e str: def dfs(u): while nxt[u] \u003c k: nxt[u] += 1 dfs(u[1:]+str(nxt[u]-1)) stack.append(u[-1]) if n == 1: return ''.join(str(i) for i in range(k)) stack, nxt = [], defaultdict(int) dfs('0'*(n-1)) return ''.join(stack) + '0'*(n-2) 44 ms ","date":"2017-01-22","objectID":"/leetcode/0753/:3:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":"*附加 其实只要每次都选最大的后继顶点，就不会遇到死胡同。所以本题还可以直接构造。 def crackSafe(self, n: int, k: int) -\u003e str: if n == 1: return ''.join(str(i) for i in range(k)) res, nxt = '0' * (n-1), defaultdict(lambda: k-1) for _ in range(k**n): u = res[1-n:] res += str(nxt[u]) nxt[u] -= 1 return res 40 ms ","date":"2017-01-22","objectID":"/leetcode/0753/:4:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":" 力扣第 744 题 ","date":"2017-01-13","objectID":"/leetcode/0744/:0:0","tags":null,"title":"0744：寻找比目标字母大的最小字母","uri":"/leetcode/0744/"},{"categories":null,"content":"题目 给你一个字符数组 letters，该数组按非递减顺序排序，以及一个字符 target。letters 里至少有两个不同的字符。 返回 letters 中大于 target 的最小的字符。如果不存在这样的字符，则返回 letters 的第一个字符。 示例 1： 输入: letters = [\"c\", \"f\", \"j\"]，target = \"a\" 输出: \"c\" 解释：letters 中字典上比 'a' 大的最小字符是 'c'。 示例 2: 输入: letters = [\"c\",\"f\",\"j\"], target = \"c\" 输出: \"f\" 解释：letters 中字典顺序上大于 'c' 的最","date":"2017-01-13","objectID":"/leetcode/0744/:1:0","tags":null,"title":"0744：寻找比目标字母大的最小字母","uri":"/leetcode/0744/"},{"categories":null,"content":"分析 ","date":"2017-01-13","objectID":"/leetcode/0744/:2:0","tags":null,"title":"0744：寻找比目标字母大的最小字母","uri":"/leetcode/0744/"},{"categories":null,"content":"#1 遍历找到第一个比 target 大的字母即可。如果都比 target 小，那么按照循环应该返回 letters[0]。 def nextGreatestLetter(self, letters: List[str], target: str) -\u003e str: for letter in letters: if letter \u003e target: return letter return letters[0] 124 ms ","date":"2017-01-13","objectID":"/leetcode/0744/:2:1","tags":null,"title":"0744：寻找比目标字母大的最小字母","uri":"/leetcode/0744/"},{"categories":null,"content":"#2 也可以二分查找从最右边将 target 插入 nums 的位置 i。如果 i == len(letters)，那么应该返回 letters[0]。 ","date":"2017-01-13","objectID":"/leetcode/0744/:2:2","tags":null,"title":"0744：寻找比目标字母大的最小字母","uri":"/leetcode/0744/"},{"categories":null,"content":"解答 def nextGreatestLetter(self, letters: List[str], target: str) -\u003e str: return letters[bisect_right(letters, target) % (len(letters))] 124 ms ","date":"2017-01-13","objectID":"/leetcode/0744/:3:0","tags":null,"title":"0744：寻找比目标字母大的最小字母","uri":"/leetcode/0744/"},{"categories":null,"content":" 力扣第 743 题 ","date":"2017-01-12","objectID":"/leetcode/0743/:0:0","tags":null,"title":"0743：网络延迟时间（★）","uri":"/leetcode/0743/"},{"categories":null,"content":"题目 有 n 个网络节点，标记为 1 到 n。 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。 示例 1： 输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 输出：2 示例 2： 输入：times = [[1,2,1]], n = 2, k = 1 输出：1 示例 3： 输入：ti","date":"2017-01-12","objectID":"/leetcode/0743/:1:0","tags":null,"title":"0743：网络延迟时间（★）","uri":"/leetcode/0743/"},{"categories":null,"content":"分析 典型的单源最短路径问题，可以用堆优化的 dijkstra 算法。 ","date":"2017-01-12","objectID":"/leetcode/0743/:2:0","tags":null,"title":"0743：网络延迟时间（★）","uri":"/leetcode/0743/"},{"categories":null,"content":"解答 def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: nxt = defaultdict(list) for u, v, w in times: nxt[u-1].append((v-1, w)) d, pq = {}, [(0, k-1)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, w2 in nxt[u]: if v not in d: heappush(pq, (w+w2, v)) return ma","date":"2017-01-12","objectID":"/leetcode/0743/:3:0","tags":null,"title":"0743：网络延迟时间（★）","uri":"/leetcode/0743/"},{"categories":null,"content":"*附加 本题可以练习各种最短路算法。 ","date":"2017-01-12","objectID":"/leetcode/0743/:4:0","tags":null,"title":"0743：网络延迟时间（★）","uri":"/leetcode/0743/"},{"categories":null,"content":"#1 Floyd def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: d = [[float('inf')]*n for _ in range(n)] for i in range(n): d[i][i] = 0 for u, v, w in times: d[u-1][v-1] = w for x, i, j in product(range(n), range(n), range(n)): d[i][j] = min(d[i][j], d[i][x]+d[x][j]) res = max(d[","date":"2017-01-12","objectID":"/leetcode/0743/:4:1","tags":null,"title":"0743：网络延迟时间（★）","uri":"/leetcode/0743/"},{"categories":null,"content":"#2 Bellman-Ford def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: d = [float('inf')] * n d[k-1] = 0 for _ in range(n - 1): flag = True for u, v, w in times: if d[u-1] + w \u003c d[v-1]: d[v-1] = d[u-1] + w flag = False if flag: break res = max(d) return res if res \u003c float('inf') ","date":"2017-01-12","objectID":"/leetcode/0743/:4:2","tags":null,"title":"0743：网络延迟时间（★）","uri":"/leetcode/0743/"},{"categories":null,"content":"#3 SPFA def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: nxt = defaultdict(list) for u, v, w in times: nxt[u-1].append((v-1, w)) d = [float('inf')] * n d[k-1] = 0 queue, vis = deque([k-1]), {k-1} while queue: u = queue.popleft() vis.remove(u) for v, w in nxt[u]: if d[u] + w","date":"2017-01-12","objectID":"/leetcode/0743/:4:3","tags":null,"title":"0743：网络延迟时间（★）","uri":"/leetcode/0743/"},{"categories":null,"content":"#4 Dijkstra 朴素 def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: nxt = defaultdict(list) for u, v, w in times: nxt[u-1].append((v-1, w)) d, Q = [float('inf')] * n, set(range(n)) d[k-1] = 0 while Q: u = min(Q, key=d.__getitem__) Q.remove(u) for v, w in nxt[u]: if v in Q: d[v]","date":"2017-01-12","objectID":"/leetcode/0743/:4:4","tags":null,"title":"0743：网络延迟时间（★）","uri":"/leetcode/0743/"},{"categories":null,"content":"在单身的辛苦OL小林身边突然出现的女仆装束的美少女托尔。\n长着角和尾巴的她的身姿正是所谓的龙娘。\n在醉酒的小林邀请下说要到家里去的托尔，鬼使神差地开始以小林家女仆的身份工作……！？\n“女仆”+“龙”=“女仆龙”有着笨手笨脚的可爱之处！\n龙娘与人类之间基本上很温暖、偶尔有些黑暗的异种族间交流喜剧！！","date":"2017-01-11","objectID":"/anime/dragon_maid/","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":"简介 在单身的辛苦OL小林身边突然出现的女仆装束的美少女托尔。 长着角和尾巴的她的身姿正是所谓的龙娘。 在醉酒的小林邀请下说要到家里去的托尔，鬼使神差地开始以小林家女仆的身份工作……！？ “女仆”+“龙”=“女仆龙”有着笨手笨脚的可爱之处！ 龙娘与人类之间基本上很温暖、偶尔有些黑暗的异种族间交流喜剧！！ 制作人员： 原作：酷教信徒 导演：武本康弘 脚本：西川昌志、山田由香、志茂文彦 分镜：木上益治、石原立也、山田尚子 ","date":"2017-01-11","objectID":"/anime/dragon_maid/:1:0","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小林小姐 小林、こばやし、Kobayashi 女 田村睦心 2 托尔 朵露、小林托尔、Tohru、小林 トール、こばやし トール、Kobayashi Tōru 女 桑原由気 3 康娜卡姆依 小林康娜(小林 カンナ,こばやし カンナ,Kobayashi Kanna)、神奈神威、阿澄雷神、カンナカムイ、Kanna Kamui 女 長縄まりあ 4 艾露玛 艾尔玛、艾玛、上井艾露玛、上井艾尔玛、上井艾玛、Joui Elma、上井エルマ、じょうい エルマ、Jōi Eruma 女 高田憂希 5 露科亚 露可亚、尔科亚、ルコア、Rukoa、Lucoa、魁札尔科亚特尔、Qu","date":"2017-01-11","objectID":"/anime/dragon_maid/:2:0","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 小林家的龙女仆 2017-01-11 13 bilibili 2 小林家的龙女仆S 2021-07-07 12 bilibili ","date":"2017-01-11","objectID":"/anime/dragon_maid/:3:0","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":"MAD ","date":"2017-01-11","objectID":"/anime/dragon_maid/:4:0","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":" 力扣第 741 题 ","date":"2017-01-10","objectID":"/leetcode/0741/:0:0","tags":null,"title":"0741：摘樱桃（★★）","uri":"/leetcode/0741/"},{"categories":null,"content":"题目 一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示： 0 表示这个格子是空的，所以你可以穿过它。 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 -1 表示这个格子里有荆棘，挡着你的路。 你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃： 从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）； 当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子； 当你经过一个格子且这个格子包含一个樱桃时，","date":"2017-01-10","objectID":"/leetcode/0741/:1:0","tags":null,"title":"0741：摘樱桃（★★）","uri":"/leetcode/0741/"},{"categories":null,"content":"分析 单程是个很显然的 dp 问题，双程则会互相影响，不能分开求。 那么考虑一起递推，到 (i,j) 位置的双程的最大值，依赖于上一步两条线路的结尾。 为了递推，令 dfs(i1,j1,i2,j2) 代表两条线路分别到 (i1,j1)、(i2,j2) 位置时的最大值，即可递推。 注意到递推过程中 i1+j1==i2+j2，因此可以简化为 dfs(k, i1, i2) 代表第 k 步 两条线路分别到 (i1,k-i1)、(i2,k-i2) 位置时的最大值。 ","date":"2017-01-10","objectID":"/leetcode/0741/:2:0","tags":null,"title":"0741：摘樱桃（★★）","uri":"/leetcode/0741/"},{"categories":null,"content":"解答 class Solution: def cherryPickup(self, grid: List[List[int]]) -\u003e int: @lru_cache(None) def dfs(k, i1, i2): if k==0: return grid[0][0] if grid[i1][k-i1] == -1 or grid[i2][k-i2] == -1: return float('-inf') res, cur = float('-inf'), sum(grid[i][k-i] for i in {i1, i2}) for x1, x2 in product([i1, i1-1","date":"2017-01-10","objectID":"/leetcode/0741/:3:0","tags":null,"title":"0741：摘樱桃（★★）","uri":"/leetcode/0741/"},{"categories":null,"content":"《动物朋友》是由“动物朋友企划”（famima.com、东京电视台、KADOKAWA、胜利娱乐、Crunchyroll SC动画基金、AT-X、SYS、人脉、Age Global Networks、Just Production、DOCOMO动画商城、武士道）发起的跨媒体企划。该企划最初的产品是由总部位于东京的游戏公司Nexon在2015年开发的手机游戏。以游戏中的兽娘为主角的漫画《动物朋友 -欢迎来到加帕里公园！-》则于同年5月至2017年1月在《月刊少年Ace》连载。《Keroro军曹》的作者吉崎观音是该企划的概念设计和角色设计者。\n\n2016年10月21日，“动物朋友企划A”宣布制作电视动画《动物朋友》。动画于2017年1月10日首播。\n\n建造于这个世界某处的超巨大综合动物园“Japari Park”，在那里，在神秘物质“Sandstar”的力量下，动物们接连变身成为拥有人类姿态的“动物娘”——！她们开始与来访的人们热闹地游玩。\n但，时间流逝……\n有一天，动物园里出现了一个看上去很困扰的迷路孩子。本是为了回家而踏上的旅途，因为动物娘们的加入，变成了一场大冒险！？","date":"2017-01-10","objectID":"/anime/kemono_friends/","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":"简介 《动物朋友》是由“动物朋友企划”（famima.com、东京电视台、KADOKAWA、胜利娱乐、Crunchyroll SC动画基金、AT-X、SYS、人脉、Age Global Networks、Just Production、DOCOMO动画商城、武士道）发起的跨媒体企划。该企划最初的产品是由总部位于东京的游戏公司Nexon在2015年开发的手机游戏。以游戏中的兽娘为主角的漫画《动物朋友 -欢迎来到加帕里公园！-》则于同年5月至2017年1月在《月刊少年Ace》连载。《Keroro军曹》的作者吉崎观音是该企划的概念设计和角色设计者。 2016年10月21日，“动物朋友企划A”宣布制作","date":"2017-01-10","objectID":"/anime/kemono_friends/:1:0","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 薮猫 Serval、Sābaru、Leptailurus serval 野中藍 2 包 小包、卡邦、背包、小鞄、Kaban、鞄 女 内田彩 3 幸运兽 Lackey beast、ボス、老大、Lucky Beast、幸運の獣、らっきーびーすと、ラッキーさん ？？？ 4 耳廓狐 Vulpes zerda、Fennec、Fenekku 本宮佳奈 5 浣熊 Procyon lotor、Common raccoon、Araiguma 小野早稀 6 巴布亚企鹅 金图企鹅、Gentoo penguin、Jentsūpengin、Pygoscelis papua 田村響華 ","date":"2017-01-10","objectID":"/anime/kemono_friends/:2:0","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 兽娘动物园 2017-01-10 12 bilibili ","date":"2017-01-10","objectID":"/anime/kemono_friends/:3:0","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":"MAD ","date":"2017-01-10","objectID":"/anime/kemono_friends/:4:0","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":" 力扣第 740 题 ","date":"2017-01-09","objectID":"/leetcode/0740/:0:0","tags":null,"title":"0740：删除并获得点数（★）","uri":"/leetcode/0740/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，你可以对它进行一些操作。 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 示例 1： 输入：nums = [3,4,2] 输出：6 解释： 删除 4 获得 4 个点数，因此 3 也被删除。 之后，删除 2 获得 2 个点数。总共获得 6 个点数。 示例 2： 输入：nums = [2,2,3,3,3,4] 输出：9 解释： 删除 3 获得 3 个点数，接着要删除两个 2 和","date":"2017-01-09","objectID":"/leetcode/0740/:1:0","tags":null,"title":"0740：删除并获得点数（★）","uri":"/leetcode/0740/"},{"categories":null,"content":"分析 拿了 nums[i] 的点数，就拿不到 nums[i]-1 和 nums[i]+1 的点数，这个限制类似 0198 打家劫舍。 因此，统计得到 min(nums) 到 max(nums) 每个数能拿到的点数，就转为打家劫舍问题了。 ","date":"2017-01-09","objectID":"/leetcode/0740/:2:0","tags":null,"title":"0740：删除并获得点数（★）","uri":"/leetcode/0740/"},{"categories":null,"content":"解答 def deleteAndEarn(self, nums: List[int]) -\u003e int: ct, a, b = Counter(nums), 0, 0 for x in range(min(ct), max(ct)+1): a, b = b, max(b, a+x*ct[x]) return b 40 ms ","date":"2017-01-09","objectID":"/leetcode/0740/:3:0","tags":null,"title":"0740：删除并获得点数（★）","uri":"/leetcode/0740/"},{"categories":null,"content":" 力扣第 739 题 ","date":"2017-01-08","objectID":"/leetcode/0739/:0:0","tags":null,"title":"0739：每日温度（★）","uri":"/leetcode/0739/"},{"categories":null,"content":"题目 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 示例 1: 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] 示例 2: 输入: temperatures = [30,40,50,60] 输出: [1,1,1,0] 示例 3: 输入: temperatures = [30,60,90] 输出: [1,1,0] 提示： 1 \u003c= tem","date":"2017-01-08","objectID":"/leetcode/0739/:1:0","tags":null,"title":"0739：每日温度（★）","uri":"/leetcode/0739/"},{"categories":null,"content":"分析 ","date":"2017-01-08","objectID":"/leetcode/0739/:2:0","tags":null,"title":"0739：每日温度（★）","uri":"/leetcode/0739/"},{"categories":null,"content":"#1 注意到气温的范围较小，所以对每个位置 i，可以遍历比 T[i] 更高的温度，比较在 T[i+1:] 中的位置即可。 而查询位置可以通过反向遍历并维护哈希表，在 O(1) 时间内完成。 def dailyTemperatures(self, T: List[int]) -\u003e List[int]: n = len(T) res, d = [0] * n, defaultdict(int) for i in range(n-1, -1, -1): d[T[i]] = i nxt = min(j if t \u003e T[i] else float('inf') for t, j in d.items(","date":"2017-01-08","objectID":"/leetcode/0739/:2:1","tags":null,"title":"0739：每日温度（★）","uri":"/leetcode/0739/"},{"categories":null,"content":"#2 本题还有个巧妙的单调栈解法。 假设在 T[i+1:] 内存在 x \u003c y, T[x] \u003e= T[y]，显然对于任意 i 前面的位置，y 都不可能是答案。 所以如果反向遍历位置 i，并维护一个去掉这种 y 的列表 tmp，位置 i 对应的答案必然在 tmp 中。 显然 tmp 保持严格单调递减，故位置 i 对应的答案就是 tmp[-1]。 注意遍历到位置 i 时，tmp 中要去掉的都是末尾的一部分元素，因此 tmp 就是一个单调栈。 每个元素最多入栈出栈一次，因此时间复杂度 O(N)。 def dailyTemperatures(self, T: List[int]) -\u003e List[in","date":"2017-01-08","objectID":"/leetcode/0739/:2:2","tags":null,"title":"0739：每日温度（★）","uri":"/leetcode/0739/"},{"categories":null,"content":"#3 其实也可以正向遍历。 用 tmp 保存还没有确定结果的位置。遍历到位置 i 时，tmp 中所有满足 T[j] \u003c T[i] 的位置 j，T[j] 的下一个更高气温就是 T[i]，将 j 弹出。 显然 tmp 是一个不严格递减的单调栈。 ","date":"2017-01-08","objectID":"/leetcode/0739/:2:3","tags":null,"title":"0739：每日温度（★）","uri":"/leetcode/0739/"},{"categories":null,"content":"解答 def dailyTemperatures(self, T: List[int]) -\u003e List[int]: n = len(T) res, stack = [0] * n, [] for i in range(n): while stack and T[stack[-1]] \u003c T[i]: j = stack.pop() res[j] = i-j stack.append(i) return res 476 ms ","date":"2017-01-08","objectID":"/leetcode/0739/:3:0","tags":null,"title":"0739：每日温度（★）","uri":"/leetcode/0739/"},{"categories":null,"content":" 力扣第 735 题 ","date":"2017-01-04","objectID":"/leetcode/0735/:0:0","tags":null,"title":"0735：行星碰撞（★）","uri":"/leetcode/0735/"},{"categories":null,"content":"题目 给定一个整数数组 asteroids，表示在同一行的行星。 对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。 找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。 示例 1： 输入：asteroids = [5,10,-5]\r输出：[5,10]\r解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。\r示例 2： 输入：asteroids = [8,-8]\r输出：[]\r解释：8 ","date":"2017-01-04","objectID":"/leetcode/0735/:1:0","tags":null,"title":"0735：行星碰撞（★）","uri":"/leetcode/0735/"},{"categories":null,"content":"分析 显然用栈，不过情况较多需要注意。 遍历到 cur 时，当 stack 非空且 cur \u003c 0 \u003c stack[-1] 时，会发生碰撞。 将 pre=stack[-1] 弹出，cur 更新为 cur 和 pre 碰撞后剩下的行星，如果相等，就将 cur 更新为 0。 循环直到不碰撞时，如果 cur 不为 0，就是还剩下的，入栈即可。 ","date":"2017-01-04","objectID":"/leetcode/0735/:2:0","tags":null,"title":"0735：行星碰撞（★）","uri":"/leetcode/0735/"},{"categories":null,"content":"解答 def asteroidCollision(self, asteroids: List[int]) -\u003e List[int]: stack = [] for cur in asteroids: while stack and cur \u003c 0 \u003c stack[-1]: pre = stack.pop() cur = 0 if abs(cur) == pre else max([cur, pre], key=abs) if cur != 0: stack.append(cur) return stack 60 ms ","date":"2017-01-04","objectID":"/leetcode/0735/:3:0","tags":null,"title":"0735：行星碰撞（★）","uri":"/leetcode/0735/"},{"categories":null,"content":" 力扣第 730 题 ","date":"2016-12-30","objectID":"/leetcode/0730/:0:0","tags":null,"title":"0730：统计不同回文子序列（★★）","uri":"/leetcode/0730/"},{"categories":null,"content":"题目 给定一个字符串 s，返回 s 中不同的非空「回文子序列」个数 。 通过从 s 中删除 0 个或多个字符来获得子序列。 如果一个字符序列与它反转后的字符序列一致，那么它是「回文字符序列」。 如果有某个 i , 满足 ai != bi ，则两个序列 a1, a2, ... 和 b1, b2, ... 不同。 注意： 结果可能很大，你需要对 109 + 7 取模 。\r示例 1： 输入：s = 'bccb'\r输出：6\r解释：6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。\r注意：'bcb' 虽然出现两次但仅计数一次。\r示例 2： 输入","date":"2016-12-30","objectID":"/leetcode/0730/:1:0","tags":null,"title":"0730：统计不同回文子序列（★★）","uri":"/leetcode/0730/"},{"categories":null,"content":"分析 不考虑重复的话，就是一般的区间 dp 问题，按序列最外层的字符递推。 考虑重复的话要复杂很多。假设最外层字符为 ‘a’，位置分别为 i、j，那么： [i,j] 范围内最外层为 ‘b’/‘c’/’d’ 的不同回文子序列，加上 ‘a’ 后显然是不同的 [i,j] 范围内最外层为 ‘a’ 的不同回文子序列，加上 ‘a’ 后也是不同的 但加/不加 ‘a’ 的两个集合是有很多重复的 观察发现，加上 ‘a’ 后基本包括了不加 ‘a’ 的集合，除了 ‘a’ 和 ‘aa’ 两个集合的大小是相同的，因此加/不加 ‘a’ 的合集只比不加 ‘a’ 的集合多 2 于是令 dp[i][j][x] 代表 [i,j]","date":"2016-12-30","objectID":"/leetcode/0730/:2:0","tags":null,"title":"0730：统计不同回文子序列（★★）","uri":"/leetcode/0730/"},{"categories":null,"content":"解答 def countPalindromicSubsequences(self, s: str) -\u003e int: n, mod = len(s), 10**9+7 A = [ord(c)-ord('a') for c in s] dp = [[[0]*4 for _ in range(n)] for _ in range(n)] for j in range(n): dp[j][j][A[j]] = 1 for i in range(j-1, -1, -1): dp[i][j] = dp[i+1][j-1][:] if A[i]==A[j]: dp[i][j][A[i]] = (sum(dp","date":"2016-12-30","objectID":"/leetcode/0730/:3:0","tags":null,"title":"0730：统计不同回文子序列（★★）","uri":"/leetcode/0730/"},{"categories":null,"content":" 力扣第 726 题 ","date":"2016-12-26","objectID":"/leetcode/0726/:0:0","tags":null,"title":"0726：原子的数量（★★）","uri":"/leetcode/0726/"},{"categories":null,"content":"题目 给你一个字符串化学式 formula ，返回 每种原子的数量 。 原子总是以一个大写字母开始，接着跟随 0 个或任意个小写字母，表示原子的名字。 如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。 例如，\"H2O\" 和 \"H2O2\" 是可行的，但 \"H1O2\" 这个表达是不可行的。 两个化学式连在一起可以构成新的化学式。 例如 \"H2O2He3Mg4\" 也是化学式。 由括号括起的化学式并佐以数字（可选择性添加）也是化学式。 例如 \"(H2O2)\" 和 \"(H2O2)3\" 是化学式。 返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如","date":"2016-12-26","objectID":"/leetcode/0726/:1:0","tags":null,"title":"0726：原子的数量（★★）","uri":"/leetcode/0726/"},{"categories":null,"content":"分析 ","date":"2016-12-26","objectID":"/leetcode/0726/:2:0","tags":null,"title":"0726：原子的数量（★★）","uri":"/leetcode/0726/"},{"categories":null,"content":"#1 典型的栈问题。数量可能很大，所以考虑栈中不保存字符，而是保存计数字典 Counter()。 先考虑没有括号的情况。遇到大写字母时，向后提取出原子的名字，再向后提取出数量，累加到 stack[-1] 中即可。 再考虑有括号的情况。遇到左括号就新加一个 Counter()，用来保存括号内的结果。遇到右括号时就弹出栈顶的 ct， 然后向后提取出数字 cnt，将 ct 的每个原子数量乘以 cnt，累加到 stack[-1] 中即可。 def countOfAtoms(self, formula: str) -\u003e str: stack, i, n = [Counter()], 0, len(for","date":"2016-12-26","objectID":"/leetcode/0726/:2:1","tags":null,"title":"0726：原子的数量（★★）","uri":"/leetcode/0726/"},{"categories":null,"content":"#2 可以用正则来节省代码。每轮提取 “原子名字+数量” 或 “(” 或 “)+数量”，其它的流程一样。 ","date":"2016-12-26","objectID":"/leetcode/0726/:2:2","tags":null,"title":"0726：原子的数量（★★）","uri":"/leetcode/0726/"},{"categories":null,"content":"解答 def countOfAtoms(self, formula: str) -\u003e str: stack, regex = [Counter()], r\"([A-Z][a-z]*)(\\d*)|(\\()|(\\))(\\d*)\" for atom, cnt, left, right, cnt2 in re.findall(regex, formula): if atom: stack[-1][atom] += int(cnt or 1) elif left: stack.append(Counter()) elif right: ct = stack.pop() for k, v in ct.it","date":"2016-12-26","objectID":"/leetcode/0726/:3:0","tags":null,"title":"0726：原子的数量（★★）","uri":"/leetcode/0726/"},{"categories":null,"content":" 力扣第 725 题 ","date":"2016-12-25","objectID":"/leetcode/0725/:0:0","tags":null,"title":"0725：分隔链表（★）","uri":"/leetcode/0725/"},{"categories":null,"content":"题目 给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。 每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。 这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。 返回一个由上述 k 部分组成的数组。 示例 1： 输入：head = [1,2,3], k = 5\r输出：[[1],[2],[3],[],[]]\r解释：\r第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。\r最后一个","date":"2016-12-25","objectID":"/leetcode/0725/:1:0","tags":null,"title":"0725：分隔链表（★）","uri":"/leetcode/0725/"},{"categories":null,"content":"分析 先得到链表长度 n，应该平均分为 n // k 长度，但可能有余数 extra。根据题目要求，应该将前 extra 个链表的长度再分别加 1。 注意可能分为空链表，所以每轮从哑结点开始，防止越界。 ","date":"2016-12-25","objectID":"/leetcode/0725/:2:0","tags":null,"title":"0725：分隔链表（★）","uri":"/leetcode/0725/"},{"categories":null,"content":"解答 def splitListToParts(self, root: ListNode, k: int) -\u003e List[ListNode]: n, p = 0, root while p: n += 1 p = p.next avg, extra = divmod(n, k) res, p = [root], ListNode(next=root) for i in range(k-1): for _ in range(avg+(i\u003cextra)): p = p.next res.append(p.next) p.next = None p = ListNode(next=res[-1])","date":"2016-12-25","objectID":"/leetcode/0725/:3:0","tags":null,"title":"0725：分隔链表（★）","uri":"/leetcode/0725/"},{"categories":null,"content":" 力扣第 724 题 ","date":"2016-12-24","objectID":"/leetcode/0724/:0:0","tags":null,"title":"0724：寻找数组的中心下标","uri":"/leetcode/0724/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，请计算数组的 中心下标 。 数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。 如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。 如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。 示例 1： 输入：nums = [1, 7, 3, 6, 5, 6]\r输出：3\r解释：\r中心下标是 3 。\r左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\r右侧","date":"2016-12-24","objectID":"/leetcode/0724/:1:0","tags":null,"title":"0724：寻找数组的中心下标","uri":"/leetcode/0724/"},{"categories":null,"content":"分析 对于中心索引 i，sum(nums[:i])==sum(nums[i+1:])，等价于 sum(nums[:i])*2+nums[i]==sum(nums)。所以遍历 i 判断是否符合即可。 ","date":"2016-12-24","objectID":"/leetcode/0724/:2:0","tags":null,"title":"0724：寻找数组的中心下标","uri":"/leetcode/0724/"},{"categories":null,"content":"解答 def pivotIndex(self, nums: List[int]) -\u003e int: s, pre = sum(nums), 0 for i, num in enumerate(nums): if pre*2+num == s: return i pre += num return -1 60 ms ","date":"2016-12-24","objectID":"/leetcode/0724/:3:0","tags":null,"title":"0724：寻找数组的中心下标","uri":"/leetcode/0724/"},{"categories":null,"content":" 力扣第 721 题 ","date":"2016-12-21","objectID":"/leetcode/0721/:0:0","tags":null,"title":"0721：账户合并（★）","uri":"/leetcode/0721/"},{"categories":null,"content":"题目 给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。 现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。 合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 按字符 ASCII 顺序排列 的邮箱地址。账户本身可以以 任意顺序 返回。","date":"2016-12-21","objectID":"/leetcode/0721/:1:0","tags":null,"title":"0721：账户合并（★）","uri":"/leetcode/0721/"},{"categories":null,"content":"分析 容易想到用并查集。如果账户 i 和 j 有共同邮箱，将 i 和 j 连通，最终每个连通子图即代表一个人。具体实现： 用字典 belong[email]=i 表示邮箱 email 属于账户 i\r遍历到账户 i，对于含有的每个邮箱 email：\r如果已在字典 belong 中，那么将 i 和 belong[email] 连通\r如果不在字典 belong 中，那么添加 belong[email]=i\r并查集连通后，连通子图中的账户有相同的祖先账号，因此可以遍历账户，将含有的邮箱都合并到祖先账号的邮箱中，最后输出所有祖先账号即可。 ","date":"2016-12-21","objectID":"/leetcode/0721/:2:0","tags":null,"title":"0721：账户合并（★）","uri":"/leetcode/0721/"},{"categories":null,"content":"解答 def accountsMerge(self, accounts: List[List[str]]) -\u003e List[List[str]]: def find(i): if p[i] != i: p[i] = find(p[i]) return p[i] def union(i, j): p[find(i)] = find(j) n = len(accounts) p, belong = list(range(n)), {} for i in range(n): for email in accounts[i][1:]: if email in belong: union(i, belo","date":"2016-12-21","objectID":"/leetcode/0721/:3:0","tags":null,"title":"0721：账户合并（★）","uri":"/leetcode/0721/"},{"categories":null,"content":"　　曾拥有过辉煌风光年代的一家歌剧院正逐步走向没落，更面临被银行抵押没收的命运。现任老板考拉巴斯特（马修·麦康纳希 Matthew McConaughey 配音）不愿见父亲毕生的心血就此终结，于是决定策划一场歌唱选秀比赛，却没留神把奖金印成了他根本无力承担的10万美元。受到奖金和歌唱梦想的鼓舞，猪妈妈罗茜塔（瑞茜·威瑟斯彭 Reese Witherspoon 饰）、少女豪猪艾什（斯嘉丽·约翰森 Scarlett Johansson 饰）、老鼠歌手麦克（塞斯·麦克法兰 Seth MacFarlane 饰）、害羞的小象米纳（托瑞·凯利Tori Kelly 饰）、大猩猩强尼（塔伦·埃格顿 Taron Egerton 饰）等音乐爱好者都纷纷前来应征。\n　　他们有着各自难以逾越的障碍，而为了各自的梦想，有竭尽全力，追逐哪怕一点点微茫的希望……","date":"2016-12-21","objectID":"/anime/sing/","tags":null,"title":"欢乐好声音","uri":"/anime/sing/"},{"categories":null,"content":"简介 曾拥有过辉煌风光年代的一家歌剧院正逐步走向没落，更面临被银行抵押没收的命运。现任老板考拉巴斯特（马修·麦康纳希 Matthew McConaughey 配音）不愿见父亲毕生的心血就此终结，于是决定策划一场歌唱选秀比赛，却没留神把奖金印成了他根本无力承担的10万美元。受到奖金和歌唱梦想的鼓舞，猪妈妈罗茜塔（瑞茜·威瑟斯彭 Reese Witherspoon 饰）、少女豪猪艾什（斯嘉丽·约翰森 Scarlett Johansson 饰）、老鼠歌手麦克（塞斯·麦克法兰 Seth MacFarlane 饰）、害羞的小象米纳（托瑞·凯利Tori Kelly 饰）、大猩猩强尼（塔伦·埃格顿 Taro","date":"2016-12-21","objectID":"/anime/sing/:1:0","tags":null,"title":"欢乐好声音","uri":"/anime/sing/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾什 雌 Scarlett Johansson 2 月伯乐 雄 Matthew McConaughey 3 Mike 雄 Seth MacFarlane 4 罗茜塔 雌 5 米娜 雌 6 乔尼 雄 7 埃迪 雄 John C. Reilly 8 Bob News Reporter Dog 雄 Bill Farmer ","date":"2016-12-21","objectID":"/anime/sing/:2:0","tags":null,"title":"欢乐好声音","uri":"/anime/sing/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 欢乐好声音 2016-12-21 1 樱花 ","date":"2016-12-21","objectID":"/anime/sing/:3:0","tags":null,"title":"欢乐好声音","uri":"/anime/sing/"},{"categories":null,"content":" 力扣第 720 题 ","date":"2016-12-20","objectID":"/leetcode/0720/:0:0","tags":null,"title":"0720：词典中最长的单词（★）","uri":"/leetcode/0720/"},{"categories":null,"content":"题目 给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。 若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。 示例 1： 输入：words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]\r输出：\"world\"\r解释： 单词\"world\"可由\"w\", \"wo\", \"wor\", 和 \"worl\"逐步添加一个字母组成。\r示例 2： 输入：words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"app","date":"2016-12-20","objectID":"/leetcode/0720/:1:0","tags":null,"title":"0720：词典中最长的单词（★）","uri":"/leetcode/0720/"},{"categories":null,"content":"分析 将单词排序，单词的前缀如果存在，必然排在前面。 边遍历边将符合条件（所有前缀都在词典中）的单词存在哈希中，那么 word 符合条件等价于 word[:-1] 在哈希中。 哈希中最长且最早出现的单词即为所求。 ","date":"2016-12-20","objectID":"/leetcode/0720/:2:0","tags":null,"title":"0720：词典中最长的单词（★）","uri":"/leetcode/0720/"},{"categories":null,"content":"解答 def longestWord(self, words): res, vis = '', {''} for word in sorted(words): if word[:-1] in vis: vis.add(word) res = word if len(word) \u003e len(res) else res return res 40 ms ","date":"2016-12-20","objectID":"/leetcode/0720/:3:0","tags":null,"title":"0720：词典中最长的单词（★）","uri":"/leetcode/0720/"},{"categories":null,"content":" 力扣第 718 题 ","date":"2016-12-18","objectID":"/leetcode/0718/:0:0","tags":null,"title":"0718：最长重复子数组（★）","uri":"/leetcode/0718/"},{"categories":null,"content":"题目 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。 示例 1： 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\r输出：3\r解释：长度最长的公共子数组是 [3,2,1] 。\r示例 2： 输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\r输出：5\r提示： 1 \u003c= nums1.length, nums2.length \u003c= 1000\r0 \u003c= nums1[i], nums2[i] \u003c= 100\r","date":"2016-12-18","objectID":"/leetcode/0718/:1:0","tags":null,"title":"0718：最长重复子数组（★）","uri":"/leetcode/0718/"},{"categories":null,"content":"分析 ","date":"2016-12-18","objectID":"/leetcode/0718/:2:0","tags":null,"title":"0718：最长重复子数组（★）","uri":"/leetcode/0718/"},{"categories":null,"content":"#1 令 dp[i][j] 代表最长的长度 size 使得 nums1[i-size:i]==nums2[j-size:j]，显然可以递推。 最后 dp 数组中的最大值即为所求。 def findLength(self, nums1: List[int], nums2: List[int]) -\u003e int: m, n = len(nums1), len(nums2) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): dp[i][j] = 0 if nums1[i-1] != ","date":"2016-12-18","objectID":"/leetcode/0718/:2:1","tags":null,"title":"0718：最长重复子数组（★）","uri":"/leetcode/0718/"},{"categories":null,"content":"#2 还有个巧妙的方法，如果 nums1 和 nums2 存在长度 x 的公共子数组，那么对任意 y\u003cx，必然也存在长度 y 的公共子数组。 因此令 check(x) 代表 nums1 和 nums2 是否存在长度 x 的公共子数组，该函数具有单调性，可以二分查找最大的 x，即为所求。 具体实现 check(x) 时，可以用滚动哈希在 O(N+M) 时间得到 nums1 和 nums2 所有长 x 的子数组的哈希值，判断是否有交集即可。 元素种类最多 100，用到的窗口种类最多 10^4，因此考虑 base 取 113，mod 取 10^9+7 ","date":"2016-12-18","objectID":"/leetcode/0718/:2:2","tags":null,"title":"0718：最长重复子数组（★）","uri":"/leetcode/0718/"},{"categories":null,"content":"解答 def findLength(self, nums1: List[int], nums2: List[int]) -\u003e int: def gen(A, L): ans, w, bL = set(), 0, pow(base, L, mod) for j, a in enumerate(A): w = w*base+a if j\u003e=L: w -= A[j-L]*bL w %= mod if j\u003e=L-1: ans.add(w) return ans base, mod = 113, 10**9+7 self.__class__.__getitem__ = lambda self, L: n","date":"2016-12-18","objectID":"/leetcode/0718/:3:0","tags":null,"title":"0718：最长重复子数组（★）","uri":"/leetcode/0718/"},{"categories":null,"content":" 力扣第 714 题 ","date":"2016-12-14","objectID":"/leetcode/0714/:0:0","tags":null,"title":"0714：买卖股票的最佳时机含手续费（★）","uri":"/leetcode/0714/"},{"categories":null,"content":"题目 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1： 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2\r输出：8\r解释：能够达到的最大利润:\r在此处买入 prices[0] = 1\r在此处卖出 prices[3] = 8\r在此处买入 prices[","date":"2016-12-14","objectID":"/leetcode/0714/:1:0","tags":null,"title":"0714：买卖股票的最佳时机含手续费（★）","uri":"/leetcode/0714/"},{"categories":null,"content":"分析 ","date":"2016-12-14","objectID":"/leetcode/0714/:2:0","tags":null,"title":"0714：买卖股票的最佳时机含手续费（★）","uri":"/leetcode/0714/"},{"categories":null,"content":"#1 与 0122 类似，但方法行不通了，考虑与 0309 一样，尝试动态规划。 令 sell[i] 表示 prices[:i] 能获得的最大利润，buy[i] 代表买入状态下 prices[:i] 能获得的最大利润，状态转移方程为： if i==0: sell[i]=0, buy[i]=float('-inf')\relse: sell[i] = max(sell[i-1], buy[i-1]+prices[i-1]-fee)\rbuy[i] = max(buy[i-1], sell[i-1]-prices[i-1])\rdef maxProfit(self, prices: List[int],","date":"2016-12-14","objectID":"/leetcode/0714/:2:1","tags":null,"title":"0714：买卖股票的最佳时机含手续费（★）","uri":"/leetcode/0714/"},{"categories":null,"content":"#2 类似 0309 ，可以只用两个参数 buy, sell 保存状态，先更新 buy 不会影响到 sell。 ","date":"2016-12-14","objectID":"/leetcode/0714/:2:2","tags":null,"title":"0714：买卖股票的最佳时机含手续费（★）","uri":"/leetcode/0714/"},{"categories":null,"content":"解答 def maxProfit(self, prices: List[int], fee: int) -\u003e int: buy, sell = float('-inf'), 0 for price in prices: buy = max(buy, sell-price) sell = max(sell, buy+price-fee) return sell 812 ms ","date":"2016-12-14","objectID":"/leetcode/0714/:3:0","tags":null,"title":"0714：买卖股票的最佳时机含手续费（★）","uri":"/leetcode/0714/"},{"categories":null,"content":" 力扣第 713 题 ","date":"2016-12-13","objectID":"/leetcode/0713/:0:0","tags":null,"title":"0713：乘积小于 K 的子数组（★）","uri":"/leetcode/0713/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。 示例 1： 输入：nums = [10,5,2,6], k = 100\r输出：8\r解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。\r需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。\r示例 2： 输入：nums = [1,2,3], k = 0\r输出：0\r提示: 1 \u003c= nums.length \u003c= 3 * 104\r1 \u003c= nums[i] \u003c= 1000\r0 \u003c= k \u003c","date":"2016-12-13","objectID":"/leetcode/0713/:1:0","tags":null,"title":"0713：乘积小于 K 的子数组（★）","uri":"/leetcode/0713/"},{"categories":null,"content":"分析 遍历每个位置 j 作为结尾，找符合条件的最长子数组 [i, j]，即找到 j-i+1 个。 发现遍历中 i 必然是不动或向右移的，因此是滑动窗口。 注意排除 k\u003c=1 的特殊情况。 ","date":"2016-12-13","objectID":"/leetcode/0713/:2:0","tags":null,"title":"0713：乘积小于 K 的子数组（★）","uri":"/leetcode/0713/"},{"categories":null,"content":"解答 def numSubarrayProductLessThanK(self, nums: List[int], k: int) -\u003e int: if k \u003c= 1: return 0 res, i, s = 0, 0, 1 for j, num in enumerate(nums): s *= num while s \u003e= k: s //= nums[i] i += 1 res += j-i+1 return res 200 ms ","date":"2016-12-13","objectID":"/leetcode/0713/:3:0","tags":null,"title":"0713：乘积小于 K 的子数组（★）","uri":"/leetcode/0713/"},{"categories":null,"content":" 力扣第 712 题 ","date":"2016-12-12","objectID":"/leetcode/0712/:0:0","tags":null,"title":"0712：两个字符串的最小ASCII删除和（★）","uri":"/leetcode/0712/"},{"categories":null,"content":"题目 给定两个字符串s1 和 s2，返回 使两个字符串相等所需删除字符的 ASCII 值的最小和 。 示例 1: 输入: s1 = \"sea\", s2 = \"eat\" 输出: 231 解释: 在 \"sea\" 中删除 \"s\" 并将 \"s\" 的值(115)加入总和。 在 \"eat\" 中删除 \"t\" 并将 116 加入总和。 结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。 示例 2: 输入: s1 = \"delete\", s2 = \"leet\" 输出: 403 解释: 在 \"delete\" 中删除 \"dee\" 字符串变成 \"let\"， 将 100[d]+101[e]+","date":"2016-12-12","objectID":"/leetcode/0712/:1:0","tags":null,"title":"0712：两个字符串的最小ASCII删除和（★）","uri":"/leetcode/0712/"},{"categories":null,"content":"分析 0583 升级版，修改下删除代价即可。 ","date":"2016-12-12","objectID":"/leetcode/0712/:2:0","tags":null,"title":"0712：两个字符串的最小ASCII删除和（★）","uri":"/leetcode/0712/"},{"categories":null,"content":"解答 def minimumDeleteSum(self, s1: str, s2: str) -\u003e int: m, n = len(s1), len(s2) dp = [0]+list(accumulate(map(ord, s2))) for c in s1: prev = dp[:] dp[0] += ord(c) for j in range(1, n+1): if s2[j-1]==c: dp[j] = prev[j-1] else: dp[j] = min(ord(c)+prev[j], ord(s2[j-1])+dp[j-1]) return dp[-1] 512 ms ","date":"2016-12-12","objectID":"/leetcode/0712/:3:0","tags":null,"title":"0712：两个字符串的最小ASCII删除和（★）","uri":"/leetcode/0712/"},{"categories":null,"content":" 力扣第 710 题 ","date":"2016-12-10","objectID":"/leetcode/0710/:0:0","tags":null,"title":"0710：黑名单中的随机数（★★）","uri":"/leetcode/0710/"},{"categories":null,"content":"题目 给定一个整数 n 和一个 无重复 黑名单整数数组 blacklist 。设计一种算法，从 [0, n - 1] 范围内的任意整数中选取一个 未加入 黑名单 blacklist 的整数。任何在上述范围内且不在黑名单 blacklist 中的整数都应该有 同等的可能性 被返回。 优化你的算法，使它最小化调用语言 内置 随机函数的次数。 实现 Solution 类: Solution(int n, int[] blacklist) 初始化整数 n 和被加入黑名单 blacklist 的整数\rint pick() 返回一个范围为 [0, n - 1] 且不在黑名单 blacklist 中的随机整","date":"2016-12-10","objectID":"/leetcode/0710/:1:0","tags":null,"title":"0710：黑名单中的随机数（★★）","uri":"/leetcode/0710/"},{"categories":null,"content":"分析 设数组 A=list(range(n))，要求的即是从 A 中随机选一个不在黑名单中的数。 为了方便随机，考虑将黑名单的数都交换到前面。设 m=len(blacklist)，交换完成后从 A[m:] 中随机选一个数即可。 但是 n 很大，直接构造 A 会超时。有个巧妙的想法是 A[m:] 中最多有 m 个数是经过了交换的，其它的就等于下标。 那么用哈希表 d 维护 A[m:] 中经过了交换的数，则对于任意 y\u003e=m，A[y]=d.get(y, y)。 因此随机取 \u003e=m 的下标 y，返回 d.get(y, y) 即可。 具体维护哈希表时，将 （黑名单中 \u003e=m 的数） 和 （[0,m) ","date":"2016-12-10","objectID":"/leetcode/0710/:2:0","tags":null,"title":"0710：黑名单中的随机数（★★）","uri":"/leetcode/0710/"},{"categories":null,"content":"解答 class Solution: def __init__(self, n: int, blacklist: List[int]): m, vis = len(blacklist), set(blacklist) B = [y for y in vis if y\u003e=m] A = [x for x in range(m) if x not in vis] self.d = dict(zip(B, A)) self.n = n self.m = m def pick(self) -\u003e int: y = random.randint(self.m, self.n-1) return self.d","date":"2016-12-10","objectID":"/leetcode/0710/:3:0","tags":null,"title":"0710：黑名单中的随机数（★★）","uri":"/leetcode/0710/"},{"categories":null,"content":" 力扣第 707 题 ","date":"2016-12-07","objectID":"/leetcode/0707/:0:0","tags":null,"title":"0707：设计链表（★）","uri":"/leetcode/0707/"},{"categories":null,"content":"题目 你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。\rint get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\rvoid addAtHead(int val) 将一个值为 val 的节点插入到链表中第","date":"2016-12-07","objectID":"/leetcode/0707/:1:0","tags":null,"title":"0707：设计链表（★）","uri":"/leetcode/0707/"},{"categories":null,"content":"分析 先定义节点 ListNode，然后再设计链表。需要经常判断索引是否有效，因此可以维护链表的长度。 ","date":"2016-12-07","objectID":"/leetcode/0707/:2:0","tags":null,"title":"0707：设计链表（★）","uri":"/leetcode/0707/"},{"categories":null,"content":"解答 class ListNode: def __init__(self, x=None, next=None): self.val = x self.next = next class MyLinkedList: def __init__(self): self.size = 0 self.dummy = ListNode() def get(self, index: int) -\u003e int: if index \u003c 0 or index \u003e= self.size: return -1 p = self.dummy for _ in range(index+1): p = p.next ret","date":"2016-12-07","objectID":"/leetcode/0707/:3:0","tags":null,"title":"0707：设计链表（★）","uri":"/leetcode/0707/"},{"categories":null,"content":" 力扣第 706 题 ","date":"2016-12-06","objectID":"/leetcode/0706/:0:0","tags":null,"title":"0706：设计哈希映射","uri":"/leetcode/0706/"},{"categories":null,"content":"题目 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。 实现 MyHashMap 类： MyHashMap() 用空映射初始化对象\rvoid put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。\rint get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。\rvoid remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。\r示例： 输入：\r[\"MyHa","date":"2016-12-06","objectID":"/leetcode/0706/:1:0","tags":null,"title":"0706：设计哈希映射","uri":"/leetcode/0706/"},{"categories":null,"content":"分析 类似 0705，只不过要将 key 和 value 一起存储。 ","date":"2016-12-06","objectID":"/leetcode/0706/:2:0","tags":null,"title":"0706：设计哈希映射","uri":"/leetcode/0706/"},{"categories":null,"content":"解答 class MyHashMap: def __init__(self): self.size = 1009 self.A = [[] for _ in range(self.size)] def put(self, key: int, value: int) -\u003e None: arr = self.A[key % self.size] for pair in arr: if pair[0] == key: pair[1] = value return arr.append([key, value]) def get(self, key: int) -\u003e int: for pair in ","date":"2016-12-06","objectID":"/leetcode/0706/:3:0","tags":null,"title":"0706：设计哈希映射","uri":"/leetcode/0706/"},{"categories":null,"content":" 力扣第 705 题 ","date":"2016-12-05","objectID":"/leetcode/0705/:0:0","tags":null,"title":"0705：设计哈希集合","uri":"/leetcode/0705/"},{"categories":null,"content":"题目 不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： void add(key) 向哈希集合中插入值 key 。\rbool contains(key) 返回哈希集合中是否存在这个值 key 。\rvoid remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。\r示例： 输入：\r[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\r[[], [1], [2], [1], [3],","date":"2016-12-05","objectID":"/leetcode/0705/:1:0","tags":null,"title":"0705：设计哈希集合","uri":"/leetcode/0705/"},{"categories":null,"content":"分析 ","date":"2016-12-05","objectID":"/leetcode/0705/:2:0","tags":null,"title":"0705：设计哈希集合","uri":"/leetcode/0705/"},{"categories":null,"content":"#1 key 的范围较小，可以直接用一个数组一一对应。 class MyHashSet: def __init__(self): self.A = [False] * (10**6+1) def add(self, key: int) -\u003e None: self.A[key] = True def remove(self, key: int) -\u003e None: self.A[key] = False def contains(self, key: int) -\u003e bool: return self.A[key] 268 ms ","date":"2016-12-05","objectID":"/leetcode/0705/:2:1","tags":null,"title":"0705：设计哈希集合","uri":"/leetcode/0705/"},{"categories":null,"content":"#2 一般哈希表会用更小的空间来存储，这时要考虑冲突的情况。最简单的就是拉链法。 ","date":"2016-12-05","objectID":"/leetcode/0705/:2:2","tags":null,"title":"0705：设计哈希集合","uri":"/leetcode/0705/"},{"categories":null,"content":"解答 class MyHashSet: def __init__(self): self.size = 1009 self.A = [[] for _ in range(self.size)] def add(self, key: int) -\u003e None: if not self.contains(key): self.A[key%self.size].append(key) def remove(self, key: int) -\u003e None: if self.contains(key): self.A[key%self.size].remove(key) def contains(sel","date":"2016-12-05","objectID":"/leetcode/0705/:3:0","tags":null,"title":"0705：设计哈希集合","uri":"/leetcode/0705/"},{"categories":null,"content":" 力扣第 703 题 ","date":"2016-12-03","objectID":"/leetcode/0703/:0:0","tags":null,"title":"0703：数据流中的第 K 大元素","uri":"/leetcode/0703/"},{"categories":null,"content":"题目 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。 请实现 KthLargest 类： KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。\rint add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。\r示例： 输入：\r[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\r[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\r输出：\r[null, ","date":"2016-12-03","objectID":"/leetcode/0703/:1:0","tags":null,"title":"0703：数据流中的第 K 大元素","uri":"/leetcode/0703/"},{"categories":null,"content":"分析 维护一个 k 大小的小顶堆即可。 ","date":"2016-12-03","objectID":"/leetcode/0703/:2:0","tags":null,"title":"0703：数据流中的第 K 大元素","uri":"/leetcode/0703/"},{"categories":null,"content":"解答 class KthLargest: def __init__(self, k: int, nums: List[int]): self.pq = nums heapify(self.pq) self.k = k def add(self, val: int) -\u003e int: heappush(self.pq, val) while len(self.pq) \u003e self.k: heappop(self.pq) return self.pq[0] 72 ms ","date":"2016-12-03","objectID":"/leetcode/0703/:3:0","tags":null,"title":"0703：数据流中的第 K 大元素","uri":"/leetcode/0703/"},{"categories":null,"content":" 力扣第 701 题 ","date":"2016-12-01","objectID":"/leetcode/0701/:0:0","tags":null,"title":"0701：二叉搜索树中的插入操作（★）","uri":"/leetcode/0701/"},{"categories":null,"content":"题目 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 示例 1： 输入：root = [4,2,7,1,3], val = 5\r输出：[4,2,7,1,3,5]\r解释：另一个满足题目要求可以通过的树是：\r示例 2： 输入：root = [40,20,60,10,30,50,70], val = 25\r输出：[40,20,60,10,30,50,70","date":"2016-12-01","objectID":"/leetcode/0701/:1:0","tags":null,"title":"0701：二叉搜索树中的插入操作（★）","uri":"/leetcode/0701/"},{"categories":null,"content":"分析 按查找的过程递归，最终到达空节点的位置插入即可。 ","date":"2016-12-01","objectID":"/leetcode/0701/:2:0","tags":null,"title":"0701：二叉搜索树中的插入操作（★）","uri":"/leetcode/0701/"},{"categories":null,"content":"解答 def insertIntoBST(self, root: TreeNode, val: int) -\u003e TreeNode: if not root: return TreeNode(val) if root.val \u003c val: root.right = self.insertIntoBST(root.right, val) elif root.val \u003e val: root.left = self.insertIntoBST(root.left, val) return root 156 ms ","date":"2016-12-01","objectID":"/leetcode/0701/:3:0","tags":null,"title":"0701：二叉搜索树中的插入操作（★）","uri":"/leetcode/0701/"},{"categories":null,"content":" 力扣第 700 题 ","date":"2016-11-30","objectID":"/leetcode/0700/:0:0","tags":null,"title":"0700：二叉搜索树中的搜索","uri":"/leetcode/0700/"},{"categories":null,"content":"题目 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 示例 1: 输入：root = [4,2,7,1,3], val = 2\r输出：[2,1,3]\r示例 2: 输入：root = [4,2,7,1,3], val = 5\r输出：[]\r提示： 数中节点数在 [1, 5000] 范围内\r1 \u003c= Node.val \u003c= 107\rroot 是二叉搜索树\r1 \u003c= val \u003c= 107\r","date":"2016-11-30","objectID":"/leetcode/0700/:1:0","tags":null,"title":"0700：二叉搜索树中的搜索","uri":"/leetcode/0700/"},{"categories":null,"content":"分析 递归查找即可。因为是二叉搜索树，若当前值偏大就递归到左子树，若偏小就递归到右子树。 ","date":"2016-11-30","objectID":"/leetcode/0700/:2:0","tags":null,"title":"0700：二叉搜索树中的搜索","uri":"/leetcode/0700/"},{"categories":null,"content":"解答 def searchBST(self, root: TreeNode, val: int) -\u003e TreeNode: if not root: return None if root.val == val: return root return self.searchBST(root.left, val) if root.val \u003e val else self.searchBST(root.right, val) 84 ms ","date":"2016-11-30","objectID":"/leetcode/0700/:3:0","tags":null,"title":"0700：二叉搜索树中的搜索","uri":"/leetcode/0700/"},{"categories":null,"content":" 力扣第 698 题 ","date":"2016-11-28","objectID":"/leetcode/0698/:0:0","tags":null,"title":"0698：划分为k个相等的子集（★）","uri":"/leetcode/0698/"},{"categories":null,"content":"题目 给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例 1： 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4\r输出： True\r说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。\r示例 2: 输入: nums = [1,2,3,4], k = 3\r输出: false\r提示： 1 \u003c= k \u003c= len(nums) \u003c= 16\r0 \u003c nums[i] \u003c 10000\r每个元素的频率在 [1,4] 范围内\r","date":"2016-11-28","objectID":"/leetcode/0698/:1:0","tags":null,"title":"0698：划分为k个相等的子集（★）","uri":"/leetcode/0698/"},{"categories":null,"content":"分析 0473 升级版，将 4 改为 k 即可。 ","date":"2016-11-28","objectID":"/leetcode/0698/:2:0","tags":null,"title":"0698：划分为k个相等的子集（★）","uri":"/leetcode/0698/"},{"categories":null,"content":"解答 def canPartitionKSubsets(self, nums: List[int], k: int) -\u003e bool: s = sum(nums) if s%k: return False n, t = len(nums), s//k dp = [0]+[-1]*((1\u003c\u003cn)-1) for st in range(1\u003c\u003cn): if dp[st]\u003e=0: for i in range(n): if not st\u0026(1\u003c\u003ci) and dp[st]+nums[i]\u003c=t: dp[st|(1\u003c\u003ci)] = (dp[st]+nums[i])%t return dp[-1]==0 1","date":"2016-11-28","objectID":"/leetcode/0698/:3:0","tags":null,"title":"0698：划分为k个相等的子集（★）","uri":"/leetcode/0698/"},{"categories":null,"content":" 力扣第 697 题 ","date":"2016-11-27","objectID":"/leetcode/0697/:0:0","tags":null,"title":"0697：数组的度","uri":"/leetcode/0697/"},{"categories":null,"content":"题目 给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。 你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。 示例 1： 输入：nums = [1,2,2,3,1]\r输出：2\r解释：\r输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。\r连续子数组里面拥有相同度的有如下所示：\r[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\r最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。","date":"2016-11-27","objectID":"/leetcode/0697/:1:0","tags":null,"title":"0697：数组的度","uri":"/leetcode/0697/"},{"categories":null,"content":"分析 找到频数等于度的元素后，对应的子数组就是元素首次出现位置 i 和末次出现位置 j 之间 nums[i:j+1]。 因此可以先遍历得到每个元素的频数、首次出现位置、末次出现位置，再遍历找到结果。 ","date":"2016-11-27","objectID":"/leetcode/0697/:2:0","tags":null,"title":"0697：数组的度","uri":"/leetcode/0697/"},{"categories":null,"content":"解答 def findShortestSubArray(self, nums: List[int]) -\u003e int: d_first, d_last, d_cnt = {}, {}, Counter(nums) for i, num in enumerate(nums): d_first[num] = d_first.get(num, i) d_last[num] = i degree = max(d_cnt.values()) res = min(d_last[num]-d_first[num]+1 for num, cnt in d_cnt.items() if cnt==degree) ","date":"2016-11-27","objectID":"/leetcode/0697/:3:0","tags":null,"title":"0697：数组的度","uri":"/leetcode/0697/"},{"categories":null,"content":" 力扣第 695 题 ","date":"2016-11-25","objectID":"/leetcode/0695/:0:0","tags":null,"title":"0695：岛屿的最大面积（★）","uri":"/leetcode/0695/"},{"categories":null,"content":"题目 给你一个大小为 m x n 的二进制矩阵 grid 。 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。 岛屿的面积是岛上值为 1 的单元格的数目。 计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。 示例 1： 输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1","date":"2016-11-25","objectID":"/leetcode/0695/:1:0","tags":null,"title":"0695：岛屿的最大面积（★）","uri":"/leetcode/0695/"},{"categories":null,"content":"分析 ","date":"2016-11-25","objectID":"/leetcode/0695/:2:0","tags":null,"title":"0695：岛屿的最大面积（★）","uri":"/leetcode/0695/"},{"categories":null,"content":"#1 类似 0200，只不过从求岛屿数量换成求最大岛屿。 遍历时记录面积即可。 def maxAreaOfIsland(self, grid: List[List[int]]) -\u003e int: def dfs(i, j): cnt, grid[i][j] = 1, 'M' for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n and grid[x][y] == 1: cnt += dfs(x, y) return cnt res, m, n = 0, len(grid","date":"2016-11-25","objectID":"/leetcode/0695/:2:1","tags":null,"title":"0695：岛屿的最大面积（★）","uri":"/leetcode/0695/"},{"categories":null,"content":"#2 也可以用并查集，将相邻的陆地连通。最终统计陆地连通块的大小即可。 ","date":"2016-11-25","objectID":"/leetcode/0695/:2:2","tags":null,"title":"0695：岛屿的最大面积（★）","uri":"/leetcode/0695/"},{"categories":null,"content":"解答 def maxAreaOfIsland(self, grid: List[List[int]]) -\u003e int: def find(x): if f.setdefault(x, x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) f, m, n = {}, len(grid), len(grid[0]) for i, j in product(range(m), range(n)): if i and grid[i - 1][j] == grid[i][j] == 1: union((i","date":"2016-11-25","objectID":"/leetcode/0695/:3:0","tags":null,"title":"0695：岛屿的最大面积（★）","uri":"/leetcode/0695/"},{"categories":null,"content":" 力扣第 692 题 ","date":"2016-11-22","objectID":"/leetcode/0692/:0:0","tags":null,"title":"0692：前K个高频单词（★）","uri":"/leetcode/0692/"},{"categories":null,"content":"题目 给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。 示例 1： 输入: words = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\r输出: [\"i\", \"love\"]\r解析: \"i\" 和 \"love\" 为出现次数最多的两个单词，均为2次。\r注意，按字母顺序 \"i\" 在 \"love\" 之前。\r示例 2： 输入: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", ","date":"2016-11-22","objectID":"/leetcode/0692/:1:0","tags":null,"title":"0692：前K个高频单词（★）","uri":"/leetcode/0692/"},{"categories":null,"content":"分析 Counter 计数后，用 sort 或者 heapq.nsmallest 即可。 ","date":"2016-11-22","objectID":"/leetcode/0692/:2:0","tags":null,"title":"0692：前K个高频单词（★）","uri":"/leetcode/0692/"},{"categories":null,"content":"解答 def topKFrequent(self, words: List[str], k: int) -\u003e List[str]: ct = Counter(words) return nsmallest(k, ct, key=lambda x: (-ct[x], x)) 72 ms ","date":"2016-11-22","objectID":"/leetcode/0692/:3:0","tags":null,"title":"0692：前K个高频单词（★）","uri":"/leetcode/0692/"},{"categories":null,"content":" 力扣第 691 题 ","date":"2016-11-21","objectID":"/leetcode/0691/:0:0","tags":null,"title":"0691：贴纸拼词（★★）","uri":"/leetcode/0691/"},{"categories":null,"content":"题目 我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。 您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。 返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。 注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的，并且 target 被选择为两个随机单词的连接。 示例 1： 输入： stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\r输出：3\r解释：\r我们","date":"2016-11-21","objectID":"/leetcode/0691/:1:0","tags":null,"title":"0691：贴纸拼词（★★）","uri":"/leetcode/0691/"},{"categories":null,"content":"分析 按 target[0] 由哪个贴纸切割可以转为递归子问题。 本质上是完全背包问题 ","date":"2016-11-21","objectID":"/leetcode/0691/:2:0","tags":null,"title":"0691：贴纸拼词（★★）","uri":"/leetcode/0691/"},{"categories":null,"content":"解答 def minStickers(self, stickers: List[str], target: str) -\u003e int: @lru_cache(None) def dfs(t): if not t: return 0 res = float('inf') for ct in A: if t[0] in ct: new = t for x in ct: new = new.replace(x, '', ct[x]) res = min(res, 1+dfs(new)) return res A = [Counter(s) for s in stickers] res = dfs(ta","date":"2016-11-21","objectID":"/leetcode/0691/:3:0","tags":null,"title":"0691：贴纸拼词（★★）","uri":"/leetcode/0691/"},{"categories":null,"content":" 力扣第 689 题 ","date":"2016-11-19","objectID":"/leetcode/0689/:0:0","tags":null,"title":"0689：三个无重叠子数组的最大和（★★）","uri":"/leetcode/0689/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、且全部数字和（3 * k 项）最大的子数组，并返回这三个子数组。 以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。如果有多个结果，返回字典序最小的一个。 示例 1： 输入：nums = [1,2,1,2,6,7,5,1], k = 2\r输出：[0,3,5]\r解释：子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。\r也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。\r示例 2： 输入：nums = [1,2,","date":"2016-11-19","objectID":"/leetcode/0689/:1:0","tags":null,"title":"0689：三个无重叠子数组的最大和（★★）","uri":"/leetcode/0689/"},{"categories":null,"content":"分析 令 A[i] 代表 sum(nums[i:i+k])，问题转为求满足 x+k\u003c=y\u003c=z-k 的最大的 A[x]+A[y]+A[z]。 那么遍历 y，求 max(A[:y-k+1])+y+max(A[y+k:]) 即可。 令 left[i] 代表 max(A[:i+1])，right[i] 代表 max(A[i:])，都可以 O(N) 递推得到。 因为要返回下标位置，所以修改下，令 left 和 right 返回最大值对应的最小下标即可。 ","date":"2016-11-19","objectID":"/leetcode/0689/:2:0","tags":null,"title":"0689：三个无重叠子数组的最大和（★★）","uri":"/leetcode/0689/"},{"categories":null,"content":"解答 def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -\u003e List[int]: pre = list(accumulate([0]+nums)) A = [pre[i+k]-pre[i] for i in range(len(pre)-k)] n = len(A) left, right = list(range(n)), list(range(n)) for i in range(1, n): left[i] = i if A[i]\u003eA[left[i-1]] else left[i-1] for i in range(n-","date":"2016-11-19","objectID":"/leetcode/0689/:3:0","tags":null,"title":"0689：三个无重叠子数组的最大和（★★）","uri":"/leetcode/0689/"},{"categories":null,"content":" 力扣第 688 题 ","date":"2016-11-18","objectID":"/leetcode/0688/:0:0","tags":null,"title":"0688：骑士在棋盘上的概率（★）","uri":"/leetcode/0688/"},{"categories":null,"content":"题目 在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。 象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。 每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。 骑士继续移动，直到它走了 k 步或离开了棋盘。 返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。 示例 1： 输入: n = 3, k = 2, row = 0, colu","date":"2016-11-18","objectID":"/leetcode/0688/:1:0","tags":null,"title":"0688：骑士在棋盘上的概率（★）","uri":"/leetcode/0688/"},{"categories":null,"content":"分析 按第一步的移动方向即可转为递归子问题。 ","date":"2016-11-18","objectID":"/leetcode/0688/:2:0","tags":null,"title":"0688：骑士在棋盘上的概率（★）","uri":"/leetcode/0688/"},{"categories":null,"content":"解答 def knightProbability(self, n: int, k: int, row: int, column: int) -\u003e float: @lru_cache(None) def dfs(i, j, k): if not (0\u003c=i\u003cn and 0\u003c=j\u003cn): return 0 if k == 0: return 1 return sum(dfs(i+dx, j+dy, k-1) for dx, dy in A)/len(A) A = [(1, 2), (-1, 2), (1, -2), (-1, -2), (2, 1), (-2, 1), (2, -1), (-2, ","date":"2016-11-18","objectID":"/leetcode/0688/:3:0","tags":null,"title":"0688：骑士在棋盘上的概率（★）","uri":"/leetcode/0688/"},{"categories":null,"content":" 力扣第 687 题 ","date":"2016-11-17","objectID":"/leetcode/0687/:0:0","tags":null,"title":"0687：最长同值路径（★）","uri":"/leetcode/0687/"},{"categories":null,"content":"题目 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度 由它们之间的边数表示。 示例 1: 输入：root = [5,4,5,1,1,5]\r输出：2\r示例 2: 输入：root = [1,4,5,4,4,5]\r输出：2\r提示: 树的节点数的范围是 [0, 104] -1000 \u003c= Node.val \u003c= 1000\r树的深度将不超过 1000 ","date":"2016-11-17","objectID":"/leetcode/0687/:1:0","tags":null,"title":"0687：最长同值路径（★）","uri":"/leetcode/0687/"},{"categories":null,"content":"分析 类似 0543 用辅助函数 help(node) 同时返回 node 的最长同值路径， 向上的终点为 node 的最长同值路径。即可递归。 ","date":"2016-11-17","objectID":"/leetcode/0687/:2:0","tags":null,"title":"0687：最长同值路径（★）","uri":"/leetcode/0687/"},{"categories":null,"content":"解答 def longestUnivaluePath(self, root: TreeNode) -\u003e int: def help(root): if not root: return 0, 0 l0, l1 = help(root.left) r0, r1 = help(root.right) l1 = l1 + 1 if root.left and root.left.val == root.val else 0 r1 = r1 + 1 if root.right and root.right.val == root.val else 0 return max(l0, r0, l1+r1)","date":"2016-11-17","objectID":"/leetcode/0687/:3:0","tags":null,"title":"0687：最长同值路径（★）","uri":"/leetcode/0687/"},{"categories":null,"content":" 力扣第 686 题 ","date":"2016-11-16","objectID":"/leetcode/0686/:0:0","tags":null,"title":"0686：重复叠加字符串匹配（★）","uri":"/leetcode/0686/"},{"categories":null,"content":"题目 给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。 注意：字符串 \"abc\" 重复叠加 0 次是 \"\"，重复叠加 1 次是 \"abc\"，重复叠加 2 次是 \"abcabc\"。 示例 1： 输入：a = \"abcd\", b = \"cdabcdab\"\r输出：3\r解释：a 重复叠加三遍后为 \"abcdabcdabcd\", 此时 b 是其子串。\r示例 2： 输入：a = \"a\", b = \"aa\"\r输出：2\r示例 3： 输入：a = \"a\", b = \"a\"\r输出：1\r示例 4： 输入：a = \"abc\", b","date":"2016-11-16","objectID":"/leetcode/0686/:1:0","tags":null,"title":"0686：重复叠加字符串匹配（★）","uri":"/leetcode/0686/"},{"categories":null,"content":"分析 假设 b 是叠加 a 的子串，且 b[0] 匹配 a[i]， 那么根据 i 的范围可知 a 叠加后的长度最少 len(b)，最多 len(a)-1+len(b)。 因此令 k=len(b)//len(a)，那么 a 最少叠加 k 次，最多叠加 k+2 次，逐个判断即可。 ","date":"2016-11-16","objectID":"/leetcode/0686/:2:0","tags":null,"title":"0686：重复叠加字符串匹配（★）","uri":"/leetcode/0686/"},{"categories":null,"content":"解答 def repeatedStringMatch(self, a: str, b: str) -\u003e int: m, n = len(a), len(b) for x in range(n//m, n//m+3): if b in a*x: return x return -1 36 ms ","date":"2016-11-16","objectID":"/leetcode/0686/:3:0","tags":null,"title":"0686：重复叠加字符串匹配（★）","uri":"/leetcode/0686/"},{"categories":null,"content":" 力扣第 685 题 ","date":"2016-11-15","objectID":"/leetcode/0685/:0:0","tags":null,"title":"0685：冗余连接 II（★★）","uri":"/leetcode/0685/"},{"categories":null,"content":"题目 在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。 输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。 返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若","date":"2016-11-15","objectID":"/leetcode/0685/:1:0","tags":null,"title":"0685：冗余连接 II（★★）","uri":"/leetcode/0685/"},{"categories":null,"content":"分析 显然有根树等价于 所有节点连通，且只有一个节点入度为 0，其它节点入度都为 1。输入的图有两种情况： 多余的边指向根节点 图中所有节点的入度都为 1 ，形成一个环，而且去掉环中任意一条边都可以\r多余的边指向其它节点 v 图中只有节点 v 的入度为 2，应该选择一条指向 v 的边去掉使得剩下的所有节点连通\r因此可以先遍历边，统计入度，若有节点 v 的入度为 2，先用并查集判断删除第二条指向 v 的边是否满足条件，不满足就应该删除第一条。 若没有节点 v 的入度为 2，转为 0684 。 ","date":"2016-11-15","objectID":"/leetcode/0685/:2:0","tags":null,"title":"0685：冗余连接 II（★★）","uri":"/leetcode/0685/"},{"categories":null,"content":"解答 def findRedundantDirectedConnection(self, edges: List[List[int]]) -\u003e List[int]: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def isvalid(u, v): for x, y in edges: if (x, y) != (u, v): union(x - 1, y - 1) return sum(find(i)==i for i in range(n)) ==","date":"2016-11-15","objectID":"/leetcode/0685/:3:0","tags":null,"title":"0685：冗余连接 II（★★）","uri":"/leetcode/0685/"},{"categories":null,"content":" 力扣第 684 题 ","date":"2016-11-14","objectID":"/leetcode/0684/:0:0","tags":null,"title":"0684：冗余连接（★）","uri":"/leetcode/0684/"},{"categories":null,"content":"题目 树可以看成是一个连通且 无环 的 无向 图。 给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。 示例 1： 输入: edges = [[1,2], [1,3], [2,3]]\r输出: [2,3]\r示例 2： 输入: edges ","date":"2016-11-14","objectID":"/leetcode/0684/:1:0","tags":null,"title":"0684：冗余连接（★）","uri":"/leetcode/0684/"},{"categories":null,"content":"分析 ","date":"2016-11-14","objectID":"/leetcode/0684/:2:0","tags":null,"title":"0684：冗余连接（★）","uri":"/leetcode/0684/"},{"categories":null,"content":"#1 典型的并查集应用。遍历边，如果两个顶点已经连通则返回，否则就连通。 def findRedundantConnection(self, edges: List[List[int]]) -\u003e List[int]: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) f = list(range(len(edges) + 1)) for u, v in edges: if find(u) == find(v): return [u, v] union(u,","date":"2016-11-14","objectID":"/leetcode/0684/:2:1","tags":null,"title":"0684：冗余连接（★）","uri":"/leetcode/0684/"},{"categories":null,"content":"#2 也可以用拓扑排序。先将所有入度为 1 的顶点入队。然后每轮弹出队首顶点，将所有后继顶点的入度减一， 并将其中所有入度为 1 的顶点入队。循环直到队空，剩下的环中的顶点的入度都大于 1， 返回最后一条剩下的边即可。 ","date":"2016-11-14","objectID":"/leetcode/0684/:2:2","tags":null,"title":"0684：冗余连接（★）","uri":"/leetcode/0684/"},{"categories":null,"content":"解答 def findRedundantConnection(self, edges: List[List[int]]) -\u003e List[int]: n = len(edges) nxt, indeg = defaultdict(list), [0] * (n+1) for u, v in edges: nxt[u].append(v) nxt[v].append(u) indeg[u] += 1 indeg[v] += 1 queue = deque(u for u in range(1, n+1) if indeg[u]==1) while queue: u = queue.popleft","date":"2016-11-14","objectID":"/leetcode/0684/:3:0","tags":null,"title":"0684：冗余连接（★）","uri":"/leetcode/0684/"},{"categories":null,"content":" 力扣第 682 题 ","date":"2016-11-12","objectID":"/leetcode/0682/:0:0","tags":null,"title":"0682：棒球比赛","uri":"/leetcode/0682/"},{"categories":null,"content":"题目 你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。 比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则： 整数 x - 表示本回合新获得分数 x\r\"+\" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。\r\"D\" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。\r\"C\" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存","date":"2016-11-12","objectID":"/leetcode/0682/:1:0","tags":null,"title":"0682：棒球比赛","uri":"/leetcode/0682/"},{"categories":null,"content":"分析 既然保证了操作总是有效的，那么直接基于栈顶计算即可。 ","date":"2016-11-12","objectID":"/leetcode/0682/:2:0","tags":null,"title":"0682：棒球比赛","uri":"/leetcode/0682/"},{"categories":null,"content":"解答 def calPoints(self, ops: List[str]) -\u003e int: stack = [] for op in ops: if op == '+': stack.append(stack[-2]+stack[-1]) elif op == 'D': stack.append(stack[-1]*2) elif op == 'C': stack.pop() else: stack.append(int(op)) return sum(stack) 44 ms ","date":"2016-11-12","objectID":"/leetcode/0682/:3:0","tags":null,"title":"0682：棒球比赛","uri":"/leetcode/0682/"},{"categories":null,"content":" 力扣第 680 题 ","date":"2016-11-10","objectID":"/leetcode/0680/:0:0","tags":null,"title":"0680：验证回文串 II","uri":"/leetcode/0680/"},{"categories":null,"content":"题目 给你一个字符串 s，最多 可以从中删除一个字符。 请你判断 s 是否能成为回文字符串：如果能，返回 true ；否则，返回 false 。 示例 1： 输入：s = \"aba\" 输出：true 示例 2： 输入：s = \"abca\" 输出：true 解释：你可以删除字符 'c' 。 示例 3： 输入：s = \"abc\" 输出：false 提示： 1 \u003c= s.length \u003c= 105 s 由小写英文字母组成 ","date":"2016-11-10","objectID":"/leetcode/0680/:1:0","tags":null,"title":"0680：验证回文串 II","uri":"/leetcode/0680/"},{"categories":null,"content":"分析 最直接的就是遍历删除每个字符的情况，判断是否回文，但太费时间。 观察可知，只需从两边遍历，删除第一对不等字符的一个即可。 ","date":"2016-11-10","objectID":"/leetcode/0680/:2:0","tags":null,"title":"0680：验证回文串 II","uri":"/leetcode/0680/"},{"categories":null,"content":"解答 def validPalindrome(self, s: str) -\u003e bool: if s == s[::-1]: return True l, r = 0, len(s) - 1 while l \u003c r and s[l] == s[r]: l += 1 r -= 1 a, b = s[l+1:r+1], s[l:r] return a==a[::-1] or b==b[::-1] 时间复杂度 O(N)，64 ms ","date":"2016-11-10","objectID":"/leetcode/0680/:3:0","tags":null,"title":"0680：验证回文串 II","uri":"/leetcode/0680/"},{"categories":null,"content":" 力扣第 678 题 ","date":"2016-11-08","objectID":"/leetcode/0678/:0:0","tags":null,"title":"0678：有效的括号字符串（★）","uri":"/leetcode/0678/"},{"categories":null,"content":"题目 给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则： 任何左括号 ( 必须有相应的右括号 )。\r任何右括号 ) 必须有相应的左括号 ( 。\r左括号 ( 必须在对应的右括号之前 )。\r* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。\r一个空字符串也被视为有效字符串。\r示例 1: 输入: \"()\"\r输出: True\r示例 2: 输入: \"(*)\"\r输出: True\r示例 3: 输入: \"(*))\"\r输出: True\r注意: 字符串大小将在 [1，100] 范围内。\r","date":"2016-11-08","objectID":"/leetcode/0678/:1:0","tags":null,"title":"0678：有效的括号字符串（★）","uri":"/leetcode/0678/"},{"categories":null,"content":"分析 先不考虑星号，那么类似 0032，可以得到不属于有效子串的括号的位置。 再考虑星号，要使得字符串变为有效，那么无效 ‘)’ 的左边必然有星号作为 ‘(’，无效 ‘(’ 的右边必然有星号作为 ‘)’。 因此再用一个栈维护星号的位置，遇到无效 ‘)’ 时弹出一个星号。最终判断栈里的无效 ‘(’ 是否都能分配一个处于右边的星号即可。 ","date":"2016-11-08","objectID":"/leetcode/0678/:2:0","tags":null,"title":"0678：有效的括号字符串（★）","uri":"/leetcode/0678/"},{"categories":null,"content":"解答 def checkValidString(self, s: str) -\u003e bool: stack, stack2 = [], [] for i, char in enumerate(s): if char == '(': stack.append(i) elif char == '*': stack2.append(i) elif stack: stack.pop() elif stack2: stack2.pop() else: return False while stack: if not stack2 or stack.pop() \u003e stack2.pop(): return ","date":"2016-11-08","objectID":"/leetcode/0678/:3:0","tags":null,"title":"0678：有效的括号字符串（★）","uri":"/leetcode/0678/"},{"categories":null,"content":" 力扣第 677 题 ","date":"2016-11-07","objectID":"/leetcode/0677/:0:0","tags":null,"title":"0677：键值映射（★）","uri":"/leetcode/0677/"},{"categories":null,"content":"题目 设计一个 map ，满足以下几点: 字符串表示键，整数表示值\r返回具有前缀等于给定字符串的键的值的总和\r实现一个 MapSum 类： MapSum() 初始化 MapSum 对象\rvoid insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对 key-value 将被替代成新的键值对。\rint sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。\r示例 1： 输入：\r[\"MapSum\", \"insert\", \"sum\",","date":"2016-11-07","objectID":"/leetcode/0677/:1:0","tags":null,"title":"0677：键值映射（★）","uri":"/leetcode/0677/"},{"categories":null,"content":"分析 ","date":"2016-11-07","objectID":"/leetcode/0677/:2:0","tags":null,"title":"0677：键值映射（★）","uri":"/leetcode/0677/"},{"categories":null,"content":"#1 最简单的就是直接用哈希。计算 sum 时，遍历哈希中所有 key 判断是否以 prefix 开头即可。 class MapSum: def __init__(self): self.d = {} def insert(self, key: str, val: int) -\u003e None: self.d[key] = val def sum(self, prefix: str) -\u003e int: return sum(self.d[key] for key in self.d if key.startswith(prefix)) 36 ms ","date":"2016-11-07","objectID":"/leetcode/0677/:2:1","tags":null,"title":"0677：键值映射（★）","uri":"/leetcode/0677/"},{"categories":null,"content":"#2 还可以用字典树优化时间。在 insert 时可以动态维护前缀对应的键值和（每个节点都新加一个 ‘val’ 属性来维护），计算 sum 时查询即可。 注意到 insert 时，若 key 已经存在，路径上所有的节点都需要更新 ‘val’ 的值。 ","date":"2016-11-07","objectID":"/leetcode/0677/:2:2","tags":null,"title":"0677：键值映射（★）","uri":"/leetcode/0677/"},{"categories":null,"content":"解答 class MapSum: def __init__(self): T = lambda: defaultdict(T) self.trie = T() self.d = defaultdict(int) def insert(self, key: str, val: int) -\u003e None: diff = val - self.d[key] self.d[key] = val p = self.trie for char in key: p = p[char] p['val'] = p.get('val', 0) + diff def sum(self, prefix: str) -","date":"2016-11-07","objectID":"/leetcode/0677/:3:0","tags":null,"title":"0677：键值映射（★）","uri":"/leetcode/0677/"},{"categories":null,"content":" 力扣第 676 题 ","date":"2016-11-06","objectID":"/leetcode/0676/:0:0","tags":null,"title":"0676：实现一个魔法字典（★）","uri":"/leetcode/0676/"},{"categories":null,"content":"题目 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。 实现 MagicDictionary 类： MagicDictionary() 初始化对象\rvoid buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同\rbool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使","date":"2016-11-06","objectID":"/leetcode/0676/:1:0","tags":null,"title":"0676：实现一个魔法字典（★）","uri":"/leetcode/0676/"},{"categories":null,"content":"分析 因为单词的长度较短且只含小写字母，所以可以遍历所有能转换得到的单词，判断是否在字典中即可。 还有个巧妙的想法，可以将单词的某一位改为 ‘.’ 作为单词的 key。 例如 hit 的 key 为 ‘.it’、‘h.t’、‘hi.’。 那么先将字典中的单词按所有的 key 存在哈希表中，查询时找 key 相同且不同的单词即可。 ","date":"2016-11-06","objectID":"/leetcode/0676/:2:0","tags":null,"title":"0676：实现一个魔法字典（★）","uri":"/leetcode/0676/"},{"categories":null,"content":"解答 class MagicDictionary: def __init__(self): self.d = defaultdict(set) def buildDict(self, dictionary: List[str]) -\u003e None: for word in dictionary: for i in range(len(word)): key = word[:i] + '.' + word[i+1:] self.d[key].add(word) def search(self, searchWord: str) -\u003e bool: for i in range(len(searchW","date":"2016-11-06","objectID":"/leetcode/0676/:3:0","tags":null,"title":"0676：实现一个魔法字典（★）","uri":"/leetcode/0676/"},{"categories":null,"content":" 力扣第 673 题 ","date":"2016-11-03","objectID":"/leetcode/0673/:0:0","tags":null,"title":"0673：最长递增子序列的个数（★）","uri":"/leetcode/0673/"},{"categories":null,"content":"题目 给定一个未排序的整数数组 nums ， 返回最长递增子序列的个数 。 注意 这个数列必须是 严格 递增的。 示例 1: 输入: [1,3,5,4,7]\r输出: 2\r解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。\r示例 2: 输入: [2,2,2,2,2]\r输出: 5\r解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。\r提示: 1 \u003c= nums.length \u003c= 2000\r-106 \u003c= nums[i] \u003c= 106\r","date":"2016-11-03","objectID":"/leetcode/0673/:1:0","tags":null,"title":"0673：最长递增子序列的个数（★）","uri":"/leetcode/0673/"},{"categories":null,"content":"分析 ","date":"2016-11-03","objectID":"/leetcode/0673/:2:0","tags":null,"title":"0673：最长递增子序列的个数（★）","uri":"/leetcode/0673/"},{"categories":null,"content":"#1 0300 的升级版，可以先求出 dp[j] 代表结尾位置 j 的最长递增子序列长度。 再令 dp2[j] 代表结尾位置 j 的最长递增子序列长度的个数，则： dp2[j] = sum(dp2[i] for i in range(j) if nums[i]\u003cnums[j] and dp[i]==dp[j]-1) or 1\r最终所有满足 dp[j]==max(dp) 的 dp2[j] 之和即为所求。 def findNumberOfLIS(self, nums: List[int]) -\u003e int: n = len(nums) dp, dp2 = [0]*n, [0]*n for j in ","date":"2016-11-03","objectID":"/leetcode/0673/:2:1","tags":null,"title":"0673：最长递增子序列的个数（★）","uri":"/leetcode/0673/"},{"categories":null,"content":"#2 0300 中能优化 dp 的递推。考虑能否优化 dp2 的递推。 注意到递推 dp2[j] 时，只需要满足 dp[i]==dp[j]-1 的位置 i。 考虑维护 B[x] 代表 dp[i]==x 的所有 \u003cnums[i],dp2[i]\u003e，问题转为求 sum(b for a,b in B[dp[j]-1] if a\u003cnums[j])。 然后将 \u003cnums[j],dp2[j]\u003e 添加到 B[dp[j]] 中即可维护 B。 注意到 B[x] 中的第一个元素必然是单调非减的，因此可以二分查找到第一个 pos 满足 B[dp[j]-1][pos][0]\u003cnums[j]，问题转为求 sum(b fo","date":"2016-11-03","objectID":"/leetcode/0673/:2:2","tags":null,"title":"0673：最长递增子序列的个数（★）","uri":"/leetcode/0673/"},{"categories":null,"content":"解答 def findNumberOfLIS(self, nums: List[int]) -\u003e int: B = [[(float('inf'), 0), (float('-inf'), 1)]] for num in nums: self.__class__.__getitem__ = lambda self, x: x==len(B) or B[x][-1][0]\u003e=num x = bisect_left(self, True, 0, len(B)) if x==len(B): B.append([(float('inf'), 0)]) self.__class__.__getitem_","date":"2016-11-03","objectID":"/leetcode/0673/:3:0","tags":null,"title":"0673：最长递增子序列的个数（★）","uri":"/leetcode/0673/"},{"categories":null,"content":" 力扣第 672 题 ","date":"2016-11-02","objectID":"/leetcode/0672/:0:0","tags":null,"title":"0672：灯泡开关 Ⅱ（★）","uri":"/leetcode/0672/"},{"categories":null,"content":"题目 房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。 这 4 个开关各自都具有不同的功能，其中： 开关 1 ：反转当前所有灯的状态（即开变为关，关变为开）\r开关 2 ：反转编号为偶数的灯的状态（即 0, 2, 4, ...）\r开关 3 ：反转编号为奇数的灯的状态（即 1, 3, ...）\r开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...）\r你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。 给你两个整数 n 和 presses","date":"2016-11-02","objectID":"/leetcode/0672/:1:0","tags":null,"title":"0672：灯泡开关 Ⅱ（★）","uri":"/leetcode/0672/"},{"categories":null,"content":"分析 ","date":"2016-11-02","objectID":"/leetcode/0672/:2:0","tags":null,"title":"0672：灯泡开关 Ⅱ（★）","uri":"/leetcode/0672/"},{"categories":null,"content":"解答 ","date":"2016-11-02","objectID":"/leetcode/0672/:3:0","tags":null,"title":"0672：灯泡开关 Ⅱ（★）","uri":"/leetcode/0672/"},{"categories":null,"content":" 力扣第 671 题 ","date":"2016-11-01","objectID":"/leetcode/0671/:0:0","tags":null,"title":"0671：二叉树中第二小的节点","uri":"/leetcode/0671/"},{"categories":null,"content":"题目 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。 更正式地说，即 root.val = min(root.left.val, root.right.val) 总成立。 给出这样的一个二叉树，你需要输出所有节点中的 第二小的值 。 如果第二小的值不存在的话，输出 -1 。 示例 1： 输入：root = [2,2,5,null,null,5,7]\r输出：5\r解释：最小的值是 2 ，第二小的值是 5 。\r示例 2： 输入：root = [2,2,2]\r输出：-1\r解释：最小的值是 ","date":"2016-11-01","objectID":"/leetcode/0671/:1:0","tags":null,"title":"0671：二叉树中第二小的节点","uri":"/leetcode/0671/"},{"categories":null,"content":"分析 递归查找大于 root.val 的最小数即可。显然，若当前节点大于 root.val，可以直接返回，无需再遍历子树了。 ","date":"2016-11-01","objectID":"/leetcode/0671/:2:0","tags":null,"title":"0671：二叉树中第二小的节点","uri":"/leetcode/0671/"},{"categories":null,"content":"解答 def findSecondMinimumValue(self, root: TreeNode) -\u003e int: def help(node): if not node: return float('inf') if node.val \u003e root.val: return node.val return min(help(node.left), help(node.right)) res = help(root) return res if res \u003c float('inf') else -1 40 ms ","date":"2016-11-01","objectID":"/leetcode/0671/:3:0","tags":null,"title":"0671：二叉树中第二小的节点","uri":"/leetcode/0671/"},{"categories":null,"content":" 力扣第 669 题 ","date":"2016-10-30","objectID":"/leetcode/0669/:0:0","tags":null,"title":"0669：修剪二叉搜索树（★）","uri":"/leetcode/0669/"},{"categories":null,"content":"题目 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例 1： 输入：root = [1,0,2], low = 1, high = 2\r输出：[1,null,2]\r示例 2： 输入：root = [3,0,4,null,2,null,null,1], low = 1, ","date":"2016-10-30","objectID":"/leetcode/0669/:1:0","tags":null,"title":"0669：修剪二叉搜索树（★）","uri":"/leetcode/0669/"},{"categories":null,"content":"分析 按是否保留根节点，分别递归即可。 ","date":"2016-10-30","objectID":"/leetcode/0669/:2:0","tags":null,"title":"0669：修剪二叉搜索树（★）","uri":"/leetcode/0669/"},{"categories":null,"content":"解答 def trimBST(self, root: TreeNode, low: int, high: int) -\u003e TreeNode: if not root: return None if root.val \u003c low: return self.trimBST(root.right, low, high) if root.val \u003e high: return self.trimBST(root.left, low, high) root.left = self.trimBST(root.left, low, high) root.right = self.trimBST(root.ri","date":"2016-10-30","objectID":"/leetcode/0669/:3:0","tags":null,"title":"0669：修剪二叉搜索树（★）","uri":"/leetcode/0669/"},{"categories":null,"content":" 力扣第 664 题 ","date":"2016-10-25","objectID":"/leetcode/0664/:0:0","tags":null,"title":"0664：奇怪的打印机（★★）","uri":"/leetcode/0664/"},{"categories":null,"content":"题目 有台奇怪的打印机有以下两个特殊要求： 打印机每次只能打印由 同一个字符 组成的序列。 每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。 给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。 示例 1： 输入：s = \"aaabbb\" 输出：2 解释：首先打印 \"aaa\" 然后打印 \"bbb\"。 示例 2： 输入：s = \"aba\" 输出：2 解释：首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 'a'。 提示： 1 \u003c= s.length \u003c= 100 s 由小写英文字母组成 ","date":"2016-10-25","objectID":"/leetcode/0664/:1:0","tags":null,"title":"0664：奇怪的打印机（★★）","uri":"/leetcode/0664/"},{"categories":null,"content":"分析 显然连续相同的字符最后是一起打印的，考虑将连续相同的字符合并得到 s’，节省时间。 考虑字符 s[-1]，它要么单独打印，要么和前面相同的字符一起打印 假如 s[-1] 单独打印，显然转为递归子问题 假如 s[-1] 和 s[i] 一起打印 先打印了 s[:i+1] 部分，顺便将 s[-1] 一起打印了 然后打印 s[i+1:-1] 部分 这两部分都是递归子问题 因此令 dfs(s) 代表打印 s 的最小次数，即可递归。 ","date":"2016-10-25","objectID":"/leetcode/0664/:2:0","tags":null,"title":"0664：奇怪的打印机（★★）","uri":"/leetcode/0664/"},{"categories":null,"content":"解答 def strangePrinter(self, s: str) -\u003e int: @lru_cache(None) def dfs(s): if not s: return 0 res = 1+dfs(s[:-1]) for i in range(len(s)-2): if s[i]==s[-1]: res = min(res, dfs(s[:i+1])+dfs(s[i+1:-1])) return res s = ''.join(key for key, _ in groupby(s)) return dfs(s) 272 ms ","date":"2016-10-25","objectID":"/leetcode/0664/:3:0","tags":null,"title":"0664：奇怪的打印机（★★）","uri":"/leetcode/0664/"},{"categories":null,"content":" 力扣第 663 题 ","date":"2016-10-24","objectID":"/leetcode/0663/:0:0","tags":null,"title":"0663：均匀树划分（★）","uri":"/leetcode/0663/"},{"categories":null,"content":"题目 给定一棵有 n 个结点的二叉树，你的任务是检查是否可以通过去掉树上的一条边将树分成两棵，且这两棵树结点之和相等。 样例 1: 输入: 5 / \\ 10 10 / \\ 2 3 输出: True 解释: 5 / 10 和: 15 10 / \\ 2 3 和: 15 样例 2: 输入: 1 / \\ 2 10 / \\ 2 20 输出: False 解释: 无法通过移除一条树边将这棵树划分成结点之和相等的两棵子树。 注释 : 树上结点的权值范围 [-100000, 100000]。 1 \u003c= n \u003c= 10000 ","date":"2016-10-24","objectID":"/leetcode/0663/:1:0","tags":null,"title":"0663：均匀树划分（★）","uri":"/leetcode/0663/"},{"categories":null,"content":"分析 等价于找一个非根节点，其子树和是整个树之和的一半。 因此深搜返回子树和并记录即可。注意根节点不能算。 ","date":"2016-10-24","objectID":"/leetcode/0663/:2:0","tags":null,"title":"0663：均匀树划分（★）","uri":"/leetcode/0663/"},{"categories":null,"content":"解答 def checkEqualTree(self, root) -\u003e bool: def dfs(node): if not node: return 0 s = node.val+dfs(node.left)+dfs(node.right) if node is not root: vis.add(s) return s vis = set() total = dfs(root) return total/2 in vis 时间 O(N)，68 ms ","date":"2016-10-24","objectID":"/leetcode/0663/:3:0","tags":null,"title":"0663：均匀树划分（★）","uri":"/leetcode/0663/"},{"categories":null,"content":" 力扣第 662 题 ","date":"2016-10-23","objectID":"/leetcode/0662/:0:0","tags":null,"title":"0662：二叉树最大宽度（★）","uri":"/leetcode/0662/"},{"categories":null,"content":"题目 给你一棵二叉树的根节点 root ，返回树的 最大宽度 。 树的 最大宽度 是所有层中最大的 宽度 。 每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。 题目数据保证答案将会在 32 位 带符号整数范围内。 示例 1： 输入：root = [1,3,2,5,3,null,9] 输出：4 解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。 示例 2： 输入：root = [1,3,2,5,null,null,9,6,nu","date":"2016-10-23","objectID":"/leetcode/0662/:1:0","tags":null,"title":"0662：二叉树最大宽度（★）","uri":"/leetcode/0662/"},{"categories":null,"content":"分析 满二叉树的一个性质是对于序号 i 的节点，其左右子树节点的序号分别为 2i，2i+1。 因此层序遍历并保存节点在满二叉树中的序号，每层宽度即可由该层的第一个节点和最后一个节点的序号计算得到。 ","date":"2016-10-23","objectID":"/leetcode/0662/:2:0","tags":null,"title":"0662：二叉树最大宽度（★）","uri":"/leetcode/0662/"},{"categories":null,"content":"解答 def widthOfBinaryTree(self, root: TreeNode) -\u003e int: res, level = 0, [(root, 0)] while level: res = max(res, level[-1][1]-level[0][1]+1) level = [(child, y) for node, x in level for child, y in [(node.left, 2*x), (node.right, 2*x+1)] if child] return res 52 ms ","date":"2016-10-23","objectID":"/leetcode/0662/:3:0","tags":null,"title":"0662：二叉树最大宽度（★）","uri":"/leetcode/0662/"},{"categories":null,"content":" 力扣第 658 题 ","date":"2016-10-19","objectID":"/leetcode/0658/:0:0","tags":null,"title":"0658：找到 K 个最接近的元素（★）","uri":"/leetcode/0658/"},{"categories":null,"content":"题目 给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。 整数 a 比整数 b 更接近 x 需要满足： |a - x| \u003c |b - x| 或者 |a - x| == |b - x| 且 a \u003c b 示例 1： 输入：arr = [1,2,3,4,5], k = 4, x = 3 输出：[1,2,3,4] 示例 2： 输入：arr = [1,2,3,4,5], k = 4, x = -1 输出：[1,2,3,4] 提示： 1 \u003c= k \u003c= arr.length 1 \u003c= arr.length \u003c= ","date":"2016-10-19","objectID":"/leetcode/0658/:1:0","tags":null,"title":"0658：找到 K 个最接近的元素（★）","uri":"/leetcode/0658/"},{"categories":null,"content":"分析 ","date":"2016-10-19","objectID":"/leetcode/0658/:2:0","tags":null,"title":"0658：找到 K 个最接近的元素（★）","uri":"/leetcode/0658/"},{"categories":null,"content":"#1 最简单的就是根据 key = abs(a-x) 排序，前 k 项即是所求。必须返回升序结果，所以最后再排下序。 def findClosestElements(self, arr: List[int], k: int, x: int) -\u003e List[int]: res = sorted(arr, key=lambda a: abs(a-x)) return sorted(res[:k]) 时间复杂度 O(N*log N)，60 ms ","date":"2016-10-19","objectID":"/leetcode/0658/:2:1","tags":null,"title":"0658：找到 K 个最接近的元素（★）","uri":"/leetcode/0658/"},{"categories":null,"content":"#2 显然要找的 k 个数是连续的，因此可以用双指针来找头尾位置。 初始令 i、j 指针分别指向 arr 头尾。如果 len(arr) == k，返回 arr 即可。否则有： 若 abs(arr[i]-x) \u003c= abs(arr[j]-x)，那么 j 必然不在结果中，j -= 1 若 abs(arr[i]-x) \u003e abs(arr[j]-x)，那么 i 必然不在结果中，i += 1 循环操作直到 j-i+1 == k 为止。 def findClosestElements(self, arr: List[int], k: int, x: int) -\u003e List[int]: n = len(a","date":"2016-10-19","objectID":"/leetcode/0658/:2:2","tags":null,"title":"0658：找到 K 个最接近的元素（★）","uri":"/leetcode/0658/"},{"categories":null,"content":"#3 当 n » k 时，显然很多遍历是不必要的。设 x 有序插入 arr 的位置是 pos，那么结果必然在 [pos-k, pos+k] 范围内。 所以初始令 i、j 分别为 max(0, pos-k)，min(n-1, pos+k)，节省时间。 ","date":"2016-10-19","objectID":"/leetcode/0658/:2:3","tags":null,"title":"0658：找到 K 个最接近的元素（★）","uri":"/leetcode/0658/"},{"categories":null,"content":"解答 def findClosestElements(self, arr: List[int], k: int, x: int) -\u003e List[int]: n, pos = len(arr), bisect_left(arr, x) i, j = max(0, pos-k), min(n-1, pos+k) while j-i+1 != k: if abs(arr[i]-x) \u003c= abs(arr[j]-x): j -= 1 else: i += 1 return arr[i:j+1] 时间复杂度 O(log N + k)，48 ms ","date":"2016-10-19","objectID":"/leetcode/0658/:3:0","tags":null,"title":"0658：找到 K 个最接近的元素（★）","uri":"/leetcode/0658/"},{"categories":null,"content":" 力扣第 655 题 ","date":"2016-10-16","objectID":"/leetcode/0655/:0:0","tags":null,"title":"0655：输出二叉树（★）","uri":"/leetcode/0655/"},{"categories":null,"content":"题目 给你一棵二叉树的根节点 root ，请你构造一个下标从 0 开始、大小为 m x n 的字符串矩阵 res ，用以表示树的 格式化布局 。构造此格式化布局矩阵需要遵循以下规则： 树的 高度 为 height ，矩阵的行数 m 应该等于 height + 1 。\r矩阵的列数 n 应该等于 2height+1 - 1 。\r根节点 需要放置在 顶行 的 正中间 ，对应位置为 res[0][(n-1)/2] 。\r对于放置在矩阵中的每个节点，设对应位置为 res[r][c] ，将其左子节点放置在 res[r+1][c-2height-r-1] ，右子节点放置在 res[r+1][c+2height","date":"2016-10-16","objectID":"/leetcode/0655/:1:0","tags":null,"title":"0655：输出二叉树（★）","uri":"/leetcode/0655/"},{"categories":null,"content":"分析 观察发现 n = (2«m)-1。于是先递归求得二叉树高度 m，便可以初始化结果数组 res。 然后遍历二叉树，节点在 res 中的行号 x 可以由父节点推得，然而列号 y 不能直接推得。 观察发现节点的子树在 res 中的左右边界 y1、y2 可以由父节点的左右边界推得，而 y = (y1+y2) // 2。 因此遍历时传递 x、y1、y2 即可。 ","date":"2016-10-16","objectID":"/leetcode/0655/:2:0","tags":null,"title":"0655：输出二叉树（★）","uri":"/leetcode/0655/"},{"categories":null,"content":"解答 def printTree(self, root: TreeNode) -\u003e List[List[str]]: def help(root): return 0 if not root else max(help(root.left), help(root.right)) + 1 m = help(root) n = (1 \u003c\u003c m) - 1 res = [[''] * n for _ in range(m)] stack = [(root, 0, 0, n - 1)] while stack: node, x, y1, y2 = stack.pop() if node: y = (y1","date":"2016-10-16","objectID":"/leetcode/0655/:3:0","tags":null,"title":"0655：输出二叉树（★）","uri":"/leetcode/0655/"},{"categories":null,"content":" 力扣第 654 题 ","date":"2016-10-15","objectID":"/leetcode/0654/:0:0","tags":null,"title":"0654：最大二叉树（★）","uri":"/leetcode/0654/"},{"categories":null,"content":"题目 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。\r递归地在最大值 左边 的 子数组前缀上 构建左子树。\r递归地在最大值 右边 的 子数组后缀上 构建右子树。\r返回 nums 构建的 最大二叉树 。 示例 1： 输入：nums = [3,2,1,6,0,5]\r输出：[6,3,5,null,2,0,null,null,1]\r解释：递归调用如下所示：\r- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\r- [3,2,1] 中的最大值是 3 ，左","date":"2016-10-15","objectID":"/leetcode/0654/:1:0","tags":null,"title":"0654：最大二叉树（★）","uri":"/leetcode/0654/"},{"categories":null,"content":"分析 递归构造即可。 ","date":"2016-10-15","objectID":"/leetcode/0654/:2:0","tags":null,"title":"0654：最大二叉树（★）","uri":"/leetcode/0654/"},{"categories":null,"content":"解答 def constructMaximumBinaryTree(self, nums: List[int]) -\u003e TreeNode: if not nums: return None i = nums.index(max(nums)) return TreeNode(nums[i], self.constructMaximumBinaryTree(nums[:i]), self.constructMaximumBinaryTree(nums[i+1:])) 148 ms ","date":"2016-10-15","objectID":"/leetcode/0654/:3:0","tags":null,"title":"0654：最大二叉树（★）","uri":"/leetcode/0654/"},{"categories":null,"content":" 力扣第 653 题 ","date":"2016-10-14","objectID":"/leetcode/0653/:0:0","tags":null,"title":"0653：两数之和 IV - 输入二叉搜索树","uri":"/leetcode/0653/"},{"categories":null,"content":"题目 给定一个二叉搜索树 root 和一个目标结果 k，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 true。 示例 1： 输入: root = [5,3,6,2,4,null,7], k = 9\r输出: true\r示例 2： 输入: root = [5,3,6,2,4,null,7], k = 28\r输出: false\r提示: 二叉树的节点个数的范围是 [1, 104].\r-104 \u003c= Node.val \u003c= 104\r题目数据保证，输入的 root 是一棵 有效 的二叉搜索树\r-105 \u003c= k \u003c= 105\r","date":"2016-10-14","objectID":"/leetcode/0653/:1:0","tags":null,"title":"0653：两数之和 IV - 输入二叉搜索树","uri":"/leetcode/0653/"},{"categories":null,"content":"分析 类似 0001，边遍历边用哈希存储元素值，每轮查询前面是否有对应的数即可。 ","date":"2016-10-14","objectID":"/leetcode/0653/:2:0","tags":null,"title":"0653：两数之和 IV - 输入二叉搜索树","uri":"/leetcode/0653/"},{"categories":null,"content":"解答 def findTarget(self, root: TreeNode, k: int) -\u003e bool: stack, vis = [root], set() while stack: node = stack.pop() if node: if k - node.val in vis: return True vis.add(node.val) stack.extend([node.right, node.left]) return False 64 ms ","date":"2016-10-14","objectID":"/leetcode/0653/:3:0","tags":null,"title":"0653：两数之和 IV - 输入二叉搜索树","uri":"/leetcode/0653/"},{"categories":null,"content":" 力扣第 652 题 ","date":"2016-10-13","objectID":"/leetcode/0652/:0:0","tags":null,"title":"0652：寻找重复的子树（★）","uri":"/leetcode/0652/"},{"categories":null,"content":"题目 给你一棵二叉树的根节点 root ，返回所有 重复的子树 。 对于同一类的重复子树，你只需要返回其中任意 一棵 的根结点即可。 如果两棵树具有 相同的结构 和 相同的结点值 ，则认为二者是 重复 的。 示例 1： 输入：root = [1,2,3,4,null,2,4,null,null,4]\r输出：[[2,4],[4]]\r示例 2： 输入：root = [2,1,1]\r输出：[[1]]\r示例 3： 输入：root = [2,2,2,3,null,3,null]\r输出：[[2,3],[3]]\r提示： 树中的结点数在 [1, 5000] 范围内。\r-200 \u003c= Node.val \u003c= 2","date":"2016-10-13","objectID":"/leetcode/0652/:1:0","tags":null,"title":"0652：寻找重复的子树（★）","uri":"/leetcode/0652/"},{"categories":null,"content":"分析 需要判断任意两个子树是否相同，可以将每个子树都序列化，方便比较。 更进一步，用哈希表保存序列化值出现的次数，一趟遍历即可。 ","date":"2016-10-13","objectID":"/leetcode/0652/:2:0","tags":null,"title":"0652：寻找重复的子树（★）","uri":"/leetcode/0652/"},{"categories":null,"content":"解答 def findDuplicateSubtrees(self, root: TreeNode) -\u003e List[TreeNode]: def serial(root): key = '#' if not root else '%d,%s,%s' % (root.val, serial(root.left), serial(root.right)) d[key] += 1 if key != '#' and d[key] == 2: res.append(root) return key res, d = [], defaultdict(int) serial(root) return r","date":"2016-10-13","objectID":"/leetcode/0652/:3:0","tags":null,"title":"0652：寻找重复的子树（★）","uri":"/leetcode/0652/"},{"categories":null,"content":"不善言辞却成为营业部员的马缔光也，与看似轻佻却成为辞典编辑部员的西冈正志，偶然在街上相遇。\n推进着中型国语辞典《大渡海》刊行计划的出版社·玄武书房的老牌编辑·荒木，因自己临近退休而努力寻找着后继者。此时他从西冈那里听闻了马缔的事情，于是选上了他……。\n“将联系人与人的——言语编织起来”\n无法传达的话语。不能传达的思念。\n这是，如此笨拙的人们所展开的故事。","date":"2016-10-13","objectID":"/anime/the_great_passage/","tags":null,"title":"编舟记","uri":"/anime/the_great_passage/"},{"categories":null,"content":"简介 不善言辞却成为营业部员的马缔光也，与看似轻佻却成为辞典编辑部员的西冈正志，偶然在街上相遇。 推进着中型国语辞典《大渡海》刊行计划的出版社·玄武书房的老牌编辑·荒木，因自己临近退休而努力寻找着后继者。此时他从西冈那里听闻了马缔的事情，于是选上了他……。 “将联系人与人的——言语编织起来” 无法传达的话语。不能传达的思念。 这是，如此笨拙的人们所展开的故事。 制作人员： 原作：三浦紫苑 导演：黑柳利充 脚本：富田赖子、木户雄一郎、根元岁三、佐藤卓哉 分镜：田头忍、长屋诚志郎 ","date":"2016-10-13","objectID":"/anime/the_great_passage/:1:0","tags":null,"title":"编舟记","uri":"/anime/the_great_passage/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 马缔光也 馬締 光也、まじめ みつや、Majime Mitsuya 男 櫻井孝宏 2 林香具矢 林 香具矢、はやし かぐや、Hayashi Kaguya 女 坂本真綾 3 西冈正志 西岡 正志、にしおか まさし、Nishioka Masashi 男 神谷浩史 4 荒木公平 あらきこうへい 男 金尾哲夫 5 松本朋佑 まつもとともすけ 男 麦人 6 佐佐木薰 ささき かおる 女 榊原良子 7 三好丽美 みよし れみ 女 斎藤千和 8 岸边绿 きしべ みどり、Kishibe Midori 女 日笠陽子 ","date":"2016-10-13","objectID":"/anime/the_great_passage/:2:0","tags":null,"title":"编舟记","uri":"/anime/the_great_passage/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 编舟记 2016-10-13 11 bilibili ","date":"2016-10-13","objectID":"/anime/the_great_passage/:3:0","tags":null,"title":"编舟记","uri":"/anime/the_great_passage/"},{"categories":null,"content":" 力扣第 650 题 ","date":"2016-10-11","objectID":"/leetcode/0650/:0:0","tags":null,"title":"0650：只有两个键的键盘（★）","uri":"/leetcode/0650/"},{"categories":null,"content":"题目 最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作： Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。\rPaste（粘贴）：粘贴 上一次 复制的字符。\r给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。 示例 1： 输入：3\r输出：3\r解释：\r最初, 只有一个字符 'A'。\r第 1 步, 使用 Copy All 操作。\r第 2 步, 使用 Paste 操作来获得 'AA'。\r第 3 步, 使用 Paste 操作来获得 'AAA'。\r示例 2： 输入：n","date":"2016-10-11","objectID":"/leetcode/0650/:1:0","tags":null,"title":"0650：只有两个键的键盘（★）","uri":"/leetcode/0650/"},{"categories":null,"content":"分析 操作必然是先复制再粘贴 k 次的形式。而这等价于将个数乘以 k+1。 因此可以将问题转化为，求 n 的一个因数分解形式，使得因数和最小。 根据代数知识可知，质因数分解形式的因数和最小，因此将 n 质因数分解即可。 ","date":"2016-10-11","objectID":"/leetcode/0650/:2:0","tags":null,"title":"0650：只有两个键的键盘（★）","uri":"/leetcode/0650/"},{"categories":null,"content":"解答 def minSteps(self, n: int) -\u003e int: res = 0 for i in range(2, int(sqrt(n))+1): if n%i == 0: while n%i==0: n //= i res += i return res + (n if n\u003e1 else 0) 40 ms ","date":"2016-10-11","objectID":"/leetcode/0650/:3:0","tags":null,"title":"0650：只有两个键的键盘（★）","uri":"/leetcode/0650/"},{"categories":null,"content":" 力扣第 648 题 ","date":"2016-10-09","objectID":"/leetcode/0648/:0:0","tags":null,"title":"0648：单词替换（★）","uri":"/leetcode/0648/"},{"categories":null,"content":"题目 在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。 现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。 你需要输出替换之后的句子。 示例 1： 输入：dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the ","date":"2016-10-09","objectID":"/leetcode/0648/:1:0","tags":null,"title":"0648：单词替换（★）","uri":"/leetcode/0648/"},{"categories":null,"content":"分析 容易想到用前缀树，先将词根插入，并在末尾用 ‘#’ 标记。 再对句子的每个单词搜索最短词根，遍历前缀树找到第一个 ‘#’ 标记即可。 ","date":"2016-10-09","objectID":"/leetcode/0648/:2:0","tags":null,"title":"0648：单词替换（★）","uri":"/leetcode/0648/"},{"categories":null,"content":"解答 def replaceWords(self, dictionary: List[str], sentence: str) -\u003e str: def find(word): p = trie for i, char in enumerate(word): if char not in p: return word p = p[char] if '#' in p: return word[:i+1] return word T = lambda: defaultdict(T) trie = T() for prefix in dictionary: reduce(dict.__getitem_","date":"2016-10-09","objectID":"/leetcode/0648/:3:0","tags":null,"title":"0648：单词替换（★）","uri":"/leetcode/0648/"},{"categories":null,"content":" 力扣第 647 题 ","date":"2016-10-08","objectID":"/leetcode/0647/:0:0","tags":null,"title":"0647：回文子串（★）","uri":"/leetcode/0647/"},{"categories":null,"content":"题目 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 输入：s = \"abc\"\r输出：3\r解释：三个回文子串: \"a\", \"b\", \"c\"\r示例 2： 输入：s = \"aaa\"\r输出：6\r解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\r提示： 1 \u003c= s.length \u003c= 1000\rs 由小写英文字母组成\r","date":"2016-10-08","objectID":"/leetcode/0647/:1:0","tags":null,"title":"0647：回文子串（★）","uri":"/leetcode/0647/"},{"categories":null,"content":"分析 ","date":"2016-10-08","objectID":"/leetcode/0647/:2:0","tags":null,"title":"0647：回文子串（★）","uri":"/leetcode/0647/"},{"categories":null,"content":"#1 类似 0005，可以发现在用 区间 dp 或中心扩展法的过程中，即可得到所有的回文子串。 这里用中心扩展法。 def countSubstrings(self, s: str) -\u003e int: def expand(s, left, right): while left \u003e 0 and right \u003c len(s)-1 and s[left-1] == s[right+1]: left -= 1 right += 1 self.res += 1 self.res = len(s) for i in range(len(s)): expand(s, i, i) expand(s, i+1,","date":"2016-10-08","objectID":"/leetcode/0647/:2:1","tags":null,"title":"0647：回文子串（★）","uri":"/leetcode/0647/"},{"categories":null,"content":"#2 还可以尝试经典的 Manacher 算法。 ","date":"2016-10-08","objectID":"/leetcode/0647/:2:2","tags":null,"title":"0647：回文子串（★）","uri":"/leetcode/0647/"},{"categories":null,"content":"解答 def countSubstrings(self, s: str) -\u003e int: def expand(l, r): while l and r\u003clen(ss)-1 and ss[l-1]==ss[r+1]: l -= 1 r += 1 return (r-l)//2 res = 0 pair, ss = (0, 0), '#' + '#'.join(s) + '#' A, center, right = [], 0, 0 for i in range(len(ss)): min_arm = min(A[2*center-i], right-i) if right \u003e i else 0","date":"2016-10-08","objectID":"/leetcode/0647/:3:0","tags":null,"title":"0647：回文子串（★）","uri":"/leetcode/0647/"},{"categories":null,"content":"幽灵？那种东西不可能存在吧！\n我闻悠太是高中2年生。\n他运营着以一夜致富为目标的超自然汇总系营销博客“轻轻松松破假象”，为了将世上存在的多数超常现象以科学的解释来“干净利落地砍掉！”，而日夜挑战着超自然现象。\n然而，以他的博客为契机，彻底、狂热、古怪的同志们全都集结到一起了。\n自我矛盾型自称救世主、神愈灵能媒介者、全否定型超理论派大学生、萌系占卜大老师、死后世界引导人、未来预知型同人漫画家大姐姐、黑魔术代行屋、现充系杂志记者、残念系Cosplay阿宅刑警，本来不应相遇的他们的命运不可思议地交错起来。\n之后，他们的周围开始产生一些小小的“违和感”。\n它们逐渐化作巨大的波澜，并发展成为超乎想象的大事件——","date":"2016-10-08","objectID":"/anime/occultic_nine/","tags":null,"title":"超自然9人组","uri":"/anime/occultic_nine/"},{"categories":null,"content":"简介 幽灵？那种东西不可能存在吧！ 我闻悠太是高中2年生。 他运营着以一夜致富为目标的超自然汇总系营销博客“轻轻松松破假象”，为了将世上存在的多数超常现象以科学的解释来“干净利落地砍掉！”，而日夜挑战着超自然现象。 然而，以他的博客为契机，彻底、狂热、古怪的同志们全都集结到一起了。 自我矛盾型自称救世主、神愈灵能媒介者、全否定型超理论派大学生、萌系占卜大老师、死后世界引导人、未来预知型同人漫画家大姐姐、黑魔术代行屋、现充系杂志记者、残念系Cosplay阿宅刑警，本来不应相遇的他们的命运不可思议地交错起来。 之后，他们的周围开始产生一些小小的“违和感”。 它们逐渐化作巨大的波澜，并发展成为超乎想","date":"2016-10-08","objectID":"/anime/occultic_nine/:1:0","tags":null,"title":"超自然9人组","uri":"/anime/occultic_nine/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 我闻悠太 我聞 悠太、がもん ゆうた、Gamon Yuuta、ガモタン 男 梶裕貴 2 成泽稜歌 成沢 稜歌、なるさわ りょうか、Narusawa Ryouka、りょーたす 女 佐倉綾音 3 桥上萨来伊 桥上浚、橋上 サライ、はしがみ さらい、Hashigami Sarai 男 石川界人 4 相川实优羽 みゅう、幽语、相川 実優羽、あいかわ みゆう、Aikawa Miyuu、幽语妹 女 吉田仁美 5 澄风桐子 澄風 桐子、すみかぜ とうこ、Sumikaze Touko 女 伊藤静 6 红之亚里亚 みなせ りあ、Minase Ria、水无濑莉爱、水無瀬莉愛、く","date":"2016-10-08","objectID":"/anime/occultic_nine/:2:0","tags":null,"title":"超自然9人组","uri":"/anime/occultic_nine/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 超自然9人组 2016-10-08 12 bilibili ","date":"2016-10-08","objectID":"/anime/occultic_nine/:3:0","tags":null,"title":"超自然9人组","uri":"/anime/occultic_nine/"},{"categories":null,"content":" 力扣第 646 题 ","date":"2016-10-07","objectID":"/leetcode/0646/:0:0","tags":null,"title":"0646：最长数对链（★）","uri":"/leetcode/0646/"},{"categories":null,"content":"题目 给你一个由 n 个数对组成的数对数组 pairs ，其中 pairs[i] = [lefti, righti] 且 lefti \u003c righti 。 现在，我们定义一种 跟随 关系，当且仅当 b \u003c c 时，数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面。我们用这种形式来构造 数对链 。 找出并返回能够形成的 最长数对链的长度 。 你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例 1： 输入：pairs = [[1,2], [2,3], [3,4]]\r输出：2\r解释：最长的数对链是 [1,2] -\u003e [3,4] 。\r示例 2： 输入：pai","date":"2016-10-07","objectID":"/leetcode/0646/:1:0","tags":null,"title":"0646：最长数对链（★）","uri":"/leetcode/0646/"},{"categories":null,"content":"分析 类似 0435，贪心地选第二个数最小的数对即可。 ","date":"2016-10-07","objectID":"/leetcode/0646/:2:0","tags":null,"title":"0646：最长数对链（★）","uri":"/leetcode/0646/"},{"categories":null,"content":"解答 def findLongestChain(self, pairs: List[List[int]]) -\u003e int: pairs.sort(key=lambda x: x[1]) res, end = 0, float('-inf') for s, e in pairs: if s\u003eend: res += 1 end = e return res 56 ms ","date":"2016-10-07","objectID":"/leetcode/0646/:3:0","tags":null,"title":"0646：最长数对链（★）","uri":"/leetcode/0646/"},{"categories":null,"content":" 力扣第 645 题 ","date":"2016-10-06","objectID":"/leetcode/0645/:0:0","tags":null,"title":"0645：错误的集合","uri":"/leetcode/0645/"},{"categories":null,"content":"题目 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。 给定一个数组 nums 代表了集合 S 发生错误后的结果。 请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。 示例 1： 输入：nums = [1,2,2,4]\r输出：[2,3]\r示例 2： 输入：nums = [1,1]\r输出：[1,2]\r提示： 2 \u003c= nums.length \u003c= 104\r1 \u003c= nums[i] \u003c= 104\r","date":"2016-10-06","objectID":"/leetcode/0645/:1:0","tags":null,"title":"0645：错误的集合","uri":"/leetcode/0645/"},{"categories":null,"content":"分析 去重后显然元素之和少的就是重复的数。而去重后的元素之和比 1 到 n 之和少的就是丢失的数字。 ","date":"2016-10-06","objectID":"/leetcode/0645/:2:0","tags":null,"title":"0645：错误的集合","uri":"/leetcode/0645/"},{"categories":null,"content":"解答 def findErrorNums(self, nums: List[int]) -\u003e List[int]: s, n = sum(set(nums)), len(nums) return [sum(nums) - s, n*(n+1)//2 - s] 48 ms ","date":"2016-10-06","objectID":"/leetcode/0645/:3:0","tags":null,"title":"0645：错误的集合","uri":"/leetcode/0645/"},{"categories":null,"content":"对你而言，世界是怎样的呢——。\n获得了打开大门的钥匙的两位女主人公，帕皮卡和可可娜。\n少女与少女相遇，开始了在不同的时间、相异的空间“Pure Illusion”的冒险。\n在寻找着据说能实现愿望的神秘结晶体“耳之碎片”而游历Pure Illusion的两人面前，\n出现了各种各样的困难。\n当两人陷入危机之时，“耳之碎片”发出光芒，而她们也因此变身了。","date":"2016-10-06","objectID":"/anime/flip_flappers/","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"简介 对你而言，世界是怎样的呢——。 获得了打开大门的钥匙的两位女主人公，帕皮卡和可可娜。 少女与少女相遇，开始了在不同的时间、相异的空间“Pure Illusion”的冒险。 在寻找着据说能实现愿望的神秘结晶体“耳之碎片”而游历Pure Illusion的两人面前， 出现了各种各样的困难。 当两人陷入危机之时，“耳之碎片”发出光芒，而她们也因此变身了。 制作人员： 导演：押山清高 脚本：绫奈由仁子、久弥直树、关根步美 分镜：榎户骏、出合小都美、新留俊哉 ","date":"2016-10-06","objectID":"/anime/flip_flappers/:1:0","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 帕皮卡 Papika 女 M・A・O 2 可可娜 Kokona 女 髙橋ミナミ 3 雅雅卡 Yayaka 女 大橋彩香 4 索尔特 Soruto 男 津田健次郎 5 托托 Toto 男 井上沙香 6 优优 Yuyu 女 歳納愛梨 7 希达卡 日高、Shidaka 男 福島潤 8 小百合 Sayuri 女 日笠陽子 ","date":"2016-10-06","objectID":"/anime/flip_flappers/:2:0","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Flip Flappers 2016-10-06 13 樱花 ","date":"2016-10-06","objectID":"/anime/flip_flappers/:3:0","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"MAD ","date":"2016-10-06","objectID":"/anime/flip_flappers/:4:0","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"“伯纳德小姐”町田佐和子与爱读书的朋友们在图书馆展开的文学日常。\n对古今东西各种书籍的爱，以及充满“确实是读书家呢”这类细节的“名著礼赞”搞笑剧！","date":"2016-10-06","objectID":"/anime/miss_bernard_said/","tags":null,"title":"伯纳德小姐说。","uri":"/anime/miss_bernard_said/"},{"categories":null,"content":"简介 “伯纳德小姐”町田佐和子与爱读书的朋友们在图书馆展开的文学日常。 对古今东西各种书籍的爱，以及充满“确实是读书家呢”这类细节的“名著礼赞”搞笑剧！ 制作人员： 原作：施川汤雨期 导演：平泽久义 脚本：内堀优一 分镜：橘纱央莉、空久保美贵 人物原案：なつのはむと 人物设定：ゴンタ ","date":"2016-10-06","objectID":"/anime/miss_bernard_said/:1:0","tags":null,"title":"伯纳德小姐说。","uri":"/anime/miss_bernard_said/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 町田佐和子 女 喜多村英梨 2 神林诗织 女 小松未可子 3 远藤 男 市来光弘 4 长谷川澄香 女 洲崎綾 ","date":"2016-10-06","objectID":"/anime/miss_bernard_said/:2:0","tags":null,"title":"伯纳德小姐说。","uri":"/anime/miss_bernard_said/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 伯纳德小姐说。 2016-10-06 13 bilibili ","date":"2016-10-06","objectID":"/anime/miss_bernard_said/:3:0","tags":null,"title":"伯纳德小姐说。","uri":"/anime/miss_bernard_said/"},{"categories":null,"content":" 力扣第 643 题 ","date":"2016-10-04","objectID":"/leetcode/0643/:0:0","tags":null,"title":"0643：子数组最大平均数 I","uri":"/leetcode/0643/"},{"categories":null,"content":"题目 给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10-5 的答案都将被视为正确答案。 示例 1： 输入：nums = [1,12,-5,-6,50,3], k = 4\r输出：12.75\r解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\r示例 2： 输入：nums = [5], k = 1\r输出：5.00000\r提示： n == nums.length\r1 \u003c= k \u003c= n \u003c= 105\r-104 \u003c= nums[i] \u003c= 104\r","date":"2016-10-04","objectID":"/leetcode/0643/:1:0","tags":null,"title":"0643：子数组最大平均数 I","uri":"/leetcode/0643/"},{"categories":null,"content":"分析 遍历子数组取最大值即可，相邻的子数组之和可以递推得到。 ","date":"2016-10-04","objectID":"/leetcode/0643/:2:0","tags":null,"title":"0643：子数组最大平均数 I","uri":"/leetcode/0643/"},{"categories":null,"content":"解答 def findMaxAverage(self, nums: List[int], k: int) -\u003e float: res, s = float('-inf'), 0 for i, num in enumerate(nums): s += num if i \u003e= k: s -= nums[i-k] if i \u003e= k-1: res = max(res, s/k) return res 312 ms ","date":"2016-10-04","objectID":"/leetcode/0643/:3:0","tags":null,"title":"0643：子数组最大平均数 I","uri":"/leetcode/0643/"},{"categories":null,"content":"主人公·大叔是一位外表帅气却过着放荡生活的父亲，工作是马桶盖设计师。和妻子离婚后与学习运动万能的女儿小敏一起生活。某天在一次平常的厕所蹲坑中大叔竟然让马桶吸了进去！ 穿越到未知世界的大叔被赋予拯救地球的重任，稀里糊涂的成为了超级英雄！而成为英雄的代价却是将原本英俊帅气的大叔变成了臃肿丑陋的大胖子！！守护地球和小敏的战斗，就此开始…","date":"2016-10-04","objectID":"/anime/to_be_hero/","tags":null,"title":"凸变英雄","uri":"/anime/to_be_hero/"},{"categories":null,"content":"简介 主人公·大叔是一位外表帅气却过着放荡生活的父亲，工作是马桶盖设计师。和妻子离婚后与学习运动万能的女儿小敏一起生活。某天在一次平常的厕所蹲坑中大叔竟然让马桶吸了进去！ 穿越到未知世界的大叔被赋予拯救地球的重任，稀里糊涂的成为了超级英雄！而成为英雄的代价却是将原本英俊帅气的大叔变成了臃肿丑陋的大胖子！！守护地球和小敏的战斗，就此开始… 制作人员： 原作：李豪凌 导演：渡边慎一 演出：LAN 音乐：東タカゴー、宫崎京一 ","date":"2016-10-04","objectID":"/anime/to_be_hero/:1:0","tags":null,"title":"凸变英雄","uri":"/anime/to_be_hero/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伢叔 大叔、姜子伢 男 津田健次郎 2 姜辰敏 ミソ、ミンちゃん、小敏 女 山新 3 美少女 女 西田望見 4 王子 猛猛哒 男 杉田智和 5 老王 山田さん 青山穣 ","date":"2016-10-04","objectID":"/anime/to_be_hero/:2:0","tags":null,"title":"凸变英雄","uri":"/anime/to_be_hero/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 凸变英雄 2016-10-04 12 bilibili 2 凸变英雄 LEAF 2018-04-14 12 bilibili ","date":"2016-10-04","objectID":"/anime/to_be_hero/:3:0","tags":null,"title":"凸变英雄","uri":"/anime/to_be_hero/"},{"categories":null,"content":"1555年，时为战国时代。\n有位青年怀抱着远大的梦想，被人称作大傻瓜的他正是后来的织田信长。\n有一位仰慕着青年的少女，被信长的梦想所吸引的她笑着说道“我要成为信长大人的忍者！”\n目标只有一个，那就是天下布武！","date":"2016-10-04","objectID":"/anime/ninja_girl/","tags":null,"title":"信长的忍者","uri":"/anime/ninja_girl/"},{"categories":null,"content":"简介 1555年，时为战国时代。 有位青年怀抱着远大的梦想，被人称作大傻瓜的他正是后来的织田信长。 有一位仰慕着青年的少女，被信长的梦想所吸引的她笑着说道“我要成为信长大人的忍者！” 目标只有一个，那就是天下布武！ 制作人员： 原作：重野なおき 导演：大地丙太郎 演出：山口光、神原敏昭、备前克彦、赤城博昭、菅井嘉浩 ","date":"2016-10-04","objectID":"/anime/ninja_girl/:1:0","tags":null,"title":"信长的忍者","uri":"/anime/ninja_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 千鸟 ちどり、Chidori 女 水瀬いのり 2 织田信长 おだ のぶなが、Oda Nobunaga 男 羽多野渉 3 助藏 すけぞう、Sukezō 男 村瀬歩 4 归蝶 きちょう、Kichō 女 たかはし智秋 5 木下秀吉 きのした ひでよし、Kinoshita Hideyoshi 男 山口勝平 6 宁宁 ねね、Nene 女 釘宮理恵 7 阿市 おいち、Oichi 女 三森すずこ 8 柴田胜家 しばた かついえ、Shibata Katsuie 男 大川透 ","date":"2016-10-04","objectID":"/anime/ninja_girl/:2:0","tags":null,"title":"信长的忍者","uri":"/anime/ninja_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 信长的忍者 2016-10-04 26 bilibili 2 信长的忍者 伊势·金崎篇 2017-04-07 26 bilibili 3 信长的忍者 姊川·石山篇 2018-04-06 26 bilibili ","date":"2016-10-04","objectID":"/anime/ninja_girl/:3:0","tags":null,"title":"信长的忍者","uri":"/anime/ninja_girl/"},{"categories":null,"content":" 力扣第 641 题 ","date":"2016-10-02","objectID":"/leetcode/0641/:0:0","tags":null,"title":"0641：设计循环双端队列（★）","uri":"/leetcode/0641/"},{"categories":null,"content":"题目 设计实现双端队列。 实现 MyCircularDeque 类: MyCircularDeque(int k) ：构造函数,双端队列最大为 k 。\rboolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false 。\rboolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。\rboolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。\rboolean deleteLast() ：从双端队列","date":"2016-10-02","objectID":"/leetcode/0641/:1:0","tags":null,"title":"0641：设计循环双端队列（★）","uri":"/leetcode/0641/"},{"categories":null,"content":"分析 类似 0622 ，增加 insertFront() 和 deleteLast() 即可。 ","date":"2016-10-02","objectID":"/leetcode/0641/:2:0","tags":null,"title":"0641：设计循环双端队列（★）","uri":"/leetcode/0641/"},{"categories":null,"content":"解答 class MyCircularDeque: def __init__(self, k: int): self.k = k self.A = [0] * k self.head = 0 self.cnt = 0 def insertFront(self, value: int) -\u003e bool: if self.isFull(): return False self.head = (self.head-1) % self.k self.A[self.head] = value self.cnt += 1 return True def insertLast(self, value: in","date":"2016-10-02","objectID":"/leetcode/0641/:3:0","tags":null,"title":"0641：设计循环双端队列（★）","uri":"/leetcode/0641/"},{"categories":null,"content":" 力扣第 639 题 ","date":"2016-09-30","objectID":"/leetcode/0639/:0:0","tags":null,"title":"0639：解码方法 II（★★）","uri":"/leetcode/0639/"},{"categories":null,"content":"题目 一条包含字母 A-Z 的消息通过以下的方式进行了 编码 ： 'A' -\u003e \"1\"\r'B' -\u003e \"2\"\r...\r'Z' -\u003e \"26\"\r要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，\"11106\" 可以映射为： \"AAJF\" 对应分组 (1 1 10 6)\r\"KJF\" 对应分组 (11 10 6)\r注意，像 (1 11 06) 这样的分组是无效的，因为 \"06\" 不可以映射为 'F' ，因为 \"6\" 与 \"06\" 不同。 除了 上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符，可以表示从 '1' 到 '9' 的","date":"2016-09-30","objectID":"/leetcode/0639/:1:0","tags":null,"title":"0639：解码方法 II（★★）","uri":"/leetcode/0639/"},{"categories":null,"content":"分析 和 0091 的区别在于存在 ‘*’ 字符，递推式的系数会不同。 注意到包含 ‘*’ 的单/双字符，所对应的系数是固定的，比如 ’ **’ 必然对应系数 15， 因此考虑用哈希表保存对应关系，再递推即可。 ","date":"2016-09-30","objectID":"/leetcode/0639/:2:0","tags":null,"title":"0639：解码方法 II（★★）","uri":"/leetcode/0639/"},{"categories":null,"content":"解答 def numDecodings(self, s: str) -\u003e int: d1 = {'*': 9, '0': 0} d2 = {'**': 15, '1*':9, '2*':6} for i in range(10): d2['*'+str(i)] = 2 if i\u003c=6 else 1 for i in range(10, 27): d2[str(i)] = 1 a, b, mod = 0, 1, 10**9+7 for i in range(len(s)): a, b = b, (b*d1.get(s[i], 1) + a*d2.get(s[i-1:i+1], 0)) % mod","date":"2016-09-30","objectID":"/leetcode/0639/:3:0","tags":null,"title":"0639：解码方法 II（★★）","uri":"/leetcode/0639/"},{"categories":null,"content":" 力扣第 638 题 ","date":"2016-09-29","objectID":"/leetcode/0638/:0:0","tags":null,"title":"0638：大礼包（★）","uri":"/leetcode/0638/"},{"categories":null,"content":"题目 在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单，其中 needs[i] 是需要购买第 i 件物品的数量。 还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[i][j] 表示第 i 个大礼包中内含第 j 件物品的数量，且 special[i][n] （也就是数组中的最后一个整数）为第 i 个大礼包的价格。","date":"2016-09-29","objectID":"/leetcode/0638/:1:0","tags":null,"title":"0638：大礼包（★）","uri":"/leetcode/0638/"},{"categories":null,"content":"分析 按最后一个礼包是否是 special[-1]，可以转为递归子问题。 令 dfs(i, needs) 代表用 special[:i+1] 满足 needs 的最小价格，即可递归。 这是典型的完全背包问题 ","date":"2016-09-29","objectID":"/leetcode/0638/:2:0","tags":null,"title":"0638：大礼包（★）","uri":"/leetcode/0638/"},{"categories":null,"content":"解答 def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -\u003e int: @lru_cache(None) def dfs(i, needs): if i==-1: return sum(a*b for a,b in zip(price, needs)) res = dfs(i-1, needs) A = tuple(b-a for a,b in zip(special[i], needs)) if all(a\u003e=0 for a in A): res = min(res, ","date":"2016-09-29","objectID":"/leetcode/0638/:3:0","tags":null,"title":"0638：大礼包（★）","uri":"/leetcode/0638/"},{"categories":null,"content":" 力扣第 637 题 ","date":"2016-09-28","objectID":"/leetcode/0637/:0:0","tags":null,"title":"0637：二叉树的层平均值","uri":"/leetcode/0637/"},{"categories":null,"content":"题目 给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。 示例 1： 输入：root = [3,9,20,null,null,15,7]\r输出：[3.00000,14.50000,11.00000]\r解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\r因此返回 [3, 14.5, 11] 。\r示例 2: 输入：root = [3,9,20,15,7]\r输出：[3.00000,14.50000,11.00000]\r提示： 树中节点数量在 [1, 104] 范围内\r-231 \u003c=","date":"2016-09-28","objectID":"/leetcode/0637/:1:0","tags":null,"title":"0637：二叉树的层平均值","uri":"/leetcode/0637/"},{"categories":null,"content":"分析 将 0102 的每层结果中取均值即可。 ","date":"2016-09-28","objectID":"/leetcode/0637/:2:0","tags":null,"title":"0637：二叉树的层平均值","uri":"/leetcode/0637/"},{"categories":null,"content":"解答 def averageOfLevels(self, root: TreeNode) -\u003e List[float]: if not root: return [] res, level = [], [root] while level: res.append(sum(node.val for node in level)/len(level)) level = [child for node in level for child in [node.left, node.right] if child] return res 48 ms ","date":"2016-09-28","objectID":"/leetcode/0637/:3:0","tags":null,"title":"0637：二叉树的层平均值","uri":"/leetcode/0637/"},{"categories":null,"content":" 力扣第 636 题 ","date":"2016-09-27","objectID":"/leetcode/0636/:0:0","tags":null,"title":"0636：函数的独占时间（★）","uri":"/leetcode/0636/"},{"categories":null,"content":"题目 有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于 0 和 n-1 之间的唯一标识符。 函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。 给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 \"{function_id}:{\"start\" | \"end\"}:{timestamp}\" 进行格式","date":"2016-09-27","objectID":"/leetcode/0636/:1:0","tags":null,"title":"0636：函数的独占时间（★）","uri":"/leetcode/0636/"},{"categories":null,"content":"分析 用栈模拟过程。函数开始时入栈，结束时出栈。 为了方便，将 end 对应的时间加 1，相邻两条记录之间的时间差便是栈顶函数运行的一段单位时间。 ","date":"2016-09-27","objectID":"/leetcode/0636/:2:0","tags":null,"title":"0636：函数的独占时间（★）","uri":"/leetcode/0636/"},{"categories":null,"content":"解答 def exclusiveTime(self, n: int, logs: List[str]) -\u003e List[int]: res, stack, prev = [0] * n, [], 0 for log in logs: i, op, ti = log.split(':') ti = int(ti) if op=='start' else int(ti)+1 if stack: res[stack[-1]] += ti - prev if op == 'start': stack.append(int(i)) else: stack.pop() prev = ti return r","date":"2016-09-27","objectID":"/leetcode/0636/:3:0","tags":null,"title":"0636：函数的独占时间（★）","uri":"/leetcode/0636/"},{"categories":null,"content":" 力扣第 629 题 ","date":"2016-09-20","objectID":"/leetcode/0629/:0:0","tags":null,"title":"0629：K个逆序对数组（★★）","uri":"/leetcode/0629/"},{"categories":null,"content":"题目 给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。 逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i \u003c j且 a[i] \u003e a[j]，则其为一个逆序对；否则不是。 由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。 示例 1: 输入: n = 3, k = 0\r输出: 1\r解释:\r只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。\r示例 2: 输入: n = 3, k = 1\r输出: 2\r解释:\r数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。\r说明: n 的范围是 ","date":"2016-09-20","objectID":"/leetcode/0629/:1:0","tags":null,"title":"0629：K个逆序对数组（★★）","uri":"/leetcode/0629/"},{"categories":null,"content":"分析 假设 n 放到位置 idx，那么包含 n 的逆序对有 n-idx-1，然后转为了子问题：1 到 n-1 的排列中恰好 k-(n-idx-1) 个逆序对的个数。 因此令 dp[i][j] 代表 1 到 i 的排列中恰好 j 个逆序对的个数，即可递推： dp[i][j] = sum(dp[i-1][j-cnt] for cnt in range(i) if j-cnt\u003e=0)\r但这个时间复杂度会超时。 观察发现递推式中其实是 dp[i-1] 的连续区间的和，于是想到用前缀和。 事先保存 dp[i-1] 的前缀和数组 pre，递推式变为： dp[i][j] = pre[j+1]-pre[max","date":"2016-09-20","objectID":"/leetcode/0629/:2:0","tags":null,"title":"0629：K个逆序对数组（★★）","uri":"/leetcode/0629/"},{"categories":null,"content":"解答 def kInversePairs(self, n: int, k: int) -\u003e int: dp, mod = [1]+[0]*k, 10**9+7 for i in range(1, n+1): pre = list(accumulate([0]+dp, lambda x,y:(x+y)%mod)) dp = [pre[j+1]-pre[max(0, j-i+1)] for j in range(k+1)] return dp[-1]%mod 548 ms ","date":"2016-09-20","objectID":"/leetcode/0629/:3:0","tags":null,"title":"0629：K个逆序对数组（★★）","uri":"/leetcode/0629/"},{"categories":null,"content":" 力扣第 628 题 ","date":"2016-09-19","objectID":"/leetcode/0628/:0:0","tags":null,"title":"0628：三个数的最大乘积","uri":"/leetcode/0628/"},{"categories":null,"content":"题目 给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1： 输入：nums = [1,2,3]\r输出：6\r示例 2： 输入：nums = [1,2,3,4]\r输出：24\r示例 3： 输入：nums = [-1,-2,-3]\r输出：-6\r提示： 3 \u003c= nums.length \u003c= 104\r-1000 \u003c= nums[i] \u003c= 1000\r","date":"2016-09-19","objectID":"/leetcode/0628/:1:0","tags":null,"title":"0628：三个数的最大乘积","uri":"/leetcode/0628/"},{"categories":null,"content":"分析 ","date":"2016-09-19","objectID":"/leetcode/0628/:2:0","tags":null,"title":"0628：三个数的最大乘积","uri":"/leetcode/0628/"},{"categories":null,"content":"#1 nums 可能有负数，需要分类讨论： nums 里最多 1 个负数，那么找最大的三个数即可\rnums 里至少 2 个负数，还要考虑最小的两个负数乘以最大数的情况\r为了方便，直接比较两种情况即可。 def maximumProduct(self, nums: List[int]) -\u003e int: nums.sort() return max(nums[0]*nums[1]*nums[-1], nums[-3]*nums[-2]*nums[-1]) 时间复杂度 O(N*log N)，64 ms ","date":"2016-09-19","objectID":"/leetcode/0628/:2:1","tags":null,"title":"0628：三个数的最大乘积","uri":"/leetcode/0628/"},{"categories":null,"content":"#2 也可以不排序，直接找最大和最小的几个数。 ","date":"2016-09-19","objectID":"/leetcode/0628/:2:2","tags":null,"title":"0628：三个数的最大乘积","uri":"/leetcode/0628/"},{"categories":null,"content":"解答 def maximumProduct(self, nums: List[int]) -\u003e int: a = b = c = float('-inf') d = e = float('inf') for num in nums: if num \u003e a: a, b, c = num, a, b elif num \u003e b: b, c = num, b elif num \u003e c: c = num if num \u003c d: d, e = num, d elif num \u003c e: e = num return max(d*e*a, a*b*c) 时间复杂度 O(N)，68 ms ","date":"2016-09-19","objectID":"/leetcode/0628/:3:0","tags":null,"title":"0628：三个数的最大乘积","uri":"/leetcode/0628/"},{"categories":null,"content":" 力扣第 623 题 ","date":"2016-09-14","objectID":"/leetcode/0623/:0:0","tags":null,"title":"0623：在二叉树中增加一行（★）","uri":"/leetcode/0623/"},{"categories":null,"content":"题目 给定一个二叉树的根 root 和两个整数 val 和 depth ，在给定的深度 depth 处添加一个值为 val 的节点行。 注意，根节点 root 位于深度 1 。 加法规则如下: 给定整数 depth，对于深度为 depth - 1 的每个非空树节点 cur ，创建两个值为 val 的树节点作为 cur 的左子树根和右子树根。 cur 原来的左子树应该是新的左子树根的左子树。 cur 原来的右子树应该是新的右子树根的右子树。 如果 depth == 1 意味着 depth - 1 根本没有深度，那么创建一个树节点，值 val 作为整个原始树的新根，而原始树就是新根的左子树。 示例","date":"2016-09-14","objectID":"/leetcode/0623/:1:0","tags":null,"title":"0623：在二叉树中增加一行（★）","uri":"/leetcode/0623/"},{"categories":null,"content":"分析 层序遍历到第 d-1 层，修改每个节点即可。注意 d = 1 时特别处理。 ","date":"2016-09-14","objectID":"/leetcode/0623/:2:0","tags":null,"title":"0623：在二叉树中增加一行（★）","uri":"/leetcode/0623/"},{"categories":null,"content":"解答 def addOneRow(self, root: TreeNode, val: int, depth: int) -\u003e TreeNode: if depth == 1: return TreeNode(val, root) level = [root] for _ in range(depth-2): level = [child for node in level for child in [node.left, node.right] if child] for node in level: node.left = TreeNode(val, left=node.left) nod","date":"2016-09-14","objectID":"/leetcode/0623/:3:0","tags":null,"title":"0623：在二叉树中增加一行（★）","uri":"/leetcode/0623/"},{"categories":null,"content":" 力扣第 622 题 ","date":"2016-09-13","objectID":"/leetcode/0622/:0:0","tags":null,"title":"0622：设计循环队列（★）","uri":"/leetcode/0622/"},{"categories":null,"content":"题目 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。\rFront: 从队首获取元素。如果队列为空，返回 -1 。\rRear: 获取队尾元素。如果队列为空，返回 -1 。\renQueue(valu","date":"2016-09-13","objectID":"/leetcode/0622/:1:0","tags":null,"title":"0622：设计循环队列（★）","uri":"/leetcode/0622/"},{"categories":null,"content":"分析 循环队列用数组实现即可。注意一个长为 k 的循环队列，当队列为空或已满时，队首队尾的指针相同，无法区分。 因此考虑用 k+1 长的数组实现，或者维护队首和队列长度，需要时计算出队尾位置。 ","date":"2016-09-13","objectID":"/leetcode/0622/:2:0","tags":null,"title":"0622：设计循环队列（★）","uri":"/leetcode/0622/"},{"categories":null,"content":"解答 class MyCircularQueue: def __init__(self, k: int): self.k = k self.A = [0] * k self.head = 0 self.cnt = 0 def enQueue(self, value: int) -\u003e bool: if self.isFull(): return False self.A[(self.head+self.cnt)%self.k] = value self.cnt += 1 return True def deQueue(self) -\u003e bool: if self.isEmpty(): retur","date":"2016-09-13","objectID":"/leetcode/0622/:3:0","tags":null,"title":"0622：设计循环队列（★）","uri":"/leetcode/0622/"},{"categories":null,"content":" 力扣第 617 题 ","date":"2016-09-08","objectID":"/leetcode/0617/:0:0","tags":null,"title":"0617：合并二叉树","uri":"/leetcode/0617/"},{"categories":null,"content":"题目 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 示例 1： 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\r输出：[3,4,5,5,4,null,7]\r示例 2： 输入：root1 = [1], root2 = ","date":"2016-09-08","objectID":"/leetcode/0617/:1:0","tags":null,"title":"0617：合并二叉树","uri":"/leetcode/0617/"},{"categories":null,"content":"分析 递归合并即可。当有一边为空时，可以直接返回非空的一边。 ","date":"2016-09-08","objectID":"/leetcode/0617/:2:0","tags":null,"title":"0617：合并二叉树","uri":"/leetcode/0617/"},{"categories":null,"content":"解答 def mergeTrees(self, root1: TreeNode, root2: TreeNode) -\u003e TreeNode: if not root1: return root2 if not root2: return root1 return TreeNode(root1.val + root2.val, self.mergeTrees(root1.left, root2.left), self.mergeTrees(root1.right, root2.right)) 80 ms ","date":"2016-09-08","objectID":"/leetcode/0617/:3:0","tags":null,"title":"0617：合并二叉树","uri":"/leetcode/0617/"},{"categories":null,"content":" 力扣第 609 题 ","date":"2016-08-31","objectID":"/leetcode/0609/:0:0","tags":null,"title":"0609：在系统中查找重复文件（★）","uri":"/leetcode/0609/"},{"categories":null,"content":"题目 给你一个目录信息列表 paths ，包括目录路径，以及该目录中的所有文件及其内容，请你按路径返回文件系统中的所有重复文件。答案可按 任意顺序 返回。 一组重复的文件至少包括 两个 具有完全相同内容的文件。 输入 列表中的单个目录信息字符串的格式如下： \"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"\r这意味着，在目录 root/d1/d2/.../dm 下，有 n 个文件 ( f1.txt, f2.txt ... fn.txt ) 的内容分别是 ( f1_content, f2","date":"2016-08-31","objectID":"/leetcode/0609/:1:0","tags":null,"title":"0609：在系统中查找重复文件（★）","uri":"/leetcode/0609/"},{"categories":null,"content":"分析 按内容将文件分类，返回至少有两个文件的类别即可。 ","date":"2016-08-31","objectID":"/leetcode/0609/:2:0","tags":null,"title":"0609：在系统中查找重复文件（★）","uri":"/leetcode/0609/"},{"categories":null,"content":"解答 def findDuplicate(self, paths: List[str]) -\u003e List[List[str]]: d = defaultdict(list) for path in paths: tmp = path.split() for val in tmp[1:]: file, key = val.split('(') d[key].append(tmp[0]+'/'+file) return [v for v in d.values() if len(v) \u003e 1] 72 ms ","date":"2016-08-31","objectID":"/leetcode/0609/:3:0","tags":null,"title":"0609：在系统中查找重复文件（★）","uri":"/leetcode/0609/"},{"categories":null,"content":" 力扣第 606 题 ","date":"2016-08-28","objectID":"/leetcode/0606/:0:0","tags":null,"title":"0606：根据二叉树创建字符串","uri":"/leetcode/0606/"},{"categories":null,"content":"题目 给你二叉树的根节点 root ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。 空节点使用一对空括号对 \"()\" 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。 示例 1： 输入：root = [1,2,3,4]\r输出：\"1(2(4))(3)\"\r解释：初步转化后得到 \"1(2(4)())(3()())\" ，但省略所有不必要的空括号对后，字符串应该是\"1(2(4))(3)\" 。\r示例 2： 输入：root = [1,2,3,null,4]\r输出：\"1(2()(4))(3)\"\r解释：和第一个示例类似，但是无法省略第一","date":"2016-08-28","objectID":"/leetcode/0606/:1:0","tags":null,"title":"0606：根据二叉树创建字符串","uri":"/leetcode/0606/"},{"categories":null,"content":"分析 递归即可。根据左右子树是否为空判断是否省略括号。 ","date":"2016-08-28","objectID":"/leetcode/0606/:2:0","tags":null,"title":"0606：根据二叉树创建字符串","uri":"/leetcode/0606/"},{"categories":null,"content":"解答 def tree2str(self, root: TreeNode) -\u003e str: if not root: return '' if not root.left and not root.right: return str(root.val) if not root.right: return '%d(%s)' % (root.val, self.tree2str(root.left)) return '%d(%s)(%s)' % (root.val, self.tree2str(root.left), self.tree2str(root.right)) 64 ms ","date":"2016-08-28","objectID":"/leetcode/0606/:3:0","tags":null,"title":"0606：根据二叉树创建字符串","uri":"/leetcode/0606/"},{"categories":null,"content":" 力扣第 604 题 ","date":"2016-08-26","objectID":"/leetcode/0604/:0:0","tags":null,"title":"0604：迭代压缩字符串","uri":"/leetcode/0604/"},{"categories":null,"content":"题目 设计并实现一个迭代压缩字符串的数据结构。给定的压缩字符串的形式是，每个字母后面紧跟一个正整数，表示该字母在原始未压缩字符串中出现的次数。 设计一个数据结构，它支持如下两种操作： next 和 hasNext。 next() - 如果原始字符串中仍有未压缩字符，则返回下一个字符，否则返回空格。 hasNext() - 如果原始字符串中存在未压缩的的字母，则返回true，否则返回false。 示例 1： 输入： [\"StringIterator\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"hasNext\", \"next\", \"hasN","date":"2016-08-26","objectID":"/leetcode/0604/:1:0","tags":null,"title":"0604：迭代压缩字符串","uri":"/leetcode/0604/"},{"categories":null,"content":"分析 正则提取出 \u003c字符，个数\u003e 对放在队列中，模拟取出即可。 ","date":"2016-08-26","objectID":"/leetcode/0604/:2:0","tags":null,"title":"0604：迭代压缩字符串","uri":"/leetcode/0604/"},{"categories":null,"content":"解答 class StringIterator: def __init__(self, compressedString: str): self.Q = deque((x, int(w)) for x,w in re.findall('(\\w)(\\d+)', compressedString)) def next(self) -\u003e str: if not self.Q: return ' ' x, w = self.Q.popleft() if w-1: self.Q.appendleft((x, w-1)) return x def hasNext(self) -\u003e bool: return","date":"2016-08-26","objectID":"/leetcode/0604/:3:0","tags":null,"title":"0604：迭代压缩字符串","uri":"/leetcode/0604/"},{"categories":null,"content":"　　在每千年回归一次的彗星造访过一个月之后的日本。\n　　某个深山的乡下小镇，女高中生三叶每天都过着忧郁的生活。\n　　而她烦恼的不光有担任镇长的父亲所举行的选举运动，还有家传神社的古老习俗。\n　　在这个小小的城镇，周围都只是些爱瞎操心的老人。为此三叶对于大都市充满了憧憬。\n　　“下辈子就让我成为东京的帅哥吧……！！！”\n　　然而某一天，自己做了一个变成男孩子的梦。\n　　这儿有着陌生的房间、陌生的朋友。而眼前出现的则是东京的街道。\n　　三叶虽然感到困惑，但是能够来到朝思暮想的都市生活，让她觉得神清气爽。\n　　“不可思议的梦……”\n　　另一方面在东京生活的男高中生·泷也做了个奇怪的梦。\n　　他在一个从未去过的深山小镇中，变成了女高中生……\n　　那么他们体验的梦境到底有什么秘密呢？\n　　原本不会相遇的两人由此相逢。\n　　少女和少年奇迹的故事，开始了。","date":"2016-08-26","objectID":"/anime/your_name/","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":"简介 在每千年回归一次的彗星造访过一个月之后的日本。 某个深山的乡下小镇，女高中生三叶每天都过着忧郁的生活。 而她烦恼的不光有担任镇长的父亲所举行的选举运动，还有家传神社的古老习俗。 在这个小小的城镇，周围都只是些爱瞎操心的老人。为此三叶对于大都市充满了憧憬。 “下辈子就让我成为东京的帅哥吧……！！！” 然而某一天，自己做了一个变成男孩子的梦。 这儿有着陌生的房间、陌生的朋友。而眼前出现的则是东京的街道。 三叶虽然感到困惑，但是能够来到朝思暮想的都市生活，让她觉得神清气爽。 “不可思议的梦……” 另一方面在东京生活的男高中生·泷也做了个奇怪的梦。 他在一个从未去过的深山小镇中，变成了女高中生…","date":"2016-08-26","objectID":"/anime/your_name/:1:0","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 立花泷 たちばな たき、Tachibana Taki 男 神木隆之介 2 宫水三叶 みやみず みつは、Miyamizu Mitsuha 女 上白石萌音 3 奥寺美纪 おくでら ミキ、Okudera Miki 女 長澤まさみ 4 宫水一叶 女 市原悦子 5 敕使河原克彦 てしがわら かつひこ、Teshigawara Katsuhiko 男 成田凌 6 名取早耶香 なとり さやか、Natori Sayaka 女 悠木碧 7 藤井司 ふじい つかさ、Fujii Tsukasa 男 島﨑信長 8 高木真太 たかぎ しんた、Takagi Shinta 男 石川界人 ","date":"2016-08-26","objectID":"/anime/your_name/:2:0","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 你的名字。 2016-08-26 1 bilibili ","date":"2016-08-26","objectID":"/anime/your_name/:3:0","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":"MAD ","date":"2016-08-26","objectID":"/anime/your_name/:4:0","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":" 力扣第 600 题 ","date":"2016-08-22","objectID":"/leetcode/0600/:0:0","tags":null,"title":"0600：不含连续1的非负整数（★★）","uri":"/leetcode/0600/"},{"categories":null,"content":"题目 给定一个正整数 n ，请你统计在 [0, n] 范围的非负整数中，有多少个整数的二进制表示中不存在 连续的 1 。 示例 1: 输入: n = 5\r输出: 5\r解释:\r下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：\r0 : 0\r1 : 1\r2 : 10\r3 : 11\r4 : 100\r5 : 101\r其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。\r示例 2: 输入: n = 1\r输出: 2\r示例 3: 输入: n = 2\r输出: 3\r提示: 1 \u003c= n \u003c= 109\r","date":"2016-08-22","objectID":"/leetcode/0600/:1:0","tags":null,"title":"0600：不含连续1的非负整数（★★）","uri":"/leetcode/0600/"},{"categories":null,"content":"分析 求范围内数字满足某种性质的个数，典型的数位 dp 问题， 令 dfs(pos, st, bound) 代表某个状态下的结果： 遍历到 n 的第 pos 位 前面一个数是 st bound 代表前面取的数是否贴着 n 的上界 即可递归。 注意本题是限制二进制，所以用 bin。 ","date":"2016-08-22","objectID":"/leetcode/0600/:2:0","tags":null,"title":"0600：不含连续1的非负整数（★★）","uri":"/leetcode/0600/"},{"categories":null,"content":"解答 def findIntegers(self, n: int) -\u003e int: @lru_cache(None) def dfs(pos, st, bound): if pos==len(s): return 1 res, cur = 0, int(s[pos]) up = cur if bound else 1 for x in range(up+1): if not x\u0026st: res += dfs(pos+1, x, bound and x==cur) return res s = bin(n)[2:] return dfs(0, 0, True) 64 ms ","date":"2016-08-22","objectID":"/leetcode/0600/:3:0","tags":null,"title":"0600：不含连续1的非负整数（★★）","uri":"/leetcode/0600/"},{"categories":null,"content":" 力扣第 599 题 ","date":"2016-08-21","objectID":"/leetcode/0599/:0:0","tags":null,"title":"0599：两个列表的最小索引总和","uri":"/leetcode/0599/"},{"categories":null,"content":"题目 假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。 示例 1: 输入: list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\r输出: [\"Shogun\"]","date":"2016-08-21","objectID":"/leetcode/0599/:1:0","tags":null,"title":"0599：两个列表的最小索引总和","uri":"/leetcode/0599/"},{"categories":null,"content":"分析 遍历两个列表，找到公共的元素，根据索引和修改结果即可。 注意可以先用哈希表保存一个列表的元素及索引，然后遍历另一个列表，根据哈希表即可快速查询元素。 ","date":"2016-08-21","objectID":"/leetcode/0599/:2:0","tags":null,"title":"0599：两个列表的最小索引总和","uri":"/leetcode/0599/"},{"categories":null,"content":"解答 def findRestaurant(self, list1: List[str], list2: List[str]) -\u003e List[str]: res, Min = [], 2000 A = {item: i for i, item in enumerate(list1)} for i, item in enumerate(list2): s = i + A.get(item, 2001) if s == Min: res.append(item) elif s \u003c Min: res, Min = [item], s return res 52 ms ","date":"2016-08-21","objectID":"/leetcode/0599/:3:0","tags":null,"title":"0599：两个列表的最小索引总和","uri":"/leetcode/0599/"},{"categories":null,"content":" 力扣第 594 题 ","date":"2016-08-16","objectID":"/leetcode/0594/:0:0","tags":null,"title":"0594：最长和谐子序列","uri":"/leetcode/0594/"},{"categories":null,"content":"题目 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。 现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。 数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。 示例 1： 输入：nums = [1,3,2,2,5,2,3,7]\r输出：5\r解释：最长的和谐子序列是 [3,2,2,2,3]\r示例 2： 输入：nums = [1,2,3,4]\r输出：2\r示例 3： 输入：nums = [1,1,1,1]\r输出：0\r提示： 1 \u003c= nums.length \u003c= 2 * 104\r-109 ","date":"2016-08-16","objectID":"/leetcode/0594/:1:0","tags":null,"title":"0594：最长和谐子序列","uri":"/leetcode/0594/"},{"categories":null,"content":"分析 先统计得到每个数的个数 ct。 然后遍历数组存在的数 x 作为最小值，如果 x+1 也存在数组中，那么对应的最长和谐子序列长度即为 ct[x] + ct[x+1]。 ","date":"2016-08-16","objectID":"/leetcode/0594/:2:0","tags":null,"title":"0594：最长和谐子序列","uri":"/leetcode/0594/"},{"categories":null,"content":"解答 def findLHS(self, nums: List[int]) -\u003e int: ct = Counter(nums) return max(ct[x]+ct[x+1] if ct[x+1] else 0 for x in ct) 88 ms ","date":"2016-08-16","objectID":"/leetcode/0594/:3:0","tags":null,"title":"0594：最长和谐子序列","uri":"/leetcode/0594/"},{"categories":null,"content":" 力扣第 591 题 ","date":"2016-08-13","objectID":"/leetcode/0591/:0:0","tags":null,"title":"0591：标签验证器（★★）","uri":"/leetcode/0591/"},{"categories":null,"content":"题目 给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则： 代码必须被合法的闭合标签包围。否则，代码是无效的。\r闭合标签（不一定合法）要严格符合格式：\u003cTAG_NAME\u003eTAG_CONTENT\u003c/TAG_NAME\u003e。其中，\u003cTAG_NAME\u003e是起始标签，\u003c/TAG_NAME\u003e是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是合法的。\r合法的 TAG_NAME 仅含有大写字母，长度在范围 [1,9] 之间。否则，该 TAG_NAME 是不","date":"2016-08-13","objectID":"/leetcode/0591/:1:0","tags":null,"title":"0591：标签验证器（★★）","uri":"/leetcode/0591/"},{"categories":null,"content":"分析 显然用正则比较方便。 首先，代码最外层必须是合法的闭合标签。然后里面的 TAG_CONTENT 去除 cdata 以后，出现的 ‘\u003c’ 必然对应了闭合标签。 循环去除最里层的合法闭合标签，不存在 ‘\u003c’ 就合法了。具体表达式： 合法的 TAG_NAME '[A-Z]{1,9}'\r最外层是合法的闭合标签 r'^\u003c([A-Z]{1,9})\u003e(.*?)\u003c/\\1\u003e$'\r合法的 cdata r'\u003c!\\[CDATA\\[.*?\\]\\]\u003e'\r最里层的合法闭合标签 r'\u003c([A-Z]{1,9})\u003e[^\u003c]*\u003c/\\1\u003e'\r","date":"2016-08-13","objectID":"/leetcode/0591/:2:0","tags":null,"title":"0591：标签验证器（★★）","uri":"/leetcode/0591/"},{"categories":null,"content":"解答 def isValid(self, code: str) -\u003e bool: tmp = re.match(r'\u003c([A-Z]{1,9})\u003e(.*?)\u003c/\\1\u003e$', code) if not tmp: return False code = re.sub(r'\u003c!\\[CDATA\\[.*?\\]\\]\u003e', '', tmp.group(2)) n = 1 while n: code, n = re.subn(r'\u003c([A-Z]{1,9})\u003e[^\u003c]*\u003c/\\1\u003e', '', code) return '\u003c' not in code 44 ms ","date":"2016-08-13","objectID":"/leetcode/0591/:3:0","tags":null,"title":"0591：标签验证器（★★）","uri":"/leetcode/0591/"},{"categories":null,"content":" 力扣第 590 题 ","date":"2016-08-12","objectID":"/leetcode/0590/:0:0","tags":null,"title":"0590：N 叉树的后序遍历","uri":"/leetcode/0590/"},{"categories":null,"content":"题目 给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 示例 1： 输入：root = [1,null,3,2,4,null,5,6]\r输出：[5,6,3,2,4,1]\r示例 2： 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\r输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]\r提示： 节点总数在范围 [","date":"2016-08-12","objectID":"/leetcode/0590/:1:0","tags":null,"title":"0590：N 叉树的后序遍历","uri":"/leetcode/0590/"},{"categories":null,"content":"分析 ","date":"2016-08-12","objectID":"/leetcode/0590/:2:0","tags":null,"title":"0590：N 叉树的后序遍历","uri":"/leetcode/0590/"},{"categories":null,"content":"#1 先写出递归算法，显然，将每个子树的后序遍历、根节点拼接起来即可。 def postorder(self, root: 'Node') -\u003e List[int]: if not root: return [] res = [] if root.children: for child in root.children: res.extend(self.postorder(child)) return res + [root.val] 52 ms ","date":"2016-08-12","objectID":"/leetcode/0590/:2:1","tags":null,"title":"0590：N 叉树的后序遍历","uri":"/leetcode/0590/"},{"categories":null,"content":"#2 迭代算法和 0144 类似，注意入栈顺序是 [节点值，子树的反序]。 ","date":"2016-08-12","objectID":"/leetcode/0590/:2:2","tags":null,"title":"0590：N 叉树的后序遍历","uri":"/leetcode/0590/"},{"categories":null,"content":"解答 def postorder(self, root: 'Node') -\u003e List[int]: res, stack = [], [root] while stack: node = stack.pop() if isinstance(node, int): res.append(node) elif node: stack.append(node.val) if node.children: stack.extend(node.children[::-1]) return res 56 ms ","date":"2016-08-12","objectID":"/leetcode/0590/:3:0","tags":null,"title":"0590：N 叉树的后序遍历","uri":"/leetcode/0590/"},{"categories":null,"content":" 力扣第 589 题 ","date":"2016-08-11","objectID":"/leetcode/0589/:0:0","tags":null,"title":"0589：N 叉树的前序遍历","uri":"/leetcode/0589/"},{"categories":null,"content":"题目 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 示例 1： 输入：root = [1,null,3,2,4,null,5,6]\r输出：[1,3,5,6,2,4]\r示例 2： 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\r输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]\r提示： 节点总数在范围 [","date":"2016-08-11","objectID":"/leetcode/0589/:1:0","tags":null,"title":"0589：N 叉树的前序遍历","uri":"/leetcode/0589/"},{"categories":null,"content":"分析 ","date":"2016-08-11","objectID":"/leetcode/0589/:2:0","tags":null,"title":"0589：N 叉树的前序遍历","uri":"/leetcode/0589/"},{"categories":null,"content":"#1 先写出递归算法，显然，将根节点、每个子树的前序遍历拼接起来即可。 def preorder(self, root: 'Node') -\u003e List[int]: if not root: return [] res = [root.val] if root.children: for child in root.children: res.extend(self.preorder(child)) return res 56 ms ","date":"2016-08-11","objectID":"/leetcode/0589/:2:1","tags":null,"title":"0589：N 叉树的前序遍历","uri":"/leetcode/0589/"},{"categories":null,"content":"#2 迭代算法和 0144 类似，注意入栈顺序是子树的反序。 ","date":"2016-08-11","objectID":"/leetcode/0589/:2:2","tags":null,"title":"0589：N 叉树的前序遍历","uri":"/leetcode/0589/"},{"categories":null,"content":"解答 def preorder(self, root: 'Node') -\u003e List[int]: res, stack = [], [root] while stack: node = stack.pop() if node: res.append(node.val) if node.children: stack.extend(node.children[::-1]) return res 52 ms ","date":"2016-08-11","objectID":"/leetcode/0589/:3:0","tags":null,"title":"0589：N 叉树的前序遍历","uri":"/leetcode/0589/"},{"categories":null,"content":" 力扣第 583 题 ","date":"2016-08-05","objectID":"/leetcode/0583/:0:0","tags":null,"title":"0583：两个字符串的删除操作（★）","uri":"/leetcode/0583/"},{"categories":null,"content":"题目 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。 每步 可以删除任意一个字符串中的一个字符。 示例 1： 输入: word1 = \"sea\", word2 = \"eat\"\r输出: 2\r解释: 第一步将 \"sea\" 变为 \"ea\" ，第二步将 \"eat \"变为 \"ea\"\r示例 2: 输入：word1 = \"leetcode\", word2 = \"etco\"\r输出：4\r提示： 1 \u003c= word1.length, word2.length \u003c= 500\rword1 和 word2 只包含小写英文字母\r","date":"2016-08-05","objectID":"/leetcode/0583/:1:0","tags":null,"title":"0583：两个字符串的删除操作（★）","uri":"/leetcode/0583/"},{"categories":null,"content":"分析 显然用动态规划即可，可以用滚动数组优化。 ","date":"2016-08-05","objectID":"/leetcode/0583/:2:0","tags":null,"title":"0583：两个字符串的删除操作（★）","uri":"/leetcode/0583/"},{"categories":null,"content":"解答 def minDistance(self, word1: str, word2: str) -\u003e int: m, n = len(word1), len(word2) dp = list(range(n+1)) for char in word1: prev = dp[:] dp[0] += 1 for j in range(1, n+1): if word2[j-1]==char: dp[j] = prev[j-1] else: dp[j] = 1+min(prev[j], dp[j-1]) return dp[-1] 244 ms ","date":"2016-08-05","objectID":"/leetcode/0583/:3:0","tags":null,"title":"0583：两个字符串的删除操作（★）","uri":"/leetcode/0583/"},{"categories":null,"content":" 力扣第 576 题 ","date":"2016-07-29","objectID":"/leetcode/0576/:0:0","tags":null,"title":"0576：出界的路径数（★）","uri":"/leetcode/0576/"},{"categories":null,"content":"题目 给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。 给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。 示例 1： 输入：m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\r输出：6\r示例 2： 输入：m = 1, n ","date":"2016-07-29","objectID":"/leetcode/0576/:1:0","tags":null,"title":"0576：出界的路径数（★）","uri":"/leetcode/0576/"},{"categories":null,"content":"分析 按第一步的移动方向即可转为递归子问题。 ","date":"2016-07-29","objectID":"/leetcode/0576/:2:0","tags":null,"title":"0576：出界的路径数（★）","uri":"/leetcode/0576/"},{"categories":null,"content":"解答 def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -\u003e int: @lru_cache(None) def dfs(i, j, k): if not 0\u003c=i\u003cm or not 0\u003c=j\u003cn: return 1 if k==0: return 0 return sum(dfs(x, y, k-1) for x,y in [(i+1, j),(i-1,j),(i,j+1),(i,j-1)])%mod mod = 10**9+7 return dfs(startRow, sta","date":"2016-07-29","objectID":"/leetcode/0576/:3:0","tags":null,"title":"0576：出界的路径数（★）","uri":"/leetcode/0576/"},{"categories":null,"content":" 力扣第 575 题 ","date":"2016-07-28","objectID":"/leetcode/0575/:0:0","tags":null,"title":"0575：分糖果","uri":"/leetcode/0575/"},{"categories":null,"content":"题目 Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。 医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。 给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的 最多 种类数。 示例 1： 输入：candyType = [1,1,2,2,3,3]\r输出：3\r解释：Alice 只能吃 6 / 2 = 3 枚糖，由","date":"2016-07-28","objectID":"/leetcode/0575/:1:0","tags":null,"title":"0575：分糖果","uri":"/leetcode/0575/"},{"categories":null,"content":"分析 妹妹分到 x = len(candyType) // 2 个糖果，若糖果种类足够多，显然 x 即是结果。 若糖果种类 y 小于 x，那么妹妹就只能分到 y 种。 ","date":"2016-07-28","objectID":"/leetcode/0575/:2:0","tags":null,"title":"0575：分糖果","uri":"/leetcode/0575/"},{"categories":null,"content":"解答 def distributeCandies(self, candyType: List[int]) -\u003e int: return min(len(candyType)//2, len(set(candyType))) 92 ms ","date":"2016-07-28","objectID":"/leetcode/0575/:3:0","tags":null,"title":"0575：分糖果","uri":"/leetcode/0575/"},{"categories":null,"content":" 力扣第 572 题 ","date":"2016-07-25","objectID":"/leetcode/0572/:0:0","tags":null,"title":"0572：另一棵树的子树","uri":"/leetcode/0572/"},{"categories":null,"content":"题目 给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。 二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。 示例 1： 输入：root = [3,4,5,1,2], subRoot = [4,1,2]\r输出：true\r示例 2： 输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\r输出：false\r提示： root 树上的节点数","date":"2016-07-25","objectID":"/leetcode/0572/:1:0","tags":null,"title":"0572：另一棵树的子树","uri":"/leetcode/0572/"},{"categories":null,"content":"分析 ","date":"2016-07-25","objectID":"/leetcode/0572/:2:0","tags":null,"title":"0572：另一棵树的子树","uri":"/leetcode/0572/"},{"categories":null,"content":"#1 容易想到递归方法，先比较 root 和 subRoot，不相等就递归到 root 的子树。 判断是否相同即是问题 0100，可以通过遍历或递归解决。 两重递归有些浪费时间了，有个巧妙的想法是将树序列化，就可以直接比较了。 用 ‘#’ 表示空节点，那么任意遍历得到的列表都一一对应二叉树。保存每棵子树对应的序列即可。 def isSubtree(self, root: TreeNode, subRoot: TreeNode) -\u003e bool: @lru_cache(None) def serial(root): return '#' if not root else '%d,%s,%s' %","date":"2016-07-25","objectID":"/leetcode/0572/:2:1","tags":null,"title":"0572：另一棵树的子树","uri":"/leetcode/0572/"},{"categories":null,"content":"#2 还可以更进一步，按类似字典的形式将树序列化，那么 t 是 s 的子树就等价于 t 的序列化是 s 的序列化的子串。 ","date":"2016-07-25","objectID":"/leetcode/0572/:2:2","tags":null,"title":"0572：另一棵树的子树","uri":"/leetcode/0572/"},{"categories":null,"content":"解答 def isSubtree(self, root: TreeNode, subRoot: TreeNode) -\u003e bool: def serial(root): return 'None' if not root else '{val:%d,left:%s,right:%s}' % (root.val,serial(root.left),serial(root.right)) return serial(subRoot) in serial(root) 80 ms ","date":"2016-07-25","objectID":"/leetcode/0572/:3:0","tags":null,"title":"0572：另一棵树的子树","uri":"/leetcode/0572/"},{"categories":null,"content":" 力扣第 567 题 ","date":"2016-07-20","objectID":"/leetcode/0567/:0:0","tags":null,"title":"0567：字符串的排列（★）","uri":"/leetcode/0567/"},{"categories":null,"content":"题目 给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。 换句话说，s1 的排列之一是 s2 的 子串 。 示例 1： 输入：s1 = \"ab\" s2 = \"eidbaooo\"\r输出：true\r解释：s2 包含 s1 的排列之一 (\"ba\").\r示例 2： 输入：s1= \"ab\" s2 = \"eidboaoo\"\r输出：false\r提示： 1 \u003c= s1.length, s2.length \u003c= 104\rs1 和 s2 仅包含小写字母\r","date":"2016-07-20","objectID":"/leetcode/0567/:1:0","tags":null,"title":"0567：字符串的排列（★）","uri":"/leetcode/0567/"},{"categories":null,"content":"分析 类似于问题 0438 ，还更简单一点。 ","date":"2016-07-20","objectID":"/leetcode/0567/:2:0","tags":null,"title":"0567：字符串的排列（★）","uri":"/leetcode/0567/"},{"categories":null,"content":"解答 def checkInclusion(self, s1: str, s2: str) -\u003e bool: ct, ct0, k = Counter(), Counter(s1), len(s1) for j, char in enumerate(s2): ct[char] += 1 if j \u003e= k: ct[s2[j-k]] -= 1 if ct[s2[j-k]] == 0: del ct[s2[j-k]] if j \u003e= k-1 and ct == ct0: return True return False 96 ms ","date":"2016-07-20","objectID":"/leetcode/0567/:3:0","tags":null,"title":"0567：字符串的排列（★）","uri":"/leetcode/0567/"},{"categories":null,"content":" 力扣第 564 题 ","date":"2016-07-17","objectID":"/leetcode/0564/:0:0","tags":null,"title":"0564：寻找最近的回文数（★★）","uri":"/leetcode/0564/"},{"categories":null,"content":"题目 给定一个表示整数的字符串 n ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。 “最近的”定义为两个整数差的绝对值最小。 示例 1: 输入: n = \"123\"\r输出: \"121\"\r示例 2: 输入: n = \"1\"\r输出: \"0\"\r解释: 0 和 2是最近的回文，但我们返回最小的，也就是 0。\r提示: 1 \u003c= n.length \u003c= 18\rn 只由数字组成\rn 不含前导 0\rn 代表在 [1, 1018 - 1] 范围内的整数\r","date":"2016-07-17","objectID":"/leetcode/0564/:1:0","tags":null,"title":"0564：寻找最近的回文数（★★）","uri":"/leetcode/0564/"},{"categories":null,"content":"分析 显然用暴力法太耗时了，考虑直接构造的方法。 尝试几次发现可以用固定前半并镜像的方法得到一个相近的回文数。 例如 356，固定住 35 并镜像得到 353，又如 6482 固定住 64 并镜像得到 6446。 这样得到的回文数和原数的差必然在 $10^{len(n)//2}$ 以内，所以暴力法要遍历 $O(\\sqrt N)$ 次。 但这并不一定是最近的，比如说 731 最近的应该是 727 而不是 737 ，399 最近的应该是 404 而不是 393。 也就是说，设 n 的前半为 half，以 half 镜像得到的不一定是最近的。但分别以 half-1、half、half+1 镜像的三个","date":"2016-07-17","objectID":"/leetcode/0564/:2:0","tags":null,"title":"0564：寻找最近的回文数（★★）","uri":"/leetcode/0564/"},{"categories":null,"content":"解答 def nearestPalindromic(self, n: str) -\u003e str: L = len(n) half, flag = n[:(L+1)//2], L % 2 h1, h2 = str(int(half)-1), str(int(half)+1) a = h1 + h1[-flag-1::-1] if h1!='0' and len(h1)==len(half) else str(10**(L-1)-1) b = half + half[-flag-1::-1] c = h2 + h2[-flag-1::-1] if len(h2)==len(half) else st","date":"2016-07-17","objectID":"/leetcode/0564/:3:0","tags":null,"title":"0564：寻找最近的回文数（★★）","uri":"/leetcode/0564/"},{"categories":null,"content":" 力扣第 563 题 ","date":"2016-07-16","objectID":"/leetcode/0563/:0:0","tags":null,"title":"0563：二叉树的坡度","uri":"/leetcode/0563/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ，计算并返回 整个树 的坡度 。 一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。 整个树 的坡度就是其所有节点的坡度之和。 示例 1： 输入：root = [1,2,3]\r输出：1\r解释：\r节点 2 的坡度：|0-0| = 0（没有子节点）\r节点 3 的坡度：|0-0| = 0（没有子节点）\r节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）\r坡度总和：0 + 0","date":"2016-07-16","objectID":"/leetcode/0563/:1:0","tags":null,"title":"0563：二叉树的坡度","uri":"/leetcode/0563/"},{"categories":null,"content":"分析 令辅助函数 help(node) 同时返回整个树 node 的坡度、node 的节点之和，即可递归。 ","date":"2016-07-16","objectID":"/leetcode/0563/:2:0","tags":null,"title":"0563：二叉树的坡度","uri":"/leetcode/0563/"},{"categories":null,"content":"解答 def findTilt(self, root: TreeNode) -\u003e int: def help(node): if not node: return 0, 0 l0, l1 = help(node.left) r0, r1 = help(node.right) return l0+r0+abs(l1-r1), node.val+l1+r1 return help(root)[0] 60 ms ","date":"2016-07-16","objectID":"/leetcode/0563/:3:0","tags":null,"title":"0563：二叉树的坡度","uri":"/leetcode/0563/"},{"categories":null,"content":" 力扣第 561 题 ","date":"2016-07-14","objectID":"/leetcode/0561/:0:0","tags":null,"title":"0561：数组拆分","uri":"/leetcode/0561/"},{"categories":null,"content":"题目 给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。 返回该 最大总和 。 示例 1： 输入：nums = [1,4,3,2]\r输出：4\r解释：所有可能的分法（忽略元素顺序）为：\r1. (1, 4), (2, 3) -\u003e min(1, 4) + min(2, 3) = 1 + 2 = 3\r2. (1, 3), (2, 4) -\u003e min(1, 3) + min(2, 4) = 1 + 2 = 3\r3. (1, 2), (3, 4) ","date":"2016-07-14","objectID":"/leetcode/0561/:1:0","tags":null,"title":"0561：数组拆分","uri":"/leetcode/0561/"},{"categories":null,"content":"分析 直觉来说应该把最小的两个数分在一起，剩下的依此类推。不过还是要证明一下。 假设最小的两个数是 $a_i、a_j$ 并且没有分在一起，那么其中两对是 $(a_i, x)、(a_j, y)$，这两对总和即为 $a_i+a_j$。那么把这两对改为 $(a_i, a_j)、(x, y)$，总和变为 $min(a_i,a_j)+min(x,y)$，显然增大了。 因此要使总和最大，最小的两个数必然分在一起，剩下的是递归子问题也同理。 ","date":"2016-07-14","objectID":"/leetcode/0561/:2:0","tags":null,"title":"0561：数组拆分","uri":"/leetcode/0561/"},{"categories":null,"content":"解答 def arrayPairSum(self, nums: List[int]) -\u003e int: return sum(sorted(nums)[::2]) 76 ms ","date":"2016-07-14","objectID":"/leetcode/0561/:3:0","tags":null,"title":"0561：数组拆分","uri":"/leetcode/0561/"},{"categories":null,"content":" 力扣第 560 题 ","date":"2016-07-13","objectID":"/leetcode/0560/:0:0","tags":null,"title":"0560：和为 K 的子数组（★）","uri":"/leetcode/0560/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。 示例 1： 输入：nums = [1,1,1], k = 2\r输出：2\r示例 2： 输入：nums = [1,2,3], k = 3\r输出：2\r提示： 1 \u003c= nums.length \u003c= 2 * 104\r-1000 \u003c= nums[i] \u003c= 1000\r-107 \u003c= k \u003c= 107\r","date":"2016-07-13","objectID":"/leetcode/0560/:1:0","tags":null,"title":"0560：和为 K 的子数组（★）","uri":"/leetcode/0560/"},{"categories":null,"content":"分析 ","date":"2016-07-13","objectID":"/leetcode/0560/:2:0","tags":null,"title":"0560：和为 K 的子数组（★）","uri":"/leetcode/0560/"},{"categories":null,"content":"#1 求任意子数组的和，容易想到前缀和。 得到前缀和数组 pre 后，就是找 i \u003c j 使得 pre[j]-pre[i]==k。 查找定值容易想到哈希表，遍历时边存边查即可。 def subarraySum(self, nums: List[int], k: int) -\u003e int: pre = list(accumulate([0]+nums)) res, ct = 0, Counter() for val in pre: res += ct[val-k] ct[val] += 1 return res 116 ms ","date":"2016-07-13","objectID":"/leetcode/0560/:2:1","tags":null,"title":"0560：和为 K 的子数组（★）","uri":"/leetcode/0560/"},{"categories":null,"content":"#2 也可以合并为一趟解决。 ","date":"2016-07-13","objectID":"/leetcode/0560/:2:2","tags":null,"title":"0560：和为 K 的子数组（★）","uri":"/leetcode/0560/"},{"categories":null,"content":"解答 def subarraySum(self, nums: List[int], k: int) -\u003e int: res, pre, ct = 0, 0, Counter([0]) for val in nums: pre += val res += ct[pre-k] ct[pre] += 1 return res 116 ms ","date":"2016-07-13","objectID":"/leetcode/0560/:3:0","tags":null,"title":"0560：和为 K 的子数组（★）","uri":"/leetcode/0560/"},{"categories":null,"content":" 力扣第 559 题 ","date":"2016-07-12","objectID":"/leetcode/0559/:0:0","tags":null,"title":"0559：N 叉树的最大深度","uri":"/leetcode/0559/"},{"categories":null,"content":"题目 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。 示例 1： 输入：root = [1,null,3,2,4,null,5,6]\r输出：3\r示例 2： 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\r输出：5\r提示： 树的深度不会超过 1000 。\r树的节点数目位于 [0, 104] 之间。\r","date":"2016-07-12","objectID":"/leetcode/0559/:1:0","tags":null,"title":"0559：N 叉树的最大深度","uri":"/leetcode/0559/"},{"categories":null,"content":"分析 ","date":"2016-07-12","objectID":"/leetcode/0559/:2:0","tags":null,"title":"0559：N 叉树的最大深度","uri":"/leetcode/0559/"},{"categories":null,"content":"#1 类似 0104 ，可以层序遍历，记录有多少层即可。 def maxDepth(self, root: 'Node') -\u003e int: if not root: return 0 D, level = 0, [root] while level: D += 1 level = [child for node in level for child in node.children] return D 44 ms ","date":"2016-07-12","objectID":"/leetcode/0559/:2:1","tags":null,"title":"0559：N 叉树的最大深度","uri":"/leetcode/0559/"},{"categories":null,"content":"#2 也可以用递归。 ","date":"2016-07-12","objectID":"/leetcode/0559/:2:2","tags":null,"title":"0559：N 叉树的最大深度","uri":"/leetcode/0559/"},{"categories":null,"content":"解答 def maxDepth(self, root: 'Node') -\u003e int: return 0 if not root else (1 if not root.children else max(map(self.maxDepth, root.children)) + 1)``` 52 ms ","date":"2016-07-12","objectID":"/leetcode/0559/:3:0","tags":null,"title":"0559：N 叉树的最大深度","uri":"/leetcode/0559/"},{"categories":null,"content":"　　平凡的中学二年级少年影山茂夫，因其微弱的存在感与名字茂夫的谐音被周遭人称为龙套（モブ），但不起眼的他其实是强大的天生超能力者。历经每一次的成长，龙套开始认为自己的超能力是危险的存在，为了不让超能力失控，龙套无意识的压抑著情感。虽然只想平凡的度过每一天，但各种麻烦却接二连三找上他，随着被压抑的情感在内心一点点膨胀，龙套体内积累的力量似乎也正蠢蠢欲动......","date":"2016-07-11","objectID":"/anime/mob_psycho_100/","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":"简介 平凡的中学二年级少年影山茂夫，因其微弱的存在感与名字茂夫的谐音被周遭人称为龙套（モブ），但不起眼的他其实是强大的天生超能力者。历经每一次的成长，龙套开始认为自己的超能力是危险的存在，为了不让超能力失控，龙套无意识的压抑著情感。虽然只想平凡的度过每一天，但各种麻烦却接二连三找上他，随着被压抑的情感在内心一点点膨胀，龙套体内积累的力量似乎也正蠢蠢欲动…… 制作人员： 原作：ONE 导演：立川让 脚本：濑古浩司 分镜：重原克也、安斋刚文、川畑乔、藤泽研一、米谷良知 ","date":"2016-07-11","objectID":"/anime/mob_psycho_100/:1:0","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 影山茂夫 龙套、影山 茂夫、かげやま しげお、Kageyama Shigeo、モブ 男 伊藤節生 2 灵幻新隆 霊幻 新隆、れいげん あらたか、Reigen Arataka 男 櫻井孝宏 3 小酒窝 エクボ、Ekubo 男 大塚明夫 4 影山律 影山 律、かげやま りつ、Kageyama Ritsu 男 入野自由 5 花泽辉气 花沢 輝気、はなざわ てるき、Hanazawa Teruki 男 松岡禎丞 6 鬼瓦天牙 鬼瓦 天牙、おにがわら てんが、Onigawara Tenga 男 細谷佳正 7 米里一 米里 イチ、めざと イチ、Mezato Ichi 女 ","date":"2016-07-11","objectID":"/anime/mob_psycho_100/:2:0","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 灵能百分百 2016-07-11 12 bilibili 2 灵能百分百 REIGEN ～不为人知的奇迹的灵能力者～ 2018-03-18 1 bilibili 3 灵能百分百 第二季 2019-01-07 13 bilibili 4 灵能百分百 第一回灵能相谈所犒劳旅行～心满意足的治愈之旅～ 2019-09-25 1 bilibili 5 灵能百分百 第三季 2022-10-05 12 bilibili ","date":"2016-07-11","objectID":"/anime/mob_psycho_100/:3:0","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":"MAD ","date":"2016-07-11","objectID":"/anime/mob_psycho_100/:4:0","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":" 力扣第 557 题 ","date":"2016-07-10","objectID":"/leetcode/0557/:0:0","tags":null,"title":"0557：反转字符串中的单词 III","uri":"/leetcode/0557/"},{"categories":null,"content":"题目 给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1： 输入：s = \"Let's take LeetCode contest\"\r输出：\"s'teL ekat edoCteeL tsetnoc\"\r示例 2: 输入： s = \"God Ding\"\r输出：\"doG gniD\"\r提示： 1 \u003c= s.length \u003c= 5 * 104\rs 包含可打印的 ASCII 字符。\rs 不包含任何开头或结尾空格。\rs 里 至少 有一个词。\rs 中的所有单词都用一个空格隔开。\r","date":"2016-07-10","objectID":"/leetcode/0557/:1:0","tags":null,"title":"0557：反转字符串中的单词 III","uri":"/leetcode/0557/"},{"categories":null,"content":"分析 按空格分开得到单词列表，分别反转后再用空格拼接起来即可。 ","date":"2016-07-10","objectID":"/leetcode/0557/:2:0","tags":null,"title":"0557：反转字符串中的单词 III","uri":"/leetcode/0557/"},{"categories":null,"content":"解答 def reverseWords(self, s: str) -\u003e str: return ' '.join(sub[::-1] for sub in s.split(' ')) 32 ms ","date":"2016-07-10","objectID":"/leetcode/0557/:3:0","tags":null,"title":"0557：反转字符串中的单词 III","uri":"/leetcode/0557/"},{"categories":null,"content":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能力，以不起眼、不和他人有所牵扯为信条，默默无闻地过日子。但不知为何，他的身边总是聚集着不可思议的人类（生物），风暴般的灾难接连不断地降临！","date":"2016-07-10","objectID":"/anime/saiki_kusuo/","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"简介 高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能力，以不起眼、不和他人有所牵扯为信条，默默无闻地过日子。但不知为何，他的身边总是聚集着不可思议的人类（生物），风暴般的灾难接连不断地降临！ 制作人员： 原作：麻生周一 导演：樱井弘明 脚本：横谷昌宏、横手美智子、金杉弘子、杉原研二 分镜：赤城博昭、名村英敏、梶井濑贺 ","date":"2016-07-10","objectID":"/anime/saiki_kusuo/:1:0","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 齐木楠雄 斉木 楠雄、さいき くすお、Saiki Kusuo 男 神谷浩史 2 燃堂力 燃堂 力、ねんどう りき、Nendō Riki 男 小野大輔 3 海藤瞬 海藤 瞬、かいどう しゅん、Kaidō Shun 男 島﨑信長 4 灰吕杵志 灰呂 杵志、はいろ きねし、Hairo Kineshi 男 日野聡 5 鸟束零太 鳥束 零太、とりつか れいた、Toritsuka Reita 男 花江夏樹 6 照桥心美 照橋 心美、てるはし ここみ、Teruhashi Kokomi 女 茅野愛衣 7 梦原知予 夢原 知予、ゆめはら ちよ、Yumehara Chiyo 女","date":"2016-07-10","objectID":"/anime/saiki_kusuo/:2:0","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 齐木楠雄的灾难 2016-07-10 24 bilibili 2 齐木楠雄的灾难 第二季 2018-01-16 24 bilibili 3 齐木楠雄的灾难 完结篇 2018-12-28 2 bilibili 4 齐木楠雄的灾难 再始动篇 2019-12-30 6 bilibili ","date":"2016-07-10","objectID":"/anime/saiki_kusuo/:3:0","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"MAD ","date":"2016-07-10","objectID":"/anime/saiki_kusuo/:4:0","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"B\u0026T首部动画电影巨作《大鱼 海棠》，导演用了三年形成《大鱼.海棠》的创意，用了三年写完《大鱼.海棠》的剧本。影片讲述了一个属于中国人的奇幻故事。试图向观众展现那条游弋在每个中国人血液和灵魂中的大鱼——鲲。\n\n获第十六届上海电视节“最佳创意奖”。影片预览获第十四届韩国首尔国际动漫节最佳技术奖，并入选第五十届法国昂西国际动漫节。","date":"2016-07-08","objectID":"/anime/big_fish/","tags":null,"title":"大鱼·海棠","uri":"/anime/big_fish/"},{"categories":null,"content":"简介 B\u0026T首部动画电影巨作《大鱼 海棠》，导演用了三年形成《大鱼.海棠》的创意，用了三年写完《大鱼.海棠》的剧本。影片讲述了一个属于中国人的奇幻故事。试图向观众展现那条游弋在每个中国人血液和灵魂中的大鱼——鲲。 获第十六届上海电视节“最佳创意奖”。影片预览获第十四届韩国首尔国际动漫节最佳技术奖，并入选第五十届法国昂西国际动漫节。 制作人员： 原作：梁旋 音乐：吉田洁 原画：羊廷牧 主题歌演出：陈奕迅 製作：霍尔果斯彩条屋影业有限公司、北京光线影业有限公司 制作助手：震雷动画 ","date":"2016-07-08","objectID":"/anime/big_fish/:1:0","tags":null,"title":"大鱼·海棠","uri":"/anime/big_fish/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 椿 女 季冠霖 2 湫 男 苏尚卿 3 鲲 男 ","date":"2016-07-08","objectID":"/anime/big_fish/:2:0","tags":null,"title":"大鱼·海棠","uri":"/anime/big_fish/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 大鱼·海棠 2016-07-08 1 bilibili ","date":"2016-07-08","objectID":"/anime/big_fish/:3:0","tags":null,"title":"大鱼·海棠","uri":"/anime/big_fish/"},{"categories":null,"content":" 力扣第 554 题 ","date":"2016-07-07","objectID":"/leetcode/0554/:0:0","tags":null,"title":"0554：砖墙（★）","uri":"/leetcode/0554/"},{"categories":null,"content":"题目 你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。 你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。 给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。 示例 1： 输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4]","date":"2016-07-07","objectID":"/leetcode/0554/:1:0","tags":null,"title":"0554：砖墙（★）","uri":"/leetcode/0554/"},{"categories":null,"content":"分析 显然找一条穿过边缘最多的垂线（除了墙边）即可。于是记录每行的边缘位置（横坐标 y），找到对应了最多行的位置即可。 ","date":"2016-07-07","objectID":"/leetcode/0554/:2:0","tags":null,"title":"0554：砖墙（★）","uri":"/leetcode/0554/"},{"categories":null,"content":"解答 def leastBricks(self, wall: List[List[int]]) -\u003e int: return len(wall) - (max(Counter([y for row in wall for y in accumulate(row[:-1])]).values() or [0])) 60 ms ","date":"2016-07-07","objectID":"/leetcode/0554/:3:0","tags":null,"title":"0554：砖墙（★）","uri":"/leetcode/0554/"},{"categories":null,"content":"在封印的都市中被废弃的天象馆，误入其中的男人所见到的机器人少女，那是被繁星所引导的奇迹的物语。\n那是世界大战之后不再降雨的世界。受到细菌武器的影响，而被人们抛弃了的最危险的城市【封印都市】。在某个百货商场的天文馆中，有一个机器人少女。她的名字是“星野梦美”。她是天文馆的解说员，1年之中只有7日运行的损坏的机器人。就这样，少女在这30年间始终相信着会有某个人到访天文馆，一个人在这个没有其他人的世界等待着。然后，在第三十个年头醒来的那天，她的面前出现了一个男人。\n“恭喜您！您正正好是250万个客人！”\n对突然出现的机器人进行警戒的男人——“废墟猎人”，以自城市回收贵重物资作为生计的他，正为了生存潜入【封印都市】，被在都市中徘徊的战斗机械的袭击，而误入了这个天文馆。\n“要来观赏一下天象仪吗。无论何时都不会消失的美丽的无尽的星光……漫天的星星们正在等着大家呢”\n在大战的影响之下，连星星都无法再看见的濒临毁灭的这个世界，他究竟在那里看到了什么。一年之中只有7天能够运行的机器人少女，苏醒的那一天正遇上那偶然的到访。\n奇迹就这样发生了……","date":"2016-07-07","objectID":"/anime/planetarian/","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":"简介 在封印的都市中被废弃的天象馆，误入其中的男人所见到的机器人少女，那是被繁星所引导的奇迹的物语。 那是世界大战之后不再降雨的世界。受到细菌武器的影响，而被人们抛弃了的最危险的城市【封印都市】。在某个百货商场的天文馆中，有一个机器人少女。她的名字是“星野梦美”。她是天文馆的解说员，1年之中只有7日运行的损坏的机器人。就这样，少女在这30年间始终相信着会有某个人到访天文馆，一个人在这个没有其他人的世界等待着。然后，在第三十个年头醒来的那天，她的面前出现了一个男人。 “恭喜您！您正正好是250万个客人！” 对突然出现的机器人进行警戒的男人——“废墟猎人”，以自城市回收贵重物资作为生计的他，正为了","date":"2016-07-07","objectID":"/anime/planetarian/:1:0","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 星野梦美 ほしのゆめみ、Hoshino yumemi 女 すずきけいこ 2 废墟猎人 星の人、くずや、Kuzuya 男 小野大輔 ","date":"2016-07-07","objectID":"/anime/planetarian/:2:0","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 星之梦 2016-07-07 5 bilibili 2 星之梦～星之人～ 2016-09-03 1 bilibili 3 星之梦～雪圏球～ 2021-08-25 1 bilibili ","date":"2016-07-07","objectID":"/anime/planetarian/:3:0","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":"MAD ","date":"2016-07-07","objectID":"/anime/planetarian/:4:0","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":" 力扣第 552 题 ","date":"2016-07-05","objectID":"/leetcode/0552/:0:0","tags":null,"title":"0552：学生出勤记录 II（★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"题目 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： 'A'：Absent，缺勤\r'L'：Late，迟到\r'P'：Present，到场\r如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： 按 总出勤 计，学生缺勤（'A'）严格 少于两天。\r学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。\r给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。 示例 1： 输入：n = 2\r输出：","date":"2016-07-05","objectID":"/leetcode/0552/:1:0","tags":null,"title":"0552：学生出勤记录 II（★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"分析 最后一个字符有三种情况： 假如为 ‘A’，那么前面不能再有 ‘A’ 假如为 ‘L’，那么前两个字符不能都为 ‘L’ 假如为 ‘P’，前面的是子问题 那么令 dp[i][j][k] 代表 长度 i 有 j 个’A’ 末尾有 k 个连续 ‘L’ 条件下的数量，即可递归。最后 sum(dp[n][0])+sum(dp[n][1]) 即为所求。 还可以用滚动数组优化。并且因为 j 和 k 的范围很小，可以合并为一维数组。 ","date":"2016-07-05","objectID":"/leetcode/0552/:2:0","tags":null,"title":"0552：学生出勤记录 II（★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"解答 def checkRecord(self, n: int) -\u003e int: mod = 10**9+7 dp = [1]+[0]*5 for i in range(1, n+1): dp = [sum(dp[:3])%mod, dp[0], dp[1], sum(dp)%mod, dp[3], dp[4]] return sum(dp)%mod 772 ms ","date":"2016-07-05","objectID":"/leetcode/0552/:3:0","tags":null,"title":"0552：学生出勤记录 II（★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"*附加 这是完全的线性递推关系，因此可以用矩阵快速幂优化。 注意在矩阵乘法时也取模即可。 def checkRecord(self, n: int) -\u003e int: def mpow(mat, n): res = mat for bit in bin(n)[3:]: res = res*res%mod if bit=='1': res = res*mat%mod return res import numpy as np mod = 10**9+7 A = np.mat([[1,1,1,0,0,0],[1,0,0,0,0,0],[0,1,0,0,0,0], [1,1,1,1,1,1],[0,0","date":"2016-07-05","objectID":"/leetcode/0552/:4:0","tags":null,"title":"0552：学生出勤记录 II（★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"海崎新太（27岁）在作为新毕业生进入的公司工作了3个月就辞职了。\n之后他的就职活动也不顺利。\n双亲寄来的生活费也中断了，不得已只好回到乡下。\n能够倾听他烦恼的朋友和女友全都没有……\n穷途末路的海崎面前出现了一位神秘人物·夜明了。\n夜明向海崎提出，要他参加以尼特为对象的社会复归程序“ReLIFE”。\n其内容是，利用神秘的秘药，仅仅让外表回复年轻，并在一年内以高中生的身份去读高中——。","date":"2016-07-01","objectID":"/anime/relife/","tags":null,"title":"ReLIFE","uri":"/anime/relife/"},{"categories":null,"content":"简介 海崎新太（27岁）在作为新毕业生进入的公司工作了3个月就辞职了。 之后他的就职活动也不顺利。 双亲寄来的生活费也中断了，不得已只好回到乡下。 能够倾听他烦恼的朋友和女友全都没有…… 穷途末路的海崎面前出现了一位神秘人物·夜明了。 夜明向海崎提出，要他参加以尼特为对象的社会复归程序“ReLIFE”。 其内容是，利用神秘的秘药，仅仅让外表回复年轻，并在一年内以高中生的身份去读高中——。 制作人员： 原作：夜宵草 导演：小坂知 脚本：兵头一步、横手美智子 分镜：备前克彦、关晓子、山田弘和、添田和弘 ","date":"2016-07-01","objectID":"/anime/relife/:1:0","tags":null,"title":"ReLIFE","uri":"/anime/relife/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 日代千鹤 日代 千鶴、ひしろ ちづる、Hishiro Chizuru 女 茅野愛衣 2 海崎新太 海崎 新太、かいざき あらた、Kaizaki Arata 男 小野賢章 3 小野屋杏 小野屋 杏、おのや あん、Onoya An 女 上田麗奈 4 夜明了 夜明 了、よあけ りょう、Yoake Ryou 男 木村良平 5 大神和臣 大神 和臣、おおが かずおみ、Ooga Kazuomi 男 内田雄馬 6 狩生玲奈 狩生 玲奈、かりう れな、Kariu Rena 女 戸松遥 7 玉来萌香 玉来 ほのか、たまらい ほのか、Tamerai Honoka 女 茜屋日海夏","date":"2016-07-01","objectID":"/anime/relife/:2:0","tags":null,"title":"ReLIFE","uri":"/anime/relife/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 ReLIFE 2016-07-01 13 bilibili 2 ReLIFE 完结篇 2018-03-21 4 bilibili ","date":"2016-07-01","objectID":"/anime/relife/:3:0","tags":null,"title":"ReLIFE","uri":"/anime/relife/"},{"categories":null,"content":" 力扣第 547 题 ","date":"2016-06-30","objectID":"/leetcode/0547/:0:0","tags":null,"title":"0547：省份数量（★）","uri":"/leetcode/0547/"},{"categories":null,"content":"题目 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 返回矩阵中 省份 的数量。 示例 1： 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]\r输出：2\r示例 2： 输入","date":"2016-06-30","objectID":"/leetcode/0547/:1:0","tags":null,"title":"0547：省份数量（★）","uri":"/leetcode/0547/"},{"categories":null,"content":"分析 即是求无向图的连通分量数，可以通过遍历求解，bfs 和 dfs 都可以。 不过一般这类问题用并查集，更直观。 ","date":"2016-06-30","objectID":"/leetcode/0547/:2:0","tags":null,"title":"0547：省份数量（★）","uri":"/leetcode/0547/"},{"categories":null,"content":"解答 def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) n = len(isConnected) f = list(range(n)) for i, j in product(range(n), range(n)): if isConnected[i][j]: union(i, j) return sum(f[i] == i for ","date":"2016-06-30","objectID":"/leetcode/0547/:3:0","tags":null,"title":"0547：省份数量（★）","uri":"/leetcode/0547/"},{"categories":null,"content":" 力扣第 546 题 ","date":"2016-06-29","objectID":"/leetcode/0546/:0:0","tags":null,"title":"0546：移除盒子（★★）","uri":"/leetcode/0546/"},{"categories":null,"content":"题目 给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k \u003e= 1），这样一轮之后你将得到 k * k 个积分。 返回 你能获得的最大积分和 。 示例 1： 输入：boxes = [1,3,2,2,2,3,4,3,1]\r输出：23\r解释：\r[1, 3, 2, 2, 2, 3, 4, 3, 1]\r----\u003e [1, 3, 3, 4, 3, 1] (3*3=9 分)\r----\u003e [1, 3, 3, 3, 1] (1*1=1 分)\r----\u003e [1, 1] (3*3=9 分)\r","date":"2016-06-29","objectID":"/leetcode/0546/:1:0","tags":null,"title":"0546：移除盒子（★★）","uri":"/leetcode/0546/"},{"categories":null,"content":"分析 显然初始连续的盒子最后是一起移除的，考虑将连续段合并，得到元素为 (颜色，连续段长度) 的数组 A。 考虑元素 A[-1]，它要么单独移除，要么和前面颜色相同的元素一起移除 假如 A[-1] 单独移除，显然转为递归子问题 假如 A[-1] 和 A[i] 一起移除 必然先移除了 A[i+1:-1] 部分，这部分即是子问题 然后将 A[-1] 的长度累加到 A[i] 上，剩下的也是子问题 因此令 dfs(A) 代表数组 A 的最大积分，即可递归。 ","date":"2016-06-29","objectID":"/leetcode/0546/:2:0","tags":null,"title":"0546：移除盒子（★★）","uri":"/leetcode/0546/"},{"categories":null,"content":"解答 def removeBoxes(self, boxes: List[int]) -\u003e int: @lru_cache(None) def dfs(A): if not A: return 0 c, k = A[-1] res = dfs(A[:-1])+k**2 for i in range(len(A)-2): if A[i][0]==c: B = A[:i]+((c, A[i][1]+k),) res = max(res, dfs(B)+dfs(A[i+1:-1])) return res A = tuple((x, len(list(g))) for x, g in groupby","date":"2016-06-29","objectID":"/leetcode/0546/:3:0","tags":null,"title":"0546：移除盒子（★★）","uri":"/leetcode/0546/"},{"categories":null,"content":"*附加 时间复杂度分析： 注意到递归时只会对区间数组的末尾进行修改，因此可以改写成一般的区间 dp 形式 令 dfs(i, j, k) 代表 A[i:j+1] 且 A[j] 额外加了 k 的最大积分，即可递归 显然 k 小于 n，因此一般的区间 dp 写法的时间复杂度是 O(N^4) 直接递归区间数组的形式，有切片操作，所以时间复杂度更高 但因为本题的数值范围很小，一般会存在重复的区间数组，所以直接递归区间数组的实际时间更快 ","date":"2016-06-29","objectID":"/leetcode/0546/:4:0","tags":null,"title":"0546：移除盒子（★★）","uri":"/leetcode/0546/"},{"categories":null,"content":" 力扣第 543 题 ","date":"2016-06-26","objectID":"/leetcode/0543/:0:0","tags":null,"title":"0543：二叉树的直径","uri":"/leetcode/0543/"},{"categories":null,"content":"题目 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 示例 : 给定二叉树 1\r/ \\\r2 3\r/ \\\r4 5\r返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 ","date":"2016-06-26","objectID":"/leetcode/0543/:1:0","tags":null,"title":"0543：二叉树的直径","uri":"/leetcode/0543/"},{"categories":null,"content":"分析 假设路径经过根节点 root，那么最大长度是 （终点为 root.left 的最大路径长度 + 终点为 root.right 的最大路径长度 + 2）。 为了递归，令辅助函数 help(node) 同时返回 node 的直径长度、向上的终点为 node 的最大路径长度。 再注意下边界条件即可。 ","date":"2016-06-26","objectID":"/leetcode/0543/:2:0","tags":null,"title":"0543：二叉树的直径","uri":"/leetcode/0543/"},{"categories":null,"content":"解答 def diameterOfBinaryTree(self, root: TreeNode) -\u003e int: def help(node): if not node: return -1, -1 l0, l1 = help(node.left) r0, r1 = help(node.right) return max(l0, r0, l1+r1+2), 1+max(l1, r1) return help(root)[0] 52 ms ","date":"2016-06-26","objectID":"/leetcode/0543/:3:0","tags":null,"title":"0543：二叉树的直径","uri":"/leetcode/0543/"},{"categories":null,"content":" 力扣第 541 题 ","date":"2016-06-24","objectID":"/leetcode/0541/:0:0","tags":null,"title":"0541：反转字符串 II","uri":"/leetcode/0541/"},{"categories":null,"content":"题目 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。\r如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\r示例 1： 输入：s = \"abcdefg\", k = 2\r输出：\"bacdfeg\"\r示例 2： 输入：s = \"abcd\", k = 2\r输出：\"bacd\"\r提示： 1 \u003c= s.length \u003c= 104\rs 仅由小写英文组成\r1 \u003c= k \u003c= 104\r","date":"2016-06-24","objectID":"/leetcode/0541/:1:0","tags":null,"title":"0541：反转字符串 II","uri":"/leetcode/0541/"},{"categories":null,"content":"分析 按 2k 长度分段进行操作即可。 ","date":"2016-06-24","objectID":"/leetcode/0541/:2:0","tags":null,"title":"0541：反转字符串 II","uri":"/leetcode/0541/"},{"categories":null,"content":"解答 def reverseStr(self, s: str, k: int) -\u003e str: return ''.join(s[i:i+k][::-1] + s[i+k:i+2*k] for i in range(0, len(s), 2*k)) 40 ms ","date":"2016-06-24","objectID":"/leetcode/0541/:3:0","tags":null,"title":"0541：反转字符串 II","uri":"/leetcode/0541/"},{"categories":null,"content":" 力扣第 538 题 ","date":"2016-06-21","objectID":"/leetcode/0538/:0:0","tags":null,"title":"0538：把二叉搜索树转换为累加树（★）","uri":"/leetcode/0538/"},{"categories":null,"content":"题目 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。\r节点的右子树仅包含键 大于 节点键的节点。\r左右子树也必须是二叉搜索树。\r注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 示例 1： 输入：[4,1,6,0,2,5,7,null,null,n","date":"2016-06-21","objectID":"/leetcode/0538/:1:0","tags":null,"title":"0538：把二叉搜索树转换为累加树（★）","uri":"/leetcode/0538/"},{"categories":null,"content":"分析 反着中序遍历并累加即可。 ","date":"2016-06-21","objectID":"/leetcode/0538/:2:0","tags":null,"title":"0538：把二叉搜索树转换为累加树（★）","uri":"/leetcode/0538/"},{"categories":null,"content":"解答 def convertBST(self, root: TreeNode) -\u003e TreeNode: stack, pre = [(root, 0)], 0 while stack: node, flag = stack.pop() if flag: node.val += pre pre = node.val elif node: stack.extend([(node.left, 0), (node, 1), (node.right, 0)]) return root 80 ms ","date":"2016-06-21","objectID":"/leetcode/0538/:3:0","tags":null,"title":"0538：把二叉搜索树转换为累加树（★）","uri":"/leetcode/0538/"},{"categories":null,"content":" 力扣第 535 题 ","date":"2016-06-18","objectID":"/leetcode/0535/:0:0","tags":null,"title":"0535：TinyURL 的加密与解密（★）","uri":"/leetcode/0535/"},{"categories":null,"content":"题目 TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。 加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。 实现 Solution 类： Solution() 初始化 TinyURL 系统对象。\rString encode(String ","date":"2016-06-18","objectID":"/leetcode/0535/:1:0","tags":null,"title":"0535：TinyURL 的加密与解密（★）","uri":"/leetcode/0535/"},{"categories":null,"content":"分析 ","date":"2016-06-18","objectID":"/leetcode/0535/:2:0","tags":null,"title":"0535：TinyURL 的加密与解密（★）","uri":"/leetcode/0535/"},{"categories":null,"content":"#1 转为唯一确定的 TinyURL，存在哈希表中即可。 最简单的就是计数，转为对应编号即可。 class Codec: def __init__(self): self.t = 0 self.d = {} def encode(self, longUrl: str) -\u003e str: shortUrl = '//tinyurl.com/%d' % self.t self.d[shortUrl] = longUrl return shortUrl def decode(self, shortUrl: str) -\u003e str: return self.d[shortUrl] 52 ms ","date":"2016-06-18","objectID":"/leetcode/0535/:2:1","tags":null,"title":"0535：TinyURL 的加密与解密（★）","uri":"/leetcode/0535/"},{"categories":null,"content":"#2 python 有内置函数 hash()。本题数据规模很小，可以不考虑冲突。 ","date":"2016-06-18","objectID":"/leetcode/0535/:2:2","tags":null,"title":"0535：TinyURL 的加密与解密（★）","uri":"/leetcode/0535/"},{"categories":null,"content":"解答 class Codec: def __init__(self): self.d = {} def encode(self, longUrl: str) -\u003e str: shortUrl = str(hash(longUrl)) self.d[shortUrl] = longUrl return shortUrl def decode(self, shortUrl: str) -\u003e str: return self.d[shortUrl] 40 ms ","date":"2016-06-18","objectID":"/leetcode/0535/:3:0","tags":null,"title":"0535：TinyURL 的加密与解密（★）","uri":"/leetcode/0535/"},{"categories":null,"content":" 力扣第 530 题 ","date":"2016-06-13","objectID":"/leetcode/0530/:0:0","tags":null,"title":"0530：二叉搜索树的最小绝对差","uri":"/leetcode/0530/"},{"categories":null,"content":"题目 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 示例 1： 输入：root = [4,2,6,1,3]\r输出：1\r示例 2： 输入：root = [1,0,48,null,null,12,49]\r输出：1\r提示： 树中节点的数目范围是 [2, 104]\r0 \u003c= Node.val \u003c= 105\r注意：本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同 ","date":"2016-06-13","objectID":"/leetcode/0530/:1:0","tags":null,"title":"0530：二叉搜索树的最小绝对差","uri":"/leetcode/0530/"},{"categories":null,"content":"分析 最简单的就是遍历得到数组，排序后求相邻间隔的最小值。 因为本题是二叉搜索树，所以直接中序遍历即可。 ","date":"2016-06-13","objectID":"/leetcode/0530/:2:0","tags":null,"title":"0530：二叉搜索树的最小绝对差","uri":"/leetcode/0530/"},{"categories":null,"content":"解答 def getMinimumDifference(self, root: TreeNode) -\u003e int: res = float('inf') stack, pre = [root], float('-inf') while stack: node = stack.pop() if isinstance(node, int): res, pre = min(res, node-pre), node elif node: stack.extend([node.right, node.val, node.left]) return res 68 ms ","date":"2016-06-13","objectID":"/leetcode/0530/:3:0","tags":null,"title":"0530：二叉搜索树的最小绝对差","uri":"/leetcode/0530/"},{"categories":null,"content":" 力扣第 529 题 ","date":"2016-06-12","objectID":"/leetcode/0529/:0:0","tags":null,"title":"0529：扫雷游戏（★）","uri":"/leetcode/0529/"},{"categories":null,"content":"题目 让我们一起来玩扫雷游戏！ 给你一个大小为 m x n 二维字符矩阵 board ，表示扫雷游戏的盘面，其中： 'M' 代表一个 未挖出的 地雷，\r'E' 代表一个 未挖出的 空方块，\r'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 已挖出的 空白方块，\r数字（'1' 到 '8'）表示有多少地雷与这块 已挖出的 方块相邻，\r'X' 则表示一个 已挖出的 地雷。\r给你一个整数数组 click ，其中 click = [clickr, clickc] 表示在所有 未挖出的 方块（'M' 或者 'E'）中的下一个点击位置（clickr 是行下标，clickc 是列下标）。 根据以","date":"2016-06-12","objectID":"/leetcode/0529/:1:0","tags":null,"title":"0529：扫雷游戏（★）","uri":"/leetcode/0529/"},{"categories":null,"content":"分析 ","date":"2016-06-12","objectID":"/leetcode/0529/:2:0","tags":null,"title":"0529：扫雷游戏（★）","uri":"/leetcode/0529/"},{"categories":null,"content":"#1 如果点到地雷了，直接改为 ‘X’ 返回。否则，每一步应该计算相邻地雷的个数，为零就改为 ‘B’ 递归遍历所有相邻的空方块， 不为零就改为数字。 可以用 dfs 解决。注意递归时判断相邻方块是否是空方块，避免重复计算。 def updateBoard(self, board: List[List[str]], click: List[int]) -\u003e List[List[str]]: def dfs(i, j): cnt = sum(0\u003c=x\u003cm and 0\u003c=y\u003cn and board[x][y]=='M' for x, y in product([i-1, i, i+1], [j-1,","date":"2016-06-12","objectID":"/leetcode/0529/:2:1","tags":null,"title":"0529：扫雷游戏（★）","uri":"/leetcode/0529/"},{"categories":null,"content":"#2 也可以用 bfs。注意每次将空方块加入队列时就应该标记一下，避免重复添加。 ","date":"2016-06-12","objectID":"/leetcode/0529/:2:2","tags":null,"title":"0529：扫雷游戏（★）","uri":"/leetcode/0529/"},{"categories":null,"content":"解答 def updateBoard(self, board: List[List[str]], click: List[int]) -\u003e List[List[str]]: m, n, (i, j) = len(board), len(board[0]), click if board[i][j] == 'M': board[i][j] = 'X' else: queue = deque([(i, j)]) while queue: i, j = queue.popleft() cnt = sum(0\u003c=x\u003cm and 0\u003c=y\u003cn and board[x][y]=='M' for x, y ","date":"2016-06-12","objectID":"/leetcode/0529/:3:0","tags":null,"title":"0529：扫雷游戏（★）","uri":"/leetcode/0529/"},{"categories":null,"content":" 力扣第 528 题 ","date":"2016-06-11","objectID":"/leetcode/0528/:0:0","tags":null,"title":"0528：按权重随机选择（★）","uri":"/leetcode/0528/"},{"categories":null,"content":"题目 给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重。 请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i 的 概率 为 w[i] / sum(w) 。 例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。\r示例 1： 输入：\r[\"Solution\",\"pickIndex\"]\r[[[1]],[]","date":"2016-06-11","objectID":"/leetcode/0528/:1:0","tags":null,"title":"0528：按权重随机选择（★）","uri":"/leetcode/0528/"},{"categories":null,"content":"分析 等价于变为数组 A = [0]*w[0]+[1]*w[1]+…，然后随机取一个值。 反过来，可以随机取 A 的索引值，求出对应的数即可，不需要实际构造出 A。 具体求对应的数容易想到前缀和数组，然后二分查找即可。 ","date":"2016-06-11","objectID":"/leetcode/0528/:2:0","tags":null,"title":"0528：按权重随机选择（★）","uri":"/leetcode/0528/"},{"categories":null,"content":"解答 class Solution: def __init__(self, w: List[int]): self.A = list(accumulate(w)) def pickIndex(self) -\u003e int: pos = random.randint(0, self.A[-1]-1) return bisect_right(self.A, pos) 224 ms ","date":"2016-06-11","objectID":"/leetcode/0528/:3:0","tags":null,"title":"0528：按权重随机选择（★）","uri":"/leetcode/0528/"},{"categories":null,"content":" 力扣第 526 题 ","date":"2016-06-09","objectID":"/leetcode/0526/:0:0","tags":null,"title":"0526：优美的排列（★）","uri":"/leetcode/0526/"},{"categories":null,"content":"题目 假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ： perm[i] 能够被 i 整除\ri 能够被 perm[i] 整除\r给你一个整数 n ，返回可以构造的 优美排列 的 数量 。 示例 1： 输入：n = 2\r输出：2\r解释：\r第 1 个优美的排列是 [1,2]：\r- perm[1] = 1 能被 i = 1 整除\r- perm[2] = 2 能被 i = 2 整除\r第 2 个优美的排列是 [2,1]:\r- perm[1] = 2 能被 i = 1 整除\r- i = 2 能被 perm[2]","date":"2016-06-09","objectID":"/leetcode/0526/:1:0","tags":null,"title":"0526：优美的排列（★）","uri":"/leetcode/0526/"},{"categories":null,"content":"分析 假设最后一个数是 x，满足 x%n==0 或 n%x==0， 那么剩下的转为子问题：求集合 set(range(1,n+1))-{x} 中构造优美排列的个数。 所以令 dfs(A) 代表集合 A 构造的优美排列个数，即可递归。 为了方便，可以将集合状态压缩为一个数。 ","date":"2016-06-09","objectID":"/leetcode/0526/:2:0","tags":null,"title":"0526：优美的排列（★）","uri":"/leetcode/0526/"},{"categories":null,"content":"解答 def countArrangement(self, n: int) -\u003e int: dp = [1]+[0]*((1\u003c\u003cn)-1) for st in range(1\u003c\u003cn): idx = bin(st).count('1')+1 for x in range(n): if not st\u0026(1\u003c\u003cx) and ((x+1)%idx==0 or idx%(x+1)==0): dp[st|(1\u003c\u003cx)] += dp[st] return dp[-1] 160 ms ","date":"2016-06-09","objectID":"/leetcode/0526/:3:0","tags":null,"title":"0526：优美的排列（★）","uri":"/leetcode/0526/"},{"categories":null,"content":" 力扣第 525 题 ","date":"2016-06-08","objectID":"/leetcode/0525/:0:0","tags":null,"title":"0525：连续数组（★）","uri":"/leetcode/0525/"},{"categories":null,"content":"题目 给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。 示例 1: 输入: nums = [0,1]\r输出: 2\r说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。\r示例 2: 输入: nums = [0,1,0]\r输出: 2\r说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。\r提示： 1 \u003c= nums.length \u003c= 105\rnums[i] 不是 0 就是 1\r","date":"2016-06-08","objectID":"/leetcode/0525/:1:0","tags":null,"title":"0525：连续数组（★）","uri":"/leetcode/0525/"},{"categories":null,"content":"分析 假如将 0 都替换为 -1，那么就是找和为 0 的子数组。 求任意子数组的和，容易想到前缀和。得到前缀和数组 pre 后，就是求距离最远的相同数，用哈希表即可。 ","date":"2016-06-08","objectID":"/leetcode/0525/:2:0","tags":null,"title":"0525：连续数组（★）","uri":"/leetcode/0525/"},{"categories":null,"content":"解答 def findMaxLength(self, nums: List[int]) -\u003e int: d, pre = {}, accumulate([0]+nums, lambda x, y: x+(y if y==1 else -1)) return max(i-d.setdefault(val, i) for i, val in enumerate(pre)) 212 ms ","date":"2016-06-08","objectID":"/leetcode/0525/:3:0","tags":null,"title":"0525：连续数组（★）","uri":"/leetcode/0525/"},{"categories":null,"content":" 力扣第 523 题 ","date":"2016-06-06","objectID":"/leetcode/0523/:0:0","tags":null,"title":"0523：连续的子数组和（★）","uri":"/leetcode/0523/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组： 子数组大小 至少为 2 ，且\r子数组元素总和为 k 的倍数。\r如果存在，返回 true ；否则，返回 false 。 如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。 示例 1： 输入：nums = [23,2,4,6,7], k = 6\r输出：true\r解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。\r示例 2： 输入：nums = [23,2,6,4,7], k = 6\r输出：true\r","date":"2016-06-06","objectID":"/leetcode/0523/:1:0","tags":null,"title":"0523：连续的子数组和（★）","uri":"/leetcode/0523/"},{"categories":null,"content":"分析 类似 0560 ，不过改成了总和为 k 的倍数。那么前缀和改为模 k 的余数即可。 注意 k 为 0 的特殊情况。 ","date":"2016-06-06","objectID":"/leetcode/0523/:2:0","tags":null,"title":"0523：连续的子数组和（★）","uri":"/leetcode/0523/"},{"categories":null,"content":"解答 def checkSubarraySum(self, nums: List[int], k: int) -\u003e bool: s, d = 0, {} for i, num in enumerate(nums): d[s] = d.get(s, i) s = (s+num) % k if k else s+num if s in d and d[s] \u003c i: return True return False 时间复杂度 O(N)，44 ms ","date":"2016-06-06","objectID":"/leetcode/0523/:3:0","tags":null,"title":"0523：连续的子数组和（★）","uri":"/leetcode/0523/"},{"categories":null,"content":" 力扣第 520 题 ","date":"2016-06-03","objectID":"/leetcode/0520/:0:0","tags":null,"title":"0520：检测大写字母","uri":"/leetcode/0520/"},{"categories":null,"content":"题目 我们定义，在以下情况时，单词的大写用法是正确的： 全部字母都是大写，比如 \"USA\" 。\r单词中所有字母都不是大写，比如 \"leetcode\" 。\r如果单词不只含有一个字母，只有首字母大写， 比如 \"Google\" 。\r给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。 示例 1： 输入：word = \"USA\"\r输出：true\r示例 2： 输入：word = \"FlaG\"\r输出：false\r提示： 1 \u003c= word.length \u003c= 100\rword 由小写和大写英文字母组成\r","date":"2016-06-03","objectID":"/leetcode/0520/:1:0","tags":null,"title":"0520：检测大写字母","uri":"/leetcode/0520/"},{"categories":null,"content":"分析 可以直接调包。 def detectCapitalUse(self, word: str) -\u003e bool: return word.isupper() or word.islower() or word.istitle() 40 ms 也可以用正则。 ","date":"2016-06-03","objectID":"/leetcode/0520/:2:0","tags":null,"title":"0520：检测大写字母","uri":"/leetcode/0520/"},{"categories":null,"content":"解答 def detectCapitalUse(self, word: str) -\u003e bool: return bool(re.match('^([A-Z]*|[a-z]*|[A-Z][a-z]*)$', word)) 36 ms ","date":"2016-06-03","objectID":"/leetcode/0520/:3:0","tags":null,"title":"0520：检测大写字母","uri":"/leetcode/0520/"},{"categories":null,"content":" 力扣第 519 题 ","date":"2016-06-02","objectID":"/leetcode/0519/:0:0","tags":null,"title":"0519：随机翻转矩阵（★）","uri":"/leetcode/0519/"},{"categories":null,"content":"题目 给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。 尽量最少调用内置的随机函数，并且优化时间和空间复杂度。 实现 Solution 类： Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象\rint[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 ","date":"2016-06-02","objectID":"/leetcode/0519/:1:0","tags":null,"title":"0519：随机翻转矩阵（★）","uri":"/leetcode/0519/"},{"categories":null,"content":"分析 ","date":"2016-06-02","objectID":"/leetcode/0519/:2:0","tags":null,"title":"0519：随机翻转矩阵（★）","uri":"/leetcode/0519/"},{"categories":null,"content":"#1 调用次数最多 1000，所以可以考虑暴力法。维护值为 1 的下标集合，每轮拒绝采样即可。 class Solution: def __init__(self, m: int, n: int): self.m = m self.n = n self.vis = set() def flip(self) -\u003e List[int]: while True: i = random.randint(0, self.m-1) j = random.randint(0, self.n-1) if (i, j) not in self.vis: self.vis.add((i, j)) return [","date":"2016-06-02","objectID":"/leetcode/0519/:2:1","tags":null,"title":"0519：随机翻转矩阵（★）","uri":"/leetcode/0519/"},{"categories":null,"content":"#2 还有个巧妙的方法是类似 0710，将返回过的下标映射为连续区间，从而方便随机。 具体来说： 设数组 A=list(range(m*n))，将 (i, j) 看作是 A 的下标 i*n+j\r设已经选过了 cnt 个下标，并且都交换到了 A[:cnt]\r用哈希表 d 维护 A[cnt:] 中经过了交换的数\r那么调用 flip 时\r随机一个 \u003e=cnt 的下标 y，A[y]=d.get(y,y)，转回二维坐标 (i,j) 即是结果\r更新 d[y] = d.get(cnt, cnt)，代表 A[y] 和 A[cnt] 进行了交换\r","date":"2016-06-02","objectID":"/leetcode/0519/:2:2","tags":null,"title":"0519：随机翻转矩阵（★）","uri":"/leetcode/0519/"},{"categories":null,"content":"解答 class Solution: def __init__(self, m: int, n: int): self.m = m self.n = n self.cnt = 0 self.d = {} def flip(self) -\u003e List[int]: y = random.randint(self.cnt, self.m*self.n-1) x = self.d.get(y, y) self.d[y] = self.d.get(self.cnt, self.cnt) self.cnt += 1 return [x // self.n, x % self.n] def reset(se","date":"2016-06-02","objectID":"/leetcode/0519/:3:0","tags":null,"title":"0519：随机翻转矩阵（★）","uri":"/leetcode/0519/"},{"categories":null,"content":" 力扣第 518 题 ","date":"2016-06-01","objectID":"/leetcode/0518/:0:0","tags":null,"title":"0518：零钱兑换 II（★）","uri":"/leetcode/0518/"},{"categories":null,"content":"题目 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 示例 1： 输入：amount = 5, coins = [1, 2, 5]\r输出：4\r解释：有四种方式可以凑成总金额：\r5=5\r5=2+2+1\r5=2+1+1+1\r5=1+1+1+1+1\r示例 2： 输入：amount = 3, coins = [2]\r输出：0\r解释：只用面额 2 的硬币不能凑成总金额 3 。\r示例 3： 输入：a","date":"2016-06-01","objectID":"/leetcode/0518/:1:0","tags":null,"title":"0518：零钱兑换 II（★）","uri":"/leetcode/0518/"},{"categories":null,"content":"分析 ","date":"2016-06-01","objectID":"/leetcode/0518/:2:0","tags":null,"title":"0518：零钱兑换 II（★）","uri":"/leetcode/0518/"},{"categories":null,"content":"#1 将硬币组合按升序排列，只要排列不同，就是不同的组合。 那么总金额 amount 的组合有两种可能： 最后一个硬币是 coins[-1]，转为 (amount-coins[-1], coins) 的子问题 最后一个硬币不是 coins[-1]，转为 (amount, coins[:-1]) 的子问题 因此，令 dfs(i, j) 代表总金额 j 由 coins[:i+1] 组成的种数，即可递归。 def change(self, amount: int, coins: List[int]) -\u003e int: @lru_cache(None) def dfs(i, j): if i\u003c0 or ","date":"2016-06-01","objectID":"/leetcode/0518/:2:1","tags":null,"title":"0518：零钱兑换 II（★）","uri":"/leetcode/0518/"},{"categories":null,"content":"#2 可以改写成非递归形式，递推式为： dp[i][j]=dp[i][j-coins[i]]+dp[i-1][j]\r注意到 dp[i][j] 依赖的是 dp[i-1][j]，可以直接优化为一维数组。 这是典型的完全背包问题 ","date":"2016-06-01","objectID":"/leetcode/0518/:2:2","tags":null,"title":"0518：零钱兑换 II（★）","uri":"/leetcode/0518/"},{"categories":null,"content":"解答 def change(self, amount: int, coins: List[int]) -\u003e int: dp = [1]+[0]*amount for coin in coins: for j in range(coin, amount+1): dp[j] += dp[j-coin] return dp[-1] 116 ms ","date":"2016-06-01","objectID":"/leetcode/0518/:3:0","tags":null,"title":"0518：零钱兑换 II（★）","uri":"/leetcode/0518/"},{"categories":null,"content":" 力扣第 516 题 ","date":"2016-05-30","objectID":"/leetcode/0516/:0:0","tags":null,"title":"0516：最长回文子序列（★）","uri":"/leetcode/0516/"},{"categories":null,"content":"题目 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 输入：s = \"bbbab\"\r输出：4\r解释：一个可能的最长回文子序列为 \"bbbb\" 。\r示例 2： 输入：s = \"cbbd\"\r输出：2\r解释：一个可能的最长回文子序列为 \"bb\" 。\r提示： 1 \u003c= s.length \u003c= 1000\rs 仅由小写英文字母组成\r","date":"2016-05-30","objectID":"/leetcode/0516/:1:0","tags":null,"title":"0516：最长回文子序列（★）","uri":"/leetcode/0516/"},{"categories":null,"content":"分析 显然当 s[0]==s[-1] 时，可以转为子问题。当 s[0]!=s[-1] 时，发现也可以转为两个子问题。 因此令 dfs(i, j) 代表 s[i:j+1] 的最长回文子序列的长度，即可递归。 这是典型的区间 dp。 ","date":"2016-05-30","objectID":"/leetcode/0516/:2:0","tags":null,"title":"0516：最长回文子序列（★）","uri":"/leetcode/0516/"},{"categories":null,"content":"解答 def longestPalindromeSubseq(self, s: str) -\u003e int: @lru_cache(None) def dfs(i, j): if i\u003e=j: return j-i+1 if s[i]==s[j]: return 2+dfs(i+1, j-1) return max(dfs(i+1, j), dfs(i, j-1)) return dfs(0, len(s)-1) 时间复杂度 O(N^2)，852 ms ","date":"2016-05-30","objectID":"/leetcode/0516/:3:0","tags":null,"title":"0516：最长回文子序列（★）","uri":"/leetcode/0516/"},{"categories":null,"content":" 力扣第 515 题 ","date":"2016-05-29","objectID":"/leetcode/0515/:0:0","tags":null,"title":"0515：在每个树行中找最大值（★）","uri":"/leetcode/0515/"},{"categories":null,"content":"题目 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 示例1： 输入: root = [1,3,2,5,3,null,9]\r输出: [1,3,9]\r示例2： 输入: root = [1,2,3]\r输出: [1,3]\r提示： 二叉树的节点个数的范围是 [0,104]\r-231 \u003c= Node.val \u003c= 231 - 1\r","date":"2016-05-29","objectID":"/leetcode/0515/:1:0","tags":null,"title":"0515：在每个树行中找最大值（★）","uri":"/leetcode/0515/"},{"categories":null,"content":"分析 层序遍历并取最大值即可。 ","date":"2016-05-29","objectID":"/leetcode/0515/:2:0","tags":null,"title":"0515：在每个树行中找最大值（★）","uri":"/leetcode/0515/"},{"categories":null,"content":"解答 def largestValues(self, root: TreeNode) -\u003e List[int]: res, level = [], [root] if root else [] while level: res.append(max(node.val for node in level)) level = [child for node in level for child in [node.left, node.right] if child] return res 60 ms ","date":"2016-05-29","objectID":"/leetcode/0515/:3:0","tags":null,"title":"0515：在每个树行中找最大值（★）","uri":"/leetcode/0515/"},{"categories":null,"content":" 力扣第 514 题 ","date":"2016-05-28","objectID":"/leetcode/0514/:0:0","tags":null,"title":"0514：自由之路（★★）","uri":"/leetcode/0514/"},{"categories":null,"content":"题目 电子游戏“辐射4”中，任务 “通向自由” 要求玩家到达名为 “Freedom Trail Ring” 的金属表盘，并使用表盘拼写特定关键词才能开门。 给定一个字符串 ring ，表示刻在外环上的编码；给定另一个字符串 key ，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。 最初，ring 的第一个字符与 12:00 方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。 旋转 ring 拼出 key 字符 key[i] 的阶段中： 您可以将 ring 顺时针或逆时针旋","date":"2016-05-28","objectID":"/leetcode/0514/:1:0","tags":null,"title":"0514：自由之路（★★）","uri":"/leetcode/0514/"},{"categories":null,"content":"分析 先按顺/逆时针找到第一个 key[0] 后，可以转为递归子问题。 那么令 dfs(i, j) 代表当 ring[i] 对齐北方时，拼写 key[j:] 的最少步数，即可递推。 要找与 ring[i] 最近的 key[j] 位置，考虑保存 ring 中每个字符的位置列表（递增的）， 然后可以二分查找离 i 最近的某字符位置，节省时间。 ","date":"2016-05-28","objectID":"/leetcode/0514/:2:0","tags":null,"title":"0514：自由之路（★★）","uri":"/leetcode/0514/"},{"categories":null,"content":"解答 def findRotateSteps(self, ring: str, key: str) -\u003e int: @lru_cache(None) def dfs(i, j): if j == len(key): return 0 A = d[key[j]] pos = bisect_left(A, i) left, right = A[pos-1], A[pos % len(A)] return 1+min((i-left)%n+dfs(left, j+1), (right-i)%n+dfs(right, j+1)) d, n = defaultdict(list), len(ring) ","date":"2016-05-28","objectID":"/leetcode/0514/:3:0","tags":null,"title":"0514：自由之路（★★）","uri":"/leetcode/0514/"},{"categories":null,"content":" 力扣第 513 题 ","date":"2016-05-27","objectID":"/leetcode/0513/:0:0","tags":null,"title":"0513：找树左下角的值（★）","uri":"/leetcode/0513/"},{"categories":null,"content":"题目 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 输入: root = [2,1,3]\r输出: 1\r示例 2: 输入: [1,2,3,4,null,5,6,null,null,7]\r输出: 7\r提示: 二叉树的节点个数的范围是 [1,104]\r-231 \u003c= Node.val \u003c= 231 - 1 ","date":"2016-05-27","objectID":"/leetcode/0513/:1:0","tags":null,"title":"0513：找树左下角的值（★）","uri":"/leetcode/0513/"},{"categories":null,"content":"分析 层序遍历并维护最左边的数即可。 ","date":"2016-05-27","objectID":"/leetcode/0513/:2:0","tags":null,"title":"0513：找树左下角的值（★）","uri":"/leetcode/0513/"},{"categories":null,"content":"解答 def findBottomLeftValue(self, root: TreeNode) -\u003e int: res, level = None, [root] while level: res = level[0].val level = [child for node in level for child in [node.left, node.right] if child] return res 44 ms ","date":"2016-05-27","objectID":"/leetcode/0513/:3:0","tags":null,"title":"0513：找树左下角的值（★）","uri":"/leetcode/0513/"},{"categories":null,"content":" 力扣第 508 题 ","date":"2016-05-22","objectID":"/leetcode/0508/:0:0","tags":null,"title":"0508：出现次数最多的子树元素和（★）","uri":"/leetcode/0508/"},{"categories":null,"content":"题目 给你一个二叉树的根结点 root ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。 一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。 示例 1： 输入: root = [5,2,-3]\r输出: [2,-3,4]\r示例 2： 输入: root = [5,2,-5]\r输出: [2]\r提示: 节点数在 [1, 104] 范围内\r-105 \u003c= Node.val \u003c= 105\r","date":"2016-05-22","objectID":"/leetcode/0508/:1:0","tags":null,"title":"0508：出现次数最多的子树元素和（★）","uri":"/leetcode/0508/"},{"categories":null,"content":"分析 统计所有的子树元素和即可。计算根节点的递归过程中就可以完成统计了。 ","date":"2016-05-22","objectID":"/leetcode/0508/:2:0","tags":null,"title":"0508：出现次数最多的子树元素和（★）","uri":"/leetcode/0508/"},{"categories":null,"content":"解答 def findFrequentTreeSum(self, root: TreeNode) -\u003e List[int]: def help(root): if not root: return 0 key = root.val + help(root.left) + help(root.right) ct[key] += 1 return key ct = Counter() help(root) M = max(ct.values()) return [key for key in ct if ct[key] == M] 64 ms ","date":"2016-05-22","objectID":"/leetcode/0508/:3:0","tags":null,"title":"0508：出现次数最多的子树元素和（★）","uri":"/leetcode/0508/"},{"categories":null,"content":" 力扣第 507 题 ","date":"2016-05-21","objectID":"/leetcode/0507/:0:0","tags":null,"title":"0507：完美数","uri":"/leetcode/0507/"},{"categories":null,"content":"题目 对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。 给定一个 整数 n， 如果是完美数，返回 true；否则返回 false。 示例 1： 输入：num = 28\r输出：true\r解释：28 = 1 + 2 + 4 + 7 + 14\r1, 2, 4, 7, 和 14 是 28 的所有正因子。\r示例 2： 输入：num = 7\r输出：false\r提示： 1 \u003c= num \u003c= 108\r","date":"2016-05-21","objectID":"/leetcode/0507/:1:0","tags":null,"title":"0507：完美数","uri":"/leetcode/0507/"},{"categories":null,"content":"分析 ","date":"2016-05-21","objectID":"/leetcode/0507/:2:0","tags":null,"title":"0507：完美数","uri":"/leetcode/0507/"},{"categories":null,"content":"#1 遍历拿到因子即可。注意到除了完全平方数的根以外，因子都是成对出现的，因此只需遍历到 int(sqrt(num))。 def checkPerfectNumber(self, num: int) -\u003e bool: x = int(sqrt(num)) s = 1 + sum(i+num//i for i in range(2, x+1) if num%i==0) s -= x if x*x==num else 0 return s == num 56 ms ","date":"2016-05-21","objectID":"/leetcode/0507/:2:1","tags":null,"title":"0507：完美数","uri":"/leetcode/0507/"},{"categories":null,"content":"#2 完美数很少，根据计算在 32 位以内的完美数只有 5 个，因此可以直接判断。 ","date":"2016-05-21","objectID":"/leetcode/0507/:2:2","tags":null,"title":"0507：完美数","uri":"/leetcode/0507/"},{"categories":null,"content":"解答 def checkPerfectNumber(self, num: int) -\u003e bool: return num in [6, 28, 496, 8128, 33550336] 36 ms ","date":"2016-05-21","objectID":"/leetcode/0507/:3:0","tags":null,"title":"0507：完美数","uri":"/leetcode/0507/"},{"categories":null,"content":" 力扣第 506 题 ","date":"2016-05-20","objectID":"/leetcode/0506/:0:0","tags":null,"title":"0506：相对名次","uri":"/leetcode/0506/"},{"categories":null,"content":"题目 给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。 运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况： 名次第 1 的运动员获金牌 \"Gold Medal\" 。\r名次第 2 的运动员获银牌 \"Silver Medal\" 。\r名次第 3 的运动员获铜牌 \"Bronze Medal\" 。\r从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 \"x\"）。\r使用长度为 n 的数组 answ","date":"2016-05-20","objectID":"/leetcode/0506/:1:0","tags":null,"title":"0506：相对名次","uri":"/leetcode/0506/"},{"categories":null,"content":"分析 先排序得到每个分数对应的名次，然后遍历 score 替换为名次即可。 ","date":"2016-05-20","objectID":"/leetcode/0506/:2:0","tags":null,"title":"0506：相对名次","uri":"/leetcode/0506/"},{"categories":null,"content":"解答 def findRelativeRanks(self, score: List[int]) -\u003e List[str]: medals = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"] d = {x: str(i+1) if i \u003e 2 else medals[i] for i, x in enumerate(sorted(score, reverse=True))} return [d[x] for x in score] 40 ms ","date":"2016-05-20","objectID":"/leetcode/0506/:3:0","tags":null,"title":"0506：相对名次","uri":"/leetcode/0506/"},{"categories":null,"content":" 力扣第 503 题 ","date":"2016-05-17","objectID":"/leetcode/0503/:0:0","tags":null,"title":"0503：下一个更大元素 II（★）","uri":"/leetcode/0503/"},{"categories":null,"content":"题目 给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。 数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。 示例 1: 输入: nums = [1,2,1]\r输出: [2,-1,2]\r解释: 第一个 1 的下一个更大的数是 2；\r数字 2 找不到下一个更大的数；\r第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\r示例 2: 输入: nums = [1,2,3,4,3]\r输","date":"2016-05-17","objectID":"/leetcode/0503/:1:0","tags":null,"title":"0503：下一个更大元素 II（★）","uri":"/leetcode/0503/"},{"categories":null,"content":"分析 ","date":"2016-05-17","objectID":"/leetcode/0503/:2:0","tags":null,"title":"0503：下一个更大元素 II（★）","uri":"/leetcode/0503/"},{"categories":null,"content":"#1 类似 0739 ，只不过可以循环搜索了。因此要遍历两趟。 def nextGreaterElements(self, nums: List[int]) -\u003e List[int]: n = len(nums) res, stack = [-1]*n, [] for i in range(n): while stack and nums[stack[-1]] \u003c nums[i]: res[stack.pop()] = nums[i] stack.append(i) for i in range(n-1): while stack and nums[stack[-1]] \u003c nums[i]: ","date":"2016-05-17","objectID":"/leetcode/0503/:2:1","tags":null,"title":"0503：下一个更大元素 II（★）","uri":"/leetcode/0503/"},{"categories":null,"content":"#2 可以利用模运算简化代码。 ","date":"2016-05-17","objectID":"/leetcode/0503/:2:2","tags":null,"title":"0503：下一个更大元素 II（★）","uri":"/leetcode/0503/"},{"categories":null,"content":"解答 def nextGreaterElements(self, nums: List[int]) -\u003e List[int]: n = len(nums) res, stack = [-1]*n, [] for i in range(2*n-1): i %= n while stack and nums[stack[-1]] \u003c nums[i]: res[stack.pop()] = nums[i] stack.append(i) return res 220 ms ","date":"2016-05-17","objectID":"/leetcode/0503/:3:0","tags":null,"title":"0503：下一个更大元素 II（★）","uri":"/leetcode/0503/"},{"categories":null,"content":" 力扣第 502 题 ","date":"2016-05-16","objectID":"/leetcode/0502/:0:0","tags":null,"title":"0502：IPO（★★）","uri":"/leetcode/0502/"},{"categories":null,"content":"题目 假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。 给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。 最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。 总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得","date":"2016-05-16","objectID":"/leetcode/0502/:1:0","tags":null,"title":"0502：IPO（★★）","uri":"/leetcode/0502/"},{"categories":null,"content":"分析 ","date":"2016-05-16","objectID":"/leetcode/0502/:2:0","tags":null,"title":"0502：IPO（★★）","uri":"/leetcode/0502/"},{"categories":null,"content":"#1 典型的堆应用，用大顶堆维护能启动的项目，每轮选择堆顶即利润最大的项目，更新资本即可。 def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -\u003e int: A = deque(sorted([c, p] for c, p in zip(capital, profits))) res, pq = w, [] for _ in range(k): while A and A[0][0] \u003c= res: heappush(pq, -A.popleft()[1]) if not","date":"2016-05-16","objectID":"/leetcode/0502/:2:1","tags":null,"title":"0502：IPO（★★）","uri":"/leetcode/0502/"},{"categories":null,"content":"#2 如果初始资本 W 已经大于等于 max(capital)，显然选择利润最大的 k 个项目即可。 这个 trick 能明显提升时间。 ","date":"2016-05-16","objectID":"/leetcode/0502/:2:2","tags":null,"title":"0502：IPO（★★）","uri":"/leetcode/0502/"},{"categories":null,"content":"解答 def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -\u003e int: if w \u003e max(capital): return w + sum(nlargest(k, profits)) A = deque(sorted([c, p] for c, p in zip(capital, profits))) res, pq = w, [] for _ in range(k): while A and A[0][0] \u003c= res: heappush(pq, -A.pople","date":"2016-05-16","objectID":"/leetcode/0502/:3:0","tags":null,"title":"0502：IPO（★★）","uri":"/leetcode/0502/"},{"categories":null,"content":" 力扣第 501 题 ","date":"2016-05-15","objectID":"/leetcode/0501/:0:0","tags":null,"title":"0501：二叉搜索树中的众数","uri":"/leetcode/0501/"},{"categories":null,"content":"题目 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 假定 BST 满足如下定义： 结点左子树中所含节点的值 小于等于 当前节点的值\r结点右子树中所含节点的值 大于等于 当前节点的值\r左子树和右子树都是二叉搜索树\r示例 1： 输入：root = [1,null,2,2]\r输出：[2]\r示例 2： 输入：root = [0]\r输出：[0]\r提示： 树中节点的数目在范围 [1, 104] 内\r-105 \u003c= Node.val \u003c= 105\r进阶：你可以不使用额外的空间吗？（","date":"2016-05-15","objectID":"/leetcode/0501/:1:0","tags":null,"title":"0501：二叉搜索树中的众数","uri":"/leetcode/0501/"},{"categories":null,"content":"分析 最简单的就是遍历得到数组，再求众数。 要求不用额外空间，可以按中序遍历，相同元素必然相邻，因此维护当前元素的频次，更新结果即可。 ","date":"2016-05-15","objectID":"/leetcode/0501/:2:0","tags":null,"title":"0501：二叉搜索树中的众数","uri":"/leetcode/0501/"},{"categories":null,"content":"解答 def findMode(self, root: TreeNode) -\u003e List[int]: res, maxcnt = [], 0 stack, pre, cnt = [root], None, 0 while stack: node = stack.pop() if isinstance(node, int): cnt, pre = cnt*(node==pre)+1, node if cnt \u003e= maxcnt: res, maxcnt = res*(cnt==maxcnt)+[node], cnt elif node: stack.extend([node.right, no","date":"2016-05-15","objectID":"/leetcode/0501/:3:0","tags":null,"title":"0501：二叉搜索树中的众数","uri":"/leetcode/0501/"},{"categories":null,"content":" 力扣第 500 题 ","date":"2016-05-14","objectID":"/leetcode/0500/:0:0","tags":null,"title":"0500：键盘行","uri":"/leetcode/0500/"},{"categories":null,"content":"题目 给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。 美式键盘 中： 第一行由字符 \"qwertyuiop\" 组成。 第二行由字符 \"asdfghjkl\" 组成。 第三行由字符 \"zxcvbnm\" 组成。 示例 1： 输入：words = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"] 输出：[\"Alaska\",\"Dad\"] 示例 2： 输入：words = [\"omk\"] 输出：[] 示例 3： 输入：words = [\"adsdf\",\"sfd\"] 输出：[\"adsdf\",\"sfd\"] 提示： 1 \u003c= words","date":"2016-05-14","objectID":"/leetcode/0500/:1:0","tags":null,"title":"0500：键盘行","uri":"/leetcode/0500/"},{"categories":null,"content":"分析 遍历判断每个单词的字符集合是否是某一行的子集即可。 注意单词可能有大写，要先全转为小写。 ","date":"2016-05-14","objectID":"/leetcode/0500/:2:0","tags":null,"title":"0500：键盘行","uri":"/leetcode/0500/"},{"categories":null,"content":"解答 def findWords(self, words: List[str]) -\u003e List[str]: return [word for word in words if any(set(word.lower()) \u003c= set(s) for s in [\"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\"])] 32 ms ","date":"2016-05-14","objectID":"/leetcode/0500/:3:0","tags":null,"title":"0500：键盘行","uri":"/leetcode/0500/"},{"categories":null,"content":" 力扣第 498 题 ","date":"2016-05-12","objectID":"/leetcode/0498/:0:0","tags":null,"title":"0498：对角线遍历（★）","uri":"/leetcode/0498/"},{"categories":null,"content":"题目 给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。 示例 1： 输入：mat = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,4,7,5,3,6,8,9] 示例 2： 输入：mat = [[1,2],[3,4]] 输出：[1,2,3,4] 提示： m == mat.length n == mat[i].length 1 \u003c= m, n \u003c= 104 1 \u003c= m * n \u003c= 104 -105 \u003c= mat[i][j] \u003c= 105 ","date":"2016-05-12","objectID":"/leetcode/0498/:1:0","tags":null,"title":"0498：对角线遍历（★）","uri":"/leetcode/0498/"},{"categories":null,"content":"分析 ","date":"2016-05-12","objectID":"/leetcode/0498/:2:0","tags":null,"title":"0498：对角线遍历（★）","uri":"/leetcode/0498/"},{"categories":null,"content":"#1 最简单的就是先保存每一条对角线的列表，然后再拼接，注意第偶数条对角线反转即可。 每条对角线中的元素行列坐标之和相等，因此遍历时将 (i, j) 位置的元素添加到 i+j 对应的对角线即可。 def findDiagonalOrder(self, matrix: List[List[int]]) -\u003e List[int]: m, n = len(matrix), len(matrix) and len(matrix[0]) tmp = [[] for _ in range(m+n-1)] for i in range(m): for j in range(n): tmp[i+j].appe","date":"2016-05-12","objectID":"/leetcode/0498/:2:1","tags":null,"title":"0498：对角线遍历（★）","uri":"/leetcode/0498/"},{"categories":null,"content":"#2 也可以直接按对角线遍历。注意边界范围，第偶数条对角线反着遍历。 ","date":"2016-05-12","objectID":"/leetcode/0498/:2:2","tags":null,"title":"0498：对角线遍历（★）","uri":"/leetcode/0498/"},{"categories":null,"content":"解答 def findDiagonalOrder(self, matrix: List[List[int]]) -\u003e List[int]: res, m, n = [], len(matrix), len(matrix) and len(matrix[0]) for k in range(m+n-1): start, end = max(0, k-n+1), min(k, m-1) span = range(start, end+1) if k%2 else range(end, start-1, -1) res.extend(matrix[i][k-i] for i in span) ret","date":"2016-05-12","objectID":"/leetcode/0498/:3:0","tags":null,"title":"0498：对角线遍历（★）","uri":"/leetcode/0498/"},{"categories":null,"content":" 力扣第 497 题 ","date":"2016-05-11","objectID":"/leetcode/0497/:0:0","tags":null,"title":"0497：非重叠矩形中的随机点（★）","uri":"/leetcode/0497/"},{"categories":null,"content":"题目 给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点，(xi, yi) 是第 i 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。 在给定的矩形覆盖的空间内的任何整数点都有可能被返回。 请注意 ，整数点是具有整数坐标的点。 实现 Solution 类: Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。 int[] pick() 返回一个随机的整数点 [","date":"2016-05-11","objectID":"/leetcode/0497/:1:0","tags":null,"title":"0497：非重叠矩形中的随机点（★）","uri":"/leetcode/0497/"},{"categories":null,"content":"分析 类似 0528 ，不过变成了二维。 矩阵内点的个数即是矩阵权重。 随机取到一个点后，先找出属于哪一个矩形，还可以得到在该矩形中排第几位，再按预定映射得到该矩形中的某一点。 ","date":"2016-05-11","objectID":"/leetcode/0497/:2:0","tags":null,"title":"0497：非重叠矩形中的随机点（★）","uri":"/leetcode/0497/"},{"categories":null,"content":"解答 class Solution: def __init__(self, rects: List[List[int]]): self.rects = rects self.pre = list(accumulate((x2-x1+1)*(y2-y1+1) for x1,y1,x2,y2 in rects)) def pick(self) -\u003e List[int]: rank = random.randint(1, self.pre[-1]) i = bisect_left(self.pre, rank) rank -= self.pre[i-1] if i else 0 x1, y1, x2","date":"2016-05-11","objectID":"/leetcode/0497/:3:0","tags":null,"title":"0497：非重叠矩形中的随机点（★）","uri":"/leetcode/0497/"},{"categories":null,"content":" 力扣第 496 题 ","date":"2016-05-10","objectID":"/leetcode/0496/:0:0","tags":null,"title":"0496：下一个更大元素 I","uri":"/leetcode/0496/"},{"categories":null,"content":"题目 nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。 对于每个 0 \u003c= i \u003c nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。 返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 ","date":"2016-05-10","objectID":"/leetcode/0496/:1:0","tags":null,"title":"0496：下一个更大元素 I","uri":"/leetcode/0496/"},{"categories":null,"content":"分析 类似 0739 ，采用单调栈即可得到 nums2 中每个元素的下一个更大元素，保存在哈希表中。 然后 nums1 的每个元素直接调用哈希表即可。 ","date":"2016-05-10","objectID":"/leetcode/0496/:2:0","tags":null,"title":"0496：下一个更大元素 I","uri":"/leetcode/0496/"},{"categories":null,"content":"解答 def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -\u003e List[int]: nxt, stack = {}, [] for num in nums2: while stack and stack[-1] \u003c num: nxt[stack.pop()] = num stack.append(num) return [nxt.get(num, -1) for num in nums1] 32 ms ","date":"2016-05-10","objectID":"/leetcode/0496/:3:0","tags":null,"title":"0496：下一个更大元素 I","uri":"/leetcode/0496/"},{"categories":null,"content":" 力扣第 495 题 ","date":"2016-05-09","objectID":"/leetcode/0495/:0:0","tags":null,"title":"0495：提莫攻击","uri":"/leetcode/0495/"},{"categories":null,"content":"题目 在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。 当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。 正式地讲，提莫在 t 发起攻击意味着艾希在时间区间 [t, t + duration - 1]（含 t 和 t + duration - 1）处于中毒状态。如果提莫在中毒影响结束 前 再次攻击，中毒状态计时器将会 重置 ，在新的攻击之后，中毒影响将会在 duration 秒后结束。 给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在 timeSeries[i] 秒时","date":"2016-05-09","objectID":"/leetcode/0495/:1:0","tags":null,"title":"0495：提莫攻击","uri":"/leetcode/0495/"},{"categories":null,"content":"分析 为了方便，用 T 代表 timeSeries。遍历位置 i，如果 T[i+1] - T[i] \u003e= duration，那么 T[i] 时的攻击造成了 duration 秒的中毒状态。 否则，到 T[i+1] 时，状态重置，所以 T[i] 时的攻击只造成了 T[i+1] - T[i] 秒的中毒状态。 再注意下边界条件即可。 ","date":"2016-05-09","objectID":"/leetcode/0495/:2:0","tags":null,"title":"0495：提莫攻击","uri":"/leetcode/0495/"},{"categories":null,"content":"解答 def findPoisonedDuration(self, timeSeries: List[int], duration: int) -\u003e int: T, n = timeSeries, len(timeSeries) return sum(min(T[i+1]-T[i], duration) for i in range(n-1)) + duration if T else 0 264 ms ","date":"2016-05-09","objectID":"/leetcode/0495/:3:0","tags":null,"title":"0495：提莫攻击","uri":"/leetcode/0495/"},{"categories":null,"content":" 力扣第 494 题 ","date":"2016-05-08","objectID":"/leetcode/0494/:0:0","tags":null,"title":"0494：目标和（★）","uri":"/leetcode/0494/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \"+2-1\" 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 ","date":"2016-05-08","objectID":"/leetcode/0494/:1:0","tags":null,"title":"0494：目标和（★）","uri":"/leetcode/0494/"},{"categories":null,"content":"分析 注意到 sum(nums)\u003c=1000，因此考虑直接递推表达式的和与对应的个数。 令 dp[i] 代表 nums[:i] 得到的计数器，key 为表达式的和，即可递推。 ","date":"2016-05-08","objectID":"/leetcode/0494/:2:0","tags":null,"title":"0494：目标和（★）","uri":"/leetcode/0494/"},{"categories":null,"content":"解答 def findTargetSumWays(self, nums: List[int], target: int) -\u003e int: ct = Counter({0: 1}) for num in nums: ct2 = Counter() for k in ct: ct2[k+num] += ct[k] ct2[k-num] += ct[k] ct = ct2 return ct[target] 260 ms ","date":"2016-05-08","objectID":"/leetcode/0494/:3:0","tags":null,"title":"0494：目标和（★）","uri":"/leetcode/0494/"},{"categories":null,"content":" 力扣第 493 题 ","date":"2016-05-07","objectID":"/leetcode/0493/:0:0","tags":null,"title":"0493：翻转对（★★）","uri":"/leetcode/0493/"},{"categories":null,"content":"题目 给定一个数组 nums ，如果 i \u003c j 且 nums[i] \u003e 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。 你需要返回给定数组中的重要翻转对的数量。 示例 1: 输入: [1,3,2,3,1] 输出: 2 示例 2: 输入: [2,4,3,5,1] 输出: 3 注意: 给定数组的长度不会超过50000。 输入数组中的所有数字都在32位整数的表示范围内。 ","date":"2016-05-07","objectID":"/leetcode/0493/:1:0","tags":null,"title":"0493：翻转对（★★）","uri":"/leetcode/0493/"},{"categories":null,"content":"分析 遍历 j，找 nums[:j] 中大于 2*nums[j] 的个数。容易想到用有序集合维护 nums[:j]，然后二分查找即可。 ","date":"2016-05-07","objectID":"/leetcode/0493/:2:0","tags":null,"title":"0493：翻转对（★★）","uri":"/leetcode/0493/"},{"categories":null,"content":"解答 def reversePairs(self, nums: List[int]) -\u003e int: from sortedcontainers import SortedList res, sl = 0, SortedList() for num in nums: res += len(sl)-sl.bisect_right(num*2) sl.add(num) return res 832 ms ","date":"2016-05-07","objectID":"/leetcode/0493/:3:0","tags":null,"title":"0493：翻转对（★★）","uri":"/leetcode/0493/"},{"categories":null,"content":" 力扣第 486 题 ","date":"2016-04-30","objectID":"/leetcode/0486/:0:0","tags":null,"title":"0486：预测赢家（★）","uri":"/leetcode/0486/"},{"categories":null,"content":"题目 给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。 玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]），取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。 如果玩家 1 能成为赢家，返回 true 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true 。你可以假设每个玩家的玩法都会使他的分数最大化。 示例 1： 输入","date":"2016-04-30","objectID":"/leetcode/0486/:1:0","tags":null,"title":"0486：预测赢家（★）","uri":"/leetcode/0486/"},{"categories":null,"content":"分析 博弈问题容易想到用递归。 考虑令 dfs(i, j) 表示用 nums[i:j+1] 玩游戏得到的玩家 1 和 2 的分数差，即可递归。 ","date":"2016-04-30","objectID":"/leetcode/0486/:2:0","tags":null,"title":"0486：预测赢家（★）","uri":"/leetcode/0486/"},{"categories":null,"content":"解答 def PredictTheWinner(self, nums: List[int]) -\u003e bool: @lru_cache(None) def dfs(i, j): if i\u003ej: return 0 return max(nums[i]-dfs(i+1, j), nums[j]-dfs(i, j-1)) return dfs(0, len(nums)-1)\u003e=0 40 ms ","date":"2016-04-30","objectID":"/leetcode/0486/:3:0","tags":null,"title":"0486：预测赢家（★）","uri":"/leetcode/0486/"},{"categories":null,"content":" 力扣第 485 题 ","date":"2016-04-29","objectID":"/leetcode/0485/:0:0","tags":null,"title":"0485：最大连续 1 的个数","uri":"/leetcode/0485/"},{"categories":null,"content":"题目 给定一个二进制数组 nums ， 计算其中最大连续 1 的个数。 示例 1： 输入：nums = [1,1,0,1,1,1] 输出：3 解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3. 示例 2: 输入：nums = [1,0,1,1,0,1] 输出：2 提示： 1 \u003c= nums.length \u003c= 105 nums[i] 不是 0 就是 1. ","date":"2016-04-29","objectID":"/leetcode/0485/:1:0","tags":null,"title":"0485：最大连续 1 的个数","uri":"/leetcode/0485/"},{"categories":null,"content":"分析 遍历计数，遇到 0 重新开始计数即可。 ","date":"2016-04-29","objectID":"/leetcode/0485/:2:0","tags":null,"title":"0485：最大连续 1 的个数","uri":"/leetcode/0485/"},{"categories":null,"content":"解答 def findMaxConsecutiveOnes(self, nums: List[int]) -\u003e int: res, cnt = 0, 0 for num in nums: cnt = cnt + 1 if num else 0 res = max(res, cnt) return res 104 ms ","date":"2016-04-29","objectID":"/leetcode/0485/:3:0","tags":null,"title":"0485：最大连续 1 的个数","uri":"/leetcode/0485/"},{"categories":null,"content":"《ISLAND》是Frontwing制作的冒险电脑游戏，Frontwing15周年纪念作品。故事穿插着各种各样的关键词，通过巧妙的伏笔，“世界的秘密”一点点揭晓。","date":"2016-04-28","objectID":"/game/island/","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":"简介 《ISLAND》是Frontwing制作的冒险电脑游戏，Frontwing15周年纪念作品。 故事穿插着各种各样的关键词，通过巧妙的伏笔， “世界的秘密”一点点揭晓。 制作人员： 开发：前翼 剧本：G.O. 音乐：安濑圣 人物设定：空中幼彩 主题歌作曲：藤田淳平 主题歌演出：riya ","date":"2016-04-28","objectID":"/game/island/:1:0","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 三千界切那 さんぜんかい せつな、Sanzenkai Setsuna 男 没有人 2 御原凛音 おはら りんね、Ohara Rinne 女 田村ゆかり 3 枢都夏莲 くるつ かれん、Kurutsu Karen 女 阿澄佳奈 4 伽蓝堂纱罗 がらんどう さら、Garandou Sara 女 村川梨衣 5 御原玖音 おはら くおん、Ohara Kuon 女 佐藤利奈 6 播守太郎 播守 太郎、はりす たろう、Harisu Tarou、駐在 男 茂木たかまさ 7 山吹桃香 やまぶき ももか、Yamabuki Momoka 女 加隈亜衣 8 枢都守春 くつる すばる","date":"2016-04-28","objectID":"/game/island/:2:0","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":"系列 系列名 发行时间 1 ISLAND 2016-04-28 ","date":"2016-04-28","objectID":"/game/island/:3:0","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":"配乐 ","date":"2016-04-28","objectID":"/game/island/:4:0","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":" 力扣第 478 题 ","date":"2016-04-22","objectID":"/leetcode/0478/:0:0","tags":null,"title":"0478：在圆内随机生成点（★）","uri":"/leetcode/0478/"},{"categories":null,"content":"题目 给定圆的半径和圆心的位置，实现函数 randPoint ，在圆中产生均匀随机点。 实现 Solution 类: Solution(double radius, double x_center, double y_center) 用圆的半径 radius 和圆心的位置 (x_center, y_center) 初始化对象 randPoint() 返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回 [x, y] 。 示例 1： 输入: [\"Solution\",\"randPoint\",\"randPoint\",\"randPoint\"] [[1.0, 0.0, 0.0], [], [","date":"2016-04-22","objectID":"/leetcode/0478/:1:0","tags":null,"title":"0478：在圆内随机生成点（★）","uri":"/leetcode/0478/"},{"categories":null,"content":"分析 可以用拒绝抽样，在外接正方形中随机，落在圆里就返回结果。 ","date":"2016-04-22","objectID":"/leetcode/0478/:2:0","tags":null,"title":"0478：在圆内随机生成点（★）","uri":"/leetcode/0478/"},{"categories":null,"content":"解答 class Solution: def __init__(self, radius: float, x_center: float, y_center: float): self.x = x_center self.y = y_center self.r = radius def randPoint(self) -\u003e List[float]: while True: a = 1-2*random.random() b = 1-2*random.random() if a*a+b*b\u003c=1: return [self.x+a*self.r, self.y+b*self.r] 228 ms ","date":"2016-04-22","objectID":"/leetcode/0478/:3:0","tags":null,"title":"0478：在圆内随机生成点（★）","uri":"/leetcode/0478/"},{"categories":null,"content":" 力扣第 474 题 ","date":"2016-04-18","objectID":"/leetcode/0474/:0:0","tags":null,"title":"0474：一和零（★）","uri":"/leetcode/0474/"},{"categories":null,"content":"题目 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 输入：strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。 其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"1","date":"2016-04-18","objectID":"/leetcode/0474/:1:0","tags":null,"title":"0474：一和零（★）","uri":"/leetcode/0474/"},{"categories":null,"content":"分析 ","date":"2016-04-18","objectID":"/leetcode/0474/:2:0","tags":null,"title":"0474：一和零（★）","uri":"/leetcode/0474/"},{"categories":null,"content":"#1 显然按是否选 strs[0]，可以转为递归子问题。 令 dfs(i, j, k) 代表 strs[i:] 中最多 j 个 0、k 个 1 的最大子集长度，即可递归。 注意每个字符串有用的信息只有 0 和 1 的个数，可以提前求出保存，节省时间。 这本质上是个 01 背包问题，m、n 是限制条件，字符串的 0/1 个数是代价，求最多能选多少个。 def findMaxForm(self, strs: List[str], m: int, n: int) -\u003e int: @lru_cache(None) def dfs(i, j, k): if j\u003c0 or k\u003c0: return floa","date":"2016-04-18","objectID":"/leetcode/0474/:2:1","tags":null,"title":"0474：一和零（★）","uri":"/leetcode/0474/"},{"categories":null,"content":"#2 可以改写成非递归形式，并且倒序遍历 j、k，将 dp 优化为二维数组。 ","date":"2016-04-18","objectID":"/leetcode/0474/:2:2","tags":null,"title":"0474：一和零（★）","uri":"/leetcode/0474/"},{"categories":null,"content":"解答 def findMaxForm(self, strs: List[str], m: int, n: int) -\u003e int: dp = [[0]*(n+1) for _ in range(m+1)] for s in strs: cnt0, cnt1 = s.count('0'), s.count('1') for j in range(m, cnt0-1, -1): for k in range(n, cnt1-1, -1): dp[j][k] = max(dp[j][k], 1+dp[j-cnt0][k-cnt1]) return dp[-1][-1] 2652 ms ","date":"2016-04-18","objectID":"/leetcode/0474/:3:0","tags":null,"title":"0474：一和零（★）","uri":"/leetcode/0474/"},{"categories":null,"content":" 力扣第 473 题 ","date":"2016-04-17","objectID":"/leetcode/0473/:0:0","tags":null,"title":"0473：火柴拼正方形（★）","uri":"/leetcode/0473/"},{"categories":null,"content":"题目 你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。 如果你能使这个正方形，则返回 true ，否则返回 false 。 示例 1: 输入: matchsticks = [1,1,2,2,2] 输出: true 解释: 能拼成一个边长为2的正方形，每边两根火柴。 示例 2: 输入: matchsticks = [3,3,3,3,4] 输出: false 解释: 不能用所有火柴拼成一个正方形。 提示: 1 \u003c=","date":"2016-04-17","objectID":"/leetcode/0473/:1:0","tags":null,"title":"0473：火柴拼正方形（★）","uri":"/leetcode/0473/"},{"categories":null,"content":"分析 为了方便，令 A=matchsticks，s=sum(A)。 显然当 s%4!=0 时非真。否则，要将 A 划分为四个和为 t=s//4 的子集。 暴力法就是遍历 A 的所有排列，判断是否能分割成功 假如排列的最后一个数是 x，那么只要 A-{x} 能组成 3 个和 t 的子集，即可成功 一般性地，令 dfs(B) 代表集合 B 能否组成 sum(B)//t 个和 t 的子集，尝试递推 从 B 中任选一个数 x，集合 C=B-x，只要 dfs(C) 为真且 x+sum(C)%t\u003c=t，dfs(B) 即为真 为了方便，可以令 dfs(B) 返回 sum(B)%t，若集合 B 非真，则返回 ","date":"2016-04-17","objectID":"/leetcode/0473/:2:0","tags":null,"title":"0473：火柴拼正方形（★）","uri":"/leetcode/0473/"},{"categories":null,"content":"解答 def makesquare(self, matchsticks: List[int]) -\u003e bool: s = sum(matchsticks) if s%4: return False A, n = matchsticks, len(matchsticks) dp = [0]+[-1]*((1\u003c\u003cn)-1) for st in range(1\u003c\u003cn): if dp[st]\u003e=0: for i in range(n): if not st\u0026(1\u003c\u003ci) and dp[st]+A[i]\u003c=s//4: dp[st|(1\u003c\u003ci)] = (dp[st]+A[i])%(s//4) return","date":"2016-04-17","objectID":"/leetcode/0473/:3:0","tags":null,"title":"0473：火柴拼正方形（★）","uri":"/leetcode/0473/"},{"categories":null,"content":" 力扣第 470 题 ","date":"2016-04-14","objectID":"/leetcode/0470/:0:0","tags":null,"title":"0470：用 Rand7() 实现 Rand10()（★）","uri":"/leetcode/0470/"},{"categories":null,"content":"题目 给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。 你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。 每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。 示例 1: 输入: 1 输出: [2] 示例 2: 输入: 2 输出: [2,8] 示例 3: 输入: 3 输出: [3,8,10] 提示: 1 \u003c= n \u003c= 105 进阶: rand7()调用次数的 期望值 是","date":"2016-04-14","objectID":"/leetcode/0470/:1:0","tags":null,"title":"0470：用 Rand7() 实现 Rand10()（★）","uri":"/leetcode/0470/"},{"categories":null,"content":"分析 典型的拒绝抽样。调用两次 rand7，可以等价于 rand49，然后 1 到 40 均匀分为 10 份即可等价于 rand10。 如果大于 40，就重新抽样。 ","date":"2016-04-14","objectID":"/leetcode/0470/:2:0","tags":null,"title":"0470：用 Rand7() 实现 Rand10()（★）","uri":"/leetcode/0470/"},{"categories":null,"content":"解答 def rand10(self): while True: res = (rand7() - 1) * 7 + rand7() if res \u003c= 40: return res % 10 + 1 340 ms ","date":"2016-04-14","objectID":"/leetcode/0470/:3:0","tags":null,"title":"0470：用 Rand7() 实现 Rand10()（★）","uri":"/leetcode/0470/"},{"categories":null,"content":" 力扣第 467 题 ","date":"2016-04-11","objectID":"/leetcode/0467/:0:0","tags":null,"title":"0467：环绕字符串中唯一的子字符串（★）","uri":"/leetcode/0467/"},{"categories":null,"content":"题目 定义字符串 base 为一个 \"abcdefghijklmnopqrstuvwxyz\" 无限环绕的字符串，所以 base 看起来是这样的： \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\". 给你一个字符串 s ，请你统计并返回 s 中有多少 不同非空子串 也在 base 中出现。 示例 1： 输入：s = \"a\" 输出：1 解释：字符串 s 的子字符串 \"a\" 在 base 中出现。 示例 2： 输入：s = \"cac\" 输出：2 解释：字符串 s 有两个子字符串 (\"a\", \"c\") 在 base 中","date":"2016-04-11","objectID":"/leetcode/0467/:1:0","tags":null,"title":"0467：环绕字符串中唯一的子字符串（★）","uri":"/leetcode/0467/"},{"categories":null,"content":"分析 容易想到用 dp[i] 代表以 p[i] 结尾的在 s 中的子串数量，即可递推。 但这样存在重复计算的问题，比如 ‘cac’ 中 ‘c’ 会被计算两次。 一个巧妙的想法是只需要找到以 ‘c’ 结尾的最长的在 s 中的子串，只统计这一个 ‘c’ 即可。 因此令 dp[x] 代表以 x 结尾的在 s 中的最长子串长度，最后 sum(dp[x]) 即为所求。 def findSubstringInWraproundString(self, p: str) -\u003e int: dp, cnt = defaultdict(int), 0 for i, x in enumerate(p): cnt = ","date":"2016-04-11","objectID":"/leetcode/0467/:2:0","tags":null,"title":"0467：环绕字符串中唯一的子字符串（★）","uri":"/leetcode/0467/"},{"categories":null,"content":"以伤痛相连的羁绊物语——。\n少年少女们分享“疼痛”的青春群像剧，现在开始！！\n舞台是在废弃的土地上建造的城镇·洲笼市。住在这座曾以未来型都市而繁荣的城镇的高中生·阿形胜平，不知为何拥有着感觉不到疼痛的不可思议身体。在暑假近在眼前的某天，胜平在谜之少女·园崎法子的引领下，被选为共享疼痛的同伴“羁绊者”之一。以及，同样以“羁绊者”身份被联系起来的同班同学们。但，他们原本各自属于从未交流过的集团。园崎说“这是，将充满纷争的世界导向和平的实验。”与这番话语同时，众多的试炼降临到他们的身上。\n背负着各自的伤痛，少年少女们的夏日物语由此开始！","date":"2016-04-09","objectID":"/anime/kiznaiver/","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":"简介 以伤痛相连的羁绊物语——。 少年少女们分享“疼痛”的青春群像剧，现在开始！！ 舞台是在废弃的土地上建造的城镇·洲笼市。住在这座曾以未来型都市而繁荣的城镇的高中生·阿形胜平，不知为何拥有着感觉不到疼痛的不可思议身体。在暑假近在眼前的某天，胜平在谜之少女·园崎法子的引领下，被选为共享疼痛的同伴“羁绊者”之一。以及，同样以“羁绊者”身份被联系起来的同班同学们。但，他们原本各自属于从未交流过的集团。园崎说“这是，将充满纷争的世界导向和平的实验。”与这番话语同时，众多的试炼降临到他们的身上。 背负着各自的伤痛，少年少女们的夏日物语由此开始！ 制作人员： 原作：TRIGGER、冈田麿里 导演：小林宽","date":"2016-04-09","objectID":"/anime/kiznaiver/:1:0","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿形胜平 阿形 勝平、あかた かつひら、AGATA KATSUHIRA 男 梶裕貴 2 园崎法子 園崎 法子、そのさき のりこ、SONOZAKI NORIKO 女 山村響 3 天河一 天河 一、てんが はじめ、TENGA HAJIME 男 前野智昭 4 由多次人 由多 次人、よしだ つぐと、YUTA TSUGUHITO 男 島﨑信長 5 牧穗乃香 牧 穂乃香、まき ほのか、MAKI HONOKA 女 佐藤利奈 6 高城千鸟 高城 千鳥、たかしろ ちどり、TAKASHIRO CHIDORI 女 寺崎裕香 7 新山仁子 新山 仁子、にいやま にこ、NIYAMA ","date":"2016-04-09","objectID":"/anime/kiznaiver/:2:0","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 羁绊者 2016-04-09 12 樱花 ","date":"2016-04-09","objectID":"/anime/kiznaiver/:3:0","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":"MAD ","date":"2016-04-09","objectID":"/anime/kiznaiver/:4:0","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":" 力扣第 464 题 ","date":"2016-04-08","objectID":"/leetcode/0464/:0:0","tags":null,"title":"0464：我能赢吗（★）","uri":"/leetcode/0464/"},{"categories":null,"content":"题目 在 \"100 game\" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过 100 的玩家，即为胜者。 如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？ 例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 \u003e= 100。 给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。 示例 1： 输入：maxChoosableInteg","date":"2016-04-08","objectID":"/leetcode/0464/:1:0","tags":null,"title":"0464：我能赢吗（★）","uri":"/leetcode/0464/"},{"categories":null,"content":"分析 为了方便，令 M=maxChoosableInteger，T=desiredTotal。 假如 M*(M+1)//2\u003cT，显然没有人能赢。否则： 如果第一个玩家选了 x 后第二个玩家要输，则第一个玩家必赢 第一个玩家选了 x 后，第二个玩家面临的情况等价于可选集合为 {原集合去掉 x}、目标为 T-x 的子问题 因此令 dfs(A, T) 代表可选集合为 A、 目标 T 的情况下第一个玩家是否稳赢，即可递归。 为了方便表示集合，可以用状态压缩。 def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -\u003e bool: ","date":"2016-04-08","objectID":"/leetcode/0464/:2:0","tags":null,"title":"0464：我能赢吗（★）","uri":"/leetcode/0464/"},{"categories":null,"content":" 力扣第 463 题 ","date":"2016-04-07","objectID":"/leetcode/0463/:0:0","tags":null,"title":"0463：岛屿的周长","uri":"/leetcode/0463/"},{"categories":null,"content":"题目 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。 网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 1： 输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] 输出：16 解","date":"2016-04-07","objectID":"/leetcode/0463/:1:0","tags":null,"title":"0463：岛屿的周长","uri":"/leetcode/0463/"},{"categories":null,"content":"分析 遍历陆地并去掉相邻陆地的重叠边即可。 ","date":"2016-04-07","objectID":"/leetcode/0463/:2:0","tags":null,"title":"0463：岛屿的周长","uri":"/leetcode/0463/"},{"categories":null,"content":"解答 def islandPerimeter(self, grid: List[List[int]]) -\u003e int: res, m, n = 0, len(grid), len(grid[0]) for i, j in product(range(m), range(n)): if grid[i][j]: res += 4 if i and grid[i-1][j]: res -= 2 if j and grid[i][j-1]: res -= 2 return res 96 ms ","date":"2016-04-07","objectID":"/leetcode/0463/:3:0","tags":null,"title":"0463：岛屿的周长","uri":"/leetcode/0463/"},{"categories":null,"content":"酷、很酷、最最酷的高中生登场了！\n本故事是某个很酷，不，是最酷的高中生坂本的校园生活的集锦。\n刚入学不久，就出现一位被全班，不是被全校瞩目的学生。\n他名为坂本。\n一旦与他扯上关系，普通的反复横跳就会升级为秘技“Repetition Side Step”\n他把上级生强加于他的“跑腿活”华丽升格为“尽心尽责的服务”。\n这样炫酷的他，一举手一投足都摄人心魄。","date":"2016-04-07","objectID":"/anime/sakamoto_desu_ga/","tags":null,"title":"在下坂本，有何贵干？","uri":"/anime/sakamoto_desu_ga/"},{"categories":null,"content":"简介 酷、很酷、最最酷的高中生登场了！ 本故事是某个很酷，不，是最酷的高中生坂本的校园生活的集锦。 刚入学不久，就出现一位被全班，不是被全校瞩目的学生。 他名为坂本。 一旦与他扯上关系，普通的反复横跳就会升级为秘技“Repetition Side Step” 他把上级生强加于他的“跑腿活”华丽升格为“尽心尽责的服务”。 这样炫酷的他，一举手一投足都摄人心魄。 制作人员： 原作：佐野菜见 导演：高松信司 分镜：城所圣明、川崎逸朗、齐藤哲人、稻垣隆行、名村英敏 ","date":"2016-04-07","objectID":"/anime/sakamoto_desu_ga/:1:0","tags":null,"title":"在下坂本，有何贵干？","uri":"/anime/sakamoto_desu_ga/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 坂本 さかもと、Sakamoto、屌神 男 緑川光 2 久保田吉伸 久保田 吉伸 男 石田彰 3 濑良裕也 瀬良 裕也 男 森久保祥太郎 4 黑沼爱菜 黒沼 あいな 女 堀江由衣 5 隼 ハヤブサ先輩 男 遊佐浩二 6 丸山 まるやま 男 稲田徹 7 藤田惠 藤田 恵 女 中原麻衣 8 久保田茂美 くぼた しげみ 女 くじら ","date":"2016-04-07","objectID":"/anime/sakamoto_desu_ga/:2:0","tags":null,"title":"在下坂本，有何贵干？","uri":"/anime/sakamoto_desu_ga/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 在下坂本，有何贵干？ 2016-04-07 13 bilibili ","date":"2016-04-07","objectID":"/anime/sakamoto_desu_ga/:3:0","tags":null,"title":"在下坂本，有何贵干？","uri":"/anime/sakamoto_desu_ga/"},{"categories":null,"content":" 力扣第 460 题 ","date":"2016-04-04","objectID":"/leetcode/0460/:0:0","tags":null,"title":"0460：LFU 缓存（★★）","uri":"/leetcode/0460/"},{"categories":null,"content":"题目 请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。 实现 LFUCache 类： LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象 int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。 void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。","date":"2016-04-04","objectID":"/leetcode/0460/:1:0","tags":null,"title":"0460：LFU 缓存（★★）","uri":"/leetcode/0460/"},{"categories":null,"content":"分析 0146 的升级版。需要先找到最小使用次数的键集合，再找到最久未使用的键。 因此考虑用哈希表存 key 的使用次数 freq。而对于相同 freq 的键, 用 OrderedDict 维护顺序。 get 和 put 时先得到 key 的使用次数 freq，从 freq 对应的字典中弹出 key，并添加到 freq+1 对应的字典中。 如果是 put 新的 key 且容量达到上限，则找到最小使用次数 minFreq，从 minFreq 对应的 OrderedDict 中弹出首位元素。 注意到当 get 或 put 已有 key 时，minFreq 只可能不变或加 1，而 put 新的 ke","date":"2016-04-04","objectID":"/leetcode/0460/:2:0","tags":null,"title":"0460：LFU 缓存（★★）","uri":"/leetcode/0460/"},{"categories":null,"content":"解答 class LFUCache: def __init__(self, capacity: int): self.ct = Counter() self.d = defaultdict(OrderedDict) self.capacity = capacity self.minFreq = 0 def pop(self, key): freq = self.ct[key] val = self.d[freq].pop(key) if not self.d[freq] and self.minFreq == freq: self.minFreq = freq+1 return freq, v","date":"2016-04-04","objectID":"/leetcode/0460/:3:0","tags":null,"title":"0460：LFU 缓存（★★）","uri":"/leetcode/0460/"},{"categories":null,"content":" 力扣第 459 题 ","date":"2016-04-03","objectID":"/leetcode/0459/:0:0","tags":null,"title":"0459：重复的子字符串","uri":"/leetcode/0459/"},{"categories":null,"content":"题目 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 示例 1: 输入: s = \"abab\" 输出: true 解释: 可由子串 \"ab\" 重复两次构成。 示例 2: 输入: s = \"aba\" 输出: false 示例 3: 输入: s = \"abcabcabcabc\" 输出: true 解释: 可由子串 \"abc\" 重复四次构成。 (或子串 \"abcabc\" 重复两次构成。) 提示： 1 \u003c= s.length \u003c= 104 s 由小写英文字母组成 ","date":"2016-04-03","objectID":"/leetcode/0459/:1:0","tags":null,"title":"0459：重复的子字符串","uri":"/leetcode/0459/"},{"categories":null,"content":"分析 ","date":"2016-04-03","objectID":"/leetcode/0459/:2:0","tags":null,"title":"0459：重复的子字符串","uri":"/leetcode/0459/"},{"categories":null,"content":"#1 假如长为 n 的 s 能由长 m 的子串 ss 组成，那么显然 n 是 m 的倍数。 因此考虑遍历所有 n 的因数（不包括 n）m，判断 s 是否由 s[:m] 重复构成即可。 def repeatedSubstringPattern(self, s: str) -\u003e bool: n = len(s) for i in range(1, int(sqrt(n))+1): if n%i==0: for j in [i, n//i]: if j\u003cn and s[:j]*(n//j)==s: return True return False 时间复杂度 $O(N*\\sqrt N)$，32 ms","date":"2016-04-03","objectID":"/leetcode/0459/:2:1","tags":null,"title":"0459：重复的子字符串","uri":"/leetcode/0459/"},{"categories":null,"content":"#2 还有个巧妙的方法，s 由子串 ss 重复组成等价于 ss 是 s[1:]+s[:-1] 的子串。 这也是一个经典的方法：证明 ","date":"2016-04-03","objectID":"/leetcode/0459/:2:2","tags":null,"title":"0459：重复的子字符串","uri":"/leetcode/0459/"},{"categories":null,"content":"解答 def repeatedSubstringPattern(self, s: str) -\u003e bool: return s in (s+s)[1:-1] 48 ms ","date":"2016-04-03","objectID":"/leetcode/0459/:3:0","tags":null,"title":"0459：重复的子字符串","uri":"/leetcode/0459/"},{"categories":null,"content":"　　从便利店回来的路上突然被召唤到异世界的少年，菜月昴。在无可依赖的异世界，无力的少年所唯一拥有的力量……那就是死后便会使时间倒转的“死亡回归”的力量。为了守护重要的人，并取回那些无可替代的时间，少年向绝望抗争，挺身面对残酷的命运。","date":"2016-04-03","objectID":"/anime/re0/","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"简介 从便利店回来的路上突然被召唤到异世界的少年，菜月昴。在无可依赖的异世界，无力的少年所唯一拥有的力量……那就是死后便会使时间倒转的“死亡回归”的力量。为了守护重要的人，并取回那些无可替代的时间，少年向绝望抗争，挺身面对残酷的命运。 制作人员： 原作：长月达平 导演：渡边政治 脚本：梅原英司、横谷昌宏、中村能子 分镜：细田直人、长山延好、相泽昌弘、山岸大悟 ","date":"2016-04-03","objectID":"/anime/re0/:1:0","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 菜月昴 なつき・すばる、Natsuki Subaru 男 小林裕介 2 艾米莉娅 爱蜜莉雅、Emilia、EMT 女 高橋李依 3 蕾姆 雷姆、REM、Remu 女 水瀬いのり 4 拉姆 RAM、ラム、Ramu 女 村川梨衣 5 碧翠丝 ベティ、贝阿特莉丝、Beatrice、ベアトリス、Beatorisu、Betty，贝蒂 女 新井里美 6 帕克 PACK、パック、Pakku 内山夕実 7 菲鲁特 FELT、フェルト、Feruto 女 赤﨑千夏 8 莱茵哈鲁特·梵·阿斯特雷亚 Reinhard Van Astrea 男 中村悠一 ","date":"2016-04-03","objectID":"/anime/re0/:2:0","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Re：从零开始的异世界生活 2016-04-03 25 bilibili 2 Re：从零开始的异世界生活 第二季 2020-07-08 13 bilibili 3 Re：从零开始的异世界生活 第二季 后半部分 2021-01-06 12 bilibili ","date":"2016-04-03","objectID":"/anime/re0/:3:0","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"MAD ","date":"2016-04-03","objectID":"/anime/re0/:4:0","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"　　在宇宙人与地球人共同生活的银河指定宇宙移民特区OGIKUBO和父亲两人生活，随处可见的“超普通”现役女初中生露露子。在过着普通生活的露露子面前突然出现的神秘转学生AΩ·诺瓦。这次“相遇”让露露子的命运卷起波澜。","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":"简介 在宇宙人与地球人共同生活的银河指定宇宙移民特区OGIKUBO和父亲两人生活，随处可见的“超普通”现役女初中生露露子。在过着普通生活的露露子面前突然出现的神秘转学生AΩ·诺瓦。这次“相遇”让露露子的命运卷起波澜。 制作人员： 原作：TRIGGER、今石洋之 脚本：上野贵美子、若林广海、雨宫哲、佐藤裕 分镜：大岛博之 ","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/:1:0","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 露露子 luluco、ルルコ、Ruruko 女 M・A・O 2 ΑΩ·Nova 男 榎木淳弥 3 碧·拯救世界 绿、Midori Save The World、Midori 女 新谷真弓 4 OverJustice本部长 男 稲田徹 5 启司 Keiji 男 岩田光央 6 拉拉子·神佑 Rarako・Godspeed 女 本名陽子 7 宇宙巡警银河总司令 男 檜山修之 8 秘书 秘 書 女 ","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/:2:0","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 宇宙巡警露露子 2016-04-01 13 bilibili ","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/:3:0","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":"MAD ","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/:4:0","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":" 力扣第 456 题 ","date":"2016-03-31","objectID":"/leetcode/0456/:0:0","tags":null,"title":"0456：132 模式（★）","uri":"/leetcode/0456/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i \u003c j \u003c k 和 nums[i] \u003c nums[k] \u003c nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [1,2,3,4] 输出：false 解释：序列中不存在 132 模式的子序列。 示例 2： 输入：nums = [3,1,4,2] 输出：true 解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例","date":"2016-03-31","objectID":"/leetcode/0456/:1:0","tags":null,"title":"0456：132 模式（★）","uri":"/leetcode/0456/"},{"categories":null,"content":"分析 ","date":"2016-03-31","objectID":"/leetcode/0456/:2:0","tags":null,"title":"0456：132 模式（★）","uri":"/leetcode/0456/"},{"categories":null,"content":"#1 遍历 b=nums[j]，那么 a 取 min(nums[:j])，在 nums[j+1:] 中找 c 使得 a \u003c c \u003c b 即可。 min(nums[:j]) 可以递推得到。而 nums[j+1:] 可以维护一个排序的子数组，然后二分查找。 def find132pattern(self, nums: List[int]) -\u003e bool: a, tmp = float('inf'), sorted(nums) for b in nums: tmp.pop(bisect_left(tmp, b)) if a \u003c b: k = bisect_right(tmp, a) if k \u003c ","date":"2016-03-31","objectID":"/leetcode/0456/:2:1","tags":null,"title":"0456：132 模式（★）","uri":"/leetcode/0456/"},{"categories":null,"content":"#2 还有个巧妙的单调栈解法。从右往左遍历，维护一个 max_c 代表满足 32 模式的最大的 2 ，维护一个 stack 保存比 max_c 大的所有数。 遍历到 num 时： 如果 num \u003c max_c 显然 num 可以作为 132 模式的 1，返回 True 如果 num == max_c 不影响，可以直接跳过 如果 max_c \u003c num \u003c min(stack) 将 num 添加到 stack 中 如果 num == min(stack) 不影响，可以直接跳过 如果 num \u003e min(stack) min(stack) 可以作为新的 max_c，将其删除。循环操作直到转为其它情","date":"2016-03-31","objectID":"/leetcode/0456/:2:2","tags":null,"title":"0456：132 模式（★）","uri":"/leetcode/0456/"},{"categories":null,"content":"解答 def find132pattern(self, nums: List[int]) -\u003e bool: stack, max_c = [], float('-inf') for num in nums[::-1]: if num \u003c max_c: return True while stack and num \u003e stack[-1]: max_c = stack.pop() if num \u003e max_c: stack.append(num) return False 时间复杂度 O(N)，44 ms ","date":"2016-03-31","objectID":"/leetcode/0456/:3:0","tags":null,"title":"0456：132 模式（★）","uri":"/leetcode/0456/"},{"categories":null,"content":" 力扣第 454 题 ","date":"2016-03-29","objectID":"/leetcode/0454/:0:0","tags":null,"title":"0454：四数相加 II（★）","uri":"/leetcode/0454/"},{"categories":null,"content":"题目 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 \u003c= i, j, k, l \u003c n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例 1： 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] 输出：2 解释： 两个元组如下： 1. (0, 0, 0, 1) -\u003e nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + ","date":"2016-03-29","objectID":"/leetcode/0454/:1:0","tags":null,"title":"0454：四数相加 II（★）","uri":"/leetcode/0454/"},{"categories":null,"content":"分析 采用 0018 的方法会超时，注意到本题是计算四元组的个数，而不需要列举出来。 因此在遍历时，可以直接用哈希表保存后两个数的和以及对应的频次，一下去掉后两层循环。 ","date":"2016-03-29","objectID":"/leetcode/0454/:2:0","tags":null,"title":"0454：四数相加 II（★）","uri":"/leetcode/0454/"},{"categories":null,"content":"解答 def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -\u003e int: ct = Counter(c+d for c in nums3 for d in nums4) return sum(ct[-a-b] for a in nums1 for b in nums2) 时间复杂度 O(N^2)，576 ms ","date":"2016-03-29","objectID":"/leetcode/0454/:3:0","tags":null,"title":"0454：四数相加 II（★）","uri":"/leetcode/0454/"},{"categories":null,"content":" 力扣第 451 题 ","date":"2016-03-26","objectID":"/leetcode/0451/:0:0","tags":null,"title":"0451：根据字符出现频率排序（★）","uri":"/leetcode/0451/"},{"categories":null,"content":"题目 给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。 返回 已排序的字符串 。如果有多个答案，返回其中任何一个。 示例 1: 输入: s = \"tree\" 输出: \"eert\" 解释: 'e'出现两次，'r'和't'都只出现一次。 因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。 示例 2: 输入: s = \"cccaaa\" 输出: \"cccaaa\" 解释: 'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。 注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。 示例 3: ","date":"2016-03-26","objectID":"/leetcode/0451/:1:0","tags":null,"title":"0451：根据字符出现频率排序（★）","uri":"/leetcode/0451/"},{"categories":null,"content":"分析 Counter 然后用 sort 或 Counter().most_common() 或 heapq.nlargest 即可。 ","date":"2016-03-26","objectID":"/leetcode/0451/:2:0","tags":null,"title":"0451：根据字符出现频率排序（★）","uri":"/leetcode/0451/"},{"categories":null,"content":"解答 def frequencySort(self, s: str) -\u003e str: return ''.join(char*freq for char, freq in Counter(s).most_common()) 48 ms ","date":"2016-03-26","objectID":"/leetcode/0451/:3:0","tags":null,"title":"0451：根据字符出现频率排序（★）","uri":"/leetcode/0451/"},{"categories":null,"content":" 力扣第 450 题 ","date":"2016-03-25","objectID":"/leetcode/0450/:0:0","tags":null,"title":"0450：删除二叉搜索树中的节点（★）","uri":"/leetcode/0450/"},{"categories":null,"content":"题目 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 示例 1: 输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,","date":"2016-03-25","objectID":"/leetcode/0450/:1:0","tags":null,"title":"0450：删除二叉搜索树中的节点（★）","uri":"/leetcode/0450/"},{"categories":null,"content":"分析 假如要删除的不是根节点，转为递归子问题。 假如删除的是根节点且左子树为空，返回右子树即可。 假如删除的是根节点且左子树非空，找到左子树中最大的节点（其必然是没有右子树的），将根节点的右子树作为其右子树即可。 ","date":"2016-03-25","objectID":"/leetcode/0450/:2:0","tags":null,"title":"0450：删除二叉搜索树中的节点（★）","uri":"/leetcode/0450/"},{"categories":null,"content":"解答 def deleteNode(self, root: TreeNode, key: int) -\u003e TreeNode: if not root: return None if root.val \u003e key: root.left = self.deleteNode(root.left, key) elif root.val \u003c key: root.right = self.deleteNode(root.right, key) elif not root.left: root = root.right else: p = root.left while p.right: p = p.rig","date":"2016-03-25","objectID":"/leetcode/0450/:3:0","tags":null,"title":"0450：删除二叉搜索树中的节点（★）","uri":"/leetcode/0450/"},{"categories":null,"content":" 力扣第 449 题 ","date":"2016-03-24","objectID":"/leetcode/0449/:0:0","tags":null,"title":"0449：序列化和反序列化二叉搜索树（★）","uri":"/leetcode/0449/"},{"categories":null,"content":"题目 序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。 设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。 编码的字符串应尽可能紧凑。 示例 1： 输入：root = [2,1,3] 输出：[2,1,3] 示例 2： 输入：root = [] 输出：[] 提示： 树中节点数范围是 [0, 104] 0 \u003c= Node.val \u003c= 104 题目数据 保证 输入的树是一棵","date":"2016-03-24","objectID":"/leetcode/0449/:1:0","tags":null,"title":"0449：序列化和反序列化二叉搜索树（★）","uri":"/leetcode/0449/"},{"categories":null,"content":"分析 ","date":"2016-03-24","objectID":"/leetcode/0449/:2:0","tags":null,"title":"0449：序列化和反序列化二叉搜索树（★）","uri":"/leetcode/0449/"},{"categories":null,"content":"#1 二叉搜索树根据前序遍历即可重构。 反序列化可以用 dfs 模拟序列化的过程。从遍历列表 queue 中弹出第一个元素作为 root， 然后进入下一层的左右子树，元素大于限定值时就返回上一层，即可重构出二叉树。 class Codec: def serialize(self, root): return '' if not root else ','.join( filter(None, [str(root.val), self.serialize(root.left), self.serialize(root.right)])) def deserialize(self, data): ","date":"2016-03-24","objectID":"/leetcode/0449/:2:1","tags":null,"title":"0449：序列化和反序列化二叉搜索树（★）","uri":"/leetcode/0449/"},{"categories":null,"content":"#2 如果每个节点的值用固定长度来表示，那么分割符也可以去掉了。因为数值范围为 0-10^4，所以用两个字节就可以表示了。 ","date":"2016-03-24","objectID":"/leetcode/0449/:2:2","tags":null,"title":"0449：序列化和反序列化二叉搜索树（★）","uri":"/leetcode/0449/"},{"categories":null,"content":"解答 class Codec: def int2str(self, val): return chr(val \u003e\u003e 7) + chr(val \u0026 127) def str2int(self, s): return (ord(s[0]) \u003c\u003c 7) + ord(s[1]) def serialize(self, root): return '' if not root else self.int2str(root.val) + self.serialize(root.left) + self.serialize(root.right) def deserialize(self, data): d","date":"2016-03-24","objectID":"/leetcode/0449/:3:0","tags":null,"title":"0449：序列化和反序列化二叉搜索树（★）","uri":"/leetcode/0449/"},{"categories":null,"content":" 力扣第 448 题 ","date":"2016-03-23","objectID":"/leetcode/0448/:0:0","tags":null,"title":"0448：找到所有数组中消失的数字","uri":"/leetcode/0448/"},{"categories":null,"content":"题目 给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。 示例 1： 输入：nums = [4,3,2,7,8,2,3,1] 输出：[5,6] 示例 2： 输入：nums = [1,1] 输出：[2] 提示： n == nums.length 1 \u003c= n \u003c= 105 1 \u003c= nums[i] \u003c= n 进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。 ","date":"2016-03-23","objectID":"/leetcode/0448/:1:0","tags":null,"title":"0448：找到所有数组中消失的数字","uri":"/leetcode/0448/"},{"categories":null,"content":"分析 没说不能修改 nums，因此可以用 nums 来保存信息。遍历到 num 时，将对应的位置 num-1 取负数。 最后还为正数的位置 i，其对应的数 i+1 即是没有出现过的数字。 ","date":"2016-03-23","objectID":"/leetcode/0448/:2:0","tags":null,"title":"0448：找到所有数组中消失的数字","uri":"/leetcode/0448/"},{"categories":null,"content":"解答 def findDisappearedNumbers(self, nums: List[int]) -\u003e List[int]: for num in nums: i = abs(num)-1 nums[i] = -abs(nums[i]) return [i+1 for i, num in enumerate(nums) if num\u003e0] 124 ms ","date":"2016-03-23","objectID":"/leetcode/0448/:3:0","tags":null,"title":"0448：找到所有数组中消失的数字","uri":"/leetcode/0448/"},{"categories":null,"content":" 力扣第 447 题 ","date":"2016-03-22","objectID":"/leetcode/0447/:0:0","tags":null,"title":"0447：回旋镖的数量（★）","uri":"/leetcode/0447/"},{"categories":null,"content":"题目 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。 返回平面上所有回旋镖的数量。 示例 1： 输入：points = [[0,0],[1,0],[2,0]] 输出：2 解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 示例 2： 输入：points = [[1,1],[2,2],[3,3]] 输出：2 示例 3： 输入：points = [[1,1]","date":"2016-03-22","objectID":"/leetcode/0447/:1:0","tags":null,"title":"0447：回旋镖的数量（★）","uri":"/leetcode/0447/"},{"categories":null,"content":"分析 n 个点各不相同，因此可以遍历 n 个点，作为回旋镖的中心，计算能构成多少回旋镖。 具体的，可以统计每个点到该点的距离。假设有 v 个点到该点的距离都为 dis，那么对应的回旋镖数量即为 v*(v-1)。 ","date":"2016-03-22","objectID":"/leetcode/0447/:2:0","tags":null,"title":"0447：回旋镖的数量（★）","uri":"/leetcode/0447/"},{"categories":null,"content":"解答 def numberOfBoomerangs(self, points: List[List[int]]) -\u003e int: res = 0 for x in points: ct = Counter((x[0]-y[0])**2+(x[1]-y[1])**2 for y in points) res += sum(v*(v-1) for v in ct.values()) return res 1292 ms ","date":"2016-03-22","objectID":"/leetcode/0447/:3:0","tags":null,"title":"0447：回旋镖的数量（★）","uri":"/leetcode/0447/"},{"categories":null,"content":" 力扣第 446 题 ","date":"2016-03-21","objectID":"/leetcode/0446/:0:0","tags":null,"title":"0446：等差数列划分 II - 子序列（★★）","uri":"/leetcode/0446/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。 如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。 例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。 再例如，[1, 1, 2, 5, 7] 不是等差序列。 数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。 例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 题目数据保证答案是一个 32-bit 整数。 示例 1： 输入：nums = [2,4,6,8,10] 输","date":"2016-03-21","objectID":"/leetcode/0446/:1:0","tags":null,"title":"0446：等差数列划分 II - 子序列（★★）","uri":"/leetcode/0446/"},{"categories":null,"content":"分析 考虑求以 nums[i] 结尾的等差子序列数目，遍历 j\u003ci，只要知道了以 nums[j] 结尾且差为 nums[i]-nums[j] 的等差子序列数目（长度 2 的也算），即可递推。 因此令 dp[i] 代表以 nums[i] 结尾的长度 \u003e=2 的等差子序列的计数器，计数的 key 是差。 递推过程中，将长度 \u003e=3 的等差子序列数目累加即可。 ","date":"2016-03-21","objectID":"/leetcode/0446/:2:0","tags":null,"title":"0446：等差数列划分 II - 子序列（★★）","uri":"/leetcode/0446/"},{"categories":null,"content":"解答 def numberOfArithmeticSlices(self, nums: List[int]) -\u003e int: res, n = 0, len(nums) dp = [defaultdict(int) for _ in range(n)] for i in range(n): for j in range(i): diff = nums[i]-nums[j] dp[i][diff] += 1+dp[j][diff] res += dp[j][diff] return res 904 ms ","date":"2016-03-21","objectID":"/leetcode/0446/:3:0","tags":null,"title":"0446：等差数列划分 II - 子序列（★★）","uri":"/leetcode/0446/"},{"categories":null,"content":" 力扣第 445 题 ","date":"2016-03-20","objectID":"/leetcode/0445/:0:0","tags":null,"title":"0445：两数相加 II（★）","uri":"/leetcode/0445/"},{"categories":null,"content":"题目 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例1： 输入：l1 = [7,2,4,3], l2 = [5,6,4] 输出：[7,8,0,7] 示例2： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[8,0,7] 示例3： 输入：l1 = [0], l2 = [0] 输出：[0] 提示： 链表的长度范围为 [1, 100] 0 \u003c= node.val \u003c= 9 输入数据保证链表代表的数字无前导 0 进阶：如果输入链表不能翻","date":"2016-03-20","objectID":"/leetcode/0445/:1:0","tags":null,"title":"0445：两数相加 II（★）","uri":"/leetcode/0445/"},{"categories":null,"content":"分析 ","date":"2016-03-20","objectID":"/leetcode/0445/:2:0","tags":null,"title":"0445：两数相加 II（★）","uri":"/leetcode/0445/"},{"categories":null,"content":"#1 最简单的想法就是先拿到两个数，相加后，再按位添加到新链表中。 def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u003e ListNode: x, y = 0, 0 while l1: x = x*10+l1.val l1 = l1.next while l2: l2 = l2*10+l2.val l2 = l2.next dummy = p = ListNode() for char in str(x+y): p.next = ListNode(int(char)) p = p.next return dummy.next 80 ms ","date":"2016-03-20","objectID":"/leetcode/0445/:2:1","tags":null,"title":"0445：两数相加 II（★）","uri":"/leetcode/0445/"},{"categories":null,"content":"#2 为了防止数太大，也可以用数组存储两个数，再模拟进位加法，类似 0415 。 ","date":"2016-03-20","objectID":"/leetcode/0445/:2:2","tags":null,"title":"0445：两数相加 II（★）","uri":"/leetcode/0445/"},{"categories":null,"content":"解答 def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u003e ListNode: A, B = [], [] while l1: A.append(l1.val) l1 = l1.next while l2: B.append(l2.val) l2 = l2.next head, carry = None, 0 while A or B or carry: x = A.pop() if A else 0 y = B.pop() if B else 0 s = x+y+carry head = ListNode(s%10, next=head","date":"2016-03-20","objectID":"/leetcode/0445/:3:0","tags":null,"title":"0445：两数相加 II（★）","uri":"/leetcode/0445/"},{"categories":null,"content":" 力扣第 439 题 ","date":"2016-03-14","objectID":"/leetcode/0439/:0:0","tags":null,"title":"0439：三元表达式解析器（★）","uri":"/leetcode/0439/"},{"categories":null,"content":"题目 给定一个表示任意嵌套三元表达式的字符串 expression ，求值并返回其结果。 你可以总是假设给定的表达式是有效的，并且只包含数字， '?' ， ':' ， 'T' 和 'F' ，其中 'T' 为真， 'F' 为假。表达式中的所有数字都是 一位 数(即在 [0,9] 范围内)。 条件表达式从右到左分组(大多数语言中都是这样)，表达式的结果总是为数字 'T' 或 'F' 。 示例 1： 输入： expression = \"T?2:3\" 输出： \"2\" 解释： 如果条件为真，结果为 2；否则，结果为 3。 示例 2： 输入： expression = \"F?1:T?4:5\" 输出： \"4","date":"2016-03-14","objectID":"/leetcode/0439/:1:0","tags":null,"title":"0439：三元表达式解析器（★）","uri":"/leetcode/0439/"},{"categories":null,"content":"分析 题目提示从右向左结合。故倒序遍历，用栈维护每一层即可。 ","date":"2016-03-14","objectID":"/leetcode/0439/:2:0","tags":null,"title":"0439：三元表达式解析器（★）","uri":"/leetcode/0439/"},{"categories":null,"content":"解答 def parseTernary(self, expression: str) -\u003e str: stack, n = [expression[-1]], len(expression) for i in range(n-3, -1, -2): if expression[i+1] == ':': stack.append(expression[i]) else: a = stack.pop() stack[-1] = a if expression[i]=='T' else stack[-1] return stack.pop() 36 ms ","date":"2016-03-14","objectID":"/leetcode/0439/:3:0","tags":null,"title":"0439：三元表达式解析器（★）","uri":"/leetcode/0439/"},{"categories":null,"content":" 力扣第 438 题 ","date":"2016-03-13","objectID":"/leetcode/0438/:0:0","tags":null,"title":"0438：找到字符串中所有字母异位词（★）","uri":"/leetcode/0438/"},{"categories":null,"content":"题目 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 示例 1: 输入: s = \"cbaebabacd\", p = \"abc\" 输出: [0,6] 解释: 起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。 起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。 示例 2: 输入: s = \"abab\", p = \"ab\" 输出: [0,1,2] 解释: 起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。 起始","date":"2016-03-13","objectID":"/leetcode/0438/:1:0","tags":null,"title":"0438：找到字符串中所有字母异位词（★）","uri":"/leetcode/0438/"},{"categories":null,"content":"分析 遍历每个窗口，判断是否符合即可。 判断是否异位词可以用排序，也可以用 Counter()。字符种类只有26种，故采用 Counter() 时间更优。 ","date":"2016-03-13","objectID":"/leetcode/0438/:2:0","tags":null,"title":"0438：找到字符串中所有字母异位词（★）","uri":"/leetcode/0438/"},{"categories":null,"content":"解答 def findAnagrams(self, s: str, p: str) -\u003e List[int]: res, k = [], len(p) ct, ct0 = Counter(), Counter(p) for j, char in enumerate(s): ct[char] += 1 if j \u003e= k: ct[s[j-k]] -= 1 if ct[s[j-k]] == 0: del ct[s[j-k]] if j \u003e= k-1 and ct == ct0: res.append(j-k+1) return res 156 ms ","date":"2016-03-13","objectID":"/leetcode/0438/:3:0","tags":null,"title":"0438：找到字符串中所有字母异位词（★）","uri":"/leetcode/0438/"},{"categories":null,"content":" 力扣第 437 题 ","date":"2016-03-12","objectID":"/leetcode/0437/:0:0","tags":null,"title":"0437：路径总和 III（★）","uri":"/leetcode/0437/"},{"categories":null,"content":"题目 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。 路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 示例 1： 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 输出：3 解释：和等于 8 的路径有 3 条，如图所示。 示例 2： 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：3 提示: 二叉树","date":"2016-03-12","objectID":"/leetcode/0437/:1:0","tags":null,"title":"0437：路径总和 III（★）","uri":"/leetcode/0437/"},{"categories":null,"content":"分析 ","date":"2016-03-12","objectID":"/leetcode/0437/:2:0","tags":null,"title":"0437：路径总和 III（★）","uri":"/leetcode/0437/"},{"categories":null,"content":"#1 依然可以采用 0112 的思路，只不过要传递的信息变成了所有以当前节点结尾的路径和。 于是遍历每个节点，统计以当前节点结尾的路径和等于目标的个数即可。 def pathSum(self, root: TreeNode, sum: int) -\u003e int: res, stack = 0, [(root, [])] while stack: node, tmp = stack.pop() if node: tmp = [node.val+v for v in tmp+[0]] res += tmp.count(sum) stack.extend([(node.right, tmp[:]), ","date":"2016-03-12","objectID":"/leetcode/0437/:2:1","tags":null,"title":"0437：路径总和 III（★）","uri":"/leetcode/0437/"},{"categories":null,"content":"#2 本题还有个巧妙的想法，可以利用前缀和来节省时间。 遍历每个节点，统计等于 当前前缀和 - 目标数 的前缀和个数即可。 为了动态维护前缀和的哈希表，考虑后序遍历，当节点二次出栈时去掉对应的前缀和。 ","date":"2016-03-12","objectID":"/leetcode/0437/:2:2","tags":null,"title":"0437：路径总和 III（★）","uri":"/leetcode/0437/"},{"categories":null,"content":"解答 def pathSum(self, root: TreeNode, sum: int) -\u003e int: d = defaultdict(int) d[0] = 1 res, stack = 0, [(root, 0)] while stack: node, val = stack.pop() if isinstance(node, int): d[val] -= 1 elif node: val += node.val res += d[val-sum] d[val] += 1 stack.extend([(node.val, val), (node.right, val), (node","date":"2016-03-12","objectID":"/leetcode/0437/:3:0","tags":null,"title":"0437：路径总和 III（★）","uri":"/leetcode/0437/"},{"categories":null,"content":" 力扣第 436 题 ","date":"2016-03-11","objectID":"/leetcode/0436/:0:0","tags":null,"title":"0436：寻找右区间（★）","uri":"/leetcode/0436/"},{"categories":null,"content":"题目 给你一个区间数组 intervals ，其中 intervals[i] = [starti, endi] ，且每个 starti 都 不同 。 区间 i 的 右侧区间 可以记作区间 j ，并满足 startj \u003e= endi ，且 startj 最小化 。 返回一个由每个区间 i 的 右侧区间 在 intervals 中对应下标组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1 。 示例 1： 输入：intervals = [[1,2]] 输出：[-1] 解释：集合中只有一个区间，所以输出-1。 示例 2： 输入：intervals = [[3,4],[","date":"2016-03-11","objectID":"/leetcode/0436/:1:0","tags":null,"title":"0436：寻找右区间（★）","uri":"/leetcode/0436/"},{"categories":null,"content":"分析 典型的排序+二分查找。 ","date":"2016-03-11","objectID":"/leetcode/0436/:2:0","tags":null,"title":"0436：寻找右区间（★）","uri":"/leetcode/0436/"},{"categories":null,"content":"解答 def findRightInterval(self, intervals: List[List[int]]) -\u003e List[int]: A = sorted((s, i) for i, (s, e) in enumerate(intervals)) res = [] for _, e in intervals: pos = bisect_left(A, (e, 0)) res.append(A[pos][1] if pos\u003clen(A) else -1) return res 92 ms ","date":"2016-03-11","objectID":"/leetcode/0436/:3:0","tags":null,"title":"0436：寻找右区间（★）","uri":"/leetcode/0436/"},{"categories":null,"content":" 力扣第 434 题 ","date":"2016-03-09","objectID":"/leetcode/0434/:0:0","tags":null,"title":"0434：字符串中的单词数","uri":"/leetcode/0434/"},{"categories":null,"content":"题目 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例: 输入: \"Hello, my name is John\" 输出: 5 解释: 这里的单词是指连续的不是空格的字符，所以 \"Hello,\" 算作 1 个单词。 ","date":"2016-03-09","objectID":"/leetcode/0434/:1:0","tags":null,"title":"0434：字符串中的单词数","uri":"/leetcode/0434/"},{"categories":null,"content":"分析 按空格分割即可。 ","date":"2016-03-09","objectID":"/leetcode/0434/:2:0","tags":null,"title":"0434：字符串中的单词数","uri":"/leetcode/0434/"},{"categories":null,"content":"解答 def countSegments(self, s: str) -\u003e int: return len(s.split()) 36 ms ","date":"2016-03-09","objectID":"/leetcode/0434/:3:0","tags":null,"title":"0434：字符串中的单词数","uri":"/leetcode/0434/"},{"categories":null,"content":" 力扣第 433 题 ","date":"2016-03-08","objectID":"/leetcode/0433/:0:0","tags":null,"title":"0433：最小基因变化（★）","uri":"/leetcode/0433/"},{"categories":null,"content":"题目 基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。 假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。 例如，\"AACCGGTT\" --\u003e \"AACCGGTA\" 就是一次基因变化。 另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中） 给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次","date":"2016-03-08","objectID":"/leetcode/0433/:1:0","tags":null,"title":"0433：最小基因变化（★）","uri":"/leetcode/0433/"},{"categories":null,"content":"分析 典型的 bfs。 ","date":"2016-03-08","objectID":"/leetcode/0433/:2:0","tags":null,"title":"0433：最小基因变化（★）","uri":"/leetcode/0433/"},{"categories":null,"content":"解答 def minMutation(self, start: str, end: str, bank: List[str]) -\u003e int: Q, d, bank = deque([start]), {start:0}, set(bank) while Q: w = Q.popleft() for i in range(len(w)): for c in 'ACGT': w2 = w[:i]+c+w[i+1:] if w2 not in d and w2 in bank: if w2 == end: return d[w]+1 Q.append(w2) d[w2] = d[w]+1 retu","date":"2016-03-08","objectID":"/leetcode/0433/:3:0","tags":null,"title":"0433：最小基因变化（★）","uri":"/leetcode/0433/"},{"categories":null,"content":" 力扣第 432 题 ","date":"2016-03-07","objectID":"/leetcode/0432/:0:0","tags":null,"title":"0432：全 O(1) 的数据结构（★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"题目 请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。 实现 AllOne 类： AllOne() 初始化数据结构的对象。 inc(String key) 字符串 key 的计数增加 1 。如果数据结构中尚不存在 key ，那么插入计数为 1 的 key 。 dec(String key) 字符串 key 的计数减少 1 。如果 key 的计数在减少后为 0 ，那么需要将这个 key 从数据结构中删除。测试用例保证：在减少计数前，key 存在于数据结构中。 getMaxKey() 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 \"\" 。 getMi","date":"2016-03-07","objectID":"/leetcode/0432/:1:0","tags":null,"title":"0432：全 O(1) 的数据结构（★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"分析 ","date":"2016-03-07","objectID":"/leetcode/0432/:2:0","tags":null,"title":"0432：全 O(1) 的数据结构（★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"#1 容易想到用一个计数器维护每个 key 的计数，然后维护一个 \u003c计数，key\u003e 的有序集合，首尾即为计数最小/大的 key。 class AllOne: def __init__(self): from sortedcontainers import SortedList self.ct = Counter() self.sl = SortedList() def inc(self, key: str) -\u003e None: freq = self.ct[key] if freq: self.sl.remove((freq, key)) self.ct[key] = freq + 1 self","date":"2016-03-07","objectID":"/leetcode/0432/:2:1","tags":null,"title":"0432：全 O(1) 的数据结构（★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"#2 要求全部单次操作 O(1)，考虑用 双向链表+哈希表 来维护 \u003c计数，key\u003e 的有序集合 。 具体来说： 操作过程中要维护： 双向链表的每个节点对应一个计数值 x，并且按值的升序相连 节点 x 保存所有计数为 x 的 key 集合 哈希表保存 key 对应的节点 Inc/Dec 时，将 key 从对应的节点 x 弹出，加入到节点 x+1/x-1 中。若 没有对应的节点，就新建一个。若节点 x 的 key 集合为空了，就去掉该节点。 GetMaxKey 和 GetMinKey 时，取首/尾节点（排除哑结点）的任意一个 key 返回即可 ","date":"2016-03-07","objectID":"/leetcode/0432/:2:2","tags":null,"title":"0432：全 O(1) 的数据结构（★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"解答 class Node: def __init__(self, val, keys=[]): self.val = val self.keys = set(keys) self.next = None self.prev = None def insert(self, node): node.next = self.next node.prev = self self.next = node node.next.prev = node def pop(self, key): self.keys.discard(key) if not self.keys: self.prev.next = ","date":"2016-03-07","objectID":"/leetcode/0432/:3:0","tags":null,"title":"0432：全 O(1) 的数据结构（★★）","uri":"/leetcode/0432/"},{"categories":null,"content":" 力扣第 429 题 ","date":"2016-03-04","objectID":"/leetcode/0429/:0:0","tags":null,"title":"0429：N 叉树的层序遍历（★）","uri":"/leetcode/0429/"},{"categories":null,"content":"题目 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。 示例 1： 输入：root = [1,null,3,2,4,null,5,6] 输出：[[1],[3,2,4],[5,6]] 示例 2： 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] 输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] 提示： 树的","date":"2016-03-04","objectID":"/leetcode/0429/:1:0","tags":null,"title":"0429：N 叉树的层序遍历（★）","uri":"/leetcode/0429/"},{"categories":null,"content":"分析 迭代保存每层的节点即可。 ","date":"2016-03-04","objectID":"/leetcode/0429/:2:0","tags":null,"title":"0429：N 叉树的层序遍历（★）","uri":"/leetcode/0429/"},{"categories":null,"content":"解答 def levelOrder(self, root: 'Node') -\u003e List[List[int]]: if not root: return [] res, Q = [], [root] while level: res.append([node.val for node in Q]) Q = [child for node in Q for child in node.children] return res 52 ms ","date":"2016-03-04","objectID":"/leetcode/0429/:3:0","tags":null,"title":"0429：N 叉树的层序遍历（★）","uri":"/leetcode/0429/"},{"categories":null,"content":"　　在这个没有人类，全由动物构成的大都会里，一只叫尼克的狐狸需要和一位兔子警官朱迪通力合作，揭开颠覆动物世界的巨大危机。不过他们好像并不容易相处……","date":"2016-03-04","objectID":"/anime/zootopia/","tags":null,"title":"疯狂动物城","uri":"/anime/zootopia/"},{"categories":null,"content":"简介 在这个没有人类，全由动物构成的大都会里，一只叫尼克的狐狸需要和一位兔子警官朱迪通力合作，揭开颠覆动物世界的巨大危机。不过他们好像并不容易相处…… 制作人员： 导演：拜伦·霍华德、里奇·摩尔 音乐：迈克·吉亚奇诺 人物设定：Jin Kim 原案：珍妮佛·李、Jim Reardon、Jared Bush ","date":"2016-03-04","objectID":"/anime/zootopia/:1:0","tags":null,"title":"疯狂动物城","uri":"/anime/zootopia/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 尼克·王尔德 狐尼克、Nicholas Piberius Wilde 男 Jason Kent Bateman 2 朱迪·霍普斯 兔朱迪、Officer Judy Hopps 女 Ginnifer Goodwin 3 闪电 Flash 男 Raymond S. Persi 4 杜克·威斯顿 雄 Alan Tudyk 5 大先生 雄 Maurice LaMarche 6 Priscilla 雌 Kristen Bell ","date":"2016-03-04","objectID":"/anime/zootopia/:2:0","tags":null,"title":"疯狂动物城","uri":"/anime/zootopia/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 疯狂动物城 2016-03-04 108分钟 樱花 ","date":"2016-03-04","objectID":"/anime/zootopia/:3:0","tags":null,"title":"疯狂动物城","uri":"/anime/zootopia/"},{"categories":null,"content":" 力扣第 427 题 ","date":"2016-03-02","objectID":"/leetcode/0427/:0:0","tags":null,"title":"0427：建立四叉树（★）","uri":"/leetcode/0427/"},{"categories":null,"content":"题目 给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。 你需要返回能表示矩阵的 四叉树 的根结点。 注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。 四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性： val：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False； isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。 class Node { public boolean v","date":"2016-03-02","objectID":"/leetcode/0427/:1:0","tags":null,"title":"0427：建立四叉树（★）","uri":"/leetcode/0427/"},{"categories":null,"content":"分析 递归构造即可。 ","date":"2016-03-02","objectID":"/leetcode/0427/:2:0","tags":null,"title":"0427：建立四叉树（★）","uri":"/leetcode/0427/"},{"categories":null,"content":"解答 def construct(self, grid: List[List[int]]) -\u003e 'Node': def dfs(x, y, n): if n==1: return Node(grid[x][y], 1, None, None, None, None) n //= 2 tL, tR = dfs(x, y, n), dfs(x, y+n, n) bL, bR = dfs(x+n, y, n), dfs(x+n, y+n, n) if tL.val==tR.val==bL.val==bR.val!=-1: return Node(tL.val, 1, None, None, Non","date":"2016-03-02","objectID":"/leetcode/0427/:3:0","tags":null,"title":"0427：建立四叉树（★）","uri":"/leetcode/0427/"},{"categories":null,"content":" 力扣第 426 题 ","date":"2016-03-01","objectID":"/leetcode/0426/:0:0","tags":null,"title":"0426：将二叉搜索树转化为排序的双向链表（★）","uri":"/leetcode/0426/"},{"categories":null,"content":"题目 将一个 二叉搜索树 就地转化为一个 已排序的双向循环链表 。 对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 特别地，我们希望可以 就地 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。 示例 1： 输入：root = [4,2,5,1,3] 输出：[1,2,3,4,5] 解释：下图显示了转化后的二叉搜索树，实线表示后继关系，虚线表示前驱关系。 示例 2： 输入：root = [2,1,3] 输出：[1,2,3] 示例 3： ","date":"2016-03-01","objectID":"/leetcode/0426/:1:0","tags":null,"title":"0426：将二叉搜索树转化为排序的双向链表（★）","uri":"/leetcode/0426/"},{"categories":null,"content":"分析 先设一个哑节点，然后中序遍历二叉搜索树，依次插入到链表即可。 ","date":"2016-03-01","objectID":"/leetcode/0426/:2:0","tags":null,"title":"0426：将二叉搜索树转化为排序的双向链表（★）","uri":"/leetcode/0426/"},{"categories":null,"content":"解答 def treeToDoublyList(self, root: 'Node') -\u003e 'Node': if not root: return None dummy = p = Node(0) stack = [(root, 0)] while stack: node, flag = stack.pop() if flag: p.right = node node.left = p p = node elif node: stack.extend([(node.right, 0), (node, 1), (node.left, 0)]) p.right = dummy.right dum","date":"2016-03-01","objectID":"/leetcode/0426/:3:0","tags":null,"title":"0426：将二叉搜索树转化为排序的双向链表（★）","uri":"/leetcode/0426/"},{"categories":null,"content":" 力扣第 423 题 ","date":"2016-02-27","objectID":"/leetcode/0423/:0:0","tags":null,"title":"0423：从英文中重建数字（★）","uri":"/leetcode/0423/"},{"categories":null,"content":"题目 给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。 示例 1： 输入：s = \"owoztneoer\" 输出：\"012\" 示例 2： 输入：s = \"fviefuro\" 输出：\"45\" 提示： 1 \u003c= s.length \u003c= 105 s[i] 为 [\"e\",\"g\",\"f\",\"i\",\"h\",\"o\",\"n\",\"s\",\"r\",\"u\",\"t\",\"w\",\"v\",\"x\",\"z\"] 这些字符之一 s 保证是一个符合题目要求的字符串 ","date":"2016-02-27","objectID":"/leetcode/0423/:1:0","tags":null,"title":"0423：从英文中重建数字（★）","uri":"/leetcode/0423/"},{"categories":null,"content":"分析 可以假设每个数字的个数，得到一个联立方程组，求解即可。 例如只有 ‘0’ 的英文里含有 ‘z’ 字母，故 s 中 ‘z’ 的个数即是原本 ‘0’ 的个数。 ","date":"2016-02-27","objectID":"/leetcode/0423/:2:0","tags":null,"title":"0423：从英文中重建数字（★）","uri":"/leetcode/0423/"},{"categories":null,"content":"解答 def originalDigits(self, s: str) -\u003e str: res, ct = [0]*10, Counter(s) res[0] = ct['z'] res[2] = ct['w'] res[4] = ct['u'] res[6] = ct['x'] res[8] = ct['g'] res[5] = ct['f'] - res[4] res[7] = ct['s'] - res[6] res[1] = ct['o'] - res[0] - res[2] - res[4] res[3] = ct['t'] - res[2] - res[8] res[9] = ct","date":"2016-02-27","objectID":"/leetcode/0423/:3:0","tags":null,"title":"0423：从英文中重建数字（★）","uri":"/leetcode/0423/"},{"categories":null,"content":" 力扣第 422 题 ","date":"2016-02-26","objectID":"/leetcode/0422/:0:0","tags":null,"title":"0422：有效的单词方块","uri":"/leetcode/0422/"},{"categories":null,"content":"题目 给你一个单词序列，判断其是否形成了一个有效的单词方块。 有效的单词方块是指此由单词序列组成的文字方块的 第 k 行 和 第 k 列 (0 ≤ k \u003c max(行数, 列数)) 所显示的字符串完全相同。 注意： 给定的单词数大于等于 1 且不超过 500。 单词长度大于等于 1 且不超过 500。 每个单词只包含小写英文字母 a-z。 示例 1： 输入： [ \"abcd\", \"bnrt\", \"crmy\", \"dtye\" ] 输出： true 解释： 第 1 行和第 1 列都是 \"abcd\"。 第 2 行和第 2 列都是 \"bnrt\"。 第 3 行和第 3 列都是 \"crmy\"。 第 4 行","date":"2016-02-26","objectID":"/leetcode/0422/:1:0","tags":null,"title":"0422：有效的单词方块","uri":"/leetcode/0422/"},{"categories":null,"content":"分析 模拟判断即可。python 可以用 zip_longest 方便地提取每列。 ","date":"2016-02-26","objectID":"/leetcode/0422/:2:0","tags":null,"title":"0422：有效的单词方块","uri":"/leetcode/0422/"},{"categories":null,"content":"解答 def validWordSquare(self, words: List[str]) -\u003e bool: return all(a==''.join(b) for a, b in zip(words, zip_longest(*words, fillvalue=''))) 48 ms ","date":"2016-02-26","objectID":"/leetcode/0422/:3:0","tags":null,"title":"0422：有效的单词方块","uri":"/leetcode/0422/"},{"categories":null,"content":" 力扣第 420 题 ","date":"2016-02-24","objectID":"/leetcode/0420/:0:0","tags":null,"title":"0420：强密码检验器（★★★）","uri":"/leetcode/0420/"},{"categories":null,"content":"题目 满足以下条件的密码被认为是强密码： 由至少 6 个，至多 20 个字符组成。 包含至少 一个小写 字母，至少 一个大写 字母，和至少 一个数字 。 不包含连续三个重复字符 (比如 \"Baaabb0\" 是弱密码, 但是 \"Baaba0\" 是强密码)。 给你一个字符串 password ，返回 将 password 修改到满足强密码条件需要的最少修改步数。如果 password 已经是强密码，则返回 0 。 在一步修改操作中，你可以： 插入一个字符到 password ， 从 password 中删除一个字符，或 用另一个字符来替换 password 中的某个字符。 示例 1： 输入：pas","date":"2016-02-24","objectID":"/leetcode/0420/:1:0","tags":null,"title":"0420：强密码检验器（★★★）","uri":"/leetcode/0420/"},{"categories":null,"content":"分析 先得到必须补充的字符个数 lack，然后按密码长度 n 分类讨论： n\u003c6，可以再按 n==5 和 n\u003c5 分类考虑，结果都满足 max(6-n, lack) 6\u003c=n\u003c=20，对于任一连续段长度 a，用 a//3 步替换操作即可满足条件“同一字符不连续出现三次 ”，最后取 max(替换操作, lack)即可。 n\u003e20，必须进行删除操作。 优先删除连续段的字符，而且优先删除长度 a%3==0 的连续段，从而减少之后的替换操作。 于是考虑用堆，每轮选 a%3 最小的 a 进行删除操作，直到没有连续段长度 \u003e=3 或 n==20 为止。 删除完成后，就转为上一情况了。 ","date":"2016-02-24","objectID":"/leetcode/0420/:2:0","tags":null,"title":"0420：强密码检验器（★★★）","uri":"/leetcode/0420/"},{"categories":null,"content":"解答 def strongPasswordChecker(self, password: str) -\u003e int: n = len(password) lack = 3 - sum(bool(re.search(reg, password)) for reg in ['[a-z]', '[A-Z]', '[0-9]']) if n \u003c 6: return max(6-n, lack) pq = [] for _, g in groupby(password): a = len(list(g)) if a\u003e=3: heappush(pq, (a%3, a)) res = 0 while pq a","date":"2016-02-24","objectID":"/leetcode/0420/:3:0","tags":null,"title":"0420：强密码检验器（★★★）","uri":"/leetcode/0420/"},{"categories":null,"content":" 力扣第 419 题 ","date":"2016-02-23","objectID":"/leetcode/0419/:0:0","tags":null,"title":"0419：甲板上的战舰（★）","uri":"/leetcode/0419/"},{"categories":null,"content":"题目 给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。 战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。 示例 1： 输入：board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]] 输出：2 示例 2： 输入：board ","date":"2016-02-23","objectID":"/leetcode/0419/:1:0","tags":null,"title":"0419：甲板上的战舰（★）","uri":"/leetcode/0419/"},{"categories":null,"content":"分析 类似 0200 岛屿问题，不过这里战舰只能是长方形，所以遍历找到左上顶点即可。 ","date":"2016-02-23","objectID":"/leetcode/0419/:2:0","tags":null,"title":"0419：甲板上的战舰（★）","uri":"/leetcode/0419/"},{"categories":null,"content":"解答 def countBattleships(self, board: List[List[str]]) -\u003e int: res, A = 0, board m, n = len(A), len(A[0]) for i, j in product(range(m), range(n)): if A[i][j]=='X' and (i==0 or A[i-1][j]=='.') and (j==0 or A[i][j-1]=='.'): res += 1 return res 36 ms ","date":"2016-02-23","objectID":"/leetcode/0419/:3:0","tags":null,"title":"0419：甲板上的战舰（★）","uri":"/leetcode/0419/"},{"categories":null,"content":" 力扣第 417 题 ","date":"2016-02-21","objectID":"/leetcode/0417/:0:0","tags":null,"title":"0417：太平洋大西洋水流问题（★★）","uri":"/leetcode/0417/"},{"categories":null,"content":"题目 有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。 这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。 岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。 返回网格坐标 result 的 2D 列表 ，其中 result[i] = [ri, ci] 表示雨水从单元格 (","date":"2016-02-21","objectID":"/leetcode/0417/:1:0","tags":null,"title":"0417：太平洋大西洋水流问题（★★）","uri":"/leetcode/0417/"},{"categories":null,"content":"分析 从每个单元格开始遍历，显然会有很多重复。因此考虑反过来，从边界往里面遍历。多源 dfs/bfs 分别求出太平洋/大西洋对应的格子列表，求交集即可。 ","date":"2016-02-21","objectID":"/leetcode/0417/:2:0","tags":null,"title":"0417：太平洋大西洋水流问题（★★）","uri":"/leetcode/0417/"},{"categories":null,"content":"解答 def pacificAtlantic(self, heights: List[List[int]]) -\u003e List[List[int]]: def bfs(A): Q, vis = deque(A), set(A) while Q: r,c = Q.popleft() for x,y in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]: if 0\u003c=x\u003cm and 0\u003c=y\u003cn and heights[x][y]\u003e=heights[r][c] and (x,y) not in vis: Q.append((x, y)) vis.add((x, y)) retur","date":"2016-02-21","objectID":"/leetcode/0417/:3:0","tags":null,"title":"0417：太平洋大西洋水流问题（★★）","uri":"/leetcode/0417/"},{"categories":null,"content":" 力扣第 416 题 ","date":"2016-02-20","objectID":"/leetcode/0416/:0:0","tags":null,"title":"0416：分割等和子集（★）","uri":"/leetcode/0416/"},{"categories":null,"content":"题目 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2： 输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 提示： 1 \u003c= nums.length \u003c= 200 1 \u003c= nums[i] \u003c= 100 ","date":"2016-02-20","objectID":"/leetcode/0416/:1:0","tags":null,"title":"0416：分割等和子集（★）","uri":"/leetcode/0416/"},{"categories":null,"content":"分析 ","date":"2016-02-20","objectID":"/leetcode/0416/:2:0","tags":null,"title":"0416：分割等和子集（★）","uri":"/leetcode/0416/"},{"categories":null,"content":"#1 令 s=sum(nums)。 s 为奇数时显然无解 s 为偶数时，问题等价于分割成子集和为 s//2 注意到 s//2 最大为 10^4，于是考虑递推 nums[:i] 能得到的所有子集和。 令 dp[i] 代表nums[:i] 能得到的所有 \u003c=s//2 的子集和，那么 $$dp[i] = dp[i-1] \\ | \\ \\{x+nums[i-1] \\}_ {\\substack{x \\in dp[i-1] \\\\ if \\ x+nums[i-1]\u003c=s//2} }$$ 只要递推过程中找到 s//2 即为真。 def canPartition(self, nums: List[int]) -\u003e","date":"2016-02-20","objectID":"/leetcode/0416/:2:1","tags":null,"title":"0416：分割等和子集（★）","uri":"/leetcode/0416/"},{"categories":null,"content":"#2 还有个巧妙的想法，可以将集合状态压缩为一个数 st，然后集合内所有数加上 num 得到的集合即是 st«num。 这样显著优化了递推的时间。 ","date":"2016-02-20","objectID":"/leetcode/0416/:2:2","tags":null,"title":"0416：分割等和子集（★）","uri":"/leetcode/0416/"},{"categories":null,"content":"解答 def canPartition(self, nums: List[int]) -\u003e bool: s = sum(nums) if s % 2: return False st = 1 for num in nums: st |= st \u003c\u003c num if st \u0026 (1 \u003c\u003c (s//2)): return True return False 24 ms ","date":"2016-02-20","objectID":"/leetcode/0416/:3:0","tags":null,"title":"0416：分割等和子集（★）","uri":"/leetcode/0416/"},{"categories":null,"content":" 力扣第 415 题 ","date":"2016-02-19","objectID":"/leetcode/0415/:0:0","tags":null,"title":"0415：字符串相加","uri":"/leetcode/0415/"},{"categories":null,"content":"题目 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。 你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。 示例 1： 输入：num1 = \"11\", num2 = \"123\" 输出：\"134\" 示例 2： 输入：num1 = \"456\", num2 = \"77\" 输出：\"533\" 示例 3： 输入：num1 = \"0\", num2 = \"0\" 输出：\"0\" 提示： 1 \u003c= num1.length, num2.length \u003c= 104 num1 和num2 都只包含数字 0-9 num1","date":"2016-02-19","objectID":"/leetcode/0415/:1:0","tags":null,"title":"0415：字符串相加","uri":"/leetcode/0415/"},{"categories":null,"content":"分析 和 0067 类似，将除数换成 10 即可。 ","date":"2016-02-19","objectID":"/leetcode/0415/:2:0","tags":null,"title":"0415：字符串相加","uri":"/leetcode/0415/"},{"categories":null,"content":"解答 def addStrings(self, num1: str, num2: str) -\u003e str: res, carry, i, j = '', 0, len(num1)-1, len(num2)-1 while i\u003e=0 or j\u003e=0 or carry: x = int(num1[i]) if i\u003e=0 else 0 y = int(num2[j]) if j\u003e=0 else 0 carry, r = divmod(x+y+carry, 10) res += str(r) i -= 1 j -= 1 return res[::-1] 40 ms ","date":"2016-02-19","objectID":"/leetcode/0415/:3:0","tags":null,"title":"0415：字符串相加","uri":"/leetcode/0415/"},{"categories":null,"content":" 力扣第 414 题 ","date":"2016-02-18","objectID":"/leetcode/0414/:0:0","tags":null,"title":"0414：第三大的数","uri":"/leetcode/0414/"},{"categories":null,"content":"题目 给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。 示例 1： 输入：[3, 2, 1] 输出：1 解释：第三大的数是 1 。 示例 2： 输入：[1, 2] 输出：2 解释：第三大的数不存在, 所以返回最大的数 2 。 示例 3： 输入：[2, 2, 3, 1] 输出：1 解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。 此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。 提示： 1 \u003c= nums.length \u003c= 104 -231 \u003c= nums[i] \u003c= 231 - 1 进阶：你能设计一个时间复杂","date":"2016-02-18","objectID":"/leetcode/0414/:1:0","tags":null,"title":"0414：第三大的数","uri":"/leetcode/0414/"},{"categories":null,"content":"分析 要求 O(N)，用堆维护前三大的数值即可。 ","date":"2016-02-18","objectID":"/leetcode/0414/:2:0","tags":null,"title":"0414：第三大的数","uri":"/leetcode/0414/"},{"categories":null,"content":"解答 def thirdMax(self, nums: List[int]) -\u003e int: A = nlargest(3, set(nums)) return A[2] if len(A)\u003e=3 else A[0] 36 ms ","date":"2016-02-18","objectID":"/leetcode/0414/:3:0","tags":null,"title":"0414：第三大的数","uri":"/leetcode/0414/"},{"categories":null,"content":" 力扣第 413 题 ","date":"2016-02-17","objectID":"/leetcode/0413/:0:0","tags":null,"title":"0413：等差数列划分（★）","uri":"/leetcode/0413/"},{"categories":null,"content":"题目 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。 给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。 子数组 是数组中的一个连续序列。 示例 1： 输入：nums = [1,2,3,4] 输出：3 解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。 示例 2： 输入：nums = [1] 输出：0 提示： 1 \u003c= nums.length \u003c= 5000 -1000 \u003c","date":"2016-02-17","objectID":"/leetcode/0413/:1:0","tags":null,"title":"0413：等差数列划分（★）","uri":"/leetcode/0413/"},{"categories":null,"content":"分析 令 dp[i] 代表以 i 结尾的等差子数组个数，那么： $$dp[i] = \\begin{cases} dp[i-1]+1 \u0026\\text{if } nums[i]-nums[i-1] \\\\ \u0026== nums[i-1]-nums[i-2] \\\\ 0 \u0026\\text{else } \\end{cases}$$ 最后 sum(dp) 即为所求。 ","date":"2016-02-17","objectID":"/leetcode/0413/:2:0","tags":null,"title":"0413：等差数列划分（★）","uri":"/leetcode/0413/"},{"categories":null,"content":"解答 def numberOfArithmeticSlices(self, nums: List[int]) -\u003e int: n = len(nums) dp = [0]*n for i in range(2, n): dp[i] = dp[i-1]+1 if 2*nums[i-1]==nums[i]+nums[i-2] else 0 return sum(dp) 40 ms ","date":"2016-02-17","objectID":"/leetcode/0413/:3:0","tags":null,"title":"0413：等差数列划分（★）","uri":"/leetcode/0413/"},{"categories":null,"content":" 力扣第 412 题 ","date":"2016-02-16","objectID":"/leetcode/0412/:0:0","tags":null,"title":"0412：Fizz Buzz","uri":"/leetcode/0412/"},{"categories":null,"content":"题目 给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中： answer[i] == \"FizzBuzz\" 如果 i 同时是 3 和 5 的倍数。 answer[i] == \"Fizz\" 如果 i 是 3 的倍数。 answer[i] == \"Buzz\" 如果 i 是 5 的倍数。 answer[i] == i （以字符串形式）如果上述条件全不满足。 示例 1： 输入：n = 3 输出：[\"1\",\"2\",\"Fizz\"] 示例 2： 输入：n = 5 输出：[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz","date":"2016-02-16","objectID":"/leetcode/0412/:1:0","tags":null,"title":"0412：Fizz Buzz","uri":"/leetcode/0412/"},{"categories":null,"content":"分析 模拟即可。 ","date":"2016-02-16","objectID":"/leetcode/0412/:2:0","tags":null,"title":"0412：Fizz Buzz","uri":"/leetcode/0412/"},{"categories":null,"content":"解答 def fizzBuzz(self, n: int) -\u003e List[str]: return [('Fizz'*(x%3==0)+'Buzz'*(x%5==0)) or str(x) for x in range(1, n+1)] 32 ms ","date":"2016-02-16","objectID":"/leetcode/0412/:3:0","tags":null,"title":"0412：Fizz Buzz","uri":"/leetcode/0412/"},{"categories":null,"content":" 力扣第 410 题 ","date":"2016-02-14","objectID":"/leetcode/0410/:0:0","tags":null,"title":"0410：分割数组的最大值（★★）","uri":"/leetcode/0410/"},{"categories":null,"content":"题目 给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m 个非空的连续子数组。 设计一个算法使得这 m 个子数组各自和的最大值最小。 示例 1： 输入：nums = [7,2,5,10,8], m = 2 输出：18 解释： 一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 示例 2： 输入：nums = [1,2,3,4,5], m = 2 输出：9 示例 3： 输入：nums = [1,4,4], m = 3 输出：4 提示： 1 \u003c= ","date":"2016-02-14","objectID":"/leetcode/0410/:1:0","tags":null,"title":"0410：分割数组的最大值（★★）","uri":"/leetcode/0410/"},{"categories":null,"content":"分析 直接分割很难入手，一个想法是假如给定和的限制，那么贪心地选择分割点即可。 因此想到对解用二分查找。假如最后的解是 x： 针对所有 y\u003cx，无法将数组分成 m 个和 \u003c=y 的子数组 针对所有 y\u003e=x，可以将数组分成 m 个和 \u003c=y 的子数组 因此可以对解用二分查找。 ","date":"2016-02-14","objectID":"/leetcode/0410/:2:0","tags":null,"title":"0410：分割数组的最大值（★★）","uri":"/leetcode/0410/"},{"categories":null,"content":"解答 def splitArray(self, nums: List[int], k: int) -\u003e int: def check(x): s, cnt = 0, 1 for num in nums: s += num if s \u003e x: cnt += 1 s = num return cnt \u003c= k self.__class__.__getitem__ = lambda self, x: check(x) return bisect_left(self, True, max(nums), sum(nums)) 32 ms ","date":"2016-02-14","objectID":"/leetcode/0410/:3:0","tags":null,"title":"0410：分割数组的最大值（★★）","uri":"/leetcode/0410/"},{"categories":null,"content":" 力扣第 409 题 ","date":"2016-02-13","objectID":"/leetcode/0409/:0:0","tags":null,"title":"0409：最长回文串","uri":"/leetcode/0409/"},{"categories":null,"content":"题目 给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。 在构造过程中，请注意 区分大小写 。比如 \"Aa\" 不能当做一个回文字符串。 示例 1: 输入:s = \"abccccdd\" 输出:7 解释: 我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。 示例 2: 输入:s = \"a\" 输出:1 示例 3： 输入:s = \"aaaaaccc\" 输出:7 提示: 1 \u003c= s.length \u003c= 2000 s 只由小写 和/或 大写英文字母组成 ","date":"2016-02-13","objectID":"/leetcode/0409/:1:0","tags":null,"title":"0409：最长回文串","uri":"/leetcode/0409/"},{"categories":null,"content":"分析 分情况讨论： 如果字符的出现次数是偶数，都能用上 如果次数是奇数，多余的那个只能作为回文串中心 如果多个字符的出现次数都是奇数，只能选一个多余的作为回文串中心，剩下的都是真正多余的 因此统计出现次数为奇数的字符个数 k，多余的个数即为 max(0, k-1)。 ","date":"2016-02-13","objectID":"/leetcode/0409/:2:0","tags":null,"title":"0409：最长回文串","uri":"/leetcode/0409/"},{"categories":null,"content":"解答 def longestPalindrome(self, s: str) -\u003e int: return len(s) - max(0, sum(v % 2 for v in Counter(s).values())-1) 36 ms ","date":"2016-02-13","objectID":"/leetcode/0409/:3:0","tags":null,"title":"0409：最长回文串","uri":"/leetcode/0409/"},{"categories":null,"content":" 力扣第 408 题 ","date":"2016-02-12","objectID":"/leetcode/0408/:0:0","tags":null,"title":"0408：有效单词缩写","uri":"/leetcode/0408/"},{"categories":null,"content":"题目 字符串可以用 缩写 进行表示，缩写 的方法是将任意数量的 不相邻 的子字符串替换为相应子串的长度。例如，字符串 \"substitution\" 可以缩写为（不止这几种方法）： \"s10n\" (\"s ubstitutio n\") \"sub4u4\" (\"sub stit u tion\") \"12\" (\"substitution\") \"su3i1u2on\" (\"su bst i t u ti on\") \"substitution\" (没有替换子字符串) 下列是不合法的缩写： \"s55n\" (\"s ubsti tutio n\"，两处缩写相邻) \"s010n\" (缩写存在前导零) \"s0ubstit","date":"2016-02-12","objectID":"/leetcode/0408/:1:0","tags":null,"title":"0408：有效单词缩写","uri":"/leetcode/0408/"},{"categories":null,"content":"分析 提取出缩写中的字母和数字，字母必须相同，数字就跳过对应位数即可。 ","date":"2016-02-12","objectID":"/leetcode/0408/:2:0","tags":null,"title":"0408：有效单词缩写","uri":"/leetcode/0408/"},{"categories":null,"content":"解答 def validWordAbbreviation(self, word: str, abbr: str) -\u003e bool: j, n = 0, len(word) for char, num in re.findall('([a-z])|(\\d+)', abbr): if char: if j \u003e= n or char != word[j]: return False j += 1 elif num[0]=='0': return False else: j += int(num) return j == n 24 ms ","date":"2016-02-12","objectID":"/leetcode/0408/:3:0","tags":null,"title":"0408：有效单词缩写","uri":"/leetcode/0408/"},{"categories":null,"content":" 力扣第 407 题 ","date":"2016-02-11","objectID":"/leetcode/0407/:0:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":"题目 给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。 示例 1: 输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] 输出: 4 解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。 示例 2: 输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]] 输出: 10 提示: m == heightMap.length n == heig","date":"2016-02-11","objectID":"/leetcode/0407/:1:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":"分析 对于每个位置： 如果有一外圈的柱子都更高，那么该位置就能接到雨水，并且至少接到（该外圈的最矮柱子高度 H - 当前高度 h）的雨水。 找到使 H 最大的外圈，就得到该位置总共能接到的雨水 maxH - h。 显然遍历所有外圈太耗时了，有个巧妙的想法是从最外圈开始： 假设最矮柱子 A 高度 H，那么相邻内侧位置 B 能接到的雨水就是 max(0, H - B的高度)。 然后可以将位置 A 替换成位置 B，并更新 B 的高度为 max(H, h)，得到一个缩小一格的新外圈，显然不影响里面位置的结果。 这样遍历逐步缩小的外圈即可得到所有位置能接到的雨水。 具体实现时： 可以用小顶堆维护外圈的高","date":"2016-02-11","objectID":"/leetcode/0407/:2:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":"解答 def trapRainWater(self, heightMap: List[List[int]]) -\u003e int: pq, H = [], heightMap m, n = len(H), len(H[0]) for i, j in product(range(m), range(n)): if i in [0, m-1] or j in [0, n-1]: heappush(pq, [H[i][j], i, j]) H[i][j] = -1 res = 0 while pq: h, i, j = heappop(pq) for x, y in [(i+1, j), (i-1, j)","date":"2016-02-11","objectID":"/leetcode/0407/:3:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":"*附加 还有个巧妙的并查集做法。 先考虑简化问题：有哪些格子能接到高度为 1 的雨水？ 将高度小于 1 的格子标记为 ‘O’，其它格子都看作 ‘X’，显然只有被 ‘X’ 围绕的 ‘O’ 才能接到高度 1 的雨水。 这类似于问题 0130，可以用并查集解决。 将边界上的 ‘O’ 都与一个哑节点 dummy 连通，再将所有相邻的 ‘O’ 连通。最终所有与 dummy 连通的即是不被围绕的 ‘O’。 同理，对于高度 2： 将高度小于 2 的格子标记为 ‘O’，即可求出哪些格子能接到高度为 2 的雨水。 注意到前一步被标记为 ‘O’ 的格子无需改变，只需要将高度为 1 的格子标记为 ‘O’ 即可。 因","date":"2016-02-11","objectID":"/leetcode/0407/:4:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":" 力扣第 406 题 ","date":"2016-02-10","objectID":"/leetcode/0406/:0:0","tags":null,"title":"0406：根据身高重建队列（★★）","uri":"/leetcode/0406/"},{"categories":null,"content":"题目 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5","date":"2016-02-10","objectID":"/leetcode/0406/:1:0","tags":null,"title":"0406：根据身高重建队列（★★）","uri":"/leetcode/0406/"},{"categories":null,"content":"分析 构造类题目先考虑极端情况： 假设最高 h0 且唯一，显然他的属性必然为 [h0, 0]，且可以随意安排 假设 h0 不唯一，那么这些人的属性必然为 [h0, 0], [h0, 1], [h0, 2], …, 并依此顺序 然后假设次高 h1 且唯一，他的属性为 [h1,k]，显然他应该插入到第 k 个 h0 之后 依此类推，即可构造出结果 实现时，将数组按 \u003c-hi,ki\u003e 排序，遍历并插入即可。 ","date":"2016-02-10","objectID":"/leetcode/0406/:2:0","tags":null,"title":"0406：根据身高重建队列（★★）","uri":"/leetcode/0406/"},{"categories":null,"content":"解答 def reconstructQueue(self, people: List[List[int]]) -\u003e List[List[int]]: res = [] for p in sorted(people, key=lambda x: (-x[0], x[1])): res.insert(p[1], p) return res 48 ms ","date":"2016-02-10","objectID":"/leetcode/0406/:3:0","tags":null,"title":"0406：根据身高重建队列（★★）","uri":"/leetcode/0406/"},{"categories":null,"content":" 力扣第 405 题 ","date":"2016-02-09","objectID":"/leetcode/0405/:0:0","tags":null,"title":"0405：数字转换为十六进制数","uri":"/leetcode/0405/"},{"categories":null,"content":"题目 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 示例 1： 输入: 26 输出: \"1a\" 示例 2： 输入: -1 输出: \"ffffffff\" ","date":"2016-02-09","objectID":"/leetcode/0405/:1:0","tags":null,"title":"0405：数字转换为十六进制数","uri":"/leetcode/0405/"},{"categories":null,"content":"分析 ","date":"2016-02-09","objectID":"/leetcode/0405/:2:0","tags":null,"title":"0405：数字转换为十六进制数","uri":"/leetcode/0405/"},{"categories":null,"content":"#1 最简单的就是调库 def toHex(self, num: int) -\u003e str: return hex(num%(1\u003c\u003c32))[2:] 44 ms ","date":"2016-02-09","objectID":"/leetcode/0405/:2:1","tags":null,"title":"0405：数字转换为十六进制数","uri":"/leetcode/0405/"},{"categories":null,"content":"#2 也可以模拟进制转换的方法。 注意 num 为 0 时的特殊情况 ","date":"2016-02-09","objectID":"/leetcode/0405/:2:2","tags":null,"title":"0405：数字转换为十六进制数","uri":"/leetcode/0405/"},{"categories":null,"content":"解答 def toHex(self, num: int) -\u003e str: num %= 1\u003c\u003c32 res, s = '', '0123456789abcdef' while num: res = s[num%16]+res num //= 16 return res if res else '0' 44 ms ","date":"2016-02-09","objectID":"/leetcode/0405/:3:0","tags":null,"title":"0405：数字转换为十六进制数","uri":"/leetcode/0405/"},{"categories":null,"content":" 力扣第 404 题 ","date":"2016-02-08","objectID":"/leetcode/0404/:0:0","tags":null,"title":"0404：左叶子之和","uri":"/leetcode/0404/"},{"categories":null,"content":"题目 给定二叉树的根节点 root ，返回所有左叶子之和。 示例 1： 输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 输入: root = [1] 输出: 0 提示: 节点数在 [1, 1000] 范围内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2016-02-08","objectID":"/leetcode/0404/:1:0","tags":null,"title":"0404：左叶子之和","uri":"/leetcode/0404/"},{"categories":null,"content":"分析 遍历时标记节点是左孩子还是右孩子即可。也可以用递归。 ","date":"2016-02-08","objectID":"/leetcode/0404/:2:0","tags":null,"title":"0404：左叶子之和","uri":"/leetcode/0404/"},{"categories":null,"content":"解答 def sumOfLeftLeaves(self, root: Optional[TreeNode]) -\u003e int: res, stack = 0, [(root, 1)] while stack: node, flag = stack.pop() if node: if not node.left and not node.right and flag == 0: res += node.val stack.extend([(node.left, 0), (node.right, 1)]) return res 36 ms ","date":"2016-02-08","objectID":"/leetcode/0404/:3:0","tags":null,"title":"0404：左叶子之和","uri":"/leetcode/0404/"},{"categories":null,"content":" 力扣第 403 题 ","date":"2016-02-07","objectID":"/leetcode/0403/:0:0","tags":null,"title":"0403：青蛙过河（★★）","uri":"/leetcode/0403/"},{"categories":null,"content":"题目 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。 给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。 示例 1： 输入：stones = [0,","date":"2016-02-07","objectID":"/leetcode/0403/:1:0","tags":null,"title":"0403：青蛙过河（★★）","uri":"/leetcode/0403/"},{"categories":null,"content":"分析 典型的递归问题。令 dfs(i, k) 代表上一步跳跃 k 位到达位置 i 的情况下能否过河，即可递归。 注意有重复子问题，所以用记忆化递归。 ","date":"2016-02-07","objectID":"/leetcode/0403/:2:0","tags":null,"title":"0403：青蛙过河（★★）","uri":"/leetcode/0403/"},{"categories":null,"content":"解答 def canCross(self, stones: List[int]) -\u003e bool: @cache def dfs(i, k): if i == last: return True return any(dfs(i+j, j) for j in [k-1, k, k+1] if i\u003ci+j\u003c=last and i+j in vis) vis, last = set(stones), stones[-1] return dfs(0, 0) 36 ms ","date":"2016-02-07","objectID":"/leetcode/0403/:3:0","tags":null,"title":"0403：青蛙过河（★★）","uri":"/leetcode/0403/"},{"categories":null,"content":" 力扣第 402 题 ","date":"2016-02-06","objectID":"/leetcode/0402/:0:0","tags":null,"title":"0402：移掉 K 位数字（★★）","uri":"/leetcode/0402/"},{"categories":null,"content":"题目 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。 示例 1 ： 输入：num = \"1432219\", k = 3 输出：\"1219\" 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。 示例 2 ： 输入：num = \"10200\", k = 1 输出：\"200\" 解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 ： 输入：num = \"10\", k = 2 输出：\"0\" 解释：从原数字移除所有的数字，剩余为空就是 0 。 提示： ","date":"2016-02-06","objectID":"/leetcode/0402/:1:0","tags":null,"title":"0402：移掉 K 位数字（★★）","uri":"/leetcode/0402/"},{"categories":null,"content":"分析 经典的贪心问题： 遍历 num，如果当前数字比上一个数字小，可以移除上一个数字 移除后若还是比上一个数字小，可以继续移除 循环操作，直到当前数字大于等于上一个数字，或者 k 用完了 如果最终 k 还有剩余，说明剩下的数字是升序的，去掉最后几位即可 在遍历过程中，每一步能减小的最高位就是上一位，因此这样得到的数就是最小的。 ","date":"2016-02-06","objectID":"/leetcode/0402/:2:0","tags":null,"title":"0402：移掉 K 位数字（★★）","uri":"/leetcode/0402/"},{"categories":null,"content":"解答 def removeKdigits(self, num: str, k: int) -\u003e str: stack, n = [], len(num)-k for char in num: while k and stack and stack[-1] \u003e char: stack.pop() k -= 1 stack.append(char) return ''.join(stack[:n]).lstrip('0') or '0' 36 ms ","date":"2016-02-06","objectID":"/leetcode/0402/:3:0","tags":null,"title":"0402：移掉 K 位数字（★★）","uri":"/leetcode/0402/"},{"categories":null,"content":" 力扣第 401 题 ","date":"2016-02-05","objectID":"/leetcode/0401/:0:0","tags":null,"title":"0401：二进制手表（★）","uri":"/leetcode/0401/"},{"categories":null,"content":"题目 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。 例如，下面的二进制手表读取 \"3:25\" 。 （图源：WikiMedia - Binary clock samui moon.jpg ，许可协议：Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) ） 给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。 小时不会以零开头： 例如，\"01:00\" 是无效","date":"2016-02-05","objectID":"/leetcode/0401/:1:0","tags":null,"title":"0401：二进制手表（★）","uri":"/leetcode/0401/"},{"categories":null,"content":"分析 数据量较小，因此可以直接遍历所有有效时间，判断对应的 1 的数量是否为 turnedOn 即可 。 ","date":"2016-02-05","objectID":"/leetcode/0401/:2:0","tags":null,"title":"0401：二进制手表（★）","uri":"/leetcode/0401/"},{"categories":null,"content":"解答 def readBinaryWatch(self, turnedOn: int) -\u003e List[str]: return ['%d:%02d' % (h, m) for h in range(12) for m in range(60) if (bin(h)+bin(m)).count('1')==turnedOn] 32 ms ","date":"2016-02-05","objectID":"/leetcode/0401/:3:0","tags":null,"title":"0401：二进制手表（★）","uri":"/leetcode/0401/"},{"categories":null,"content":" 力扣第 400 题 ","date":"2016-02-04","objectID":"/leetcode/0400/:0:0","tags":null,"title":"0400：第 N 位数字（★）","uri":"/leetcode/0400/"},{"categories":null,"content":"题目 给你一个整数 n ，请你在无限的整数序列 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第 n 位上的数字。 示例 1： 输入：n = 3 输出：3 示例 2： 输入：n = 11 输出：0 解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。 提示： 1 \u003c= n \u003c= 231 - 1 ","date":"2016-02-04","objectID":"/leetcode/0400/:1:0","tags":null,"title":"0400：第 N 位数字（★）","uri":"/leetcode/0400/"},{"categories":null,"content":"分析 依次统计发现 [1, 9] 共 1*9 位 [10, 99] 共 2*90 位 [100, 999] 共 3*900 位 。。。 因此可以计算出第 n 位数字对应的是 几位数中的第几个。 ","date":"2016-02-04","objectID":"/leetcode/0400/:2:0","tags":null,"title":"0400：第 N 位数字（★）","uri":"/leetcode/0400/"},{"categories":null,"content":"解答 def findNthDigit(self, n: int) -\u003e int: x, y = 1, 9 while n \u003e x*y: n -= x*y x+=1 y*=10 q, r = divmod(n-1, x) ans = 10**(x-1)+q return int(str(ans)[r]) 24 ms ","date":"2016-02-04","objectID":"/leetcode/0400/:3:0","tags":null,"title":"0400：第 N 位数字（★）","uri":"/leetcode/0400/"},{"categories":null,"content":" 力扣第 399 题 ","date":"2016-02-03","objectID":"/leetcode/0399/:0:0","tags":null,"title":"0399：除法求值（★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"题目 给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。 另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。 返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -","date":"2016-02-03","objectID":"/leetcode/0399/:1:0","tags":null,"title":"0399：除法求值（★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"分析 ","date":"2016-02-03","objectID":"/leetcode/0399/:2:0","tags":null,"title":"0399：除法求值（★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"#1 将等式看作边 (a, b)，value 看作边的权重，同时反向边 (b, a) 的权重为 1/value。 那么问题就相当于找到从 c 到 d 在图中的路径，计算路径的权重乘积。 因为数据规模较小，所以可以对每个问题进行遍历查找，bfs 或 dfs 都可以。 def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -\u003e List[float]: def bfs(c, d): queue, vis = deque([(c, 1.0)]), set() ","date":"2016-02-03","objectID":"/leetcode/0399/:2:1","tags":null,"title":"0399：除法求值（★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"#2 更节省时间的做法是并查集。每个节点维护到父节点的权重，注意路径压缩和合并时都要同步更新。 最终查询 c、d 的比值时，如果 c、d 都出现过且连通，那么 c、d 路径压缩后的权重比值即为所求。 ","date":"2016-02-03","objectID":"/leetcode/0399/:2:2","tags":null,"title":"0399：除法求值（★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"解答 def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -\u003e List[float]: def find(x): if f.setdefault(x, x) != x: root = find(f[x]) w[x] *= w[f[x]] f[x] = root return f[x] def union(x, y, val): root = find(x) f[root] = find(y) w[root] = w[y] * val / w[x] f","date":"2016-02-03","objectID":"/leetcode/0399/:3:0","tags":null,"title":"0399：除法求值（★★）","uri":"/leetcode/0399/"},{"categories":null,"content":" 力扣第 398 题 ","date":"2016-02-02","objectID":"/leetcode/0398/:0:0","tags":null,"title":"0398：随机数索引（★）","uri":"/leetcode/0398/"},{"categories":null,"content":"题目 给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。 实现 Solution 类： Solution(int[] nums) 用数组 nums 初始化对象。 int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。 示例： 输入 [\"Solution\", \"pick\", \"pick\", \"pick\"] [[[1, 2, 3, 3, 3]], [3], [1], [3]] 输出 [","date":"2016-02-02","objectID":"/leetcode/0398/:1:0","tags":null,"title":"0398：随机数索引（★）","uri":"/leetcode/0398/"},{"categories":null,"content":"分析 ","date":"2016-02-02","objectID":"/leetcode/0398/:2:0","tags":null,"title":"0398：随机数索引（★）","uri":"/leetcode/0398/"},{"categories":null,"content":"#1 最简单的就是用哈希表保存每个数对应的索引列表。 class Solution: def __init__(self, nums: List[int]): self.d = defaultdict(list) for i, num in enumerate(nums): self.d[num].append(i) def pick(self, target: int) -\u003e int: return random.choice(self.d[target]) 148 ms ","date":"2016-02-02","objectID":"/leetcode/0398/:2:1","tags":null,"title":"0398：随机数索引（★）","uri":"/leetcode/0398/"},{"categories":null,"content":"#2 要求额外空间小，想到蓄水池抽样。遇到第 cnt 个等于 target 的数时，以 1/cnt 的概率将该数的索引赋值给 res。 ","date":"2016-02-02","objectID":"/leetcode/0398/:2:2","tags":null,"title":"0398：随机数索引（★）","uri":"/leetcode/0398/"},{"categories":null,"content":"解答 class Solution: def __init__(self, nums: List[int]): self.nums = nums def pick(self, target: int) -\u003e int: res, cnt = 0, 0 for i, num in enumerate(self.nums): if num == target: cnt += 1 if random.randint(1, cnt) == cnt: res = i return res 112 ms ","date":"2016-02-02","objectID":"/leetcode/0398/:3:0","tags":null,"title":"0398：随机数索引（★）","uri":"/leetcode/0398/"},{"categories":null,"content":" 力扣第 397 题 ","date":"2016-02-01","objectID":"/leetcode/0397/:0:0","tags":null,"title":"0397：整数替换（★）","uri":"/leetcode/0397/"},{"categories":null,"content":"题目 给定一个正整数 n ，你可以做如下操作： 如果 n 是偶数，则用 n / 2替换 n 。 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。 返回 n 变为 1 所需的 最小替换次数 。 示例 1： 输入：n = 8 输出：3 解释：8 -\u003e 4 -\u003e 2 -\u003e 1 示例 2： 输入：n = 7 输出：4 解释：7 -\u003e 8 -\u003e 4 -\u003e 2 -\u003e 1 或 7 -\u003e 6 -\u003e 3 -\u003e 2 -\u003e 1 示例 3： 输入：n = 4 输出：2 提示： 1 \u003c= n \u003c= 231 - 1 ","date":"2016-02-01","objectID":"/leetcode/0397/:1:0","tags":null,"title":"0397：整数替换（★）","uri":"/leetcode/0397/"},{"categories":null,"content":"分析 显然递归即可。 ","date":"2016-02-01","objectID":"/leetcode/0397/:2:0","tags":null,"title":"0397：整数替换（★）","uri":"/leetcode/0397/"},{"categories":null,"content":"解答 def integerReplacement(self, n: int) -\u003e int: @cache def dfs(n): if n == 1: return 0 if n % 2 == 0: return 1 + dfs(n//2) return 1+min(dfs(n+1), dfs(n-1)) return dfs(n) 24 ms ","date":"2016-02-01","objectID":"/leetcode/0397/:3:0","tags":null,"title":"0397：整数替换（★）","uri":"/leetcode/0397/"},{"categories":null,"content":" 力扣第 396 题 ","date":"2016-01-31","objectID":"/leetcode/0396/:0:0","tags":null,"title":"0396：旋转函数（★）","uri":"/leetcode/0396/"},{"categories":null,"content":"题目 给定一个长度为 n 的整数数组 nums 。 假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数 F 为： F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1] 返回 F(0), F(1), ..., F(n-1)中的最大值 。 生成的测试用例让答案符合 32 位 整数。 示例 1: 输入: nums = [4,3,2,6] 输出: 26 解释: F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 ","date":"2016-01-31","objectID":"/leetcode/0396/:1:0","tags":null,"title":"0396：旋转函数（★）","uri":"/leetcode/0396/"},{"categories":null,"content":"分析 观察发现 F(k) 可以递推： $$F[k] = F[k-1]+sum(A)-len(A)*A[-k]$$ ","date":"2016-01-31","objectID":"/leetcode/0396/:2:0","tags":null,"title":"0396：旋转函数（★）","uri":"/leetcode/0396/"},{"categories":null,"content":"解答 def maxRotateFunction(self, nums: List[int]) -\u003e int: n, s = len(nums), sum(nums) res = f = sum(i*x for i, x in enumerate(nums)) for k in range(1, n): f += s-n*nums[-k] res = max(res, f) return res 320 ms ","date":"2016-01-31","objectID":"/leetcode/0396/:3:0","tags":null,"title":"0396：旋转函数（★）","uri":"/leetcode/0396/"},{"categories":null,"content":" 力扣第 395 题 ","date":"2016-01-30","objectID":"/leetcode/0395/:0:0","tags":null,"title":"0395：至少有 K 个重复字符的最长子串（★★）","uri":"/leetcode/0395/"},{"categories":null,"content":"题目 给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。 示例 1： 输入：s = \"aaabb\", k = 3 输出：3 解释：最长子串为 \"aaa\" ，其中 'a' 重复了 3 次。 示例 2： 输入：s = \"ababbc\", k = 2 输出：5 解释：最长子串为 \"ababb\" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。 提示： 1 \u003c= s.length \u003c= 104 s 仅由小写英文字母组成 1 \u003c= k \u003c= 105 ","date":"2016-01-30","objectID":"/leetcode/0395/:1:0","tags":null,"title":"0395：至少有 K 个重复字符的最长子串（★★）","uri":"/leetcode/0395/"},{"categories":null,"content":"分析 若某字符 char 在 s 中出现的次数小于 k，显然子串就不能含有 char。 所以可以将 s 按 char 分割，转为递归子问题。 ","date":"2016-01-30","objectID":"/leetcode/0395/:2:0","tags":null,"title":"0395：至少有 K 个重复字符的最长子串（★★）","uri":"/leetcode/0395/"},{"categories":null,"content":"解答 def longestSubstring(self, s: str, k: int) -\u003e int: def dfs(s): A = [c for c, freq in Counter(s).items() if freq \u003c k] return len(s) if not A else max(dfs(sub) for sub in re.split('|'.join(A), s)) return dfs(s) 56 ms ","date":"2016-01-30","objectID":"/leetcode/0395/:3:0","tags":null,"title":"0395：至少有 K 个重复字符的最长子串（★★）","uri":"/leetcode/0395/"},{"categories":null,"content":" 力扣第 394 题 ","date":"2016-01-29","objectID":"/leetcode/0394/:0:0","tags":null,"title":"0394：字符串解码（★）","uri":"/leetcode/0394/"},{"categories":null,"content":"题目 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例 1： 输入：s = \"3[a]2[bc]\" 输出：\"aaabcbc\" 示例 2： 输入：s = \"3[a2[c]]\" 输出：\"accaccacc\" 示例 3： 输入：s = \"2[","date":"2016-01-29","objectID":"/leetcode/0394/:1:0","tags":null,"title":"0394：字符串解码（★）","uri":"/leetcode/0394/"},{"categories":null,"content":"分析 显然 s 的编码由子串递归地组成。可以用栈模拟这个过程，一趟解决。 ","date":"2016-01-29","objectID":"/leetcode/0394/:2:0","tags":null,"title":"0394：字符串解码（★）","uri":"/leetcode/0394/"},{"categories":null,"content":"解答 def decodeString(self, s: str) -\u003e str: stack = [[]] for left, sub, right in re.findall(r'(\\[)|([a-z]+|\\d+)|(\\])', s): if left: stack.append([]) elif right: x = ''.join(stack.pop()) stack[-1][-1] = x*int(stack[-1][-1]) else: stack[-1].append(sub) return ''.join(stack[0]) 32 ms ","date":"2016-01-29","objectID":"/leetcode/0394/:3:0","tags":null,"title":"0394：字符串解码（★）","uri":"/leetcode/0394/"},{"categories":null,"content":" 力扣第 393 题 ","date":"2016-01-28","objectID":"/leetcode/0393/:0:0","tags":null,"title":"0393：UTF-8 编码验证（★）","uri":"/leetcode/0393/"},{"categories":null,"content":"题目 给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。 UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。 对于 n 字节 的字符 (n \u003e 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。 这是 UTF-8 编码的工作方式： Number of Bytes | UTF-8 octet sequence | (binary) -----","date":"2016-01-28","objectID":"/leetcode/0393/:1:0","tags":null,"title":"0393：UTF-8 编码验证（★）","uri":"/leetcode/0393/"},{"categories":null,"content":"分析 先取第一个字节，得到第一个字符的长度，然后判断是否符合。再从该字符后的位置循环即可。 ","date":"2016-01-28","objectID":"/leetcode/0393/:2:0","tags":null,"title":"0393：UTF-8 编码验证（★）","uri":"/leetcode/0393/"},{"categories":null,"content":"解答 def validUtf8(self, data: List[int]) -\u003e bool: def cal(num): bits = bin(num\u0026255)[2:].zfill(8) return len(bits.split('0')[0]) i, n = 0, len(data) while i \u003c n: x = cal(data[i]) if x not in [0, 2, 3, 4]: return False x = x or 1 if i+x \u003e n or any(cal(num) != 1 for num in data[i+1:i+x]): return False i","date":"2016-01-28","objectID":"/leetcode/0393/:3:0","tags":null,"title":"0393：UTF-8 编码验证（★）","uri":"/leetcode/0393/"},{"categories":null,"content":" 力扣第 392 题 ","date":"2016-01-27","objectID":"/leetcode/0392/:0:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"题目 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k \u003e= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 致谢： 特别感谢 @pbrother 添加此问题并且创建所有测试用例。 示例 1： 输入：s = \"abc\", t = \"ahbgdc\" 输出：true 示例 2： 输入：s = \"axc\", t ","date":"2016-01-27","objectID":"/leetcode/0392/:1:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"分析 ","date":"2016-01-27","objectID":"/leetcode/0392/:2:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"#1 遍历 s 的每个字符，在剩下的 t 中找第一个位置即可。 def isSubsequence(self, s: str, t: str) -\u003e bool: pos = 0 for char in s: pos = t.find(char, pos) + 1 if not pos: return False return True 24 ms ","date":"2016-01-27","objectID":"/leetcode/0392/:2:1","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"#2 也可以遍历 t，逐步匹配 s。 def isSubsequence(self, s: str, t: str) -\u003e bool: i, n = 0, len(s) for char in t: if i\u003cn and char == s[i]: i += 1 return i==n 40 ms ","date":"2016-01-27","objectID":"/leetcode/0392/:2:2","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"#3 还有种简单的迭代器写法。 ","date":"2016-01-27","objectID":"/leetcode/0392/:2:3","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"解答 def isSubsequence(self, s: str, t: str) -\u003e bool: it = iter(t) return all(c in it for c in s) 40 ms ","date":"2016-01-27","objectID":"/leetcode/0392/:3:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"*附加 如果有大量的 s，考虑保存 t 中字符 x 对应的下标列表，遍历 s 时从下标列表中二分查询即可。 ","date":"2016-01-27","objectID":"/leetcode/0392/:4:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":" 力扣第 391 题 ","date":"2016-01-26","objectID":"/leetcode/0391/:0:0","tags":null,"title":"0391：完美矩形（★★）","uri":"/leetcode/0391/"},{"categories":null,"content":"题目 给你一个数组 rectangles ，其中 rectangles[i] = [xi, yi, ai, bi] 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (xi, yi) ，右上顶点是 (ai, bi) 。 如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。 示例 1： 输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]] 输出：true 解释：5 个矩形一起可以精确地覆盖一个矩形区域。 示例 2： 输入：rectangles = [[1,1,2,3],[1,3,2,","date":"2016-01-26","objectID":"/leetcode/0391/:1:0","tags":null,"title":"0391：完美矩形（★★）","uri":"/leetcode/0391/"},{"categories":null,"content":"分析 精确覆盖即代表没有重叠、没有间隙。考虑根据轮廓线来判断，类似 0218 遍历所有边缘坐标 x，维护还没掠过的高度区间集合，如果该集合精确覆盖一个区间且一直不变，即说明是完美矩形。 在边缘 x 处（除了第一个和最后一个 x），只需要判断新增的区间集合和弹出的区间集合是否等价即可。不需要真的维护整个区间集合。 ","date":"2016-01-26","objectID":"/leetcode/0391/:2:0","tags":null,"title":"0391：完美矩形（★★）","uri":"/leetcode/0391/"},{"categories":null,"content":"解答 def isRectangleCover(self, rectangles: List[List[int]]) -\u003e bool: def merge(A): res = [] for s, e in sorted(A): if not res or res[-1][1] \u003c s: res.append([s, e]) elif res[-1][1] == s: res[-1][1] = e else: return None return res d = defaultdict(list) for x1, y1, x2, y2 in rectangles: d[x1].append((y","date":"2016-01-26","objectID":"/leetcode/0391/:3:0","tags":null,"title":"0391：完美矩形（★★）","uri":"/leetcode/0391/"},{"categories":null,"content":" 力扣第 390 题 ","date":"2016-01-25","objectID":"/leetcode/0390/:0:0","tags":null,"title":"0390：消除游戏（★）","uri":"/leetcode/0390/"},{"categories":null,"content":"题目 列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法： 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。 给你整数 n ，返回 arr 最后剩下的数字。 示例 1： 输入：n = 9 输出：6 解释： arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] arr = [2, 4, 6, 8] arr = [2, 6] arr = [6] 示例 2","date":"2016-01-25","objectID":"/leetcode/0390/:1:0","tags":null,"title":"0390：消除游戏（★）","uri":"/leetcode/0390/"},{"categories":null,"content":"分析 典型的递归。令 dfs(n) 代表长度 n 玩游戏最终剩下的是第几个数字： 设初始数组 A，第一轮后剩下长度为 n//2 的数组 B=A[1::2] 最终数字即是 B 的第 dfs(n//2) 个数字 B[0] 是 A 中第 n//2*2 个数字 最终数字即是 A 的第 n//2 * 2 - 2 * (dfs(n//2)-1) 个数字 ","date":"2016-01-25","objectID":"/leetcode/0390/:2:0","tags":null,"title":"0390：消除游戏（★）","uri":"/leetcode/0390/"},{"categories":null,"content":"解答 def lastRemaining(self, n: int) -\u003e int: return 1 if n==1 else n//2*2-2*(self.lastRemaining(n//2)-1) 52 ms ","date":"2016-01-25","objectID":"/leetcode/0390/:3:0","tags":null,"title":"0390：消除游戏（★）","uri":"/leetcode/0390/"},{"categories":null,"content":" 力扣第 389 题 ","date":"2016-01-24","objectID":"/leetcode/0389/:0:0","tags":null,"title":"0389：找不同","uri":"/leetcode/0389/"},{"categories":null,"content":"题目 给定两个字符串 s 和 t ，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例 1： 输入：s = \"abcd\", t = \"abcde\" 输出：\"e\" 解释：'e' 是那个被添加的字母。 示例 2： 输入：s = \"\", t = \"y\" 输出：\"y\" 提示： 0 \u003c= s.length \u003c= 1000 t.length == s.length + 1 s 和 t 只包含小写字母 ","date":"2016-01-24","objectID":"/leetcode/0389/:1:0","tags":null,"title":"0389：找不同","uri":"/leetcode/0389/"},{"categories":null,"content":"分析 简单的计数。 ","date":"2016-01-24","objectID":"/leetcode/0389/:2:0","tags":null,"title":"0389：找不同","uri":"/leetcode/0389/"},{"categories":null,"content":"解答 def findTheDifference(self, s: str, t: str) -\u003e str: return (Counter(t) - Counter(s)).popitem()[0] 24 ms ","date":"2016-01-24","objectID":"/leetcode/0389/:3:0","tags":null,"title":"0389：找不同","uri":"/leetcode/0389/"},{"categories":null,"content":" 力扣第 388 题 ","date":"2016-01-23","objectID":"/leetcode/0388/:0:0","tags":null,"title":"0388：文件的最长绝对路径（★）","uri":"/leetcode/0388/"},{"categories":null,"content":"题目 假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例： 这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext 。 在文本格式中，如下所示(⟶表示制表符)： dir ⟶ subdir1 ⟶ ⟶ file1.ext ⟶ ⟶ subsubdir1 ⟶ subdir2 ⟶ ⟶ subsubdir2 ⟶ ⟶ ⟶ file2.ext 如果是代码表示，上面的文件系统可以写为","date":"2016-01-23","objectID":"/leetcode/0388/:1:0","tags":null,"title":"0388：文件的最长绝对路径（★）","uri":"/leetcode/0388/"},{"categories":null,"content":"分析 观察可知： input 按 ‘\\n’ 分割即为文本格式 分割后，每一行开头的 ‘\\t’ 个数即代表层级 若包含 ‘.’ 即为文件名，否则为目录名 维护每一层对应的绝对路径长度，即可得到当前目录/文件的绝对路径长度。 ","date":"2016-01-23","objectID":"/leetcode/0388/:2:0","tags":null,"title":"0388：文件的最长绝对路径（★）","uri":"/leetcode/0388/"},{"categories":null,"content":"解答 def lengthLongestPath(self, input: str) -\u003e int: res, d = 0, {-1: -1} for line in input.split('\\n'): name = line.strip('\\t') rank = len(line)-len(name) d[rank] = d[rank-1]+1+len(name) if '.' in name: res = max(res, d[rank]) return res 32 ms ","date":"2016-01-23","objectID":"/leetcode/0388/:3:0","tags":null,"title":"0388：文件的最长绝对路径（★）","uri":"/leetcode/0388/"},{"categories":null,"content":" 力扣第 387 题 ","date":"2016-01-22","objectID":"/leetcode/0387/:0:0","tags":null,"title":"0387：字符串中的第一个唯一字符","uri":"/leetcode/0387/"},{"categories":null,"content":"题目 给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。 示例 1： 输入: s = \"leetcode\" 输出: 0 示例 2: 输入: s = \"loveleetcode\" 输出: 2 示例 3: 输入: s = \"aabb\" 输出: -1 提示: 1 \u003c= s.length \u003c= 105 s 只包含小写字母 ","date":"2016-01-22","objectID":"/leetcode/0387/:1:0","tags":null,"title":"0387：字符串中的第一个唯一字符","uri":"/leetcode/0387/"},{"categories":null,"content":"分析 记录每个字符出现的次数，遍历找到第一个出现一次的字符即可。 ","date":"2016-01-22","objectID":"/leetcode/0387/:2:0","tags":null,"title":"0387：字符串中的第一个唯一字符","uri":"/leetcode/0387/"},{"categories":null,"content":"解答 def firstUniqChar(self, s: str) -\u003e int: ct = Counter(s) for i, char in enumerate(s): if ct[char] == 1: return i return -1 92 ms ","date":"2016-01-22","objectID":"/leetcode/0387/:3:0","tags":null,"title":"0387：字符串中的第一个唯一字符","uri":"/leetcode/0387/"},{"categories":null,"content":" 力扣第 386 题 ","date":"2016-01-21","objectID":"/leetcode/0386/:0:0","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"题目 给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n = 13 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9] 示例 2： 输入：n = 2 输出：[1,2] 提示： 1 \u003c= n \u003c= 5 * 104 ","date":"2016-01-21","objectID":"/leetcode/0386/:1:0","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"分析 ","date":"2016-01-21","objectID":"/leetcode/0386/:2:0","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"#1 观察知道字典排序和字符串排序是一样的，可直接调包。 def lexicalOrder(self, n: int) -\u003e List[int]: return sorted(range(1, n+1), key=str) 44 ms ","date":"2016-01-21","objectID":"/leetcode/0386/:2:1","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"#2 要求时间 O(N)，空间 O(1)，可以用 dfs 构造。 先考虑 ‘1’，然后在后面加 ‘0’，当大于 n 时就返回上一步，尝试加更大的数。 ","date":"2016-01-21","objectID":"/leetcode/0386/:2:2","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"解答 def lexicalOrder(self, n: int) -\u003e List[int]: def dfs(i): for j in range(max(1, i*10), min(i*10+10, n+1)): res.append(j) dfs(j) res = [] dfs(0) return res 136 ms ","date":"2016-01-21","objectID":"/leetcode/0386/:3:0","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":" 力扣第 385 题 ","date":"2016-01-20","objectID":"/leetcode/0385/:0:0","tags":null,"title":"0385：迷你语法分析器（★）","uri":"/leetcode/0385/"},{"categories":null,"content":"题目 给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。 列表中的每个元素只可能是整数或整数嵌套列表 示例 1： 输入：s = \"324\", 输出：324 解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。 示例 2： 输入：s = \"[123,[456,[789]]]\", 输出：[123,[456,[789]]] 解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表： 1. 一个 integer 包含值 123 2. 一个包含两个元素的嵌套列表： i. 一个 intege","date":"2016-01-20","objectID":"/leetcode/0385/:1:0","tags":null,"title":"0385：迷你语法分析器（★）","uri":"/leetcode/0385/"},{"categories":null,"content":"分析 显然 s 的对象由子串递归地组成。可以用栈模拟这个过程，一趟解决。 特别注意数字前可能有负号。 ","date":"2016-01-20","objectID":"/leetcode/0385/:2:0","tags":null,"title":"0385：迷你语法分析器（★）","uri":"/leetcode/0385/"},{"categories":null,"content":"解答 def deserialize(self, s: str) -\u003e NestedInteger: stack = [NestedInteger()] for left, num, right in re.findall(r'(\\[)|(-?\\d+)|(\\])', s): if left: stack.append(NestedInteger()) elif num: stack[-1].add(NestedInteger(int(num))) else: x = stack.pop() stack[-1].add(x) return stack[0].getList()[0] 40 ms ","date":"2016-01-20","objectID":"/leetcode/0385/:3:0","tags":null,"title":"0385：迷你语法分析器（★）","uri":"/leetcode/0385/"},{"categories":null,"content":" 力扣第 384 题 ","date":"2016-01-19","objectID":"/leetcode/0384/:0:0","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。 实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 示例 1： 输入 [\"Solution\", \"shuffle\", \"reset\", \"shuffle\"] [[[1, 2, 3]], [], [], []] 输出 [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]] 解释 ","date":"2016-01-19","objectID":"/leetcode/0384/:1:0","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"分析 ","date":"2016-01-19","objectID":"/leetcode/0384/:2:0","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"#1 最简单的就是调包 random.shuffle()。 class Solution: def __init__(self, nums: List[int]): self.nums = nums self.A = nums[:] def reset(self) -\u003e List[int]: return self.nums def shuffle(self) -\u003e List[int]: random.shuffle(self.A) return self.A 192 ms ","date":"2016-01-19","objectID":"/leetcode/0384/:2:1","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"#2 经典的洗牌方法就是第 i 轮随机取 [i, n) 的一个索引 j，将 A[i]、A[j] 互换。 ","date":"2016-01-19","objectID":"/leetcode/0384/:2:2","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"解答 class Solution: def __init__(self, nums: List[int]): self.nums = nums self.A = nums[:] def reset(self) -\u003e List[int]: return self.nums def shuffle(self) -\u003e List[int]: for i in range(len(self.A)): j = random.randint(i, len(self.A)-1) self.A[i], self.A[j] = self.A[j], self.A[i] return self.A 228 ms ","date":"2016-01-19","objectID":"/leetcode/0384/:3:0","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":" 力扣第 383 题 ","date":"2016-01-18","objectID":"/leetcode/0383/:0:0","tags":null,"title":"0383：赎金信","uri":"/leetcode/0383/"},{"categories":null,"content":"题目 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 输入：ransomNote = \"a\", magazine = \"b\" 输出：false 示例 2： 输入：ransomNote = \"aa\", magazine = \"ab\" 输出：false 示例 3： 输入：ransomNote = \"aa\", magazine = \"aab\" 输出：true 提示： 1 \u003c=","date":"2016-01-18","objectID":"/leetcode/0383/:1:0","tags":null,"title":"0383：赎金信","uri":"/leetcode/0383/"},{"categories":null,"content":"分析 显然只要 ransomNote 中每个字符的频数都小于等于在 magazine 中的频数即可。 ","date":"2016-01-18","objectID":"/leetcode/0383/:2:0","tags":null,"title":"0383：赎金信","uri":"/leetcode/0383/"},{"categories":null,"content":"解答 def canConstruct(self, ransomNote: str, magazine: str) -\u003e bool: return not (Counter(ransomNote) - Counter(magazine)) 48 ms ","date":"2016-01-18","objectID":"/leetcode/0383/:3:0","tags":null,"title":"0383：赎金信","uri":"/leetcode/0383/"},{"categories":null,"content":" 力扣第 382 题 ","date":"2016-01-17","objectID":"/leetcode/0382/:0:0","tags":null,"title":"0382：链表随机节点（★）","uri":"/leetcode/0382/"},{"categories":null,"content":"题目 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。 实现 Solution 类： Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 示例： 输入 [\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"] [[[1, 2, 3]], [], [], [], [], []] 输出 [null, 1, 3, 2, 2, 3] 解","date":"2016-01-17","objectID":"/leetcode/0382/:1:0","tags":null,"title":"0382：链表随机节点（★）","uri":"/leetcode/0382/"},{"categories":null,"content":"分析 ","date":"2016-01-17","objectID":"/leetcode/0382/:2:0","tags":null,"title":"0382：链表随机节点（★）","uri":"/leetcode/0382/"},{"categories":null,"content":"#1 最简单的就是保存在数组中，然后随机抽取。 class Solution: def __init__(self, head: ListNode): self.A = [] while head: self.A.append(head.val) head = head.next def getRandom(self) -\u003e int: return random.choice(self.A) 84 ms ","date":"2016-01-17","objectID":"/leetcode/0382/:2:1","tags":null,"title":"0382：链表随机节点（★）","uri":"/leetcode/0382/"},{"categories":null,"content":"#2 还有个经典的蓄水池抽样方法，无需事先知道长度。 遍历 1 到 n，第 i 轮以 1/i 的概率将 i 赋值到结果。最后结果即是 1 到 n 的随机数。 ","date":"2016-01-17","objectID":"/leetcode/0382/:2:2","tags":null,"title":"0382：链表随机节点（★）","uri":"/leetcode/0382/"},{"categories":null,"content":"解答 class Solution: def __init__(self, head: ListNode): self.head = head def getRandom(self) -\u003e int: res, i = 0, 0 p = self.head while p: i += 1 if random.randint(1, i) == 1: res = p.val p = p.next return res 180 ms ","date":"2016-01-17","objectID":"/leetcode/0382/:3:0","tags":null,"title":"0382：链表随机节点（★）","uri":"/leetcode/0382/"},{"categories":null,"content":" 力扣第 381 题 ","date":"2016-01-16","objectID":"/leetcode/0381/:0:0","tags":null,"title":"0381：O(1) 时间插入、删除和获取随机元素 - 允许重复（★★）","uri":"/leetcode/0381/"},{"categories":null,"content":"题目 RandomizedCollection 是一种包含数字集合(可能是重复的)的数据结构。它应该支持插入和删除特定元素，以及删除随机元素。 实现 RandomizedCollection 类: RandomizedCollection()初始化空的 RandomizedCollection 对象。 bool insert(int val) 将一个 val 项插入到集合中，即使该项已经存在。如果该项不存在，则返回 true ，否则返回 false 。 bool remove(int val) 如果存在，从集合中移除一个 val 项。如果该项存在，则返回 true ，否则返回 false 。注","date":"2016-01-16","objectID":"/leetcode/0381/:1:0","tags":null,"title":"0381：O(1) 时间插入、删除和获取随机元素 - 允许重复（★★）","uri":"/leetcode/0381/"},{"categories":null,"content":"分析 0380 进阶版，只是允许元素重复了，于是用哈希表记录元素的所有位置即可。 为了保证 O(1)，哈希表用 {int:set} 的结构。 ","date":"2016-01-16","objectID":"/leetcode/0381/:2:0","tags":null,"title":"0381：O(1) 时间插入、删除和获取随机元素 - 允许重复（★★）","uri":"/leetcode/0381/"},{"categories":null,"content":"解答 class RandomizedCollection: def __init__(self): self.A = [] self.d = defaultdict(set) def insert(self, val: int) -\u003e bool: self.A.append(val) self.d[val].add(len(self.A)-1) return len(self.d[val]) == 1 def remove(self, val: int) -\u003e bool: if not self.d[val]: return False i, last = self.d[val].pop()","date":"2016-01-16","objectID":"/leetcode/0381/:3:0","tags":null,"title":"0381：O(1) 时间插入、删除和获取随机元素 - 允许重复（★★）","uri":"/leetcode/0381/"},{"categories":null,"content":" 力扣第 380 题 ","date":"2016-01-15","objectID":"/leetcode/0380/:0:0","tags":null,"title":"0380：O(1) 时间插入、删除和获取随机元素（★★）","uri":"/leetcode/0380/"},{"categories":null,"content":"题目 实现RandomizedSet 类： RandomizedSet() 初始化 RandomizedSet 对象 bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。 bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。 int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。 你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1)","date":"2016-01-15","objectID":"/leetcode/0380/:1:0","tags":null,"title":"0380：O(1) 时间插入、删除和获取随机元素（★★）","uri":"/leetcode/0380/"},{"categories":null,"content":"分析 如果用哈希表，可以 O(1) 时间内判断元素是否存在，并添加/移除元素， 但不能 O(1) 时间返回随机项。 如果用数组，可以 O(1) 时间内返回随机项，但不能 O(1) 时间判断元素是否存在。 有个巧妙的方法是结合数组和哈希表： 用数组维护元素集合，哈希表维护每个元素和在数组中的位置 insert 时，用哈希表判断元素是否存在，若不存在，更新到数组末尾和哈希表中 remove 时，用哈希表判断元素是否存在，若存在，弹出元素，更新数组和哈希表 要 O(1) 时间弹出数组某个位置的元素，有个巧妙的方法 将数组该位置的元素和末尾元素互换，再从末尾弹出即可 特别注意同步更新哈希表 ","date":"2016-01-15","objectID":"/leetcode/0380/:2:0","tags":null,"title":"0380：O(1) 时间插入、删除和获取随机元素（★★）","uri":"/leetcode/0380/"},{"categories":null,"content":"解答 class RandomizedSet: def __init__(self): self.A = [] self.d = {} def insert(self, val: int) -\u003e bool: if val in self.d: return False self.A.append(val) self.d[val] = len(self.A)-1 return True def remove(self, val: int) -\u003e bool: if val not in self.d: return False i, last = self.d[val], self.A[-1] s","date":"2016-01-15","objectID":"/leetcode/0380/:3:0","tags":null,"title":"0380：O(1) 时间插入、删除和获取随机元素（★★）","uri":"/leetcode/0380/"},{"categories":null,"content":"　　17年前，非洲的战场上出现了绝对不会死的人，人们将这种未知的新生物称为“亚人”。在暑假即将到来之时，日本普通高中生永井圭在放学途中遭遇了交通事故而当场死亡，不过又随即复活，正因如此，其“亚人”的身份暴露，并被投以高额的悬赏。就这样，身为众人类敌人的少年逃避之旅开始了……","date":"2016-01-15","objectID":"/anime/ajin/","tags":null,"title":"亚人","uri":"/anime/ajin/"},{"categories":null,"content":"简介 17年前，非洲的战场上出现了绝对不会死的人，人们将这种未知的新生物称为“亚人”。在暑假即将到来之时，日本普通高中生永井圭在放学途中遭遇了交通事故而当场死亡，不过又随即复活，正因如此，其“亚人”的身份暴露，并被投以高额的悬赏。就这样，身为众人类敌人的少年逃避之旅开始了…… 制作人员： 原作：樱井画门 导演：安藤裕章 脚本：猪原健太、熊谷纯、濑古浩司 分镜：井出惠介、鹿住朗生、福岛宏之、森田宏幸 ","date":"2016-01-15","objectID":"/anime/ajin/:1:0","tags":null,"title":"亚人","uri":"/anime/ajin/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 永井圭 永井 圭、ながい けい、Nagai Kei 男 宮野真守 2 佐藤 帽子、さとう、Satou 男 大塚芳忠 3 户崎优 戸崎 優、とさき ゆう、Tosaki Yuu 男 櫻井孝宏 4 海斗 かいと、Kaito 男 細谷佳正 5 下村泉 田井中陽子、たいなか ようこ、Tainaka Yōko、田井中阳子、下村 泉、しもむら いずみ、Shimomura Izumi 女 小松未可子 6 田中功次 田中 功次、たなか こうじ、Tanaka Kouji 男 平川大輔 7 永井慧理子 永井 慧理子、ながい えりこ、Nagai Eriko 女 洲崎綾 8 小仓郁也","date":"2016-01-15","objectID":"/anime/ajin/:2:0","tags":null,"title":"亚人","uri":"/anime/ajin/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 亚人 2016-01-15 13 樱花 2 亚人 OAD 2016-05-06 3 樱花 3 亚人 第二季 2016-10-07 13 樱花 ","date":"2016-01-15","objectID":"/anime/ajin/:3:0","tags":null,"title":"亚人","uri":"/anime/ajin/"},{"categories":null,"content":" 力扣第 379 题 ","date":"2016-01-14","objectID":"/leetcode/0379/:0:0","tags":null,"title":"0379：电话目录管理系统","uri":"/leetcode/0379/"},{"categories":null,"content":"题目 设计一个电话目录管理系统，让它支持以下功能： get: 分配给用户一个未被使用的电话号码，获取失败请返回 -1 check: 检查指定的电话号码是否被使用 release: 释放掉一个电话号码，使其能够重新被分配 示例： // 初始化电话目录，包括 3 个电话号码：0，1 和 2。 PhoneDirectory directory = new PhoneDirectory(3); // 可以返回任意未分配的号码，这里我们假设它返回 0。 directory.get(); // 假设，函数返回 1。 directory.get(); // 号码 2 未分配，所以返回为 true。 dire","date":"2016-01-14","objectID":"/leetcode/0379/:1:0","tags":null,"title":"0379：电话目录管理系统","uri":"/leetcode/0379/"},{"categories":null,"content":"分析 维护一个哈希表即可。 ","date":"2016-01-14","objectID":"/leetcode/0379/:2:0","tags":null,"title":"0379：电话目录管理系统","uri":"/leetcode/0379/"},{"categories":null,"content":"解答 class PhoneDirectory: def __init__(self, maxNumbers: int): self.A = set(range(maxNumbers)) def get(self) -\u003e int: return -1 if not self.A else self.A.pop() def check(self, number: int) -\u003e bool: return number in self.A def release(self, number: int) -\u003e None: self.A.add(number) 72 ms ","date":"2016-01-14","objectID":"/leetcode/0379/:3:0","tags":null,"title":"0379：电话目录管理系统","uri":"/leetcode/0379/"},{"categories":null,"content":" 力扣第 378 题 ","date":"2016-01-13","objectID":"/leetcode/0378/:0:0","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★）","uri":"/leetcode/0378/"},{"categories":null,"content":"题目 给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。 请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。 你必须找到一个内存复杂度优于 O(n2) 的解决方案。 示例 1： 输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8 输出：13 解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13 示例 2： 输入：matrix = [[-5]], k = 1 输出：-5 提示： n == matrix.length n == m","date":"2016-01-13","objectID":"/leetcode/0378/:1:0","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★）","uri":"/leetcode/0378/"},{"categories":null,"content":"分析 ","date":"2016-01-13","objectID":"/leetcode/0378/:2:0","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★）","uri":"/leetcode/0378/"},{"categories":null,"content":"#1 每一行都是升序列表。问题等价于归并排序矩阵的 n 行，取第 k 项，可以用堆实现。 def kthSmallest(self, matrix: List[List[int]], k: int) -\u003e int: n = len(matrix) pq = [(matrix[i][0], i, 0) for i in range(min(n, k))] for _ in range(k-1): _, i, j = heappop(pq) if j+1 \u003c n: heappush(pq, (matrix[i][j+1], i, j+1)) return heappop(pq)[0] 时间复杂度 ","date":"2016-01-13","objectID":"/leetcode/0378/:2:1","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★）","uri":"/leetcode/0378/"},{"categories":null,"content":"#2 还有个巧妙的二分查找方法。 以最终答案 x 为界 若 y\u003cx，那么矩阵中小于等于 y 的元素小于 k个 若 y\u003e=x，矩阵中小于等于 y 的元素大于等于 k个 令 check(x) 代表矩阵中小于等于 x 的元素是否大于等于 k 个，二分查找第一个满足 check(x) 为真的 x 即可 具体求 check(x)，每一行二分查找 x 的位置即可 ","date":"2016-01-13","objectID":"/leetcode/0378/:2:2","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★）","uri":"/leetcode/0378/"},{"categories":null,"content":"解答 def kthSmallest(self, matrix: List[List[int]], k: int) -\u003e int: def check(x): return sum(bisect_right(row, x) for row in matrix) \u003e= k self.__class__.__getitem__ = lambda self, i: check(i-10**9) return bisect_left(self, True, 0, 2*10**9)-10**9 时间复杂度 $O(N * logN * logS)$，44 ms ","date":"2016-01-13","objectID":"/leetcode/0378/:3:0","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★）","uri":"/leetcode/0378/"},{"categories":null,"content":"　　热爱游戏的家里蹲少年·佐藤和真的人生，因交通事故（!?）而轻易闭幕……本该是这样，但当他醒来之时，眼前有一位自称是女神的美少女。“喂，我有点好事要告诉你。要去异世界吗？只带一样你喜欢的东西没问题喔。”“那，我就带着你好了。”由此开始，在异世界转生的和真的魔王讨伐大冒险开始了……虽然是这么想的，但他却为了获得衣食住行而开始劳动！想要平稳度日的和真，却由于女神引起的各种问题，而终于被魔王军盯上了!? ","date":"2016-01-13","objectID":"/anime/konosuba/","tags":null,"title":"为美好的世界献上祝福！","uri":"/anime/konosuba/"},{"categories":null,"content":"简介 热爱游戏的家里蹲少年·佐藤和真的人生，因交通事故（!?）而轻易闭幕……本该是这样，但当他醒来之时，眼前有一位自称是女神的美少女。“喂，我有点好事要告诉你。要去异世界吗？只带一样你喜欢的东西没问题喔。”“那，我就带着你好了。”由此开始，在异世界转生的和真的魔王讨伐大冒险开始了……虽然是这么想的，但他却为了获得衣食住行而开始劳动！想要平稳度日的和真，却由于女神引起的各种问题，而终于被魔王军盯上了!? 制作人员： 原作：晓夏目 导演：金崎贵臣 脚本：朱白葵、中村浩二郎、上江洲诚 分镜：稻垣隆行、齐藤哲人、伊势昌弘 ","date":"2016-01-13","objectID":"/anime/konosuba/:1:0","tags":null,"title":"为美好的世界献上祝福！","uri":"/anime/konosuba/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐藤和真 佐藤 和真、サトウ カズマ、Satou Kazuma 男 福島潤 2 阿克娅 阿库娅、Aqua、アクア、Akua、茶包 女 雨宮天 3 惠惠 めぐみん、Megumin 女 高橋李依 4 达克妮斯 达斯堤尼斯·福特·拉拉蒂娜、Raratina Dustiness Ford、ダスティネス・フォード・ララティーナ、Dukunesu 女 茅野愛衣 5 厄里斯 Eris、エリス、Erisu 女 諏訪彩花 6 露娜 Luna、Runa 女 原紗友里 7 贝尔迪亚 Beldia、Berudia 男 安元洋貴 8 克莉丝 Chris、クリス、Kurisu 女 諏訪","date":"2016-01-13","objectID":"/anime/konosuba/:2:0","tags":null,"title":"为美好的世界献上祝福！","uri":"/anime/konosuba/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 为美好的世界献上祝福！ 2016-01-13 10 樱花 2 为美好的世界献上祝福！ 第二季 2017-01-11 10 樱花 3 电影 为美好的世界献上祝福！红传说 2019-08-30 1 樱花 ","date":"2016-01-13","objectID":"/anime/konosuba/:3:0","tags":null,"title":"为美好的世界献上祝福！","uri":"/anime/konosuba/"},{"categories":null,"content":" 力扣第 377 题 ","date":"2016-01-12","objectID":"/leetcode/0377/:0:0","tags":null,"title":"0377：组合总和 Ⅳ（★）","uri":"/leetcode/0377/"},{"categories":null,"content":"题目 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 示例 1： 输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2： 输入：nums = [9], target = 3 输出：0 提示： 1 \u003c= nums.length \u003c= ","date":"2016-01-12","objectID":"/leetcode/0377/:1:0","tags":null,"title":"0377：组合总和 Ⅳ（★）","uri":"/leetcode/0377/"},{"categories":null,"content":"分析 典型的线性 dp，按最后一个数即可递归。 ","date":"2016-01-12","objectID":"/leetcode/0377/:2:0","tags":null,"title":"0377：组合总和 Ⅳ（★）","uri":"/leetcode/0377/"},{"categories":null,"content":"解答 def combinationSum4(self, nums: List[int], target: int) -\u003e int: dp = [1] * (target+1) for i in range(1, target+1): dp[i] = sum(dp[i-x] for x in nums if x\u003c=i) return dp[-1] 44 ms ","date":"2016-01-12","objectID":"/leetcode/0377/:3:0","tags":null,"title":"0377：组合总和 Ⅳ（★）","uri":"/leetcode/0377/"},{"categories":null,"content":" 力扣第 376 题 ","date":"2016-01-11","objectID":"/leetcode/0376/:0:0","tags":null,"title":"0376：摆动序列（★）","uri":"/leetcode/0376/"},{"categories":null,"content":"题目 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。 给你一个整数数组 nums ，","date":"2016-01-11","objectID":"/leetcode/0376/:1:0","tags":null,"title":"0376：摆动序列（★）","uri":"/leetcode/0376/"},{"categories":null,"content":"分析 ","date":"2016-01-11","objectID":"/leetcode/0376/:2:0","tags":null,"title":"0376：摆动序列（★）","uri":"/leetcode/0376/"},{"categories":null,"content":"#1 观察发现可以递推。 令 dp[i][0]、dp[i][1] 分别代表以位置 i 结尾且最后一个差值为 正/负 的最长摆动序列长度， 即可递推。 def wiggleMaxLength(self, nums: List[int]) -\u003e int: n = len(nums) dp = [[1, 1] for _ in range(n)] for i in range(1, n): dp[i][0] = 1 + max([dp[j][1] for j in range(i) if nums[j]\u003cnums[i]], default=0) dp[i][1] = 1 + max([dp[j][0","date":"2016-01-11","objectID":"/leetcode/0376/:2:1","tags":null,"title":"0376：摆动序列（★）","uri":"/leetcode/0376/"},{"categories":null,"content":"#2 还有个巧妙的贪心方法： 显然相邻重复的点只留一个即可，其它可以忽略 假设存在 nums[i-1]\u003cnums[i]\u003cnums[i+1] 任意包含 nums[i] 的摆动序列都可以将 nums[i] 替换为 nums[i-1] 或 nums[i+1]，依然是摆动序列 所以可以忽略掉这样的 nums[i] 同理，当 nums[i-1]\u003enums[i]\u003enums[i+1] 时，也可以忽略掉 nums[i] 因此只需要考虑波峰/谷的点，其它点都可以忽略掉 所有波峰/谷的点组成的显然是摆动序列，即为所求 注意首尾也是波峰/谷。 ","date":"2016-01-11","objectID":"/leetcode/0376/:2:2","tags":null,"title":"0376：摆动序列（★）","uri":"/leetcode/0376/"},{"categories":null,"content":"解答 def wiggleMaxLength(self, nums: List[int]) -\u003e int: A = [a for a,_ in groupby(nums)] n = len(A) return sum(i in [0, n-1] or (A[i]-A[i-1])*(A[i]-A[i+1])\u003e0 for i in range(n)) 时间复杂度 O(N)，36 ms ","date":"2016-01-11","objectID":"/leetcode/0376/:3:0","tags":null,"title":"0376：摆动序列（★）","uri":"/leetcode/0376/"},{"categories":null,"content":"被垃圾堆里的奇妙生物说了“你有魔法少女的素质”的柚香。\n变身成魔法少女的她，衣服竟然是泳装！？而且也没有什么敌人，不去帮助别人、不去收集道具也无所谓！？\n漫无目的的魔法少女生活开始了……。","date":"2016-01-11","objectID":"/anime/mahou_shoujo_nante/","tags":null,"title":"魔法少女什么的已经够了啦。","uri":"/anime/mahou_shoujo_nante/"},{"categories":null,"content":"简介 被垃圾堆里的奇妙生物说了“你有魔法少女的素质”的柚香。 变身成魔法少女的她，衣服竟然是泳装！？而且也没有什么敌人，不去帮助别人、不去收集道具也无所谓！？ 漫无目的的魔法少女生活开始了……。 制作人员： 原作：双见醉 导演：米田和弘 脚本：村上桃子、笔安一幸 音乐：中山真斗 人物设定：岛田和晃 ","date":"2016-01-11","objectID":"/anime/mahou_shoujo_nante/:1:0","tags":null,"title":"魔法少女什么的已经够了啦。","uri":"/anime/mahou_shoujo_nante/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 叶波柚香 葉波 ゆずか、はなみ ゆずか、Hanami Yuzuka 女 藤田茜 2 米咚 Miton 若井友希 3 坂上千叶 坂上 ちや、さかがみ ちや、Sakagami Chiya 女 大森日雅 4 黛雅 Daiya 女 田中美海 5 篠木真冬 篠木 真冬、しのぎ まふゆ、Shinogi Mafuyu 女 伊藤美来 6 波奇 Pochi 西明日香 7 柚香的父亲 ゆずかの父 男 諏訪部順一 8 美代子 Miyoko 女 斎藤千和 ","date":"2016-01-11","objectID":"/anime/mahou_shoujo_nante/:2:0","tags":null,"title":"魔法少女什么的已经够了啦。","uri":"/anime/mahou_shoujo_nante/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔法少女什么的已经够了啦。 2016-01-11 12 bilibili 2 魔法少女什么的已经够了啦。第二季 2016-10-05 12 bilibili ","date":"2016-01-11","objectID":"/anime/mahou_shoujo_nante/:3:0","tags":null,"title":"魔法少女什么的已经够了啦。","uri":"/anime/mahou_shoujo_nante/"},{"categories":null,"content":" 力扣第 375 题 ","date":"2016-01-10","objectID":"/leetcode/0375/:0:0","tags":null,"title":"0375：猜数字大小 II（★）","uri":"/leetcode/0375/"},{"categories":null,"content":"题目 我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字。 你来猜我选了哪个数字。 如果你猜到正确的数字，就会 赢得游戏 。 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。 示例 1： 输入：n = 10 输出：16 解释：制胜策略如下： - 数字范围是 [1,10] 。你先猜测数字为 7 。 - 如果这是我选中的数字，你的总费用为 $0 。否则","date":"2016-01-10","objectID":"/leetcode/0375/:1:0","tags":null,"title":"0375：猜数字大小 II（★）","uri":"/leetcode/0375/"},{"categories":null,"content":"分析 典型的区间 dp，按一开始猜的数字即可递归。 令 dp[i][j] 代表在 [i, j] 玩游戏的最小必胜现金： 选 x 时，最坏情况下要支付 x+max(dp[i][x-1], dp[x+1][n]) 遍历 x，取最小的必胜值即可 ","date":"2016-01-10","objectID":"/leetcode/0375/:2:0","tags":null,"title":"0375：猜数字大小 II（★）","uri":"/leetcode/0375/"},{"categories":null,"content":"解答 def getMoneyAmount(self, n: int) -\u003e int: dp = [[0]*(n+2) for _ in range(n+2)] for i in range(n, 0, -1): for j in range(i+1, n+1): dp[i][j] = min(x+max(dp[i][x-1], dp[x+1][j]) for x in range(i, j+1)) return dp[1][n] 时间复杂度 O(N^3)，1536 ms ","date":"2016-01-10","objectID":"/leetcode/0375/:3:0","tags":null,"title":"0375：猜数字大小 II（★）","uri":"/leetcode/0375/"},{"categories":null,"content":"我们为什么要这么做……？\n\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方是哪里。\n\n他的身边有一群和他一样失去记忆，只记得自己名字的男女；而离开了地底后，等待着众人的是一个「宛如游戏」的世界。\n\n为求生存，哈尔希洛与自己有着相同境遇的伙伴们组成队伍、学习技能，以义勇兵见习者的身份踏入了这个世界--「格林姆迦尔」。\n\n没有人知道未来会遇见什么……这一切，就是从灰烬之中所诞生的冒险谭。 ","date":"2016-01-10","objectID":"/anime/grimgar_of_fantasy_and_ash/","tags":null,"title":"灰与幻想的格林姆迦尔","uri":"/anime/grimgar_of_fantasy_and_ash/"},{"categories":null,"content":"简介 我们为什么要这么做……？ 哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方是哪里。 他的身边有一群和他一样失去记忆，只记得自己名字的男女；而离开了地底后，等待着众人的是一个「宛如游戏」的世界。 为求生存，哈尔希洛与自己有着相同境遇的伙伴们组成队伍、学习技能，以义勇兵见习者的身份踏入了这个世界–「格林姆迦尔」。 没有人知道未来会遇见什么……这一切，就是从灰烬之中所诞生的冒险谭。 制作人员： 原作：十文字青 导演：中村亮介 分镜：仁贺绿朗、角铜博之、玄马宣彦、工藤进、川村贤一、飞田刚 ","date":"2016-01-10","objectID":"/anime/grimgar_of_fantasy_and_ash/:1:0","tags":null,"title":"灰与幻想的格林姆迦尔","uri":"/anime/grimgar_of_fantasy_and_ash/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哈尔希洛 Haruhiro 男 細谷佳正 2 梦儿 Yume 女 小松未可子 3 席赫露 Shihoru 女 照井春佳 4 蓝德 Ranta 男 吉野裕行 5 梅莉 女 安済知佳 6 莫古索 Mogzo 男 落合福嗣 7 马纳多 Manato 男 島﨑信長 8 莲崎 Renji 男 関智一 ","date":"2016-01-10","objectID":"/anime/grimgar_of_fantasy_and_ash/:2:0","tags":null,"title":"灰与幻想的格林姆迦尔","uri":"/anime/grimgar_of_fantasy_and_ash/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 灰与幻想的格林姆迦尔 2016-01-10 12 bilibili ","date":"2016-01-10","objectID":"/anime/grimgar_of_fantasy_and_ash/:3:0","tags":null,"title":"灰与幻想的格林姆迦尔","uri":"/anime/grimgar_of_fantasy_and_ash/"},{"categories":null,"content":" 力扣第 374 题 ","date":"2016-01-09","objectID":"/leetcode/0374/:0:0","tags":null,"title":"0374：猜数字大小","uri":"/leetcode/0374/"},{"categories":null,"content":"题目 猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick \u003c num 1：我选出的数字比你猜的数字大 pick \u003e num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。 示例 1： 输入：n = 10, pick = 6 输出：6 示例 2： ","date":"2016-01-09","objectID":"/leetcode/0374/:1:0","tags":null,"title":"0374：猜数字大小","uri":"/leetcode/0374/"},{"categories":null,"content":"分析 典型的二分查找。 ","date":"2016-01-09","objectID":"/leetcode/0374/:2:0","tags":null,"title":"0374：猜数字大小","uri":"/leetcode/0374/"},{"categories":null,"content":"解答 def guessNumber(self, n: int) -\u003e int: self.__class__.__getitem__ = lambda self, i: guess(i)\u003c=0 return bisect_left(self, True, 1, n) 28 ms ","date":"2016-01-09","objectID":"/leetcode/0374/:3:0","tags":null,"title":"0374：猜数字大小","uri":"/leetcode/0374/"},{"categories":null,"content":" 力扣第 373 题 ","date":"2016-01-08","objectID":"/leetcode/0373/:0:0","tags":null,"title":"0373：查找和最小的 K 对数字（★）","uri":"/leetcode/0373/"},{"categories":null,"content":"题目 给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。 请找到和最小的 k 个数对 (u1,v1), (u2,v2) ... (uk,vk) 。 示例 1: 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 输出: [1,2],[1,4],[1,6] 解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 示例 2: 输入: nums1 ","date":"2016-01-08","objectID":"/leetcode/0373/:1:0","tags":null,"title":"0373：查找和最小的 K 对数字（★）","uri":"/leetcode/0373/"},{"categories":null,"content":"分析 有个巧妙的想法。令 A[i][j] 代表 nums1[i]+nums2[j]，每一行都是升序列表。 问题等价于归并排序 A 的前 k 行，取前 k 项，可以用堆实现。 具体实现时，不需要真的构造出 A，归并时根据下标计算值即可。 ","date":"2016-01-08","objectID":"/leetcode/0373/:2:0","tags":null,"title":"0373：查找和最小的 K 对数字（★）","uri":"/leetcode/0373/"},{"categories":null,"content":"解答 def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u003e List[List[int]]: m, n = len(nums1), len(nums2) res, A = [], [(nums1[i]+nums2[0], i, 0) for i in range(min(m, k))] for _ in range(min(m * n, k)): _, i, j = heappop(A) res.append([nums1[i], nums2[j]]) if j \u003c n - 1: heappush(A, ","date":"2016-01-08","objectID":"/leetcode/0373/:3:0","tags":null,"title":"0373：查找和最小的 K 对数字（★）","uri":"/leetcode/0373/"},{"categories":null,"content":"外表不管哪里不管怎么看都是金发辣妹，实际却是纯情女生。以有着辣妹外表和直率温柔的内心这种反差萌的辣妹子为中心，戴着眼镜小巧玲珑的宅子，以及举止文雅天真烂漫的大小姐，三个人在各种场所展开女生会话的日常喜剧。","date":"2016-01-08","objectID":"/anime/galko_chan/","tags":null,"title":"告诉我！辣妹子酱","uri":"/anime/galko_chan/"},{"categories":null,"content":"简介 外表不管哪里不管怎么看都是金发辣妹，实际却是纯情女生。以有着辣妹外表和直率温柔的内心这种反差萌的辣妹子为中心，戴着眼镜小巧玲珑的宅子，以及举止文雅天真烂漫的大小姐，三个人在各种场所展开女生会话的日常喜剧。 制作人员： 原作：铃木健也 导演：川口敬一郎 演出：藤井隆文、新田义方、松下周平、冈村正弘、关大 ","date":"2016-01-08","objectID":"/anime/galko_chan/:1:0","tags":null,"title":"告诉我！辣妹子酱","uri":"/anime/galko_chan/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 辣妹子 女 和氣あず未 2 宅子 女 富田美憂 3 大小姐 女 髙橋ミナミ 4 轻薄男 男 櫻井孝宏 5 运动男 男 小野大輔 6 宅男 男 松岡禎丞 7 阿部先 男 中村悠一 8 超嗨美 女 石上静香 ","date":"2016-01-08","objectID":"/anime/galko_chan/:2:0","tags":null,"title":"告诉我！辣妹子酱","uri":"/anime/galko_chan/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 告诉我！辣妹子酱 2016-01-08 12 樱花 ","date":"2016-01-08","objectID":"/anime/galko_chan/:3:0","tags":null,"title":"告诉我！辣妹子酱","uri":"/anime/galko_chan/"},{"categories":null,"content":"无法忘记在刑务所的落语慰问会中见到的大名人·八云的“死神”，出狱的与太郎径直前往寄席。拜倒在八云面前，成为他住所雇工以及弟子的与太郎，却发现在八云之处住着一位名叫小夏的女性。八云与小夏似乎有着他人无从触及的因缘……。","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":"简介 无法忘记在刑务所的落语慰问会中见到的大名人·八云的“死神”，出狱的与太郎径直前往寄席。拜倒在八云面前，成为他住所雇工以及弟子的与太郎，却发现在八云之处住着一位名叫小夏的女性。八云与小夏似乎有着他人无从触及的因缘……。 制作人员： 原作：云田晴子 导演：小俣真一 脚本：中西泰大、熊谷纯、待田堂子、柿原优子 分镜：园田雅裕、阿部达也 ","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/:1:0","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 三代目有乐亭助六 九代目有乐亭八云、九代目有楽亭八雲、強次、よたろう、与太郎、三代目有楽亭助六、さんだいめ ゆうらくてい すけろく、与太 男 関智一 2 八代目有乐亭八云 八云、菊比古、きくひこ、八代目有楽亭八雲、やくも、yakumo 男 石田彰 3 小夏 小夏、こなつ、konatsu 女 小林ゆう 4 二代目有乐亭助六 助六、信さん、はつたろう、初太郎、二代目有楽亭助六、にだいめ ゆうらくてい すけろく 男 山寺宏一 5 美代吉 ユリエ、みよ吉、みよきち、miyokichi 女 林原めぐみ 6 黑道大哥 男 加瀬康之 7 お栄 おえい 女 斎藤恵理 8 四","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/:2:0","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 昭和元禄落语心中 2016-01-08 13 樱花 2 昭和元禄落语心中 -助六再临篇- 2017-01-06 12 樱花 ","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/:3:0","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":"MAD ","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/:4:0","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":" 力扣第 372 题 ","date":"2016-01-07","objectID":"/leetcode/0372/:0:0","tags":null,"title":"0372：超级次方（★）","uri":"/leetcode/0372/"},{"categories":null,"content":"题目 你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 示例 1： 输入：a = 2, b = [3] 输出：8 示例 2： 输入：a = 2, b = [1,0] 输出：1024 示例 3： 输入：a = 1, b = [4,3,3,8,5,2] 输出：1 示例 4： 输入：a = 2147483647, b = [2,0,0] 输出：1198 提示： 1 \u003c= a \u003c= 231 - 1 1 \u003c= b.length \u003c= 2000 0 \u003c= b[i] \u003c= 9 b 不含前导 0 ","date":"2016-01-07","objectID":"/leetcode/0372/:1:0","tags":null,"title":"0372：超级次方（★）","uri":"/leetcode/0372/"},{"categories":null,"content":"分析 可以递推。令 dp[i] 代表 $a^{b[:i]}，n_i$ 是 b[:i+1] 对应的数，那么： $$\\begin{aligned} dp[i]\u0026=a^{n_i}=a^{n_{i-1}*10+b[i]} \\\\ \u0026= (a^{n_{i-1}})^{10}*a^{b[i]} \\\\ \u0026=dp[i-1]^{10}*a^{b[i]} \\end{aligned}$$ 再注意取模即可。 ","date":"2016-01-07","objectID":"/leetcode/0372/:2:0","tags":null,"title":"0372：超级次方（★）","uri":"/leetcode/0372/"},{"categories":null,"content":"解答 def superPow(self, a: int, b: List[int]) -\u003e int: dp, mod = 1, 1337 for x in b: dp = pow(dp, 10, 1337)*pow(a, x, 1337)%mod return dp 100 ms ","date":"2016-01-07","objectID":"/leetcode/0372/:3:0","tags":null,"title":"0372：超级次方（★）","uri":"/leetcode/0372/"},{"categories":null,"content":"　　藤沼悟是一个三流漫画家，但是他却拥有着名为“再上映”（可以穿越到事件发生之前的时间点，阻止事件发生，但失败了会一直重复）的能力。某天，当回到家里的时候他发现了自己母亲遇害的一幕，并且自己被嫁祸为杀人凶手。就在这时候，由于再上映的关系，他突然回到了18年前·小学五年级的时候，而这一刻他不但要拯救母亲，也要为了同学的安全而战……","date":"2016-01-07","objectID":"/anime/erased/","tags":null,"title":"只有我不存在的城市","uri":"/anime/erased/"},{"categories":null,"content":"简介 藤沼悟是一个三流漫画家，但是他却拥有着名为“再上映”（可以穿越到事件发生之前的时间点，阻止事件发生，但失败了会一直重复）的能力。某天，当回到家里的时候他发现了自己母亲遇害的一幕，并且自己被嫁祸为杀人凶手。就在这时候，由于再上映的关系，他突然回到了18年前·小学五年级的时候，而这一刻他不但要拯救母亲，也要为了同学的安全而战…… 制作人员： 原作：三部敬 导演：伊藤智彦 脚本：安永丰、岸本卓 分镜：江崎慎平、绵田慎也、平川哲生、こさや ","date":"2016-01-07","objectID":"/anime/erased/:1:0","tags":null,"title":"只有我不存在的城市","uri":"/anime/erased/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤沼悟 ふじぬま さとる、Fujinuma Satoru、藤沼 悟 男 満島真之介 2 雏月加代 雛月 加代、ひなづき かよ、Hinazuki Kayo 女 悠木碧 3 片桐爱梨 片桐 愛梨、かたぎり あいり、Katagiri Airi 女 赤﨑千夏 4 藤沼佐知子 藤沼 佐知子、ふじぬま さちこ、Fujinuma Sachiko 女 高山みなみ 5 小林贤也 ケンヤ、小林 賢也、こばやし けんや、Kobayashi Kenya 男 大地葉 6 杉田广美 杉田 広美、すぎた ひろみ、Sugita Hiromi、ヒロミ 男 田丸篤志 7 和 カズ、Kazu 男","date":"2016-01-07","objectID":"/anime/erased/:2:0","tags":null,"title":"只有我不存在的城市","uri":"/anime/erased/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 只有我不存在的城市 2016-01-07 12 bilibili ","date":"2016-01-07","objectID":"/anime/erased/:3:0","tags":null,"title":"只有我不存在的城市","uri":"/anime/erased/"},{"categories":null,"content":" 力扣第 371 题 ","date":"2016-01-06","objectID":"/leetcode/0371/:0:0","tags":null,"title":"0371：两整数之和（★）","uri":"/leetcode/0371/"},{"categories":null,"content":"题目 给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。 示例 1： 输入：a = 1, b = 2 输出：3 示例 2： 输入：a = 2, b = 3 输出：5 提示： -1000 \u003c= a, b \u003c= 1000 ","date":"2016-01-06","objectID":"/leetcode/0371/:1:0","tags":null,"title":"0371：两整数之和（★）","uri":"/leetcode/0371/"},{"categories":null,"content":"分析 可以用位运算来解决，但 python 处理本题的负数较为麻烦，所以直接调库。 def getSum(self, a: int, b: int) -\u003e int: return sum([a,b]) 40 ms ","date":"2016-01-06","objectID":"/leetcode/0371/:2:0","tags":null,"title":"0371：两整数之和（★）","uri":"/leetcode/0371/"},{"categories":null,"content":" 力扣第 370 题 ","date":"2016-01-05","objectID":"/leetcode/0370/:0:0","tags":null,"title":"0370：区间加法（★）","uri":"/leetcode/0370/"},{"categories":null,"content":"题目 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k​​​​​​​ 个更新的操作。 其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。 请你返回 k 次操作后的数组。 示例: 输入: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]] 输出: [-2,0,3,5,3] 解释: 初始状态: [0,0,0,0,0] 进行了操作 [1,3,2] 后的","date":"2016-01-05","objectID":"/leetcode/0370/:1:0","tags":null,"title":"0370：区间加法（★）","uri":"/leetcode/0370/"},{"categories":null,"content":"分析 针对区间修改，用差分数组。 ","date":"2016-01-05","objectID":"/leetcode/0370/:2:0","tags":null,"title":"0370：区间加法（★）","uri":"/leetcode/0370/"},{"categories":null,"content":"解答 def getModifiedArray(self, length: int, updates: List[List[int]]) -\u003e List[int]: d = [0] * (length+1) for s, e, w in updates: d[s] += w d[e+1] -= w return list(accumulate(d[:-1])) 40 ms ","date":"2016-01-05","objectID":"/leetcode/0370/:3:0","tags":null,"title":"0370：区间加法（★）","uri":"/leetcode/0370/"},{"categories":null,"content":" 力扣第 369 题 ","date":"2016-01-04","objectID":"/leetcode/0369/:0:0","tags":null,"title":"0369：给单链表加一（★）","uri":"/leetcode/0369/"},{"categories":null,"content":"题目 给定一个用链表表示的非负整数， 然后将这个整数 再加上 1 。 这些数字的存储是这样的：最高位有效的数字位于链表的首位 head 。 示例 1: 输入: head = [1,2,3] 输出: [1,2,4] 示例 2: 输入: head = [0] 输出: [1] 提示： 链表中的节点数在 [1, 100] 的范围内。 0 \u003c= Node.val \u003c= 9 由链表表示的数字不包含前导零，除了零本身。 ","date":"2016-01-04","objectID":"/leetcode/0369/:1:0","tags":null,"title":"0369：给单链表加一（★）","uri":"/leetcode/0369/"},{"categories":null,"content":"分析 可以类似 0066，先转为数组，模拟进位加分后再转为链表。也可以用递归，直接修改节点值。 ","date":"2016-01-04","objectID":"/leetcode/0369/:2:0","tags":null,"title":"0369：给单链表加一（★）","uri":"/leetcode/0369/"},{"categories":null,"content":"解答 def plusOne(self, head: ListNode) -\u003e ListNode: def dfs(node): if not node: return 1 s = node.val + dfs(node.next) node.val = s % 10 return s // 10 carry = dfs(head) return ListNode(1, next=head) if carry else head 28 ms ","date":"2016-01-04","objectID":"/leetcode/0369/:3:0","tags":null,"title":"0369：给单链表加一（★）","uri":"/leetcode/0369/"},{"categories":null,"content":" 力扣第 368 题 ","date":"2016-01-03","objectID":"/leetcode/0368/:0:0","tags":null,"title":"0368：最大整除子集（★）","uri":"/leetcode/0368/"},{"categories":null,"content":"题目 给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足： answer[i] % answer[j] == 0 ，或 answer[j] % answer[i] == 0 如果存在多个有效解子集，返回其中任何一个均可。 示例 1： 输入：nums = [1,2,3] 输出：[1,2] 解释：[1,3] 也会被视为正确答案。 示例 2： 输入：nums = [1,2,4,8] 输出：[1,2,4,8] 提示： 1 \u003c= nums.length \u003c= 1000 1 \u003c= n","date":"2016-01-03","objectID":"/leetcode/0368/:1:0","tags":null,"title":"0368：最大整除子集（★）","uri":"/leetcode/0368/"},{"categories":null,"content":"分析 典型的子序列 dp。先将 nums 排序后得到数组 A。 令 dp[i] 代表以 A[i] 结尾的最大整除子集的长度，按A[i]前元素位置即可递推。 本题要求给出一个最大整除子集，考虑从递推的路径反推： 先找到一个终点 i，满足 dp[i]==max(dp) 往前找点 j ，满足 A[i]%A[j]==0 且 dp[j]==dp[i]-1 依此类推即可 ","date":"2016-01-03","objectID":"/leetcode/0368/:2:0","tags":null,"title":"0368：最大整除子集（★）","uri":"/leetcode/0368/"},{"categories":null,"content":"解答 def largestDivisibleSubset(self, nums: List[int]) -\u003e List[int]: A, n = sorted(nums), len(nums) dp = [1]*n for i in range(n): dp[i] = 1+max([dp[j] for j in range(i) if A[i]%A[j]==0], default=0) i = dp.index(max(dp)) res = [A[i]] while dp[i] != 1: for j in range(i): if dp[j]==dp[i]-1 and A[i]%A[j]=","date":"2016-01-03","objectID":"/leetcode/0368/:3:0","tags":null,"title":"0368：最大整除子集（★）","uri":"/leetcode/0368/"},{"categories":null,"content":" 力扣第 367 题 ","date":"2016-01-02","objectID":"/leetcode/0367/:0:0","tags":null,"title":"0367：有效的完全平方数","uri":"/leetcode/0367/"},{"categories":null,"content":"题目 给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。 完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。 不能使用任何内置的库函数，如 sqrt 。 示例 1： 输入：num = 16 输出：true 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。 示例 2： 输入：num = 14 输出：false 解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。 提示： 1 \u003c= num \u003c= 231 - 1 ","date":"2016-01-02","objectID":"/leetcode/0367/:1:0","tags":null,"title":"0367：有效的完全平方数","uri":"/leetcode/0367/"},{"categories":null,"content":"分析 0069 升级版，找到平方根取整后，判断其平方是否等于 num 即可。 找平方根可以用二分查找，也可以用牛顿迭代法。 ","date":"2016-01-02","objectID":"/leetcode/0367/:2:0","tags":null,"title":"0367：有效的完全平方数","uri":"/leetcode/0367/"},{"categories":null,"content":"解答 def isPerfectSquare(self, num: int) -\u003e bool: i = num while i * i \u003e num: i = (i+num//i) // 2 return i * i == num 32 ms ","date":"2016-01-02","objectID":"/leetcode/0367/:3:0","tags":null,"title":"0367：有效的完全平方数","uri":"/leetcode/0367/"},{"categories":null,"content":" 力扣第 366 题 ","date":"2016-01-01","objectID":"/leetcode/0366/:0:0","tags":null,"title":"0366：寻找二叉树的叶子节点（★）","uri":"/leetcode/0366/"},{"categories":null,"content":"题目 给你一棵二叉树，请按以下要求的顺序收集它的全部节点： 依次从左到右，每次收集并删除所有的叶子节点 重复如上过程直到整棵树为空 示例: 输入: [1,2,3,4,5] 1 / \\ 2 3 / \\ 4 5 输出: [[4,5,3],[2],[1]] 解释: 1. 删除叶子节点 [4,5,3] ，得到如下树结构： 1 / 2 2. 现在删去叶子节点 [2] ，得到如下树结构： 1 3. 现在删去叶子节点 [1] ，得到空树： [] ","date":"2016-01-01","objectID":"/leetcode/0366/:1:0","tags":null,"title":"0366：寻找二叉树的叶子节点（★）","uri":"/leetcode/0366/"},{"categories":null,"content":"分析 观察发现是按节点的高度从小到大收集，因此用递归并返回节点高度即可。 ","date":"2016-01-01","objectID":"/leetcode/0366/:2:0","tags":null,"title":"0366：寻找二叉树的叶子节点（★）","uri":"/leetcode/0366/"},{"categories":null,"content":"解答 def findLeaves(self, root: TreeNode) -\u003e List[List[int]]: def dfs(node): if not node: return -1 h = 1+max(dfs(node.left), dfs(node.right)) if h==len(res): res.append([]) res[h].append(node.val) return h res = [] dfs(root) return res ","date":"2016-01-01","objectID":"/leetcode/0366/:3:0","tags":null,"title":"0366：寻找二叉树的叶子节点（★）","uri":"/leetcode/0366/"},{"categories":null,"content":"故事发生在当代的人间江南小镇和神界。 \n\n门神神荼和郁垒是两兄弟。因为近年人间不再关注神仙，神界经济萧条，门神、土地爷、八仙等等小神们面临下岗失业的危险。门神郁垒决定去人间，做一番惊天动地的事情，证明门神的价值。郁垒和神荼先后来到人间，遇到了小镇上的单亲母女小英和雨儿，之后发生了一系列意想不到的有趣惊险故事……","date":"2016-01-01","objectID":"/anime/little_door_gods/","tags":null,"title":"小门神","uri":"/anime/little_door_gods/"},{"categories":null,"content":"简介 故事发生在当代的人间江南小镇和神界。 门神神荼和郁垒是两兄弟。因为近年人间不再关注神仙，神界经济萧条，门神、土地爷、八仙等等小神们面临下岗失业的危险。门神郁垒决定去人间，做一番惊天动地的事情，证明门神的价值。郁垒和神荼先后来到人间，遇到了小镇上的单亲母女小英和雨儿，之后发生了一系列意想不到的有趣惊险故事…… 制作人员： 导演：王微 剪辑：赵霁 製作：追光人动画设计（北京）有限公司 配音监督：陈家恒 ","date":"2016-01-01","objectID":"/anime/little_door_gods/:1:0","tags":null,"title":"小门神","uri":"/anime/little_door_gods/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 小门神 2016-01-01 1 樱花 ","date":"2016-01-01","objectID":"/anime/little_door_gods/:2:0","tags":null,"title":"小门神","uri":"/anime/little_door_gods/"},{"categories":null,"content":" 力扣第 365 题 ","date":"2015-12-31","objectID":"/leetcode/0365/:0:0","tags":null,"title":"0365：水壶问题（★）","uri":"/leetcode/0365/"},{"categories":null,"content":"题目 有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。 如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。 你可以： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: 输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4 输出: true 解释：来自著名的 \"Die Hard\" 示例 2","date":"2015-12-31","objectID":"/leetcode/0365/:1:0","tags":null,"title":"0365：水壶问题（★）","uri":"/leetcode/0365/"},{"categories":null,"content":"分析 注意到有效的操作对应的容量变化只能是 ±x、±y、0： 有效的 z 必然能表示为 ax+by（a、b为整数） 反过来，若 z 能表示为 ax+by（a、b为整数），且 z\u003c=x+y，可以构造出方案得到 z 根据 裴蜀定理，z 能表示为 ax+by（a、b为整数）等价于 z 是 a、b 的最大公约数的倍数 因此满足 z\u003c=x+y 且 z%gcd(x,y)==0 即可 ","date":"2015-12-31","objectID":"/leetcode/0365/:2:0","tags":null,"title":"0365：水壶问题（★）","uri":"/leetcode/0365/"},{"categories":null,"content":"解答 def canMeasureWater(self, x: int, y: int, z: int) -\u003e bool: return z\u003c=x+y and z%gcd(x,y)==0 28 ms ","date":"2015-12-31","objectID":"/leetcode/0365/:3:0","tags":null,"title":"0365：水壶问题（★）","uri":"/leetcode/0365/"},{"categories":null,"content":" 力扣第 364 题 ","date":"2015-12-30","objectID":"/leetcode/0364/:0:0","tags":null,"title":"0364：加权嵌套序列和 II（★）","uri":"/leetcode/0364/"},{"categories":null,"content":"题目 给你一个整数嵌套列表 nestedList ，每一个元素要么是一个整数，要么是一个列表（这个列表中的每个元素也同样是整数或列表）。 整数的 深度 取决于它位于多少个列表内部。例如，嵌套列表 [1,[2,2],[[3],2],1] 的每个整数的值都等于它的 深度 。令 maxDepth 是任意整数的 最大深度 。 整数的 权重 为 maxDepth - (整数的深度) + 1 。 将 nestedList 列表中每个整数先乘权重再求和，返回该加权和。 示例 1： 输入：nestedList = [[1,1],2,[1,1]] 输出：8 解释：4 个 1 在深度为 1 的位置， 一个 2 在","date":"2015-12-30","objectID":"/leetcode/0364/:1:0","tags":null,"title":"0364：加权嵌套序列和 II（★）","uri":"/leetcode/0364/"},{"categories":null,"content":"分析 类似 0339，只是递归过程中维护最大深度 maxDepth 和所有整数之和 total 即可。 ","date":"2015-12-30","objectID":"/leetcode/0364/:2:0","tags":null,"title":"0364：加权嵌套序列和 II（★）","uri":"/leetcode/0364/"},{"categories":null,"content":"解答 def depthSumInverse(self, nestedList: List[NestedInteger]) -\u003e int: def dfs(nest, w): if nest.isInteger(): self.total += nest.getInteger() self.w = max(self.w, w) return w*nest.getInteger() return sum(dfs(sub, w+1) for sub in nest.getList()) self.total, self.w = 0, 0 return -sum(dfs(nest, 1) for n","date":"2015-12-30","objectID":"/leetcode/0364/:3:0","tags":null,"title":"0364：加权嵌套序列和 II（★）","uri":"/leetcode/0364/"},{"categories":null,"content":" 力扣第 363 题 ","date":"2015-12-29","objectID":"/leetcode/0363/:0:0","tags":null,"title":"0363：矩形区域不超过 K 的最大数值和（★★）","uri":"/leetcode/0363/"},{"categories":null,"content":"题目 给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。 题目数据保证总会存在一个数值和不超过 k 的矩形区域。 示例 1： 输入：matrix = [[1,0,1],[0,-2,3]], k = 2 输出：2 解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。 示例 2： 输入：matrix = [[2,2,-1]], k = 3 输出：3 提示： m == matrix.length n == matrix[i].length 1 \u003c= m, ","date":"2015-12-29","objectID":"/leetcode/0363/:1:0","tags":null,"title":"0363：矩形区域不超过 K 的最大数值和（★★）","uri":"/leetcode/0363/"},{"categories":null,"content":"分析 矩形区域的个数是 $O(M^2N^2)$ 级别，光遍历就会超时了。因此要考虑不完全遍历的方法： 左右边界固定为 \u003cy1,y2\u003e 时，求出每一行 [y1,y2] 的区间和，得到数组 A 问题转为求 A 中不超过 k 的最大区间和，可以用前缀和+有序集合解决 预先保存每一行的前缀和，即可快速求出每一行 [y1,y2] 的区间和 ","date":"2015-12-29","objectID":"/leetcode/0363/:2:0","tags":null,"title":"0363：矩形区域不超过 K 的最大数值和（★★）","uri":"/leetcode/0363/"},{"categories":null,"content":"解答 def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -\u003e int: from sortedcontainers import SortedList res, m, n = float('-inf'), len(matrix), len(matrix[0]) P = [list(accumulate([0]+row)) for row in matrix] for y1 in range(n): for y2 in range(y1, n): A = [row[y2+1]-row[y1] for row in P] sl =","date":"2015-12-29","objectID":"/leetcode/0363/:3:0","tags":null,"title":"0363：矩形区域不超过 K 的最大数值和（★★）","uri":"/leetcode/0363/"},{"categories":null,"content":" 力扣第 362 题 ","date":"2015-12-28","objectID":"/leetcode/0362/:0:0","tags":null,"title":"0362：敲击计数器（★）","uri":"/leetcode/0362/"},{"categories":null,"content":"题目 设计一个敲击计数器，使它可以统计在过去 5 分钟内被敲击次数。（即过去 300 秒） 您的系统应该接受一个时间戳参数 timestamp (单位为 秒 )，并且您可以假定对系统的调用是按时间顺序进行的(即 timestamp 是单调递增的)。几次撞击可能同时发生。 实现 HitCounter 类: HitCounter() 初始化命中计数器系统。 void hit(int timestamp) 记录在 timestamp ( 单位为秒 )发生的一次命中。在同一个 timestamp 中可能会出现几个点击。 int getHits(int timestamp) 返回 timestamp 在","date":"2015-12-28","objectID":"/leetcode/0362/:1:0","tags":null,"title":"0362：敲击计数器（★）","uri":"/leetcode/0362/"},{"categories":null,"content":"分析 只需要过去 300 秒的次数，那么记录每秒的次数，相加即可。 这样也可以处理进阶问题。 ","date":"2015-12-28","objectID":"/leetcode/0362/:2:0","tags":null,"title":"0362：敲击计数器（★）","uri":"/leetcode/0362/"},{"categories":null,"content":"解答 class HitCounter: def __init__(self): self.d = defaultdict(int) def hit(self, timestamp: int) -\u003e None: self.d[timestamp] += 1 def getHits(self, timestamp: int) -\u003e int: return sum(self.d.get(t, 0) for t in range(timestamp-299, timestamp+1)) 44 ms ","date":"2015-12-28","objectID":"/leetcode/0362/:3:0","tags":null,"title":"0362：敲击计数器（★）","uri":"/leetcode/0362/"},{"categories":null,"content":" 力扣第 361 题 ","date":"2015-12-27","objectID":"/leetcode/0361/:0:0","tags":null,"title":"0361：轰炸敌人（★）","uri":"/leetcode/0361/"},{"categories":null,"content":"题目 给你一个大小为 m x n 的矩阵 grid ，其中每个单元格都放置有一个字符： 'W' 表示一堵墙 'E' 表示一个敌人 '0'（数字 0）表示一个空位 返回你使用 一颗炸弹 可以击杀的最大敌人数目。你只能把炸弹放在一个空位里。 由于炸弹的威力不足以穿透墙体，炸弹只能击杀同一行和同一列没被墙体挡住的敌人。 示例 1： 输入：grid = [[\"0\",\"E\",\"0\",\"0\"],[\"E\",\"0\",\"W\",\"E\"],[\"0\",\"E\",\"0\",\"0\"]] 输出：3 示例 2： 输入：grid = [[\"W\",\"W\",\"W\"],[\"0\",\"0\",\"0\"],[\"E\",\"E\",\"E\"]] 输出：1 ","date":"2015-12-27","objectID":"/leetcode/0361/:1:0","tags":null,"title":"0361：轰炸敌人（★）","uri":"/leetcode/0361/"},{"categories":null,"content":"分析 可以一趟递推求出每个格子的左边有多少个不隔墙的敌人。 同理，可以递推求出右/上/下边有多少个不隔墙的敌人。 统计哪个空位的四个方向的总数最大即可。 ","date":"2015-12-27","objectID":"/leetcode/0361/:2:0","tags":null,"title":"0361：轰炸敌人（★）","uri":"/leetcode/0361/"},{"categories":null,"content":"解答 def maxKilledEnemies(self, grid: List[List[str]]) -\u003e int: _key = lambda x,y: 0 if y=='W' else x+(y=='E') cal = lambda row: list(accumulate(row, _key, initial=0))[1:] L = [cal(row) for row in grid] R = [cal(row[::-1])[::-1] for row in grid] U = list(zip(*[cal(col) for col in zip(*grid)])) D = list","date":"2015-12-27","objectID":"/leetcode/0361/:3:0","tags":null,"title":"0361：轰炸敌人（★）","uri":"/leetcode/0361/"},{"categories":null,"content":" 力扣第 360 题 ","date":"2015-12-26","objectID":"/leetcode/0360/:0:0","tags":null,"title":"0360：有序转化数组（★）","uri":"/leetcode/0360/"},{"categories":null,"content":"题目 给你一个已经 排好序 的整数数组 nums 和整数 a 、 b 、 c 。对于数组中的每一个元素 nums[i] ，计算函数值 f(x) = ax2 + bx + c ，请 按升序返回数组 。 示例 1： 输入: nums = [-4,-2,2,4], a = 1, b = 3, c = 5 输出: [3,9,15,33] 示例 2： 输入: nums = [-4,-2,2,4], a = -1, b = 3, c = 5 输出: [-23,-5,1,7] 提示： 1 \u003c= nums.length \u003c= 200 -100 \u003c= nums[i], a, b, c \u003c= 100 nums 按","date":"2015-12-26","objectID":"/leetcode/0360/:1:0","tags":null,"title":"0360：有序转化数组（★）","uri":"/leetcode/0360/"},{"categories":null,"content":"分析 最简单的排序即可。 要求 O(N) 的话则需要考虑到抛物线的性质，分类讨论即可。 ","date":"2015-12-26","objectID":"/leetcode/0360/:2:0","tags":null,"title":"0360：有序转化数组（★）","uri":"/leetcode/0360/"},{"categories":null,"content":"解答 def sortTransformedArray(self, nums: List[int], a: int, b: int, c: int) -\u003e List[int]: return sorted(a*x*x+b*x+c for x in nums) 24 ms ","date":"2015-12-26","objectID":"/leetcode/0360/:3:0","tags":null,"title":"0360：有序转化数组（★）","uri":"/leetcode/0360/"},{"categories":null,"content":" 力扣第 359 题 ","date":"2015-12-25","objectID":"/leetcode/0359/:0:0","tags":null,"title":"0359：日志速率限制器","uri":"/leetcode/0359/"},{"categories":null,"content":"题目 请你设计一个日志系统，可以流式接收消息以及它的时间戳。每条 不重复 的消息最多只能每 10 秒打印一次。也就是说，如果在时间戳 t 打印某条消息，那么相同内容的消息直到时间戳变为 t + 10 之前都不会被打印。 所有消息都按时间顺序发送。多条消息可能到达同一时间戳。 实现 Logger 类： Logger() 初始化 logger 对象 bool shouldPrintMessage(int timestamp, string message) 如果这条消息 message 在给定的时间戳 timestamp 应该被打印出来，则返回 true ，否则请返回 false 。 示例： 输入","date":"2015-12-25","objectID":"/leetcode/0359/:1:0","tags":null,"title":"0359：日志速率限制器","uri":"/leetcode/0359/"},{"categories":null,"content":"分析 维护每条消息的上一时间戳即可。 ","date":"2015-12-25","objectID":"/leetcode/0359/:2:0","tags":null,"title":"0359：日志速率限制器","uri":"/leetcode/0359/"},{"categories":null,"content":"解答 class Logger: def __init__(self): self.d = {} def shouldPrintMessage(self, timestamp: int, message: str) -\u003e bool: if timestamp-self.d.get(message, -10)\u003c10: return False self.d[message] = timestamp return True 116 ms ","date":"2015-12-25","objectID":"/leetcode/0359/:3:0","tags":null,"title":"0359：日志速率限制器","uri":"/leetcode/0359/"},{"categories":null,"content":" 力扣第 358 题 ","date":"2015-12-24","objectID":"/leetcode/0358/:0:0","tags":null,"title":"0358：K 距离间隔重排字符串（★★）","uri":"/leetcode/0358/"},{"categories":null,"content":"题目 给你一个非空的字符串 s 和一个整数 k ，你要将这个字符串 s 中的字母进行重新排列，使得重排后的字符串中相同字母的位置间隔距离 至少 为 k 。如果无法做到，请返回一个空字符串 \"\"。 示例 1： 输入: s = \"aabbcc\", k = 3 输出: \"abcabc\" 解释: 相同的字母在新的字符串中间隔至少 3 个单位距离。 示例 2: 输入: s = \"aaabc\", k = 3 输出: \"\" 解释: 没有办法找到可能的重排结果。 示例 3: 输入: s = \"aaadbbcc\", k = 2 输出: \"abacabcd\" 解释: 相同的字母在新的字符串中间隔至少 2 个单位距","date":"2015-12-24","objectID":"/leetcode/0358/:1:0","tags":null,"title":"0358：K 距离间隔重排字符串（★★）","uri":"/leetcode/0358/"},{"categories":null,"content":"分析 类似 0621，优先选剩余最多且能放的字符即可。 可以用堆维护剩余的字符及个数，用队列维护暂时不能放的字符。 ","date":"2015-12-24","objectID":"/leetcode/0358/:2:0","tags":null,"title":"0358：K 距离间隔重排字符串（★★）","uri":"/leetcode/0358/"},{"categories":null,"content":"解答 def rearrangeString(self, s: str, k: int) -\u003e str: pq = [(-freq, c) for c,freq in Counter(s).items()] heapify(pq) res, busy = '', deque() for i in range(len(s)): if busy and busy[0][2]\u003c=i-k: heappush(pq, busy.popleft()[:2]) if not pq: return '' freq, c = heappop(pq) res += c if freq\u003c-1: busy.appen","date":"2015-12-24","objectID":"/leetcode/0358/:3:0","tags":null,"title":"0358：K 距离间隔重排字符串（★★）","uri":"/leetcode/0358/"},{"categories":null,"content":" 力扣第 357 题 ","date":"2015-12-23","objectID":"/leetcode/0357/:0:0","tags":null,"title":"0357：统计各位数字都不同的数字个数（★）","uri":"/leetcode/0357/"},{"categories":null,"content":"题目 给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 \u003c= x \u003c 10n 。 示例 1： 输入：n = 2 输出：91 解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x \u003c 100 范围内的所有数字。 示例 2： 输入：n = 0 输出：1 提示： 0 \u003c= n \u003c= 8 ","date":"2015-12-23","objectID":"/leetcode/0357/:1:0","tags":null,"title":"0357：统计各位数字都不同的数字个数（★）","uri":"/leetcode/0357/"},{"categories":null,"content":"分析 根据数学知识： [1, 9] 的对应个数：9 [10, 99] 的对应个数：9*9 [100, 999] 的对应个数：998 一般性的，[10^k, 10^(k+1)-1] 的对应个数为 9*perm(9, k)。 因此可以分段计算 [0, 10^n-1] 的对应个数。甚至可以直接打表。 ","date":"2015-12-23","objectID":"/leetcode/0357/:2:0","tags":null,"title":"0357：统计各位数字都不同的数字个数（★）","uri":"/leetcode/0357/"},{"categories":null,"content":"解答 def countNumbersWithUniqueDigits(self, n: int) -\u003e int: return 1+9*sum(perm(9, k) for k in range(n)) 36 ms ","date":"2015-12-23","objectID":"/leetcode/0357/:3:0","tags":null,"title":"0357：统计各位数字都不同的数字个数（★）","uri":"/leetcode/0357/"},{"categories":null,"content":" 力扣第 356 题 ","date":"2015-12-22","objectID":"/leetcode/0356/:0:0","tags":null,"title":"0356：直线镜像（★）","uri":"/leetcode/0356/"},{"categories":null,"content":"题目 在一个二维平面空间中，给你 n 个点的坐标。问，是否能找出一条平行于 y 轴的直线，让这些点关于这条直线成镜像排布？ 注意：题目数据中可能有重复的点。 示例 1： 输入：points = [[1,1],[-1,1]] 输出：true 解释：可以找出 x = 0 这条线。 示例 2： 输入：points = [[1,1],[-1,-1]] 输出：false 解释：无法找出这样一条线。 提示： n == points.length 1 \u003c= n \u003c= 10^4 -10^8 \u003c= points[i][j] \u003c= 10^8 进阶：你能找到比 O(n2) 更优的解法吗? ","date":"2015-12-22","objectID":"/leetcode/0356/:1:0","tags":null,"title":"0356：直线镜像（★）","uri":"/leetcode/0356/"},{"categories":null,"content":"分析 如果可行，那么该直线必然是 x=(min(points)[0]+max(points)[0])/2。 然后遍历每个点，判断其关于该直线的镜像点是否存在即可。 注意：看起来是镜像排布的即可，不一定要两两配对。因此可以直接去重。 ","date":"2015-12-22","objectID":"/leetcode/0356/:2:0","tags":null,"title":"0356：直线镜像（★）","uri":"/leetcode/0356/"},{"categories":null,"content":"解答 def isReflected(self, points: List[List[int]]) -\u003e bool: s = min(points)[0] + max(points)[0] vis = {(x, y) for x, y in points} return all((s-x, y) in vis for x, y in vis) 40 ms ","date":"2015-12-22","objectID":"/leetcode/0356/:3:0","tags":null,"title":"0356：直线镜像（★）","uri":"/leetcode/0356/"},{"categories":null,"content":" 力扣第 355 题 ","date":"2015-12-21","objectID":"/leetcode/0355/:0:0","tags":null,"title":"0355：设计推特（★）","uri":"/leetcode/0355/"},{"categories":null,"content":"题目 设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近 10 条推文。 实现 Twitter 类： Twitter() 初始化简易版推特对象 void postTweet(int userId, int tweetId) 根据给定的 tweetId 和 userId 创建一条新推文。每次调用此函数都会使用一个不同的 tweetId 。 List\u003cInteger\u003e getNewsFeed(int userId) 检索当前用户新闻推送中最近 10 条推文的 ID 。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推","date":"2015-12-21","objectID":"/leetcode/0355/:1:0","tags":null,"title":"0355：设计推特（★）","uri":"/leetcode/0355/"},{"categories":null,"content":"分析 维护一个时间变量 t，记录每个用户发过的推文及时间，记录每个用户的关注列表，检索时将相关的推文合并排序即可。 ","date":"2015-12-21","objectID":"/leetcode/0355/:2:0","tags":null,"title":"0355：设计推特（★）","uri":"/leetcode/0355/"},{"categories":null,"content":"解答 class Twitter: def __init__(self): self.t = 0 self.tw = defaultdict(list) self.fo = defaultdict(set) def postTweet(self, userId: int, tweetId: int) -\u003e None: self.tw[userId].append((tweetId, self.t)) self.t += 1 def getNewsFeed(self, userId: int) -\u003e List[int]: news = {tid: t for uid in (self.fo[us","date":"2015-12-21","objectID":"/leetcode/0355/:3:0","tags":null,"title":"0355：设计推特（★）","uri":"/leetcode/0355/"},{"categories":null,"content":" 力扣第 354 题 ","date":"2015-12-20","objectID":"/leetcode/0354/:0:0","tags":null,"title":"0354：俄罗斯套娃信封问题（★★）","uri":"/leetcode/0354/"},{"categories":null,"content":"题目 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 注意：不允许旋转信封。 示例 1： 输入：envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出：3 解释：最多信封的个数为 3, 组合为: [2,3] =\u003e [5,4] =\u003e [6,7]。 示例 2： 输入：envelopes = [","date":"2015-12-20","objectID":"/leetcode/0354/:1:0","tags":null,"title":"0354：俄罗斯套娃信封问题（★★）","uri":"/leetcode/0354/"},{"categories":null,"content":"分析 将信封按宽度排序： 如果宽度各不相同，等价于在高度序列中找最长递增子序列，即是问题 0300 若存在宽度相同的信封，按高度反序排列，就依然等价 ","date":"2015-12-20","objectID":"/leetcode/0354/:2:0","tags":null,"title":"0354：俄罗斯套娃信封问题（★★）","uri":"/leetcode/0354/"},{"categories":null,"content":"解答 def maxEnvelopes(self, envelopes: List[List[int]]) -\u003e int: A = [] for _, h in sorted(envelopes, key=lambda x: [x[0], -x[1]]): j = bisect_left(A, h) A[j:j + 1] = [h] return len(A) 56 ms ","date":"2015-12-20","objectID":"/leetcode/0354/:3:0","tags":null,"title":"0354：俄罗斯套娃信封问题（★★）","uri":"/leetcode/0354/"},{"categories":null,"content":" 力扣第 353 题 ","date":"2015-12-19","objectID":"/leetcode/0353/:0:0","tags":null,"title":"0353：贪吃蛇（★）","uri":"/leetcode/0353/"},{"categories":null,"content":"题目 请你设计一个 贪吃蛇游戏，该游戏将会在一个 屏幕尺寸 = 宽度 x 高度 的屏幕上运行。如果你不熟悉这个游戏，可以 点击这里 在线试玩。 起初时，蛇在左上角的 (0, 0) 位置，身体长度为 1 个单位。 你将会被给出一个数组形式的食物位置序列 food ，其中 food[i] = (ri, ci) 。当蛇吃到食物时，身子的长度会增加 1 个单位，得分也会 +1 。 食物不会同时出现，会按列表的顺序逐一显示在屏幕上。比方讲，第一个食物被蛇吃掉后，第二个食物才会出现。 当一个食物在屏幕上出现时，保证 不会 出现在被蛇身体占据的格子里。 如果蛇越界（与边界相撞）或者头与 移动后 的身体相撞（","date":"2015-12-19","objectID":"/leetcode/0353/:1:0","tags":null,"title":"0353：贪吃蛇（★）","uri":"/leetcode/0353/"},{"categories":null,"content":"分析 用队列维护蛇身即可。 为了方便，先判断吃没吃到食物，再判断是否失败。 ","date":"2015-12-19","objectID":"/leetcode/0353/:2:0","tags":null,"title":"0353：贪吃蛇（★）","uri":"/leetcode/0353/"},{"categories":null,"content":"解答 class SnakeGame: def __init__(self, width: int, height: int, food: List[List[int]]): self.m = height self.n = width self.food = deque(food) self.snake = deque([(0, 0)]) self.score = 0 self.d = dict(zip('UDLR', [(-1, 0), (1, 0), (0, -1), (0, 1)])) def move(self, direction: str) -\u003e int: x, y = self","date":"2015-12-19","objectID":"/leetcode/0353/:3:0","tags":null,"title":"0353：贪吃蛇（★）","uri":"/leetcode/0353/"},{"categories":null,"content":" 力扣第 352 题 ","date":"2015-12-18","objectID":"/leetcode/0352/:0:0","tags":null,"title":"0352：将数据流变为多个不相交区间（★★）","uri":"/leetcode/0352/"},{"categories":null,"content":"题目 给你一个由非负整数 a1, a2, ..., an 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。 实现 SummaryRanges 类： SummaryRanges() 使用一个空数据流初始化对象。 void addNum(int val) 向数据流中加入整数 val 。 int[][] getIntervals() 以不相交区间 [starti, endi] 的列表形式返回对数据流中整数的总结。 示例： 输入： [\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNu","date":"2015-12-18","objectID":"/leetcode/0352/:1:0","tags":null,"title":"0352：将数据流变为多个不相交区间（★★）","uri":"/leetcode/0352/"},{"categories":null,"content":"分析 0057 升级版。 addNum 时二分查找与 [val,val] 相交的区间下标，替换为合并后的区间即可。 ","date":"2015-12-18","objectID":"/leetcode/0352/:2:0","tags":null,"title":"0352：将数据流变为多个不相交区间（★★）","uri":"/leetcode/0352/"},{"categories":null,"content":"解答 class SummaryRanges: def __init__(self): self.A = [] def addNum(self, val: int) -\u003e None: L, R = val, val i = bisect_left(self.A, L-1, key=lambda x: x[1]) j = bisect_right(self.A, R+1, key=lambda x: x[0]) if i\u003cj: L, R = min(L, self.A[i][0]), max(R, self.A[j-1][1]) self.A[i:j] = [[L, R]] def getInt","date":"2015-12-18","objectID":"/leetcode/0352/:3:0","tags":null,"title":"0352：将数据流变为多个不相交区间（★★）","uri":"/leetcode/0352/"},{"categories":null,"content":" 力扣第 351 题 ","date":"2015-12-17","objectID":"/leetcode/0351/:0:0","tags":null,"title":"0351：安卓系统手势解锁（★）","uri":"/leetcode/0351/"},{"categories":null,"content":"题目 我们都知道安卓有个手势解锁的界面，是一个 3 x 3 的点所绘制出来的网格。用户可以设置一个 “解锁模式” ，通过连接特定序列中的点，形成一系列彼此连接的线段，每个线段的端点都是序列中两个连续的点。如果满足以下两个条件，则 k 点序列是有效的解锁模式： 解锁模式中的所有点 互不相同 。 假如模式中两个连续点的线段需要经过其他点的 中心 ，那么要经过的点 必须提前出现 在序列中（已经经过），不能跨过任何还未被经过的点。 例如，点 5 或 6 没有提前出现的情况下连接点 2 和 9 是有效的，因为从点 2 到点 9 的线没有穿过点 5 或 6 的中心。 然而，点 2 没有提前出现的情况下连接","date":"2015-12-17","objectID":"/leetcode/0351/:1:0","tags":null,"title":"0351：安卓系统手势解锁（★）","uri":"/leetcode/0351/"},{"categories":null,"content":"分析 ","date":"2015-12-17","objectID":"/leetcode/0351/:2:0","tags":null,"title":"0351：安卓系统手势解锁（★）","uri":"/leetcode/0351/"},{"categories":null,"content":"#1 数据较小，可以直接生成所有可能的排列，判断是否有效即可： 本题中，若两点连线经过其它点，必然是这两点的中点 因此判断两个连续点的中点是否为网格、是否已访问即可 def numberOfPatterns(self, m: int, n: int) -\u003e int: def check(A): vis = set() for a, b in pairwise(A): x1, y1 = divmod(a, 3) x2, y2 = divmod(b, 3) mid = (x1+x2)//2*3+(y1+y2)//2 if (x1+x2)%2==0 and (y1+y2)%2==0 and mid ","date":"2015-12-17","objectID":"/leetcode/0351/:2:1","tags":null,"title":"0351：安卓系统手势解锁（★）","uri":"/leetcode/0351/"},{"categories":null,"content":"#2 还可以用状压 dp。 令 dp[st][i] 代表访问过的点集合是 st 且最后一个点是 i 的有效序列数量，即可递推。 ","date":"2015-12-17","objectID":"/leetcode/0351/:2:2","tags":null,"title":"0351：安卓系统手势解锁（★）","uri":"/leetcode/0351/"},{"categories":null,"content":"解答 def numberOfPatterns(self, m: int, n: int) -\u003e int: def check(st, i, j): x1, y1 = divmod(i, 3) x2, y2 = divmod(j, 3) mid = (x1+x2)//2*3+(y1+y2)//2 return (x1+x2)%2 or (y1+y2)%2 or st\u0026(1\u003c\u003cmid) res, dp = 0, [[0]*9 for _ in range(1\u003c\u003c9)] for i in range(9): dp[1\u003c\u003ci][i] = 1 for st in range(1\u003c\u003c9): for i ","date":"2015-12-17","objectID":"/leetcode/0351/:3:0","tags":null,"title":"0351：安卓系统手势解锁（★）","uri":"/leetcode/0351/"},{"categories":null,"content":" 力扣第 350 题 ","date":"2015-12-16","objectID":"/leetcode/0350/:0:0","tags":null,"title":"0350：两个数组的交集 II","uri":"/leetcode/0350/"},{"categories":null,"content":"题目 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 提示： 1 \u003c= nums1.length, nums2.length \u003c= 1000 0 \u003c= nums1[i], nums2[i] \u003c= 1000 进阶： 如果给定","date":"2015-12-16","objectID":"/leetcode/0350/:1:0","tags":null,"title":"0350：两个数组的交集 II","uri":"/leetcode/0350/"},{"categories":null,"content":"分析 直接调用 Counter 求交集即可。 ","date":"2015-12-16","objectID":"/leetcode/0350/:2:0","tags":null,"title":"0350：两个数组的交集 II","uri":"/leetcode/0350/"},{"categories":null,"content":"解答 def intersect(self, nums1: List[int], nums2: List[int]) -\u003e List[int]: return list((Counter(nums1)\u0026Counter(nums2)).elements()) 36 ms ","date":"2015-12-16","objectID":"/leetcode/0350/:3:0","tags":null,"title":"0350：两个数组的交集 II","uri":"/leetcode/0350/"},{"categories":null,"content":" 力扣第 349 题 ","date":"2015-12-15","objectID":"/leetcode/0349/:0:0","tags":null,"title":"0349：两个数组的交集","uri":"/leetcode/0349/"},{"categories":null,"content":"题目 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 提示： 1 \u003c= nums1.length, nums2.length \u003c= 1000 0 \u003c= nums1[i], nums2[i] \u003c= 1000 ","date":"2015-12-15","objectID":"/leetcode/0349/:1:0","tags":null,"title":"0349：两个数组的交集","uri":"/leetcode/0349/"},{"categories":null,"content":"分析 直接调用 set 取交集即可。 ","date":"2015-12-15","objectID":"/leetcode/0349/:2:0","tags":null,"title":"0349：两个数组的交集","uri":"/leetcode/0349/"},{"categories":null,"content":"解答 def intersection(self, nums1: List[int], nums2: List[int]) -\u003e List[int]: return list(set(nums1)\u0026set(nums2)) 44 ms ","date":"2015-12-15","objectID":"/leetcode/0349/:3:0","tags":null,"title":"0349：两个数组的交集","uri":"/leetcode/0349/"},{"categories":null,"content":" 力扣第 348 题 ","date":"2015-12-14","objectID":"/leetcode/0348/:0:0","tags":null,"title":"0348：设计井字棋（★）","uri":"/leetcode/0348/"},{"categories":null,"content":"题目 请在 n × n 的棋盘上，实现一个判定井字棋（Tic-Tac-Toe）胜负的神器，判断每一次玩家落子后，是否有胜出的玩家。 在这个井字棋游戏中，会有 2 名玩家，他们将轮流在棋盘上放置自己的棋子。 在实现这个判定器的过程中，你可以假设以下这些规则一定成立： 1. 每一步棋都是在棋盘内的，并且只能被放置在一个空的格子里； 2. 一旦游戏中有一名玩家胜出的话，游戏将不能再继续； 3. 一个玩家如果在同一行、同一列或者同一斜对角线上都放置了自己的棋子，那么他便获得胜利。 示例: 给定棋盘边长 n = 3, 玩家 1 的棋子符号是 \"X\"，玩家 2 的棋子符号是 \"O\"。 TicTacToe ","date":"2015-12-14","objectID":"/leetcode/0348/:1:0","tags":null,"title":"0348：设计井字棋（★）","uri":"/leetcode/0348/"},{"categories":null,"content":"分析 只需要维护每一行、每一列、对角线上的 ‘X’ 和 ‘O’ 的个数，判断是否等于 n 即可。 特别的，还可以只维护两者之差。 ","date":"2015-12-14","objectID":"/leetcode/0348/:2:0","tags":null,"title":"0348：设计井字棋（★）","uri":"/leetcode/0348/"},{"categories":null,"content":"解答 class TicTacToe: def __init__(self, n: int): self.n = n self.r = [0]*n self.c = [0]*n self.d1 = 0 self.d2 = 0 def move(self, row: int, col: int, player: int) -\u003e int: val = 1 if player == 1 else -1 self.r[row] += val self.c[col] += val self.d1 += val*(row+col==self.n-1) self.d2 += val*(row==col) f","date":"2015-12-14","objectID":"/leetcode/0348/:3:0","tags":null,"title":"0348：设计井字棋（★）","uri":"/leetcode/0348/"},{"categories":null,"content":" 力扣第 347 题 ","date":"2015-12-13","objectID":"/leetcode/0347/:0:0","tags":null,"title":"0347：前 K 个高频元素（★）","uri":"/leetcode/0347/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 提示： 1 \u003c= nums.length \u003c= 105 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 ","date":"2015-12-13","objectID":"/leetcode/0347/:1:0","tags":null,"title":"0347：前 K 个高频元素（★）","uri":"/leetcode/0347/"},{"categories":null,"content":"分析 典型的排序问题。要求优于 O(n log n)，考虑用堆排序。 ","date":"2015-12-13","objectID":"/leetcode/0347/:2:0","tags":null,"title":"0347：前 K 个高频元素（★）","uri":"/leetcode/0347/"},{"categories":null,"content":"解答 def topKFrequent(self, nums: List[int], k: int) -\u003e List[int]: ct = Counter(nums) return nlargest(k, ct.keys(), key=ct.get) 44 ms ","date":"2015-12-13","objectID":"/leetcode/0347/:3:0","tags":null,"title":"0347：前 K 个高频元素（★）","uri":"/leetcode/0347/"},{"categories":null,"content":" 力扣第 346 题 ","date":"2015-12-12","objectID":"/leetcode/0346/:0:0","tags":null,"title":"0346：数据流中的移动平均值","uri":"/leetcode/0346/"},{"categories":null,"content":"题目 给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算其所有整数的移动平均值。 实现 MovingAverage 类： MovingAverage(int size) 用窗口大小 size 初始化对象。 double next(int val) 计算并返回数据流中最后 size 个值的移动平均值。 示例： 输入： [\"MovingAverage\", \"next\", \"next\", \"next\", \"next\"] [[3], [1], [10], [3], [5]] 输出： [null, 1.0, 5.5, 4.66667, 6.0] 解释： MovingAverage moving","date":"2015-12-12","objectID":"/leetcode/0346/:1:0","tags":null,"title":"0346：数据流中的移动平均值","uri":"/leetcode/0346/"},{"categories":null,"content":"分析 维护一个 size 大小的队列，并维护队列元素之和即可。 ","date":"2015-12-12","objectID":"/leetcode/0346/:2:0","tags":null,"title":"0346：数据流中的移动平均值","uri":"/leetcode/0346/"},{"categories":null,"content":"解答 class MovingAverage: def __init__(self, size: int): self.size = size self.A = deque() self.s = 0 def next(self, val: int) -\u003e float: self.A.append(val) self.s += val if len(self.A)\u003eself.size: self.s -= self.A.popleft() return self.s / len(self.A) 52 ms ","date":"2015-12-12","objectID":"/leetcode/0346/:3:0","tags":null,"title":"0346：数据流中的移动平均值","uri":"/leetcode/0346/"},{"categories":null,"content":" 力扣第 345 题 ","date":"2015-12-11","objectID":"/leetcode/0345/:0:0","tags":null,"title":"0345：反转字符串中的元音字母","uri":"/leetcode/0345/"},{"categories":null,"content":"题目 给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。 元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现不止一次。 示例 1： 输入：s = \"hello\" 输出：\"holle\" 示例 2： 输入：s = \"leetcode\" 输出：\"leotcede\" 提示： 1 \u003c= s.length \u003c= 3 * 105 s 由 可打印的 ASCII 字符组成 ","date":"2015-12-11","objectID":"/leetcode/0345/:1:0","tags":null,"title":"0345：反转字符串中的元音字母","uri":"/leetcode/0345/"},{"categories":null,"content":"分析 0344 升级版，指针移动时跳过非元音字母即可。 ","date":"2015-12-11","objectID":"/leetcode/0345/:2:0","tags":null,"title":"0345：反转字符串中的元音字母","uri":"/leetcode/0345/"},{"categories":null,"content":"解答 def reverseVowels(self, s: str) -\u003e str: s = list(s) i, j = 0, len(s) -1 while i \u003c j: if s[i].lower() not in 'aeiou': i += 1 elif s[j].lower() not in 'aeiou': j -= 1 else: s[i], s[j] = s[j], s[i] i += 1 j -= 1 return ''.join(s) 68 ms ","date":"2015-12-11","objectID":"/leetcode/0345/:3:0","tags":null,"title":"0345：反转字符串中的元音字母","uri":"/leetcode/0345/"},{"categories":null,"content":" 力扣第 344 题 ","date":"2015-12-10","objectID":"/leetcode/0344/:0:0","tags":null,"title":"0344：反转字符串","uri":"/leetcode/0344/"},{"categories":null,"content":"题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 示例 1： 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2： 输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 提示： 1 \u003c= s.length \u003c= 105 s[i] 都是 ASCII 码表中的可打印字符 ","date":"2015-12-10","objectID":"/leetcode/0344/:1:0","tags":null,"title":"0344：反转字符串","uri":"/leetcode/0344/"},{"categories":null,"content":"分析 典型的双指针应用。 ","date":"2015-12-10","objectID":"/leetcode/0344/:2:0","tags":null,"title":"0344：反转字符串","uri":"/leetcode/0344/"},{"categories":null,"content":"解答 def reverseString(self, s: List[str]) -\u003e None: i, j = 0, len(s)-1 while i \u003c j: s[i], s[j] = s[j], s[i] i += 1 j -= 1 48 ms ","date":"2015-12-10","objectID":"/leetcode/0344/:3:0","tags":null,"title":"0344：反转字符串","uri":"/leetcode/0344/"},{"categories":null,"content":" 力扣第 343 题 ","date":"2015-12-09","objectID":"/leetcode/0343/:0:0","tags":null,"title":"0343：整数拆分（★）","uri":"/leetcode/0343/"},{"categories":null,"content":"题目 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k \u003e= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 示例 1: 输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 输入: n = 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 提示: 2 \u003c= n \u003c= 58 ","date":"2015-12-09","objectID":"/leetcode/0343/:1:0","tags":null,"title":"0343：整数拆分（★）","uri":"/leetcode/0343/"},{"categories":null,"content":"分析 ","date":"2015-12-09","objectID":"/leetcode/0343/:2:0","tags":null,"title":"0343：整数拆分（★）","uri":"/leetcode/0343/"},{"categories":null,"content":"#1 可以用 dp，按最后一个拆分的数即可递归。 def integerBreak(self, n: int) -\u003e int: dp = [1] * n for i in range(2, n): dp[i] = max(i, max(dp[j]*dp[i-j] for j in range(1, i))) return max(dp[j]*dp[n-j] for j in range(1, n)) 时间复杂度 O(N^2)，28 ms ","date":"2015-12-09","objectID":"/leetcode/0343/:2:1","tags":null,"title":"0343：整数拆分（★）","uri":"/leetcode/0343/"},{"categories":null,"content":"#2 还可以利用数学知识： 假如拆分出的某个数 x\u003e=4 那么将 x 拆为 2 和 x-2，2*(x-2)\u003e=x，乘积不变或增大 因此必然存在最佳方案，拆出的数都小于等于 3 除了 n=2 或 3 的特殊情况，显然拆出 1 会使乘积减小 因此 n\u003e3 时，必然存在最佳方案，拆出的数都是 2 或 3 3 个 2 换成 2 个 3，乘积增大 因此 n\u003e3 时，必然存在最佳方案，拆出 2 的个数 \u003c=2，其它的都是 3。 根据 n%3 的值，即可确定一种最佳方案： n%3 == 0 时，全拆为 3 即可 n%3 == 1 时，拆为 2 个 2，剩下的都为 3 即可 n%3 == 2 时，拆为 1 个","date":"2015-12-09","objectID":"/leetcode/0343/:2:2","tags":null,"title":"0343：整数拆分（★）","uri":"/leetcode/0343/"},{"categories":null,"content":"解答 def integerBreak(self, n: int) -\u003e int: if n \u003c= 3: return n-1 q, r = divmod(n, 3) return 3**q if r==0 else 3**(q-1)*4 if r==1 else 3**q*2 时间复杂度 O(1)，28 ms ","date":"2015-12-09","objectID":"/leetcode/0343/:3:0","tags":null,"title":"0343：整数拆分（★）","uri":"/leetcode/0343/"},{"categories":null,"content":" 力扣第 342 题 ","date":"2015-12-08","objectID":"/leetcode/0342/:0:0","tags":null,"title":"0342：4的幂","uri":"/leetcode/0342/"},{"categories":null,"content":"题目 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x 示例 1： 输入：n = 16 输出：true 示例 2： 输入：n = 5 输出：false 示例 3： 输入：n = 1 输出：true 提示： -231 \u003c= n \u003c= 231 - 1 进阶：你能不使用循环或者递归来完成本题吗？ ","date":"2015-12-08","objectID":"/leetcode/0342/:1:0","tags":null,"title":"0342：4的幂","uri":"/leetcode/0342/"},{"categories":null,"content":"分析 0231 升级版。n 是 4 的幂等价于 n 是 2 的幂且 n 的二进制中的 1 在偶数位上。 只要 n \u0026 0xAAAAAAAA == 0，即说明 n 的二进制不存在奇数位的 1。 ","date":"2015-12-08","objectID":"/leetcode/0342/:2:0","tags":null,"title":"0342：4的幂","uri":"/leetcode/0342/"},{"categories":null,"content":"解答 def isPowerOfFour(self, n: int) -\u003e bool: return n \u003e 0 and n\u0026(n-1) == 0 and n \u0026 0xAAAAAAAA == 0 32 ms ","date":"2015-12-08","objectID":"/leetcode/0342/:3:0","tags":null,"title":"0342：4的幂","uri":"/leetcode/0342/"},{"categories":null,"content":" 力扣第 341 题 ","date":"2015-12-07","objectID":"/leetcode/0341/:0:0","tags":null,"title":"0341：扁平化嵌套列表迭代器（★）","uri":"/leetcode/0341/"},{"categories":null,"content":"题目 给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。 实现扁平迭代器类 NestedIterator ： NestedIterator(List\u003cNestedInteger\u003e nestedList) 用嵌套列表 nestedList 初始化迭代器。 int next() 返回嵌套列表的下一个整数。 boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。 你的代码将会用下述伪代码检测： initial","date":"2015-12-07","objectID":"/leetcode/0341/:1:0","tags":null,"title":"0341：扁平化嵌套列表迭代器（★）","uri":"/leetcode/0341/"},{"categories":null,"content":"分析 ","date":"2015-12-07","objectID":"/leetcode/0341/:2:0","tags":null,"title":"0341：扁平化嵌套列表迭代器（★）","uri":"/leetcode/0341/"},{"categories":null,"content":"#1 可以直接递归将 nextedList 转为一维列表，然后迭代返回即可。 为了方便，可以用转为队列，不断弹出首位元素即可。 class NestedIterator: def __init__(self, nestedList: [NestedInteger]): def dfs(nest): if nest.isInteger(): return [nest.getInteger()] return [x for sub in nest.getList() for x in dfs(sub)] self.A = deque(x for sub in nestedList for x in","date":"2015-12-07","objectID":"/leetcode/0341/:2:1","tags":null,"title":"0341：扁平化嵌套列表迭代器（★）","uri":"/leetcode/0341/"},{"categories":null,"content":"#2 还可以边迭代边转换： 如果队首是列表，就拆为元素加到队首 循环操作直到队首是整数，再弹出即可 为了方便，在 hasNext() 中完成转换，从而判断是否为空 ","date":"2015-12-07","objectID":"/leetcode/0341/:2:2","tags":null,"title":"0341：扁平化嵌套列表迭代器（★）","uri":"/leetcode/0341/"},{"categories":null,"content":"解答 class NestedIterator: def __init__(self, nestedList: [NestedInteger]): self.A = deque(nestedList) def next(self) -\u003e int: return self.A.popleft().getInteger() def hasNext(self) -\u003e bool: while self.A and not self.A[0].isInteger(): self.A.extendleft(self.A.popleft().getList()[::-1]) return bool(self","date":"2015-12-07","objectID":"/leetcode/0341/:3:0","tags":null,"title":"0341：扁平化嵌套列表迭代器（★）","uri":"/leetcode/0341/"},{"categories":null,"content":" 力扣第 340 题 ","date":"2015-12-06","objectID":"/leetcode/0340/:0:0","tags":null,"title":"0340：至多包含 K 个不同字符的最长子串（★）","uri":"/leetcode/0340/"},{"categories":null,"content":"题目 给你一个字符串 s 和一个整数 k ，请你找出 至多 包含 k 个 不同 字符的最长子串，并返回该子串的长度。 示例 1： 输入：s = \"eceba\", k = 2 输出：3 解释：满足题目要求的子串是 \"ece\" ，长度为 3 。 示例 2： 输入：s = \"aa\", k = 1 输出：2 解释：满足题目要求的子串是 \"aa\" ，长度为 2 。 提示： 1 \u003c= s.length \u003c= 5 * 104 0 \u003c= k \u003c= 50 ","date":"2015-12-06","objectID":"/leetcode/0340/:1:0","tags":null,"title":"0340：至多包含 K 个不同字符的最长子串（★）","uri":"/leetcode/0340/"},{"categories":null,"content":"分析 典型的滑动窗口。 ","date":"2015-12-06","objectID":"/leetcode/0340/:2:0","tags":null,"title":"0340：至多包含 K 个不同字符的最长子串（★）","uri":"/leetcode/0340/"},{"categories":null,"content":"解答 def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -\u003e int: res, i, d = 0, 0, defaultdict(int) for j, c in enumerate(s): d[c] += 1 while len(d)\u003ek: d[s[i]] -= 1 if not d[s[i]]: del d[s[i]] i += 1 res = max(res, j-i+1) return res 88 ms ","date":"2015-12-06","objectID":"/leetcode/0340/:3:0","tags":null,"title":"0340：至多包含 K 个不同字符的最长子串（★）","uri":"/leetcode/0340/"},{"categories":null,"content":" 力扣第 339 题 ","date":"2015-12-05","objectID":"/leetcode/0339/:0:0","tags":null,"title":"0339：嵌套列表权重和（★）","uri":"/leetcode/0339/"},{"categories":null,"content":"题目 给定一个嵌套的整数列表 nestedList ，每个元素要么是整数，要么是列表。同时，列表中元素同样也可以是整数或者是另一个列表。 整数的 深度 是其在列表内部的嵌套层数。例如，嵌套列表 [1,[2,2],[[3],2],1] 中每个整数的值就是其深度。 请返回该列表按深度加权后所有整数的总和。 示例 1： 输入：nestedList = [[1,1],2,[1,1]] 输出：10 解释：因为列表中有四个深度为 2 的 1 ，和一个深度为 1 的 2。 示例 2： 输入：nestedList = [1,[4,[6]]] 输出：27 解释：一个深度为 1 的 1，一个深度为 2 的 4，一","date":"2015-12-05","objectID":"/leetcode/0339/:1:0","tags":null,"title":"0339：嵌套列表权重和（★）","uri":"/leetcode/0339/"},{"categories":null,"content":"分析 递归求解即可。 ","date":"2015-12-05","objectID":"/leetcode/0339/:2:0","tags":null,"title":"0339：嵌套列表权重和（★）","uri":"/leetcode/0339/"},{"categories":null,"content":"解答 def depthSum(self, nestedList: List[NestedInteger]) -\u003e int: def dfs(nest, w): if nest.isInteger(): return w*nest.getInteger() return sum(dfs(sub, w+1) for sub in nest.getList()) return sum(dfs(nest, 1) for nest in nestedList) 48 ms ","date":"2015-12-05","objectID":"/leetcode/0339/:3:0","tags":null,"title":"0339：嵌套列表权重和（★）","uri":"/leetcode/0339/"},{"categories":null,"content":" 力扣第 338 题 ","date":"2015-12-04","objectID":"/leetcode/0338/:0:0","tags":null,"title":"0338：比特位计数（★）","uri":"/leetcode/0338/"},{"categories":null,"content":"题目 给你一个整数 n ，对于 0 \u003c= i \u003c= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。 示例 1： 输入：n = 2 输出：[0,1,1] 解释： 0 --\u003e 0 1 --\u003e 1 2 --\u003e 10 示例 2： 输入：n = 5 输出：[0,1,1,2,1,2] 解释： 0 --\u003e 0 1 --\u003e 1 2 --\u003e 10 3 --\u003e 11 4 --\u003e 100 5 --\u003e 101 提示： 0 \u003c= n \u003c= 105 进阶： 很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟","date":"2015-12-04","objectID":"/leetcode/0338/:1:0","tags":null,"title":"0338：比特位计数（★）","uri":"/leetcode/0338/"},{"categories":null,"content":"分析 0191 进阶版。已知 n \u0026 (n-1) 等价于将 n 中最后一个 1 变为 0。 所以 n 的 1 的数目就是 n \u0026 (n-1) 的 1 的数目加 1。递推即可。 ","date":"2015-12-04","objectID":"/leetcode/0338/:2:0","tags":null,"title":"0338：比特位计数（★）","uri":"/leetcode/0338/"},{"categories":null,"content":"解答 def countBits(self, num: int) -\u003e List[int]: dp = [0] for i in range(1, num + 1): dp.append(dp[i \u0026 (i - 1)] + 1) return dp 40 ms ","date":"2015-12-04","objectID":"/leetcode/0338/:3:0","tags":null,"title":"0338：比特位计数（★）","uri":"/leetcode/0338/"},{"categories":null,"content":" 力扣第 337 题 ","date":"2015-12-03","objectID":"/leetcode/0337/:0:0","tags":null,"title":"0337：打家劫舍 III（★）","uri":"/leetcode/0337/"},{"categories":null,"content":"题目 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。 示例 1: 输入: root = [3,2,3,null,3,null,1] 输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7 示例 2: 输入: root = [3,4,5,1,3,null,1]","date":"2015-12-03","objectID":"/leetcode/0337/:1:0","tags":null,"title":"0337：打家劫舍 III（★）","uri":"/leetcode/0337/"},{"categories":null,"content":"分析 令 dfs(node) 同时返回 能偷的最高金额 不偷 node 情况下的最高金额 即可递归。 ","date":"2015-12-03","objectID":"/leetcode/0337/:2:0","tags":null,"title":"0337：打家劫舍 III（★）","uri":"/leetcode/0337/"},{"categories":null,"content":"解答 def rob(self, root: TreeNode) -\u003e int: def dfs(node): if not node: return 0, 0 l1, l2 = dfs(node.left) r1, r2 = dfs(node.right) return max(node.val+l2+r2, l1+r1), l1+r1 return dfs(root)[0] 48 ms ","date":"2015-12-03","objectID":"/leetcode/0337/:3:0","tags":null,"title":"0337：打家劫舍 III（★）","uri":"/leetcode/0337/"},{"categories":null,"content":" 力扣第 336 题 ","date":"2015-12-02","objectID":"/leetcode/0336/:0:0","tags":null,"title":"0336：回文对（★★）","uri":"/leetcode/0336/"},{"categories":null,"content":"题目 给定一组 互不相同 的单词， 找出所有 不同 的索引对 (i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。 示例 1： 输入：words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"] 输出：[[0,1],[1,0],[3,2],[2,4]] 解释：可拼接成的回文串为 [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"] 示例 2： 输入：words = [\"bat\",\"tab\",\"cat\"] 输出：[[0,1],[1,0]] 解释：可拼接成的回文串为 [\"battab\",\"tabbat\"","date":"2015-12-02","objectID":"/leetcode/0336/:1:0","tags":null,"title":"0336：回文对（★★）","uri":"/leetcode/0336/"},{"categories":null,"content":"分析 单词个数范围较大，而单词长度范围较小，因此考虑优化搜索方法。 假如 w1+w2 是回文串，那么必然是以下情况之一： len(w1) == len(w2)，w1==w2[::-1] len(w1) \u003c len(w2), w2 可拆分为 pre、suf，pre==pre[::-1]，suf==w1[::-1] len(w1) \u003e len(w2), w1 可拆分为 pre、suf，pre==w2[::-1]，suf==suf[::-1] 因此，遍历单词 x 的所有拆分方式，假如能拆分为一个回文串和另一个单词 y 的反序，那么 x+y 或者 y+x 就是回文串。 特别注意空单词的情况，空单词+回","date":"2015-12-02","objectID":"/leetcode/0336/:2:0","tags":null,"title":"0336：回文对（★★）","uri":"/leetcode/0336/"},{"categories":null,"content":"解答 def palindromePairs(self, words: List[str]) -\u003e List[List[int]]: res, d = [], {x: i for i, x in enumerate(words)} for i, x in enumerate(words): if x != x[::-1] and x[::-1] in d: res.append([i, d[x[::-1]]]) if x and x==x[::-1] and '' in d: res.extend([[i, d['']], [d[''], i]]) for k in range(1, len(","date":"2015-12-02","objectID":"/leetcode/0336/:3:0","tags":null,"title":"0336：回文对（★★）","uri":"/leetcode/0336/"},{"categories":null,"content":" 力扣第 335 题 ","date":"2015-12-01","objectID":"/leetcode/0335/:0:0","tags":null,"title":"0335：路径交叉（★★）","uri":"/leetcode/0335/"},{"categories":null,"content":"题目 给你一个整数数组 distance 。 从 X-Y 平面上的点 (0,0) 开始，先向北移动 distance[0] 米，然后向西移动 distance[1] 米，向南移动 distance[2] 米，向东移动 distance[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。 判断你所经过的路径是否相交。如果相交，返回 true ；否则，返回 false 。 示例 1： 输入：distance = [2,1,1,2] 输出：true 示例 2： 输入：distance = [1,2,3,4] 输出：false 示例 3： 输入：distance = [1,1,1,1]","date":"2015-12-01","objectID":"/leetcode/0335/:1:0","tags":null,"title":"0335：路径交叉（★★）","uri":"/leetcode/0335/"},{"categories":null,"content":"分析 观察发现，第 i 步的路径只可能和 [i-5,i-3] 范围内的路径交叉。分别判断即可。 ","date":"2015-12-01","objectID":"/leetcode/0335/:2:0","tags":null,"title":"0335：路径交叉（★★）","uri":"/leetcode/0335/"},{"categories":null,"content":"解答 def isSelfCrossing(self, distance: List[int]) -\u003e bool: n, A = len(distance), distance for i in range(3, n): if A[i]\u003e=A[i-2] and A[i-1]\u003c=A[i-3]: return True if i\u003e=4 and A[i-1]==A[i-3] and A[i]+A[i-4]\u003e=A[i-2]: return True if i\u003e=5 and A[i]+A[i-4]\u003e=A[i-2]\u003e=A[i-4] and A[i-1]+A[i-5]\u003e=A[i-3]\u003e=A[i-1]: re","date":"2015-12-01","objectID":"/leetcode/0335/:3:0","tags":null,"title":"0335：路径交叉（★★）","uri":"/leetcode/0335/"},{"categories":null,"content":" 力扣第 334 题 ","date":"2015-11-30","objectID":"/leetcode/0334/:0:0","tags":null,"title":"0334：递增的三元子序列（★）","uri":"/leetcode/0334/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标 (i, j, k) 且满足 i \u003c j \u003c k ，使得 nums[i] \u003c nums[j] \u003c nums[k] ，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [1,2,3,4,5] 输出：true 解释：任何 i \u003c j \u003c k 的三元组都满足题意 示例 2： 输入：nums = [5,4,3,2,1] 输出：false 解释：不存在满足题意的三元组 示例 3： 输入：nums = [2,1,5,0,4,6] 输出：true 解释：三元组 (3, 4","date":"2015-11-30","objectID":"/leetcode/0334/:1:0","tags":null,"title":"0334：递增的三元子序列（★）","uri":"/leetcode/0334/"},{"categories":null,"content":"分析 0300 简化版，当最长递增子序列的长度大于 2 时，即可返回 True。 ","date":"2015-11-30","objectID":"/leetcode/0334/:2:0","tags":null,"title":"0334：递增的三元子序列（★）","uri":"/leetcode/0334/"},{"categories":null,"content":"解答 def increasingTriplet(self, nums: List[int]) -\u003e bool: A = [] for num in nums: j = bisect_left(A, num) A[j:j + 1] = [num] if len(A) \u003e 2: return True return False 132 ms ","date":"2015-11-30","objectID":"/leetcode/0334/:3:0","tags":null,"title":"0334：递增的三元子序列（★）","uri":"/leetcode/0334/"},{"categories":null,"content":" 力扣第 333 题 ","date":"2015-11-29","objectID":"/leetcode/0333/:0:0","tags":null,"title":"0333：最大 BST 子树（★）","uri":"/leetcode/0333/"},{"categories":null,"content":"题目 给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小。其中，最大指的是子树节点数最多的。 二叉搜索树（BST）中的所有节点都具备以下属性： 左子树的值小于其父（根）节点的值。 右子树的值大于其父（根）节点的值。 注意：子树必须包含其所有后代。 示例 1： 输入：root = [10,5,15,1,8,null,7] 输出：3 解释：本例中最大的 BST 子树是高亮显示的子树。返回值是子树的大小，即 3 。 示例 2： 输入：root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1] 输出：2 提示： 树上节点数目的范","date":"2015-11-29","objectID":"/leetcode/0333/:1:0","tags":null,"title":"0333：最大 BST 子树（★）","uri":"/leetcode/0333/"},{"categories":null,"content":"分析 递归返回其子树是否为 BST、最小/大值、节点数，即可判断是否为 BST，并更新最大节点数。 为了方便，当不为 BST 时，可以返回最小值为 -inf，最大值为 inf。 ","date":"2015-11-29","objectID":"/leetcode/0333/:2:0","tags":null,"title":"0333：最大 BST 子树（★）","uri":"/leetcode/0333/"},{"categories":null,"content":"解答 def largestBSTSubtree(self, root: Optional[TreeNode]) -\u003e int: def dfs(node): if not node: return 0, inf, -inf l1, l2, l3 = dfs(node.left) r1, r2, r3 = dfs(node.right) if l3\u003cnode.val\u003cr2: return 1+l1+r1, min(l2, node.val), max(r3, node.val) return max(l1, r1), -inf, inf return dfs(root)[0] 52 ms ","date":"2015-11-29","objectID":"/leetcode/0333/:3:0","tags":null,"title":"0333：最大 BST 子树（★）","uri":"/leetcode/0333/"},{"categories":null,"content":" 力扣第 332 题 ","date":"2015-11-28","objectID":"/leetcode/0332/:0:0","tags":null,"title":"0332：重新安排行程（★★）","uri":"/leetcode/0332/"},{"categories":null,"content":"题目 给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。 例如，行程 [\"JFK\", \"LGA\"] 与 [\"JFK\", \"LGB\"] 相比就更小，排序更靠前。 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。 示例 1： 输入：tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"","date":"2015-11-28","objectID":"/leetcode/0332/:1:0","tags":null,"title":"0332：重新安排行程（★★）","uri":"/leetcode/0332/"},{"categories":null,"content":"分析 本题是经典的欧拉图问题，可以用精妙的 Hierholzer 算法 。 ","date":"2015-11-28","objectID":"/leetcode/0332/:2:0","tags":null,"title":"0332：重新安排行程（★★）","uri":"/leetcode/0332/"},{"categories":null,"content":"解答 def findItinerary(self, tickets: List[List[str]]) -\u003e List[str]: def dfs(u): while nxt[u]: dfs(heappop(nxt[u])) res.append(u) nxt = defaultdict(list) for u, v in tickets: heappush(nxt[u], v) res = [] dfs('JFK') return res[::-1] 32 ms ","date":"2015-11-28","objectID":"/leetcode/0332/:3:0","tags":null,"title":"0332：重新安排行程（★★）","uri":"/leetcode/0332/"},{"categories":null,"content":" 力扣第 331 题 ","date":"2015-11-27","objectID":"/leetcode/0331/:0:0","tags":null,"title":"0331：验证二叉树的前序序列化（★）","uri":"/leetcode/0331/"},{"categories":null,"content":"题目 序列化二叉树的一种方法是使用 前序遍历 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 例如，上面的二叉树可以被序列化为字符串 \"9,3,4,#,#,1,#,#,2,#,6,#,#\"，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。 你可以认为输入格式总是有效的 例如它永远不会包含两个连续的逗号，比如 \"1,,3\" 。 注意：不允许重建树。 示例 1: 输入:","date":"2015-11-27","objectID":"/leetcode/0331/:1:0","tags":null,"title":"0331：验证二叉树的前序序列化（★）","uri":"/leetcode/0331/"},{"categories":null,"content":"分析 前序序列中，叶子节点后必然是两个空节点。 不断将叶子节点和后面的两个空节点替换为一个空节点， 直到只剩下一个空节点，即说明是正确的。 具体实现可以用栈。 ","date":"2015-11-27","objectID":"/leetcode/0331/:2:0","tags":null,"title":"0331：验证二叉树的前序序列化（★）","uri":"/leetcode/0331/"},{"categories":null,"content":"解答 def isValidSerialization(self, preorder: str) -\u003e bool: stack = [] for c in preorder.split(','): while len(stack)\u003e1 and c==stack[-1]=='#'!=stack[-2]: stack.pop() stack.pop() stack.append(c) return stack == ['#'] 32 ms ","date":"2015-11-27","objectID":"/leetcode/0331/:3:0","tags":null,"title":"0331：验证二叉树的前序序列化（★）","uri":"/leetcode/0331/"},{"categories":null,"content":" 力扣第 330 题 ","date":"2015-11-26","objectID":"/leetcode/0330/:0:0","tags":null,"title":"0330：按要求补齐数组（★★）","uri":"/leetcode/0330/"},{"categories":null,"content":"题目 给定一个已排序的正整数数组 nums ，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。 请返回 满足上述要求的最少需要补充的数字个数 。 示例 1: 输入: nums = [1,3], n = 6 输出: 1 解释: 根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。 现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。 其和可以表示数字 1, 2, 3, 4,","date":"2015-11-26","objectID":"/leetcode/0330/:1:0","tags":null,"title":"0330：按要求补齐数组（★★）","uri":"/leetcode/0330/"},{"categories":null,"content":"分析 假设现有组合不能得到的最小数是 x，显然 x 是必须要补充的。加上 x 并更新组合能得到的数，依此循环即可。 具体实现： 先找到第一个 i 使得 nums[i] \u003e sum(nums[:i])+1，sum(nums[:i])+1 即是 x 在位置 i 插入 x，跳回上一步 不需要真的插入，更新 s=sum(nums[:i]) 即可 ","date":"2015-11-26","objectID":"/leetcode/0330/:2:0","tags":null,"title":"0330：按要求补齐数组（★★）","uri":"/leetcode/0330/"},{"categories":null,"content":"解答 def minPatches(self, nums: List[int], n: int) -\u003e int: res, Q, s = 0, deque(nums), 0 while s \u003c n: if Q and Q[0] \u003c= s+1: s += Q.popleft() else: s += s + 1 res += 1 return res 32 ms ","date":"2015-11-26","objectID":"/leetcode/0330/:3:0","tags":null,"title":"0330：按要求补齐数组（★★）","uri":"/leetcode/0330/"},{"categories":null,"content":" 力扣第 329 题 ","date":"2015-11-25","objectID":"/leetcode/0329/:0:0","tags":null,"title":"0329：矩阵中的最长递增路径（★★）","uri":"/leetcode/0329/"},{"categories":null,"content":"题目 给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。 示例 1： 输入：matrix = [[9,9,4],[6,6,8],[2,1,1]] 输出：4 解释：最长递增路径为 [1, 2, 6, 9]。 示例 2： 输入：matrix = [[3,4,5],[3,2,6],[2,2,1]] 输出：4 解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 示例 3： 输入：matrix = [[1]] 输出：1 提示：","date":"2015-11-25","objectID":"/leetcode/0329/:1:0","tags":null,"title":"0329：矩阵中的最长递增路径（★★）","uri":"/leetcode/0329/"},{"categories":null,"content":"分析 显然路径中不存在环，所以直接递归每个点出发的最长路径即可。 ","date":"2015-11-25","objectID":"/leetcode/0329/:2:0","tags":null,"title":"0329：矩阵中的最长递增路径（★★）","uri":"/leetcode/0329/"},{"categories":null,"content":"解答 def longestIncreasingPath(self, matrix: List[List[int]]) -\u003e int: @cache def dfs(i, j): res = 1 for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0\u003c=x\u003cm and 0\u003c=y\u003cn and matrix[i][j]\u003cmatrix[x][y]: res = max(res, 1+dfs(x, y)) return res m, n = len(matrix), len(matrix[0]) return max(dfs(i, j) f","date":"2015-11-25","objectID":"/leetcode/0329/:3:0","tags":null,"title":"0329：矩阵中的最长递增路径（★★）","uri":"/leetcode/0329/"},{"categories":null,"content":" 力扣第 328 题 ","date":"2015-11-24","objectID":"/leetcode/0328/:0:0","tags":null,"title":"0328：奇偶链表（★）","uri":"/leetcode/0328/"},{"categories":null,"content":"题目 给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。 第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。 请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。 你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。 示例 1: 输入: head = [1,2,3,4,5] 输出: [1,3,5,2,4] 示例 2: 输入: head = [2,1,3,5,6,4,7] 输出: [2,3,6,7,1,5,4] 提示: n == 链表中的节点数 0 \u003c= n \u003c= 104 -10","date":"2015-11-24","objectID":"/leetcode/0328/:1:0","tags":null,"title":"0328：奇偶链表（★）","uri":"/leetcode/0328/"},{"categories":null,"content":"分析 类似于 0086 ，将奇数节点先提出来，按顺序链接，末尾再链接到原链表即可。 ","date":"2015-11-24","objectID":"/leetcode/0328/:2:0","tags":null,"title":"0328：奇偶链表（★）","uri":"/leetcode/0328/"},{"categories":null,"content":"解答 def oddEvenList(self, head: ListNode) -\u003e ListNode: dummy1 = p = ListNode(next=head) dummy2 = q = ListNode() while p and p.next: q.next = p.next q = q.next p.next = p.next.next p = p.next q.next = dummy1.next return dummy2.next 48 ms ","date":"2015-11-24","objectID":"/leetcode/0328/:3:0","tags":null,"title":"0328：奇偶链表（★）","uri":"/leetcode/0328/"},{"categories":null,"content":" 力扣第 327 题 ","date":"2015-11-23","objectID":"/leetcode/0327/:0:0","tags":null,"title":"0327：区间和的个数（★★）","uri":"/leetcode/0327/"},{"categories":null,"content":"题目 给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。 区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。 示例 1： 输入：nums = [-2,5,-1], lower = -2, upper = 2 输出：3 解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。 示例 2： 输入：nums = [0], lower = 0, upper = ","date":"2015-11-23","objectID":"/leetcode/0327/:1:0","tags":null,"title":"0327：区间和的个数（★★）","uri":"/leetcode/0327/"},{"categories":null,"content":"分析 区间和容易想到前缀和，于是先得到前缀和数组 pre，pre[i]=sum(nums[:i])。 遍历位置 j，求满足 i\u003cj, lower\u003c=pre[j]-pre[i]\u003c=upper 的 i 个数即可。 于是考虑维护 pre[:j] 的有序集合，即可二分查找 i 的个数。 要进行插入、查找的操作，考虑用 SortedList，都能在 O(logN) 时间内完成。 ","date":"2015-11-23","objectID":"/leetcode/0327/:2:0","tags":null,"title":"0327：区间和的个数（★★）","uri":"/leetcode/0327/"},{"categories":null,"content":"解答 def countRangeSum(self, nums: List[int], lower: int, upper: int) -\u003e int: from sortedcontainers import SortedList res, sl = 0, SortedList() for x in accumulate([0]+nums): res += sl.bisect_right(x-lower)-sl.bisect_left(x-upper) sl.add(x) return res 时间 $O(N*logN)$，1492 ms ","date":"2015-11-23","objectID":"/leetcode/0327/:3:0","tags":null,"title":"0327：区间和的个数（★★）","uri":"/leetcode/0327/"},{"categories":null,"content":" 力扣第 326 题 ","date":"2015-11-22","objectID":"/leetcode/0326/:0:0","tags":null,"title":"0326：3 的幂","uri":"/leetcode/0326/"},{"categories":null,"content":"题目 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x 示例 1： 输入：n = 27 输出：true 示例 2： 输入：n = 0 输出：false 示例 3： 输入：n = 9 输出：true 示例 4： 输入：n = 45 输出：false 提示： -231 \u003c= n \u003c= 231 - 1 进阶：你能不使用循环或者递归来完成本题吗？ ","date":"2015-11-22","objectID":"/leetcode/0326/:1:0","tags":null,"title":"0326：3 的幂","uri":"/leetcode/0326/"},{"categories":null,"content":"分析 类似 0231 ，n 是 3 的幂等价于 n 是正整数且 n 被 3^19 整除。 （3^19 是给定范围内最大的 3 的幂次方） ","date":"2015-11-22","objectID":"/leetcode/0326/:2:0","tags":null,"title":"0326：3 的幂","uri":"/leetcode/0326/"},{"categories":null,"content":"解答 def isPowerOfThree(self, n: int) -\u003e bool: return n \u003e 0 and (3**19) % n == 0 72 ms ","date":"2015-11-22","objectID":"/leetcode/0326/:3:0","tags":null,"title":"0326：3 的幂","uri":"/leetcode/0326/"},{"categories":null,"content":" 力扣第 325 题 ","date":"2015-11-21","objectID":"/leetcode/0325/:0:0","tags":null,"title":"0325：和等于 k 的最长子数组长度（★）","uri":"/leetcode/0325/"},{"categories":null,"content":"题目 给定一个数组 nums 和一个目标值 k，找到和等于 k 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 0。 示例 1: 输入: nums = [1,-1,5,-2,3], k = 3 输出: 4 解释: 子数组 [1, -1, 5, -2] 和等于 3，且长度最长。 示例 2: 输入: nums = [-2,-1,2,1], k = 1 输出: 2 解释: 子数组 [-1, 2] 和等于 1，且长度最长。 提示： 1 \u003c= nums.length \u003c= 2 * 105 -104 \u003c= nums[i] \u003c= 104 -109 \u003c= k \u003c= 109 ","date":"2015-11-21","objectID":"/leetcode/0325/:1:0","tags":null,"title":"0325：和等于 k 的最长子数组长度（★）","uri":"/leetcode/0325/"},{"categories":null,"content":"分析 区间和容易想到前缀和。 先得到前缀和数组 pre，问题转为求 pre 最远的两个元素，其差为 k。 容易想到用哈希表解决。 ","date":"2015-11-21","objectID":"/leetcode/0325/:2:0","tags":null,"title":"0325：和等于 k 的最长子数组长度（★）","uri":"/leetcode/0325/"},{"categories":null,"content":"解答 def maxSubArrayLen(self, nums: List[int], k: int) -\u003e int: res, d = 0, {} for i, x in enumerate(accumulate([0]+nums)): res = max(res, i-d.get(x-k, i)) d.setdefault(x, i) return res 224 ms ","date":"2015-11-21","objectID":"/leetcode/0325/:3:0","tags":null,"title":"0325：和等于 k 的最长子数组长度（★）","uri":"/leetcode/0325/"},{"categories":null,"content":" 力扣第 324 题 ","date":"2015-11-20","objectID":"/leetcode/0324/:0:0","tags":null,"title":"0324：摆动排序 II（★）","uri":"/leetcode/0324/"},{"categories":null,"content":"题目 给你一个整数数组 nums，将它重新排列成 nums[0] \u003c nums[1] \u003e nums[2] \u003c nums[3]... 的顺序。 你可以假设所有输入数组都可以得到满足题目要求的结果。 示例 1： 输入：nums = [1,5,1,1,6,4] 输出：[1,6,1,5,1,4] 解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。 示例 2： 输入：nums = [1,3,2,2,3,1] 输出：[2,3,1,3,1,2] 提示： 1 \u003c= nums.length \u003c= 5 * 104 0 \u003c= nums[i] \u003c= 5000 题目数据保证，对于给定的输入","date":"2015-11-20","objectID":"/leetcode/0324/:1:0","tags":null,"title":"0324：摆动排序 II（★）","uri":"/leetcode/0324/"},{"categories":null,"content":"分析 容易想到将较小的一半和较大的一半交叉放： 令 a=max(较小的一半数)，b=min(较大的一半) 假如 a\u003cb，按顺序放就可以了 假如 a==b 时，按顺序放可能不行 比如用例 [1，2，4，4，4，6] 按顺序放是 [1,4,2,4,4,6] 直觉上来说，应该使 a、b 尽量远离。因此考虑令 a 尽量靠左放，b 尽量靠右放 比如用例 [1，2，4，4，4，6] 可以放置为 [4,6,1,4,2,4] 即符合条件 为了方便，较小/大的一半都逆序放即可 最后证明一下该方案不可行时，必然无解： 假设 n=len(nums) 为偶数 该方案不可行，意味着某个数 x 出现了至少 n//2+1 ","date":"2015-11-20","objectID":"/leetcode/0324/:2:0","tags":null,"title":"0324：摆动排序 II（★）","uri":"/leetcode/0324/"},{"categories":null,"content":"解答 def wiggleSort(self, nums: List[int]) -\u003e None: n = len(nums) nums.sort(reverse=True) nums[1::2], nums[::2] = nums[:n//2], nums[n//2:] 48 ms ","date":"2015-11-20","objectID":"/leetcode/0324/:3:0","tags":null,"title":"0324：摆动排序 II（★）","uri":"/leetcode/0324/"},{"categories":null,"content":" 力扣第 323 题 ","date":"2015-11-19","objectID":"/leetcode/0323/:0:0","tags":null,"title":"0323：无向图中连通分量的数目（★）","uri":"/leetcode/0323/"},{"categories":null,"content":"题目 你有一个包含 n 个节点的图。给定一个整数 n 和一个数组 edges ，其中 edges[i] = [ai, bi] 表示图中 ai 和 bi 之间有一条边。 返回 图中已连接分量的数目 。 示例 1: 输入: n = 5, edges = [[0, 1], [1, 2], [3, 4]] 输出: 2 示例 2: 输入: n = 5, edges = [[0,1], [1,2], [2,3], [3,4]] 输出: 1 提示： 1 \u003c= n \u003c= 2000 1 \u003c= edges.length \u003c= 5000 edges[i].length == 2 0 \u003c= ai \u003c= bi \u003c n ","date":"2015-11-19","objectID":"/leetcode/0323/:1:0","tags":null,"title":"0323：无向图中连通分量的数目（★）","uri":"/leetcode/0323/"},{"categories":null,"content":"分析 典型的并查集，最后计算块的个数即可。 ","date":"2015-11-19","objectID":"/leetcode/0323/:2:0","tags":null,"title":"0323：无向图中连通分量的数目（★）","uri":"/leetcode/0323/"},{"categories":null,"content":"解答 def countComponents(self, n: int, edges: List[List[int]]) -\u003e int: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) f = list(range(n)) for u, v in edges: union(u, v) return len({find(x) for x in range(n)}) 56 ms ","date":"2015-11-19","objectID":"/leetcode/0323/:3:0","tags":null,"title":"0323：无向图中连通分量的数目（★）","uri":"/leetcode/0323/"},{"categories":null,"content":" 力扣第 322 题 ","date":"2015-11-18","objectID":"/leetcode/0322/:0:0","tags":null,"title":"0322：零钱兑换（★）","uri":"/leetcode/0322/"},{"categories":null,"content":"题目 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2： 输入：coins = [2], amount = 3 输出：-1 示例 3： 输入：coins = [1], amount = 0 输出：0 提示： 1 \u003c= coins.length \u003c= 12 1 \u003c= coins[","date":"2015-11-18","objectID":"/leetcode/0322/:1:0","tags":null,"title":"0322：零钱兑换（★）","uri":"/leetcode/0322/"},{"categories":null,"content":"分析 典型的线性 dp，按最后选择的硬币即可递归。 ","date":"2015-11-18","objectID":"/leetcode/0322/:2:0","tags":null,"title":"0322：零钱兑换（★）","uri":"/leetcode/0322/"},{"categories":null,"content":"解答 def coinChange(self, coins: List[int], amount: int) -\u003e int: dp = [0] * (amount+1) for i in range(1, amount+1): dp[i] = 1 + min(dp[i-coin] if coin\u003c=i else float('inf') for coin in coins) return dp[-1] if dp[-1]\u003cfloat('inf') else -1 时间复杂度 $O(N*S)$，848 ms ","date":"2015-11-18","objectID":"/leetcode/0322/:3:0","tags":null,"title":"0322：零钱兑换（★）","uri":"/leetcode/0322/"},{"categories":null,"content":" 力扣第 321 题 ","date":"2015-11-17","objectID":"/leetcode/0321/:0:0","tags":null,"title":"0321：拼接最大数（★★★）","uri":"/leetcode/0321/"},{"categories":null,"content":"题目 给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k \u003c= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。 求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。 说明: 请尽可能地优化你算法的时间和空间复杂度。 示例 1: 输入: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 输出: [9, 8, 6, 5, 3] 示例 2: 输入: nums1 = [6, 7] nums2 = [6, 0,","date":"2015-11-17","objectID":"/leetcode/0321/:1:0","tags":null,"title":"0321：拼接最大数（★★★）","uri":"/leetcode/0321/"},{"categories":null,"content":"分析 假设 nums1 取出 x 个，nums2 取出 k-x 个： 显然应该使 nums1 取出的 x 个数拼成的数最大，这等价于 0402 同理取出 nums2 的数 可以归求出这 k 个数能拼成的最大数 那么遍历 x，分别计算即可。 注意归并时当两个指针指向元素相等，要比较后面的元素。为了方便，可以直接比较数组后缀。 ","date":"2015-11-17","objectID":"/leetcode/0321/:2:0","tags":null,"title":"0321：拼接最大数（★★★）","uri":"/leetcode/0321/"},{"categories":null,"content":"解答 def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -\u003e List[int]: def select(A, i): stack, j = [], len(A)-i for x in A: while j and stack and stack[-1]\u003cx: stack.pop() j -= 1 stack.append(x) return stack[:i] def gen(i): A, B = select(nums1, i), select(nums2, k-i) return [max(A,B).pop(0","date":"2015-11-17","objectID":"/leetcode/0321/:3:0","tags":null,"title":"0321：拼接最大数（★★★）","uri":"/leetcode/0321/"},{"categories":null,"content":" 力扣第 320 题 ","date":"2015-11-16","objectID":"/leetcode/0320/:0:0","tags":null,"title":"0320：列举单词的全部缩写（★）","uri":"/leetcode/0320/"},{"categories":null,"content":"题目 单词的 广义缩写词 可以通过下述步骤构造：先取任意数量的 不重叠、不相邻 的子字符串，再用它们各自的长度进行替换。 例如，\"abcde\" 可以缩写为： \"a3e\"（\"bcd\" 变为 \"3\" ） \"1bcd1\"（\"a\" 和 \"e\" 都变为 \"1\"） \"5\" (\"abcde\" 变为 \"5\") \"abcde\" (没有子字符串被代替) 然而，这些缩写是 无效的 ： \"23\"（\"ab\" 变为 \"2\" ，\"cde\" 变为 \"3\" ）是无效的，因为被选择的字符串是相邻的 \"22de\" (\"ab\" 变为 \"2\" ， \"bc\" 变为 \"2\") 是无效的，因为被选择的字符串是重叠的 给你一个字符串 word","date":"2015-11-16","objectID":"/leetcode/0320/:1:0","tags":null,"title":"0320：列举单词的全部缩写（★）","uri":"/leetcode/0320/"},{"categories":null,"content":"分析 每个广义缩写词即对应一种缩写位置的集合，因此遍历 word 的子集并缩写即可。 可以用状态压缩来表示集合。 ","date":"2015-11-16","objectID":"/leetcode/0320/:2:0","tags":null,"title":"0320：列举单词的全部缩写（★）","uri":"/leetcode/0320/"},{"categories":null,"content":"解答 def generateAbbreviations(self, word: str) -\u003e List[str]: def gen(st): res, cnt = '', 0 for c, bit in zip(word, bin(st)[2:].zfill(n)): if bit == '1': res += str(cnt or '') + c cnt = 0 else: cnt += 1 return res + str(cnt or '') n = len(word) return [gen(st) for st in range(1\u003c\u003cn)] 204 ms ","date":"2015-11-16","objectID":"/leetcode/0320/:3:0","tags":null,"title":"0320：列举单词的全部缩写（★）","uri":"/leetcode/0320/"},{"categories":null,"content":" 力扣第 319 题 ","date":"2015-11-15","objectID":"/leetcode/0319/:0:0","tags":null,"title":"0319：灯泡开关（★）","uri":"/leetcode/0319/"},{"categories":null,"content":"题目 初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。 第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。 找出并返回 n 轮后有多少个亮着的灯泡。 示例 1： 输入：n = 3 输出：1 解释： 初始时, 灯泡状态 [关闭, 关闭, 关闭]. 第一轮后, 灯泡状态 [开启, 开启, 开启]. 第二轮后, 灯泡状态 [开启, 关闭, 开启]. 第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因","date":"2015-11-15","objectID":"/leetcode/0319/:1:0","tags":null,"title":"0319：灯泡开关（★）","uri":"/leetcode/0319/"},{"categories":null,"content":"分析 可以观察每个位置的灯泡切换了多少次： 位置 x 的灯泡，第 i 轮切换等价于 x % i == 0 位置 x 的灯泡的切换次数即为 x 的因数个数 根据数学知识，只有完全平方数有奇数个因数，其它都是偶数个因数。 因此计算 1 到 n 有多少个完全平方数即可。 ","date":"2015-11-15","objectID":"/leetcode/0319/:2:0","tags":null,"title":"0319：灯泡开关（★）","uri":"/leetcode/0319/"},{"categories":null,"content":"解答 def bulbSwitch(self, n: int) -\u003e int: return int(sqrt(n)) 44 ms ","date":"2015-11-15","objectID":"/leetcode/0319/:3:0","tags":null,"title":"0319：灯泡开关（★）","uri":"/leetcode/0319/"},{"categories":null,"content":" 力扣第 318 题 ","date":"2015-11-14","objectID":"/leetcode/0318/:0:0","tags":null,"title":"0318：最大单词长度乘积（★）","uri":"/leetcode/0318/"},{"categories":null,"content":"题目 给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。 示例 1： 输入：words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"] 输出：16 解释：这两个单词为 \"abcw\", \"xtfn\"。 示例 2： 输入：words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"] 输出：4 解释：这两个单词为 \"ab\", \"cd\"。 示例 3： 输入：words = [\"a\",\"","date":"2015-11-14","objectID":"/leetcode/0318/:1:0","tags":null,"title":"0318：最大单词长度乘积（★）","uri":"/leetcode/0318/"},{"categories":null,"content":"分析 ","date":"2015-11-14","objectID":"/leetcode/0318/:2:0","tags":null,"title":"0318：最大单词长度乘积（★）","uri":"/leetcode/0318/"},{"categories":null,"content":"#1 先保存每个单词的字母集合，然后遍历每一对单词，判断是否有公共字母即可。 def maxProduct(self, words: List[str]) -\u003e int: A, n = [set(w) for w in words], len(words) return max(len(words[i])*len(words[j]) if not A[i] \u0026 A[j] else 0 for i in range(n) for j in range(i)) 1024 ms ","date":"2015-11-14","objectID":"/leetcode/0318/:2:1","tags":null,"title":"0318：最大单词长度乘积（★）","uri":"/leetcode/0318/"},{"categories":null,"content":"#2 注意到可能有多个单词的字母集合相同，所以可以用状态压缩表示的字母集合作为 key，保存对应的最大长度。 ","date":"2015-11-14","objectID":"/leetcode/0318/:2:2","tags":null,"title":"0318：最大单词长度乘积（★）","uri":"/leetcode/0318/"},{"categories":null,"content":"解答 def maxProduct(self, words: List[str]) -\u003e int: d = defaultdict(int) for w in words: st = reduce(lambda x, y: x | 1 \u003c\u003c (ord(y) - ord('a')), w, 0) d[st] = max(d[st], len(w)) return max([d[a] * d[b] for a in d for b in d if not a \u0026 b], default=0) 284 ms ","date":"2015-11-14","objectID":"/leetcode/0318/:3:0","tags":null,"title":"0318：最大单词长度乘积（★）","uri":"/leetcode/0318/"},{"categories":null,"content":" 力扣第 317 题 ","date":"2015-11-13","objectID":"/leetcode/0317/:0:0","tags":null,"title":"0317：离建筑物最近的距离（★★）","uri":"/leetcode/0317/"},{"categories":null,"content":"题目 给你一个 m × n 的网格，值为 0 、 1 或 2 ，其中: 每一个 0 代表一块你可以自由通过的 空地 每一个 1 代表一个你不能通过的 建筑 每个 2 标记一个你不能通过的 障碍 你想要在一块空地上建造一所房子，在 最短的总旅行距离 内到达所有的建筑。你只能上下左右移动。 返回到该房子的 最短旅行距离 。如果根据上述规则无法建造这样的房子，则返回 -1 。 总旅行距离 是朋友们家到聚会地点的距离之和。 使用 曼哈顿距离 计算距离，其中距离 (p1, p2) = |p2.x - p1.x | + | p2.y - p1.y | 。 示例 1： 输入：grid = [[1,0,2,0","date":"2015-11-13","objectID":"/leetcode/0317/:1:0","tags":null,"title":"0317：离建筑物最近的距离（★★）","uri":"/leetcode/0317/"},{"categories":null,"content":"分析 典型的 bfs。从每个建筑开始遍历，求得空地到每个建筑的距离，总和最小的空地即为所求。 细节上的优化： 遍历时，记录空地能到达的建筑个数，若空地不能到达某个已遍历建筑，则该空地可以视为障碍 为了与障碍的 2 区分，可以记录为负数 用 dis 数组维护空地到已遍历建筑的距离之和，节省时间和空间 ","date":"2015-11-13","objectID":"/leetcode/0317/:2:0","tags":null,"title":"0317：离建筑物最近的距离（★★）","uri":"/leetcode/0317/"},{"categories":null,"content":"解答 def shortestDistance(self, grid: List[List[int]]) -\u003e int: def bfs(i, j, k): Q = deque([(i, j, 0)]) while Q: i, j, w = Q.popleft() for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]: if 0\u003c=x\u003cm and 0\u003c=y\u003cn and grid[x][y]==-k: Q.append((x, y, w+1)) dis[x][y] += w+1 grid[x][y] -= 1 m, n = len(grid),","date":"2015-11-13","objectID":"/leetcode/0317/:3:0","tags":null,"title":"0317：离建筑物最近的距离（★★）","uri":"/leetcode/0317/"},{"categories":null,"content":" 力扣第 316 题 ","date":"2015-11-12","objectID":"/leetcode/0316/:0:0","tags":null,"title":"0316：去除重复字母（★★）","uri":"/leetcode/0316/"},{"categories":null,"content":"题目 给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 示例 1： 输入：s = \"bcabc\" 输出：\"abc\" 示例 2： 输入：s = \"cbacdcbc\" 输出：\"acdb\" 提示： 1 \u003c= s.length \u003c= 104 s 由小写英文字母组成 注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同 ","date":"2015-11-12","objectID":"/leetcode/0316/:1:0","tags":null,"title":"0316：去除重复字母（★★）","uri":"/leetcode/0316/"},{"categories":null,"content":"分析 0402 的进阶版。如果没有每个字母出现一次的限制，保持字符串升序即可。 为了保证每个字母出现一次: 若某个字母已经在栈中，应该跳过它 若某个字母后面不再出现，就不能去掉它 ","date":"2015-11-12","objectID":"/leetcode/0316/:2:0","tags":null,"title":"0316：去除重复字母（★★）","uri":"/leetcode/0316/"},{"categories":null,"content":"解答 def removeDuplicateLetters(self, s: str) -\u003e str: stack, vis, ct = [], set(), Counter(s) for c in s: ct[c] -= 1 if c not in vis: while stack and stack[-1]\u003ec and ct[stack[-1]]: vis.remove(stack.pop()) stack.append(c) vis.add(c) return ''.join(stack) 32 ms ","date":"2015-11-12","objectID":"/leetcode/0316/:3:0","tags":null,"title":"0316：去除重复字母（★★）","uri":"/leetcode/0316/"},{"categories":null,"content":" 力扣第 315 题 ","date":"2015-11-11","objectID":"/leetcode/0315/:0:0","tags":null,"title":"0315：计算右侧小于当前元素的个数（★★）","uri":"/leetcode/0315/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例 1： 输入：nums = [5,2,6,1] 输出：[2,1,1,0] 解释： 5 的右侧有 2 个更小的元素 (2 和 1) 2 的右侧仅有 1 个更小的元素 (1) 6 的右侧有 1 个更小的元素 (1) 1 的右侧有 0 个更小的元素 示例 2： 输入：nums = [-1] 输出：[0] 示例 3： 输入：nums = [-1,-1] 输出：[0,0] 提示： 1 \u003c= nums.lengt","date":"2015-11-11","objectID":"/leetcode/0315/:1:0","tags":null,"title":"0315：计算右侧小于当前元素的个数（★★）","uri":"/leetcode/0315/"},{"categories":null,"content":"分析 考虑从右往左遍历，并维护一个有序集合。二分查找 nums[i] 的位置即可得到 counts[i]。 要进行插入、查找的操作，考虑用 SortedList 维护，都能在 O(logN) 时间内完成。 ","date":"2015-11-11","objectID":"/leetcode/0315/:2:0","tags":null,"title":"0315：计算右侧小于当前元素的个数（★★）","uri":"/leetcode/0315/"},{"categories":null,"content":"解答 def countSmaller(self, nums: List[int]) -\u003e List[int]: from sortedcontainers import SortedList n = len(nums) res, sl = [0]*n, SortedList() for i in range(n-1, -1, -1): res[i] = sl.bisect_left(nums[i]) sl.add(nums[i]) return res 时间 $O(N*logN)$，1088 ms ","date":"2015-11-11","objectID":"/leetcode/0315/:3:0","tags":null,"title":"0315：计算右侧小于当前元素的个数（★★）","uri":"/leetcode/0315/"},{"categories":null,"content":" 力扣第 314 题 ","date":"2015-11-10","objectID":"/leetcode/0314/:0:0","tags":null,"title":"0314：二叉树的垂直遍历（★）","uri":"/leetcode/0314/"},{"categories":null,"content":"题目 给你一个二叉树的根结点，返回其结点按 垂直方向（从上到下，逐列）遍历的结果。 如果两个结点在同一行和列，那么顺序则为 从左到右。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[[9],[3,15],[20],[7]] 示例 2： 输入：root = [3,9,8,4,0,1,7] 输出：[[4],[9],[3,0,1],[8],[7]] 示例 3： 输入：root = [3,9,8,4,0,1,7,null,null,null,2,5] 输出：[[4],[9,5],[3,0,1],[8,2],[7]] 提示： 树中结点的数目在范围 [0, 100","date":"2015-11-10","objectID":"/leetcode/0314/:1:0","tags":null,"title":"0314：二叉树的垂直遍历（★）","uri":"/leetcode/0314/"},{"categories":null,"content":"分析 中序遍历并按坐标存到哈希表中，最后再按排序后的坐标输出即可。 ","date":"2015-11-10","objectID":"/leetcode/0314/:2:0","tags":null,"title":"0314：二叉树的垂直遍历（★）","uri":"/leetcode/0314/"},{"categories":null,"content":"解答 def verticalOrder(self, root: TreeNode) -\u003e List[List[int]]: d = defaultdict(lambda: defaultdict(list)) stack = [(root, 0, 0)] while stack: node, x, y = stack.pop() if node: d[x][y].append(node.val) stack.extend([(node.right, x+1, y+1), (node.left, x-1,y+1)]) return [[val for y in sorted(d[x]) for","date":"2015-11-10","objectID":"/leetcode/0314/:3:0","tags":null,"title":"0314：二叉树的垂直遍历（★）","uri":"/leetcode/0314/"},{"categories":null,"content":" 力扣第 313 题 ","date":"2015-11-09","objectID":"/leetcode/0313/:0:0","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"题目 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。 给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。 题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。 示例 1： 输入：n = 12, primes = [2,7,13,19] 输出：32 解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。 示例 2： 输入：n = 1, primes = [2,3,5] 输出：1 解释：1 不含质因数，因","date":"2015-11-09","objectID":"/leetcode/0313/:1:0","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"分析 ","date":"2015-11-09","objectID":"/leetcode/0313/:2:0","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"#1 类似 0264，只不过质数数组不固定了。 def nthSuperUglyNumber(self, n: int, primes: List[int]) -\u003e int: dp, A = [1] * n, defaultdict(int) for i in range(1, n): dp[i] = min(dp[A[p]] * p for p in primes) for p in primes: if dp[A[p]] * p == dp[i]: A[p] += 1 return dp[-1] 时间 $O(N*M)$，超时了 ","date":"2015-11-09","objectID":"/leetcode/0313/:2:1","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"#2 注意到每次是取最小的 dp[A[p]]*p，想到可以用堆来维护 \u003cdp[A[p]]*p, A[p], p\u003e 三元组，可以快速获得最小值。 ","date":"2015-11-09","objectID":"/leetcode/0313/:2:2","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"解答 def nthSuperUglyNumber(self, n: int, primes: List[int]) -\u003e int: dp = [1] * n pq = [(p, 0, p) for p in primes] for i in range(1, n): dp[i] = pq[0][0] while pq and pq[0][0] == dp[i]: _, idx, p = heappop(pq) heappush(pq, (dp[idx+1] * p, idx+1, p)) return dp[-1] 时间 $O(N*logM)$，2548 ms ","date":"2015-11-09","objectID":"/leetcode/0313/:3:0","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":" 力扣第 312 题 ","date":"2015-11-08","objectID":"/leetcode/0312/:0:0","tags":null,"title":"0312：戳气球（★★）","uri":"/leetcode/0312/"},{"categories":null,"content":"题目 有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。 求所能获得硬币的最大数量。 示例 1： 输入：nums = [3,1,5,8] 输出：167 解释： nums = [3,1,5,8] --\u003e [3,5,8] --\u003e [3,8] --\u003e [8]","date":"2015-11-08","objectID":"/leetcode/0312/:1:0","tags":null,"title":"0312：戳气球（★★）","uri":"/leetcode/0312/"},{"categories":null,"content":"分析 为了方便，在前后各加一个数字 1 的气球得到数组 A。问题转为求 A 戳破非边界气球能得到的最大硬币数。 假设最后戳破第 k 个气球，获得 A[0]*A[-1]*A[k] 个硬币，剩下的即转为 A[:k+1] 和 A[k:] 的递归子问题。 令 dp[i][j] 代表 A[i:j+1] 能得到的最大硬币数，则递推式为： $$dp[i][j] = max(A[k]*A[i]*A[j]+dp[i][k]+dp[k][j])_{\\ i\u003ck\u003cj}$$ ","date":"2015-11-08","objectID":"/leetcode/0312/:2:0","tags":null,"title":"0312：戳气球（★★）","uri":"/leetcode/0312/"},{"categories":null,"content":"解答 def maxCoins(self, nums: List[int]) -\u003e int: A = [1]+nums+[1] n = len(A) dp = [[0]*n for _ in range(n)] for i in range(n-3, -1, -1): for j in range(i+2, n): dp[i][j] = max(A[k]*A[i]*A[j]+dp[i][k]+dp[k][j] for k in range(i+1, j)) return dp[0][-1] 时间复杂度 O(N^3)，2968 ms ","date":"2015-11-08","objectID":"/leetcode/0312/:3:0","tags":null,"title":"0312：戳气球（★★）","uri":"/leetcode/0312/"},{"categories":null,"content":" 力扣第 311 题 ","date":"2015-11-07","objectID":"/leetcode/0311/:0:0","tags":null,"title":"0311：稀疏矩阵的乘法（★）","uri":"/leetcode/0311/"},{"categories":null,"content":"题目 给定两个 稀疏矩阵 ：大小为 m x k 的稀疏矩阵 mat1 和大小为 k x n 的稀疏矩阵 mat2 ，返回 mat1 x mat2 的结果。你可以假设乘法总是可能的。 示例 1： 输入：mat1 = [[1,0,0],[-1,0,3]], mat2 = [[7,0,0],[0,0,0],[0,0,1]] 输出：[[7,0,0],[-7,0,3]] 示例 2: 输入：mat1 = [[0]], mat2 = [[0]] 输出：[[0]] 提示: m == mat1.length k == mat1[i].length == mat2.length n == mat2[i].leng","date":"2015-11-07","objectID":"/leetcode/0311/:1:0","tags":null,"title":"0311：稀疏矩阵的乘法（★）","uri":"/leetcode/0311/"},{"categories":null,"content":"分析 暴力计算即可。 ","date":"2015-11-07","objectID":"/leetcode/0311/:2:0","tags":null,"title":"0311：稀疏矩阵的乘法（★）","uri":"/leetcode/0311/"},{"categories":null,"content":"解答 def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -\u003e List[List[int]]: return [[sum(a*b for a, b in zip(row, col)) for col in zip(*mat2)] for row in mat1] 96 ms ","date":"2015-11-07","objectID":"/leetcode/0311/:3:0","tags":null,"title":"0311：稀疏矩阵的乘法（★）","uri":"/leetcode/0311/"},{"categories":null,"content":" 力扣第 310 题 ","date":"2015-11-06","objectID":"/leetcode/0310/:0:0","tags":null,"title":"0310：最小高度树（★）","uri":"/leetcode/0310/"},{"categories":null,"content":"题目 树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。 给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。 可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。 请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。 树的 ","date":"2015-11-06","objectID":"/leetcode/0310/:1:0","tags":null,"title":"0310：最小高度树（★）","uri":"/leetcode/0310/"},{"categories":null,"content":"分析 本题是拓扑排序的变种。从最外层的叶子节点向里面广度遍历，最里面的一层即是所求。 无向图的拓扑排序从考虑入度 0 变为考虑入度 1 的节点即可。 注意 n=1 的特殊情况。 ","date":"2015-11-06","objectID":"/leetcode/0310/:2:0","tags":null,"title":"0310：最小高度树（★）","uri":"/leetcode/0310/"},{"categories":null,"content":"解答 def findMinHeightTrees(self, n: int, edges: List[List[int]]) -\u003e List[int]: nxt, indeg = defaultdict(list), [0] * n for u, v in edges: nxt[u].append(v) nxt[v].append(u) indeg[u] += 1 indeg[v] += 1 res, Q = [], [u for u in range(n) if indeg[u] \u003c= 1] while Q: res, Q = Q, [] for u in res: for v in nx","date":"2015-11-06","objectID":"/leetcode/0310/:3:0","tags":null,"title":"0310：最小高度树（★）","uri":"/leetcode/0310/"},{"categories":null,"content":" 力扣第 309 题 ","date":"2015-11-05","objectID":"/leetcode/0309/:0:0","tags":null,"title":"0309：最佳买卖股票时机含冷冻期（★）","uri":"/leetcode/0309/"},{"categories":null,"content":"题目 给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: prices = [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 示例 2: 输入: prices = [1] 输出: 0 提示： 1 \u003c= prices.length \u003c= 5000 0 ","date":"2015-11-05","objectID":"/leetcode/0309/:1:0","tags":null,"title":"0309：最佳买卖股票时机含冷冻期（★）","uri":"/leetcode/0309/"},{"categories":null,"content":"分析 0122 升级版，dp[i][0] 的递推式有变化： $$dp[i][0] = max(dp[i-1][0], dp[i-2][1]-prices[i-1])$$ ","date":"2015-11-05","objectID":"/leetcode/0309/:2:0","tags":null,"title":"0309：最佳买卖股票时机含冷冻期（★）","uri":"/leetcode/0309/"},{"categories":null,"content":"解答 def maxProfit(self, prices: List[int]) -\u003e int: a, b, c = float('-inf'), 0, 0 for price in prices: a, b, c = max(a, b-price), c, max(c, a+price) return c 32 ms ","date":"2015-11-05","objectID":"/leetcode/0309/:3:0","tags":null,"title":"0309：最佳买卖股票时机含冷冻期（★）","uri":"/leetcode/0309/"},{"categories":null,"content":" 力扣第 308 题 ","date":"2015-11-04","objectID":"/leetcode/0308/:0:0","tags":null,"title":"0308：二维区域和检索 - 可变（★★）","uri":"/leetcode/0308/"},{"categories":null,"content":"题目 给你一个二维矩阵 matrix ，处理以下类型的多个查询: 更新 matrix 中单元格的值。 计算由 左上角 (row1, col1) 和 右下角 (row2, col2) 定义的 matrix 内矩阵元素的 和。 实现 NumMatrix 类： NumMatrix(int[][] matrix) 用整数矩阵 matrix 初始化对象。 void update(int row, int col, int val) 更新 matrix[row][col] 的值到 val 。 int sumRegion(int row1, int col1, int row2, int col2) 返回矩","date":"2015-11-04","objectID":"/leetcode/0308/:1:0","tags":null,"title":"0308：二维区域和检索 - 可变（★★）","uri":"/leetcode/0308/"},{"categories":null,"content":"分析 0304 升级版，元素不固定了。 朴素的想法是维护每一行的前缀和即可，update 时间 O(N)，sumRegion 时间 O(M)。 ","date":"2015-11-04","objectID":"/leetcode/0308/:2:0","tags":null,"title":"0308：二维区域和检索 - 可变（★★）","uri":"/leetcode/0308/"},{"categories":null,"content":"解答 class NumMatrix: def __init__(self, matrix: List[List[int]]): self.matrix = matrix self.P = [list(accumulate([0]+sub)) for sub in matrix] def update(self, row: int, col: int, val: int) -\u003e None: self.matrix[row][col] = val self.P[row] = list(accumulate([0]+self.matrix[row])) def sumRegion(self, ro","date":"2015-11-04","objectID":"/leetcode/0308/:3:0","tags":null,"title":"0308：二维区域和检索 - 可变（★★）","uri":"/leetcode/0308/"},{"categories":null,"content":"*附加 类似 0307 ，也可以用树状数组解决，采用二维树状数组。 class NumMatrix: def __init__(self, matrix: List[List[int]]): m, n = len(matrix), len(matrix[0]) self.matrix = matrix self.tree = [[0]*(n+1) for _ in range(m+1)] for i, j in product(range(m), range(n)): self.add(i+1, j+1, matrix[i][j]) def lowbit(self, x): return x ","date":"2015-11-04","objectID":"/leetcode/0308/:4:0","tags":null,"title":"0308：二维区域和检索 - 可变（★★）","uri":"/leetcode/0308/"},{"categories":null,"content":" 力扣第 307 题 ","date":"2015-11-03","objectID":"/leetcode/0307/:0:0","tags":null,"title":"0307：区域和检索 - 数组可修改（★）","uri":"/leetcode/0307/"},{"categories":null,"content":"题目 给你一个数组 nums ，请你完成两类查询。 其中一类查询要求 更新 数组 nums 下标对应的值 另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left \u003c= right 实现 NumArray 类： NumArray(int[] nums) 用整数数组 nums 初始化对象 void update(int index, int val) 将 nums[index] 的值 更新 为 val int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right ","date":"2015-11-03","objectID":"/leetcode/0307/:1:0","tags":null,"title":"0307：区域和检索 - 数组可修改（★）","uri":"/leetcode/0307/"},{"categories":null,"content":"分析 0303 升级版，元素不固定了。 每次 sumRange 都挨个求和，显然会有大量不必要的运算。 有个想法是维护一些区间和，修改的数无关时就无需重新计算区间和。 这个想法也就是块状数组： 将数组分成大小 size 的块，并计算得到每一块的和 update 时，更新该数所属的块的和即可 sumRange 时，其中包含的完整的块的和无需再计算，只需计算两边的残块的和 完整的块最多有 n//size 个，残块的元素个数不超过 2*size 个 因此，当 size 取 $\\sqrt n$ 时，sumRange 时间是 $O(\\sqrt n)$ ","date":"2015-11-03","objectID":"/leetcode/0307/:2:0","tags":null,"title":"0307：区域和检索 - 数组可修改（★）","uri":"/leetcode/0307/"},{"categories":null,"content":"解答 class NumArray: def __init__(self, nums: List[int]): n = len(nums) self.size = int(sqrt(n)) self.B = [0]*((n-1)//self.size+1) for i in range(n): self.B[i//self.size] += nums[i] self.nums = nums def update(self, index: int, val: int) -\u003e None: self.B[index//self.size] += val-self.nums[index] self.n","date":"2015-11-03","objectID":"/leetcode/0307/:3:0","tags":null,"title":"0307：区域和检索 - 数组可修改（★）","uri":"/leetcode/0307/"},{"categories":null,"content":"*附加 还有个专门针对 单点更新+区间查询 的算法——树状数组。更新和查询时间 O(logN)。 为了方便，用 tree[i] 维护数组 [0]+nums 的区间 (i-lowbit(i), i] 的和 class NumArray: def __init__(self, nums: List[int]): self.nums = nums self.tree = [0] * (len(nums)+1) for i, num in enumerate(nums): self.add(i+1, num) def lowbit(self, x): return x \u0026 -x def add(sel","date":"2015-11-03","objectID":"/leetcode/0307/:4:0","tags":null,"title":"0307：区域和检索 - 数组可修改（★）","uri":"/leetcode/0307/"},{"categories":null,"content":" 力扣第 306 题 ","date":"2015-11-02","objectID":"/leetcode/0306/:0:0","tags":null,"title":"0306：累加数（★）","uri":"/leetcode/0306/"},{"categories":null,"content":"题目 累加数 是一个字符串，组成它的数字可以形成累加序列。 一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。 给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。 说明：累加序列里的数，除数字 0 之外，不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。 示例 1： 输入：\"112358\" 输出：true 解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3","date":"2015-11-02","objectID":"/leetcode/0306/:1:0","tags":null,"title":"0306：累加数（★）","uri":"/leetcode/0306/"},{"categories":null,"content":"分析 类似 0093，回溯即可。 ","date":"2015-11-02","objectID":"/leetcode/0306/:2:0","tags":null,"title":"0306：累加数（★）","uri":"/leetcode/0306/"},{"categories":null,"content":"解答 def isAdditiveNumber(self, num: str) -\u003e bool: def dfs(i): if len(path) \u003e= 3 and path[-1] != path[-2] + path[-3]: return False if i == n: return len(path) \u003e 2 for j in range(i+1, n + 1 if num[i] != '0' else i+2): path.append(int(num[i:j])) if dfs(j): return True path.pop() return False path, n = [","date":"2015-11-02","objectID":"/leetcode/0306/:3:0","tags":null,"title":"0306：累加数（★）","uri":"/leetcode/0306/"},{"categories":null,"content":" 力扣第 305 题 ","date":"2015-11-01","objectID":"/leetcode/0305/:0:0","tags":null,"title":"0305：岛屿数量 II（★★）","uri":"/leetcode/0305/"},{"categories":null,"content":"题目 给你一个大小为 m x n 的二进制网格 grid 。网格表示一个地图，其中，0 表示水，1 表示陆地。最初，grid 中的所有单元格都是水单元格（即，所有单元格都是 0）。 可以通过执行 addLand 操作，将某个位置的水转换成陆地。给你一个数组 positions ，其中 positions[i] = [ri, ci] 是要执行第 i 次操作的位置 (ri, ci) 。 返回一个整数数组 answer ，其中 answer[i] 是将单元格 (ri, ci) 转换为陆地后，地图中岛屿的数量。 岛屿 的定义是被「水」包围的「陆地」，通过水平方向或者垂直方向上相邻的陆地连接而成。你可以","date":"2015-11-01","objectID":"/leetcode/0305/:1:0","tags":null,"title":"0305：岛屿数量 II（★★）","uri":"/leetcode/0305/"},{"categories":null,"content":"分析 典型的并查集，维护并查集的块的个数即可。 ","date":"2015-11-01","objectID":"/leetcode/0305/:2:0","tags":null,"title":"0305：岛屿数量 II（★★）","uri":"/leetcode/0305/"},{"categories":null,"content":"解答 def numIslands2(self, m: int, n: int, positions: List[List[int]]) -\u003e List[int]: def find(x): if f.setdefault(x, x) != x: f[x] = find(f[x]) return f[x] def union(x, y): fx, fy = find(x), find(y) if fx != fy: f[fx] = fy self.cnt -= 1 res, f, self.cnt = [], {}, 0 for i, j in positions: if (i, j) not","date":"2015-11-01","objectID":"/leetcode/0305/:3:0","tags":null,"title":"0305：岛屿数量 II（★★）","uri":"/leetcode/0305/"},{"categories":null,"content":" 力扣第 304 题 ","date":"2015-10-31","objectID":"/leetcode/0304/:0:0","tags":null,"title":"0304：二维区域和检索 - 矩阵不可变（★）","uri":"/leetcode/0304/"},{"categories":null,"content":"题目 给定一个二维矩阵 matrix，以下类型的多个请求： 计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。 实现 NumMatrix 类： NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化 int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。 示例 1： 输入: [\"NumMatrix\",\"sumRegion\",\"su","date":"2015-10-31","objectID":"/leetcode/0304/:1:0","tags":null,"title":"0304：二维区域和检索 - 矩阵不可变（★）","uri":"/leetcode/0304/"},{"categories":null,"content":"分析 0303 的升级版，需要用二维前缀和。 令 $$ pre[i][j] = \\sum_{\\substack {0 \\le r\u003ci \\\\ 0 \\le c\u003cj }} matrix[r][c] $$那么： $$sumRegion(r1, c1, r2, c2) = pre[r2+1][c2+1] \\\\ -pre[r1][c2+1]-pre[r2+1][c1]+pre[r1][c1]$$ ","date":"2015-10-31","objectID":"/leetcode/0304/:2:0","tags":null,"title":"0304：二维区域和检索 - 矩阵不可变（★）","uri":"/leetcode/0304/"},{"categories":null,"content":"解答 class NumMatrix: def __init__(self, matrix: List[List[int]]): self.pre = [list(accumulate((0,)+col)) for col in zip(*matrix)] self.pre = [list(accumulate((0,)+col)) for col in zip(*self.pre)] def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -\u003e int: return self.pre[row2+1][col2+1]-s","date":"2015-10-31","objectID":"/leetcode/0304/:3:0","tags":null,"title":"0304：二维区域和检索 - 矩阵不可变（★）","uri":"/leetcode/0304/"},{"categories":null,"content":" 力扣第 303 题 ","date":"2015-10-30","objectID":"/leetcode/0303/:0:0","tags":null,"title":"0303：区域和检索 - 数组不可变","uri":"/leetcode/0303/"},{"categories":null,"content":"题目 给定一个整数数组 nums，处理以下类型的多个查询: 计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left \u003c= right 实现 NumArray 类： NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] ) 示例 1： 输入： [\"","date":"2015-10-30","objectID":"/leetcode/0303/:1:0","tags":null,"title":"0303：区域和检索 - 数组不可变","uri":"/leetcode/0303/"},{"categories":null,"content":"分析 典型的前缀和问题。 ","date":"2015-10-30","objectID":"/leetcode/0303/:2:0","tags":null,"title":"0303：区域和检索 - 数组不可变","uri":"/leetcode/0303/"},{"categories":null,"content":"解答 class NumArray: def __init__(self, nums: List[int]): self.pre = list(accumulate([0]+nums)) def sumRange(self, left: int, right: int) -\u003e int: return self.pre[right+1] - self.pre[left] 76 ms ","date":"2015-10-30","objectID":"/leetcode/0303/:3:0","tags":null,"title":"0303：区域和检索 - 数组不可变","uri":"/leetcode/0303/"},{"categories":null,"content":" 力扣第 302 题 ","date":"2015-10-29","objectID":"/leetcode/0302/:0:0","tags":null,"title":"0302：包含全部黑色像素的最小矩形（★★）","uri":"/leetcode/0302/"},{"categories":null,"content":"题目 图片在计算机处理中往往是使用二维矩阵来表示的。 给你一个大小为 m x n 的二进制矩阵 image 表示一张黑白图片，0 代表白色像素，1 代表黑色像素。 黑色像素相互连接，也就是说，图片中只会有一片连在一块儿的黑色像素。像素点是水平或竖直方向连接的。 给你两个整数 x 和 y 表示某一个黑色像素的位置，请你找出包含全部黑色像素的最小矩形（与坐标轴对齐），并返回该矩形的面积。 你必须设计并实现一个时间复杂度低于 O(mn) 的算法来解决此问题。 示例 1： 输入：image = [[\"0\",\"0\",\"1\",\"0\"],[\"0\",\"1\",\"1\",\"0\"],[\"0\",\"1\",\"0\",\"0\"]","date":"2015-10-29","objectID":"/leetcode/0302/:1:0","tags":null,"title":"0302：包含全部黑色像素的最小矩形（★★）","uri":"/leetcode/0302/"},{"categories":null,"content":"分析 要求时间复杂度低于 O(mn)，也就是不能遍历完矩阵。于是考虑二分查找： 假设最左边的黑色像素的横坐标是 y1，那么 对任意 0\u003c=c\u003cy1，第 c 列没有黑色像素 对任意 y1\u003c=c\u003c=y，第 c 列有黑色像素 所以可以二分查找出 y1 所求矩形的左边界即是 y1 同理可找出右/上/下边界，即得到面积 ","date":"2015-10-29","objectID":"/leetcode/0302/:2:0","tags":null,"title":"0302：包含全部黑色像素的最小矩形（★★）","uri":"/leetcode/0302/"},{"categories":null,"content":"解答 def minArea(self, image: List[List[str]], x: int, y: int) -\u003e int: m, n, A = len(image), len(image[0]), image x1 = bisect_left(range(x), True, key=lambda i: '1' in A[i]) x2 = bisect_left(range(m), True, x, m, key=lambda i: '1' not in A[i]) y1 = bisect_left(range(y), True, key=lambda j: any(A[i][j]","date":"2015-10-29","objectID":"/leetcode/0302/:3:0","tags":null,"title":"0302：包含全部黑色像素的最小矩形（★★）","uri":"/leetcode/0302/"},{"categories":null,"content":" 力扣第 301 题 ","date":"2015-10-28","objectID":"/leetcode/0301/:0:0","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"题目 给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。 返回所有可能的结果。答案可以按 任意顺序 返回。 示例 1： 输入：s = \"()())()\" 输出：[\"(())()\",\"()()()\"] 示例 2： 输入：s = \"(a)())()\" 输出：[\"(a())()\",\"(a)()()\"] 示例 3： 输入：s = \")(\" 输出：[\"\"] 提示： 1 \u003c= s.length \u003c= 25 s 由小写英文字母以及括号 '(' 和 ')' 组成 s 中至多含 20 个括号 ","date":"2015-10-28","objectID":"/leetcode/0301/:1:0","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"分析 ","date":"2015-10-28","objectID":"/leetcode/0301/:2:0","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"#1 1249 的升级版，但要求所有最少删除数的方案。 考虑先得到最少删除数 k，然后遍历所有删除 k 个括号的子序列，判断是否有效即可。 def removeInvalidParentheses(self, s: str) -\u003e List[str]: def cal(s): ans, stack = 0, [] for char in s: if char == '(': stack.append(char) elif char == ')': if stack: stack.pop() else: ans += 1 return ans + len(stack) ss = {s} for ","date":"2015-10-28","objectID":"/leetcode/0301/:2:1","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"#2 注意到计算最少删除数时，其实只关心栈的长度。所以可以用一个变量来维护，而无需真正地进行栈操作。 ","date":"2015-10-28","objectID":"/leetcode/0301/:2:2","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"解答 def removeInvalidParentheses(self, s: str) -\u003e List[str]: def cal(s): ans, size = 0, 0 for char in s: size += 1 if char == '(' else -1 if char == ')' else 0 if size \u003c 0: ans, size = ans+1, 0 return ans + size ss = {s} for _ in range(cal(s)): ss = {sub[:i]+sub[i+1:] for sub in ss for i in range(len","date":"2015-10-28","objectID":"/leetcode/0301/:3:0","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":" 力扣第 300 题 ","date":"2015-10-27","objectID":"/leetcode/0300/:0:0","tags":null,"title":"0300：最长递增子序列（★）","uri":"/leetcode/0300/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1 提示： 1 \u003c= nums.length \u003c= 2500 -104 ","date":"2015-10-27","objectID":"/leetcode/0300/:1:0","tags":null,"title":"0300：最长递增子序列（★）","uri":"/leetcode/0300/"},{"categories":null,"content":"分析 ","date":"2015-10-27","objectID":"/leetcode/0300/:2:0","tags":null,"title":"0300：最长递增子序列（★）","uri":"/leetcode/0300/"},{"categories":null,"content":"#1 子序列/子数组相关的问题容易想到遍历结尾位置 j，分别找最值。 令 dp[j] 代表结尾位置 j 的最长递增子序列长度。那么： $$dp[j] = 1 + max(dp[i])_{\\begin{subarray}{l} i \\ in \\ range(j) \\\\ if \\ nums[i]\u003cnums[j] \\end{subarray}}$$ 递推即可。 def lengthOfLIS(self, nums: List[int]) -\u003e int: n = len(nums) dp = [0] * n for j in range(n): dp[j] = 1 + max([dp[i] for i","date":"2015-10-27","objectID":"/leetcode/0300/:2:1","tags":null,"title":"0300：最长递增子序列（★）","uri":"/leetcode/0300/"},{"categories":null,"content":"#2 本题还有个很经典的优化解法： 假如 dp[i1]==dp[i2] 且 nums[i1]\u003cnums[i2]，那么在递推式中只需要考虑 i1 而不用考虑 i2 令 A[k] 代表使 dp[i]==k 的最小 nums[i]，递推式即转为： $$dp[j] = 1 + max(k)_{\\begin{subarray}{l} k \\ in \\ range(j) \\\\ if \\ A[k]\u003cnums[j] \\end{subarray}}$$ 注意到 A 是严格递增的数组，因此可以二分查找最大的 k 得到 dp[j] 后，只需要更新 A[k+1] = nums[j] 即可维护 A 额外的，令 A 初始","date":"2015-10-27","objectID":"/leetcode/0300/:2:2","tags":null,"title":"0300：最长递增子序列（★）","uri":"/leetcode/0300/"},{"categories":null,"content":"解答 def lengthOfLIS(self, nums: List[int]) -\u003e int: A = [] for num in nums: j = bisect_left(A, num) A[j:j + 1] = [num] return len(A) 时间 $O(N*logN)$，40 ms ","date":"2015-10-27","objectID":"/leetcode/0300/:3:0","tags":null,"title":"0300：最长递增子序列（★）","uri":"/leetcode/0300/"},{"categories":null,"content":" 力扣第 299 题 ","date":"2015-10-26","objectID":"/leetcode/0299/:0:0","tags":null,"title":"0299：猜数字游戏（★）","uri":"/leetcode/0299/"},{"categories":null,"content":"题目 你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下： 写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示： 猜测数字中有多少位属于数字和确切位置都猜对了（称为 \"Bulls\"，公牛）， 有多少位属于数字猜对了但是位置不对（称为 \"Cows\"，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。 给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。 提示的格式为 \"xAyB\" ，x 是公牛个数， y 是奶牛个数，A 表示公牛，B 表示奶牛。 请注意秘密数字","date":"2015-10-26","objectID":"/leetcode/0299/:1:0","tags":null,"title":"0299：猜数字游戏（★）","uri":"/leetcode/0299/"},{"categories":null,"content":"分析 计算 “Bulls” 很简单，但 “Cows” 较麻烦。可以考虑先计算 Bulls+Cows，即数字正确的个数， 再减去 Bulls 即是 Cows。 ","date":"2015-10-26","objectID":"/leetcode/0299/:2:0","tags":null,"title":"0299：猜数字游戏（★）","uri":"/leetcode/0299/"},{"categories":null,"content":"解答 def getHint(self, secret: str, guess: str) -\u003e str: A = sum(s==g for s,g in zip(secret, guess)) C = sum((Counter(secret)\u0026Counter(guess)).values()) return '%dA%dB' % (A, C-A) 48 ms ","date":"2015-10-26","objectID":"/leetcode/0299/:3:0","tags":null,"title":"0299：猜数字游戏（★）","uri":"/leetcode/0299/"},{"categories":null,"content":" 力扣第 298 题 ","date":"2015-10-25","objectID":"/leetcode/0298/:0:0","tags":null,"title":"0298：二叉树最长连续序列（★）","uri":"/leetcode/0298/"},{"categories":null,"content":"题目 给你一棵指定的二叉树的根节点 root ，请你计算其中 最长连续序列路径 的长度。 最长连续序列路径 是依次递增 1 的路径。该路径，可以是从某个初始节点到树中任意节点，通过「父 - 子」关系连接而产生的任意路径。且必须从父节点到子节点，反过来是不可以的。 示例 1： 输入：root = [1,null,3,2,4,null,null,null,5] 输出：3 解释：当中，最长连续序列是 3-4-5 ，所以返回结果为 3 。 示例 2： 输入：root = [2,null,3,2,null,1] 输出：2 解释：当中，最长连续序列是 2-3 。注意，不是 3-2-1，所以返回 2 。 提","date":"2015-10-25","objectID":"/leetcode/0298/:1:0","tags":null,"title":"0298：二叉树最长连续序列（★）","uri":"/leetcode/0298/"},{"categories":null,"content":"分析 可以递归求出每个节点开始的最长连续路径。 ","date":"2015-10-25","objectID":"/leetcode/0298/:2:0","tags":null,"title":"0298：二叉树最长连续序列（★）","uri":"/leetcode/0298/"},{"categories":null,"content":"解答 def longestConsecutive(self, root: TreeNode) -\u003e int: def dfs(p): if not p: return 0 ans = 1 for child in [p.left, p.right]: tmp = dfs(child) if child and child.val==p.val+1: ans = max(ans, 1+tmp) self.res = max(self.res, ans) return ans self.res = 0 dfs(root) return self.res 104 ms ","date":"2015-10-25","objectID":"/leetcode/0298/:3:0","tags":null,"title":"0298：二叉树最长连续序列（★）","uri":"/leetcode/0298/"},{"categories":null,"content":" 力扣第 297 题 ","date":"2015-10-24","objectID":"/leetcode/0297/:0:0","tags":null,"title":"0297：二叉树的序列化与反序列化（★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 示例 1： 输入：root = [1,2,3,null,null","date":"2015-10-24","objectID":"/leetcode/0297/:1:0","tags":null,"title":"0297：二叉树的序列化与反序列化（★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"分析 ","date":"2015-10-24","objectID":"/leetcode/0297/:2:0","tags":null,"title":"0297：二叉树的序列化与反序列化（★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"#1 最简单粗暴的是 json 做法， 将树转为多重字典，用 json 序列化/反序列化。 class Codec: def serialize(self, root): def dfs(node): if not node: return 'None' return {'val': node.val, 'left':dfs(node.left), 'right':dfs(node.right) } return json.dumps(dfs(root)) def deserialize(self, data): def dfs(data): if data=='None': return N","date":"2015-10-24","objectID":"/leetcode/0297/:2:1","tags":null,"title":"0297：二叉树的序列化与反序列化（★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"#2 也可以用树的遍历列表来对应，空节点用 ‘#’ 表示即可。 这里采用前序遍历： 序列化时，递归地拼接遍历列表。 反序列化时，从遍历列表 Q 中弹出第一个元素作为 root，然后递归地构建左右子树。 遇到空节点时就返回上一层递归即可。 ","date":"2015-10-24","objectID":"/leetcode/0297/:2:2","tags":null,"title":"0297：二叉树的序列化与反序列化（★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"解答 class Codec: def serialize(self, root): def dfs(node): if not node: return '#' return '%d,%s,%s' % (node.val, dfs(node.left), dfs(node.right)) return dfs(root) def deserialize(self, data): def dfs(): val = Q.popleft() return None if val=='#' else TreeNode(val, dfs(), dfs()) Q = deque(data.split('","date":"2015-10-24","objectID":"/leetcode/0297/:3:0","tags":null,"title":"0297：二叉树的序列化与反序列化（★★）","uri":"/leetcode/0297/"},{"categories":null,"content":" 力扣第 296 题 ","date":"2015-10-23","objectID":"/leetcode/0296/:0:0","tags":null,"title":"0296：最佳的碰头地点（★★）","uri":"/leetcode/0296/"},{"categories":null,"content":"题目 给你一个 m x n 的二进制网格 grid ，其中 1 表示某个朋友的家所处的位置。返回 最小的 总行走距离 。 总行走距离 是朋友们家到碰头地点的距离之和。 我们将使用 曼哈顿距离 来计算，其中 distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y| 。 示例 1： 输入: grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]] 输出: 6 解释: 给定的三个人分别住在(0,0)，(0,4) 和 (2,2): (0,2) 是一个最佳的碰面点，其总行走距离为 2 + 2 + 2 = 6，最小，因此返回 6。 示","date":"2015-10-23","objectID":"/leetcode/0296/:1:0","tags":null,"title":"0296：最佳的碰头地点（★★）","uri":"/leetcode/0296/"},{"categories":null,"content":"分析 用 A 保存所有位置的 x 坐标，A 的中位数即是最佳位置的 x 坐标。y 坐标同理。 ","date":"2015-10-23","objectID":"/leetcode/0296/:2:0","tags":null,"title":"0296：最佳的碰头地点（★★）","uri":"/leetcode/0296/"},{"categories":null,"content":"解答 def minTotalDistance(self, grid: List[List[int]]) -\u003e int: def cal(grid): A = [i for i, row in enumerate(grid) for val in row if val==1] half = len(A) // 2 return sum(A[-half:])-sum(A[:half]) return cal(grid)+cal(zip(*grid)) 40 ms ","date":"2015-10-23","objectID":"/leetcode/0296/:3:0","tags":null,"title":"0296：最佳的碰头地点（★★）","uri":"/leetcode/0296/"},{"categories":null,"content":" 力扣第 295 题 ","date":"2015-10-22","objectID":"/leetcode/0295/:0:0","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"题目 中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。 例如 arr = [2,3,4] 的中位数是 3 。 例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。 实现 MedianFinder 类: MedianFinder() 初始化 MedianFinder 对象。 void addNum(int num) 将数据流中的整数 num 添加到数据结构中。 double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。 示例 1： 输入 [\"MedianFind","date":"2015-10-22","objectID":"/leetcode/0295/:1:0","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"分析 ","date":"2015-10-22","objectID":"/leetcode/0295/:2:0","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"#1 考虑维护一个有序集合，根据中间位置的一个数或两个数即可得到中位数。 要进行插入、访问的操作，考虑用 SortedList，都能在 O(logN) 时间内完成。 class MedianFinder: def __init__(self): from sortedcontainers import SortedList self.sl = SortedList() def addNum(self, num: int) -\u003e None: self.sl.add(num) def findMedian(self) -\u003e float: n = len(self.sl) return (self.","date":"2015-10-22","objectID":"/leetcode/0295/:2:1","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"#2 也可以用双堆维护： 用两个堆 low、high 分别维护较小的一半和较大的一半 low 为大顶堆，high 为小顶堆，并且保证 len(low)\u003e=len(high) addNum 时 先将元素添加到 low 中，弹出堆顶并添加到 high 中 如果 len(low)\u003clen(high)，就再弹出 high 堆顶添加到 low 中 findMedian 时 若 len(low)==len(high)，中位数等于 (max(low)+min(high))//2 若 len(low)\u003elen(high)，中位数等于 max(low) addNum 时间复杂度 O(logN)，findMedi","date":"2015-10-22","objectID":"/leetcode/0295/:2:2","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"解答 class MedianFinder: def __init__(self): self.low, self.high = [], [] def addNum(self, num: int) -\u003e None: heappush(self.high, -heappushpop(self.low, -num)) if len(self.high) \u003e len(self.low): heappush(self.low, -heappop(self.high)) def findMedian(self) -\u003e float: return (-self.low[0]+self.high[0]) /","date":"2015-10-22","objectID":"/leetcode/0295/:3:0","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":" 力扣第 294 题 ","date":"2015-10-21","objectID":"/leetcode/0294/:0:0","tags":null,"title":"0294：翻转游戏 II（★★★）","uri":"/leetcode/0294/"},{"categories":null,"content":"题目 你和朋友玩一个叫做「翻转游戏」的游戏。游戏规则如下： 给你一个字符串 currentState ，其中只含 '+' 和 '-' 。你和朋友轮流将 连续 的两个 \"++\" 反转成 \"--\" 。当一方无法进行有效的翻转时便意味着游戏结束，则另一方获胜。默认每个人都会采取最优策略。 请你写出一个函数来判定起始玩家 是否存在必胜的方案 ：如果存在，返回 true ；否则，返回 false 。 示例 1： 输入：currentState = \"++++\" 输出：true 解释：起始玩家可将中间的 \"++\" 翻转变为 \"+--+\" 从而得胜。 示例 2： 输入：currentState = \"+\" ","date":"2015-10-21","objectID":"/leetcode/0294/:1:0","tags":null,"title":"0294：翻转游戏 II（★★★）","uri":"/leetcode/0294/"},{"categories":null,"content":"分析 典型的博弈问题，考虑用 dp，遍历每种操作并递归即可。 ","date":"2015-10-21","objectID":"/leetcode/0294/:2:0","tags":null,"title":"0294：翻转游戏 II（★★★）","uri":"/leetcode/0294/"},{"categories":null,"content":"解答 def canWin(self, currentState: str) -\u003e bool: @cache def dfs(s): for i in range(len(s)): if s[i:i+2]=='++' and not dfs(s[:i]+'--'+s[i+2:]): return True return False return dfs(currentState) 60 ms ","date":"2015-10-21","objectID":"/leetcode/0294/:3:0","tags":null,"title":"0294：翻转游戏 II（★★★）","uri":"/leetcode/0294/"},{"categories":null,"content":"*附加 上面 dp 的时间复杂度其实很高，是 $O(N*2^{N/2})$，能通过是因为数据太弱。 更优的是利用 Sprague-Grundy 定理， 时间复杂度 $O(N^2)$。 def canWin(self, currentState: str) -\u003e bool: def mex(vis): x = 0 while x in vis: x += 1 return x A = [len(sub) for sub in currentState.split('-') if sub] n = max(A, default=0) sg = [0] * (n+1) for i in range(","date":"2015-10-21","objectID":"/leetcode/0294/:4:0","tags":null,"title":"0294：翻转游戏 II（★★★）","uri":"/leetcode/0294/"},{"categories":null,"content":" 力扣第 293 题 ","date":"2015-10-20","objectID":"/leetcode/0293/:0:0","tags":null,"title":"0293：翻转游戏","uri":"/leetcode/0293/"},{"categories":null,"content":"题目 你和朋友玩一个叫做「翻转游戏」的游戏。游戏规则如下： 给你一个字符串 currentState ，其中只含 '+' 和 '-' 。你和朋友轮流将 连续 的两个 \"++\" 反转成 \"--\" 。当一方无法进行有效的翻转时便意味着游戏结束，则另一方获胜。 计算并返回 一次有效操作 后，字符串 currentState 所有的可能状态，返回结果可以按 任意顺序 排列。如果不存在可能的有效操作，请返回一个空列表 [] 。 示例 1： 输入：currentState = \"++++\" 输出：[\"--++\",\"+--+\",\"++--\"] 示例 2： 输入：currentState = \"+\" 输出：[","date":"2015-10-20","objectID":"/leetcode/0293/:1:0","tags":null,"title":"0293：翻转游戏","uri":"/leetcode/0293/"},{"categories":null,"content":"分析 模拟即可。 ","date":"2015-10-20","objectID":"/leetcode/0293/:2:0","tags":null,"title":"0293：翻转游戏","uri":"/leetcode/0293/"},{"categories":null,"content":"解答 def generatePossibleNextMoves(self, currentState: str) -\u003e List[str]: n, s = len(currentState), currentState return [s[:i]+'--'+s[i+2:] for i in range(n) if s[i:i+2] == '++'] 28 ms ","date":"2015-10-20","objectID":"/leetcode/0293/:3:0","tags":null,"title":"0293：翻转游戏","uri":"/leetcode/0293/"},{"categories":null,"content":" 力扣第 292 题 ","date":"2015-10-19","objectID":"/leetcode/0292/:0:0","tags":null,"title":"0292：Nim 游戏","uri":"/leetcode/0292/"},{"categories":null,"content":"题目 你和你的朋友，两个人一起玩 Nim 游戏： 桌子上有一堆石头。 你们轮流进行自己的回合， 你作为先手 。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。 示例 1： 输入：n = 4 输出：false 解释：以下是可能的结果: 1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。 2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。 3.你移走3颗石子。你的朋友移走了","date":"2015-10-19","objectID":"/leetcode/0292/:1:0","tags":null,"title":"0292：Nim 游戏","uri":"/leetcode/0292/"},{"categories":null,"content":"分析 经典的博弈： 如果 n 是 4 的倍数，先手必输 因为后手可以保证每一轮共拿走 4 块，最后一轮刚好拿完 如果 n 不是 4 的倍数，先手比赢 因为先手拿走 n%4 块使得 n 变为 4 的倍数，就变为上面的情况了 ","date":"2015-10-19","objectID":"/leetcode/0292/:2:0","tags":null,"title":"0292：Nim 游戏","uri":"/leetcode/0292/"},{"categories":null,"content":"解答 def canWinNim(self, n: int) -\u003e bool: return n % 4 != 0 32 ms ","date":"2015-10-19","objectID":"/leetcode/0292/:3:0","tags":null,"title":"0292：Nim 游戏","uri":"/leetcode/0292/"},{"categories":null,"content":" 力扣第 291 题 ","date":"2015-10-18","objectID":"/leetcode/0291/:0:0","tags":null,"title":"0291：单词规律 II（★）","uri":"/leetcode/0291/"},{"categories":null,"content":"题目 给你一种规律 pattern 和一个字符串 s，请你判断 s 是否和 pattern 的规律相匹配。 如果存在单个字符到字符串的 双射映射 ，那么字符串 s 匹配 pattern ，即：如果pattern 中的每个字符都被它映射到的字符串替换，那么最终的字符串则为 s 。双射 意味着映射双方一一对应，不会存在两个字符映射到同一个字符串，也不会存在一个字符分别映射到两个不同的字符串。 示例 1： 输入：pattern = \"abab\", s = \"redblueredblue\" 输出：true 解释：一种可能的映射如下： 'a' -\u003e \"red\" 'b' -\u003e \"blue\" 示例 2： 输","date":"2015-10-18","objectID":"/leetcode/0291/:1:0","tags":null,"title":"0291：单词规律 II（★）","uri":"/leetcode/0291/"},{"categories":null,"content":"分析 典型的回溯，尝试用 s 的不同前缀来匹配，如果映射冲突就返回上一步。 注意回溯时维护两个方向的映射即可。 ","date":"2015-10-18","objectID":"/leetcode/0291/:2:0","tags":null,"title":"0291：单词规律 II（★）","uri":"/leetcode/0291/"},{"categories":null,"content":"解答 def wordPatternMatch(self, pattern: str, s: str) -\u003e bool: def dfs(p, s): if not p and not s: return True if not p or not s: return False x = p[0] if x in d1: y = d1[x] return s[:len(y)]==y and dfs(p[1:], s[len(y):]) for i in range(len(s)): y = s[:i+1] if y not in d2: d1[x], d2[y] = y, x if dfs(p[","date":"2015-10-18","objectID":"/leetcode/0291/:3:0","tags":null,"title":"0291：单词规律 II（★）","uri":"/leetcode/0291/"},{"categories":null,"content":" 力扣第 290 题 ","date":"2015-10-17","objectID":"/leetcode/0290/:0:0","tags":null,"title":"0290：单词规律","uri":"/leetcode/0290/"},{"categories":null,"content":"题目 给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = \"abba\", s = \"dog cat cat dog\" 输出: true 示例 2: 输入:pattern = \"abba\", s = \"dog cat cat fish\" 输出: false 示例 3: 输入: pattern = \"aaaa\", s = \"dog cat cat dog\" 输出: false 提示: 1 \u003c= pattern","date":"2015-10-17","objectID":"/leetcode/0290/:1:0","tags":null,"title":"0290：单词规律","uri":"/leetcode/0290/"},{"categories":null,"content":"分析 类似 0205，注意先判断 s 的单词数和 pattern 长度是否相同即可。 ","date":"2015-10-17","objectID":"/leetcode/0290/:2:0","tags":null,"title":"0290：单词规律","uri":"/leetcode/0290/"},{"categories":null,"content":"解答 def wordPattern(self, pattern: str, s: str) -\u003e bool: A, B = pattern, s.split() return len(A)==len(B) and len(set(A))==len(set(B))==len(set(zip(A, B))) 32 ms ","date":"2015-10-17","objectID":"/leetcode/0290/:3:0","tags":null,"title":"0290：单词规律","uri":"/leetcode/0290/"},{"categories":null,"content":" 力扣第 289 题 ","date":"2015-10-16","objectID":"/leetcode/0289/:0:0","tags":null,"title":"0289：生命游戏（★）","uri":"/leetcode/0289/"},{"categories":null,"content":"题目 根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置","date":"2015-10-16","objectID":"/leetcode/0289/:1:0","tags":null,"title":"0289：生命游戏（★）","uri":"/leetcode/0289/"},{"categories":null,"content":"分析 ","date":"2015-10-16","objectID":"/leetcode/0289/:2:0","tags":null,"title":"0289：生命游戏（★）","uri":"/leetcode/0289/"},{"categories":null,"content":"#1 先写出额外数组的方法。根据规则，下一个状态是存活只有两种情况： 周围加自身共有三个活细胞 周围加自身共有四个活细胞，且当前状态是存活 def gameOfLife(self, board: List[List[int]]) -\u003e None: m, n = len(board), len(board[0]) tmp = [[0] * n for _ in range(m)] for i, j in product(range(m), range(n)): cnt = 0 for x, y in product([i - 1, i, i + 1], [j - 1, j, j + 1]): i","date":"2015-10-16","objectID":"/leetcode/0289/:2:1","tags":null,"title":"0289：生命游戏（★）","uri":"/leetcode/0289/"},{"categories":null,"content":"#2 要求原地算法，考虑用 board 自身来保存信息。 最简单的就是增加一位 bit 来表示下一轮状态，于是遍历中可能遇到的标志有： 0，当前状态为死，下一轮状态未知 1，当前状态为活，下一轮状态未知 10，当前状态为死，下一轮状态为活 11，当前状态为活，下一轮状态为活 那么遍历中 值%2 即是当前状态，遍历完后 值//2 即是下一轮状态。 ","date":"2015-10-16","objectID":"/leetcode/0289/:2:2","tags":null,"title":"0289：生命游戏（★）","uri":"/leetcode/0289/"},{"categories":null,"content":"解答 def gameOfLife(self, board: List[List[int]]) -\u003e None: m, n = len(board), len(board[0]) for i, j in product(range(m), range(n)): cnt = 0 for x, y in product([i - 1, i, i + 1], [j - 1, j, j + 1]): if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n and board[x][y] % 2: cnt += 1 board[i][j] += 2 if cnt == 3 or (cnt == 4 a","date":"2015-10-16","objectID":"/leetcode/0289/:3:0","tags":null,"title":"0289：生命游戏（★）","uri":"/leetcode/0289/"},{"categories":null,"content":" 力扣第 288 题 ","date":"2015-10-15","objectID":"/leetcode/0288/:0:0","tags":null,"title":"0288：单词的唯一缩写（★）","uri":"/leetcode/0288/"},{"categories":null,"content":"题目 单词的 缩写 需要遵循 \u003c起始字母\u003e\u003c中间字母数\u003e\u003c结尾字母\u003e 这样的格式。如果单词只有两个字符，那么它就是它自身的 缩写 。 以下是一些单词缩写的范例： dog --\u003e d1g 因为第一个字母 'd' 和最后一个字母 'g' 之间有 1 个字母 internationalization --\u003e i18n 因为第一个字母 'i' 和最后一个字母 'n' 之间有 18 个字母 it --\u003e it 单词只有两个字符，它就是它自身的 缩写 实现 ValidWordAbbr 类： ValidWordAbbr(String[] dictionary) 使用单词字典 dictionary 初始化对象","date":"2015-10-15","objectID":"/leetcode/0288/:1:0","tags":null,"title":"0288：单词的唯一缩写（★）","uri":"/leetcode/0288/"},{"categories":null,"content":"分析 典型的哈希表，按缩写分组。 如果 word 的缩写不在哈希表中，或者该组只有 word，即为 true。 ","date":"2015-10-15","objectID":"/leetcode/0288/:2:0","tags":null,"title":"0288：单词的唯一缩写（★）","uri":"/leetcode/0288/"},{"categories":null,"content":"解答 class ValidWordAbbr: def __init__(self, dictionary: List[str]): self.d = defaultdict(set) for w in dictionary: key = w[0]+str(len(w)-2 or '')+w[-1] self.d[key].add(w) def isUnique(self, word: str) -\u003e bool: key = word[0]+str(len(word)-2 or '')+word[-1] return key not in self.d or self.d[key] == {w","date":"2015-10-15","objectID":"/leetcode/0288/:3:0","tags":null,"title":"0288：单词的唯一缩写（★）","uri":"/leetcode/0288/"},{"categories":null,"content":" 力扣第 287 题 ","date":"2015-10-14","objectID":"/leetcode/0287/:0:0","tags":null,"title":"0287：寻找重复数（★）","uri":"/leetcode/0287/"},{"categories":null,"content":"题目 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。 示例 1： 输入：nums = [1,3,4,2,2] 输出：2 示例 2： 输入：nums = [3,1,3,4,2] 输出：3 提示： 1 \u003c= n \u003c= 105 nums.length == n + 1 1 \u003c= nums[i] \u003c= n nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现","date":"2015-10-14","objectID":"/leetcode/0287/:1:0","tags":null,"title":"0287：寻找重复数（★）","uri":"/leetcode/0287/"},{"categories":null,"content":"分析 ","date":"2015-10-14","objectID":"/leetcode/0287/:2:0","tags":null,"title":"0287：寻找重复数（★）","uri":"/leetcode/0287/"},{"categories":null,"content":"#1 以重复的数 x 为界，任意 y\u003cx 必然满足 [1,y] 范围内的个数 \u003c= y，任意 y\u003e=x 则反之。 因此二分查找第一个满足 [1,y] 范围内的个数 \u003e y 的 y 即可。 def findDuplicate(self, nums: List[int]) -\u003e int: self.__class__.__getitem__ = lambda self, x: sum(num\u003c=x for num in nums)\u003ex return bisect_left(self, True, 1, len(nums)-1) 时间复杂度 O(N*logN)，384 ms ","date":"2015-10-14","objectID":"/leetcode/0287/:2:1","tags":null,"title":"0287：寻找重复数（★）","uri":"/leetcode/0287/"},{"categories":null,"content":"#2 要求 O(N)，有个非常巧妙的方法： 将 nums 看作是链表，nums[i] 表示节点 i 指向节点 nums[i] 那么从节点 0 出发的链表必然存在一个环，入环的节点即是所求 问题便等价于 0142 了 ","date":"2015-10-14","objectID":"/leetcode/0287/:2:2","tags":null,"title":"0287：寻找重复数（★）","uri":"/leetcode/0287/"},{"categories":null,"content":"解答 def findDuplicate(self, nums: List[int]) -\u003e int: slow = fast = 0 while True: slow, fast = nums[slow], nums[nums[fast]] if slow == fast: break slow = 0 while slow != fast: slow, fast = nums[slow], nums[fast] return slow 时间复杂度 O(N)，108 ms ","date":"2015-10-14","objectID":"/leetcode/0287/:3:0","tags":null,"title":"0287：寻找重复数（★）","uri":"/leetcode/0287/"},{"categories":null,"content":"*附加 如果可以修改数组，那么还有种时间 O(N)，空间 O(1) 的做法： 遍历到值 x 时，将位置 abs(x) 的值标记为负数 若位置 abs(x) 的值已经被标记为负数，abs(x) 即为所求 def findDuplicate(self, nums: List[int]) -\u003e int: for x in nums: if nums[abs(x)]\u003c0: return abs(x) nums[abs(x)] *= -1 120 ms ","date":"2015-10-14","objectID":"/leetcode/0287/:4:0","tags":null,"title":"0287：寻找重复数（★）","uri":"/leetcode/0287/"},{"categories":null,"content":" 力扣第 286 题 ","date":"2015-10-13","objectID":"/leetcode/0286/:0:0","tags":null,"title":"0286：墙与门（★）","uri":"/leetcode/0286/"},{"categories":null,"content":"题目 你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值： -1 表示墙或是障碍物 0 表示一扇门 INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。 你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。 示例 1： 输入：rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647","date":"2015-10-13","objectID":"/leetcode/0286/:1:0","tags":null,"title":"0286：墙与门（★）","uri":"/leetcode/0286/"},{"categories":null,"content":"分析 典型的多源 bfs，从门开始遍历即可。 ","date":"2015-10-13","objectID":"/leetcode/0286/:2:0","tags":null,"title":"0286：墙与门（★）","uri":"/leetcode/0286/"},{"categories":null,"content":"解答 def wallsAndGates(self, rooms: List[List[int]]) -\u003e None: m, n = len(rooms), len(rooms[0]) Q = deque((i, j) for i in range(m) for j in range(n) if rooms[i][j]==0) while Q: i, j = Q.popleft() for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0\u003c=x\u003cm and 0\u003c=y\u003cn and rooms[x][y]==2147483647: roo","date":"2015-10-13","objectID":"/leetcode/0286/:3:0","tags":null,"title":"0286：墙与门（★）","uri":"/leetcode/0286/"},{"categories":null,"content":" 力扣第 285 题 ","date":"2015-10-12","objectID":"/leetcode/0285/:0:0","tags":null,"title":"0285：二叉搜索树中的中序后继（★）","uri":"/leetcode/0285/"},{"categories":null,"content":"题目 给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。 节点 p 的后继是值比 p.val 大的节点中键值最小的节点。 示例 1： 输入：root = [2,1,3], p = 1 输出：2 解释：这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。 示例 2： 输入：root = [5,3,6,2,4,null,null,1], p = 6 输出：null 解释：因为给出的节点没有中序后继，所以答案就返回 null 了。 提示： 树中节点的数目在范围 [1, 104] 内。 -105 \u003c= Node.","date":"2015-10-12","objectID":"/leetcode/0285/:1:0","tags":null,"title":"0285：二叉搜索树中的中序后继（★）","uri":"/leetcode/0285/"},{"categories":null,"content":"分析 遍历并比较即可： 先比较 root 和 p 如果 root 比 p 大，后继要么是 root，要么在左子树中，继续遍历 root 的左子树 同理，如果 root 比 p 大，继续遍历 root 的右子树 ","date":"2015-10-12","objectID":"/leetcode/0285/:2:0","tags":null,"title":"0285：二叉搜索树中的中序后继（★）","uri":"/leetcode/0285/"},{"categories":null,"content":"解答 def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -\u003e 'TreeNode': res, q = None, root while q: if q.val\u003ep.val: res = q if not res or q.val\u003cres.val else res q = q.left else: q = q.right return res 68 ms ","date":"2015-10-12","objectID":"/leetcode/0285/:3:0","tags":null,"title":"0285：二叉搜索树中的中序后继（★）","uri":"/leetcode/0285/"},{"categories":null,"content":" 力扣第 284 题 ","date":"2015-10-11","objectID":"/leetcode/0284/:0:0","tags":null,"title":"0284：顶端迭代器（★）","uri":"/leetcode/0284/"},{"categories":null,"content":"题目 请你在设计一个迭代器，在集成现有迭代器拥有的 hasNext 和 next 操作的基础上，还额外支持 peek 操作。 实现 PeekingIterator 类： PeekingIterator(Iterator\u003cint\u003e nums) 使用指定整数迭代器 nums 初始化迭代器。 int next() 返回数组中的下一个元素，并将指针移动到下个元素处。 bool hasNext() 如果数组中存在下一个元素，返回 true ；否则，返回 false 。 int peek() 返回数组中的下一个元素，但 不 移动指针。 注意：每种语言可能有不同的构造函数和迭代器 Iterator，但均支持","date":"2015-10-11","objectID":"/leetcode/0284/:1:0","tags":null,"title":"0284：顶端迭代器（★）","uri":"/leetcode/0284/"},{"categories":null,"content":"分析 peek 必须获得下一个元素，但不能移动指针。 因此考虑用缓存保存已看过但还没移到的元素，每次 next/hasNext/peek 时先看缓存，没有再调用迭代器。 ","date":"2015-10-11","objectID":"/leetcode/0284/:2:0","tags":null,"title":"0284：顶端迭代器（★）","uri":"/leetcode/0284/"},{"categories":null,"content":"解答 class PeekingIterator: def __init__(self, iterator): self.it = iterator self.cache = None def peek(self): self.cache = self.cache or self.it.next() return self.cache def next(self): res = self.cache or self.it.next() self.cache = None return res def hasNext(self): return bool(self.cache) or self.","date":"2015-10-11","objectID":"/leetcode/0284/:3:0","tags":null,"title":"0284：顶端迭代器（★）","uri":"/leetcode/0284/"},{"categories":null,"content":" 力扣第 283 题 ","date":"2015-10-10","objectID":"/leetcode/0283/:0:0","tags":null,"title":"0283：移动零","uri":"/leetcode/0283/"},{"categories":null,"content":"题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2: 输入: nums = [0] 输出: [0] 提示: 1 \u003c= nums.length \u003c= 104 -231 \u003c= nums[i] \u003c= 231 - 1 进阶：你能尽量减少完成的操作次数吗？ ","date":"2015-10-10","objectID":"/leetcode/0283/:1:0","tags":null,"title":"0283：移动零","uri":"/leetcode/0283/"},{"categories":null,"content":"分析 类似 0027 ，等价于移除前面的 0 ，再在后面补 0 即可。 ","date":"2015-10-10","objectID":"/leetcode/0283/:2:0","tags":null,"title":"0283：移动零","uri":"/leetcode/0283/"},{"categories":null,"content":"解答 def moveZeroes(self, nums: List[int]) -\u003e None: i = 0 for num in nums: if num != 0: nums[i] = num i += 1 nums[i:] = [0] * (len(nums)-i) 40 ms ","date":"2015-10-10","objectID":"/leetcode/0283/:3:0","tags":null,"title":"0283：移动零","uri":"/leetcode/0283/"},{"categories":null,"content":" 力扣第 282 题 ","date":"2015-10-09","objectID":"/leetcode/0282/:0:0","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"题目 给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ，在 num 的数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回 所有 能够得到 target 的表达式。 注意，返回表达式中的操作数 不应该 包含前导零。 示例 1: 输入: num = \"123\", target = 6 输出: [\"1+2+3\", \"1*2*3\"] 解释: “1*2*3” 和 “1+2+3” 的值都是6。 示例 2: 输入: num = \"232\", target = 8 输出: [\"2*3+2\", \"2+3*2\"] 解释: “2*3+2” 和 “2+3*2” 的值都是8。 示","date":"2015-10-09","objectID":"/leetcode/0282/:1:0","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"分析 ","date":"2015-10-09","objectID":"/leetcode/0282/:2:0","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"#1 最简单的就是遍历每一种情况，判断是否等于 target。 可以用 dfs，每一步添加 +、-、* 或空。注意不能有前置 0。 def addOperators(self, num: str, target: int) -\u003e List[str]: def dfs(i, exp): if i == n: if eval(exp) == target: res.append(exp) return ops = ['+','-','*',''] if not exp: ops = [''] elif exp[-2:] in ['0','+0','-0','*0']: ops = '+-*' fo","date":"2015-10-09","objectID":"/leetcode/0282/:2:1","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"2 考虑在遍历时维护当前表达式的值，节省时间。 为了递推 exp+op+num[i:j] 的值，需要知道 exp 计算后的值 val exp 计算了乘法之后的最后一个数（包括正负号） prev 因此 dfs 时添加两个传递的变量。 ","date":"2015-10-09","objectID":"/leetcode/0282/:2:2","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"解答 def addOperators(self, num: str, target: int) -\u003e List[str]: def dfs(i, exp, prev, val): if i == n: if val == target: res.append(exp) return for j in range(i+1, i+2 if num[i] == '0' else n+1): s = num[i:j] x = int(s) if not exp: dfs(j, s, x, x) else: dfs(j, exp+'+'+s, x, val+x) dfs(j, exp+'-'+s, -","date":"2015-10-09","objectID":"/leetcode/0282/:3:0","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"动画电影《小魔女学园：魔法游行》是“动画未来2013”的上映作品《小魔女学园》的续作，于2015年10月9日起在日本进行限定两周的上映。","date":"2015-10-09","objectID":"/anime/little_witch_academia/","tags":null,"title":"小魔女学园 魔法游行","uri":"/anime/little_witch_academia/"},{"categories":null,"content":"简介 动画电影《小魔女学园：魔法游行》是“动画未来2013”的上映作品《小魔女学园》的续作，于2015年10月9日起在日本进行限定两周的上映。 制作人员： 导演：吉成曜 脚本：岛田满 音乐：大岛满 美术监督：金子雄司 色彩设计：垣田由纪子 作画监督：米山舞、锦织敦史 ","date":"2015-10-09","objectID":"/anime/little_witch_academia/:1:0","tags":null,"title":"小魔女学园 魔法游行","uri":"/anime/little_witch_academia/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 篝敦子 亚可·卡嘉莉、Akko Kagari、アツコ・カガリ、アッコ 女 潘めぐみ 2 洛蒂·杨森 Lotte Yanson、ロッテ・ヤンソン 女 折笠富美子 3 苏西·曼芭芭拉 Sucy Mambavaran、スーシィ・マンババラン、Sushi Manbabaran、苏西 女 村瀬迪与 4 戴安娜·卡文迪什 Diana Cavendish、ダイアナ・キャベンディッシュ、Daiana Kyabendisshu 女 日笠陽子 5 厄休拉老师 亚丝菈老师、Professor Ursula、アーシュラ先生、Āshura-sensei 女 日髙のり子 6 阿曼达·奥","date":"2015-10-09","objectID":"/anime/little_witch_academia/:2:0","tags":null,"title":"小魔女学园 魔法游行","uri":"/anime/little_witch_academia/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 小魔女学园 魔法游行 2015-10-09 00:53:00 bilibili ","date":"2015-10-09","objectID":"/anime/little_witch_academia/:3:0","tags":null,"title":"小魔女学园 魔法游行","uri":"/anime/little_witch_academia/"},{"categories":null,"content":"MAD ","date":"2015-10-09","objectID":"/anime/little_witch_academia/:4:0","tags":null,"title":"小魔女学园 魔法游行","uri":"/anime/little_witch_academia/"},{"categories":null,"content":" 力扣第 281 题 ","date":"2015-10-08","objectID":"/leetcode/0281/:0:0","tags":null,"title":"0281：锯齿迭代器（★）","uri":"/leetcode/0281/"},{"categories":null,"content":"题目 给出两个一维的向量，请你实现一个迭代器，交替返回它们中间的元素。 示例: 输入: v1 = [1,2] v2 = [3,4,5,6] 输出: [1,3,2,4,5,6] 解析: 通过连续调用 next 函数直到 hasNext 函数返回 false， next 函数返回值的次序应依次为: [1,3,2,4,5,6]。 拓展：假如给你 k 个一维向量呢？你的代码在这种情况下的扩展性又会如何呢? 拓展声明： “锯齿” 顺序对于 k \u003e 2 的情况定义可能会有些歧义。所以，假如你觉得 “锯齿” 这个表述不妥，也可以认为这是一种 “循环”。例如： 输入: [1,2,3] [4,5,6,7] [8","date":"2015-10-08","objectID":"/leetcode/0281/:1:0","tags":null,"title":"0281：锯齿迭代器（★）","uri":"/leetcode/0281/"},{"categories":null,"content":"分析 每次取一对 v1、v2 的元素放入缓存即可。 ","date":"2015-10-08","objectID":"/leetcode/0281/:2:0","tags":null,"title":"0281：锯齿迭代器（★）","uri":"/leetcode/0281/"},{"categories":null,"content":"解答 class ZigzagIterator: def __init__(self, v1: List[int], v2: List[int]): self.v1 = v1 self.v2 = v2 self.i = 0 self.cache = [] def next(self) -\u003e int: return self.cache.pop(0) def hasNext(self) -\u003e bool: if not self.cache: if self.i\u003clen(self.v1): self.cache.append(self.v1[self.i]) if self.i\u003clen(self.","date":"2015-10-08","objectID":"/leetcode/0281/:3:0","tags":null,"title":"0281：锯齿迭代器（★）","uri":"/leetcode/0281/"},{"categories":null,"content":"　　故事发生在一座孤岛的研究所中。从幼年时期就开始过着完全隔离生活的天才程序员真贺田四季被关押在那里。为了见上这位天才一面，那古野大学准教授犀川创平和学生西之园萌绘来到研究所，在那里，师生两人目击了一起离奇的杀人案。原本不会有人员出入的四季的房间里，却出现了身穿婚纱、双手双脚被切断的支离破碎的尸体。师生被卷入了不可思议的密室杀人事件……","date":"2015-10-08","objectID":"/anime/the_perfect_insider/","tags":null,"title":"全部成为F THE PERFECT INSIDER","uri":"/anime/the_perfect_insider/"},{"categories":null,"content":"简介 故事发生在一座孤岛的研究所中。从幼年时期就开始过着完全隔离生活的天才程序员真贺田四季被关押在那里。为了见上这位天才一面，那古野大学准教授犀川创平和学生西之园萌绘来到研究所，在那里，师生两人目击了一起离奇的杀人案。原本不会有人员出入的四季的房间里，却出现了身穿婚纱、双手双脚被切断的支离破碎的尸体。师生被卷入了不可思议的密室杀人事件…… 制作人员： 原作：森博嗣 导演：神户守 脚本：渡边雄介、大野敏哉、雨宮麻美 分镜：工藤进、高桥敦史、今泉贤一 ","date":"2015-10-08","objectID":"/anime/the_perfect_insider/:1:0","tags":null,"title":"全部成为F THE PERFECT INSIDER","uri":"/anime/the_perfect_insider/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 犀川创平 犀川 創平、さいかわ そうへい、SAIKAWA Sohei 男 加瀬康之 2 西之园萌绘 西之園 萌絵、にしのその もえ、NISHINOSONO Moe 女 種﨑敦美 3 真贺田四季 真賀田 四季、まがた しき、MAGATA Shiki 女 木戸衣吹 4 进藤清二 新藤 清二、SHINDO Seiji 男 咲野俊介 5 进藤裕见子 新藤 裕見子、SHINDO Yumiko 女 小林さやか 6 山根幸宏 山根 幸宏、YAMANE Yukihiro 男 鈴木達央 7 弓永富彦 弓永 富彦、YUMINAGA Tomihiko 男 佐々木敏 8 水谷主税 ","date":"2015-10-08","objectID":"/anime/the_perfect_insider/:2:0","tags":null,"title":"全部成为F THE PERFECT INSIDER","uri":"/anime/the_perfect_insider/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 全部成为F THE PERFECT INSIDER 2015-10-08 11 bilibili ","date":"2015-10-08","objectID":"/anime/the_perfect_insider/:3:0","tags":null,"title":"全部成为F THE PERFECT INSIDER","uri":"/anime/the_perfect_insider/"},{"categories":null,"content":" 力扣第 280 题 ","date":"2015-10-07","objectID":"/leetcode/0280/:0:0","tags":null,"title":"0280：摆动排序（★）","uri":"/leetcode/0280/"},{"categories":null,"content":"题目 给你一个的整数数组 nums, 将该数组重新排序后使 nums[0] \u003c= nums[1] \u003e= nums[2] \u003c= nums[3]... 输入数组总是有一个有效的答案。 示例 1: 输入：nums = [3,5,2,1,6,4] 输出：[3,5,1,6,2,4] 解释：[1,6,2,5,3,4]也是有效的答案 示例 2: 输入：nums = [6,6,5,6,3,8] 输出：[6,6,5,6,3,8] 提示： 1 \u003c= nums.length \u003c= 5 * 104 0 \u003c= nums[i] \u003c= 104 输入的 nums 保证至少有一个答案。 进阶：你能在 O(n) 时间复杂度下解决","date":"2015-10-07","objectID":"/leetcode/0280/:1:0","tags":null,"title":"0280：摆动排序（★）","uri":"/leetcode/0280/"},{"categories":null,"content":"分析 容易想到将较小的一半和较大的一半交叉放即可。 ","date":"2015-10-07","objectID":"/leetcode/0280/:2:0","tags":null,"title":"0280：摆动排序（★）","uri":"/leetcode/0280/"},{"categories":null,"content":"解答 def wiggleSort(self, nums: List[int]) -\u003e None: n = len(nums) nums.sort() nums[::2], nums[1::2] = nums[:(n+1)//2], nums[(n+1)//2:] 36 ms ","date":"2015-10-07","objectID":"/leetcode/0280/:3:0","tags":null,"title":"0280：摆动排序（★）","uri":"/leetcode/0280/"},{"categories":null,"content":" 力扣第 279 题 ","date":"2015-10-06","objectID":"/leetcode/0279/:0:0","tags":null,"title":"0279：完全平方数（★）","uri":"/leetcode/0279/"},{"categories":null,"content":"题目 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 示例 2： 输入：n = 13 输出：2 解释：13 = 4 + 9 提示： 1 \u003c= n \u003c= 104 ","date":"2015-10-06","objectID":"/leetcode/0279/:1:0","tags":null,"title":"0279：完全平方数（★）","uri":"/leetcode/0279/"},{"categories":null,"content":"分析 典型的线性 dp，按分割递归即可。 ","date":"2015-10-06","objectID":"/leetcode/0279/:2:0","tags":null,"title":"0279：完全平方数（★）","uri":"/leetcode/0279/"},{"categories":null,"content":"解答 def numSquares(self, n: int) -\u003e int: dp = [0] * (n+1) for i in range(1, n+1): dp[i] = 1 + min(dp[i - j * j] for j in range(1, int(sqrt(i)) + 1)) return dp[-1] 时间复杂度 $O(N*\\sqrt N)$，1648 ms ","date":"2015-10-06","objectID":"/leetcode/0279/:3:0","tags":null,"title":"0279：完全平方数（★）","uri":"/leetcode/0279/"},{"categories":null,"content":"*附加 根据数学上的 四平方和定理，每个正整数均可表示为4个整数的平方和。 因此只需逐层遍历 i 个正整数平方的和，找到 n 即可。 def numSquares(self, n: int) -\u003e int: queue, vis = deque([(0, 0)]), {0} while True: u, step = queue.popleft() for j in range(1, int(sqrt(n-u))+1): v = u + j*j if v not in vis: if v == n: return step+1 vis.add(v) queue.append((v, step+","date":"2015-10-06","objectID":"/leetcode/0279/:4:0","tags":null,"title":"0279：完全平方数（★）","uri":"/leetcode/0279/"},{"categories":null,"content":" 力扣第 278 题 ","date":"2015-10-05","objectID":"/leetcode/0278/:0:0","tags":null,"title":"0278：第一个错误的版本","uri":"/leetcode/0278/"},{"categories":null,"content":"题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 1： 输入：n = 5, bad = 4 输出：4 解释： 调用 isBadVersion(3) -\u003e fals","date":"2015-10-05","objectID":"/leetcode/0278/:1:0","tags":null,"title":"0278：第一个错误的版本","uri":"/leetcode/0278/"},{"categories":null,"content":"分析 以出错版本 bad 为界，前面的都是正确的，后面的都是错的。所以可以二分查找。 ","date":"2015-10-05","objectID":"/leetcode/0278/:2:0","tags":null,"title":"0278：第一个错误的版本","uri":"/leetcode/0278/"},{"categories":null,"content":"解答 def firstBadVersion(self, n): self.__class__.__getitem__ = lambda self, i: isBadVersion(i) return bisect_left(self, True, 1, n) 32 ms ","date":"2015-10-05","objectID":"/leetcode/0278/:3:0","tags":null,"title":"0278：第一个错误的版本","uri":"/leetcode/0278/"},{"categories":null,"content":" 力扣第 277 题 ","date":"2015-10-04","objectID":"/leetcode/0277/:0:0","tags":null,"title":"0277：搜寻名人（★）","uri":"/leetcode/0277/"},{"categories":null,"content":"题目 假设你是一个专业的狗仔，参加了一个 n 人派对，其中每个人被从 0 到 n - 1 标号。在这个派对人群当中可能存在一位 “名人”。所谓 “名人” 的定义是：其他所有 n - 1 个人都认识他/她，而他/她并不认识其他任何人。 现在你想要确认这个 “名人” 是谁，或者确定这里没有 “名人”。而你唯一能做的就是问诸如 “A 你好呀，请问你认不认识 B呀？” 的问题，以确定 A 是否认识 B。你需要在（渐近意义上）尽可能少的问题内来确定这位 “名人” 是谁（或者确定这里没有 “名人”）。 在本题中，你可以使用辅助函数 bool knows(a, b) 获取到 A 是否认识 B。请你来实现一个","date":"2015-10-04","objectID":"/leetcode/0277/:1:0","tags":null,"title":"0277：搜寻名人（★）","uri":"/leetcode/0277/"},{"categories":null,"content":"分析 可以用猜想加验证的方式： 先猜 0 是名人，考察 0 和 1 的关系 假如 0 认识 1，0 不可能是名人了，换为猜 1 是名人 假如 0 不认识 1，1 不可能是名人了 从 2 开始继续考察 考察完一遍，即可排除 n-1 个人 验证剩下的那个人是否是名人即可 ","date":"2015-10-04","objectID":"/leetcode/0277/:2:0","tags":null,"title":"0277：搜寻名人（★）","uri":"/leetcode/0277/"},{"categories":null,"content":"解答 def findCelebrity(self, n: int) -\u003e int: x = 0 for i in range(1, n): if knows(x, i): x = i for i in range(x): if not knows(i, x) or knows(x, i): return -1 for i in range(x+1, n): if not knows(i, x): return -1 return x 1264 ms ","date":"2015-10-04","objectID":"/leetcode/0277/:3:0","tags":null,"title":"0277：搜寻名人（★）","uri":"/leetcode/0277/"},{"categories":null,"content":"　　因为兴趣而开始当英雄的男人「埼玉」，在经过三年特训之後，得到了无敌的力量。\n　　然而，他实在是强过了头，所以无论多厉害的对手，都被他一拳解决。「绝对强势的力量，实在是很无聊。」在这种普通热血的最强英雄面前，今天也出现新的敌踪。今天可以让他拿出认真的态度吗！？","date":"2015-10-04","objectID":"/anime/one_punch_man/","tags":null,"title":"一拳超人","uri":"/anime/one_punch_man/"},{"categories":null,"content":"简介 因为兴趣而开始当英雄的男人「埼玉」，在经过三年特训之後，得到了无敌的力量。 然而，他实在是强过了头，所以无论多厉害的对手，都被他一拳解决。「绝对强势的力量，实在是很无聊。」在这种普通热血的最强英雄面前，今天也出现新的敌踪。今天可以让他拿出认真的态度吗！？ 制作人员： 原作：村田雄介、ONE 导演：夏目真悟 脚本：铃木智寻 分镜：久木晃嗣、牛岛新一郎、柴田胜纪、芦野芳晴 ","date":"2015-10-04","objectID":"/anime/one_punch_man/:1:0","tags":null,"title":"一拳超人","uri":"/anime/one_punch_man/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 埼玉 サイタマ、Saitama、光头斗篷、秃头披风侠（ハゲマント） 男 古川慎 2 杰诺斯 ジェノス、Genos、魔鬼改造人（鬼サイボーグ） 男 石川界人 3 KING KING、キング、地上最强的男人 男 安元洋貴 4 音速的索尼克 音速索尼克、SPEED-O’-SOUND SONIC、音速のソニック、Sonic、最強の忍者 男 梶裕貴 5 战栗的龙卷 战栗的龙卷风、TERRIBLE TORNADO、戦慄のタツマキ、Tatsumaki 女 悠木碧 6 银色獠牙 邦古、SILVERFANG、バング、Bang 男 山路和弘 7 原子武士 ATOMIC SAMU","date":"2015-10-04","objectID":"/anime/one_punch_man/:2:0","tags":null,"title":"一拳超人","uri":"/anime/one_punch_man/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 一拳超人 2015-10-04 12 樱花 2 一拳超人 第二季 2019-04-02 12 樱花 ","date":"2015-10-04","objectID":"/anime/one_punch_man/:3:0","tags":null,"title":"一拳超人","uri":"/anime/one_punch_man/"},{"categories":null,"content":"MAD ","date":"2015-10-04","objectID":"/anime/one_punch_man/:4:0","tags":null,"title":"一拳超人","uri":"/anime/one_punch_man/"},{"categories":null,"content":" 力扣第 276 题 ","date":"2015-10-03","objectID":"/leetcode/0276/:0:0","tags":null,"title":"0276：栅栏涂色（★）","uri":"/leetcode/0276/"},{"categories":null,"content":"题目 有 k 种颜色的涂料和一个包含 n 个栅栏柱的栅栏，请你按下述规则为栅栏设计涂色方案： 每个栅栏柱可以用其中 一种 颜色进行上色。 相邻的栅栏柱 最多连续两个 颜色相同。 给你两个整数 k 和 n ，返回所有有效的涂色 方案数 。 示例 1： 输入：n = 3, k = 2 输出：6 解释：所有的可能涂色方案如上图所示。注意，全涂红或者全涂绿的方案属于无效方案，因为相邻的栅栏柱 最多连续两个 颜色相同。 示例 2： 输入：n = 1, k = 1 输出：1 示例 3： 输入：n = 7, k = 2 输出：42 提示： 1 \u003c= n \u003c= 50 1 \u003c= k \u003c= 105 题目数据保证：","date":"2015-10-03","objectID":"/leetcode/0276/:1:0","tags":null,"title":"0276：栅栏涂色（★）","uri":"/leetcode/0276/"},{"categories":null,"content":"分析 典型的 dp，令 dp[i][0] 代表前 i 个栅栏最后两个不连续的涂色方案数， dp[i][1] 代表前 i 个栅栏最后两个连续的涂色方案数，即可递归。 因为 dp[i] 只依赖于 dp[i-1]，所以可以优化为两个参数。 ","date":"2015-10-03","objectID":"/leetcode/0276/:2:0","tags":null,"title":"0276：栅栏涂色（★）","uri":"/leetcode/0276/"},{"categories":null,"content":"解答 def numWays(self, n: int, k: int) -\u003e int: a, b = k, 0 for _ in range(n-1): a, b = (k-1)*(a+b), a return a+b 36 ms ","date":"2015-10-03","objectID":"/leetcode/0276/:3:0","tags":null,"title":"0276：栅栏涂色（★）","uri":"/leetcode/0276/"},{"categories":null,"content":"*附加 这是完全的线性递推关系，因此可以用矩阵快速幂优化。 def numWays(self, n: int, k: int) -\u003e int: import numpy as np A = np.mat([[k-1,k-1],[1,0]]) dp = np.mat([[k],[0]]) dp = pow(A, n-1)*dp return int(sum(dp)) 96 ms ","date":"2015-10-03","objectID":"/leetcode/0276/:4:0","tags":null,"title":"0276：栅栏涂色（★）","uri":"/leetcode/0276/"},{"categories":null,"content":" 力扣第 275 题 ","date":"2015-10-02","objectID":"/leetcode/0275/:0:0","tags":null,"title":"0275：H 指数 II（★）","uri":"/leetcode/0275/"},{"categories":null,"content":"题目 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数，citations 已经按照 升序排列 。计算并返回该研究者的 h 指数。 h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。 提示：如果 h 有多种可能的值，h 指数 是其中最大的那个。 请你设计并实现对数时间复杂度的算法解决此问题。 示例 1： 输入：citations = [0,1,3,5,6","date":"2015-10-02","objectID":"/leetcode/0275/:1:0","tags":null,"title":"0275：H 指数 II（★）","uri":"/leetcode/0275/"},{"categories":null,"content":"分析 类似 0274，找第一个满足 n-i\u003c=citations[i] 的 i 即可。 本题已排好序了，由于单调性，可以二分查找。 ","date":"2015-10-02","objectID":"/leetcode/0275/:2:0","tags":null,"title":"0275：H 指数 II（★）","uri":"/leetcode/0275/"},{"categories":null,"content":"解答 def hIndex(self, citations: List[int]) -\u003e int: n = len(citations) self.__class__.__getitem__ = lambda self, i: n-i\u003c=citations[i] return n - bisect_left(self, True, 0, n) 时间复杂度 O(log N)，44 ms ","date":"2015-10-02","objectID":"/leetcode/0275/:3:0","tags":null,"title":"0275：H 指数 II（★）","uri":"/leetcode/0275/"},{"categories":null,"content":"在情报过度发达的现代社会，人们沉溺在铺天盖地的信息海洋中为其所缚，变得不再自由，为了解决这一问题，一位年轻勇敢的科学家站了出来，试图挑战这种压抑状态……","date":"2015-10-02","objectID":"/anime/hacka_doll/","tags":null,"title":"骇客娃娃","uri":"/anime/hacka_doll/"},{"categories":null,"content":"简介 在情报过度发达的现代社会，人们沉溺在铺天盖地的信息海洋中为其所缚，变得不再自由，为了解决这一问题，一位年轻勇敢的科学家站了出来，试图挑战这种压抑状态…… 制作人员： 原作：DeNA 导演：奥居久明 脚本：佐藤裕 分镜：大地丙太郎、坂本一也、中川英树、普津泽画乃新、五味伸介 ","date":"2015-10-02","objectID":"/anime/hacka_doll/:1:0","tags":null,"title":"骇客娃娃","uri":"/anime/hacka_doll/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 骇客娃娃一号 Hacka Doll NO.1、ハッカドール １号 女 高木美佑 2 骇客娃娃二号 Hacka Doll NO.2、ハッカドール ２号 女 奥野香耶 3 骇客娃娃三号 Hacka Doll NO.3、ハッカドール ３号 男 山下七海 4 骇客娃娃零号 Hacka Doll NO.0、ハッカドール ０号 女 柚木涼香 5 骇客娃娃四号 Hacka Doll NO.4、ハッカドール ４号 女 上田麗奈 6 彩芽 Ayame 女 吉岡茉祐 7 七濑佳乃 ななせ よしの、Nanase Yoshino 女性 青山吉能 ","date":"2015-10-02","objectID":"/anime/hacka_doll/:2:0","tags":null,"title":"骇客娃娃","uri":"/anime/hacka_doll/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 骇客娃娃 2015-10-02 13 bilibili ","date":"2015-10-02","objectID":"/anime/hacka_doll/:3:0","tags":null,"title":"骇客娃娃","uri":"/anime/hacka_doll/"},{"categories":null,"content":" 力扣第 274 题 ","date":"2015-10-01","objectID":"/leetcode/0274/:0:0","tags":null,"title":"0274：H 指数（★）","uri":"/leetcode/0274/"},{"categories":null,"content":"题目 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。 根据维基百科上 h 指数的定义：h 代表“高引用次数”，一名科研人员的 h指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。 如果 h 有多种可能的值，h 指数 是其中最大的那个。 示例 1： 输入：citations = [3,0,6,1,5] 输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。","date":"2015-10-01","objectID":"/leetcode/0274/:1:0","tags":null,"title":"0274：H 指数（★）","uri":"/leetcode/0274/"},{"categories":null,"content":"分析 将 citations 排序后，citations[i:] 这 n-i 篇论文的最低引用数是 citations[i]。 因此遍历找到第一个满足 n-i\u003c=citations[i] 的 i 即可。 ","date":"2015-10-01","objectID":"/leetcode/0274/:2:0","tags":null,"title":"0274：H 指数（★）","uri":"/leetcode/0274/"},{"categories":null,"content":"解答 def hIndex(self, citations: List[int]) -\u003e int: n = len(citations) for i, c in enumerate(sorted(citations)): if n-i \u003c= c: return n-i return 0 时间复杂度 O(N*logN)，28 ms ","date":"2015-10-01","objectID":"/leetcode/0274/:3:0","tags":null,"title":"0274：H 指数（★）","uri":"/leetcode/0274/"},{"categories":null,"content":" 力扣第 273 题 ","date":"2015-09-30","objectID":"/leetcode/0273/:0:0","tags":null,"title":"0273：整数转换英文表示（★★）","uri":"/leetcode/0273/"},{"categories":null,"content":"题目 将非负整数 num 转换为其对应的英文表示。 示例 1： 输入：num = 123 输出：\"One Hundred Twenty Three\" 示例 2： 输入：num = 12345 输出：\"Twelve Thousand Three Hundred Forty Five\" 示例 3： 输入：num = 1234567 输出：\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" 提示： 0 \u003c= num \u003c= 231 - 1 ","date":"2015-09-30","objectID":"/leetcode/0273/:1:0","tags":null,"title":"0273：整数转换英文表示（★★）","uri":"/leetcode/0273/"},{"categories":null,"content":"分析 容易看出用递归，但要注意细节处理： 当 num 为 0 时要返回 Zero 其它数（比如100）递归求 0 的表示时应该返回空 为了方便处理空格，dfs 返回元组形式，主函数再拼接 ","date":"2015-09-30","objectID":"/leetcode/0273/:2:0","tags":null,"title":"0273：整数转换英文表示（★★）","uri":"/leetcode/0273/"},{"categories":null,"content":"解答 def numberToWords(self, num: int) -\u003e str: def dfs(num): if num == 0: return () for unit, exp in zip([10**9, 10**6, 10**3, 10**2], ['Billion', 'Million', 'Thousand', 'Hundred']): if num \u003e= unit: return dfs(num//unit)+(exp,)+dfs(num%unit) return (ones[num-1],) if num \u003c 20 else (tens[num//10-2],)+df","date":"2015-09-30","objectID":"/leetcode/0273/:3:0","tags":null,"title":"0273：整数转换英文表示（★★）","uri":"/leetcode/0273/"},{"categories":null,"content":" 力扣第 272 题 ","date":"2015-09-29","objectID":"/leetcode/0272/:0:0","tags":null,"title":"0272：最接近的二叉搜索树值 II（★★）","uri":"/leetcode/0272/"},{"categories":null,"content":"题目 给定二叉搜索树的根 root 、一个目标值 target 和一个整数 k ，返回BST中最接近目标的 k 个值。你可以按 任意顺序 返回答案。 题目 保证 该二叉搜索树中只会存在一种 k 个值集合最接近 target 示例 1： 输入: root = [4,2,5,1,3]，目标值 = 3.714286，且 k = 2 输出: [4,3] 示例 2: 输入: root = [1], target = 0.000000, k = 1 输出: [1] 提示： 二叉树的节点总数为 n 1 \u003c= k \u003c= n \u003c= 104 0 \u003c= Node.val \u003c= 109 -109 \u003c= target ","date":"2015-09-29","objectID":"/leetcode/0272/:1:0","tags":null,"title":"0272：最接近的二叉搜索树值 II（★★）","uri":"/leetcode/0272/"},{"categories":null,"content":"分析 最简单的就是遍历所有值并排序。 ","date":"2015-09-29","objectID":"/leetcode/0272/:2:0","tags":null,"title":"0272：最接近的二叉搜索树值 II（★★）","uri":"/leetcode/0272/"},{"categories":null,"content":"解答 def closestKValues(self, root: TreeNode, target: float, k: int) -\u003e List[int]: A, stack = [], [root] while stack: p = stack.pop() if p: A.append(p.val) stack.extend([p.right, p.left]) return nsmallest(k, A, key=lambda x: abs(x-target)) 48 ms ","date":"2015-09-29","objectID":"/leetcode/0272/:3:0","tags":null,"title":"0272：最接近的二叉搜索树值 II（★★）","uri":"/leetcode/0272/"},{"categories":null,"content":" 力扣第 271 题 ","date":"2015-09-28","objectID":"/leetcode/0271/:0:0","tags":null,"title":"0271：字符串的编码与解码（★）","uri":"/leetcode/0271/"},{"categories":null,"content":"题目 请你设计一个算法，可以将一个 字符串列表 编码成为一个 字符串。这个编码后的字符串是可以通过网络进行高效传送的，并且可以在接收端被解码回原来的字符串列表。 1 号机（发送方）有如下函数： string encode(vector\u003cstring\u003e strs) { // ... your code return encoded_string; } 2 号机（接收方）有如下函数： vector\u003cstring\u003e decode(string s) { //... your code return strs; } 1 号机（发送方）执行： string encoded_string = encode","date":"2015-09-28","objectID":"/leetcode/0271/:1:0","tags":null,"title":"0271：字符串的编码与解码（★）","uri":"/leetcode/0271/"},{"categories":null,"content":"分析 用非 ascii 码的字符连接即可。 ","date":"2015-09-28","objectID":"/leetcode/0271/:2:0","tags":null,"title":"0271：字符串的编码与解码（★）","uri":"/leetcode/0271/"},{"categories":null,"content":"解答 class Codec: def encode(self, strs: List[str]) -\u003e str: return chr(257).join(strs) def decode(self, s: str) -\u003e List[str]: return s.split(chr(257)) 72 ms ","date":"2015-09-28","objectID":"/leetcode/0271/:3:0","tags":null,"title":"0271：字符串的编码与解码（★）","uri":"/leetcode/0271/"},{"categories":null,"content":" 力扣第 270 题 ","date":"2015-09-27","objectID":"/leetcode/0270/:0:0","tags":null,"title":"0270：最接近的二叉搜索树值","uri":"/leetcode/0270/"},{"categories":null,"content":"题目 给定一个不为空的二叉搜索树和一个目标值 target，请在该二叉搜索树中找到最接近目标值 target 的数值。 注意： 给定的目标值 target 是一个浮点数 题目保证在该二叉搜索树中只会存在一个最接近目标值的数 示例： 输入: root = [4,2,5,1,3]，目标值 target = 3.714286 4 / \\ 2 5 / \\ 1 3 输出: 4 ","date":"2015-09-27","objectID":"/leetcode/0270/:1:0","tags":null,"title":"0270：最接近的二叉搜索树值","uri":"/leetcode/0270/"},{"categories":null,"content":"分析 遍历并比较即可： 先比较 root 和 target 如果 root 比 target 小，那么左子树的节点都离 target 更远，继续遍历 root 的右子树即可 同理，如果 root 比 target 大，继续遍历 root 的左子树即可 ","date":"2015-09-27","objectID":"/leetcode/0270/:2:0","tags":null,"title":"0270：最接近的二叉搜索树值","uri":"/leetcode/0270/"},{"categories":null,"content":"解答 def closestValue(self, root: Optional[TreeNode], target: float) -\u003e int: res, p = inf, root while p: res = min([res, p.val], key=lambda x: abs(x-target)) p = p.left if p.val\u003etarget else p.right return res 36 ms ","date":"2015-09-27","objectID":"/leetcode/0270/:3:0","tags":null,"title":"0270：最接近的二叉搜索树值","uri":"/leetcode/0270/"},{"categories":null,"content":" 力扣第 269 题 ","date":"2015-09-26","objectID":"/leetcode/0269/:0:0","tags":null,"title":"0269：火星词典（★★）","uri":"/leetcode/0269/"},{"categories":null,"content":"题目 现有一种使用英语字母的火星语言，这门语言的字母顺序与英语顺序不同。 给你一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。 请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 \"\" 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。 字符串 s 字典顺序小于 字符串 t 有两种情况： 在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。 如果前面 min(s.length, t.length) 字母都相","date":"2015-09-26","objectID":"/leetcode/0269/:1:0","tags":null,"title":"0269：火星词典（★★）","uri":"/leetcode/0269/"},{"categories":null,"content":"分析 根据相邻单词的比较，可以得到一些字母的大小关系。 将字母看作顶点，大小关系看作有向边，即转为拓扑排序问题。 注意词典可能本身排序就错误，此时应该直接返回空字符串。 ","date":"2015-09-26","objectID":"/leetcode/0269/:2:0","tags":null,"title":"0269：火星词典（★★）","uri":"/leetcode/0269/"},{"categories":null,"content":"解答 def alienOrder(self, words: List[str]) -\u003e str: nxt, indeg = defaultdict(list), defaultdict(int) for w1, w2 in pairwise(words): if w1 != w2 and w1.startswith(w2): return '' for a,b in zip(w1, w2): if a!=b: nxt[a].append(b) indeg[b] += 1 break A = {c for w in words for c in w} Q = deque(u for u in ","date":"2015-09-26","objectID":"/leetcode/0269/:3:0","tags":null,"title":"0269：火星词典（★★）","uri":"/leetcode/0269/"},{"categories":null,"content":" 力扣第 268 题 ","date":"2015-09-25","objectID":"/leetcode/0268/:0:0","tags":null,"title":"0268：丢失的数字","uri":"/leetcode/0268/"},{"categories":null,"content":"题目 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 示例 1： 输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2： 输入：nums = [0,1] 输出：2 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3： 输入：nums = [9,6,4,2,3,5,7,0,1] 输出：8 解释：n = 9，因为","date":"2015-09-25","objectID":"/leetcode/0268/:1:0","tags":null,"title":"0268：丢失的数字","uri":"/leetcode/0268/"},{"categories":null,"content":"分析 直接算比原本的总和 sum(range(n+1)) 少了多少即可。 ","date":"2015-09-25","objectID":"/leetcode/0268/:2:0","tags":null,"title":"0268：丢失的数字","uri":"/leetcode/0268/"},{"categories":null,"content":"解答 def missingNumber(self, nums: List[int]) -\u003e int: return sum(range(len(nums)+1)) - sum(nums) 32 ms ","date":"2015-09-25","objectID":"/leetcode/0268/:3:0","tags":null,"title":"0268：丢失的数字","uri":"/leetcode/0268/"},{"categories":null,"content":" 力扣第 267 题 ","date":"2015-09-24","objectID":"/leetcode/0267/:0:0","tags":null,"title":"0267：回文排列 II（★）","uri":"/leetcode/0267/"},{"categories":null,"content":"题目 给定一个字符串 s ，返回 其重新排列组合后可能构成的所有回文字符串，并去除重复的组合 。 你可以按 任意顺序 返回答案。如果 s 不能形成任何回文排列时，则返回一个空列表。 示例 1： 输入: s = \"aabb\" 输出: [\"abba\", \"baab\"] 示例 2： 输入: s = \"abc\" 输出: [] 提示： 1 \u003c= s.length \u003c= 16 s 仅由小写英文字母组成 ","date":"2015-09-24","objectID":"/leetcode/0267/:1:0","tags":null,"title":"0267：回文排列 II（★）","uri":"/leetcode/0267/"},{"categories":null,"content":"分析 0266 升级版。 回文字符串的前一半和后一半对称，中间最多一个单独的字符。 因此，先通过计数器，拿到前一半和可能的中间字符，遍历前一半的所有排列并去重即可。 ","date":"2015-09-24","objectID":"/leetcode/0267/:2:0","tags":null,"title":"0267：回文排列 II（★）","uri":"/leetcode/0267/"},{"categories":null,"content":"解答 def generatePalindromes(self, s: str) -\u003e List[str]: half, mid = '', '' for c, freq in Counter(s).items(): half += c*(freq//2) mid += c*(freq%2) if len(mid)\u003e1: return [] return [''.join(sub)+mid+''.join(sub)[::-1] for sub in set(permutations(half))] 52 ms ","date":"2015-09-24","objectID":"/leetcode/0267/:3:0","tags":null,"title":"0267：回文排列 II（★）","uri":"/leetcode/0267/"},{"categories":null,"content":" 力扣第 266 题 ","date":"2015-09-23","objectID":"/leetcode/0266/:0:0","tags":null,"title":"0266：回文排列","uri":"/leetcode/0266/"},{"categories":null,"content":"题目 给定一个字符串，判断该字符串中是否可以通过重新排列组合，形成一个回文字符串。 示例 1： 输入: \"code\" 输出: false 示例 2： 输入: \"aab\" 输出: true 示例 3： 输入: \"carerac\" 输出: true ","date":"2015-09-23","objectID":"/leetcode/0266/:1:0","tags":null,"title":"0266：回文排列","uri":"/leetcode/0266/"},{"categories":null,"content":"分析 假如回文字符串长度是偶数，所有字符个数都应该是偶数。 假如回文字符串长度是奇数，只有一个字符个数为奇数。 因此，用计数器判断即可。 ","date":"2015-09-23","objectID":"/leetcode/0266/:2:0","tags":null,"title":"0266：回文排列","uri":"/leetcode/0266/"},{"categories":null,"content":"解答 def canPermutePalindrome(self, s: str) -\u003e bool: return sum(v%2 for v in Counter(s).values())\u003c=1 36 ms ","date":"2015-09-23","objectID":"/leetcode/0266/:3:0","tags":null,"title":"0266：回文排列","uri":"/leetcode/0266/"},{"categories":null,"content":" 力扣第 265 题 ","date":"2015-09-22","objectID":"/leetcode/0265/:0:0","tags":null,"title":"0265：粉刷房子 II（★★）","uri":"/leetcode/0265/"},{"categories":null,"content":"题目 假如有一排房子共有 n 幢，每个房子可以被粉刷成 k 种颜色中的一种。房子粉刷成不同颜色的花费成本也是不同的。你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 每个房子粉刷成不同颜色的花费以一个 n x k 的矩阵表示。 例如，costs[0][0] 表示第 0 幢房子粉刷成 0 号颜色的成本；costs[1][2] 表示第 1 幢房子粉刷成 2 号颜色的成本，以此类推。 返回 粉刷完所有房子的最低成本 。 示例 1： 输入: costs = [[1,5,3],[2,9,4]] 输出: 5 解释: 将房子 0 刷成 0 号颜色，房子 1 刷成 2 号颜色。花费: 1 + 4 = ","date":"2015-09-22","objectID":"/leetcode/0265/:1:0","tags":null,"title":"0265：粉刷房子 II（★★）","uri":"/leetcode/0265/"},{"categories":null,"content":"分析 0256 升级版。同样令 dp[i][j] 代表第 i 个房子刷成 j 颜色时，前 i 个房子所需的最低成本，即可递推。 $$dp[i][j] = costs[i][j]+min(dp[i-1][:j]+dp[i-1][j+1:])$$ 令 left[j] 代表 min(dp[i-1][:j])，right[j] 代表 min(dp[i-1][j+1:])，left，right 数组可以一趟得到。 因为 dp[i] 只依赖于 dp[i-1]，所以还可以优化为一维数组。 ","date":"2015-09-22","objectID":"/leetcode/0265/:2:0","tags":null,"title":"0265：粉刷房子 II（★★）","uri":"/leetcode/0265/"},{"categories":null,"content":"解答 def minCostII(self, costs: List[List[int]]) -\u003e int: n, k = len(costs), len(costs[0]) dp = [0]*k for row in costs: left = list(accumulate([inf]+dp[:-1], min)) right = list(accumulate([inf]+dp[:0:-1], min))[::-1] dp = [x+min(l, r) for x,l,r in zip(row, left, right)] return min(dp) 52 ms ","date":"2015-09-22","objectID":"/leetcode/0265/:3:0","tags":null,"title":"0265：粉刷房子 II（★★）","uri":"/leetcode/0265/"},{"categories":null,"content":" 力扣第 264 题 ","date":"2015-09-21","objectID":"/leetcode/0264/:0:0","tags":null,"title":"0264：丑数 II（★）","uri":"/leetcode/0264/"},{"categories":null,"content":"题目 给你一个整数 n ，请你找出并返回第 n 个 丑数 。 丑数 就是只包含质因数 2、3 和/或 5 的正整数。 示例 1： 输入：n = 10 输出：12 解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。 示例 2： 输入：n = 1 输出：1 解释：1 通常被视为丑数。 提示： 1 \u003c= n \u003c= 1690 ","date":"2015-09-21","objectID":"/leetcode/0264/:1:0","tags":null,"title":"0264：丑数 II（★）","uri":"/leetcode/0264/"},{"categories":null,"content":"分析 0263 升级版，有个巧妙的 dp 方法： 令 dp[n] 代表第 n 个丑数 显然后面的丑数必然是前面的某个丑数乘 2或3或5 得到： $$ dp[n]=min(dp[j]*p)_{ \\substack{ 0\\le j\u003cn;\\ p\\in\\ [2,3,5] \\\\ if\\ dp[j]*p\u003edp[n-1]}}$$ 观察发现，p 固定时，只需要考虑第一个使得 dp[j]*p\u003edp[n-1] 的 j 令 A[p] 代表第一个使得 dp[j]*p\u003edp[n-1] 的 j，递推式转为： $$dp[n]=min(dp[A[p]]*p)_{p\\in\\ [2,3,5]} $$ 维护 A[p] 很简单，当 ","date":"2015-09-21","objectID":"/leetcode/0264/:2:0","tags":null,"title":"0264：丑数 II（★）","uri":"/leetcode/0264/"},{"categories":null,"content":"解答 def nthUglyNumber(self, n: int) -\u003e int: dp, A = [1] * n, defaultdict(int) for i in range(1, n): dp[i] = min(dp[A[p]]*p for p in [2,3,5]) for p in [2,3,5]: if dp[A[p]]*p == dp[i]: A[p] += 1 return dp[-1] 时间复杂度 O(N)，224 ms ","date":"2015-09-21","objectID":"/leetcode/0264/:3:0","tags":null,"title":"0264：丑数 II（★）","uri":"/leetcode/0264/"},{"categories":null,"content":" 力扣第 263 题 ","date":"2015-09-20","objectID":"/leetcode/0263/:0:0","tags":null,"title":"0263：丑数","uri":"/leetcode/0263/"},{"categories":null,"content":"题目 丑数 就是只包含质因数 2、3 和 5 的正整数。 给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。 示例 1： 输入：n = 6 输出：true 解释：6 = 2 × 3 示例 2： 输入：n = 1 输出：true 解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。 示例 3： 输入：n = 14 输出：false 解释：14 不是丑数，因为它包含了另外一个质因数 7 。 提示： -231 \u003c= n \u003c= 231 - 1 ","date":"2015-09-20","objectID":"/leetcode/0263/:1:0","tags":null,"title":"0263：丑数","uri":"/leetcode/0263/"},{"categories":null,"content":"分析 ","date":"2015-09-20","objectID":"/leetcode/0263/:2:0","tags":null,"title":"0263：丑数","uri":"/leetcode/0263/"},{"categories":null,"content":"#1 去掉所有 2、3、5 的因子，看是否变为 1 即可。 def isUgly(self, n: int) -\u003e bool: if n \u003c= 0: return False for p in [2, 3, 5]: while n % p == 0: n //= p return n == 1 36 ms ","date":"2015-09-20","objectID":"/leetcode/0263/:2:1","tags":null,"title":"0263：丑数","uri":"/leetcode/0263/"},{"categories":null,"content":"#2 丑数必然是 $2^{a}*3^{b}*5^{c}$ 的形式。 而所给范围内的丑数，必然有 a\u003c=30，b\u003c=19，c\u003c=13。 因此丑数等价于是 $2^{30}*3^{19}*5^{13}$ 的因数。 ","date":"2015-09-20","objectID":"/leetcode/0263/:2:2","tags":null,"title":"0263：丑数","uri":"/leetcode/0263/"},{"categories":null,"content":"解答 def isUgly(self, n: int) -\u003e bool: return n \u003e 0 and pow(2,30)*pow(3,19)*pow(5,13)%n == 0 36 ms ","date":"2015-09-20","objectID":"/leetcode/0263/:3:0","tags":null,"title":"0263：丑数","uri":"/leetcode/0263/"},{"categories":null,"content":" 力扣第 262 题 ","date":"2015-09-19","objectID":"/leetcode/0262/:0:0","tags":null,"title":"0262：行程和用户（★★）","uri":"/leetcode/0262/"},{"categories":null,"content":"题目 表：Trips +-------------+----------+ | Column Name | Type | +-------------+----------+ | id | int | | client_id | int | | driver_id | int | | city_id | int | | status | enum | | request_at | date | +-------------+----------+ id 是这张表的主键。 这张表中存所有出租车的行程信息。每段行程有唯一 id ，其中 client_id 和 driver_id 是 Users 表","date":"2015-09-19","objectID":"/leetcode/0262/:1:0","tags":null,"title":"0262：行程和用户（★★）","uri":"/leetcode/0262/"},{"categories":null,"content":"分析 先通过连接筛出非禁止用户的请求，然后按日期分组，求每组的取消率即可。 ","date":"2015-09-19","objectID":"/leetcode/0262/:2:0","tags":null,"title":"0262：行程和用户（★★）","uri":"/leetcode/0262/"},{"categories":null,"content":"解答 select request_at as Day, round(avg(status!='completed'), 2) as 'Cancellation Rate' from Trips a inner join Users b on a.client_id = b.users_id and b.banned = 'No' inner join Users c on a.driver_id = c.users_id and c.banned = 'No' where request_at between '2013-10-01' and '2013-10-03' group by re","date":"2015-09-19","objectID":"/leetcode/0262/:3:0","tags":null,"title":"0262：行程和用户（★★）","uri":"/leetcode/0262/"},{"categories":null,"content":"少女成濑顺（水濑祈 配音）有着一段不堪回首的童年往事，曾经，年少无知的她因为口无遮拦，导致了家族的悲剧，而她本人亦被封印了言语，无法再开口说话。这样的顺终日生活在悲伤之中，和所有人都保持着距离，紧紧的关闭上了心门。  \n\n某一天，浑浑噩噩迷迷糊糊的少年坂上拓実（内山昂辉 配音）、因为受伤而无法完成棒球梦想的田崎大树（细谷佳正 配音）、深陷令人苦恼的恋爱之中的拉拉队员仁藤菜月（雨宫天 配音）以及顺，这四人被老师任命组成了“地域沟通交流会”，他们要在交流会上表演一出音乐剧，可是班级里的大部分学生对此兴趣寥寥。在一片争执声中，顺突然出声，担下了演唱的任务。","date":"2015-09-19","objectID":"/anime/beautiful_word_beautiful_world/","tags":null,"title":"心灵想要大声呼喊。","uri":"/anime/beautiful_word_beautiful_world/"},{"categories":null,"content":"简介 少女成濑顺（水濑祈 配音）有着一段不堪回首的童年往事，曾经，年少无知的她因为口无遮拦，导致了家族的悲剧，而她本人亦被封印了言语，无法再开口说话。这样的顺终日生活在悲伤之中，和所有人都保持着距离，紧紧的关闭上了心门。 某一天，浑浑噩噩迷迷糊糊的少年坂上拓実（内山昂辉 配音）、因为受伤而无法完成棒球梦想的田崎大树（细谷佳正 配音）、深陷令人苦恼的恋爱之中的拉拉队员仁藤菜月（雨宫天 配音）以及顺，这四人被老师任命组成了“地域沟通交流会”，他们要在交流会上表演一出音乐剧，可是班级里的大部分学生对此兴趣寥寥。在一片争执声中，顺突然出声，担下了演唱的任务。 制作人员： 原作：超和平Busters 导","date":"2015-09-19","objectID":"/anime/beautiful_word_beautiful_world/:1:0","tags":null,"title":"心灵想要大声呼喊。","uri":"/anime/beautiful_word_beautiful_world/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 成濑顺 成瀬 順、なるせ じゅん、Naruse Jun 女 水瀬いのり 2 坂上拓实 坂上 拓実、さかがみ たくみ、Sakagami Takumi 男 内山昂輝 3 仁藤菜月 仁藤 菜月、にとう なつき、Nitō Natsuki 女 雨宮天 4 田崎大树 田崎 大樹、たさき だいき、Tasaki Daiki 男 細谷佳正 5 城嶋一基 城嶋 一基、じょうしま かずき 男 藤原啓治 6 三嶋树 みしま いつき、Mishima Itsuki 男 村田太志 7 岩木寿则 岩木 寿則、いわき としのり、Iwaki Toshinori 男 古川慎 8 相泽基纪 相沢 ","date":"2015-09-19","objectID":"/anime/beautiful_word_beautiful_world/:2:0","tags":null,"title":"心灵想要大声呼喊。","uri":"/anime/beautiful_word_beautiful_world/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 心灵想要大声呼喊。 2015-09-19 01:59:17 bilibili ","date":"2015-09-19","objectID":"/anime/beautiful_word_beautiful_world/:3:0","tags":null,"title":"心灵想要大声呼喊。","uri":"/anime/beautiful_word_beautiful_world/"},{"categories":null,"content":"MAD ","date":"2015-09-19","objectID":"/anime/beautiful_word_beautiful_world/:4:0","tags":null,"title":"心灵想要大声呼喊。","uri":"/anime/beautiful_word_beautiful_world/"},{"categories":null,"content":" 力扣第 261 题 ","date":"2015-09-18","objectID":"/leetcode/0261/:0:0","tags":null,"title":"0261：以图判树（★）","uri":"/leetcode/0261/"},{"categories":null,"content":"题目 给定编号从 0 到 n - 1 的 n 个结点。给定一个整数 n 和一个 edges 列表，其中 edges[i] = [ai, bi] 表示图中节点 ai 和 bi 之间存在一条无向边。 如果这些边能够形成一个合法有效的树结构，则返回 true ，否则返回 false 。 示例 1： 输入: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]] 输出: true 示例 2: 输入: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]] 输出: false 提示： 1 \u003c= n \u003c= 2000 0 \u003c= edges.le","date":"2015-09-18","objectID":"/leetcode/0261/:1:0","tags":null,"title":"0261：以图判树（★）","uri":"/leetcode/0261/"},{"categories":null,"content":"分析 只要所有点连通且没有环，即是一棵树。用并查集判断即可。 ","date":"2015-09-18","objectID":"/leetcode/0261/:2:0","tags":null,"title":"0261：以图判树（★）","uri":"/leetcode/0261/"},{"categories":null,"content":"解答 def validTree(self, n: int, edges: List[List[int]]) -\u003e bool: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) if len(edges) != n-1: return False f = list(range(n)) for u, v in edges: if find(u)==find(v): return False union(u, v) return True 40 ms ","date":"2015-09-18","objectID":"/leetcode/0261/:3:0","tags":null,"title":"0261：以图判树（★）","uri":"/leetcode/0261/"},{"categories":null,"content":" 力扣第 260 题 ","date":"2015-09-17","objectID":"/leetcode/0260/:0:0","tags":null,"title":"0260：只出现一次的数字 III（★）","uri":"/leetcode/0260/"},{"categories":null,"content":"题目 给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。 你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。 示例 1： 输入：nums = [1,2,1,3,2,5] 输出：[3,5] 解释：[5, 3] 也是有效的答案。 示例 2： 输入：nums = [-1,0] 输出：[-1,0] 示例 3： 输入：nums = [0,1] 输出：[1,0] 提示： 2 \u003c= nums.length \u003c= 3 * 104 -231 \u003c= nums[i] \u003c= 231 - 1 除两个只出现一次","date":"2015-09-17","objectID":"/leetcode/0260/:1:0","tags":null,"title":"0260：只出现一次的数字 III（★）","uri":"/leetcode/0260/"},{"categories":null,"content":"分析 ","date":"2015-09-17","objectID":"/leetcode/0260/:2:0","tags":null,"title":"0260：只出现一次的数字 III（★）","uri":"/leetcode/0260/"},{"categories":null,"content":"#1 0136 升级版，最简单的依然是哈希表。 def singleNumber(self, nums: List[int]) -\u003e List[int]: ct = Counter(nums) return [num for num in nums if ct[num]==1] 44 ms ","date":"2015-09-17","objectID":"/leetcode/0260/:2:1","tags":null,"title":"0260：只出现一次的数字 III（★）","uri":"/leetcode/0260/"},{"categories":null,"content":"#2 同样有巧妙的位运算方法： 设出现两次的元素是 a、b 将所有数字异或得到 x，显然 x = a^b 在 x 的二进制表示中，任选一个为 1 的位置 i，按二进制的位置 i 是否为 1 可以将 nums 分为两组 显然 a、b 必然在不同的组，而相同的数必然在同一组 每一组就转为问题 0136 ","date":"2015-09-17","objectID":"/leetcode/0260/:2:2","tags":null,"title":"0260：只出现一次的数字 III（★）","uri":"/leetcode/0260/"},{"categories":null,"content":"解答 def singleNumber(self, nums: List[int]) -\u003e List[int]: x = reduce(xor, nums) i = len(bin(x))-3 a, b = 0, 0 for num in nums: if num \u0026 (1\u003c\u003ci): a ^= num else: b ^= num return [a, b] 40 ms ","date":"2015-09-17","objectID":"/leetcode/0260/:3:0","tags":null,"title":"0260：只出现一次的数字 III（★）","uri":"/leetcode/0260/"},{"categories":null,"content":" 力扣第 259 题 ","date":"2015-09-16","objectID":"/leetcode/0259/:0:0","tags":null,"title":"0259：较小的三数之和（★）","uri":"/leetcode/0259/"},{"categories":null,"content":"题目 给定一个长度为 n 的整数数组和一个目标值 target ，寻找能够使条件 nums[i] + nums[j] + nums[k] \u003c target 成立的三元组 i, j, k 个数（0 \u003c= i \u003c j \u003c k \u003c n）。 示例 1： 输入: nums = [-2,0,1,3], target = 2 输出: 2 解释: 因为一共有两个三元组满足累加和小于 2: [-2,0,1] [-2,0,3] 示例 2： 输入: nums = [], target = 0 输出: 0 示例 3： 输入: nums = [0], target = 0 输出: 0 提示: n == nums.len","date":"2015-09-16","objectID":"/leetcode/0259/:1:0","tags":null,"title":"0259：较小的三数之和（★）","uri":"/leetcode/0259/"},{"categories":null,"content":"分析 注意到数的范围很小，因此考虑递推出 所有可能的三元组之和及其个数。 令 dp[i][j] 代表 nums[:i] 所有可能的 j 元组之和及其个数，即可递推。 因为 dp[i] 只依赖于 dp[i-1]，所以可以优化为 3 个计数器。 ","date":"2015-09-16","objectID":"/leetcode/0259/:2:0","tags":null,"title":"0259：较小的三数之和（★）","uri":"/leetcode/0259/"},{"categories":null,"content":"解答 def threeSumSmaller(self, nums: List[int], target: int) -\u003e int: d1, d2, d3 = [defaultdict(int) for _ in range(3)] for x in nums: for y in d2: d3[x+y] += d2[y] for y in d1: d2[x+y] += d1[y] d1[x] += 1 return sum(d3[x] for x in d3 if x\u003ctarget) 116 ms ","date":"2015-09-16","objectID":"/leetcode/0259/:3:0","tags":null,"title":"0259：较小的三数之和（★）","uri":"/leetcode/0259/"},{"categories":null,"content":" 力扣第 258 题 ","date":"2015-09-15","objectID":"/leetcode/0258/:0:0","tags":null,"title":"0258：各位相加","uri":"/leetcode/0258/"},{"categories":null,"content":"题目 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。 示例 1: 输入: num = 38 输出: 2 解释: 各位相加的过程为： 38 --\u003e 3 + 8 --\u003e 11 11 --\u003e 1 + 1 --\u003e 2 由于 2 是一位数，所以返回 2。 示例 2: 输入: num = 0 输出: 0 提示： 0 \u003c= num \u003c= 231 - 1 进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？ ","date":"2015-09-15","objectID":"/leetcode/0258/:1:0","tags":null,"title":"0258：各位相加","uri":"/leetcode/0258/"},{"categories":null,"content":"分析 ","date":"2015-09-15","objectID":"/leetcode/0258/:2:0","tags":null,"title":"0258：各位相加","uri":"/leetcode/0258/"},{"categories":null,"content":"#1 模拟即可。 def addDigits(self, num: int) -\u003e int: while num \u003e= 10: num = sum(map(int, str(num))) return num ","date":"2015-09-15","objectID":"/leetcode/0258/:2:1","tags":null,"title":"0258：各位相加","uri":"/leetcode/0258/"},{"categories":null,"content":"#2 由数学知识可知，一个数各位相加模 9 的余数等于该数模 9 的余数。 注意排除 num 为 0 的情况。 ","date":"2015-09-15","objectID":"/leetcode/0258/:2:2","tags":null,"title":"0258：各位相加","uri":"/leetcode/0258/"},{"categories":null,"content":"解答 def addDigits(self, num: int) -\u003e int: return num%9 or min(num, 9) 32 ms ","date":"2015-09-15","objectID":"/leetcode/0258/:3:0","tags":null,"title":"0258：各位相加","uri":"/leetcode/0258/"},{"categories":null,"content":" 力扣第 257 题 ","date":"2015-09-14","objectID":"/leetcode/0257/:0:0","tags":null,"title":"0257：二叉树的所有路径","uri":"/leetcode/0257/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [1,2,3,null,5] 输出：[\"1-\u003e2-\u003e5\",\"1-\u003e3\"] 示例 2： 输入：root = [1] 输出：[\"1\"] 提示： 树中节点的数目在范围 [1, 100] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-09-14","objectID":"/leetcode/0257/:1:0","tags":null,"title":"0257：二叉树的所有路径","uri":"/leetcode/0257/"},{"categories":null,"content":"分析 遍历时维护根节点到当前节点的路径，遇到叶子节点就加到结果中即可。 ","date":"2015-09-14","objectID":"/leetcode/0257/:2:0","tags":null,"title":"0257：二叉树的所有路径","uri":"/leetcode/0257/"},{"categories":null,"content":"解答 def binaryTreePaths(self, root: TreeNode) -\u003e List[str]: res, stack = [], [(root, '')] while stack: node, s = stack.pop() if node: s += ('-\u003e' if s else '') + str(node.val) if not node.left and not node.right: res.append(s) stack.extend([(node.right, s), (node.left, s)]) return res 24 ms ","date":"2015-09-14","objectID":"/leetcode/0257/:3:0","tags":null,"title":"0257：二叉树的所有路径","uri":"/leetcode/0257/"},{"categories":null,"content":" 力扣第 256 题 ","date":"2015-09-13","objectID":"/leetcode/0256/:0:0","tags":null,"title":"0256：粉刷房子（★）","uri":"/leetcode/0256/"},{"categories":null,"content":"题目 假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。 请计算出粉刷完所有房子最少的花费成本。 示例 1： 输入: costs = [[17,2,17],[16,16,5],[14,3,19]","date":"2015-09-13","objectID":"/leetcode/0256/:1:0","tags":null,"title":"0256：粉刷房子（★）","uri":"/leetcode/0256/"},{"categories":null,"content":"分析 可以令 dp[i][j] 代表第 i 个房子刷成 j 颜色时，前 i 个房子所需的最低成本，即可递推。 因为 dp[i] 只依赖于 dp[i-1]，所以可以优化为三个参数。 ","date":"2015-09-13","objectID":"/leetcode/0256/:2:0","tags":null,"title":"0256：粉刷房子（★）","uri":"/leetcode/0256/"},{"categories":null,"content":"解答 def minCost(self, costs: List[List[int]]) -\u003e int: a, b, c = 0, 0, 0 for x,y,z in costs: a, b, c = x+min(b,c), y+min(a,c), z+min(a,b) return min(a,b,c) 40 ms ","date":"2015-09-13","objectID":"/leetcode/0256/:3:0","tags":null,"title":"0256：粉刷房子（★）","uri":"/leetcode/0256/"},{"categories":null,"content":" 力扣第 255 题 ","date":"2015-09-12","objectID":"/leetcode/0255/:0:0","tags":null,"title":"0255：验证前序遍历序列二叉搜索树（★）","uri":"/leetcode/0255/"},{"categories":null,"content":"题目 给定一个 无重复元素 的整数数组 preorder ， 如果它是以二叉搜索树的先序遍历排列 ，返回 true 。 示例 1： 输入: preorder = [5,2,1,3,6] 输出: true 示例 2： 输入: preorder = [5,2,6,1,3] 输出: false 提示: 1 \u003c= preorder.length \u003c= 104 1 \u003c= preorder[i] \u003c= 104 preorder 中 无重复元素 进阶：您能否使用恒定的空间复杂度来完成此题？ ","date":"2015-09-12","objectID":"/leetcode/0255/:1:0","tags":null,"title":"0255：验证前序遍历序列二叉搜索树（★）","uri":"/leetcode/0255/"},{"categories":null,"content":"分析 先模拟先序遍历的过程： 一开始一直往左走到底 如果该节点没有右子树，就返回其根节点 如果该节点有右子树，就走到右子树，跳回第一步 根据 preorder 元素的大小可以还原这一过程： 递减即是在往左走 增大时，假如当前元素为 x ，往左找到最大的小于 x 的元素 y， y 即是应该返回到的根节点，x 是 y 的右节点 假如 x 子树里的某个节点小于 y，即错误 可以用单调栈来具体实现： 维护一个单调递减的栈，并维护当前元素所处右子树的根节点的值 bound 每来一个元素 x，弹出比 x 小的元素 y，并更新 bound = y 假如 x\u003cbound，即错误 ","date":"2015-09-12","objectID":"/leetcode/0255/:2:0","tags":null,"title":"0255：验证前序遍历序列二叉搜索树（★）","uri":"/leetcode/0255/"},{"categories":null,"content":"解答 def verifyPreorder(self, preorder: List[int]) -\u003e bool: stack, bound = [], 0 for x in preorder: if x\u003cbound: return False while stack and stack[-1]\u003cx: bound = stack.pop() stack.append(x) return True 48 ms ","date":"2015-09-12","objectID":"/leetcode/0255/:3:0","tags":null,"title":"0255：验证前序遍历序列二叉搜索树（★）","uri":"/leetcode/0255/"},{"categories":null,"content":" 力扣第 254 题 ","date":"2015-09-11","objectID":"/leetcode/0254/:0:0","tags":null,"title":"0254：因子的组合（★）","uri":"/leetcode/0254/"},{"categories":null,"content":"题目 整数可以被看作是其因子的乘积。 例如： 8 = 2 x 2 x 2; = 2 x 4. 请实现一个函数，该函数接收一个整数 n 并返回该整数所有的因子组合。 注意： 你可以假定 n 为永远为正数。 因子必须大于 1 并且小于 n。 示例 1： 输入: 1 输出: [] 示例 2： 输入: 37 输出: [] 示例 3： 输入: 12 输出: [ [2, 6], [2, 2, 3], [3, 4] ] 示例 4: 输入: 32 输出: [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ","date":"2015-09-11","objectID":"/leetcode/0254/:1:0","tags":null,"title":"0254：因子的组合（★）","uri":"/leetcode/0254/"},{"categories":null,"content":"分析 令 dfs(n, p) 代表 n 的所有最小因子 \u003e=p 的因子组合，即可递归。 ","date":"2015-09-11","objectID":"/leetcode/0254/:2:0","tags":null,"title":"0254：因子的组合（★）","uri":"/leetcode/0254/"},{"categories":null,"content":"解答 def getFactors(self, n: int) -\u003e List[List[int]]: def dfs(n, p): res = [] for i in range(p, int(sqrt(n))+1): if n%i==0: res.append([i, n//i]) for sub in dfs(n//i, i): res.append([i]+sub) return res return dfs(n, 2) 52 ms ","date":"2015-09-11","objectID":"/leetcode/0254/:3:0","tags":null,"title":"0254：因子的组合（★）","uri":"/leetcode/0254/"},{"categories":null,"content":" 力扣第 253 题 ","date":"2015-09-10","objectID":"/leetcode/0253/:0:0","tags":null,"title":"0253：会议室 II（★）","uri":"/leetcode/0253/"},{"categories":null,"content":"题目 给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。 示例 1： 输入：intervals = [[0,30],[5,10],[15,20]] 输出：2 示例 2： 输入：intervals = [[7,10],[2,4]] 输出：1 提示： 1 \u003c= intervals.length \u003c= 104 0 \u003c= starti \u003c endi \u003c= 106 ","date":"2015-09-10","objectID":"/leetcode/0253/:1:0","tags":null,"title":"0253：会议室 II（★）","uri":"/leetcode/0253/"},{"categories":null,"content":"分析 先将 intervals 排序，然后模拟： 初始没有会议室 来了一个会议时，假如没有空闲的会议室，就加一个，并记录下会议结束时间 如果已经有会议室结束了，可以任选一个安排新的会议，并更新会议结束时间 ","date":"2015-09-10","objectID":"/leetcode/0253/:2:0","tags":null,"title":"0253：会议室 II（★）","uri":"/leetcode/0253/"},{"categories":null,"content":"解答 def minMeetingRooms(self, intervals: List[List[int]]) -\u003e int: pq = [] for a,b in sorted(intervals): if pq and a\u003e=pq[0]: heappop(pq) heappush(pq, b) return len(pq) 36 ms ","date":"2015-09-10","objectID":"/leetcode/0253/:3:0","tags":null,"title":"0253：会议室 II（★）","uri":"/leetcode/0253/"},{"categories":null,"content":" 力扣第 252 题 ","date":"2015-09-09","objectID":"/leetcode/0252/:0:0","tags":null,"title":"0252：会议室","uri":"/leetcode/0252/"},{"categories":null,"content":"题目 给定一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，请你判断一个人是否能够参加这里面的全部会议。 示例 1： 输入：intervals = [[0,30],[5,10],[15,20]] 输出：false 示例 2： 输入：intervals = [[7,10],[2,4]] 输出：true 提示： 0 \u003c= intervals.length \u003c= 104 intervals[i].length == 2 0 \u003c= starti \u003c endi \u003c= 106 ","date":"2015-09-09","objectID":"/leetcode/0252/:1:0","tags":null,"title":"0252：会议室","uri":"/leetcode/0252/"},{"categories":null,"content":"分析 等价于所有区间都不重叠，排序后比较相邻区间即可。 ","date":"2015-09-09","objectID":"/leetcode/0252/:2:0","tags":null,"title":"0252：会议室","uri":"/leetcode/0252/"},{"categories":null,"content":"解答 def canAttendMeetings(self, intervals: List[List[int]]) -\u003e bool: return all(a[1]\u003c=b[0] for a,b in pairwise(sorted(intervals))) 36 ms ","date":"2015-09-09","objectID":"/leetcode/0252/:3:0","tags":null,"title":"0252：会议室","uri":"/leetcode/0252/"},{"categories":null,"content":" 力扣第 251 题 ","date":"2015-09-08","objectID":"/leetcode/0251/:0:0","tags":null,"title":"0251：展开二维向量（★）","uri":"/leetcode/0251/"},{"categories":null,"content":"题目 请设计并实现一个能够展开二维向量的迭代器。该迭代器需要支持 next 和 hasNext 两种操作。 示例： Vector2D iterator = new Vector2D([[1,2],[3],[4]]); iterator.next(); // 返回 1 iterator.next(); // 返回 2 iterator.next(); // 返回 3 iterator.hasNext(); // 返回 true iterator.hasNext(); // 返回 true iterator.next(); // 返回 4 iterator.hasNext(); // 返回 fal","date":"2015-09-08","objectID":"/leetcode/0251/:1:0","tags":null,"title":"0251：展开二维向量（★）","uri":"/leetcode/0251/"},{"categories":null,"content":"分析 ","date":"2015-09-08","objectID":"/leetcode/0251/:2:0","tags":null,"title":"0251：展开二维向量（★）","uri":"/leetcode/0251/"},{"categories":null,"content":"#1 最简单的就是展开为队列，每次队首弹出即可。 class Vector2D: def __init__(self, vec: List[List[int]]): self.Q = deque(x for sub in vec for x in sub) def next(self) -\u003e int: return self.Q.popleft() def hasNext(self) -\u003e bool: return bool(self.Q) 68 ms ","date":"2015-09-08","objectID":"/leetcode/0251/:2:1","tags":null,"title":"0251：展开二维向量（★）","uri":"/leetcode/0251/"},{"categories":null,"content":"#2 还可以直接在二维数组上迭代，记录当前元素的二维下标即可。 为了方便，可以让 hasNext 将二维下标移到下一个有效元素，next 先调用 hasNext 即可。 ","date":"2015-09-08","objectID":"/leetcode/0251/:2:2","tags":null,"title":"0251：展开二维向量（★）","uri":"/leetcode/0251/"},{"categories":null,"content":"解答 class Vector2D: def __init__(self, vec: List[List[int]]): self.vec = vec self.i = 0 self.j = 0 def next(self) -\u003e int: self.hasNext() res = self.vec[self.i][self.j] self.j += 1 return res def hasNext(self) -\u003e bool: while self.i\u003clen(self.vec) and self.j == len(self.vec[self.i]): self.i += 1 self.j ","date":"2015-09-08","objectID":"/leetcode/0251/:3:0","tags":null,"title":"0251：展开二维向量（★）","uri":"/leetcode/0251/"},{"categories":null,"content":" 力扣第 250 题 ","date":"2015-09-07","objectID":"/leetcode/0250/:0:0","tags":null,"title":"0250：统计同值子树（★）","uri":"/leetcode/0250/"},{"categories":null,"content":"题目 给定一个二叉树，统计该二叉树数值相同的子树个数。 同值子树是指该子树的所有节点都拥有相同的数值。 示例： 输入: root = [5,1,5,5,5,null,5] 5 / \\ 1 5 / \\ \\ 5 5 5 输出: 4 ","date":"2015-09-07","objectID":"/leetcode/0250/:1:0","tags":null,"title":"0250：统计同值子树（★）","uri":"/leetcode/0250/"},{"categories":null,"content":"分析 可以递归判断每个子树是否是同值子树，递归过程中统计即可。 ","date":"2015-09-07","objectID":"/leetcode/0250/:2:0","tags":null,"title":"0250：统计同值子树（★）","uri":"/leetcode/0250/"},{"categories":null,"content":"解答 def countUnivalSubtrees(self, root: Optional[TreeNode]) -\u003e int: def dfs(node): if not node: return True flag = True if node.left: flag \u0026= dfs(node.left) and node.left.val==node.val if node.right: flag \u0026= dfs(node.right) and node.right.val==node.val self.res += flag return flag self.res = 0 dfs(ro","date":"2015-09-07","objectID":"/leetcode/0250/:3:0","tags":null,"title":"0250：统计同值子树（★）","uri":"/leetcode/0250/"},{"categories":null,"content":" 力扣第 249 题 ","date":"2015-09-06","objectID":"/leetcode/0249/:0:0","tags":null,"title":"0249：移位字符串分组（★）","uri":"/leetcode/0249/"},{"categories":null,"content":"题目 给定一个字符串，对该字符串可以进行 “移位” 的操作，也就是将字符串中每个字母都变为其在字母表中后续的字母，比如：\"abc\" -\u003e \"bcd\"。这样，我们可以持续进行 “移位” 操作，从而生成如下移位序列： \"abc\" -\u003e \"bcd\" -\u003e ... -\u003e \"xyz\" 给定一个包含仅小写字母字符串的列表，将该列表中所有满足 “移位” 操作规律的组合进行分组并返回。 示例： 输入：[\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"] 输出： [ [\"abc\",\"bcd\",\"xyz\"], [\"az\",\"ba\"], [\"acef\"], [\"a\"","date":"2015-09-06","objectID":"/leetcode/0249/:1:0","tags":null,"title":"0249：移位字符串分组（★）","uri":"/leetcode/0249/"},{"categories":null,"content":"分析 典型的哈希表，按特征分组。 这里共同的特征是相邻字母的偏移量相同，因此转为字符串作为键值即可。 ","date":"2015-09-06","objectID":"/leetcode/0249/:2:0","tags":null,"title":"0249：移位字符串分组（★）","uri":"/leetcode/0249/"},{"categories":null,"content":"解答 def groupStrings(self, strings: List[str]) -\u003e List[List[str]]: d = defaultdict(list) for w in strings: key = ''.join(chr((ord(b)-ord(a))%26) for a,b in pairwise(w)) d[key].append(w) return list(d.values()) 40 ms ","date":"2015-09-06","objectID":"/leetcode/0249/:3:0","tags":null,"title":"0249：移位字符串分组（★）","uri":"/leetcode/0249/"},{"categories":null,"content":" 力扣第 248 题 ","date":"2015-09-05","objectID":"/leetcode/0248/:0:0","tags":null,"title":"0248：中心对称数 III（★★）","uri":"/leetcode/0248/"},{"categories":null,"content":"题目 给定两个字符串 low 和 high 表示两个整数 low 和 high ，其中 low \u003c= high ，返回 范围 [low, high] 内的 「中心对称数」总数 。 中心对称数 是一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。 示例 1: 输入: low = \"50\", high = \"100\" 输出: 3 示例 2: 输入: low = \"0\", high = \"0\" 输出: 1 提示: 1 \u003c= low.length, high.length \u003c= 15 low 和 high 只包含数字 low \u003c= high low and high 不包含任何","date":"2015-09-05","objectID":"/leetcode/0248/:1:0","tags":null,"title":"0248：中心对称数 III（★★）","uri":"/leetcode/0248/"},{"categories":null,"content":"分析 0247 升级版，递推得到所有不超过 high 长度的中心对称数，判断是否在范围内即可。 注意最外层为 0 的不能计数。 ","date":"2015-09-05","objectID":"/leetcode/0248/:2:0","tags":null,"title":"0248：中心对称数 III（★★）","uri":"/leetcode/0248/"},{"categories":null,"content":"解答 def strobogrammaticInRange(self, low: str, high: str) -\u003e int: n, low, high = len(high), int(low), int(high) dp = [[] for _ in range(n+1)] dp[0], dp[1] = [''], ['0', '1', '8'] res = sum(low\u003c=int(x)\u003c=high for x in dp[1]) for i in range(2, n+1): dp[i] = [a+sub+b for sub in dp[i-2] for a,b in zip('16","date":"2015-09-05","objectID":"/leetcode/0248/:3:0","tags":null,"title":"0248：中心对称数 III（★★）","uri":"/leetcode/0248/"},{"categories":null,"content":" 力扣第 247 题 ","date":"2015-09-04","objectID":"/leetcode/0247/:0:0","tags":null,"title":"0247：中心对称数 II（★）","uri":"/leetcode/0247/"},{"categories":null,"content":"题目 给定一个整数 n ，返回所有长度为 n 的 中心对称数 。你可以以 任何顺序 返回答案。 中心对称数 是一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。 示例 1: 输入：n = 2 输出：[\"11\",\"69\",\"88\",\"96\"] 示例 2: 输入：n = 1 输出：[\"0\",\"1\",\"8\"] 提示： 1 \u003c= n \u003c= 14 ","date":"2015-09-04","objectID":"/leetcode/0247/:1:0","tags":null,"title":"0247：中心对称数 II（★）","uri":"/leetcode/0247/"},{"categories":null,"content":"分析 可以按最外层的数字递归。 注意当 n\u003e=2 时，最外层不能为 0。 ","date":"2015-09-04","objectID":"/leetcode/0247/:2:0","tags":null,"title":"0247：中心对称数 II（★）","uri":"/leetcode/0247/"},{"categories":null,"content":"解答 def findStrobogrammatic(self, n: int) -\u003e List[str]: res = ['0', '1', '8'] if n%2 else [''] for _ in range(n%2+2, n-1, 2): res = [a+sub+b for sub in res for a,b in zip('01689', '01986')] if n\u003e=2: res = [a+sub+b for sub in res for a,b in zip('1689', '1986')] return res 36 ms ","date":"2015-09-04","objectID":"/leetcode/0247/:3:0","tags":null,"title":"0247：中心对称数 II（★）","uri":"/leetcode/0247/"},{"categories":null,"content":" 力扣第 246 题 ","date":"2015-09-03","objectID":"/leetcode/0246/:0:0","tags":null,"title":"0246：中心对称数","uri":"/leetcode/0246/"},{"categories":null,"content":"题目 中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。 请写一个函数来判断该数字是否是中心对称数，其输入将会以一个字符串的形式来表达数字。 示例 1: 输入: num = \"69\" 输出: true 示例 2: 输入: num = \"88\" 输出: true 示例 3: 输入: num = \"962\" 输出: false 示例 4： 输入：num = \"1\" 输出：true ","date":"2015-09-03","objectID":"/leetcode/0246/:1:0","tags":null,"title":"0246：中心对称数","uri":"/leetcode/0246/"},{"categories":null,"content":"分析 只有 ‘01689’ 才能旋转，可以得到旋转的对应关系，模拟即可。 ","date":"2015-09-03","objectID":"/leetcode/0246/:2:0","tags":null,"title":"0246：中心对称数","uri":"/leetcode/0246/"},{"categories":null,"content":"解答 def isStrobogrammatic(self, num: str) -\u003e bool: d = dict(zip('01689', '01986')) return ''.join(d.get(c, '') for c in num)[::-1]==num 32 ms ","date":"2015-09-03","objectID":"/leetcode/0246/:3:0","tags":null,"title":"0246：中心对称数","uri":"/leetcode/0246/"},{"categories":null,"content":" 力扣第 245 题 ","date":"2015-09-02","objectID":"/leetcode/0245/:0:0","tags":null,"title":"0245：最短单词距离 III（★）","uri":"/leetcode/0245/"},{"categories":null,"content":"题目 给定一个字符串数组 wordsDict 和两个字符串 word1 和 word2 ，返回这两个单词在列表中出现的最短距离。 注意：word1 和 word2 是有可能相同的，并且它们将分别表示为列表中 两个独立的单词 。 示例 1： 输入：wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"coding\" 输出：1 示例 2： 输入：wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"],","date":"2015-09-02","objectID":"/leetcode/0245/:1:0","tags":null,"title":"0245：最短单词距离 III（★）","uri":"/leetcode/0245/"},{"categories":null,"content":"分析 与 0243 的区别在于 word1 和 word2 可能相同。 在更新 res 后再统一更新 word1/word2 的位置即可。 ","date":"2015-09-02","objectID":"/leetcode/0245/:2:0","tags":null,"title":"0245：最短单词距离 III（★）","uri":"/leetcode/0245/"},{"categories":null,"content":"解答 def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -\u003e int: res, i1, i2 = inf, -inf, -inf for j, w in enumerate(wordsDict): if w==word1: res = min(res, j-i2) elif w==word2: res = min(res, j-i1) if w==word1: i1 = j if w==word2: i2 = j return res 128 ms ","date":"2015-09-02","objectID":"/leetcode/0245/:3:0","tags":null,"title":"0245：最短单词距离 III（★）","uri":"/leetcode/0245/"},{"categories":null,"content":" 力扣第 244 题 ","date":"2015-09-01","objectID":"/leetcode/0244/:0:0","tags":null,"title":"0244：最短单词距离 II（★）","uri":"/leetcode/0244/"},{"categories":null,"content":"题目 请设计一个类，使该类的构造函数能够接收一个字符串数组。然后再实现一个方法，该方法能够分别接收两个单词，并返回列表中这两个单词之间的最短距离。 实现 WordDistanc 类: WordDistance(String[] wordsDict) 用字符串数组 wordsDict 初始化对象。 int shortest(String word1, String word2) 返回数组 worddict 中 word1 和 word2 之间的最短距离。 示例 1: 输入: [\"WordDistance\", \"shortest\", \"shortest\"] [[[\"practice\", \"make","date":"2015-09-01","objectID":"/leetcode/0244/:1:0","tags":null,"title":"0244：最短单词距离 II（★）","uri":"/leetcode/0244/"},{"categories":null,"content":"分析 0243 升级版，需要多次查询，考虑将每个单词的位置列表预先保存下来，节省查询时间。 ","date":"2015-09-01","objectID":"/leetcode/0244/:2:0","tags":null,"title":"0244：最短单词距离 II（★）","uri":"/leetcode/0244/"},{"categories":null,"content":"解答 class WordDistance: def __init__(self, wordsDict: List[str]): self.d = defaultdict(list) for i, w in enumerate(wordsDict): self.d[w].append(i) def shortest(self, word1: str, word2: str) -\u003e int: return min(abs(i-j) for i in self.d[word1] for j in self.d[word2]) 68 ms ","date":"2015-09-01","objectID":"/leetcode/0244/:3:0","tags":null,"title":"0244：最短单词距离 II（★）","uri":"/leetcode/0244/"},{"categories":null,"content":" 力扣第 243 题 ","date":"2015-08-31","objectID":"/leetcode/0243/:0:0","tags":null,"title":"0243：最短单词距离","uri":"/leetcode/0243/"},{"categories":null,"content":"题目 给定一个字符串数组 wordDict 和两个已经存在于该数组中的不同的字符串 word1 和 word2 。返回列表中这两个单词之间的最短距离。 示例 1: 输入: wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"coding\", word2 = \"practice\" 输出: 3 示例 2: 输入: wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"codin","date":"2015-08-31","objectID":"/leetcode/0243/:1:0","tags":null,"title":"0243：最短单词距离","uri":"/leetcode/0243/"},{"categories":null,"content":"分析 遍历时记录上一个 word1/word2 的位置即可。 ","date":"2015-08-31","objectID":"/leetcode/0243/:2:0","tags":null,"title":"0243：最短单词距离","uri":"/leetcode/0243/"},{"categories":null,"content":"解答 def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -\u003e int: res, i1, i2 = inf, -inf, -inf for j, w in enumerate(wordsDict): if w == word1: res = min(res, j-i2) i1 = j elif w == word2: res = min(res, j-i1) i2 = j return res 36 ms ","date":"2015-08-31","objectID":"/leetcode/0243/:3:0","tags":null,"title":"0243：最短单词距离","uri":"/leetcode/0243/"},{"categories":null,"content":" 力扣第 242 题 ","date":"2015-08-30","objectID":"/leetcode/0242/:0:0","tags":null,"title":"0242：有效的字母异位词","uri":"/leetcode/0242/"},{"categories":null,"content":"题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 示例 1: 输入: s = \"anagram\", t = \"nagaram\" 输出: true 示例 2: 输入: s = \"rat\", t = \"car\" 输出: false 提示: 1 \u003c= s.length, t.length \u003c= 5 * 104 s 和 t 仅包含小写字母 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ ","date":"2015-08-30","objectID":"/leetcode/0242/:1:0","tags":null,"title":"0242：有效的字母异位词","uri":"/leetcode/0242/"},{"categories":null,"content":"分析 用排序或者计数即可。 ","date":"2015-08-30","objectID":"/leetcode/0242/:2:0","tags":null,"title":"0242：有效的字母异位词","uri":"/leetcode/0242/"},{"categories":null,"content":"解答 def isAnagram(self, s: str, t: str) -\u003e bool: return Counter(s)==Counter(t) 48 ms ","date":"2015-08-30","objectID":"/leetcode/0242/:3:0","tags":null,"title":"0242：有效的字母异位词","uri":"/leetcode/0242/"},{"categories":null,"content":" 力扣第 241 题 ","date":"2015-08-29","objectID":"/leetcode/0241/:0:0","tags":null,"title":"0241：为运算表达式设计优先级（★）","uri":"/leetcode/0241/"},{"categories":null,"content":"题目 给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。 生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。 示例 1： 输入：expression = \"2-1-1\" 输出：[0,2] 解释： ((2-1)-1) = 0 (2-(1-1)) = 2 示例 2： 输入：expression = \"2*3-4*5\" 输出：[-34,-14,-10,-10,10] 解释： (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3","date":"2015-08-29","objectID":"/leetcode/0241/:1:0","tags":null,"title":"0241：为运算表达式设计优先级（★）","uri":"/leetcode/0241/"},{"categories":null,"content":"分析 典型的区间 dp，按最后一步运算的运算符即可递归。 ","date":"2015-08-29","objectID":"/leetcode/0241/:2:0","tags":null,"title":"0241：为运算表达式设计优先级（★）","uri":"/leetcode/0241/"},{"categories":null,"content":"解答 def diffWaysToCompute(self, expression: str) -\u003e List[int]: @cache def dfs(s): res = [] for i, c in enumerate(s): if c in func: res.extend(func[c](x, y) for x in dfs(s[:i]) for y in dfs(s[i+1:])) return res if res else [int(s)] func = {'+': int.__add__, '-': int.__sub__, '*': int.__mul__} return d","date":"2015-08-29","objectID":"/leetcode/0241/:3:0","tags":null,"title":"0241：为运算表达式设计优先级（★）","uri":"/leetcode/0241/"},{"categories":null,"content":" 力扣第 240 题 ","date":"2015-08-28","objectID":"/leetcode/0240/:0:0","tags":null,"title":"0240：搜索二维矩阵 II（★）","uri":"/leetcode/0240/"},{"categories":null,"content":"题目 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 输出：true 示例 2： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]]","date":"2015-08-28","objectID":"/leetcode/0240/:1:0","tags":null,"title":"0240：搜索二维矩阵 II（★）","uri":"/leetcode/0240/"},{"categories":null,"content":"分析 ","date":"2015-08-28","objectID":"/leetcode/0240/:2:0","tags":null,"title":"0240：搜索二维矩阵 II（★）","uri":"/leetcode/0240/"},{"categories":null,"content":"#1 最简单的就是遍历每行，二分查找即可。 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: return any(target \u003c= row[-1] and row[bisect_left(row, target)]==target for row in matrix) 时间 $O(M*logN)$，156ms ","date":"2015-08-28","objectID":"/leetcode/0240/:2:1","tags":null,"title":"0240：搜索二维矩阵 II（★）","uri":"/leetcode/0240/"},{"categories":null,"content":"#2 上一方法只利用了每行升序的条件，没有利用到每列升序的条件。 先在第 i=m//2 行二分查找到第一个 \u003e=target 的位置 j，如果 matrix[i][j] != target，则： 位于矩形 (\u003c0, 0\u003e, \u003ci, j-1\u003e) 内的元素必然小于 target 位于矩形 (\u003ci, j\u003e, \u003cm-1, n-1\u003e) 内的元素必然大于 target 转为搜索矩形 (\u003ci+1, 0\u003e, \u003cm-1, j-1\u003e) 和矩形 (\u003c0, j\u003e, \u003ci-1, n-1\u003e) 搜索范围至少缩小了一半，递归搜索即可 ","date":"2015-08-28","objectID":"/leetcode/0240/:2:2","tags":null,"title":"0240：搜索二维矩阵 II（★）","uri":"/leetcode/0240/"},{"categories":null,"content":"解答 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: def help(x0, y0, x1, y1): if x0 \u003e x1 or y0 \u003e y1: return False i = x0 + (x1 - x0) // 2 j = bisect_left(matrix[i], target, y0, y1+1) if j \u003c= y1 and matrix[i][j] == target: return True return help(i+1, y0, x1, j-1) or help(x0, j, ","date":"2015-08-28","objectID":"/leetcode/0240/:3:0","tags":null,"title":"0240：搜索二维矩阵 II（★）","uri":"/leetcode/0240/"},{"categories":null,"content":"*附加 还有个巧妙的双指针方法。 方法一中每行二分查找 target 得到的位置 j 必然是递减的 初始令 \u003ci,j\u003e=\u003c0,n-1\u003e 遍历每一行，移动 j 直到 matrix[i][j]\u003c=target 即可 j 最多移动 n 步，总共最多 m+n 步即可完成 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: m, n = len(matrix), len(matrix[0]) i, j = 0, n-1 for i in range(m): while j \u003e= 0 and matrix[i][j] ","date":"2015-08-28","objectID":"/leetcode/0240/:4:0","tags":null,"title":"0240：搜索二维矩阵 II（★）","uri":"/leetcode/0240/"},{"categories":null,"content":" 力扣第 239 题 ","date":"2015-08-27","objectID":"/leetcode/0239/:0:0","tags":null,"title":"0239：滑动窗口最大值（★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"题目 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 1： 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6","date":"2015-08-27","objectID":"/leetcode/0239/:1:0","tags":null,"title":"0239：滑动窗口最大值（★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"分析 ","date":"2015-08-27","objectID":"/leetcode/0239/:2:0","tags":null,"title":"0239：滑动窗口最大值（★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"#1 考虑维护一个长度 k 的有序窗口，每轮取最大值即可。 窗口要进行插入、删除、取最大值的操作，考虑用有序集合 SortedList，都能在 O(logN) 时间内完成。 def maxSlidingWindow(self, nums: List[int], k: int) -\u003e List[int]: from sortedcontainers import SortedList res, sl = [], SortedList() for j, num in enumerate(nums): sl.add(num) if j \u003e= k: sl.remove(nums[j-k]) if j ","date":"2015-08-27","objectID":"/leetcode/0239/:2:1","tags":null,"title":"0239：滑动窗口最大值（★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"#2 有个巧妙的单调队列方法。 当窗口内存在 i\u003cj 且 nums[i]\u003c=nums[j] 时，去掉 nums[i] 不影响结果 去掉所有这种情况的元素，剩下的即是一个严格单调递减队列 每轮维护这个队列，队首即是最大值 注意当队首不在窗口内时，要删掉，因此队列还需保存下标 ","date":"2015-08-27","objectID":"/leetcode/0239/:2:2","tags":null,"title":"0239：滑动窗口最大值（★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"解答 def maxSlidingWindow(self, nums: List[int], k: int) -\u003e List[int]: res, Q = [], deque() for j, y in enumerate(nums): while Q and Q[-1][1] \u003c= y: Q.pop() Q.append((j, y)) if Q[0][0] == j-k: Q.popleft() if j \u003e= k-1: res.append(Q[0][1]) return res 时间复杂度 O(N)，396 ms ","date":"2015-08-27","objectID":"/leetcode/0239/:3:0","tags":null,"title":"0239：滑动窗口最大值（★★）","uri":"/leetcode/0239/"},{"categories":null,"content":" 力扣第 238 题 ","date":"2015-08-26","objectID":"/leetcode/0238/:0:0","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"题目 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 示例 1: 输入: nums = [1,2,3,4] 输出: [24,12,8,6] 示例 2: 输入: nums = [-1,1,0,-3,3] 输出: [0,0,9,0,0] 提示： 2 \u003c= nums.length \u003c= 105 -30 \u003c= nums[i] \u003c= 30 保证 数组 nu","date":"2015-08-26","objectID":"/leetcode/0238/:1:0","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"分析 ","date":"2015-08-26","objectID":"/leetcode/0238/:2:0","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"#1 要求不用除法，只能考虑 answer[i] 等于 nums[:i] 的连乘再乘以 nums[i+1:] 的连乘。 于是先遍历得到前缀乘和后缀乘，再相乘即可。 def productExceptSelf(self, nums: List[int]) -\u003e List[int]: pre = list(accumulate([1]+nums[:-1], mul)) suf = list(accumulate([1]+nums[:0:-1], mul))[::-1] return [a*b for a,b in zip(pre, suf)] 48 ms ","date":"2015-08-26","objectID":"/leetcode/0238/:2:1","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"#2 要求常数空间，可以用 answer 先保存前缀乘的信息，再遍历后缀乘并修改。 ","date":"2015-08-26","objectID":"/leetcode/0238/:2:2","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"解答 def productExceptSelf(self, nums: List[int]) -\u003e List[int]: ans, n = [1], len(nums) for i in range(n-1): ans.append(nums[i]*ans[-1]) suf = 1 for i in range(n-1, -1, -1): ans[i] *= suf suf *= nums[i] return ans 52 ms ","date":"2015-08-26","objectID":"/leetcode/0238/:3:0","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":" 力扣第 237 题 ","date":"2015-08-25","objectID":"/leetcode/0237/:0:0","tags":null,"title":"0237：删除链表中的节点（★）","uri":"/leetcode/0237/"},{"categories":null,"content":"题目 有一个单链表的 head，我们想删除它其中的一个节点 node。 给你一个需要删除的节点 node 。你将 无法访问 第一个节点 head。 链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。 删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是： 给定节点的值不应该存在于链表中。 链表中的节点数应该减少 1。 node 前面的所有值顺序相同。 node 后面的所有值顺序相同。 自定义测试： 对于输入，你应该提供整个链表 head 和要给出的节点 node。node 不应该是链表的最后一个节点，而应该是链表中的一个实际节点。 我们将构建链表，","date":"2015-08-25","objectID":"/leetcode/0237/:1:0","tags":null,"title":"0237：删除链表中的节点（★）","uri":"/leetcode/0237/"},{"categories":null,"content":"分析 要求原地操作，节点为非末尾节点。因此赋值为下一个节点，删除下一个节点即可。 ","date":"2015-08-25","objectID":"/leetcode/0237/:2:0","tags":null,"title":"0237：删除链表中的节点（★）","uri":"/leetcode/0237/"},{"categories":null,"content":"解答 def deleteNode(self, node): node.val = node.next.val node.next = node.next.next 48 ms ","date":"2015-08-25","objectID":"/leetcode/0237/:3:0","tags":null,"title":"0237：删除链表中的节点（★）","uri":"/leetcode/0237/"},{"categories":null,"content":" 力扣第 236 题 ","date":"2015-08-24","objectID":"/leetcode/0236/:0:0","tags":null,"title":"0236：二叉树的最近公共祖先（★）","uri":"/leetcode/0236/"},{"categories":null,"content":"题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 ","date":"2015-08-24","objectID":"/leetcode/0236/:1:0","tags":null,"title":"0236：二叉树的最近公共祖先（★）","uri":"/leetcode/0236/"},{"categories":null,"content":"分析 与 0235 的区别在于只是二叉树，并不有序。 依然可以考虑递归： 如果 root 等于 p 或 q，结果就是 root 如果 p、q 分别在 root 的左右子树，结果就是 root 如果 p、q 都在 root 的左子树或右子树，转为递归子问题 于是令 dfs(node) 代表 node 包含 p、q 的状态： 若 node 同时有 p、q，返回 p、q 的最近公共祖先 若 node 中有 p 或 q，返回 p 或 q 节点 若 node 中都没有，返回 None 即可递归。 ","date":"2015-08-24","objectID":"/leetcode/0236/:2:0","tags":null,"title":"0236：二叉树的最近公共祖先（★）","uri":"/leetcode/0236/"},{"categories":null,"content":"解答 def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u003e 'TreeNode': def dfs(node): if not node or node in [p, q]: return node l, r = dfs(node.left), dfs(node.right) return node if l and r else (l or r) return dfs(root) 56 ms ","date":"2015-08-24","objectID":"/leetcode/0236/:3:0","tags":null,"title":"0236：二叉树的最近公共祖先（★）","uri":"/leetcode/0236/"},{"categories":null,"content":" 力扣第 235 题 ","date":"2015-08-23","objectID":"/leetcode/0235/:0:0","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,","date":"2015-08-23","objectID":"/leetcode/0235/:1:0","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"分析 ","date":"2015-08-23","objectID":"/leetcode/0235/:2:0","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"#1 由 root 和 p、q 的大小关系可以分类讨论： 如果 root 比 p、q 的值都大，结果必然在 root 的左子树中。 如果 root 比 p、q 的值都小，结果必然在 root 的右子树中。 如果 root 在 p、q 的值之间，结果就是 root 于是可以递归解决。 def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u003e 'TreeNode': if root.val \u003e max(p.val, q.val): return self.lowestCommonAncesto","date":"2015-08-23","objectID":"/leetcode/0235/:2:1","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"#2 也可以写成迭代的形式。 ","date":"2015-08-23","objectID":"/leetcode/0235/:2:2","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"解答 def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u003e 'TreeNode': while root: if root.val \u003e max(p.val, q.val): root = root.left elif root.val \u003c min(p.val, q.val): root = root.right else: return root 92 ms ","date":"2015-08-23","objectID":"/leetcode/0235/:3:0","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":" 力扣第 234 题 ","date":"2015-08-22","objectID":"/leetcode/0234/:0:0","tags":null,"title":"0234：回文链表","uri":"/leetcode/0234/"},{"categories":null,"content":"题目 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 示例 1： 输入：head = [1,2,2,1] 输出：true 示例 2： 输入：head = [1,2] 输出：false 提示： 链表中节点数目在范围[1, 105] 内 0 \u003c= Node.val \u003c= 9 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ ","date":"2015-08-22","objectID":"/leetcode/0234/:1:0","tags":null,"title":"0234：回文链表","uri":"/leetcode/0234/"},{"categories":null,"content":"分析 ","date":"2015-08-22","objectID":"/leetcode/0234/:2:0","tags":null,"title":"0234：回文链表","uri":"/leetcode/0234/"},{"categories":null,"content":"#1 用额外空间的话很简单。 def isPalindrome(self, head: ListNode) -\u003e bool: tmp = [] while head: tmp.append(head.val) head = head.next return tmp == tmp[::-1] 780 ms ","date":"2015-08-22","objectID":"/leetcode/0234/:2:1","tags":null,"title":"0234：回文链表","uri":"/leetcode/0234/"},{"categories":null,"content":"#2 不用额外空间，考虑将链表均分为两部分，反转其中一部分，再遍历判断两部分的节点值序列是否相同。 找中点可以用快慢指针，而反转链表即是 0206 。 ","date":"2015-08-22","objectID":"/leetcode/0234/:2:2","tags":null,"title":"0234：回文链表","uri":"/leetcode/0234/"},{"categories":null,"content":"解答 def isPalindrome(self, head: ListNode) -\u003e bool: def reverseList(head): tail = head while tail and tail.next: tmp = tail.next tail.next = tmp.next tmp.next = head head = tmp return head dummy = slow = fast = ListNode(next=head) while fast and fast.next: slow, fast = slow.next, fast.next.next head2","date":"2015-08-22","objectID":"/leetcode/0234/:3:0","tags":null,"title":"0234：回文链表","uri":"/leetcode/0234/"},{"categories":null,"content":" 力扣第 233 题 ","date":"2015-08-21","objectID":"/leetcode/0233/:0:0","tags":null,"title":"0233：数字 1 的个数（★★）","uri":"/leetcode/0233/"},{"categories":null,"content":"题目 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 输入：n = 13 输出：6 示例 2： 输入：n = 0 输出：0 提示： 0 \u003c= n \u003c= 109 ","date":"2015-08-21","objectID":"/leetcode/0233/:1:0","tags":null,"title":"0233：数字 1 的个数（★★）","uri":"/leetcode/0233/"},{"categories":null,"content":"分析 求范围内数字满足某种性质的个数，典型的数位 dp 问题。 令 dfs(pos, st, bound) 代表某个状态下的结果： 遍历到 n 的第 pos 位 前面取的数中有 st 个 1 bound 代表前面取的数是否贴着 n 的上界 即可递归。 ","date":"2015-08-21","objectID":"/leetcode/0233/:2:0","tags":null,"title":"0233：数字 1 的个数（★★）","uri":"/leetcode/0233/"},{"categories":null,"content":"解答 def countDigitOne(self, n: int) -\u003e int: @cache def dfs(pos, st, bound): if pos == len(s): return st cur = int(s[pos]) up = cur if bound else 9 return sum(dfs(pos+1, st+(x==1), bound and x==cur) for x in range(up+1)) s = str(n) return dfs(0, 0, 1) 32 ms ","date":"2015-08-21","objectID":"/leetcode/0233/:3:0","tags":null,"title":"0233：数字 1 的个数（★★）","uri":"/leetcode/0233/"},{"categories":null,"content":" 力扣第 232 题 ","date":"2015-08-20","objectID":"/leetcode/0232/:0:0","tags":null,"title":"0232：用栈实现队列","uri":"/leetcode/0232/"},{"categories":null,"content":"题目 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 li","date":"2015-08-20","objectID":"/leetcode/0232/:1:0","tags":null,"title":"0232：用栈实现队列","uri":"/leetcode/0232/"},{"categories":null,"content":"分析 python 一般直接用 deque 作为队列。本题要求用栈实现，pop 时只能先把后面所有元素都出栈。 这里有个巧妙的想法，将出栈的元素依次保存到另一个栈 stack2 中，相当于反序保存了，后面要 pop 时若 stack2 还有元素，直接弹出即可。 ","date":"2015-08-20","objectID":"/leetcode/0232/:2:0","tags":null,"title":"0232：用栈实现队列","uri":"/leetcode/0232/"},{"categories":null,"content":"解答 class MyQueue: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, x: int) -\u003e None: self.stack1.append(x) def pop(self) -\u003e int: if self.stack2: return self.stack2.pop() for _ in range(len(self.stack1)-1): self.stack2.append(self.stack1.pop()) return self.stack1.pop() def peek(sel","date":"2015-08-20","objectID":"/leetcode/0232/:3:0","tags":null,"title":"0232：用栈实现队列","uri":"/leetcode/0232/"},{"categories":null,"content":" 力扣第 231 题 ","date":"2015-08-19","objectID":"/leetcode/0231/:0:0","tags":null,"title":"0231：2 的幂","uri":"/leetcode/0231/"},{"categories":null,"content":"题目 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 示例 1： 输入：n = 1 输出：true 解释：20 = 1 示例 2： 输入：n = 16 输出：true 解释：24 = 16 示例 3： 输入：n = 3 输出：false 示例 4： 输入：n = 4 输出：true 示例 5： 输入：n = 5 输出：false 提示： -231 \u003c= n \u003c= 231 - 1 进阶：你能够不使用循环/递归解决此问题吗？ ","date":"2015-08-19","objectID":"/leetcode/0231/:1:0","tags":null,"title":"0231：2 的幂","uri":"/leetcode/0231/"},{"categories":null,"content":"分析 n 是 2 的幂等价于 n 是正整数且 n 的二进制中只有一个 1。 那么用 n\u0026(n-1) 移除最后一个 1 即变为 0。或者用 n\u0026(-n) 提取出最后一个 1 后面的部分，即等于 n。 ","date":"2015-08-19","objectID":"/leetcode/0231/:2:0","tags":null,"title":"0231：2 的幂","uri":"/leetcode/0231/"},{"categories":null,"content":"解答 def isPowerOfTwo(self, n: int) -\u003e bool: return n\u003e0 and n\u0026(n-1)==0 40 ms ","date":"2015-08-19","objectID":"/leetcode/0231/:3:0","tags":null,"title":"0231：2 的幂","uri":"/leetcode/0231/"},{"categories":null,"content":"*附加 还有个巧妙的方法。n 是 2 的幂等价于 n 是正整数且 n 被 2^31 整除。 def isPowerOfTwo(self, n: int) -\u003e bool: return n\u003e0 and (1\u003c\u003c31)%n==0 32 ms ","date":"2015-08-19","objectID":"/leetcode/0231/:4:0","tags":null,"title":"0231：2 的幂","uri":"/leetcode/0231/"},{"categories":null,"content":" 力扣第 230 题 ","date":"2015-08-18","objectID":"/leetcode/0230/:0:0","tags":null,"title":"0230：二叉搜索树中第K小的元素（★）","uri":"/leetcode/0230/"},{"categories":null,"content":"题目 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。 示例 1： 输入：root = [3,1,4,null,2], k = 1 输出：1 示例 2： 输入：root = [5,3,6,2,4,null,null,1], k = 3 输出：3 提示： 树中的节点数为 n 。 1 \u003c= k \u003c= n \u003c= 104 0 \u003c= Node.val \u003c= 104 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？ ","date":"2015-08-18","objectID":"/leetcode/0230/:1:0","tags":null,"title":"0230：二叉搜索树中第K小的元素（★）","uri":"/leetcode/0230/"},{"categories":null,"content":"分析 中序遍历到第 k 个数即可。 ","date":"2015-08-18","objectID":"/leetcode/0230/:2:0","tags":null,"title":"0230：二叉搜索树中第K小的元素（★）","uri":"/leetcode/0230/"},{"categories":null,"content":"解答 def kthSmallest(self, root: TreeNode, k: int) -\u003e int: stack = [root] while stack: node = stack.pop() if isinstance(node, int): k -= 1 if k == 0: return node elif node: stack.extend([node.right, node.val, node.left] 52 ms ","date":"2015-08-18","objectID":"/leetcode/0230/:3:0","tags":null,"title":"0230：二叉搜索树中第K小的元素（★）","uri":"/leetcode/0230/"},{"categories":null,"content":" 力扣第 229 题 ","date":"2015-08-17","objectID":"/leetcode/0229/:0:0","tags":null,"title":"0229：多数元素 II（★）","uri":"/leetcode/0229/"},{"categories":null,"content":"题目 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 示例 1： 输入：nums = [3,2,3] 输出：[3] 示例 2： 输入：nums = [1] 输出：[1] 示例 3： 输入：nums = [1,2] 输出：[1,2] 提示： 1 \u003c= nums.length \u003c= 5 * 104 -109 \u003c= nums[i] \u003c= 109 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。 ","date":"2015-08-17","objectID":"/leetcode/0229/:1:0","tags":null,"title":"0229：多数元素 II（★）","uri":"/leetcode/0229/"},{"categories":null,"content":"分析 0169 升级版，可以直接计数，也可以考虑摩尔投票法。 在 nums 中任意消除三个不同的数直到剩下两种数或一种数 假如 nums 中存在超过 ⌊ n/3 ⌋ 次的元素，那么该元素必然会留下来 因此检查最终留下来的数是否符合即可 这可以推广到求超过 ⌊ n/k ⌋ 次的元素。 ","date":"2015-08-17","objectID":"/leetcode/0229/:2:0","tags":null,"title":"0229：多数元素 II（★）","uri":"/leetcode/0229/"},{"categories":null,"content":"解答 def majorityElement(self, nums: List[int]) -\u003e List[int]: d = defaultdict(int) for num in nums: d[num] += 1 if len(d)==3: for x in list(d): d[x] -= 1 if d[x] == 0: del d[x] return [x for x in d if nums.count(x)\u003elen(nums)//3] 52 ms ","date":"2015-08-17","objectID":"/leetcode/0229/:3:0","tags":null,"title":"0229：多数元素 II（★）","uri":"/leetcode/0229/"},{"categories":null,"content":" 力扣第 228 题 ","date":"2015-08-16","objectID":"/leetcode/0228/:0:0","tags":null,"title":"0228：汇总区间","uri":"/leetcode/0228/"},{"categories":null,"content":"题目 给定一个 无重复元素 的 有序 整数数组 nums 。 返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。 列表中的每个区间范围 [a,b] 应该按如下格式输出： \"a-\u003eb\" ，如果 a != b \"a\" ，如果 a == b 示例 1： 输入：nums = [0,1,2,4,5,7] 输出：[\"0-\u003e2\",\"4-\u003e5\",\"7\"] 解释：区间范围是： [0,2] --\u003e \"0-\u003e2\" [4,5] --\u003e \"4-\u003e5\" [7,7] --\u003e \"7\" 示例 2： 输入：","date":"2015-08-16","objectID":"/leetcode/0228/:1:0","tags":null,"title":"0228：汇总区间","uri":"/leetcode/0228/"},{"categories":null,"content":"分析 遍历数组，记录连续区间的首尾即可。 ","date":"2015-08-16","objectID":"/leetcode/0228/:2:0","tags":null,"title":"0228：汇总区间","uri":"/leetcode/0228/"},{"categories":null,"content":"解答 def summaryRanges(self, nums: List[int]) -\u003e List[str]: res, i = [], 0 for j, num in enumerate(nums): if j==len(nums)-1 or nums[j+1] != num+1: res.append('%d-\u003e%d' % (nums[i], num) if j\u003ei else str(num)) i = j+1 return res 32 ms ","date":"2015-08-16","objectID":"/leetcode/0228/:3:0","tags":null,"title":"0228：汇总区间","uri":"/leetcode/0228/"},{"categories":null,"content":" 力扣第 227 题 ","date":"2015-08-15","objectID":"/leetcode/0227/:0:0","tags":null,"title":"0227：基本计算器 II（★）","uri":"/leetcode/0227/"},{"categories":null,"content":"题目 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 整数除法仅保留整数部分。 你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。 注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。 示例 1： 输入：s = \"3+2*2\" 输出：7 示例 2： 输入：s = \" 3/2 \" 输出：1 示例 3： 输入：s = \" 3+5 / 2 \" 输出：5 提示： 1 \u003c= s.length \u003c= 3 * 105 s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开 s 表示一","date":"2015-08-15","objectID":"/leetcode/0227/:1:0","tags":null,"title":"0227：基本计算器 II（★）","uri":"/leetcode/0227/"},{"categories":null,"content":"分析 ","date":"2015-08-15","objectID":"/leetcode/0227/:2:0","tags":null,"title":"0227：基本计算器 II（★）","uri":"/leetcode/0227/"},{"categories":null,"content":"#1 本题不含括号和符号位，所以将 ‘/’ 替换为 ‘//’ 就可以直接调用 eval 了。 def calculate(self, s: str) -\u003e int: return eval(s.replace('/', '//')) 64 ms ","date":"2015-08-15","objectID":"/leetcode/0227/:2:1","tags":null,"title":"0227：基本计算器 II（★）","uri":"/leetcode/0227/"},{"categories":null,"content":"#2 也可以自己实现 eval，有个通用的方法： 用一个栈 stack 维护数字，一个栈 op 维护运算符 遍历到某个运算符时，将前面优先级更高的运算符从 op 弹出，先运算了 比如遇到 ‘+-’ 时，可以将 op 栈顶的 ‘+-*/’ 先运算了 注意最终栈 op 非空时，还需要弹出运算。 更方便的方法是末尾添加优先级最低的运算符，让所有运算符都出栈。 ","date":"2015-08-15","objectID":"/leetcode/0227/:2:2","tags":null,"title":"0227：基本计算器 II（★）","uri":"/leetcode/0227/"},{"categories":null,"content":"解答 def calculate(self, s: str) -\u003e int: func = {'+': int.__add__, '-': int.__sub__, '*': int.__mul__, '/': lambda x, y: x//y} pro = dict(zip('+-*/', [1, 1, 2, 2])) stack, ops = [], [] for num, op in re.findall(r'(\\d+)|([-+/*])', s+'+'): if num: stack.append(int(num)) else: while ops and pro[ops[-1]] ","date":"2015-08-15","objectID":"/leetcode/0227/:3:0","tags":null,"title":"0227：基本计算器 II（★）","uri":"/leetcode/0227/"},{"categories":null,"content":" 力扣第 226 题 ","date":"2015-08-14","objectID":"/leetcode/0226/:0:0","tags":null,"title":"0226：翻转二叉树","uri":"/leetcode/0226/"},{"categories":null,"content":"题目 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 示例 2： 输入：root = [2,1,3] 输出：[2,3,1] 示例 3： 输入：root = [] 输出：[] 提示： 树中节点数目范围在 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-08-14","objectID":"/leetcode/0226/:1:0","tags":null,"title":"0226：翻转二叉树","uri":"/leetcode/0226/"},{"categories":null,"content":"分析 递归翻转即可。 ","date":"2015-08-14","objectID":"/leetcode/0226/:2:0","tags":null,"title":"0226：翻转二叉树","uri":"/leetcode/0226/"},{"categories":null,"content":"解答 def invertTree(self, root: TreeNode) -\u003e TreeNode: if not root: return None root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root 36 ms ","date":"2015-08-14","objectID":"/leetcode/0226/:3:0","tags":null,"title":"0226：翻转二叉树","uri":"/leetcode/0226/"},{"categories":null,"content":" 力扣第 225 题 ","date":"2015-08-13","objectID":"/leetcode/0225/:0:0","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"题目 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list ","date":"2015-08-13","objectID":"/leetcode/0225/:1:0","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"分析 ","date":"2015-08-13","objectID":"/leetcode/0225/:2:0","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"#1 python 一般直接用 list 作为栈。 class MyStack: def __init__(self): self.stack = [] def push(self, x: int) -\u003e None: self.stack.append(x) def pop(self) -\u003e int: return self.stack.pop() def top(self) -\u003e int: return self.stack[-1] def empty(self) -\u003e bool: return not self.stack 40 ms ","date":"2015-08-13","objectID":"/leetcode/0225/:2:1","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"#2 要求用队列实现，那么 pop 时只能把前面所有元素都出队再加在末尾。 ","date":"2015-08-13","objectID":"/leetcode/0225/:2:2","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"解答 class MyStack: def __init__(self): self.queue = deque() def push(self, x: int) -\u003e None: self.queue.append(x) def pop(self) -\u003e int: for _ in range(len(self.queue)-1): self.queue.append(self.queue.popleft()) return self.queue.popleft() def top(self) -\u003e int: return self.queue[-1] def empty(self) -\u003e ","date":"2015-08-13","objectID":"/leetcode/0225/:3:0","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":" 力扣第 224 题 ","date":"2015-08-12","objectID":"/leetcode/0224/:0:0","tags":null,"title":"0224：基本计算器（★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"题目 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。 示例 1： 输入：s = \"1 + 1\" 输出：2 示例 2： 输入：s = \" 2-1 + 2 \" 输出：3 示例 3： 输入：s = \"(1+(4+5+2)-3)+(6+8)\" 输出：23 提示： 1 \u003c= s.length \u003c= 3 * 105 s 由数字、'+'、'-'、'('、')'、和 ' ' 组成 s 表示一个有效的表达式 '+' 不能用作一元运算(例如， \"+1\" 和 \"+(2 + 3)\" 无效) '-' 可以用作一元运","date":"2015-08-12","objectID":"/leetcode/0224/:1:0","tags":null,"title":"0224：基本计算器（★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"分析 ","date":"2015-08-12","objectID":"/leetcode/0224/:2:0","tags":null,"title":"0224：基本计算器（★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"#1 python 的 eval 最多只能处理 200 层括号，因此考虑用栈模拟递归过程， 先处理括号内并转为一个值。括号内的计算就可以直接用 eval 了。 def calculate(self, s: str) -\u003e int: stack = [''] for char in s: if char == '(': stack.append('') elif char == ')': x = eval(stack.pop()) stack[-1] += str(x) elif char: stack[-1] += char return eval(stack[0]) 100 ms ","date":"2015-08-12","objectID":"/leetcode/0224/:2:1","tags":null,"title":"0224：基本计算器（★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"#2 也可以自己实现 eval。本题只有加减号，看作是带正负号的数之和即可。 注意当括号内结果为负数，且括号前为负号时，会出现 ‘- -’ 的情况，提前替换为 ‘+’ 即可。 ","date":"2015-08-12","objectID":"/leetcode/0224/:2:2","tags":null,"title":"0224：基本计算器（★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"解答 def calculate(self, s: str) -\u003e int: def cal(ss): return sum(map(int, re.findall('[-+]?\\d+', ss.replace('--', '+')))) stack = [''] for char in s: if char == '(': stack.append('') elif char == ')': x = cal(stack.pop()) stack[-1] += str(x) elif char != ' ': stack[-1] += char return cal(stack[0]) 84 ","date":"2015-08-12","objectID":"/leetcode/0224/:3:0","tags":null,"title":"0224：基本计算器（★★）","uri":"/leetcode/0224/"},{"categories":null,"content":" 力扣第 223 题 ","date":"2015-08-11","objectID":"/leetcode/0223/:0:0","tags":null,"title":"0223：矩形面积（★）","uri":"/leetcode/0223/"},{"categories":null,"content":"题目 给你 二维 平面上两个 由直线构成且边与坐标轴平行/垂直 的矩形，请你计算并返回两个矩形覆盖的总面积。 每个矩形由其 左下 顶点和 右上 顶点坐标表示： 第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。 第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。 示例 1： 输入：ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2 输出：45 示例 2： 输入：ax1 = -2, ay1 = -2, ax2 = 2, ay2 = ","date":"2015-08-11","objectID":"/leetcode/0223/:1:0","tags":null,"title":"0223：矩形面积（★）","uri":"/leetcode/0223/"},{"categories":null,"content":"分析 用两个矩形面积的和去掉重叠面积即可： 若有重叠部分，宽必然等于 [ax1, ax2] 和 [bx1, bx2] 的重叠长度，即 $$min(ax2, bx2)-max(ax1, bx1)$$ 高也同理。 ","date":"2015-08-11","objectID":"/leetcode/0223/:2:0","tags":null,"title":"0223：矩形面积（★）","uri":"/leetcode/0223/"},{"categories":null,"content":"解答 def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -\u003e int: x = max(0, min(ax2, bx2)-max(ax1, bx1)) y = max(0, min(ay2, by2)-max(ay1, by1)) return (ax2-ax1)*(ay2-ay1)+(bx2-bx1)*(by2-by1)-x*y 52 ms ","date":"2015-08-11","objectID":"/leetcode/0223/:3:0","tags":null,"title":"0223：矩形面积（★）","uri":"/leetcode/0223/"},{"categories":null,"content":" 力扣第 222 题 ","date":"2015-08-10","objectID":"/leetcode/0222/:0:0","tags":null,"title":"0222：完全二叉树的节点个数（★）","uri":"/leetcode/0222/"},{"categories":null,"content":"题目 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例 1： 输入：root = [1,2,3,4,5,6] 输出：6 示例 2： 输入：root = [] 输出：0 示例 3： 输入：root = [1] 输出：1 提示： 树中节点的数目范围是[0, 5 * 104] 0 \u003c= Node.val \u003c= 5 * 104 题目数据保证输入的树是 完全二叉树 进阶：遍历树来统计","date":"2015-08-10","objectID":"/leetcode/0222/:1:0","tags":null,"title":"0222：完全二叉树的节点个数（★）","uri":"/leetcode/0222/"},{"categories":null,"content":"分析 递归很简单。 ","date":"2015-08-10","objectID":"/leetcode/0222/:2:0","tags":null,"title":"0222：完全二叉树的节点个数（★）","uri":"/leetcode/0222/"},{"categories":null,"content":"解答 def countNodes(self, root: TreeNode) -\u003e int: return 0 if not root else 1 + self.countNodes(root.left)+self.countNodes(root.right) 64 ms ","date":"2015-08-10","objectID":"/leetcode/0222/:3:0","tags":null,"title":"0222：完全二叉树的节点个数（★）","uri":"/leetcode/0222/"},{"categories":null,"content":"*附加 利用完全二叉树的特性，还有个巧妙的二分查找方法。 先遍历到最底层最左边的节点，得到高度 h 该完全二叉树的节点数 x 必然满足 x\u003c=2^(h+1)-1 以节点数 x 为界，序号 [1, x] 的节点都存在，序号 [x+1, M] 都不存在 因此可以在 [0， 2^(h+1)-1] 范围内二分查找 x 判断序号 y 是否存在，可以按 y 的二进制遍历树 def countNodes(self, root: TreeNode) -\u003e int: def check(x): p = root for bit in bin(x)[3:]: p = p.left if bit == '0' el","date":"2015-08-10","objectID":"/leetcode/0222/:4:0","tags":null,"title":"0222：完全二叉树的节点个数（★）","uri":"/leetcode/0222/"},{"categories":null,"content":" 力扣第 221 题 ","date":"2015-08-09","objectID":"/leetcode/0221/:0:0","tags":null,"title":"0221：最大正方形（★）","uri":"/leetcode/0221/"},{"categories":null,"content":"题目 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。 示例 1： 输入：matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] 输出：4 示例 2： 输入：matrix = [[\"0\",\"1\"],[\"1\",\"0\"]] 输出：1 示例 3： 输入：matrix = [[\"0\"]] 输出：0 提示： m == matrix.length n == matrix[i].length 1 \u003c= m, n \u003c= 3","date":"2015-08-09","objectID":"/leetcode/0221/:1:0","tags":null,"title":"0221：最大正方形（★）","uri":"/leetcode/0221/"},{"categories":null,"content":"分析 ","date":"2015-08-09","objectID":"/leetcode/0221/:2:0","tags":null,"title":"0221：最大正方形（★）","uri":"/leetcode/0221/"},{"categories":null,"content":"#1 本题是 0085 的子问题，修改一下即可。 def maximalSquare(self, matrix: List[List[str]]) -\u003e int: def cal(H): res, stack = 0, [] for j, y in enumerate(H+[0]): while stack and stack[-1][1] \u003e= y: i, x = stack.pop() left = stack[-1][0] if stack else -1 h = min(j-left-1, x) res = max(res, h*h) stack.append((j, y)) retu","date":"2015-08-09","objectID":"/leetcode/0221/:2:1","tags":null,"title":"0221：最大正方形（★）","uri":"/leetcode/0221/"},{"categories":null,"content":"#2 还有个巧妙的 dp 方法： 令 dp[i][j] 代表以 (i,j) 为右下顶点的最大正方形的边长，当 matrix[i][j] == ‘1’ 时： $$dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])$$ 证明： 该值显然是成立的 假设 dp[i][j]=x，则必然有 dp[i][j-1] \u003e=x-1，即 x \u003c= 1+dp[i][j-1] 同理可得 x \u003c= 1 + dp[i-1][j-1]; x\u003c=1+dp[i-1][j] 故 dp[i][j] 等于该值 可以用滚动数组优化空间。 ","date":"2015-08-09","objectID":"/leetcode/0221/:2:2","tags":null,"title":"0221：最大正方形（★）","uri":"/leetcode/0221/"},{"categories":null,"content":"解答 def maximalSquare(self, matrix: List[List[str]]) -\u003e int: m, n = len(matrix), len(matrix[0]) side, dp = 0, [0]*n for i in range(m): new = [0]*n for j in range(n): if matrix[i][j] == '1': new[j] = 1 if i==0 or j==0 else 1 + min(dp[j-1], dp[j], new[j-1]) side = max(side, new[j]) dp = new return side","date":"2015-08-09","objectID":"/leetcode/0221/:3:0","tags":null,"title":"0221：最大正方形（★）","uri":"/leetcode/0221/"},{"categories":null,"content":" 力扣第 220 题 ","date":"2015-08-08","objectID":"/leetcode/0220/:0:0","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) \u003c= t ，同时又满足 abs(i - j) \u003c= k 。 如果存在则返回 true，不存在返回 false。 示例 1： 输入：nums = [1,2,3,1], k = 3, t = 0 输出：true 示例 2： 输入：nums = [1,0,1,1], k = 1, t = 2 输出：true 示例 3： 输入：nums = [1,5,9,1,5,9], k = 2, t = 3 输出：false 提示： 0 \u003c= nums.len","date":"2015-08-08","objectID":"/leetcode/0220/:1:0","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"分析 ","date":"2015-08-08","objectID":"/leetcode/0220/:2:0","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"#1 0219 升级版，要找的不是相同数而是一个范围内的数了。 考虑维护窗口 [j-k, j-1] 有序，即可二分查找离 nums[j] 最近的数 有序窗口要进行插入、删除、查找操作，考虑用有序集合 SortedList 实现 def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -\u003e bool: from sortedcontainers import SortedList sl = SortedList() for j, num in enumerate(nums): if j \u003e k: sl.re","date":"2015-08-08","objectID":"/leetcode/0220/:2:1","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"#2 还有个巧妙的桶排序方法。 桶的 size 设为 t+1，维护窗口 [j-k, j-1] 的桶状态。 符合条件的数和 nums[j] 要么在一个桶，要么在相邻桶 如果某个桶有两个元素，显然已经符合了 因此每轮最多与三个桶中的唯一元素比较，时间复杂度 O(N) ","date":"2015-08-08","objectID":"/leetcode/0220/:2:2","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"解答 def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -\u003e bool: bucket, size = {}, t + 1 for j, num in enumerate(nums): if j \u003e k: bucket.pop(nums[j - k - 1] // size) key = num // size if any(kk in bucket and abs(bucket[kk]-num)\u003c=t for kk in [key, key-1, key+1]): return True buck","date":"2015-08-08","objectID":"/leetcode/0220/:3:0","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":" 力扣第 219 题 ","date":"2015-08-07","objectID":"/leetcode/0219/:0:0","tags":null,"title":"0219：存在重复元素 II","uri":"/leetcode/0219/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) \u003c= k 。如果存在，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [1,2,3,1], k = 3 输出：true 示例 2： 输入：nums = [1,0,1,1], k = 1 输出：true 示例 3： 输入：nums = [1,2,3,1,2,3], k = 2 输出：false 提示： 1 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 0","date":"2015-08-07","objectID":"/leetcode/0219/:1:0","tags":null,"title":"0219：存在重复元素 II","uri":"/leetcode/0219/"},{"categories":null,"content":"分析 典型的哈希表，边遍历边存储元素位置，并判断上一个位置是否在范围内即可。 ","date":"2015-08-07","objectID":"/leetcode/0219/:2:0","tags":null,"title":"0219：存在重复元素 II","uri":"/leetcode/0219/"},{"categories":null,"content":"解答 def containsNearbyDuplicate(self, nums: List[int], k: int) -\u003e bool: d = {} for i, num in enumerate(nums): if num in d and i-d[num] \u003c= k: return True d[num] = i return False 40 ms ","date":"2015-08-07","objectID":"/leetcode/0219/:3:0","tags":null,"title":"0219：存在重复元素 II","uri":"/leetcode/0219/"},{"categories":null,"content":" 力扣第 218 题 ","date":"2015-08-06","objectID":"/leetcode/0218/:0:0","tags":null,"title":"0218：天际线问题（★★）","uri":"/leetcode/0218/"},{"categories":null,"content":"题目 城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。 每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示： lefti 是第 i 座建筑物左边缘的 x 坐标。 righti 是第 i 座建筑物右边缘的 x 坐标。 heighti 是第 i 座建筑物的高度。 你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。 天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y","date":"2015-08-06","objectID":"/leetcode/0218/:1:0","tags":null,"title":"0218：天际线问题（★★）","uri":"/leetcode/0218/"},{"categories":null,"content":"分析 典型的扫描线问题： 显然只有边缘处才可能改变高度，考虑按顺序遍历所有边缘坐标 x 遍历 x 时，维护还没有掠过的建筑物高度集合 H，max(H) 就是对应的轮廓高度 max(H) 和上一个关键点高度比较，即可判断高度是否改变 具体实现时，H 要进行插入、删除、取最大值的操作，考虑用有序集合 SortedList，都能在 O(logN) 时间内完成。 ","date":"2015-08-06","objectID":"/leetcode/0218/:2:0","tags":null,"title":"0218：天际线问题（★★）","uri":"/leetcode/0218/"},{"categories":null,"content":"解答 def getSkyline(self, buildings: List[List[int]]) -\u003e List[List[int]]: from sortedcontainers import SortedList d = defaultdict(list) for left, right, h in buildings: d[left].append((h, 1)) d[right].append((h, 0)) res, H = [], SortedList() for x in sorted(d): for h, flag in d[x]: H.add(h) if flag el","date":"2015-08-06","objectID":"/leetcode/0218/:3:0","tags":null,"title":"0218：天际线问题（★★）","uri":"/leetcode/0218/"},{"categories":null,"content":" 力扣第 217 题 ","date":"2015-08-05","objectID":"/leetcode/0217/:0:0","tags":null,"title":"0217：存在重复元素","uri":"/leetcode/0217/"},{"categories":null,"content":"题目 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 示例 1： 输入：nums = [1,2,3,1] 输出：true 示例 2： 输入：nums = [1,2,3,4] 输出：false 示例 3： 输入：nums = [1,1,1,3,3,4,3,2,4,2] 输出：true 提示： 1 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 ","date":"2015-08-05","objectID":"/leetcode/0217/:1:0","tags":null,"title":"0217：存在重复元素","uri":"/leetcode/0217/"},{"categories":null,"content":"分析 典型的哈希应用，判断去重后长度是否减小即可。 ","date":"2015-08-05","objectID":"/leetcode/0217/:2:0","tags":null,"title":"0217：存在重复元素","uri":"/leetcode/0217/"},{"categories":null,"content":"解答 def containsDuplicate(self, nums: List[int]) -\u003e bool: return len(nums) != len(set(nums)) 44 ms ","date":"2015-08-05","objectID":"/leetcode/0217/:3:0","tags":null,"title":"0217：存在重复元素","uri":"/leetcode/0217/"},{"categories":null,"content":" 力扣第 216 题 ","date":"2015-08-04","objectID":"/leetcode/0216/:0:0","tags":null,"title":"0216：组合总和 III（★）","uri":"/leetcode/0216/"},{"categories":null,"content":"题目 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] 解释: 1 + 2 + 4 = 7 没有其他符合的组合了。 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解释: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 没有其他符合的组合了。 示例 3: 输入: k = 4, n =","date":"2015-08-04","objectID":"/leetcode/0216/:1:0","tags":null,"title":"0216：组合总和 III（★）","uri":"/leetcode/0216/"},{"categories":null,"content":"分析 类似 0077 ，添加和的限制即可。 ","date":"2015-08-04","objectID":"/leetcode/0216/:2:0","tags":null,"title":"0216：组合总和 III（★）","uri":"/leetcode/0216/"},{"categories":null,"content":"解答 def combinationSum3(self, k: int, n: int) -\u003e List[List[int]]: return [A for A in combinations(range(1, 10), k) if sum(A) == n] 32 ms ","date":"2015-08-04","objectID":"/leetcode/0216/:3:0","tags":null,"title":"0216：组合总和 III（★）","uri":"/leetcode/0216/"},{"categories":null,"content":" 力扣第 215 题 ","date":"2015-08-03","objectID":"/leetcode/0215/:0:0","tags":null,"title":"0215：数组中的第K个最大元素（★）","uri":"/leetcode/0215/"},{"categories":null,"content":"题目 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1: 输入: [3,2,1,5,6,4], k = 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6], k = 4 输出: 4 提示： 1 \u003c= k \u003c= nums.length \u003c= 105 -104 \u003c= nums[i] \u003c= 104 ","date":"2015-08-03","objectID":"/leetcode/0215/:1:0","tags":null,"title":"0215：数组中的第K个最大元素（★）","uri":"/leetcode/0215/"},{"categories":null,"content":"分析 直接调用排序或者堆即可。 ","date":"2015-08-03","objectID":"/leetcode/0215/:2:0","tags":null,"title":"0215：数组中的第K个最大元素（★）","uri":"/leetcode/0215/"},{"categories":null,"content":"解答 def findKthLargest(self, nums: List[int], k: int) -\u003e int: return nlargest(k, nums)[-1] 32 ms ","date":"2015-08-03","objectID":"/leetcode/0215/:3:0","tags":null,"title":"0215：数组中的第K个最大元素（★）","uri":"/leetcode/0215/"},{"categories":null,"content":"*附加 借助快排的思想可以在 O(N) 时间内完成。 随机取一个数 pivot，按照快排的方法将 pivot 调整到位置 i，使得左边都 \u003c=pivot，右边都 \u003e=pivot。 假如 i == n-k ， pivot 即为所求 假如 i \u003c n-k ， 转为求 nums[i+1:] 中第 k 大的数 假如 i \u003e n-k ， 转为求 nums[:i] 中第 k-(n-i) 大的数 每次只递归一边，时间复杂度 O(N)。 def findKthLargest(self, nums: List[int], k: int) -\u003e int: def quick(l, r, k): x = rando","date":"2015-08-03","objectID":"/leetcode/0215/:4:0","tags":null,"title":"0215：数组中的第K个最大元素（★）","uri":"/leetcode/0215/"},{"categories":null,"content":" 力扣第 214 题 ","date":"2015-08-02","objectID":"/leetcode/0214/:0:0","tags":null,"title":"0214：最短回文串（★★）","uri":"/leetcode/0214/"},{"categories":null,"content":"题目 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 示例 1： 输入：s = \"aacecaaa\" 输出：\"aaacecaaa\" 示例 2： 输入：s = \"abcd\" 输出：\"dcbabcd\" 提示： 0 \u003c= s.length \u003c= 5 * 104 s 仅由小写英文字母组成 ","date":"2015-08-02","objectID":"/leetcode/0214/:1:0","tags":null,"title":"0214：最短回文串（★★）","uri":"/leetcode/0214/"},{"categories":null,"content":"分析 观察可知问题等价于找到 s 最长的前缀回文子串 s[:i]，然后在前面添加 s[i:][::-1] 即可。 与回文相关，首先想到 Manacher 算法。Manacher 算法能在 O(N) 时间内得到每个位置 i 的臂长， 那么找最后一个 i 满足其臂长等于 i 即可。 ","date":"2015-08-02","objectID":"/leetcode/0214/:2:0","tags":null,"title":"0214：最短回文串（★★）","uri":"/leetcode/0214/"},{"categories":null,"content":"解答 def shortestPalindrome(self, s: str) -\u003e str: def expand(l, r): while l \u003e 0 and r \u003c len(ss) - 1 and ss[l - 1] == ss[r + 1]: l -= 1 r += 1 return (r - l) // 2 pos, ss = 0, '#' + '#'.join(s) + '#' A, center, right = [], 0, 0 for i in range(len(ss)//2+1): min_arm = min(A[2*center-i], right-i) if righ","date":"2015-08-02","objectID":"/leetcode/0214/:3:0","tags":null,"title":"0214：最短回文串（★★）","uri":"/leetcode/0214/"},{"categories":null,"content":"*附加 还有个很巧妙的 KMP 解法。 若 s[:i] 是回文子串，那么 s[::-1][-i:] 也是回文子串，ss[::-1][-i:] 和 s[:i] 相同。 因此将 s 作为模式串在 s[::-1] 中用 KMP 匹配，最终匹配到的 s[:j] 即为最长的前缀回文子串。 def shortestPalindrome(self, s: str) -\u003e str: nxt, j, n = [-1], -1, len(s) for i in range(n): while j \u003e= 0 and s[i] != s[j]: j = nxt[j] j += 1 nxt.append(j) t, j","date":"2015-08-02","objectID":"/leetcode/0214/:4:0","tags":null,"title":"0214：最短回文串（★★）","uri":"/leetcode/0214/"},{"categories":null,"content":" 力扣第 213 题 ","date":"2015-08-01","objectID":"/leetcode/0213/:0:0","tags":null,"title":"0213：打家劫舍 II（★）","uri":"/leetcode/0213/"},{"categories":null,"content":"题目 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 输入：nums = [1,2,3,1] 输出：4 解释：你可以先","date":"2015-08-01","objectID":"/leetcode/0213/:1:0","tags":null,"title":"0213：打家劫舍 II（★）","uri":"/leetcode/0213/"},{"categories":null,"content":"分析 0198 升级版，只是第一个房屋和最后一个房屋也不能同时偷了， 按偷不偷第一个房屋分类即可。 ","date":"2015-08-01","objectID":"/leetcode/0213/:2:0","tags":null,"title":"0213：打家劫舍 II（★）","uri":"/leetcode/0213/"},{"categories":null,"content":"解答 def rob(self, nums: List[int]) -\u003e int: def dfs(nums): a, b = 0, 0 for num in nums: a, b = b, max(num + a, b) return b return max(dfs(nums[1:]), nums[0]+dfs(nums[2:-1])) 32 ms ","date":"2015-08-01","objectID":"/leetcode/0213/:3:0","tags":null,"title":"0213：打家劫舍 II（★）","uri":"/leetcode/0213/"},{"categories":null,"content":" 力扣第 212 题 ","date":"2015-07-31","objectID":"/leetcode/0212/:0:0","tags":null,"title":"0212：单词搜索 II（★★）","uri":"/leetcode/0212/"},{"categories":null,"content":"题目 给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。 单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。 示例 1： 输入：board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"] 输出：[\"eat\",\"oath\"] 示例 2： 输入：boa","date":"2015-07-31","objectID":"/leetcode/0212/:1:0","tags":null,"title":"0212：单词搜索 II（★★）","uri":"/leetcode/0212/"},{"categories":null,"content":"分析 0079 的升级版，变成搜索多个单词。 单词数量太多，一个个搜会超时，考虑怎么同时搜索： 只要搜索路径是某一个单词的前缀，就可以继续搜索 否则，可以直接跳出 当搜索路径匹配某一个单词时，添加到结果中即可 于是想到用 trie 树，方便判断路径是否单词前缀或单词本身。 注意不同路径可能找到相同单词，结果要去重 ","date":"2015-07-31","objectID":"/leetcode/0212/:2:0","tags":null,"title":"0212：单词搜索 II（★★）","uri":"/leetcode/0212/"},{"categories":null,"content":"解答 def findWords(self, board: List[List[str]], words: List[str]) -\u003e List[str]: def dfs(p, i, j): if '#' in p: res.add(p['#']) A = product(range(m),range(n)) if p==trie else [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] for x, y in A: if 0 \u003c=x\u003cm and 0\u003c=y\u003cn and board[x][y] in p: c = board[x][y] board[x][y] = '0' ","date":"2015-07-31","objectID":"/leetcode/0212/:3:0","tags":null,"title":"0212：单词搜索 II（★★）","uri":"/leetcode/0212/"},{"categories":null,"content":"*附加 针对本题有巧妙的优化： 找到单词的同时将 ‘#’ 弹出，就不会搜索到相同单词，最后无需再去重 弹出 ‘#’ 后，非 ‘#’ 的叶子结点也可以弹出，无需再考虑 def findWords(self, board: List[List[str]], words: List[str]) -\u003e List[str]: def dfs(p, i, j): if '#' in p: res.append(p.pop('#')) A = product(range(m),range(n)) if p==trie else [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] for x,","date":"2015-07-31","objectID":"/leetcode/0212/:4:0","tags":null,"title":"0212：单词搜索 II（★★）","uri":"/leetcode/0212/"},{"categories":null,"content":" 力扣第 211 题 ","date":"2015-07-30","objectID":"/leetcode/0211/:0:0","tags":null,"title":"0211：添加与搜索单词 - 数据结构设计（★）","uri":"/leetcode/0211/"},{"categories":null,"content":"题目 请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。 实现词典类 WordDictionary ： WordDictionary() 初始化词典对象 void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配 bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回 false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。 示例： 输入： [\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"se","date":"2015-07-30","objectID":"/leetcode/0211/:1:0","tags":null,"title":"0211：添加与搜索单词 - 数据结构设计（★）","uri":"/leetcode/0211/"},{"categories":null,"content":"分析 0208 升级版，search 里可能含有 ‘.’。 按首位是否为 ‘.’，分别递归即可。 ","date":"2015-07-30","objectID":"/leetcode/0211/:2:0","tags":null,"title":"0211：添加与搜索单词 - 数据结构设计（★）","uri":"/leetcode/0211/"},{"categories":null,"content":"解答 class WordDictionary: def __init__(self): T = lambda: defaultdict(T) self.trie = T() def addWord(self, word: str) -\u003e None: reduce(dict.__getitem__, word, self.trie)['#'] = {} def search(self, word: str) -\u003e bool: def dfs(p, w): if not w: return True if w[0]=='.': return any(dfs(q, w[1:]) for q in ","date":"2015-07-30","objectID":"/leetcode/0211/:3:0","tags":null,"title":"0211：添加与搜索单词 - 数据结构设计（★）","uri":"/leetcode/0211/"},{"categories":null,"content":" 力扣第 210 题 ","date":"2015-07-29","objectID":"/leetcode/0210/:0:0","tags":null,"title":"0210：课程表 II（★）","uri":"/leetcode/0210/"},{"categories":null,"content":"题目 现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。 示例 1： 输入：numCourses = 2, prerequisites = [[1,0]] 输出：[0,1]","date":"2015-07-29","objectID":"/leetcode/0210/:1:0","tags":null,"title":"0210：课程表 II（★）","uri":"/leetcode/0210/"},{"categories":null,"content":"分析 类似 0207，保存出队节点即可。 ","date":"2015-07-29","objectID":"/leetcode/0210/:2:0","tags":null,"title":"0210：课程表 II（★）","uri":"/leetcode/0210/"},{"categories":null,"content":"解答 def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -\u003e List[int]: n = numCourses nxt, indeg = defaultdict(list), [0]*n for v, u in prerequisites: nxt[u].append(v) indeg[v] += 1 res, Q = [], deque(u for u in range(n) if indeg[u]==0) while Q: u = Q.popleft() res.append(u) for v in ","date":"2015-07-29","objectID":"/leetcode/0210/:3:0","tags":null,"title":"0210：课程表 II（★）","uri":"/leetcode/0210/"},{"categories":null,"content":" 力扣第 209 题 ","date":"2015-07-28","objectID":"/leetcode/0209/:0:0","tags":null,"title":"0209：长度最小的子数组（★）","uri":"/leetcode/0209/"},{"categories":null,"content":"题目 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 输入：target = 4, nums = [1,4,4] 输出：1 示例 3： 输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输","date":"2015-07-28","objectID":"/leetcode/0209/:1:0","tags":null,"title":"0209：长度最小的子数组（★）","uri":"/leetcode/0209/"},{"categories":null,"content":"分析 遍历每个位置 j 作为结尾，找符合条件的最短子串 [i, j] 即可。 发现遍历中 i 必然是不动或向右移的，因此是滑动窗口。 ","date":"2015-07-28","objectID":"/leetcode/0209/:2:0","tags":null,"title":"0209：长度最小的子数组（★）","uri":"/leetcode/0209/"},{"categories":null,"content":"解答 def minSubArrayLen(self, target: int, nums: List[int]) -\u003e int: res, i, s = float('inf'), 0, 0 for j, num in enumerate(nums): s += num while s \u003e= target: res = min(res, j-i+1) s -= nums[i] i += 1 return res if res \u003c float('inf') else 0 36 ms ","date":"2015-07-28","objectID":"/leetcode/0209/:3:0","tags":null,"title":"0209：长度最小的子数组（★）","uri":"/leetcode/0209/"},{"categories":null,"content":"*附加 有个巧妙的二分查找方法： 以答案 x 为界，长度小于 x 的子数组必然都不符合，长度 \u003e= x 的子数组中必然有一个符合 因此可以二分查找第一个 y 使得存在长度 y 的子数组符合 判断是否存在长度 y 的子数组符合，可以用滑动窗口在 O(N) 内实现 y 的取值范围是 [1,n]，所以最终的时间复杂度为 O(N log N) def minSubArrayLen(self, target: int, nums: List[int]) -\u003e int: def check(x): s = 0 for j, num in enumerate(nums): s += num if j \u003e= ","date":"2015-07-28","objectID":"/leetcode/0209/:4:0","tags":null,"title":"0209：长度最小的子数组（★）","uri":"/leetcode/0209/"},{"categories":null,"content":" 力扣第 208 题 ","date":"2015-07-27","objectID":"/leetcode/0208/:0:0","tags":null,"title":"0208：实现 Trie (前缀树)（★）","uri":"/leetcode/0208/"},{"categories":null,"content":"题目 Trie（发音类似 \"try\"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 pr","date":"2015-07-27","objectID":"/leetcode/0208/:1:0","tags":null,"title":"0208：实现 Trie (前缀树)（★）","uri":"/leetcode/0208/"},{"categories":null,"content":"分析 trie 树是一种经典的树结构，python 中用 defaultdict 实现比较方便。 insert 时将没有的节点补齐即可 为了区分前缀和整个单词，insert 时添加结尾标志 “#” startsWith 时，判断 trie 中是否有该路径即可 search 某个单词 w 等价于 startsWith(w+’#') ","date":"2015-07-27","objectID":"/leetcode/0208/:2:0","tags":null,"title":"0208：实现 Trie (前缀树)（★）","uri":"/leetcode/0208/"},{"categories":null,"content":"解答 class Trie: def __init__(self): T = lambda: defaultdict(T) self.trie = T() def insert(self, word: str) -\u003e None: reduce(dict.__getitem__, word, self.trie)['#'] = {} def search(self, word: str) -\u003e bool: return self.startsWith(word + '#') def startsWith(self, prefix: str) -\u003e bool: p = self.trie for ","date":"2015-07-27","objectID":"/leetcode/0208/:3:0","tags":null,"title":"0208：实现 Trie (前缀树)（★）","uri":"/leetcode/0208/"},{"categories":null,"content":" 力扣第 207 题 ","date":"2015-07-26","objectID":"/leetcode/0207/:0:0","tags":null,"title":"0207：课程表（★）","uri":"/leetcode/0207/"},{"categories":null,"content":"题目 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。 示例 1： 输入：numCourses = 2, prerequisites = [[1,0]] 输出：tru","date":"2015-07-26","objectID":"/leetcode/0207/:1:0","tags":null,"title":"0207：课程表（★）","uri":"/leetcode/0207/"},{"categories":null,"content":"分析 典型的拓扑排序，等价于判断有向图中是否有环。 一般用 bfs 实现，更容易理解： 初始将所有入度为 0 的顶点入队 每轮弹出队首顶点，将所有后继顶点的入度减一，入度变为 0 的顶点入队 循环直到队空，判断弹出的顶点个数是否等于 numCourses 即可 ","date":"2015-07-26","objectID":"/leetcode/0207/:2:0","tags":null,"title":"0207：课程表（★）","uri":"/leetcode/0207/"},{"categories":null,"content":"解答 def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -\u003e bool: n = numCourses nxt, indeg = defaultdict(list), [0]*n for v, u in prerequisites: nxt[u].append(v) indeg[v] += 1 res, Q = 0, deque(u for u in range(n) if indeg[u]==0) while Q: u = Q.popleft() res += 1 for v in nxt[u]: ind","date":"2015-07-26","objectID":"/leetcode/0207/:3:0","tags":null,"title":"0207：课程表（★）","uri":"/leetcode/0207/"},{"categories":null,"content":" 力扣第 206 题 ","date":"2015-07-25","objectID":"/leetcode/0206/:0:0","tags":null,"title":"0206：反转链表","uri":"/leetcode/0206/"},{"categories":null,"content":"题目 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3： 输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 \u003c= Node.val \u003c= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ ","date":"2015-07-25","objectID":"/leetcode/0206/:1:0","tags":null,"title":"0206：反转链表","uri":"/leetcode/0206/"},{"categories":null,"content":"分析 ","date":"2015-07-25","objectID":"/leetcode/0206/:2:0","tags":null,"title":"0206：反转链表","uri":"/leetcode/0206/"},{"categories":null,"content":"#1 先考虑递归方法： 首先反转 head.next 后的链表，这是递归子问题 然后改变 head.next 和 head 之间的指向即可 def reverseList(self, head: ListNode) -\u003e ListNode: if not head or not head.next: return head newhead = self.reverseList(head.next) head.next.next = head head.next = None return newhead 48 ms ","date":"2015-07-25","objectID":"/leetcode/0206/:2:1","tags":null,"title":"0206：反转链表","uri":"/leetcode/0206/"},{"categories":null,"content":"#2 也可以用迭代法： 用 tail 维护已经反转部分的尾节点 初始新建哑节点，tail 指向 head tail 后面还剩节点时，将该节点去除并插入到哑结点后即可 ","date":"2015-07-25","objectID":"/leetcode/0206/:2:2","tags":null,"title":"0206：反转链表","uri":"/leetcode/0206/"},{"categories":null,"content":"解答 def reverseList(self, head: ListNode) -\u003e ListNode: dummy, tail = ListNode(next=head), head while tail and tail.next: tmp = tail.next tail.next = tmp.next tmp.next = dummy.next dummy.next = tmp return dummy.next 36 ms ","date":"2015-07-25","objectID":"/leetcode/0206/:3:0","tags":null,"title":"0206：反转链表","uri":"/leetcode/0206/"},{"categories":null,"content":" 力扣第 205 题 ","date":"2015-07-24","objectID":"/leetcode/0205/:0:0","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"题目 给定两个字符串 s 和 t ，判断它们是否是同构的。 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。 示例 1: 输入：s = \"egg\", t = \"add\" 输出：true 示例 2： 输入：s = \"foo\", t = \"bar\" 输出：false 示例 3： 输入：s = \"paper\", t = \"title\" 输出：true 提示： 1 \u003c= s.length \u003c= 5 * 104 t.lengt","date":"2015-07-24","objectID":"/leetcode/0205/:1:0","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"分析 ","date":"2015-07-24","objectID":"/leetcode/0205/:2:0","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"#1 显然可以用哈希表。因为要求一一对应，所以用两个哈希表来记录双向关系。 def isIsomorphic(self, s: str, t: str) -\u003e bool: d1, d2 = {}, {} for a, b in zip(s, t): if d1.setdefault(a, b) != b or d2.setdefault(b, a) != a: return False return True 40 ms ","date":"2015-07-24","objectID":"/leetcode/0205/:2:1","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"#2 还有个更巧妙的方法。 若 len(set(s))==len(set(zip(s,t)))，代表 s 到 t 是单射 若 len(set(t))==len(set(zip(s,t)))，代表 t 到 s 是单射 同时满足即说明是双射 ","date":"2015-07-24","objectID":"/leetcode/0205/:2:2","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"解答 def isIsomorphic(self, s: str, t: str) -\u003e bool: return len(set(s))==len(set(t))==len(set(zip(s,t))) 32 ms ","date":"2015-07-24","objectID":"/leetcode/0205/:3:0","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":" 力扣第 204 题 ","date":"2015-07-23","objectID":"/leetcode/0204/:0:0","tags":null,"title":"0204：计数质数（★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"题目 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。 示例 1： 输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2： 输入：n = 0 输出：0 示例 3： 输入：n = 1 输出：0 提示： 0 \u003c= n \u003c= 5 * 106 ","date":"2015-07-23","objectID":"/leetcode/0204/:1:0","tags":null,"title":"0204：计数质数（★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"分析 本题有个经典的埃氏筛法： 从 2 开始遍历到 n 遍历到质数 x 时 ，将之后 x 的倍数都标记为 0 遍历到数 x，假如 x 还未标记，x 即是质数 ","date":"2015-07-23","objectID":"/leetcode/0204/:2:0","tags":null,"title":"0204：计数质数（★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"解答 def countPrimes(self, n: int) -\u003e int: flags = [0] * 2 + [1] * (n - 2) for i in range(2, int(sqrt(n)) + 1): if flags[i]: flags[i*i:n:i] = [0] * ((n-1-i*i)//i+1) return sum(flags) 时间复杂度 O(N log N)，784 ms ","date":"2015-07-23","objectID":"/leetcode/0204/:3:0","tags":null,"title":"0204：计数质数（★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"*附加 ","date":"2015-07-23","objectID":"/leetcode/0204/:4:0","tags":null,"title":"0204：计数质数（★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"#1 基于埃氏筛法还有个很巧妙的动态规划方法。 令 dp[p][v] 代表埃氏筛法遍历到数 p 时[2, v] 内还未标记的个数，f(x) 代表 x 的最小质因数 如果 p*p \u003e v 或者 p 是合数： $$p \\ 筛不到数，dp[p][v] = dp[p-1][v]$$ 如果 p*p \u003c= v 且 p 是质数: $$p 能筛掉合数 C=p*x，当且仅当 f(x)\u003e=p$$ $$\\begin{aligned} p 能筛掉的合数个数 \u0026= 满足 p*x \\le v 且 f(x) \\ge p 的 x 的个数 \\\\ \u0026= 遍历到 p-1 时 [p, v//p] 内还未标记的个数 \\\\ \u0026= dp[","date":"2015-07-23","objectID":"/leetcode/0204/:4:1","tags":null,"title":"0204：计数质数（★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"#2 注意反向遍历 v 就可以优化为一维数组。 并且当 p*p \u003e v 或者 p 是合数时，可以直接跳出遍历，极大地优化时间。 def countPrimes(self, n: int) -\u003e int: n -= 1 if n \u003c 2: return 0 r = int(sqrt(n)) V = [n//x for x in range(1, r)] + list(range(n//r, 0, -1)) dp = {v: v-1 for v in V} for p in range(2, r+1): for v in V: if dp[p]==dp[p-1] or p*p\u003ev: break d","date":"2015-07-23","objectID":"/leetcode/0204/:4:2","tags":null,"title":"0204：计数质数（★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":" 力扣第 203 题 ","date":"2015-07-22","objectID":"/leetcode/0203/:0:0","tags":null,"title":"0203：移除链表元素","uri":"/leetcode/0203/"},{"categories":null,"content":"题目 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2： 输入：head = [], val = 1 输出：[] 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 \u003c= Node.val \u003c= 50 0 \u003c= val \u003c= 50 ","date":"2015-07-22","objectID":"/leetcode/0203/:1:0","tags":null,"title":"0203：移除链表元素","uri":"/leetcode/0203/"},{"categories":null,"content":"分析 遍历删除即可。头节点也可能删除，所以要建个哑结点。 ","date":"2015-07-22","objectID":"/leetcode/0203/:2:0","tags":null,"title":"0203：移除链表元素","uri":"/leetcode/0203/"},{"categories":null,"content":"解答 def removeElements(self, head: ListNode, val: int) -\u003e ListNode: dummy = p = ListNode(next=head) while p.next: if p.next.val == val: p.next = p.next.next else: p = p.next return dummy.next 76 ms ","date":"2015-07-22","objectID":"/leetcode/0203/:3:0","tags":null,"title":"0203：移除链表元素","uri":"/leetcode/0203/"},{"categories":null,"content":" 力扣第 202 题 ","date":"2015-07-21","objectID":"/leetcode/0202/:0:0","tags":null,"title":"0202：快乐数","uri":"/leetcode/0202/"},{"categories":null,"content":"题目 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 1： 输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 示例 2： 输入：n = 2 输出：false 提示： 1 \u003c= n \u003c= 231 - 1 ","date":"2015-07-21","objectID":"/leetcode/0202/:1:0","tags":null,"title":"0202：快乐数","uri":"/leetcode/0202/"},{"categories":null,"content":"分析 直觉上这个过程中数不会越来越大，最终必然进入一个循环，判断是否在 1 上循环即可。 可以用数学知识证明： 设 n 是一个 k 位数，第一次替换后得到 n' 必然有 n’\u003c=81*k，n’的位数 \u003c= $3+\\lfloor log_{10}k \\rfloor$。 有限步之后 n 的位数必然 \u003c=3 ","date":"2015-07-21","objectID":"/leetcode/0202/:2:0","tags":null,"title":"0202：快乐数","uri":"/leetcode/0202/"},{"categories":null,"content":"解答 def isHappy(self, n: int) -\u003e bool: vis = set() while n not in vis: vis.add(n) n = sum(int(x)**2 for x in str(n)) return n == 1 36 ms ","date":"2015-07-21","objectID":"/leetcode/0202/:3:0","tags":null,"title":"0202：快乐数","uri":"/leetcode/0202/"},{"categories":null,"content":"*附加 还可以遍历 [0, 999] 来找出所有循环。最后发现只有两种循环： 1 → 1 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 故无需哈希表，直接判断是否变成 1 或 4 即可。 def isHappy(self, n: int) -\u003e bool: while n not in [1, 4]: n = sum(int(x)**2 for x in str(n)) return n == 1 32 ms ","date":"2015-07-21","objectID":"/leetcode/0202/:4:0","tags":null,"title":"0202：快乐数","uri":"/leetcode/0202/"},{"categories":null,"content":" 力扣第 201 题 ","date":"2015-07-20","objectID":"/leetcode/0201/:0:0","tags":null,"title":"0201：数字范围按位与（★）","uri":"/leetcode/0201/"},{"categories":null,"content":"题目 给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。 示例 1： 输入：left = 5, right = 7 输出：4 示例 2： 输入：left = 0, right = 0 输出：0 示例 3： 输入：left = 1, right = 2147483647 输出：0 提示： 0 \u003c= left \u003c= right \u003c= 231 - 1 ","date":"2015-07-20","objectID":"/leetcode/0201/:1:0","tags":null,"title":"0201：数字范围按位与（★）","uri":"/leetcode/0201/"},{"categories":null,"content":"分析 本题要利用位运算与的特性： 假如 right 的二进制位数比 left 多，结果必然为 0 假如位数相等，去掉 right 和 left 二进制的第一位，转为递归子问题 因此只需要找到 right 和 left 的二进制表示的公共前缀，后面补 0 即可 具体实现时有个巧妙的方法：right 不断去掉最右边的 1 直到 right\u003c=left，即为所求。 ","date":"2015-07-20","objectID":"/leetcode/0201/:2:0","tags":null,"title":"0201：数字范围按位与（★）","uri":"/leetcode/0201/"},{"categories":null,"content":"解答 def rangeBitwiseAnd(self, left: int, right: int) -\u003e int: while right \u003e left: right \u0026= right - 1 return right 48 ms ","date":"2015-07-20","objectID":"/leetcode/0201/:3:0","tags":null,"title":"0201：数字范围按位与（★）","uri":"/leetcode/0201/"},{"categories":null,"content":" 力扣第 200 题 ","date":"2015-07-19","objectID":"/leetcode/0200/:0:0","tags":null,"title":"0200：岛屿数量（★）","uri":"/leetcode/0200/"},{"categories":null,"content":"题目 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 输入：grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] 输出：1 示例 2： 输入：grid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"","date":"2015-07-19","objectID":"/leetcode/0200/:1:0","tags":null,"title":"0200：岛屿数量（★）","uri":"/leetcode/0200/"},{"categories":null,"content":"分析 本题可以用 dfs/bfs 遍历找到每一个岛。 不过连通问题一般还是用并查集，方便进阶问题的解决。 将相邻的陆地连通 最终连通块的个数即是岛屿数量 ","date":"2015-07-19","objectID":"/leetcode/0200/:2:0","tags":null,"title":"0200：岛屿数量（★）","uri":"/leetcode/0200/"},{"categories":null,"content":"解答 def numIslands(self, grid: List[List[str]]) -\u003e int: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) f, m, n = {}, len(grid), len(grid[0]) for i, j in product(range(m), range(n)): if grid[i][j] == '1': f[(i, j)] = (i, j) if i and grid[i-1][j] == '1': ","date":"2015-07-19","objectID":"/leetcode/0200/:3:0","tags":null,"title":"0200：岛屿数量（★）","uri":"/leetcode/0200/"},{"categories":null,"content":" 力扣第 199 题 ","date":"2015-07-18","objectID":"/leetcode/0199/:0:0","tags":null,"title":"0199：二叉树的右视图（★）","uri":"/leetcode/0199/"},{"categories":null,"content":"题目 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 1: 输入: [1,2,3,null,5,null,4] 输出: [1,3,4] 示例 2: 输入: [1,null,3] 输出: [1,3] 示例 3: 输入: [] 输出: [] 提示: 二叉树的节点个数的范围是 [0,100] -100 \u003c= Node.val \u003c= 100 ","date":"2015-07-18","objectID":"/leetcode/0199/:1:0","tags":null,"title":"0199：二叉树的右视图（★）","uri":"/leetcode/0199/"},{"categories":null,"content":"分析 层序遍历，保存每层的最后一个元素即可。 ","date":"2015-07-18","objectID":"/leetcode/0199/:2:0","tags":null,"title":"0199：二叉树的右视图（★）","uri":"/leetcode/0199/"},{"categories":null,"content":"解答 def rightSideView(self, root: Optional[TreeNode]) -\u003e List[int]: res, Q = [], [root] if root else [] while Q: res.append(Q[-1].val) Q = [child for p in Q for child in [p.left, p.right] if child] return res 28 ms ","date":"2015-07-18","objectID":"/leetcode/0199/:3:0","tags":null,"title":"0199：二叉树的右视图（★）","uri":"/leetcode/0199/"},{"categories":null,"content":" 力扣第 198 题 ","date":"2015-07-17","objectID":"/leetcode/0198/:0:0","tags":null,"title":"0198：打家劫舍（★）","uri":"/leetcode/0198/"},{"categories":null,"content":"题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (","date":"2015-07-17","objectID":"/leetcode/0198/:1:0","tags":null,"title":"0198：打家劫舍（★）","uri":"/leetcode/0198/"},{"categories":null,"content":"分析 经典 dp，按偷不偷最后一家即可递归。 按非递归形式的动态规划写时，可以优化为两个变量。 ","date":"2015-07-17","objectID":"/leetcode/0198/:2:0","tags":null,"title":"0198：打家劫舍（★）","uri":"/leetcode/0198/"},{"categories":null,"content":"解答 def rob(self, nums: List[int]) -\u003e int: a, b = 0, 0 for x in nums: a, b = b, max(x+a, b) return b 28 ms ","date":"2015-07-17","objectID":"/leetcode/0198/:3:0","tags":null,"title":"0198：打家劫舍（★）","uri":"/leetcode/0198/"},{"categories":null,"content":" 力扣第 197 题 ","date":"2015-07-16","objectID":"/leetcode/0197/:0:0","tags":null,"title":"0197：上升的温度","uri":"/leetcode/0197/"},{"categories":null,"content":"题目 表： Weather +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | recordDate | date | | temperature | int | +---------------+---------+ id 是这个表的主键 该表包含特定日期的温度信息 编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。 返回结果 不要求顺序 。 查询结果格式如下例。 示例 1： 输入： Weather 表： +----+---","date":"2015-07-16","objectID":"/leetcode/0197/:1:0","tags":null,"title":"0197：上升的温度","uri":"/leetcode/0197/"},{"categories":null,"content":"分析 自连接并按条件选取即可。时间比较可以用 datediff。 ","date":"2015-07-16","objectID":"/leetcode/0197/:2:0","tags":null,"title":"0197：上升的温度","uri":"/leetcode/0197/"},{"categories":null,"content":"解答 select a.id as id from weather a inner join weather b on datediff(a.recordDate , b.recordDate )=1 and a.Temperature\u003eb.Temperature 480 ms ","date":"2015-07-16","objectID":"/leetcode/0197/:3:0","tags":null,"title":"0197：上升的温度","uri":"/leetcode/0197/"},{"categories":null,"content":" 力扣第 196 题 ","date":"2015-07-15","objectID":"/leetcode/0196/:0:0","tags":null,"title":"0196：删除重复的电子邮箱","uri":"/leetcode/0196/"},{"categories":null,"content":"题目 表: Person +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | email | varchar | +-------------+---------+ id是该表的主键列。 该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。 编写一个 SQL 删除语句来 删除 所有重复的电子邮件，只保留一个id最小的唯一电子邮件。 以 任意顺序 返回结果表。 （注意： 仅需要写删除语句，将自动对剩余结果进行查询） 查询结果格式如下所示。 示例 1: 输入: Per","date":"2015-07-15","objectID":"/leetcode/0196/:1:0","tags":null,"title":"0196：删除重复的电子邮箱","uri":"/leetcode/0196/"},{"categories":null,"content":"分析 自连接然后按条件删除即可。 ","date":"2015-07-15","objectID":"/leetcode/0196/:2:0","tags":null,"title":"0196：删除重复的电子邮箱","uri":"/leetcode/0196/"},{"categories":null,"content":"解答 delete p1 from Person p1 inner join Person p2 on p1.email = p2.email and p1.id \u003e p2.id 861 ms ","date":"2015-07-15","objectID":"/leetcode/0196/:3:0","tags":null,"title":"0196：删除重复的电子邮箱","uri":"/leetcode/0196/"},{"categories":null,"content":" 力扣第 195 题 ","date":"2015-07-14","objectID":"/leetcode/0195/:0:0","tags":null,"title":"0195：第十行","uri":"/leetcode/0195/"},{"categories":null,"content":"题目 给定一个文本文件 file.txt，请只打印这个文件中的第十行。 示例: 假设 file.txt 有如下内容： Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10 你的脚本应当显示第十行： Line 10 说明: 1. 如果文件少于十行，你应当输出什么？ 2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。 ","date":"2015-07-14","objectID":"/leetcode/0195/:1:0","tags":null,"title":"0195：第十行","uri":"/leetcode/0195/"},{"categories":null,"content":"分析 需要用到的操作： sed -n '1p' -n 定位到第 1 行，然后 p 打印 ","date":"2015-07-14","objectID":"/leetcode/0195/:2:0","tags":null,"title":"0195：第十行","uri":"/leetcode/0195/"},{"categories":null,"content":"解答 sed -n '10p' file.txt 4 ms ","date":"2015-07-14","objectID":"/leetcode/0195/:3:0","tags":null,"title":"0195：第十行","uri":"/leetcode/0195/"},{"categories":null,"content":" 力扣第 194 题 ","date":"2015-07-13","objectID":"/leetcode/0194/:0:0","tags":null,"title":"0194：转置文件（★）","uri":"/leetcode/0194/"},{"categories":null,"content":"题目 给定一个文件 file.txt，转置它的内容。 你可以假设每行列数相同，并且每个字段由 ' ' 分隔。 示例： 假设 file.txt 文件内容如下： name age alice 21 ryan 30 应当输出： name alice ryan age 21 30 ","date":"2015-07-13","objectID":"/leetcode/0194/:1:0","tags":null,"title":"0194：转置文件（★）","uri":"/leetcode/0194/"},{"categories":null,"content":"分析 需要用到的操作： cat 浏览文件 head -n 取前 n 行 wc -w 获取当前行的列数 xargs 转为单行输出 cut -d' ' f1 按空格分割，取第一列 ","date":"2015-07-13","objectID":"/leetcode/0194/:2:0","tags":null,"title":"0194：转置文件（★）","uri":"/leetcode/0194/"},{"categories":null,"content":"解答 col=$(cat file.txt | head -n 1 | wc -w) for i in $(seq 1 $col) do cut -d' ' -f$i file.txt | xargs done 8 ms ","date":"2015-07-13","objectID":"/leetcode/0194/:3:0","tags":null,"title":"0194：转置文件（★）","uri":"/leetcode/0194/"},{"categories":null,"content":" 力扣第 193 题 ","date":"2015-07-12","objectID":"/leetcode/0193/:0:0","tags":null,"title":"0193：有效电话号码","uri":"/leetcode/0193/"},{"categories":null,"content":"题目 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。 你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字） 你也可以假设每行前后没有多余的空格字符。 示例： 假设 file.txt 内容如下： 987-123-4567 123 456 7890 (123) 456-7890 你的脚本应当输出下列有效的电话号码： 987-123-4567 (123) 456-7890 ","date":"2015-07-12","objectID":"/leetcode/0193/:1:0","tags":null,"title":"0193：有效电话号码","uri":"/leetcode/0193/"},{"categories":null,"content":"分析 正则匹配，需要用到的操作： grep -P 用 perl 模式的正则，能支持 \\d ","date":"2015-07-12","objectID":"/leetcode/0193/:2:0","tags":null,"title":"0193：有效电话号码","uri":"/leetcode/0193/"},{"categories":null,"content":"解答 grep -P '^(\\d{3}-|\\(\\d{3}\\) )\\d{3}-\\d{4}$' file.txt 8 ms ","date":"2015-07-12","objectID":"/leetcode/0193/:3:0","tags":null,"title":"0193：有效电话号码","uri":"/leetcode/0193/"},{"categories":null,"content":" 力扣第 192 题 ","date":"2015-07-11","objectID":"/leetcode/0192/:0:0","tags":null,"title":"0192：统计词频（★）","uri":"/leetcode/0192/"},{"categories":null,"content":"题目 写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。 为了简单起见，你可以假设： words.txt只包括小写字母和 ' ' 。 每个单词只由小写字母组成。 单词间由一个或多个空格字符分隔。 示例: 假设 words.txt 内容如下： the day is sunny the the the sunny is is 你的脚本应当输出（以词频降序排列）： the 4 is 3 sunny 2 day 1 说明: 不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。 你可以使用一行 Unix pipes 实现吗？ ","date":"2015-07-11","objectID":"/leetcode/0192/:1:0","tags":null,"title":"0192：统计词频（★）","uri":"/leetcode/0192/"},{"categories":null,"content":"分析 需要用到的操作： cat 浏览文件 tr -s 替换字符串 sort 排序 uniq -c 输出 sort -r 反向排序 awk 格式化输出， $1、$2 取元素 ","date":"2015-07-11","objectID":"/leetcode/0192/:2:0","tags":null,"title":"0192：统计词频（★）","uri":"/leetcode/0192/"},{"categories":null,"content":"解答 cat words.txt | tr -s ' ' '\\n' | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' 8 ms ","date":"2015-07-11","objectID":"/leetcode/0192/:3:0","tags":null,"title":"0192：统计词频（★）","uri":"/leetcode/0192/"},{"categories":null,"content":" 力扣第 191 题 ","date":"2015-07-10","objectID":"/leetcode/0191/:0:0","tags":null,"title":"0191：位1的个数","uri":"/leetcode/0191/"},{"categories":null,"content":"题目 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。 示例 1： 输入：n = 00000000000000000000000000001011 输出：3 解释：输入的二进制串 0000000000","date":"2015-07-10","objectID":"/leetcode/0191/:1:0","tags":null,"title":"0191：位1的个数","uri":"/leetcode/0191/"},{"categories":null,"content":"分析 ","date":"2015-07-10","objectID":"/leetcode/0191/:2:0","tags":null,"title":"0191：位1的个数","uri":"/leetcode/0191/"},{"categories":null,"content":"#1 可以直接调包。 def hammingWeight(self, n: int) -\u003e int: return n.bit_count() 32 ms ","date":"2015-07-10","objectID":"/leetcode/0191/:2:1","tags":null,"title":"0191：位1的个数","uri":"/leetcode/0191/"},{"categories":null,"content":"#2 有个巧妙的位计算技巧，n \u0026 (n-1) 等价于将 n 中最后一个 1 变为 0。 循环操作直到 n 变为 0 即可。 ","date":"2015-07-10","objectID":"/leetcode/0191/:2:2","tags":null,"title":"0191：位1的个数","uri":"/leetcode/0191/"},{"categories":null,"content":"解答 def hammingWeight(self, n: int) -\u003e int: res = 0 while n: n \u0026= n - 1 res += 1 return res 40 ms ","date":"2015-07-10","objectID":"/leetcode/0191/:3:0","tags":null,"title":"0191：位1的个数","uri":"/leetcode/0191/"},{"categories":null,"content":"进入了原为女校、有着1016名女学生的私立八光学园的仅仅五名男学生，清志、岳人、真吾、让、安德雷。他们刚一入学，就在是个男人都会产生的邪念驱使下前去偷窥女浴室，作为惩罚，被管理着学园纪律的“里学生会”的三名美女投入了惩罚大楼（=通称：监狱）。他们还会有名为明日的希望吗！？","date":"2015-07-10","objectID":"/anime/prison_school/","tags":null,"title":"监狱学园","uri":"/anime/prison_school/"},{"categories":null,"content":"简介 进入了原为女校、有着1016名女学生的私立八光学园的仅仅五名男学生，清志、岳人、真吾、让、安德雷。他们刚一入学，就在是个男人都会产生的邪念驱使下前去偷窥女浴室，作为惩罚，被管理着学园纪律的“里学生会”的三名美女投入了惩罚大楼（=通称：监狱）。他们还会有名为明日的希望吗！？ 制作人员： 原作：平本彰 导演：水岛努 脚本：横手美智子 分镜：二瓶勇一、小林敦、倉川英揚 演出：樱美胜志 ","date":"2015-07-10","objectID":"/anime/prison_school/:1:0","tags":null,"title":"监狱学园","uri":"/anime/prison_school/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤野清志 藤野 清志、ふじの きよし、Fujino Kiyoshi、清志(キヨシ) 男 神谷浩史 2 诸葛岳人 諸葛 岳人、もろくず たけひと、Morokuzu Takehito、葛人(ガクト) 男 小西克幸 3 若本真吾 若本 真吾、わかもと しんご、Wakamoto Shingo、真吾(シンゴ) 男 鈴村健一 4 根津让二 根津 譲二、ねづ じょうじ、Nezu joji、让(ジョー) 男 浪川大輔 5 安堂丽治 安堂 麗治、あんどう れいじ、Andō Reiji、安德鲁(アンドレ) 男 興津和幸 6 栗原万里 栗原 万里、くりはら まり、Kurihara","date":"2015-07-10","objectID":"/anime/prison_school/:2:0","tags":null,"title":"监狱学园","uri":"/anime/prison_school/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 监狱学园 2015-07-10 12 樱花 ","date":"2015-07-10","objectID":"/anime/prison_school/:3:0","tags":null,"title":"监狱学园","uri":"/anime/prison_school/"},{"categories":null,"content":"　　大闹天宫后四百年多年，齐天大圣成了一个传说，在山妖横行的长安城，孤儿江流儿（林子杰 配音）与行脚僧法明（吴文伦 配音）相依为命，小小少年常常神往大闹天宫的孙悟空（张磊 配音）。 \n　　有一天，山妖（吴迪 配音）来劫掠童男童女，江流儿救了一个小女孩，惹得山妖追杀，他一路逃跑，跑进了五行山，盲打误撞地解除了孙悟空的封印。悟空自由之后只想回花果山，却无奈腕上封印未解，又欠江流儿人情，勉强地护送他回长安城。 \n　　一路上八戒（刘九容 配音）和白龙马也因缘际化地现身，但或落魄或魔性大发，英雄不再。妖王为抢女童，布下夜店迷局，却发现悟空法力尽失，轻而易举地抓走了女童。悟空不愿再去救女童，江流儿决定自己去救。\n　　日全食之日，在悬空寺，妖王准备将童男童女投入丹炉中，江流儿却冲进了道场，最后一战开始了……","date":"2015-07-10","objectID":"/anime/monkey_king/","tags":null,"title":"西游记之大圣归来","uri":"/anime/monkey_king/"},{"categories":null,"content":"简介 大闹天宫后四百年多年，齐天大圣成了一个传说，在山妖横行的长安城，孤儿江流儿（林子杰 配音）与行脚僧法明（吴文伦 配音）相依为命，小小少年常常神往大闹天宫的孙悟空（张磊 配音）。 有一天，山妖（吴迪 配音）来劫掠童男童女，江流儿救了一个小女孩，惹得山妖追杀，他一路逃跑，跑进了五行山，盲打误撞地解除了孙悟空的封印。悟空自由之后只想回花果山，却无奈腕上封印未解，又欠江流儿人情，勉强地护送他回长安城。 一路上八戒（刘九容 配音）和白龙马也因缘际化地现身，但或落魄或魔性大发，英雄不再。妖王为抢女童，布下夜店迷局，却发现悟空法力尽失，轻而易举地抓走了女童。悟空不愿再去救女童，江流儿决定自己去救。 日","date":"2015-07-10","objectID":"/anime/monkey_king/:1:0","tags":null,"title":"西游记之大圣归来","uri":"/anime/monkey_king/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 西游记之大圣归来 2015-07-10 1 bilibili ","date":"2015-07-10","objectID":"/anime/monkey_king/:2:0","tags":null,"title":"西游记之大圣归来","uri":"/anime/monkey_king/"},{"categories":null,"content":" 力扣第 190 题 ","date":"2015-07-09","objectID":"/leetcode/0190/:0:0","tags":null,"title":"0190：颠倒二进制位","uri":"/leetcode/0190/"},{"categories":null,"content":"题目 颠倒给定的 32 位无符号整数的二进制位。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 示例 1： 输入：n = 00000010100101000001111010011100 输出：964176192 (0011100101111000001010010100000","date":"2015-07-09","objectID":"/leetcode/0190/:1:0","tags":null,"title":"0190：颠倒二进制位","uri":"/leetcode/0190/"},{"categories":null,"content":"分析 类似于 0007，转为字符串再反转，或者按位依次构建皆可。 ","date":"2015-07-09","objectID":"/leetcode/0190/:2:0","tags":null,"title":"0190：颠倒二进制位","uri":"/leetcode/0190/"},{"categories":null,"content":"解答 def reverseBits(self, n: int) -\u003e int: return int(bin(n)[2:].zfill(32)[::-1], 2) 32 ms ","date":"2015-07-09","objectID":"/leetcode/0190/:3:0","tags":null,"title":"0190：颠倒二进制位","uri":"/leetcode/0190/"},{"categories":null,"content":" 力扣第 189 题 ","date":"2015-07-08","objectID":"/leetcode/0189/:0:0","tags":null,"title":"0189：轮转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"题目 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] 提示","date":"2015-07-08","objectID":"/leetcode/0189/:1:0","tags":null,"title":"0189：轮转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"分析 ","date":"2015-07-08","objectID":"/leetcode/0189/:2:0","tags":null,"title":"0189：轮转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"#1 最简单的就是切片。 def rotate(self, nums: List[int], k: int) -\u003e None: k %= len(nums) nums[:] = nums[-k:] + nums[:-k] 40 ms ","date":"2015-07-08","objectID":"/leetcode/0189/:2:1","tags":null,"title":"0189：轮转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"#2 要求空间复杂度 O(1)，有一个很巧妙的方法。 将 nums 反转，和最终结果比较，发现只要再将 nums[:k] 和 nums[k:] 反转即可。 ","date":"2015-07-08","objectID":"/leetcode/0189/:2:2","tags":null,"title":"0189：轮转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"解答 def rotate(self, nums: List[int], k: int) -\u003e None: def rev(i, j): while i \u003c j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 n = len(nums) k %= n rev(0, n-1) rev(0, k-1) rev(k, n-1) 56 ms ","date":"2015-07-08","objectID":"/leetcode/0189/:3:0","tags":null,"title":"0189：轮转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"我的妹妹小埋16岁，完美的妹妹，完美的高中生，但在家里却是个超懒的干物妹。\n然而妹妹在家的一切她生活中的朋友并不知道，居住在同一栋楼的天然少女，以及无意间来到我家的冷酷少女，她们会发现小埋的真实面目吗？","date":"2015-07-08","objectID":"/anime/himouto_umaru_chan/","tags":null,"title":"干物妹！小埋","uri":"/anime/himouto_umaru_chan/"},{"categories":null,"content":"简介 我的妹妹小埋16岁，完美的妹妹，完美的高中生，但在家里却是个超懒的干物妹。 然而妹妹在家的一切她生活中的朋友并不知道，居住在同一栋楼的天然少女，以及无意间来到我家的冷酷少女，她们会发现小埋的真实面目吗？ 制作人员： 原作：三角头 导演：太田雅彦 脚本：青岛崇、子安秀明、鸿野贵光、杉原研二 分镜：志村宏明、今泉贤一、荒井省吾 ","date":"2015-07-08","objectID":"/anime/himouto_umaru_chan/:1:0","tags":null,"title":"干物妹！小埋","uri":"/anime/himouto_umaru_chan/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 土间埋 UMR、土間うまる、どま うまる、Doma Umaru、狸吉 女 田中あいみ 2 土间大平 土間タイヘイ、どま たいへい、Doma Taihei 男 野島健児 3 海老名菜菜 海老名 菜々、えびな なな、Ebina Nana 女 影山灯 4 本场切绘 本場切絵、もとば きりえ、Motoba Kirie、きりんりん 女 白石晴香 5 橘·希尔芬福特 TSF、Sylphinford Tachibana、たちばな・シルフィンフォード、Tachibana Shirufinfōdo 女 古川由利奈 6 本场猛 もとば たけし、Motoba Takeshi、崩巴","date":"2015-07-08","objectID":"/anime/himouto_umaru_chan/:2:0","tags":null,"title":"干物妹！小埋","uri":"/anime/himouto_umaru_chan/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 干物妹！小埋 2015-07-08 12 bilibili 2 干物妹！小埋R 2017-10-08 12 bilibili ","date":"2015-07-08","objectID":"/anime/himouto_umaru_chan/:3:0","tags":null,"title":"干物妹！小埋","uri":"/anime/himouto_umaru_chan/"},{"categories":null,"content":" 力扣第 188 题 ","date":"2015-07-07","objectID":"/leetcode/0188/:0:0","tags":null,"title":"0188：买卖股票的最佳时机 IV（★★）","uri":"/leetcode/0188/"},{"categories":null,"content":"题目 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格","date":"2015-07-07","objectID":"/leetcode/0188/:1:0","tags":null,"title":"0188：买卖股票的最佳时机 IV（★★）","uri":"/leetcode/0188/"},{"categories":null,"content":"分析 类似 0121，只是从 2 次变成了 k 次。 ","date":"2015-07-07","objectID":"/leetcode/0188/:2:0","tags":null,"title":"0188：买卖股票的最佳时机 IV（★★）","uri":"/leetcode/0188/"},{"categories":null,"content":"解答 def maxProfit(self, k: int, prices: List[int]) -\u003e int: n = len(prices) dp = [[float('-inf'), 0] for _ in range(k+1)] for x in prices: prev = dp[:] for j in range(1, k+1): dp[j][0] = max(prev[j][0], prev[j-1][1]-x) dp[j][1] = max(prev[j][1], prev[j][0]+x) return dp[-1][-1] 84 ms ","date":"2015-07-07","objectID":"/leetcode/0188/:3:0","tags":null,"title":"0188：买卖股票的最佳时机 IV（★★）","uri":"/leetcode/0188/"},{"categories":null,"content":"作品主要讲述了某天，一款掀起大热潮的VRMMORPG「YGGDRASIL」原本会停止一切服务，但即使过了结束时间，玩家也不会退出游戏，NPC也有了各自的思想。现实世界中喜爱电玩的主人公铃木悟（真名）在等待系统强制登出时，与“安兹·乌尔·恭”公会的成员意外穿越到了异世界，并且自己还变成了拥有骷髅外表的最强魔法师——“飞鼠”。就这样，真正的奇幻传说正式拉开帷幕。","date":"2015-07-07","objectID":"/anime/overlord/","tags":null,"title":"OVERLORD","uri":"/anime/overlord/"},{"categories":null,"content":"简介 作品主要讲述了某天，一款掀起大热潮的VRMMORPG「YGGDRASIL」原本会停止一切服务，但即使过了结束时间，玩家也不会退出游戏，NPC也有了各自的思想。现实世界中喜爱电玩的主人公铃木悟（真名）在等待系统强制登出时，与“安兹·乌尔·恭”公会的成员意外穿越到了异世界，并且自己还变成了拥有骷髅外表的最强魔法师——“飞鼠”。就这样，真正的奇幻传说正式拉开帷幕。 制作人员： 原作：丸山黄金 导演：伊藤尚往 脚本：菅原雪绘 分镜：川尻善昭、薮田修平、仓谷凉一、小野学、松村政辉 ","date":"2015-07-07","objectID":"/anime/overlord/:1:0","tags":null,"title":"OVERLORD","uri":"/anime/overlord/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安兹·乌尔·恭 铃木悟、莫莫伽、飞鼠、ainz ooal gown、モモンガ、拥有骷髅外表的最强魔法吟唱者 男 日野聡 2 雅儿贝德 albedo、温柔体贴的纯白恶魔 女 原由実 3 夏提雅·布拉德弗伦 shalltear bloodfallen、鲜血的战争少女 女 上坂すみれ 4 马雷·贝罗·菲欧雷 mare bello fiore、不可靠的大自然使者 男 内山夕実 5 亚乌菈·贝拉·菲欧拉 aura bella fiora、不服输的知名训练师 女 加藤英美里 6 迪米乌哥斯 demiurge、炎狱造物主 男 加藤将之 7 科塞特斯 cocytus、冰河统","date":"2015-07-07","objectID":"/anime/overlord/:2:0","tags":null,"title":"OVERLORD","uri":"/anime/overlord/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 OVERLORD 2015-07-07 13 bilibili 2 OVERLORD II 2018-01-09 13 bilibili 3 OVERLORD III 2018-07-10 13 bilibili 4 OVERLORD IV 2022-07-05 13 樱花 ","date":"2015-07-07","objectID":"/anime/overlord/:3:0","tags":null,"title":"OVERLORD","uri":"/anime/overlord/"},{"categories":null,"content":" 力扣第 187 题 ","date":"2015-07-06","objectID":"/leetcode/0187/:0:0","tags":null,"title":"0187：重复的DNA序列（★）","uri":"/leetcode/0187/"},{"categories":null,"content":"题目 DNA序列 由一系列核苷酸组成，缩写为 'A', 'C', 'G' 和 'T'.。 例如，\"ACGAATTCCG\" 是一个 DNA序列 。 在研究 DNA 时，识别 DNA 中的重复序列非常有用。 给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。 示例 1： 输入：s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\" 输出：[\"AAAAACCCCC\",\"CCCCCAAAAA\"] 示例 2： 输入：s = \"AAAAAAAAAAAAA\" 输出：[\"AAAAAAAAAA","date":"2015-07-06","objectID":"/leetcode/0187/:1:0","tags":null,"title":"0187：重复的DNA序列（★）","uri":"/leetcode/0187/"},{"categories":null,"content":"分析 ","date":"2015-07-06","objectID":"/leetcode/0187/:2:0","tags":null,"title":"0187：重复的DNA序列（★）","uri":"/leetcode/0187/"},{"categories":null,"content":"#1 最简单的就是依次遍历子串，用哈希表判断是否出现过即可。 def findRepeatedDnaSequences(self, s: str) -\u003e List[str]: ct = Counter(s[i:i + 10] for i in range(len(s) - 9)) return [sub for sub, freq in ct.items() if freq \u003e 1] 60 ms ","date":"2015-07-06","objectID":"/leetcode/0187/:2:1","tags":null,"title":"0187：重复的DNA序列（★）","uri":"/leetcode/0187/"},{"categories":null,"content":"#2 当子串长度较大时，朴素哈希比较耗时。更为通用的方法是滚动哈希。 ","date":"2015-07-06","objectID":"/leetcode/0187/:2:2","tags":null,"title":"0187：重复的DNA序列（★）","uri":"/leetcode/0187/"},{"categories":null,"content":"解答 def findRepeatedDnaSequences(self, s: str) -\u003e List[str]: d = dict(zip('ACGT', range(4))) base, L = 5, 10 w, bL = 0, base**L res, ct = [], Counter() for j, char in enumerate(s): w = w * base + d[char] if j \u003e= L: w -= d[s[j-L]] * bL if j \u003e= L-1: ct[w] += 1 if ct[w] == 2: res.append(s[j-L+1:j+1]) re","date":"2015-07-06","objectID":"/leetcode/0187/:3:0","tags":null,"title":"0187：重复的DNA序列（★）","uri":"/leetcode/0187/"},{"categories":null,"content":" 力扣第 186 题 ","date":"2015-07-05","objectID":"/leetcode/0186/:0:0","tags":null,"title":"0186：反转字符串中的单词 II（★）","uri":"/leetcode/0186/"},{"categories":null,"content":"题目 给你一个字符数组 s ，反转其中 单词 的顺序。 单词 的定义为：单词是一个由非空格字符组成的序列。s 中的单词将会由单个空格分隔。 必须设计并实现 原地 解法来解决此问题，即不分配额外的空间。 示例 1： 输入：s = [\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"] 输出：[\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"] 示例 2： 输入：s = [\"a\"] 输出：[\"a\"] 提示： 1 \u003c= s.length \u003c= 105 s[i] 可","date":"2015-07-05","objectID":"/leetcode/0186/:1:0","tags":null,"title":"0186：反转字符串中的单词 II（★）","uri":"/leetcode/0186/"},{"categories":null,"content":"分析 分割翻转再拼接，或者双指针即可解决。 ","date":"2015-07-05","objectID":"/leetcode/0186/:2:0","tags":null,"title":"0186：反转字符串中的单词 II（★）","uri":"/leetcode/0186/"},{"categories":null,"content":"解答 def reverseWords(self, s: List[str]) -\u003e None: s[:] = list(' '.join(''.join(s).split()[::-1])) 44 ms ","date":"2015-07-05","objectID":"/leetcode/0186/:3:0","tags":null,"title":"0186：反转字符串中的单词 II（★）","uri":"/leetcode/0186/"},{"categories":null,"content":" 力扣第 185 题 ","date":"2015-07-04","objectID":"/leetcode/0185/:0:0","tags":null,"title":"0185：部门工资前三高的所有员工（★★）","uri":"/leetcode/0185/"},{"categories":null,"content":"题目 表: Employee +--------------+---------+ | Column Name | Type | +--------------+---------+ | id | int | | name | varchar | | salary | int | | departmentId | int | +--------------+---------+ Id是该表的主键列。 departmentId是Department表中ID的外键。 该表的每一行都表示员工的ID、姓名和工资。它还包含了他们部门的ID。 表: Department +-------------+--","date":"2015-07-04","objectID":"/leetcode/0185/:1:0","tags":null,"title":"0185：部门工资前三高的所有员工（★★）","uri":"/leetcode/0185/"},{"categories":null,"content":"分析 0184 升级版。 可以将每个员工和比自己工资高的连接，将连接数小于 3 的员工返回即可。 ","date":"2015-07-04","objectID":"/leetcode/0185/:2:0","tags":null,"title":"0185：部门工资前三高的所有员工（★★）","uri":"/leetcode/0185/"},{"categories":null,"content":"解答 select b.name as Department, a.name as Employee, a.salary as Salary from Employee a left join Department b on a.departmentId = b.id left join Employee c on a.departmentId = c.departmentId and a.salary \u003c c.salary group by a.id having count(distinct c.salary)\u003c3 881 ms ","date":"2015-07-04","objectID":"/leetcode/0185/:3:0","tags":null,"title":"0185：部门工资前三高的所有员工（★★）","uri":"/leetcode/0185/"},{"categories":null,"content":"故事讲述当“魔神”自暗黑深渊苏醒，命运之神将会挑选出六名勇者，授与其拯救世界的力量。自称地表最强的少年亚德雷，获选为六位“六花勇者”之一，并前往战地阻止魔神复活。然而不知为何，在约定之地集结的却有七位勇者!? 紧接着雾幻结界随之启动，将七人全数困在森林中。发现其中混入一名内奸后，勇者们变得疑神疑鬼，人人自危。而首当其冲遭受质疑的，正是亚德雷！","date":"2015-07-04","objectID":"/anime/rokka/","tags":null,"title":"六花的勇者","uri":"/anime/rokka/"},{"categories":null,"content":"简介 故事讲述当“魔神”自暗黑深渊苏醒，命运之神将会挑选出六名勇者，授与其拯救世界的力量。自称地表最强的少年亚德雷，获选为六位“六花勇者”之一，并前往战地阻止魔神复活。然而不知为何，在约定之地集结的却有七位勇者!? 紧接着雾幻结界随之启动，将七人全数困在森林中。发现其中混入一名内奸后，勇者们变得疑神疑鬼，人人自危。而首当其冲遭受质疑的，正是亚德雷！ 制作人员： 原作：山形石雄 导演：高桥丈夫 脚本：浦畑达彦 分镜：中野典克、川尻善昭、森义博、鹈饲悠纪、迫井政行 ","date":"2015-07-04","objectID":"/anime/rokka/:1:0","tags":null,"title":"六花的勇者","uri":"/anime/rokka/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 亚特雷特 麦亚 男 沢城みゆき 2 娜榭塔妮亚 娜榭塔妮亚·露伊·彼埃纳·奥古斯特、ナッシェタニア・ルーイ・ピエナ・アウグストラ 女 日笠陽子 3 芙蕾米·斯皮德洛 女 悠木碧 4 汉斯·翰普缇 男 鈴村健一 5 莫拉·切斯特 女 佐藤利奈 6 茶末·罗素 恰姆、Chamo Rosso 女 加隈亜衣 7 戈尔道夫·奥欧拉 内山昂輝 8 萝萝妮亚·曼切特 洛洛尼亚·曼切塔、ロロニア・マンチェッタ 女 金元寿子 ","date":"2015-07-04","objectID":"/anime/rokka/:2:0","tags":null,"title":"六花的勇者","uri":"/anime/rokka/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 六花的勇者 2015-07-04 12 樱花 ","date":"2015-07-04","objectID":"/anime/rokka/:3:0","tags":null,"title":"六花的勇者","uri":"/anime/rokka/"},{"categories":null,"content":"思春期的少年少女中极少部分人会发作的特殊能力。\n驱使着无人知晓的能力，过着顺风顺水学园生活的乙坂有宇。\n突然出现在这样的他的面前的少女，友利奈绪。\n从与她相遇之日起，被揭露出来的特殊能力者的宿命。\n这是由麻枝准所描绘的，特殊能力者们奔跑着的青春物语——。","date":"2015-07-04","objectID":"/anime/charlotte/","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":"简介 思春期的少年少女中极少部分人会发作的特殊能力。 驱使着无人知晓的能力，过着顺风顺水学园生活的乙坂有宇。 突然出现在这样的他的面前的少女，友利奈绪。 从与她相遇之日起，被揭露出来的特殊能力者的宿命。 这是由麻枝准所描绘的，特殊能力者们奔跑着的青春物语——。 制作人员： 原作：Visual Art’s、Key、麻枝准 导演：浅井义之 分镜：筱原俊哉、湖山祯崇、福田道生 ","date":"2015-07-04","objectID":"/anime/charlotte/:1:0","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 友利奈绪 友利 奈緒、ともり なお、Tomori Nao 女 佐倉綾音 2 乙坂有宇 Yuu Otosaka、乙坂 有宇、おとさか ゆう、Otosaka Yū、独眼死神（隻眼の死神） 男 内山昂輝 3 高城丈士朗 高城 丈士朗、たかじょう じょうじろう、Takajō Jōjirō 男 水島大宙 4 西森柚咲 黑羽柚咲、西森 柚咲、にしもり ゆさ、Nishimori Yusa、黒羽柚咲、くろはね ゆさ、Kurobane Yusa 女 内田真礼 5 乙坂步未 乙坂 歩未、おとさか あゆみ、Otosaka Ayumi 女 麻倉もも 6 黑羽美砂 黒羽 美砂、くろば","date":"2015-07-04","objectID":"/anime/charlotte/:2:0","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 夏洛特 2015-07-04 14 bilibili ","date":"2015-07-04","objectID":"/anime/charlotte/:3:0","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":"MAD ","date":"2015-07-04","objectID":"/anime/charlotte/:4:0","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":" 力扣第 184 题 ","date":"2015-07-03","objectID":"/leetcode/0184/:0:0","tags":null,"title":"0184：部门工资最高的员工（★）","uri":"/leetcode/0184/"},{"categories":null,"content":"题目 表： Employee +--------------+---------+ | 列名 | 类型 | +--------------+---------+ | id | int | | name | varchar | | salary | int | | departmentId | int | +--------------+---------+ id是此表的主键列。 departmentId是Department表中ID的外键。 此表的每一行都表示员工的ID、姓名和工资。它还包含他们所在部门的ID。 表： Department +-------------+---------+ |","date":"2015-07-03","objectID":"/leetcode/0184/:1:0","tags":null,"title":"0184：部门工资最高的员工（★）","uri":"/leetcode/0184/"},{"categories":null,"content":"分析 先按部门分组得到每个组的最大工资，并作为临时表，然后与 Employee、Department 按部门 id 连接并判断员工工资是否为最大工资即可。 ","date":"2015-07-03","objectID":"/leetcode/0184/:2:0","tags":null,"title":"0184：部门工资最高的员工（★）","uri":"/leetcode/0184/"},{"categories":null,"content":"解答 select b.name as Department, a.name as Employee, a.salary as Salary from Employee a left join Department b on a.departmentId = b.id inner join ( select departmentId, max(salary) salary from Employee group by departmentId ) c on a.departmentId = c.departmentId and a.salary = c.salary 681 ms ","date":"2015-07-03","objectID":"/leetcode/0184/:3:0","tags":null,"title":"0184：部门工资最高的员工（★）","uri":"/leetcode/0184/"},{"categories":null,"content":"在火星所建立的日本新的都道府县之一——「第4东京都」。在这个城市的经济特区「雾科市」中，有着以宇宙航空事业著名的超一流企业——「雾科Corporation」。\n公司为了将市场份额扩大到各个领域，运营着名为「雾科科学技术学园」的私立学校。\n虽然仅是如此便已能称得上是特殊，但是学园中更是有着与众不同的班级。\n白天作为学生在学园中学习，放学后作为社员在公司上班，参加着重要项目“发展型试制火箭”的研发。\n这就是「雾科Corporation先行技术开发部 教育开发室」，通称「A-TEC」。\n担任此部门室长职务的年轻天才工程师瀬良カイト，是学园中A-TEC的班主任，被学生们亲切地（？）叫做“热血火箭老师”。\n故事从A-TEC迎来了转校生开始。\n虽然A-TEC做好了迎接新伙伴的准备，但是发生了转校生在前往火星的途中被诱拐绑架的事件。\n意识到只有依靠自己才能突破这一难关的カイト，和A-TEC的成员一起，踏上了前所未闻的解救作战之路……","date":"2015-07-03","objectID":"/anime/classroom_crisis/","tags":null,"title":"教室☆危机","uri":"/anime/classroom_crisis/"},{"categories":null,"content":"简介 在火星所建立的日本新的都道府县之一——「第4东京都」。在这个城市的经济特区「雾科市」中，有着以宇宙航空事业著名的超一流企业——「雾科Corporation」。 公司为了将市场份额扩大到各个领域，运营着名为「雾科科学技术学园」的私立学校。 虽然仅是如此便已能称得上是特殊，但是学园中更是有着与众不同的班级。 白天作为学生在学园中学习，放学后作为社员在公司上班，参加着重要项目“发展型试制火箭”的研发。 这就是「雾科Corporation先行技术开发部 教育开发室」，通称「A-TEC」。 担任此部门室长职务的年轻天才工程师瀬良カイト，是学园中A-TEC的班主任，被学生们亲切地（？）叫做“热血火箭","date":"2015-07-03","objectID":"/anime/classroom_crisis/:1:0","tags":null,"title":"教室☆危机","uri":"/anime/classroom_crisis/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 濑良界人 瀬良 カイト、せら かいと、Sera Kaito 男 森久保祥太郎 2 雾羽渚 霧羽 ナギサ、きりゅ なぎさ、Kiryu Nagisa 男 内田雄馬 3 白崎伊莉丝 Shirosaki Iris、白崎 イリス、しろさき イリス、Shirosaki Irisu 女 雨宮天 4 濑良瑞季 濑良美月、瀬良 ミズキ、せら みずき、Sera Mizuki 女 小澤亜李 5 雾羽和久 霧羽 カズヒサ、きりゅ かずひさ、Kiryu Kazuhisa 男 井上和彦 6 雾羽裕次 霧羽 ユウジ、きりゅ ゆうじ、Kiryu Yuuji 男 吉野裕行 7 服部花子 アン","date":"2015-07-03","objectID":"/anime/classroom_crisis/:2:0","tags":null,"title":"教室☆危机","uri":"/anime/classroom_crisis/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 教室☆危机 2015-07-03 14 bilibili ","date":"2015-07-03","objectID":"/anime/classroom_crisis/:3:0","tags":null,"title":"教室☆危机","uri":"/anime/classroom_crisis/"},{"categories":null,"content":" 力扣第 183 题 ","date":"2015-07-02","objectID":"/leetcode/0183/:0:0","tags":null,"title":"0183：从不订购的客户","uri":"/leetcode/0183/"},{"categories":null,"content":"题目 某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： +----+-------+ | Id | Name | +----+-------+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +----+-------+ Orders 表： +----+------------+ | Id | CustomerId | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ 例如给定上","date":"2015-07-02","objectID":"/leetcode/0183/:1:0","tags":null,"title":"0183：从不订购的客户","uri":"/leetcode/0183/"},{"categories":null,"content":"分析 返回左连接没成功的即可。 ","date":"2015-07-02","objectID":"/leetcode/0183/:2:0","tags":null,"title":"0183：从不订购的客户","uri":"/leetcode/0183/"},{"categories":null,"content":"解答 select a.Name as Customers from Customers a left join Orders b on a.Id = b.CustomerId where b.Id is null 520 ms ","date":"2015-07-02","objectID":"/leetcode/0183/:3:0","tags":null,"title":"0183：从不订购的客户","uri":"/leetcode/0183/"},{"categories":null,"content":" 力扣第 182 题 ","date":"2015-07-01","objectID":"/leetcode/0182/:0:0","tags":null,"title":"0182：查找重复的电子邮箱","uri":"/leetcode/0182/"},{"categories":null,"content":"题目 表: Person +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | email | varchar | +-------------+---------+ id 是该表的主键列。 此表的每一行都包含一封电子邮件。电子邮件不包含大写字母。 编写一个 SQL 查询来报告所有重复的电子邮件。 请注意，可以保证电子邮件字段不为 NULL。 以 任意顺序 返回结果表。 查询结果格式如下例。 示例 1: 输入: Person 表: +----+---------+ | ","date":"2015-07-01","objectID":"/leetcode/0182/:1:0","tags":null,"title":"0182：查找重复的电子邮箱","uri":"/leetcode/0182/"},{"categories":null,"content":"分析 分组计数即可。 ","date":"2015-07-01","objectID":"/leetcode/0182/:2:0","tags":null,"title":"0182：查找重复的电子邮箱","uri":"/leetcode/0182/"},{"categories":null,"content":"解答 select Email from Person group by Email having count(Email) \u003e 1 394 ms ","date":"2015-07-01","objectID":"/leetcode/0182/:3:0","tags":null,"title":"0182：查找重复的电子邮箱","uri":"/leetcode/0182/"},{"categories":null,"content":" 力扣第 181 题 ","date":"2015-06-30","objectID":"/leetcode/0181/:0:0","tags":null,"title":"0181：超过经理收入的员工","uri":"/leetcode/0181/"},{"categories":null,"content":"题目 表：Employee +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | name | varchar | | salary | int | | managerId | int | +-------------+---------+ Id是该表的主键。 该表的每一行都表示雇员的ID、姓名、工资和经理的ID。 编写一个SQL查询来查找收入比经理高的员工。 以 任意顺序 返回结果表。 查询结果格式如下所示。 示例 1: 输入: Employee 表: +----+-","date":"2015-06-30","objectID":"/leetcode/0181/:1:0","tags":null,"title":"0181：超过经理收入的员工","uri":"/leetcode/0181/"},{"categories":null,"content":"分析 自连接并判断即可。 ","date":"2015-06-30","objectID":"/leetcode/0181/:2:0","tags":null,"title":"0181：超过经理收入的员工","uri":"/leetcode/0181/"},{"categories":null,"content":"解答 select a.name as Employee from Employee a inner join Employee b on a.managerId = b.id and a.salary \u003e b.salary 375 ms ","date":"2015-06-30","objectID":"/leetcode/0181/:3:0","tags":null,"title":"0181：超过经理收入的员工","uri":"/leetcode/0181/"},{"categories":null,"content":" 力扣第 180 题 ","date":"2015-06-29","objectID":"/leetcode/0180/:0:0","tags":null,"title":"0180：连续出现的数字（★）","uri":"/leetcode/0180/"},{"categories":null,"content":"题目 表：Logs +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | num | varchar | +-------------+---------+ id 是这个表的主键。 编写一个 SQL 查询，查找所有至少连续出现三次的数字。 返回的结果表中的数据可以按 任意顺序 排列。 查询结果格式如下面的例子所示： 示例 1: 输入： Logs 表： +----+-----+ | Id | Num | +----+-----+ | 1 | 1 | | 2 | 1 | |","date":"2015-06-29","objectID":"/leetcode/0180/:1:0","tags":null,"title":"0180：连续出现的数字（★）","uri":"/leetcode/0180/"},{"categories":null,"content":"分析 可以采用窗口函数 lag/lead。 ","date":"2015-06-29","objectID":"/leetcode/0180/:2:0","tags":null,"title":"0180：连续出现的数字（★）","uri":"/leetcode/0180/"},{"categories":null,"content":"解答 select distinct num as ConsecutiveNums from ( select num, lag(num, 1, null) over (order by id) prev, lead(num, 1, null) over (order by id) post from logs ) a where a.num = a.prev and a.num = a.post 536 ms ","date":"2015-06-29","objectID":"/leetcode/0180/:3:0","tags":null,"title":"0180：连续出现的数字（★）","uri":"/leetcode/0180/"},{"categories":null,"content":" 力扣第 179 题 ","date":"2015-06-28","objectID":"/leetcode/0179/:0:0","tags":null,"title":"0179：最大数（★）","uri":"/leetcode/0179/"},{"categories":null,"content":"题目 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。 示例 1： 输入：nums = [10,2] 输出：\"210\" 示例 2： 输入：nums = [3,30,34,5,9] 输出：\"9534330\" 提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 109 ","date":"2015-06-28","objectID":"/leetcode/0179/:1:0","tags":null,"title":"0179：最大数（★）","uri":"/leetcode/0179/"},{"categories":null,"content":"分析 首先想到按字典序降序拼接，但是某些情况并不适用。 例如 [3,30,34,5,9] 的字典序降序为 [9,5,34,30,3]，但正确的顺序应该是 [9,5,34,3,30]。 因此需要重新定义优先顺序。这里有个巧妙的想法，只要 $\\overline{AB}\u003e\\overline{BA}$，就认为 A 的优先级更高，应该排在前面。直觉告诉我们这样很可能是正确的，不过需要证明一下。 采用反证法： 假设最大结果 res 中存在 $\\overline{AB}\u003e\\overline{BA}$ 但 B 排在 A 的前面。 显然 B 和 A 不可能是相邻的，否则直接交换就得到更大的结果了。故res 是 ","date":"2015-06-28","objectID":"/leetcode/0179/:2:0","tags":null,"title":"0179：最大数（★）","uri":"/leetcode/0179/"},{"categories":null,"content":"解答 def largestNumber(self, nums: List[int]) -\u003e str: compare = lambda x,y: 1 if x+y\u003cy+x else -1 if x+y\u003ey+x else 0 res = ''.join(sorted(map(str, nums), key=cmp_to_key(compare))) return res.lstrip('0') or '0' 时间复杂度 $O(N*logN)$，44 ms ","date":"2015-06-28","objectID":"/leetcode/0179/:3:0","tags":null,"title":"0179：最大数（★）","uri":"/leetcode/0179/"},{"categories":null,"content":" 力扣第 178 题 ","date":"2015-06-27","objectID":"/leetcode/0178/:0:0","tags":null,"title":"0178：分数排名（★）","uri":"/leetcode/0178/"},{"categories":null,"content":"题目 表: Scores +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | score | decimal | +-------------+---------+ Id是该表的主键。 该表的每一行都包含了一场比赛的分数。Score是一个有两位小数点的浮点值。 编写 SQL 查询对分数进行排序。排名按以下规则计算: 分数应按从高到低排列。 如果两个分数相等，那么两个分数的排名应该相同。 在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的","date":"2015-06-27","objectID":"/leetcode/0178/:1:0","tags":null,"title":"0178：分数排名（★）","uri":"/leetcode/0178/"},{"categories":null,"content":"分析 调用 dense_rank 即可。 ","date":"2015-06-27","objectID":"/leetcode/0178/:2:0","tags":null,"title":"0178：分数排名（★）","uri":"/leetcode/0178/"},{"categories":null,"content":"解答 select score, dense_rank() over (order by score desc) as \"rank\" from Scores 280 ms ","date":"2015-06-27","objectID":"/leetcode/0178/:3:0","tags":null,"title":"0178：分数排名（★）","uri":"/leetcode/0178/"},{"categories":null,"content":" 力扣第 177 题 ","date":"2015-06-26","objectID":"/leetcode/0177/:0:0","tags":null,"title":"0177：第N高的薪水（★）","uri":"/leetcode/0177/"},{"categories":null,"content":"题目 表: Employee +-------------+------+ | Column Name | Type | +-------------+------+ | id | int | | salary | int | +-------------+------+ Id是该表的主键列。 该表的每一行都包含有关员工工资的信息。 编写一个SQL查询来报告 Employee 表中第 n 高的工资。如果没有第 n 个最高工资，查询应该报告为 null 。 查询结果格式如下所示。 示例 1: 输入: Employee table: +----+--------+ | id | salary | ","date":"2015-06-26","objectID":"/leetcode/0177/:1:0","tags":null,"title":"0177：第N高的薪水（★）","uri":"/leetcode/0177/"},{"categories":null,"content":"分析 0176 升级版，注意查找中不能运算 N-1，所以提前减 1。 ","date":"2015-06-26","objectID":"/leetcode/0177/:2:0","tags":null,"title":"0177：第N高的薪水（★）","uri":"/leetcode/0177/"},{"categories":null,"content":"解答 CREATE FUNCTION getNthHighestSalary ( N INT ) RETURNS INT BEGIN SET N = N - 1; RETURN ( # Write your MySQL query statement below. SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET N ); END 372 ms ","date":"2015-06-26","objectID":"/leetcode/0177/:3:0","tags":null,"title":"0177：第N高的薪水（★）","uri":"/leetcode/0177/"},{"categories":null,"content":" 力扣第 176 题 ","date":"2015-06-25","objectID":"/leetcode/0176/:0:0","tags":null,"title":"0176：第二高的薪水（★）","uri":"/leetcode/0176/"},{"categories":null,"content":"题目 Employee 表： +-------------+------+ | Column Name | Type | +-------------+------+ | id | int | | salary | int | +-------------+------+ id 是这个表的主键。 表的每一行包含员工的工资信息。 编写一个 SQL 查询，获取并返回 Employee 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 null 。 查询结果如下例所示。 示例 1： 输入： Employee 表： +----+--------+ | id | salary | +----+-","date":"2015-06-25","objectID":"/leetcode/0176/:1:0","tags":null,"title":"0176：第二高的薪水（★）","uri":"/leetcode/0176/"},{"categories":null,"content":"分析 按 salary 排序即可。注意： 要去掉重复值，用 distinct 没有时要返回 null，所以外面再套一层 ","date":"2015-06-25","objectID":"/leetcode/0176/:2:0","tags":null,"title":"0176：第二高的薪水（★）","uri":"/leetcode/0176/"},{"categories":null,"content":"解答 select ( select distinct salary from Employee order by salary desc limit 1 offset 1 ) as SecondHighestSalary 233 ms ","date":"2015-06-25","objectID":"/leetcode/0176/:3:0","tags":null,"title":"0176：第二高的薪水（★）","uri":"/leetcode/0176/"},{"categories":null,"content":" 力扣第 175 题 ","date":"2015-06-24","objectID":"/leetcode/0175/:0:0","tags":null,"title":"0175：组合两个表","uri":"/leetcode/0175/"},{"categories":null,"content":"题目 表: Person +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ personId 是该表的主键列。 该表包含一些人的 ID 和他们的姓和名的信息。 表: Address +-------------+---------+ | 列名 | 类型 | +-------------+---------+ | AddressId | ","date":"2015-06-24","objectID":"/leetcode/0175/:1:0","tags":null,"title":"0175：组合两个表","uri":"/leetcode/0175/"},{"categories":null,"content":"分析 左连接即可。 ","date":"2015-06-24","objectID":"/leetcode/0175/:2:0","tags":null,"title":"0175：组合两个表","uri":"/leetcode/0175/"},{"categories":null,"content":"解答 select p.firstName,p.lastName,a.city,a.state from Person p left join Address a on p.personId = a.personId 408 ms ","date":"2015-06-24","objectID":"/leetcode/0175/:3:0","tags":null,"title":"0175：组合两个表","uri":"/leetcode/0175/"},{"categories":null,"content":" 力扣第 174 题 ","date":"2015-06-23","objectID":"/leetcode/0174/:0:0","tags":null,"title":"0174：地下城游戏（★★）","uri":"/leetcode/0174/"},{"categories":null,"content":"题目 一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。 为了尽快到达公主，骑士决定每次只向右或向下移动一步。 编写一个函数来计算确保","date":"2015-06-23","objectID":"/leetcode/0174/:1:0","tags":null,"title":"0174：地下城游戏（★★）","uri":"/leetcode/0174/"},{"categories":null,"content":"分析 典型的矩阵 dp，按第一步向右或向下递归即可。 注意必须一直保持正整数。 ","date":"2015-06-23","objectID":"/leetcode/0174/:2:0","tags":null,"title":"0174：地下城游戏（★★）","uri":"/leetcode/0174/"},{"categories":null,"content":"解答 def calculateMinimumHP(self, dungeon: List[List[int]]) -\u003e int: @cache def dfs(i, j): if (i, j) == (m-1, n-1): return max(1, 1-dungeon[i][j]) res = min(dfs(x, y) for x, y in [(i+1, j), (i, j+1)] if x\u003cm and y\u003cn) return max(1, res-dungeon[i][j]) m, n = len(dungeon), len(dungeon[0]) return dfs(0, 0) ","date":"2015-06-23","objectID":"/leetcode/0174/:3:0","tags":null,"title":"0174：地下城游戏（★★）","uri":"/leetcode/0174/"},{"categories":null,"content":" 力扣第 173 题 ","date":"2015-06-22","objectID":"/leetcode/0173/:0:0","tags":null,"title":"0173：二叉搜索树迭代器（★）","uri":"/leetcode/0173/"},{"categories":null,"content":"题目 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器： BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。 boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。 int next()将指针向右移动，然后返回指针处的数字。 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用","date":"2015-06-22","objectID":"/leetcode/0173/:1:0","tags":null,"title":"0173：二叉搜索树迭代器（★）","uri":"/leetcode/0173/"},{"categories":null,"content":"分析 模拟中序遍历的过程即可。 为了方便，可以将遍历过程写在 hasNext 中，然后每次 next 时先调用 hasNext。 ","date":"2015-06-22","objectID":"/leetcode/0173/:2:0","tags":null,"title":"0173：二叉搜索树迭代器（★）","uri":"/leetcode/0173/"},{"categories":null,"content":"解答 class BSTIterator: def __init__(self, root: TreeNode): self.stack = [root] def next(self) -\u003e int: if self.hasNext(): return self.stack.pop() def hasNext(self) -\u003e bool: while self.stack: node = self.stack.pop() if isinstance(node, int): self.stack.append(node) return True if node: self.stack.exten","date":"2015-06-22","objectID":"/leetcode/0173/:3:0","tags":null,"title":"0173：二叉搜索树迭代器（★）","uri":"/leetcode/0173/"},{"categories":null,"content":" 力扣第 172 题 ","date":"2015-06-21","objectID":"/leetcode/0172/:0:0","tags":null,"title":"0172：阶乘后的零（★）","uri":"/leetcode/0172/"},{"categories":null,"content":"题目 给定一个整数 n ，返回 n! 结果中尾随零的数量。 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1 示例 1： 输入：n = 3 输出：0 解释：3! = 6 ，不含尾随 0 示例 2： 输入：n = 5 输出：1 解释：5! = 120 ，有一个尾随 0 示例 3： 输入：n = 0 输出：0 提示： 0 \u003c= n \u003c= 104 进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？ ","date":"2015-06-21","objectID":"/leetcode/0172/:1:0","tags":null,"title":"0172：阶乘后的零（★）","uri":"/leetcode/0172/"},{"categories":null,"content":"分析 数学分析： 结尾零的个数等于 n! 的质因数中 (2, 5) 对的个数 显然 5 更少，因此结果就等于因子 5 的个数 从 1 到 n ，含有 1 个因子 5 的个数是 n // 5，含有 2 个因子 5 的个数是 n // 25，依此类推 因此结果为： $$n // 5 + n // 25 + n // 125 + …$$ ","date":"2015-06-21","objectID":"/leetcode/0172/:2:0","tags":null,"title":"0172：阶乘后的零（★）","uri":"/leetcode/0172/"},{"categories":null,"content":"解答 def trailingZeroes(self, n: int) -\u003e int: res = 0 while n: n //= 5 res += n return res 28 ms ","date":"2015-06-21","objectID":"/leetcode/0172/:3:0","tags":null,"title":"0172：阶乘后的零（★）","uri":"/leetcode/0172/"},{"categories":null,"content":" 力扣第 171 题 ","date":"2015-06-20","objectID":"/leetcode/0171/:0:0","tags":null,"title":"0171：Excel 表列序号","uri":"/leetcode/0171/"},{"categories":null,"content":"题目 给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。 例如： A -\u003e 1 B -\u003e 2 C -\u003e 3 ... Z -\u003e 26 AA -\u003e 27 AB -\u003e 28 ... 示例 1: 输入: columnTitle = \"A\" 输出: 1 示例 2: 输入: columnTitle = \"AB\" 输出: 28 示例 3: 输入: columnTitle = \"ZY\" 输出: 701 提示： 1 \u003c= columnTitle.length \u003c= 7 columnTitle 仅由大写英文组成 columnTitle 在范围 [\"A\", \"","date":"2015-06-20","objectID":"/leetcode/0171/:1:0","tags":null,"title":"0171：Excel 表列序号","uri":"/leetcode/0171/"},{"categories":null,"content":"分析 类似 26 进制，只不过每一位的范围是 [1, 26] 而不是 [0, 25]。 ","date":"2015-06-20","objectID":"/leetcode/0171/:2:0","tags":null,"title":"0171：Excel 表列序号","uri":"/leetcode/0171/"},{"categories":null,"content":"解答 def titleToNumber(self, columnTitle: str) -\u003e int: res = 0 for char in columnTitle: res = res * 26 + ord(char) - ord('A') + 1 return res 36 ms ","date":"2015-06-20","objectID":"/leetcode/0171/:3:0","tags":null,"title":"0171：Excel 表列序号","uri":"/leetcode/0171/"},{"categories":null,"content":" 力扣第 170 题 ","date":"2015-06-19","objectID":"/leetcode/0170/:0:0","tags":null,"title":"0170：两数之和 III - 数据结构设计","uri":"/leetcode/0170/"},{"categories":null,"content":"题目 设计一个接收整数流的数据结构，该数据结构支持检查是否存在两数之和等于特定值。 实现 TwoSum 类： TwoSum() 使用空数组初始化 TwoSum 对象 void add(int number) 向数据结构添加一个数 number boolean find(int value) 寻找数据结构中是否存在一对整数，使得两数之和与给定的值相等。如果存在，返回 true ；否则，返回 false 。 示例： 输入： [\"TwoSum\", \"add\", \"add\", \"add\", \"find\", \"find\"] [[], [1], [3], [5], [4], [7]] 输出： [null,","date":"2015-06-19","objectID":"/leetcode/0170/:1:0","tags":null,"title":"0170：两数之和 III - 数据结构设计","uri":"/leetcode/0170/"},{"categories":null,"content":"分析 ","date":"2015-06-19","objectID":"/leetcode/0170/:2:0","tags":null,"title":"0170：两数之和 III - 数据结构设计","uri":"/leetcode/0170/"},{"categories":null,"content":"#1 最简单的是维护计数器 ct，查找 value 时遍历 x，看 value-x 是否在 ct 中即可。 注意当 x==value-x 的特殊情况，要满足 ct[x]\u003e=2 才可以。 class TwoSum: def __init__(self): self.ct = Counter() def add(self, number: int) -\u003e None: self.ct[number] += 1 def find(self, value: int) -\u003e bool: return any(self.ct.get(value-x, 0)\u003e=1+int(x==value-x) for x ","date":"2015-06-19","objectID":"/leetcode/0170/:2:1","tags":null,"title":"0170：两数之和 III - 数据结构设计","uri":"/leetcode/0170/"},{"categories":null,"content":"#2 由于数据较弱，所以 O(N^2) 能过。 用状态压缩的方法则可以保证能过： 用 st 维护数的集合，st2 维护两数之和的集合 为了避免负数，add 时 num 加上 10^5，find 时 value 加上 10^5*2 ","date":"2015-06-19","objectID":"/leetcode/0170/:2:2","tags":null,"title":"0170：两数之和 III - 数据结构设计","uri":"/leetcode/0170/"},{"categories":null,"content":"解答 class TwoSum: def __init__(self): self.st = 0 self.st2 = 0 def add(self, number: int) -\u003e None: x = number + 10**5 self.st2 |= self.st\u003c\u003cx self.st |= 1\u003c\u003cx def find(self, value: int) -\u003e bool: x = value+10**5*2 return 0\u003c=x\u003c=10**5*4 and self.st2\u0026(1\u003c\u003cx)\u003e0 280 ms ","date":"2015-06-19","objectID":"/leetcode/0170/:3:0","tags":null,"title":"0170：两数之和 III - 数据结构设计","uri":"/leetcode/0170/"},{"categories":null,"content":"　　主角莱莉因为父亲工作的因素举家搬迁至旧金山，要准备适应新环境，但就在此时，莱莉脑中控制欢乐与忧伤的两位脑内大臣乐乐与忧忧迷失在茫茫脑海中，大脑总部只剩下掌管愤怒、害怕与厌恶的三位干部负责，导致本来乐观的莱莉变成愤世忌俗少女。乐乐与忧忧必须要尽快在复杂的脑中世界回到大脑总部，让莱莉重拾原本快乐正常的情绪……","date":"2015-06-19","objectID":"/anime/inside_out/","tags":null,"title":"头脑特工队","uri":"/anime/inside_out/"},{"categories":null,"content":"简介 主角莱莉因为父亲工作的因素举家搬迁至旧金山，要准备适应新环境，但就在此时，莱莉脑中控制欢乐与忧伤的两位脑内大臣乐乐与忧忧迷失在茫茫脑海中，大脑总部只剩下掌管愤怒、害怕与厌恶的三位干部负责，导致本来乐观的莱莉变成愤世忌俗少女。乐乐与忧忧必须要尽快在复杂的脑中世界回到大脑总部，让莱莉重拾原本快乐正常的情绪…… 制作人员： 导演：彼特·道格特 製作：迪士尼电影公司 动画制作：皮克斯动画工作室 ","date":"2015-06-19","objectID":"/anime/inside_out/:1:0","tags":null,"title":"头脑特工队","uri":"/anime/inside_out/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 头脑特工队 2015-06-19 1 樱花 ","date":"2015-06-19","objectID":"/anime/inside_out/:2:0","tags":null,"title":"头脑特工队","uri":"/anime/inside_out/"},{"categories":null,"content":" 力扣第 169 题 ","date":"2015-06-18","objectID":"/leetcode/0169/:0:0","tags":null,"title":"0169：多数元素","uri":"/leetcode/0169/"},{"categories":null,"content":"题目 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 输入：nums = [3,2,3] 输出：3 示例 2： 输入：nums = [2,2,1,1,1,2,2] 输出：2 提示： n == nums.length 1 \u003c= n \u003c= 5 * 104 -109 \u003c= nums[i] \u003c= 109 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。 ","date":"2015-06-18","objectID":"/leetcode/0169/:1:0","tags":null,"title":"0169：多数元素","uri":"/leetcode/0169/"},{"categories":null,"content":"分析 ","date":"2015-06-18","objectID":"/leetcode/0169/:2:0","tags":null,"title":"0169：多数元素","uri":"/leetcode/0169/"},{"categories":null,"content":"#1 时间复杂度 O(N) 很简单，直接计数即可。 def majorityElement(self, nums: List[int]) -\u003e int: ct = Counter(nums) return max(ct, key=ct.get) ","date":"2015-06-18","objectID":"/leetcode/0169/:2:1","tags":null,"title":"0169：多数元素","uri":"/leetcode/0169/"},{"categories":null,"content":"#2 要求空间复杂度 O(1)，有个经典的摩尔投票法 ： 在 nums 中任意消除两个不同的数直到剩下的数都相同 假如 nums 中存在多数元素，那么该元素必然会留下来 因此返回最终留下来的数即可 ","date":"2015-06-18","objectID":"/leetcode/0169/:2:2","tags":null,"title":"0169：多数元素","uri":"/leetcode/0169/"},{"categories":null,"content":"解答 def majorityElement(self, nums: List[int]) -\u003e int: cand, cnt = None, 0 for num in nums: cand = cand if cnt else num cnt += 1 if num == cand else -1 return cand 56 ms ","date":"2015-06-18","objectID":"/leetcode/0169/:3:0","tags":null,"title":"0169：多数元素","uri":"/leetcode/0169/"},{"categories":null,"content":" 力扣第 168 题 ","date":"2015-06-17","objectID":"/leetcode/0168/:0:0","tags":null,"title":"0168：Excel表列名称","uri":"/leetcode/0168/"},{"categories":null,"content":"题目 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。 例如： A -\u003e 1 B -\u003e 2 C -\u003e 3 ... Z -\u003e 26 AA -\u003e 27 AB -\u003e 28 ... 示例 1： 输入：columnNumber = 1 输出：\"A\" 示例 2： 输入：columnNumber = 28 输出：\"AB\" 示例 3： 输入：columnNumber = 701 输出：\"ZY\" 示例 4： 输入：columnNumber = 2147483647 输出：\"FXSHRXW\" 提示： 1 \u003c= columnNumber \u003c= 231 - 1 ","date":"2015-06-17","objectID":"/leetcode/0168/:1:0","tags":null,"title":"0168：Excel表列名称","uri":"/leetcode/0168/"},{"categories":null,"content":"分析 类似 26 进制，只不过每一位的范围是 [1, 26] 而不是 [0, 25]，注意每次除 26 之前先减一。 ","date":"2015-06-17","objectID":"/leetcode/0168/:2:0","tags":null,"title":"0168：Excel表列名称","uri":"/leetcode/0168/"},{"categories":null,"content":"解答 def convertToTitle(self, columnNumber: int) -\u003e str: res, n = '', columnNumber while n: n, r = divmod(n-1, 26) res = chr(ord('A')+r) + res return res 28 ms ","date":"2015-06-17","objectID":"/leetcode/0168/:3:0","tags":null,"title":"0168：Excel表列名称","uri":"/leetcode/0168/"},{"categories":null,"content":" 力扣第 167 题 ","date":"2015-06-16","objectID":"/leetcode/0167/:0:0","tags":null,"title":"0167：两数之和 II - 输入有序数组（★）","uri":"/leetcode/0167/"},{"categories":null,"content":"题目 给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 \u003c= index1 \u003c index2 \u003c= numbers.length 。 以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。 你所设计的解决方案必须只使用常量级的额外空间。 示例 1： 输入：n","date":"2015-06-16","objectID":"/leetcode/0167/:1:0","tags":null,"title":"0167：两数之和 II - 输入有序数组（★）","uri":"/leetcode/0167/"},{"categories":null,"content":"分析 类似 0001，可以用哈希表。 数组有序，也可以用双指针来解决： 初始指针 i、j 分别指向 numbers 的首尾。 如果 numbers[i]+numbers[j]\u003ctarget，则 numbers[i] 与任意 [i+1,j-1] 内的数相加更小，故可以不再考虑 numbers[i]，缩小查找范围为 [i+1,j]。 同理，如果 numbers[i]+numbers[j]\u003etarget，可以缩小查找范围为 [i, j-1]。 循环操作直到找到结果即可 ","date":"2015-06-16","objectID":"/leetcode/0167/:2:0","tags":null,"title":"0167：两数之和 II - 输入有序数组（★）","uri":"/leetcode/0167/"},{"categories":null,"content":"解答 def twoSum(self, numbers: List[int], target: int) -\u003e List[int]: i, j = 0, len(numbers) - 1 while numbers[i] + numbers[j] != target: if numbers[i] + numbers[j] \u003c target: i += 1 else: j -= 1 return [i+1, j+1] 40 ms ","date":"2015-06-16","objectID":"/leetcode/0167/:3:0","tags":null,"title":"0167：两数之和 II - 输入有序数组（★）","uri":"/leetcode/0167/"},{"categories":null,"content":" 力扣第 166 题 ","date":"2015-06-15","objectID":"/leetcode/0166/:0:0","tags":null,"title":"0166：分数到小数（★）","uri":"/leetcode/0166/"},{"categories":null,"content":"题目 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。 如果小数部分为循环小数，则将循环的部分括在括号内。 如果存在多个答案，只需返回 任意一个 。 对于所有给定的输入，保证 答案字符串的长度小于 104 。 示例 1： 输入：numerator = 1, denominator = 2 输出：\"0.5\" 示例 2： 输入：numerator = 2, denominator = 1 输出：\"2\" 示例 3： 输入：numerator = 4, denominator = 333 输出：\"0.(012)\" 提示： -231 \u003c= ","date":"2015-06-15","objectID":"/leetcode/0166/:1:0","tags":null,"title":"0166：分数到小数（★）","uri":"/leetcode/0166/"},{"categories":null,"content":"分析 模拟除法，用哈希表检测循环即可。注意边界条件较多： 转为两个非负数相除，并判断是否加上负号 若能整除，直接返回商，没有小数点 若不能整除，加上小数点，每轮相除，添加商 若除得尽，直接返回 若除不尽，用哈希表找到循环起点，添加括号即可 ","date":"2015-06-15","objectID":"/leetcode/0166/:2:0","tags":null,"title":"0166：分数到小数（★）","uri":"/leetcode/0166/"},{"categories":null,"content":"解答 def fractionToDecimal(self, numerator: int, denominator: int) -\u003e str: res = '' if numerator*denominator \u003e= 0 else '-' m, n = abs(numerator), abs(denominator) q, r = divmod(m, n) res += str(q) if r == 0: return res res += '.' d = {} while True: d[r] = len(res) q, r = divmod(r*10, n) res += str(q) ","date":"2015-06-15","objectID":"/leetcode/0166/:3:0","tags":null,"title":"0166：分数到小数（★）","uri":"/leetcode/0166/"},{"categories":null,"content":" 力扣第 165 题 ","date":"2015-06-14","objectID":"/leetcode/0165/:0:0","tags":null,"title":"0165：比较版本号（★）","uri":"/leetcode/0165/"},{"categories":null,"content":"题目 给你两个版本号 version1 和 version2 ，请你比较它们。 版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1","date":"2015-06-14","objectID":"/leetcode/0165/:1:0","tags":null,"title":"0165：比较版本号（★）","uri":"/leetcode/0165/"},{"categories":null,"content":"分析 把版本号按 ‘.’ 分割为数组，依次比较即可。 ","date":"2015-06-14","objectID":"/leetcode/0165/:2:0","tags":null,"title":"0165：比较版本号（★）","uri":"/leetcode/0165/"},{"categories":null,"content":"解答 def compareVersion(self, version1: str, version2: str) -\u003e int: A, B = version1.split('.'), version2.split('.') for a, b in zip_longest(A, B, fillvalue=0): a, b = int(a), int(b) if a != b: return 1 if a \u003e b else -1 return 0 32 ms ","date":"2015-06-14","objectID":"/leetcode/0165/:3:0","tags":null,"title":"0165：比较版本号（★）","uri":"/leetcode/0165/"},{"categories":null,"content":" 力扣第 164 题 ","date":"2015-06-13","objectID":"/leetcode/0164/:0:0","tags":null,"title":"0164：最大间距（★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"题目 给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。 您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。 示例 1: 输入: nums = [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 输入: nums = [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 提示: 1 \u003c= nums.length \u003c= 105 0 \u003c= nums[i] \u003c= 109 ","date":"2015-06-13","objectID":"/leetcode/0164/:1:0","tags":null,"title":"0164：最大间距（★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"分析 ","date":"2015-06-13","objectID":"/leetcode/0164/:2:0","tags":null,"title":"0164：最大间距（★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"#1 最简单的是排序后遍历间距即可。 def maximumGap(self, nums: List[int]) -\u003e int: return max([b-a for a,b in pairwise(sorted(nums))], default=0) 180 ms ","date":"2015-06-13","objectID":"/leetcode/0164/:2:1","tags":null,"title":"0164：最大间距（★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"#2 要求线性时间排序，数据范围又较大，考虑用桶排序。 根据抽屉原理，最大间距必定 \u003e= (max(nums)-min(nums)) // (N-1) 取该下界作为桶长 size，桶内元素的间距小于最大间距，无需再比较 比较相邻桶的间距即可，而最多 N 个桶，故满足 O(N) 时间 特别注意 size 不能取 0 ","date":"2015-06-13","objectID":"/leetcode/0164/:2:2","tags":null,"title":"0164：最大间距（★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"解答 def maximumGap(self, nums: List[int]) -\u003e int: n, Min, Max = len(nums), min(nums), max(nums) if n \u003c 2: return 0 B, size = defaultdict(list), max(1, (Max-Min)//(n-1)) for x in nums: B[x//size].append(x) res, pre = 0, float('inf') for key in range(Min//size, Max//size+1): if key in B: res = max(res,","date":"2015-06-13","objectID":"/leetcode/0164/:3:0","tags":null,"title":"0164：最大间距（★★）","uri":"/leetcode/0164/"},{"categories":null,"content":" 力扣第 163 题 ","date":"2015-06-12","objectID":"/leetcode/0163/:0:0","tags":null,"title":"0163：缺失的区间","uri":"/leetcode/0163/"},{"categories":null,"content":"题目 给定一个排序的整数数组 nums ，其中元素的范围在 闭区间 [lower, upper] 当中，返回不包含在数组中的缺失区间。 示例： 输入: nums = [0, 1, 3, 50, 75], lower = 0 和 upper = 99, 输出: [\"2\", \"4-\u003e49\", \"51-\u003e74\", \"76-\u003e99\"] ","date":"2015-06-12","objectID":"/leetcode/0163/:1:0","tags":null,"title":"0163：缺失的区间","uri":"/leetcode/0163/"},{"categories":null,"content":"分析 遍历 nums 的间隔并分类按格式添加即可。 为了方便，可以将 lower-1、upper+1 也添加到 nums 中，一次遍历即可。 ","date":"2015-06-12","objectID":"/leetcode/0163/:2:0","tags":null,"title":"0163：缺失的区间","uri":"/leetcode/0163/"},{"categories":null,"content":"解答 def findMissingRanges(self, nums: List[int], lower: int, upper: int) -\u003e List[str]: res = [] for a, b in pairwise([lower-1]+nums+[upper+1]): if b-a\u003e=2: s = '%d-\u003e%d'%(a+1, b-1) if b-a\u003e2 else str(a+1) res.append(s) return res 32 ms ","date":"2015-06-12","objectID":"/leetcode/0163/:3:0","tags":null,"title":"0163：缺失的区间","uri":"/leetcode/0163/"},{"categories":null,"content":" 力扣第 162 题 ","date":"2015-06-11","objectID":"/leetcode/0162/:0:0","tags":null,"title":"0162：寻找峰值（★）","uri":"/leetcode/0162/"},{"categories":null,"content":"题目 峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞ 。 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。 示例 1： 输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2： 输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示： ","date":"2015-06-11","objectID":"/leetcode/0162/:1:0","tags":null,"title":"0162：寻找峰值（★）","uri":"/leetcode/0162/"},{"categories":null,"content":"分析 显然最大值即是一个峰值。但要求时间复杂度 O(log N)，考虑二分查找。 nums[mid] \u003e max(nums[mid-1], nums[mid+1])，mid 即为所求 nums[mid] \u003c nums[mid+1]，[mid+1, n-1] 范围内必然有一个峰值 nums[mid] \u003c nums[mid-1]，[0, mid-1] 范围内必然有一个峰值 ","date":"2015-06-11","objectID":"/leetcode/0162/:2:0","tags":null,"title":"0162：寻找峰值（★）","uri":"/leetcode/0162/"},{"categories":null,"content":"解答 def findPeakElement(self, nums: List[int]) -\u003e int: n = len(nums) i, j = 0, n - 1 while i \u003c= j: mid = i + (j - i) // 2 if (mid == 0 or nums[mid] \u003e nums[mid-1]) and (mid == n-1 or nums[mid] \u003e nums[mid+1]): return mid if nums[mid] \u003c nums[mid+1]: i = mid + 1 else: j = mid - 1 32 ms ","date":"2015-06-11","objectID":"/leetcode/0162/:3:0","tags":null,"title":"0162：寻找峰值（★）","uri":"/leetcode/0162/"},{"categories":null,"content":" 力扣第 161 题 ","date":"2015-06-10","objectID":"/leetcode/0161/:0:0","tags":null,"title":"0161：相隔为 1 的编辑距离（★）","uri":"/leetcode/0161/"},{"categories":null,"content":"题目 给定两个字符串 s 和 t ，如果它们的编辑距离为 1 ，则返回 true ，否则返回 false 。 字符串 s 和字符串 t 之间满足编辑距离等于 1 有三种可能的情形： 往 s 中插入 恰好一个 字符得到 t 从 s 中删除 恰好一个 字符得到 t 在 s 中用 一个不同的字符 替换 恰好一个 字符得到 t 示例 1： 输入: s = \"ab\", t = \"acb\" 输出: true 解释: 可以将 'c' 插入字符串 s 来得到 t。 示例 2: 输入: s = \"cab\", t = \"ad\" 输出: false 解释: 无法通过 1 步操作使 s 变为 t。 提示: 0 \u003c= ","date":"2015-06-10","objectID":"/leetcode/0161/:1:0","tags":null,"title":"0161：相隔为 1 的编辑距离（★）","uri":"/leetcode/0161/"},{"categories":null,"content":"分析 分类讨论，设 s/t 长度分别为 m/n： 若 m==n，则有且仅有一个位置上不同 若 m==n+1，则 s 删掉一个后相同 若 m==n-1，则 t 删掉一个后相同 其它情况不可能 ","date":"2015-06-10","objectID":"/leetcode/0161/:2:0","tags":null,"title":"0161：相隔为 1 的编辑距离（★）","uri":"/leetcode/0161/"},{"categories":null,"content":"解答 def isOneEditDistance(self, s: str, t: str) -\u003e bool: m, n = len(s), len(t) if m==n: return sum(a!=b for a,b in zip(s,t))==1 if m==n+1: return any(s[:i]+s[i+1:]==t for i in range(m)) if m==n-1: return any(t[:i]+t[i+1:]==s for i in range(n)) return False 36 ms ","date":"2015-06-10","objectID":"/leetcode/0161/:3:0","tags":null,"title":"0161：相隔为 1 的编辑距离（★）","uri":"/leetcode/0161/"},{"categories":null,"content":" 力扣第 160 题 ","date":"2015-06-09","objectID":"/leetcode/0160/:0:0","tags":null,"title":"0160：相交链表","uri":"/leetcode/0160/"},{"categories":null,"content":"题目 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 自定义评测： 评测系统 的输入如下（你设计的程序 不适用 此输入）： intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0 listA - 第一个链表 listB - 第二个链表 skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数 skipB - 在 listB 中（从","date":"2015-06-09","objectID":"/leetcode/0160/:1:0","tags":null,"title":"0160：相交链表","uri":"/leetcode/0160/"},{"categories":null,"content":"分析 ","date":"2015-06-09","objectID":"/leetcode/0160/:2:0","tags":null,"title":"0160：相交链表","uri":"/leetcode/0160/"},{"categories":null,"content":"#1 最直接的是哈希。 def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u003e ListNode: p, q, vis = headA, headB, set() while p: vis.add(p) p = p.next while q: if q in vis: return q q = q.next return None 140 ms ","date":"2015-06-09","objectID":"/leetcode/0160/:2:1","tags":null,"title":"0160：相交链表","uri":"/leetcode/0160/"},{"categories":null,"content":"#2 要求 O(1) 空间，有个巧妙的方法。 初始指针 p、q 分别指向 A、B 链表开头 每轮 p、q 同时移动一步 p 到达 A 末尾时重定向到 B 开头，q 到达 B 末尾时重定向到 A 开头。 经过 (A长度+B长度-相交部分长度) 轮后 p、q 相遇在相交节点（或者是空节点） ","date":"2015-06-09","objectID":"/leetcode/0160/:2:2","tags":null,"title":"0160：相交链表","uri":"/leetcode/0160/"},{"categories":null,"content":"解答 def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u003e ListNode: p, q = headA, headB while p != q: p = p.next if p else headB q = q.next if q else headA return p 164 ms ","date":"2015-06-09","objectID":"/leetcode/0160/:3:0","tags":null,"title":"0160：相交链表","uri":"/leetcode/0160/"},{"categories":null,"content":" 力扣第 159 题 ","date":"2015-06-08","objectID":"/leetcode/0159/:0:0","tags":null,"title":"0159：至多包含两个不同字符的最长子串（★）","uri":"/leetcode/0159/"},{"categories":null,"content":"题目 给你一个字符串 s ，请你找出 至多 包含 两个不同字符 的最长子串，并返回该子串的长度。 示例 1： 输入：s = \"eceba\" 输出：3 解释：满足题目要求的子串是 \"ece\" ，长度为 3 。 示例 2： 输入：s = \"ccaabbb\" 输出：5 解释：满足题目要求的子串是 \"aabbb\" ，长度为 5 。 提示： 1 \u003c= s.length \u003c= 105 s 由英文字母组成 ","date":"2015-06-08","objectID":"/leetcode/0159/:1:0","tags":null,"title":"0159：至多包含两个不同字符的最长子串（★）","uri":"/leetcode/0159/"},{"categories":null,"content":"分析 典型的滑动窗口问题，维护至多 2 个不同字符的窗口，找最大窗口即可。 ","date":"2015-06-08","objectID":"/leetcode/0159/:2:0","tags":null,"title":"0159：至多包含两个不同字符的最长子串（★）","uri":"/leetcode/0159/"},{"categories":null,"content":"解答 def lengthOfLongestSubstringTwoDistinct(self, s: str) -\u003e int: res, d, i = 0, defaultdict(int), 0 for j, c in enumerate(s): d[c] += 1 while len(d)\u003e2: d[s[i]]-=1 if d[s[i]] == 0: del d[s[i]] i += 1 res = max(res, j-i+1) return res 352 ms ","date":"2015-06-08","objectID":"/leetcode/0159/:3:0","tags":null,"title":"0159：至多包含两个不同字符的最长子串（★）","uri":"/leetcode/0159/"},{"categories":null,"content":" 力扣第 158 题 ","date":"2015-06-07","objectID":"/leetcode/0158/:0:0","tags":null,"title":"0158：用 Read4 读取 N 个字符 II（★★）","uri":"/leetcode/0158/"},{"categories":null,"content":"题目 给你一个文件 file ，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够使 read 读取 n 个字符。注意：你的 read 方法可能会被调用多次。 read4 的定义： read4 API 从文件中读取 4 个连续的字符，然后将这些字符写入缓冲区数组 buf4 。 返回值是读取的实际字符数。 请注意，read4() 有其自己的文件指针，类似于 C 中的 FILE * fp 。 参数类型: char[] buf4 返回类型: int 注意: buf4[] 是目标缓存区不是源缓存区，read4 的返回结果将会复制到 buf4[] 当中。 下列是一些使用 read4","date":"2015-06-07","objectID":"/leetcode/0158/:1:0","tags":null,"title":"0158：用 Read4 读取 N 个字符 II（★★）","uri":"/leetcode/0158/"},{"categories":null,"content":"分析 0157 升级版，需要连续多次读取： 注意一次读取后，从 buf4 拿到的字符可能没用完，所以额外维护缓存数组 tmp 每次读取时，先读取到 tmp 中，再从 tmp 读取到 buf ","date":"2015-06-07","objectID":"/leetcode/0158/:2:0","tags":null,"title":"0158：用 Read4 读取 N 个字符 II（★★）","uri":"/leetcode/0158/"},{"categories":null,"content":"解答 class Solution: def __init__(self): self.tmp = [] def read(self, buf: List[str], n: int) -\u003e int: buf4 = ['']*4 while len(self.tmp)\u003cn: x = read4(buf4) self.tmp.extend(buf4[:x]) if x \u003c 4: break i = min(len(self.tmp), n) buf[:i] = self.tmp[:i] self.tmp = self.tmp[i:] return i 24 ms ","date":"2015-06-07","objectID":"/leetcode/0158/:3:0","tags":null,"title":"0158：用 Read4 读取 N 个字符 II（★★）","uri":"/leetcode/0158/"},{"categories":null,"content":" 力扣第 157 题 ","date":"2015-06-06","objectID":"/leetcode/0157/:0:0","tags":null,"title":"0157：用 Read4 读取 N 个字符","uri":"/leetcode/0157/"},{"categories":null,"content":"题目 给你一个文件，并且该文件只能通过给定的 read4 方法来读取，请实现一个方法使其能够读取 n 个字符。 read4 方法： API read4 可以从文件中读取 4 个连续的字符，并且将它们写入缓存数组 buf 中。 返回值为实际读取的字符个数。 注意 read4() 自身拥有文件指针，很类似于 C 语言中的 FILE *fp 。 read4 的定义： 参数类型: char[] buf4 返回类型: int 注意: buf4[] 是目标缓存区不是源缓存区，read4 的返回结果将会复制到 buf4[] 当中。 下列是一些使用 read4 的例子： File file(\"abcde\");","date":"2015-06-06","objectID":"/leetcode/0157/:1:0","tags":null,"title":"0157：用 Read4 读取 N 个字符","uri":"/leetcode/0157/"},{"categories":null,"content":"分析 模拟即可： 初始 buf 下标 i=0，buf4=[’’]*4 每轮调用 read4(buf4) 方法，读取 x 个字符 将 buf4[:x] 写入到 buf[i:i+x] 中，并更新 i 为 i+x x\u003c4 或 i\u003e=n 时即代表读完了 ","date":"2015-06-06","objectID":"/leetcode/0157/:2:0","tags":null,"title":"0157：用 Read4 读取 N 个字符","uri":"/leetcode/0157/"},{"categories":null,"content":"解答 def read(self, buf, n): i, buf4 = 0, ['']*4 while i\u003cn: x = read4(buf4) buf[i:i+x] = buf4[:x] i += x if x \u003c 4: break return min(i, n) 24 ms ","date":"2015-06-06","objectID":"/leetcode/0157/:3:0","tags":null,"title":"0157：用 Read4 读取 N 个字符","uri":"/leetcode/0157/"},{"categories":null,"content":" 力扣第 156 题 ","date":"2015-06-05","objectID":"/leetcode/0156/:0:0","tags":null,"title":"0156：上下翻转二叉树（★）","uri":"/leetcode/0156/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ，请你将此二叉树上下翻转，并返回新的根节点。 你可以按下面的步骤翻转一棵二叉树： 原来的左子节点变成新的根节点 原来的根节点变成新的右子节点 原来的右子节点变成新的左子节点 上面的步骤逐层进行。题目数据保证每个右节点都有一个同级节点（即共享同一父节点的左节点）且不存在子节点。 示例 1： 输入：root = [1,2,3,4,5] 输出：[4,5,2,null,null,3,1] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 10] 内 1 \u003c= Node.va","date":"2015-06-05","objectID":"/leetcode/0156/:1:0","tags":null,"title":"0156：上下翻转二叉树（★）","uri":"/leetcode/0156/"},{"categories":null,"content":"分析 注意树中的每个右节点都没有子节点。因此先递归把左子树翻转了，再修改左节点和根节点的指针即可。 ","date":"2015-06-05","objectID":"/leetcode/0156/:2:0","tags":null,"title":"0156：上下翻转二叉树（★）","uri":"/leetcode/0156/"},{"categories":null,"content":"解答 def upsideDownBinaryTree(self, root: Optional[TreeNode]) -\u003e Optional[TreeNode]: if not root or not root.left: return root new = self.upsideDownBinaryTree(root.left) root.left.left = root.right root.left.right = root root.left = root.right = None return new 20 ms ","date":"2015-06-05","objectID":"/leetcode/0156/:3:0","tags":null,"title":"0156：上下翻转二叉树（★）","uri":"/leetcode/0156/"},{"categories":null,"content":" 力扣第 155 题 ","date":"2015-06-04","objectID":"/leetcode/0155/:0:0","tags":null,"title":"0155：最小栈（★）","uri":"/leetcode/0155/"},{"categories":null,"content":"题目 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 示例 1: 输入： [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null","date":"2015-06-04","objectID":"/leetcode/0155/:1:0","tags":null,"title":"0155：最小栈（★）","uri":"/leetcode/0155/"},{"categories":null,"content":"分析 每次入栈的同时保存当前最小值即可。 ","date":"2015-06-04","objectID":"/leetcode/0155/:2:0","tags":null,"title":"0155：最小栈（★）","uri":"/leetcode/0155/"},{"categories":null,"content":"解答 class MinStack: def __init__(self): self.stack = [] def push(self, val: int) -\u003e None: Min = min(self.stack[-1][1], val) if self.stack else val self.stack.append((val, Min)) def pop(self) -\u003e None: self.stack.pop() def top(self) -\u003e int: return self.stack[-1][0] def getMin(self) -\u003e int: return self.","date":"2015-06-04","objectID":"/leetcode/0155/:3:0","tags":null,"title":"0155：最小栈（★）","uri":"/leetcode/0155/"},{"categories":null,"content":" 力扣第 154 题 ","date":"2015-06-03","objectID":"/leetcode/0154/:0:0","tags":null,"title":"0154：寻找旋转排序数组中的最小值 II（★★）","uri":"/leetcode/0154/"},{"categories":null,"content":"题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返","date":"2015-06-03","objectID":"/leetcode/0154/:1:0","tags":null,"title":"0154：寻找旋转排序数组中的最小值 II（★★）","uri":"/leetcode/0154/"},{"categories":null,"content":"分析 直接调用 0153 的方法会出错， 因为有重复元素，可能 nums[0] 等于 nums[-1]，不满足二分条件。 那么不断弹出末尾元素使得 nums[0] \u003e nums[-1] 即可转换为 0153 。 注意 nums 全都相等的特殊情况。 ","date":"2015-06-03","objectID":"/leetcode/0154/:2:0","tags":null,"title":"0154：寻找旋转排序数组中的最小值 II（★★）","uri":"/leetcode/0154/"},{"categories":null,"content":"解答 def findMin(self, nums: List[int]) -\u003e int: while len(nums) \u003e 1 and nums[-1] == nums[0]: nums.pop() self.__class__.__getitem__ = lambda self, i: nums[i]\u003c=nums[-1] return nums[bisect_left(self, True, 0, len(nums)-1)] 36 ms ","date":"2015-06-03","objectID":"/leetcode/0154/:3:0","tags":null,"title":"0154：寻找旋转排序数组中的最小值 II（★★）","uri":"/leetcode/0154/"},{"categories":null,"content":" 力扣第 153 题 ","date":"2015-06-02","objectID":"/leetcode/0153/:0:0","tags":null,"title":"0153：寻找旋转排序数组中的最小值（★）","uri":"/leetcode/0153/"},{"categories":null,"content":"题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数","date":"2015-06-02","objectID":"/leetcode/0153/:1:0","tags":null,"title":"0153：寻找旋转排序数组中的最小值（★）","uri":"/leetcode/0153/"},{"categories":null,"content":"分析 以最小值位置 i 为界，nums[:i] 都大于 nums[-1]，nums[i:] 都小于等于 nums[-1]。 因此二分查找第一个小于等于 nums[-1] 的数即可。 ","date":"2015-06-02","objectID":"/leetcode/0153/:2:0","tags":null,"title":"0153：寻找旋转排序数组中的最小值（★）","uri":"/leetcode/0153/"},{"categories":null,"content":"解答 def findMin(self, nums: List[int]) -\u003e int: self.__class__.__getitem__ = lambda self, i: nums[i]\u003c=nums[-1] return nums[bisect_left(self, True, 0, len(nums)-1)] 24 ms ","date":"2015-06-02","objectID":"/leetcode/0153/:3:0","tags":null,"title":"0153：寻找旋转排序数组中的最小值（★）","uri":"/leetcode/0153/"},{"categories":null,"content":" 力扣第 152 题 ","date":"2015-06-01","objectID":"/leetcode/0152/:0:0","tags":null,"title":"0152：乘积最大子数组（★）","uri":"/leetcode/0152/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 子数组 是数组的连续子序列。 示例 1: 输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: nums = [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 提示: 1 \u003c= nums.length \u003c= 2 * 104 -10 \u003c= nums[i] \u003c= 10 nums 的任何前缀或后缀的乘积都 保证 是一","date":"2015-06-01","objectID":"/leetcode/0152/:1:0","tags":null,"title":"0152：乘积最大子数组（★）","uri":"/leetcode/0152/"},{"categories":null,"content":"分析 0053 进阶版，加法变成了乘法。 注意乘法的最值和正负有关。因此令 dp[j][0]、dp[j][1] 分别代表以位置 j 结尾的最小/大乘积，即可递推。 还可以优化为两个参数。 ","date":"2015-06-01","objectID":"/leetcode/0152/:2:0","tags":null,"title":"0152：乘积最大子数组（★）","uri":"/leetcode/0152/"},{"categories":null,"content":"解答 def maxProduct(self, nums: List[int]) -\u003e int: res, Min, Max = float('-inf'), 1, 1 for num in nums: Min, _, Max = sorted([num*Max, num*Min, num]) res = max(res, Max) return res 44 ms ","date":"2015-06-01","objectID":"/leetcode/0152/:3:0","tags":null,"title":"0152：乘积最大子数组（★）","uri":"/leetcode/0152/"},{"categories":null,"content":" 力扣第 151 题 ","date":"2015-05-31","objectID":"/leetcode/0151/:0:0","tags":null,"title":"0151：反转字符串中的单词（★）","uri":"/leetcode/0151/"},{"categories":null,"content":"题目 给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 示例 1： 输入：s = \"the sky is blue\" 输出：\"blue is sky the\" 示例 2： 输入：s = \" hello world \" 输出：\"world hello\" 解释：反转后的字符串中不能存在前导空格和尾随空","date":"2015-05-31","objectID":"/leetcode/0151/:1:0","tags":null,"title":"0151：反转字符串中的单词（★）","uri":"/leetcode/0151/"},{"categories":null,"content":"分析 按空格分割得到单词列表，将列表反转后再用空格拼接起来即可。 ","date":"2015-05-31","objectID":"/leetcode/0151/:2:0","tags":null,"title":"0151：反转字符串中的单词（★）","uri":"/leetcode/0151/"},{"categories":null,"content":"解答 def reverseWords(self, s: str) -\u003e str: return ' '.join(s.split()[::-1]) 24 ms ","date":"2015-05-31","objectID":"/leetcode/0151/:3:0","tags":null,"title":"0151：反转字符串中的单词（★）","uri":"/leetcode/0151/"},{"categories":null,"content":" 力扣第 150 题 ","date":"2015-05-30","objectID":"/leetcode/0150/:0:0","tags":null,"title":"0150：逆波兰表达式求值（★）","uri":"/leetcode/0150/"},{"categories":null,"content":"题目 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。 请你计算该表达式。返回一个表示表达式值的整数。 注意： 有效的算符为 '+'、'-'、'*' 和 '/' 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 示例 1： 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 输","date":"2015-05-30","objectID":"/leetcode/0150/:1:0","tags":null,"title":"0150：逆波兰表达式求值（★）","uri":"/leetcode/0150/"},{"categories":null,"content":"分析 栈的典型应用，每次遇到运算符出栈两个数字进行计算，将结果入栈即可。 注意 python 中 // 是向下取整，不满足要求，应该用 int(x/y) 。 ","date":"2015-05-30","objectID":"/leetcode/0150/:2:0","tags":null,"title":"0150：逆波兰表达式求值（★）","uri":"/leetcode/0150/"},{"categories":null,"content":"解答 def evalRPN(self, tokens: List[str]) -\u003e int: func = {'+': int.__add__, '-': int.__sub__, '*': int.__mul__, '/': lambda x,y: int(x/y)} stack = [] for token in tokens: if token in func: y, x = stack.pop(), stack.pop() stack.append(func[token](x, y)) else: stack.append(int(token)) return stack[0] 40","date":"2015-05-30","objectID":"/leetcode/0150/:3:0","tags":null,"title":"0150：逆波兰表达式求值（★）","uri":"/leetcode/0150/"},{"categories":null,"content":" 力扣第 149 题 ","date":"2015-05-29","objectID":"/leetcode/0149/:0:0","tags":null,"title":"0149：直线上最多的点数（★★）","uri":"/leetcode/0149/"},{"categories":null,"content":"题目 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。 示例 1： 输入：points = [[1,1],[2,2],[3,3]] 输出：3 示例 2： 输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] 输出：4 提示： 1 \u003c= points.length \u003c= 300 points[i].length == 2 -104 \u003c= xi, yi \u003c= 104 points 中的所有点 互不相同 ","date":"2015-05-29","objectID":"/leetcode/0149/:1:0","tags":null,"title":"0149：直线上最多的点数（★★）","uri":"/leetcode/0149/"},{"categories":null,"content":"分析 本题可能有重复点，因此不能按直线遍历，考虑按点来遍历： 对于点 i，首先统计重复个数 same 然后将其它点按斜率分组 最大的组大小加上 same 即可 考虑到精度问题，可以用最简分数来表示斜率，注意下不存在斜率的特殊情况即可。 ","date":"2015-05-29","objectID":"/leetcode/0149/:2:0","tags":null,"title":"0149：直线上最多的点数（★★）","uri":"/leetcode/0149/"},{"categories":null,"content":"解答 def maxPoints(self, points: List[List[int]]) -\u003e int: from fractions import Fraction res = 0 for p in points: d, same = defaultdict(int), 0 for q in points: if p==q: same += 1 else: key = str(Fraction(q[1]-p[1], q[0]-p[0])) if q[0]!=p[0] else '1/0' d[key] += 1 res = max(res, same+max(d.values(), d","date":"2015-05-29","objectID":"/leetcode/0149/:3:0","tags":null,"title":"0149：直线上最多的点数（★★）","uri":"/leetcode/0149/"},{"categories":null,"content":" 力扣第 148 题 ","date":"2015-05-28","objectID":"/leetcode/0148/:0:0","tags":null,"title":"0148：排序链表（★）","uri":"/leetcode/0148/"},{"categories":null,"content":"题目 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 示例 1： 输入：head = [4,2,1,3] 输出：[1,2,3,4] 示例 2： 输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5] 示例 3： 输入：head = [] 输出：[] 提示： 链表中节点的数目在范围 [0, 5 * 104] 内 -105 \u003c= Node.val \u003c= 105 进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ ","date":"2015-05-28","objectID":"/leetcode/0148/:1:0","tags":null,"title":"0148：排序链表（★）","uri":"/leetcode/0148/"},{"categories":null,"content":"分析 要求 O(n log n) 时间复杂度和常数级空间复杂度，马上想到快排和归并排序。 这里使用归并排序，用快慢指针找到中点，归并部分即问题 0021 。 ","date":"2015-05-28","objectID":"/leetcode/0148/:2:0","tags":null,"title":"0148：排序链表（★）","uri":"/leetcode/0148/"},{"categories":null,"content":"解答 def sortList(self, head: ListNode) -\u003e ListNode: def merge(l1, l2): dummy = l3 = ListNode() while l1 and l2: if l1.val \u003c= l2.val: l3.next = l1 l1 = l1.next else: l3.next = l2 l2 = l2.next l3 = l3.next l3.next = l1 if l1 else l2 return dummy.next if not head or not head.next: return head slow = fas","date":"2015-05-28","objectID":"/leetcode/0148/:3:0","tags":null,"title":"0148：排序链表（★）","uri":"/leetcode/0148/"},{"categories":null,"content":" 力扣第 147 题 ","date":"2015-05-27","objectID":"/leetcode/0147/:0:0","tags":null,"title":"0147：对链表进行插入排序（★）","uri":"/leetcode/0147/"},{"categories":null,"content":"题目 给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。 插入排序 算法的步骤: 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。 对链表进行插入排序。 示例 1： 输入: head = [4,2,1,3] 输出: [1,2,3,4] 示例 ","date":"2015-05-27","objectID":"/leetcode/0147/:1:0","tags":null,"title":"0147：对链表进行插入排序（★）","uri":"/leetcode/0147/"},{"categories":null,"content":"分析 维护两个指针 tail，cur 分别指向 已排序的结尾节点 和 当前要排序的节点。 若 cur.val \u003e= tail.val，就无需插入了，否则要在前面找插入位置 p，改变几个节点的指向。 ","date":"2015-05-27","objectID":"/leetcode/0147/:2:0","tags":null,"title":"0147：对链表进行插入排序（★）","uri":"/leetcode/0147/"},{"categories":null,"content":"解答 def insertionSortList(self, head: ListNode) -\u003e ListNode: dummy = ListNode(float('-inf'), next=head) tail, cur = dummy, head while cur: if tail.val \u003c= cur.val: tail = tail.next else: p = dummy while p.next.val \u003c= cur.val: p = p.next tail.next = cur.next cur.next = p.next p.next = cur cur = tail.ne","date":"2015-05-27","objectID":"/leetcode/0147/:3:0","tags":null,"title":"0147：对链表进行插入排序（★）","uri":"/leetcode/0147/"},{"categories":null,"content":" 力扣第 146 题 ","date":"2015-05-26","objectID":"/leetcode/0146/:0:0","tags":null,"title":"0146：LRU 缓存（★）","uri":"/leetcode/0146/"},{"categories":null,"content":"题目 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数 get 和","date":"2015-05-26","objectID":"/leetcode/0146/:1:0","tags":null,"title":"0146：LRU 缓存（★）","uri":"/leetcode/0146/"},{"categories":null,"content":"分析 ","date":"2015-05-26","objectID":"/leetcode/0146/:2:0","tags":null,"title":"0146：LRU 缓存（★）","uri":"/leetcode/0146/"},{"categories":null,"content":"#1 先考虑最简单的方法，用数组维护关键字的顺序: get 和 put 时将对应关键字移到最后面 容量达到上限时，弹出数组首个元素即可 class LRUCache: def __init__(self, capacity: int): self.A = [] self.d = {} self.capacity = capacity def get(self, key: int) -\u003e int: if key not in self.d: return -1 self.A.remove(key) self.A.append(key) return self.d[key] def put(sel","date":"2015-05-26","objectID":"/leetcode/0146/:2:1","tags":null,"title":"0146：LRU 缓存（★）","uri":"/leetcode/0146/"},{"categories":null,"content":"#2 要求 O(1) 时间完成 put() 和 get()，也就是 O(1) 时间内删除元素，在头部或尾部添加元素。 可以用双向链表+哈希表来实现。不过 python 有个更方便的 OrderedDict。 ","date":"2015-05-26","objectID":"/leetcode/0146/:2:2","tags":null,"title":"0146：LRU 缓存（★）","uri":"/leetcode/0146/"},{"categories":null,"content":"解答 class LRUCache: def __init__(self, capacity: int): self.d = OrderedDict() self.capacity = capacity def get(self, key: int) -\u003e int: if key not in self.d: return -1 self.d.move_to_end(key) return self.d[key] def put(self, key: int, value: int) -\u003e None: if key in self.d: self.d.move_to_end(key) elif","date":"2015-05-26","objectID":"/leetcode/0146/:3:0","tags":null,"title":"0146：LRU 缓存（★）","uri":"/leetcode/0146/"},{"categories":null,"content":" 力扣第 145 题 ","date":"2015-05-25","objectID":"/leetcode/0145/:0:0","tags":null,"title":"0145：二叉树的后序遍历","uri":"/leetcode/0145/"},{"categories":null,"content":"题目 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 示例 1： 输入：root = [1,null,2,3] 输出：[3,2,1] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 提示： 树中节点的数目在范围 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？ ","date":"2015-05-25","objectID":"/leetcode/0145/:1:0","tags":null,"title":"0145：二叉树的后序遍历","uri":"/leetcode/0145/"},{"categories":null,"content":"分析 ","date":"2015-05-25","objectID":"/leetcode/0145/:2:0","tags":null,"title":"0145：二叉树的后序遍历","uri":"/leetcode/0145/"},{"categories":null,"content":"#1 先写出递归算法，显然，将左子树的后序遍历、右子树的后序遍历、根节点拼接起来即可。 def postorderTraversal(self, root: TreeNode) -\u003e List[int]: return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] 36 ms ","date":"2015-05-25","objectID":"/leetcode/0145/:2:1","tags":null,"title":"0145：二叉树的后序遍历","uri":"/leetcode/0145/"},{"categories":null,"content":"#2 迭代算法类似 0094，入栈顺序换成 [节点值、右子树、左子树] 即可。 ","date":"2015-05-25","objectID":"/leetcode/0145/:2:2","tags":null,"title":"0145：二叉树的后序遍历","uri":"/leetcode/0145/"},{"categories":null,"content":"解答 def postorderTraversal(self, root: TreeNode) -\u003e List[int]: res, stack = [], [root] while stack: node = stack.pop() if isinstance(node, int): res.append(node) elif node: stack.extend([node.val, node.right, node.left]) return res 40 ms ","date":"2015-05-25","objectID":"/leetcode/0145/:3:0","tags":null,"title":"0145：二叉树的后序遍历","uri":"/leetcode/0145/"},{"categories":null,"content":" 力扣第 144 题 ","date":"2015-05-24","objectID":"/leetcode/0144/:0:0","tags":null,"title":"0144：二叉树的前序遍历","uri":"/leetcode/0144/"},{"categories":null,"content":"题目 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例 1： 输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[1,2] 示例 5： 输入：root = [1,null,2] 输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？ ","date":"2015-05-24","objectID":"/leetcode/0144/:1:0","tags":null,"title":"0144：二叉树的前序遍历","uri":"/leetcode/0144/"},{"categories":null,"content":"分析 ","date":"2015-05-24","objectID":"/leetcode/0144/:2:0","tags":null,"title":"0144：二叉树的前序遍历","uri":"/leetcode/0144/"},{"categories":null,"content":"#1 先写出递归算法，显然，将根节点、左子树的前序遍历、右子树的前序遍历拼接起来即可。 def preorderTraversal(self, root: TreeNode) -\u003e List[int]: return [root.val]+self.preorderTraversal(root.left)+self.preorderTraversal(root.right) if root else [] 40 ms ","date":"2015-05-24","objectID":"/leetcode/0144/:2:1","tags":null,"title":"0144：二叉树的前序遍历","uri":"/leetcode/0144/"},{"categories":null,"content":"#2 迭代算法类似 0094，入栈顺序换成 [右子树、左子树] ，节点值不需入栈直接输出即可。 ","date":"2015-05-24","objectID":"/leetcode/0144/:2:2","tags":null,"title":"0144：二叉树的前序遍历","uri":"/leetcode/0144/"},{"categories":null,"content":"解答 def preorderTraversal(self, root: TreeNode) -\u003e List[int]: res, stack = [], [root] while stack: node = stack.pop() if node: res.append(node.val) stack.extend([node.right, node.left]) return res 32 ms ","date":"2015-05-24","objectID":"/leetcode/0144/:3:0","tags":null,"title":"0144：二叉树的前序遍历","uri":"/leetcode/0144/"},{"categories":null,"content":" 力扣第 143 题 ","date":"2015-05-23","objectID":"/leetcode/0143/:0:0","tags":null,"title":"0143：重排链表（★）","uri":"/leetcode/0143/"},{"categories":null,"content":"题目 给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln - 1 → Ln 请将其重新排列后变为： L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1： 输入：head = [1,2,3,4] 输出：[1,4,2,3] 示例 2： 输入：head = [1,2,3,4,5] 输出：[1,5,2,4,3] 提示： 链表的长度范围为 [1, 5 * 104] 1 \u003c= node.val \u003c= 1000 ","date":"2015-05-23","objectID":"/leetcode/0143/:1:0","tags":null,"title":"0143：重排链表（★）","uri":"/leetcode/0143/"},{"categories":null,"content":"分析 先用快慢节点找到中点位置，截断为两部分，将后半部分链表反转后依次插入前半部分中即可。 反转链表即是问题 0206 。 ","date":"2015-05-23","objectID":"/leetcode/0143/:2:0","tags":null,"title":"0143：重排链表（★）","uri":"/leetcode/0143/"},{"categories":null,"content":"解答 def reorderList(self, head: ListNode) -\u003e None: def reverse(head): tail = head while tail and tail.next: tmp = tail.next tail.next = tmp.next tmp.next = head head = tmp return head slow = fast = ListNode(next=head) while fast and fast.next: slow, fast = slow.next, fast.next.next q = slow.next slow","date":"2015-05-23","objectID":"/leetcode/0143/:3:0","tags":null,"title":"0143：重排链表（★）","uri":"/leetcode/0143/"},{"categories":null,"content":" 力扣第 142 题 ","date":"2015-05-22","objectID":"/leetcode/0142/:0:0","tags":null,"title":"0142：环形链表 II（★）","uri":"/leetcode/0142/"},{"categories":null,"content":"题目 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：he","date":"2015-05-22","objectID":"/leetcode/0142/:1:0","tags":null,"title":"0142：环形链表 II（★）","uri":"/leetcode/0142/"},{"categories":null,"content":"分析 0141 升级版，依然可以用快慢指针解决： 假如环的周长为 L，入环位置为 x 当慢节点达到 x 时： 快节点走了 2*x 步，也就是说在环上走了 x 步 此时快节点距离慢节点 L-x%L，再经过 L-x%L 轮相遇 当快慢节点相遇时： 慢节点在环上走了 L-x%L 步 若慢节点再在环上走 x 步，即到达位置 x 于是有个巧妙的想法，此时令另一个慢节点从起点开始同步走，两个慢节点相遇位置即为位置 x ","date":"2015-05-22","objectID":"/leetcode/0142/:2:0","tags":null,"title":"0142：环形链表 II（★）","uri":"/leetcode/0142/"},{"categories":null,"content":"解答 def detectCycle(self, head: ListNode) -\u003e ListNode: slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: slow2 = head while slow != slow2: slow, slow2 = slow.next, slow2.next return slow return None 44 ms ","date":"2015-05-22","objectID":"/leetcode/0142/:3:0","tags":null,"title":"0142：环形链表 II（★）","uri":"/leetcode/0142/"},{"categories":null,"content":" 力扣第 141 题 ","date":"2015-05-21","objectID":"/leetcode/0141/:0:0","tags":null,"title":"0141：环形链表","uri":"/leetcode/0141/"},{"categories":null,"content":"题目 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true","date":"2015-05-21","objectID":"/leetcode/0141/:1:0","tags":null,"title":"0141：环形链表","uri":"/leetcode/0141/"},{"categories":null,"content":"分析 ","date":"2015-05-21","objectID":"/leetcode/0141/:2:0","tags":null,"title":"0141：环形链表","uri":"/leetcode/0141/"},{"categories":null,"content":"#1 最简单的就是哈希。 def hasCycle(self, head: ListNode) -\u003e bool: vis = set() while head: if head in vis: return True vis.add(head) head = head.next return False 48 ms ","date":"2015-05-21","objectID":"/leetcode/0141/:2:1","tags":null,"title":"0141：环形链表","uri":"/leetcode/0141/"},{"categories":null,"content":"#2 要求 O(1) 空间，本题有个经典的快慢指针解法： 初始快慢指针都指向表头 每轮快指针移动两步，慢指针移动一步 若链表无环，快指针先到达末尾，无法再移动 若链表有环，快慢指针将会在环中某节点相遇 ","date":"2015-05-21","objectID":"/leetcode/0141/:2:2","tags":null,"title":"0141：环形链表","uri":"/leetcode/0141/"},{"categories":null,"content":"解答 def hasCycle(self, head: ListNode) -\u003e bool: slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False 64 ms ","date":"2015-05-21","objectID":"/leetcode/0141/:3:0","tags":null,"title":"0141：环形链表","uri":"/leetcode/0141/"},{"categories":null,"content":" 力扣第 140 题 ","date":"2015-05-20","objectID":"/leetcode/0140/:0:0","tags":null,"title":"0140：单词拆分 II（★★）","uri":"/leetcode/0140/"},{"categories":null,"content":"题目 给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。 注意：词典中的同一个单词可能在分段中被重复使用多次。 示例 1： 输入:s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"] 输出:[\"cats and dog\",\"cat sand dog\"] 示例 2： 输入:s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"","date":"2015-05-20","objectID":"/leetcode/0140/:1:0","tags":null,"title":"0140：单词拆分 II（★★）","uri":"/leetcode/0140/"},{"categories":null,"content":"分析 0139 升级版，改下递归的返回值即可。 ","date":"2015-05-20","objectID":"/leetcode/0140/:2:0","tags":null,"title":"0140：单词拆分 II（★★）","uri":"/leetcode/0140/"},{"categories":null,"content":"解答 def wordBreak(self, s: str, wordDict: List[str]) -\u003e List[str]: @cache def dfs(s): if not s: return [[]] res = [] for i in range(len(s)): if s[:i+1] in W: res.extend([s[:i+1]]+sub for sub in dfs(s[i+1:])) return res W = set(wordDict) return [' '.join(sub) for sub in dfs(s)] 32 ms ","date":"2015-05-20","objectID":"/leetcode/0140/:3:0","tags":null,"title":"0140：单词拆分 II（★★）","uri":"/leetcode/0140/"},{"categories":null,"content":" 力扣第 139 题 ","date":"2015-05-19","objectID":"/leetcode/0139/:0:0","tags":null,"title":"0139：单词拆分（★）","uri":"/leetcode/0139/"},{"categories":null,"content":"题目 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例 1： 输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"] 输出: true 解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。 示例 2： 输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] 输出: true 解释: 返回 true 因为 \"appl","date":"2015-05-19","objectID":"/leetcode/0139/:1:0","tags":null,"title":"0139：单词拆分（★）","uri":"/leetcode/0139/"},{"categories":null,"content":"分析 典型的单串 dp，按第一个单词长度即可递归。 ","date":"2015-05-19","objectID":"/leetcode/0139/:2:0","tags":null,"title":"0139：单词拆分（★）","uri":"/leetcode/0139/"},{"categories":null,"content":"解答 def wordBreak(self, s: str, wordDict: List[str]) -\u003e bool: @cache def dfs(s): return not s or any(s[:i+1] in W and dfs(s[i+1:]) for i in range(len(s))) W = set(wordDict) return dfs(s) 48 ms ","date":"2015-05-19","objectID":"/leetcode/0139/:3:0","tags":null,"title":"0139：单词拆分（★）","uri":"/leetcode/0139/"},{"categories":null,"content":" 力扣第 138 题 ","date":"2015-05-18","objectID":"/leetcode/0138/:0:0","tags":null,"title":"0138：复制带随机指针的链表（★）","uri":"/leetcode/0138/"},{"categories":null,"content":"题目 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --\u003e Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --\u003e y 。 返回复制链表","date":"2015-05-18","objectID":"/leetcode/0138/:1:0","tags":null,"title":"0138：复制带随机指针的链表（★）","uri":"/leetcode/0138/"},{"categories":null,"content":"分析 ","date":"2015-05-18","objectID":"/leetcode/0138/:2:0","tags":null,"title":"0138：复制带随机指针的链表（★）","uri":"/leetcode/0138/"},{"categories":null,"content":"#1 最直接的就是维护原节点和新节点的映射 d： 遍历节点 p，若 p 在 d 中就跳过 若 p 不在 d 中，只拷贝值得到节点 p’，保存映射 \u003cp,p’\u003e 到 d 中 p.next/random 遍历完后，将 p’ 的 next/random 指向 p.next/random 的拷贝节点即可 def copyRandomList(self, head: 'Optional[Node]') -\u003e 'Optional[Node]': d, p = {head: Node(head.val) if head else None}, head while p: d[p].next = d.setd","date":"2015-05-18","objectID":"/leetcode/0138/:2:1","tags":null,"title":"0138：复制带随机指针的链表（★）","uri":"/leetcode/0138/"},{"categories":null,"content":"#2 本题还有个非常巧妙的方法，不用额外空间。 先将新节点 new 依次插入到原节点 old 的后面 那么 old.random.next 就应该是 new.random 最后再按顺序拆分出新节点，即满足了 next 的正确指向 ","date":"2015-05-18","objectID":"/leetcode/0138/:2:2","tags":null,"title":"0138：复制带随机指针的链表（★）","uri":"/leetcode/0138/"},{"categories":null,"content":"解答 def copyRandomList(self, head: 'Node') -\u003e 'Node': p = head while p: p.next = Node(p.val, p.next) p = p.next.next p = head while p: p.next.random = p.random.next if p.random else None p = p.next.next p = head dummy = q = Node(0) while p: q.next = p.next p.next = p.next.next p = p.next q = q.next r","date":"2015-05-18","objectID":"/leetcode/0138/:3:0","tags":null,"title":"0138：复制带随机指针的链表（★）","uri":"/leetcode/0138/"},{"categories":null,"content":" 力扣第 137 题 ","date":"2015-05-17","objectID":"/leetcode/0137/:0:0","tags":null,"title":"0137：只出现一次的数字 II（★）","uri":"/leetcode/0137/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法且不使用额外空间来解决此问题。 示例 1： 输入：nums = [2,2,3,2] 输出：3 示例 2： 输入：nums = [0,1,0,1,0,1,99] 输出：99 提示： 1 \u003c= nums.length \u003c= 3 * 104 -231 \u003c= nums[i] \u003c= 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 ","date":"2015-05-17","objectID":"/leetcode/0137/:1:0","tags":null,"title":"0137：只出现一次的数字 II（★）","uri":"/leetcode/0137/"},{"categories":null,"content":"分析 ","date":"2015-05-17","objectID":"/leetcode/0137/:2:0","tags":null,"title":"0137：只出现一次的数字 II（★）","uri":"/leetcode/0137/"},{"categories":null,"content":"#1 最简单的依然是哈希表。 def singleNumber(self, nums: List[int]) -\u003e int: return [x for x,freq in Counter(nums).items() if freq==1].pop() 32 ms ","date":"2015-05-17","objectID":"/leetcode/0137/:2:1","tags":null,"title":"0137：只出现一次的数字 II（★）","uri":"/leetcode/0137/"},{"categories":null,"content":"#2 要不用额外空间实现，有个非常巧妙的位运算方法：逻辑电路角度详细分析该题思路。 ","date":"2015-05-17","objectID":"/leetcode/0137/:2:2","tags":null,"title":"0137：只出现一次的数字 II（★）","uri":"/leetcode/0137/"},{"categories":null,"content":"解答 def singleNumber(self, nums: List[int]) -\u003e int: X, Y = 0, 0 for Z in nums: Y = Y^Z \u0026 ~X X = X^Z \u0026 ~Y return Y 48 ms ","date":"2015-05-17","objectID":"/leetcode/0137/:3:0","tags":null,"title":"0137：只出现一次的数字 II（★）","uri":"/leetcode/0137/"},{"categories":null,"content":" 力扣第 136 题 ","date":"2015-05-16","objectID":"/leetcode/0136/:0:0","tags":null,"title":"0136：只出现一次的数字","uri":"/leetcode/0136/"},{"categories":null,"content":"题目 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 示例 1 ： 输入：nums = [2,2,1] 输出：1 示例 2 ： 输入：nums = [4,1,2,1,2] 输出：4 示例 3 ： 输入：nums = [1] 输出：1 提示： 1 \u003c= nums.length \u003c= 3 * 104 -3 * 104 \u003c= nums[i] \u003c= 3 * 104 除了某个元素只出现一次以外，其余每个元素均出现两次。 ","date":"2015-05-16","objectID":"/leetcode/0136/:1:0","tags":null,"title":"0136：只出现一次的数字","uri":"/leetcode/0136/"},{"categories":null,"content":"分析 ","date":"2015-05-16","objectID":"/leetcode/0136/:2:0","tags":null,"title":"0136：只出现一次的数字","uri":"/leetcode/0136/"},{"categories":null,"content":"#1 最简单的就是哈希表。 def singleNumber(self, nums: List[int]) -\u003e int: return [x for x,freq in Counter(nums).items() if freq==1].pop() 40 ms ","date":"2015-05-16","objectID":"/leetcode/0136/:2:1","tags":null,"title":"0136：只出现一次的数字","uri":"/leetcode/0136/"},{"categories":null,"content":"#2 要求不用额外空间实现，有个非常巧妙的思路，利用了异或运算的特性。 满足交换律和结合律 x^x=0 x^0=x 可以推出：题目所给数组的所有元素的异或结果即为所求。 ","date":"2015-05-16","objectID":"/leetcode/0136/:2:2","tags":null,"title":"0136：只出现一次的数字","uri":"/leetcode/0136/"},{"categories":null,"content":"解答 def singleNumber(self, nums: List[int]) -\u003e int: return reduce(xor, nums) 40 ms ","date":"2015-05-16","objectID":"/leetcode/0136/:3:0","tags":null,"title":"0136：只出现一次的数字","uri":"/leetcode/0136/"},{"categories":null,"content":" 力扣第 135 题 ","date":"2015-05-15","objectID":"/leetcode/0135/:0:0","tags":null,"title":"0135：分发糖果（★★）","uri":"/leetcode/0135/"},{"categories":null,"content":"题目 n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 示例 1： 输入：ratings = [1,0,2] 输出：5 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 示例 2： 输入：ratings = [1,2,2] 输出：4 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 提示","date":"2015-05-15","objectID":"/leetcode/0135/:1:0","tags":null,"title":"0135：分发糖果（★★）","uri":"/leetcode/0135/"},{"categories":null,"content":"分析 考虑每个孩子最少多少颗： 对于孩子 i，假如左侧的严格递减序列长度为 left[i]，那么 i 至少 left[i] 颗 同理，假如右侧的严格递减序列长度为 right[i]，那么 i 至少 right[i] 颗 孩子 i 发 max(left[i],right[i]) 颗即可 left 和 right 数组可以一趟递推求出 ","date":"2015-05-15","objectID":"/leetcode/0135/:2:0","tags":null,"title":"0135：分发糖果（★★）","uri":"/leetcode/0135/"},{"categories":null,"content":"解答 def candy(self, ratings: List[int]) -\u003e int: n = len(ratings) left, right = [1] * n, [1] * n for i in range(1, n): left[i] = left[i-1] + 1 if ratings[i] \u003e ratings[i-1] else 1 for i in range(n-2, -1, -1): right[i] = right[i+1] + 1 if ratings[i] \u003e ratings[i+1] else 1 return sum(max(l, r) for l, r in","date":"2015-05-15","objectID":"/leetcode/0135/:3:0","tags":null,"title":"0135：分发糖果（★★）","uri":"/leetcode/0135/"},{"categories":null,"content":" 力扣第 134 题 ","date":"2015-05-14","objectID":"/leetcode/0134/:0:0","tags":null,"title":"0134：加油站（★）","uri":"/leetcode/0134/"},{"categories":null,"content":"题目 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例 1: 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升","date":"2015-05-14","objectID":"/leetcode/0134/:1:0","tags":null,"title":"0134：加油站（★）","uri":"/leetcode/0134/"},{"categories":null,"content":"分析 可以将 gas 和 cost 逐项相减得到数组 A，代表经过每段路的汽油变化。 问题等价于在 B=A+A 中找一个长度 len(A) 的子数组，其前缀和都非负。 具体实现时： 初始起点 i=0，从 i 开始遍历 j 遇到第一个 j 使得 sum(B[i:j])\u003c0 时： 对任意 (i,j) 范围内的 k： sum(B[i:k])\u003e=0 sum(B[k:j])=sum(B[i:j])-sum(B[i:k])\u003c0 故 k 不能作为起点 所以重置起点 i=j，重置遍历 否则，当 j-i==len(A) 时，即符合要求 ","date":"2015-05-14","objectID":"/leetcode/0134/:2:0","tags":null,"title":"0134：加油站（★）","uri":"/leetcode/0134/"},{"categories":null,"content":"解答 def canCompleteCircuit(self, gas: List[int], cost: List[int]) -\u003e int: A = [g-c for g,c in zip(gas, cost)] pre, i = 0, 0 for j, x in enumerate(A+A): pre += x if pre\u003c0: pre, i = 0, j+1 if j-i==len(A)-1: return i return -1 136 ms ","date":"2015-05-14","objectID":"/leetcode/0134/:3:0","tags":null,"title":"0134：加油站（★）","uri":"/leetcode/0134/"},{"categories":null,"content":"*附加 问题还可以转为：在 A+A 的前缀和数组 pre 中，找一个长度 len(A)+1 的子数组，满足其首位是最小元素。 容易想到直接找 pre 前半部分的最小位置 i 作为首位 注意 pre 的后半部分其实就是前半部分的元素分别加上 sum(A) 如果 sum(A)\u003c0，则 pre[i+len(A)]\u003cpre[i]，没有满足要求的 i 如果 sum(A)\u003e=0，那么 i 就是符合要求的位置 最后 (i+1)%len(A) 即为所求。 def canCompleteCircuit(self, gas: List[int], cost: List[int]) -\u003e int: pre = li","date":"2015-05-14","objectID":"/leetcode/0134/:4:0","tags":null,"title":"0134：加油站（★）","uri":"/leetcode/0134/"},{"categories":null,"content":" 力扣第 133 题 ","date":"2015-05-13","objectID":"/leetcode/0133/:0:0","tags":null,"title":"0133：克隆图（★）","uri":"/leetcode/0133/"},{"categories":null,"content":"题目 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 class Node { public int val; public List\u003cNode\u003e neighbors; } 测试用例格式： 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必须","date":"2015-05-13","objectID":"/leetcode/0133/:1:0","tags":null,"title":"0133：克隆图（★）","uri":"/leetcode/0133/"},{"categories":null,"content":"分析 考虑在遍历时维护 \u003c原节点,克隆节点\u003e 的映射 d，即可解决循环的问题： 遍历到节点 u ，若 u 在 d 中则跳过 若 u 不在 d 中，只克隆值得到节点 u’，保存映射 \u003cu,u’\u003e 到 d 当 u 的邻居 v 遍历完后，将 v 的克隆 v’ 添加到 u’ 的邻居列表中即可 遍历可以用 bfs，也可以用 dfs： 用 bfs 时注意入队前就应克隆，防止重复入队。 用 dfs 时注意不能用 d.get(v, dfs(v)) 来简化。即使元素在 dict 中，dict.get 的 default 也会执行，只不过不返回该值。 ","date":"2015-05-13","objectID":"/leetcode/0133/:2:0","tags":null,"title":"0133：克隆图（★）","uri":"/leetcode/0133/"},{"categories":null,"content":"解答 def cloneGraph(self, node: 'Node') -\u003e 'Node': def dfs(u): d[u] = Node(u.val) d[u].neighbors = [d[v] if v in d else dfs(v) for v in u.neighbors] return d[u] d = {} return dfs(node) if node else None 40 ms ","date":"2015-05-13","objectID":"/leetcode/0133/:3:0","tags":null,"title":"0133：克隆图（★）","uri":"/leetcode/0133/"},{"categories":null,"content":" 力扣第 132 题 ","date":"2015-05-12","objectID":"/leetcode/0132/:0:0","tags":null,"title":"0132：分割回文串 II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"题目 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。 返回符合要求的 最少分割次数 。 示例 1： 输入：s = \"aab\" 输出：1 解释：只需一次分割就可将 s 分割成 [\"aa\",\"b\"] 这样两个回文子串。 示例 2： 输入：s = \"a\" 输出：0 示例 3： 输入：s = \"ab\" 输出：1 提示： 1 \u003c= s.length \u003c= 2000 s 仅由小写英文字母组成 ","date":"2015-05-12","objectID":"/leetcode/0132/:1:0","tags":null,"title":"0132：分割回文串 II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"分析 ","date":"2015-05-12","objectID":"/leetcode/0132/:2:0","tags":null,"title":"0132：分割回文串 II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"#1 类似 0131，可以递归。 要注意的是若本身就是回文串，应直接返回 0。 def minCut(self, s: str) -\u003e int: @cache def dfs(i): if s[i:] == s[i:][::-1]: return 0 res = float('inf') for j in range(i+1, len(s)): if s[i:j] == s[i:j][::-1]: res = min(res, 1+dfs(j)) return res return dfs(0) 1784 ms ","date":"2015-05-12","objectID":"/leetcode/0132/:2:1","tags":null,"title":"0132：分割回文串 II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"#2 观察可发现，有很多重复判断 s 的子串是否回文。根据 0005，也可以用动态规划解决。 另外，求最小分割也可以改成动态规划的非递归形式，节省空间。 ","date":"2015-05-12","objectID":"/leetcode/0132/:2:2","tags":null,"title":"0132：分割回文串 II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"解答 def minCut(self, s: str) -\u003e int: n = len(s) f = [[True]*n for _ in range(n)] for j in range(n): for i in range(j): f[i][j] = f[i+1][j-1] and s[i]==s[j] dp = [0]*n for i in range(n): dp[i] = 0 if f[0][i] else 1+min(dp[j] for j in range(i) if f[j+1][i]) return dp[-1] 时间复杂度 O(N^2)，572 ms ","date":"2015-05-12","objectID":"/leetcode/0132/:3:0","tags":null,"title":"0132：分割回文串 II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":" 力扣第 131 题 ","date":"2015-05-11","objectID":"/leetcode/0131/:0:0","tags":null,"title":"0131：分割回文串（★）","uri":"/leetcode/0131/"},{"categories":null,"content":"题目 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 示例 1： 输入：s = \"aab\" 输出：[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]] 示例 2： 输入：s = \"a\" 输出：[[\"a\"]] 提示： 1 \u003c= s.length \u003c= 16 s 仅由小写英文字母组成 ","date":"2015-05-11","objectID":"/leetcode/0131/:1:0","tags":null,"title":"0131：分割回文串（★）","uri":"/leetcode/0131/"},{"categories":null,"content":"分析 典型的单串 dp，按第一个回文子串的长度可以递归。 ","date":"2015-05-11","objectID":"/leetcode/0131/:2:0","tags":null,"title":"0131：分割回文串（★）","uri":"/leetcode/0131/"},{"categories":null,"content":"解答 def partition(self, s: str) -\u003e List[List[str]]: @cache def dfs(i): if i==len(s): return [[]] res = [] for j in range(i+1, len(s)+1): pre = s[i:j] if pre == pre[::-1]: res.extend([pre]+sub for sub in dfs(j)) return res return dfs(0) 88 ms ","date":"2015-05-11","objectID":"/leetcode/0131/:3:0","tags":null,"title":"0131：分割回文串（★）","uri":"/leetcode/0131/"},{"categories":null,"content":" 力扣第 130 题 ","date":"2015-05-10","objectID":"/leetcode/0130/:0:0","tags":null,"title":"0130：被围绕的区域（★）","uri":"/leetcode/0130/"},{"categories":null,"content":"题目 给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例 1： 输入：board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] 输出：[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何","date":"2015-05-10","objectID":"/leetcode/0130/:1:0","tags":null,"title":"0130：被围绕的区域（★）","uri":"/leetcode/0130/"},{"categories":null,"content":"分析 本题可以用 dfs 或 bfs 遍历找到所有与边界外连通的 ‘O’，剩下的 ‘O’ 换成 ‘X’ 即可。 不过连通问题一般还是用并查集，方便进阶问题的解决。 并查集做法： 将边界上的 ‘O’ 都与哑节点 dummy 连通， 再将相邻的 ‘O’ 连通。 将不与 dummy 连通的 ‘O’ 换成 ‘X’ 即可 ","date":"2015-05-10","objectID":"/leetcode/0130/:2:0","tags":null,"title":"0130：被围绕的区域（★）","uri":"/leetcode/0130/"},{"categories":null,"content":"解答 def solve(self, board: List[List[str]]) -\u003e None: def find(x): if f.setdefault(x, x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) m, n = len(board), len(board[0]) f, dummy = {}, (-1, -1) for i, j in product(range(m), range(n)): if board[i][j] == 'O': if i in [0, m - 1]","date":"2015-05-10","objectID":"/leetcode/0130/:3:0","tags":null,"title":"0130：被围绕的区域（★）","uri":"/leetcode/0130/"},{"categories":null,"content":" 力扣第 129 题 ","date":"2015-05-09","objectID":"/leetcode/0129/:0:0","tags":null,"title":"0129：求根节点到叶节点数字之和（★）","uri":"/leetcode/0129/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。 每条从根节点到叶节点的路径都代表一个数字： 例如，从根节点到叶节点的路径 1 -\u003e 2 -\u003e 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。 叶节点 是指没有子节点的节点。 示例 1： 输入：root = [1,2,3] 输出：25 解释： 从根到叶子节点路径 1-\u003e2 代表数字 12 从根到叶子节点路径 1-\u003e3 代表数字 13 因此，数字总和 = 12 + 13 = 25 示例 2： 输入：root = [4,9,0,5,1] 输出：1026 解释： 从根到叶子节点路径 4","date":"2015-05-09","objectID":"/leetcode/0129/:1:0","tags":null,"title":"0129：求根节点到叶节点数字之和（★）","uri":"/leetcode/0129/"},{"categories":null,"content":"分析 遍历时维护根节点到当前节点的路径数字，遇到叶子节点就加到结果中即可。 ","date":"2015-05-09","objectID":"/leetcode/0129/:2:0","tags":null,"title":"0129：求根节点到叶节点数字之和（★）","uri":"/leetcode/0129/"},{"categories":null,"content":"解答 def binaryTreePaths(self, root: Optional[TreeNode]) -\u003e List[str]: res, stack = [], [(root, '')] while stack: node, s = stack.pop() if node: s += ('-\u003e' if s else '') + str(node.val) if not node.left and not node.right: res.append(s) stack.extend([(node.right, s), (node.left, s)]) return res 32 ms ","date":"2015-05-09","objectID":"/leetcode/0129/:3:0","tags":null,"title":"0129：求根节点到叶节点数字之和（★）","uri":"/leetcode/0129/"},{"categories":null,"content":" 力扣第 128 题 ","date":"2015-05-08","objectID":"/leetcode/0128/:0:0","tags":null,"title":"0128：最长连续序列（★）","uri":"/leetcode/0128/"},{"categories":null,"content":"题目 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1： 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2： 输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9 提示： 0 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 ","date":"2015-05-08","objectID":"/leetcode/0128/:1:0","tags":null,"title":"0128：最长连续序列（★）","uri":"/leetcode/0128/"},{"categories":null,"content":"分析 ","date":"2015-05-08","objectID":"/leetcode/0128/:2:0","tags":null,"title":"0128：最长连续序列（★）","uri":"/leetcode/0128/"},{"categories":null,"content":"#1 最简单的就是去重排序，然后遍历比较每条数字连续的序列即可。 def longestConsecutive(self, nums: List[int]) -\u003e int: nums = sorted(set(nums)) res, i = 0, 0 for j, num in enumerate(nums): if j == len(nums)-1 or num+1 != nums[j+1]: res = max(res, j-i+1) i = j+1 return res 32 ms ","date":"2015-05-08","objectID":"/leetcode/0128/:2:1","tags":null,"title":"0128：最长连续序列（★）","uri":"/leetcode/0128/"},{"categories":null,"content":"#2 要求时间复杂度 O(n)，考虑找到每条序列的起点开始遍历。 有个巧妙的方法判断起点： 如果 x-1 在 nums 中，x 不是起点 如果 x-1 不在 nums 中，x 是起点 ","date":"2015-05-08","objectID":"/leetcode/0128/:2:2","tags":null,"title":"0128：最长连续序列（★）","uri":"/leetcode/0128/"},{"categories":null,"content":"解答 def longestConsecutive(self, nums: List[int]) -\u003e int: res, nums = 0, set(nums) for num in nums: if num-1 not in nums: cnt = 0 while num in nums: num += 1 cnt += 1 res = max(res, cnt) return res 44 ms ","date":"2015-05-08","objectID":"/leetcode/0128/:3:0","tags":null,"title":"0128：最长连续序列（★）","uri":"/leetcode/0128/"},{"categories":null,"content":" 力扣第 127 题 ","date":"2015-05-07","objectID":"/leetcode/0127/:0:0","tags":null,"title":"0127：单词接龙（★★）","uri":"/leetcode/0127/"},{"categories":null,"content":"题目 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -\u003e s1 -\u003e s2 -\u003e ... -\u003e sk： 每一对相邻的单词只差一个字母。 对于 1 \u003c= i \u003c= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。 sk == endWord 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。","date":"2015-05-07","objectID":"/leetcode/0127/:1:0","tags":null,"title":"0127：单词接龙（★★）","uri":"/leetcode/0127/"},{"categories":null,"content":"分析 显然可以用 bfs，从 beginWord 开始，每一轮搜索能转换的单词，直到搜到 endWord 或没有能转换的单词。 搜索过程类似 0676： 将单词的某一位改为 ‘.’ 作为单词的 key 每个单词按所有的 key 存在哈希表中 搜索时，取所有 key 对应的列表即可 ","date":"2015-05-07","objectID":"/leetcode/0127/:2:0","tags":null,"title":"0127：单词接龙（★★）","uri":"/leetcode/0127/"},{"categories":null,"content":"解答 def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -\u003e int: d = defaultdict(list) for w in wordList: for i in range(len(w)): d[w[:i]+'.'+w[i+1:]].append(w) Q, dis = deque([beginWord]), {beginWord: 1} while Q: u = Q.popleft() if u == endWord: return dis[u] for i in range(len(","date":"2015-05-07","objectID":"/leetcode/0127/:3:0","tags":null,"title":"0127：单词接龙（★★）","uri":"/leetcode/0127/"},{"categories":null,"content":" 力扣第 126 题 ","date":"2015-05-06","objectID":"/leetcode/0126/:0:0","tags":null,"title":"0126：单词接龙 II（★★）","uri":"/leetcode/0126/"},{"categories":null,"content":"题目 按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -\u003e s1 -\u003e s2 -\u003e ... -\u003e sk 这样的单词序列，并满足： 每对相邻的单词之间仅有单个字母不同。 转换过程中的每个单词 si（1 \u003c= i \u003c= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。 sk == endWord 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endW","date":"2015-05-06","objectID":"/leetcode/0126/:1:0","tags":null,"title":"0126：单词接龙 II（★★）","uri":"/leetcode/0126/"},{"categories":null,"content":"分析 0127 升级版。 要求所有序列，考虑从 bfs 的路径中倒推： bfs 的过程中得到 dis 字典，保存了经过的每个单词到 beginWord 的距离 假设单词 w 和 endWord 相邻且 dis[w]==dis[endWord]-1，那么可以经过 w 来组成最短路径 依此类推，找到 beginWord 时，即得到一条最短路径 用回溯法可以搜索到所有最短路径 特别注意 beginWord 可能在 wordList 中，也可能不在，因此构建字典 d 时， 要遍历 set(wordList)|{beginWord}。 ","date":"2015-05-06","objectID":"/leetcode/0126/:2:0","tags":null,"title":"0126：单词接龙 II（★★）","uri":"/leetcode/0126/"},{"categories":null,"content":"解答 def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -\u003e List[List[str]]: d = defaultdict(list) for w in set(wordList)|{beginWord}: for i in range(len(w)): d[w[:i]+'.'+w[i+1:]].append(w) Q, dis = deque([beginWord]), {beginWord: 1} while Q: u = Q.popleft() if u == endWord: break","date":"2015-05-06","objectID":"/leetcode/0126/:3:0","tags":null,"title":"0126：单词接龙 II（★★）","uri":"/leetcode/0126/"},{"categories":null,"content":" 力扣第 125 题 ","date":"2015-05-05","objectID":"/leetcode/0125/:0:0","tags":null,"title":"0125：验证回文串","uri":"/leetcode/0125/"},{"categories":null,"content":"题目 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。 字母和数字都属于字母数字字符。 给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。 示例 1： 输入: s = \"A man, a plan, a canal: Panama\" 输出：true 解释：\"amanaplanacanalpanama\" 是回文串。 示例 2： 输入：s = \"race a car\" 输出：false 解释：\"raceacar\" 不是回文串。 示例 3： 输入：s = \" \" 输出：true 解释：在移","date":"2015-05-05","objectID":"/leetcode/0125/:1:0","tags":null,"title":"0125：验证回文串","uri":"/leetcode/0125/"},{"categories":null,"content":"分析 去除掉无关字符，判断正反序是否相同即可。 ","date":"2015-05-05","objectID":"/leetcode/0125/:2:0","tags":null,"title":"0125：验证回文串","uri":"/leetcode/0125/"},{"categories":null,"content":"解答 def isPalindrome(self, s: str) -\u003e bool: ss = ''.join(char for char in s if char.isalnum()).lower() return ss == ss[::-1] 36 ms ","date":"2015-05-05","objectID":"/leetcode/0125/:3:0","tags":null,"title":"0125：验证回文串","uri":"/leetcode/0125/"},{"categories":null,"content":" 力扣第 124 题 ","date":"2015-05-04","objectID":"/leetcode/0124/:0:0","tags":null,"title":"0124：二叉树中的最大路径和（★★）","uri":"/leetcode/0124/"},{"categories":null,"content":"题目 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 示例 1： 输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -\u003e 1 -\u003e 3 ，路径和为 2 + 1 + 3 = 6 示例 2： 输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -\u003e 20 -\u003e 7 ，路径和为 15 + 20 + 7 = 42","date":"2015-05-04","objectID":"/leetcode/0124/:1:0","tags":null,"title":"0124：二叉树中的最大路径和（★★）","uri":"/leetcode/0124/"},{"categories":null,"content":"分析 用 dfs(node) 同时返回 node 的最大路径和，以 node 为起点的最大路径和，即可递归。 ","date":"2015-05-04","objectID":"/leetcode/0124/:2:0","tags":null,"title":"0124：二叉树中的最大路径和（★★）","uri":"/leetcode/0124/"},{"categories":null,"content":"解答 def maxPathSum(self, root: Optional[TreeNode]) -\u003e int: def dfs(node): if not node: return float('-inf'), float('-inf') l1, l2 = dfs(node.left) r1, r2 = dfs(node.right) l2, r2 = max(0, l2), max(0, r2) return max(l1, r1, node.val+l2+r2), node.val+max(l2, r2) return dfs(root)[0] 84 ms ","date":"2015-05-04","objectID":"/leetcode/0124/:3:0","tags":null,"title":"0124：二叉树中的最大路径和（★★）","uri":"/leetcode/0124/"},{"categories":null,"content":" 力扣第 123 题 ","date":"2015-05-03","objectID":"/leetcode/0123/:0:0","tags":null,"title":"0123：买卖股票的最佳时机 III（★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 输入：p","date":"2015-05-03","objectID":"/leetcode/0123/:1:0","tags":null,"title":"0123：买卖股票的最佳时机 III（★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"分析 ","date":"2015-05-03","objectID":"/leetcode/0123/:2:0","tags":null,"title":"0123：买卖股票的最佳时机 III（★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"#1 0121 升级版，添加了次数限制，所以考虑加一个状态参数。 令 dp[i][j][0]、dp[i][j][1] 分别代表 prices[:i] 最多买过 j 支股票且手里有/无股票的最大利润，即可递推： $$\\begin{cases} dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j-1][1]-prices[i-1]) \\\\ dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j][0]+prices[i-1]) \\end{cases}$$ def maxProfit(self, prices: List[int]) -","date":"2015-05-03","objectID":"/leetcode/0123/:2:1","tags":null,"title":"0123：买卖股票的最佳时机 III（★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"#2 可以用滚动数组优化空间。 ","date":"2015-05-03","objectID":"/leetcode/0123/:2:2","tags":null,"title":"0123：买卖股票的最佳时机 III（★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"解答 def maxProfit(self, prices: List[int]) -\u003e int: n = len(prices) dp = [[float('-inf'), 0] for _ in range(3)] for x in prices: prev = dp[:] for j in range(1, 3): dp[j][0] = max(prev[j][0], prev[j-1][1]-x) dp[j][1] = max(prev[j][1], prev[j][0]+x) return dp[-1][-1] 692 ms ","date":"2015-05-03","objectID":"/leetcode/0123/:3:0","tags":null,"title":"0123：买卖股票的最佳时机 III（★★）","uri":"/leetcode/0123/"},{"categories":null,"content":" 力扣第 122 题 ","date":"2015-05-02","objectID":"/leetcode/0122/:0:0","tags":null,"title":"0122：买卖股票的最佳时机 II（★）","uri":"/leetcode/0122/"},{"categories":null,"content":"题目 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = ","date":"2015-05-02","objectID":"/leetcode/0122/:1:0","tags":null,"title":"0122：买卖股票的最佳时机 II（★）","uri":"/leetcode/0122/"},{"categories":null,"content":"分析 类似 0121，区别在于可以多次买卖，dp[i][0] 的递推式有变化： $$\\begin{cases} dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i-1]) \\\\ dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i-1])\\end{cases}$$ ","date":"2015-05-02","objectID":"/leetcode/0122/:2:0","tags":null,"title":"0122：买卖股票的最佳时机 II（★）","uri":"/leetcode/0122/"},{"categories":null,"content":"解答 def maxProfit(self, prices: List[int]) -\u003e int: a, b = float('-inf'), 0 for price in prices: a, b = max(a, b-price), max(b, a+price) return b 28 ms ","date":"2015-05-02","objectID":"/leetcode/0122/:3:0","tags":null,"title":"0122：买卖股票的最佳时机 II（★）","uri":"/leetcode/0122/"},{"categories":null,"content":" 力扣第 121 题 ","date":"2015-05-01","objectID":"/leetcode/0121/:0:0","tags":null,"title":"0121：买卖股票的最佳时机","uri":"/leetcode/0121/"},{"categories":null,"content":"题目 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2：","date":"2015-05-01","objectID":"/leetcode/0121/:1:0","tags":null,"title":"0121：买卖股票的最佳时机","uri":"/leetcode/0121/"},{"categories":null,"content":"分析 经典 dp 问题。 考虑最后一天的交易状态： 如果没有卖出，则转为 prices[:-1] 的递归子问题 如果卖了，则要求 prices[:-1] 有股票状态下的最大值 那么令 dp[i][0]、dp[i][1] 分别代表 prices[:i] 手里有/无股票的最大利润，即可递推： $$ \\begin{cases} dp[i][0] = max(dp[i-1][0], -prices[i-1]) \\\\ dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i-1]) \\end{cases} $$ 还可以优化为两个参数。 ","date":"2015-05-01","objectID":"/leetcode/0121/:2:0","tags":null,"title":"0121：买卖股票的最佳时机","uri":"/leetcode/0121/"},{"categories":null,"content":"解答 def maxProfit(self, prices: List[int]) -\u003e int: a, b = float('-inf'), 0 for price in prices: a, b = max(a, -price), max(b, a+price) return b 188 ms ","date":"2015-05-01","objectID":"/leetcode/0121/:3:0","tags":null,"title":"0121：买卖股票的最佳时机","uri":"/leetcode/0121/"},{"categories":null,"content":" 力扣第 120 题 ","date":"2015-04-30","objectID":"/leetcode/0120/:0:0","tags":null,"title":"0120：三角形最小路径和（★）","uri":"/leetcode/0120/"},{"categories":null,"content":"题目 给定一个三角形 triangle ，找出自顶向下的最小路径和。 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。 示例 1： 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] 输出：11 解释：如下面简图所示： 2 3 4 6 5 7 4 1 8 3 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 示例 2： 输入：triangle = ","date":"2015-04-30","objectID":"/leetcode/0120/:1:0","tags":null,"title":"0120：三角形最小路径和（★）","uri":"/leetcode/0120/"},{"categories":null,"content":"分析 典型的 dp 问题。还可以直接用 triangle 保存结果，节省空间。 ","date":"2015-04-30","objectID":"/leetcode/0120/:2:0","tags":null,"title":"0120：三角形最小路径和（★）","uri":"/leetcode/0120/"},{"categories":null,"content":"解答 def minimumTotal(self, triangle: List[List[int]]) -\u003e int: n = len(triangle) for i in range(n-2, -1, -1): for j in range(i+1): triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]) return triangle[0][0] 36 ms ","date":"2015-04-30","objectID":"/leetcode/0120/:3:0","tags":null,"title":"0120：三角形最小路径和（★）","uri":"/leetcode/0120/"},{"categories":null,"content":" 力扣第 119 题 ","date":"2015-04-29","objectID":"/leetcode/0119/:0:0","tags":null,"title":"0119：杨辉三角 II","uri":"/leetcode/0119/"},{"categories":null,"content":"题目 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 输入: rowIndex = 3 输出: [1,3,3,1] 示例 2: 输入: rowIndex = 0 输出: [1] 示例 3: 输入: rowIndex = 1 输出: [1,1] 提示: 0 \u003c= rowIndex \u003c= 33 进阶： 你可以优化你的算法到 O(rowIndex) 空间复杂度吗？ ","date":"2015-04-29","objectID":"/leetcode/0119/:1:0","tags":null,"title":"0119：杨辉三角 II","uri":"/leetcode/0119/"},{"categories":null,"content":"分析 迭代时覆盖上一层即可节省空间。 ","date":"2015-04-29","objectID":"/leetcode/0119/:2:0","tags":null,"title":"0119：杨辉三角 II","uri":"/leetcode/0119/"},{"categories":null,"content":"解答 def getRow(self, rowIndex: int) -\u003e List[int]: res = [1] for _ in range(rowIndex): res = [1] + [a+b for a,b in pairwise(res)] + [1] return res 32 ms ","date":"2015-04-29","objectID":"/leetcode/0119/:3:0","tags":null,"title":"0119：杨辉三角 II","uri":"/leetcode/0119/"},{"categories":null,"content":"*附加 也可以利用数学知识，杨辉三角的第 k 行其实就是： $$[ C_k^0, C_k^1, …, C_k^k ]$$ def getRow(self, rowIndex: int) -\u003e List[int]: return [comb(rowIndex, i) for i in range(rowIndex+1)] 40 ms ","date":"2015-04-29","objectID":"/leetcode/0119/:4:0","tags":null,"title":"0119：杨辉三角 II","uri":"/leetcode/0119/"},{"categories":null,"content":" 力扣第 118 题 ","date":"2015-04-28","objectID":"/leetcode/0118/:0:0","tags":null,"title":"0118：杨辉三角","uri":"/leetcode/0118/"},{"categories":null,"content":"题目 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2: 输入: numRows = 1 输出: [[1]] 提示: 1 \u003c= numRows \u003c= 30 ","date":"2015-04-28","objectID":"/leetcode/0118/:1:0","tags":null,"title":"0118：杨辉三角","uri":"/leetcode/0118/"},{"categories":null,"content":"分析 每层迭代即可。 ","date":"2015-04-28","objectID":"/leetcode/0118/:2:0","tags":null,"title":"0118：杨辉三角","uri":"/leetcode/0118/"},{"categories":null,"content":"解答 def generate(self, numRows: int) -\u003e List[List[int]]: res = [[1]] for _ in range(numRows-1): res.append([1]+[a+b for a,b in pairwise(res[-1])]+[1]) return res 32 ms ","date":"2015-04-28","objectID":"/leetcode/0118/:3:0","tags":null,"title":"0118：杨辉三角","uri":"/leetcode/0118/"},{"categories":null,"content":" 力扣第 117 题 ","date":"2015-04-27","objectID":"/leetcode/0117/:0:0","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★）","uri":"/leetcode/0117/"},{"categories":null,"content":"题目 给定一个二叉树： struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。 初始状态下，所有 next 指针都被设置为 NULL 。 示例 1： 输入：root = [1,2,3,4,5,null,7] 输出：[1,#,2,3,#,4,5,7,#] 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 ne","date":"2015-04-27","objectID":"/leetcode/0117/:1:0","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★）","uri":"/leetcode/0117/"},{"categories":null,"content":"分析 ","date":"2015-04-27","objectID":"/leetcode/0117/:2:0","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★）","uri":"/leetcode/0117/"},{"categories":null,"content":"#1 与 0116 的区别在于不是完美二叉树了。 层序遍历的代码相同。 def connect(self, root: 'Node') -\u003e 'Node': Q = [root] if root else [] while Q: for p, q in pairwise(Q): p.next = q Q = [child for p in Q for child in [p.left, p.right] if child] return root 52 ms ","date":"2015-04-27","objectID":"/leetcode/0117/:2:1","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★）","uri":"/leetcode/0117/"},{"categories":null,"content":"#2 依然可以每层提前填充下一层的 next 指针。额外添加哑结点，并记录前置节点即可。 ","date":"2015-04-27","objectID":"/leetcode/0117/:2:2","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★）","uri":"/leetcode/0117/"},{"categories":null,"content":"解答 def connect(self, root: 'Node') -\u003e 'Node': p = root while p: dummy = prev = Node() while p: for child in [p.left, p.right]: if child: prev.next = child prev = child p = p.next p = dummy.next return root 52 ms ","date":"2015-04-27","objectID":"/leetcode/0117/:3:0","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★）","uri":"/leetcode/0117/"},{"categories":null,"content":" 力扣第 116 题 ","date":"2015-04-26","objectID":"/leetcode/0116/:0:0","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★）","uri":"/leetcode/0116/"},{"categories":null,"content":"题目 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例 1： 输入：root = [1,2,3,4,5,6,7] 输出：[1,#,2,3,#,4,5,6,7,#] 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指","date":"2015-04-26","objectID":"/leetcode/0116/:1:0","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★）","uri":"/leetcode/0116/"},{"categories":null,"content":"分析 ","date":"2015-04-26","objectID":"/leetcode/0116/:2:0","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★）","uri":"/leetcode/0116/"},{"categories":null,"content":"#1 最简单的就是层序遍历，每一层填充即可。 def connect(self, root: 'Optional[Node]') -\u003e 'Optional[Node]': Q = [root] if root else [] while Q: for p, q in pairwise(Q): p.next = q Q = [child for p in Q for child in [p.left, p.right] if child] return root 56 ms ","date":"2015-04-26","objectID":"/leetcode/0116/:2:1","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★）","uri":"/leetcode/0116/"},{"categories":null,"content":"#2 要求不用额外空间，有个巧妙的想法。 每层提前填充下一层的 next 指针，那么从每层最左边根据 next 指针就可以完成遍历，不需要存储其它节点。 ","date":"2015-04-26","objectID":"/leetcode/0116/:2:2","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★）","uri":"/leetcode/0116/"},{"categories":null,"content":"解答 def connect(self, root: 'Optional[Node]') -\u003e 'Optional[Node]': cur = root while cur and cur.left: p = cur while p: p.left.next = p.right if p.next: p.right.next = p.next.left p = p.next cur = cur.left return root 60 ms ","date":"2015-04-26","objectID":"/leetcode/0116/:3:0","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★）","uri":"/leetcode/0116/"},{"categories":null,"content":" 力扣第 115 题 ","date":"2015-04-25","objectID":"/leetcode/0115/:0:0","tags":null,"title":"0115：不同的子序列（★★）","uri":"/leetcode/0115/"},{"categories":null,"content":"题目 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，\"ACE\" 是 \"ABCDE\" 的一个子序列，而 \"AEC\" 不是） 题目数据保证答案符合 32 位带符号整数范围。 示例 1： 输入：s = \"rabbbit\", t = \"rabbit\" 输出：3 解释： 如下图所示, 有 3 种可以从 s 中得到 \"rabbit\" 的方案。 rabbbit rabbbit rabbbit 示例 2： 输入：s = \"babgbag\", t = \"bag\" 输出","date":"2015-04-25","objectID":"/leetcode/0115/:1:0","tags":null,"title":"0115：不同的子序列（★★）","uri":"/leetcode/0115/"},{"categories":null,"content":"分析 典型的双串 dp，按是否由 s[-1] 拼成 t[-1] 即可递归。 ","date":"2015-04-25","objectID":"/leetcode/0115/:2:0","tags":null,"title":"0115：不同的子序列（★★）","uri":"/leetcode/0115/"},{"categories":null,"content":"解答 def numDistinct(self, s: str, t: str) -\u003e int: @cache def dfs(s, t): if len(s) \u003c len(t): return 0 if not t: return 1 res = dfs(s[:-1], t) if s[-1]==t[-1]: res += dfs(s[:-1], t[:-1]) return res return dfs(s, t) 60 ms ","date":"2015-04-25","objectID":"/leetcode/0115/:3:0","tags":null,"title":"0115：不同的子序列（★★）","uri":"/leetcode/0115/"},{"categories":null,"content":" 力扣第 114 题 ","date":"2015-04-24","objectID":"/leetcode/0114/:0:0","tags":null,"title":"0114：二叉树展开为链表（★）","uri":"/leetcode/0114/"},{"categories":null,"content":"题目 给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 示例 1： 输入：root = [1,2,5,3,4,null,6] 输出：[1,null,2,null,3,null,4,null,5,null,6] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [0] 输出：[0] 提示： 树中结点数在范围 [0, 2000] 内 -100 \u003c= Node.val \u003c= 100 进","date":"2015-04-24","objectID":"/leetcode/0114/:1:0","tags":null,"title":"0114：二叉树展开为链表（★）","uri":"/leetcode/0114/"},{"categories":null,"content":"分析 先序遍历 root，每次将上一个节点的 right 指向当前节点即可。 注意要去掉节点的 left 指针。 ","date":"2015-04-24","objectID":"/leetcode/0114/:2:0","tags":null,"title":"0114：二叉树展开为链表（★）","uri":"/leetcode/0114/"},{"categories":null,"content":"解答 def flatten(self, root: TreeNode) -\u003e None: stack, prev = [root], TreeNode() while stack: node = stack.pop() if node: stack.extend([node.right, node.left]) prev.right = node node.left = None prev = node 40 ms ","date":"2015-04-24","objectID":"/leetcode/0114/:3:0","tags":null,"title":"0114：二叉树展开为链表（★）","uri":"/leetcode/0114/"},{"categories":null,"content":" 力扣第 113 题 ","date":"2015-04-23","objectID":"/leetcode/0113/:0:0","tags":null,"title":"0113：路径总和 II（★）","uri":"/leetcode/0113/"},{"categories":null,"content":"题目 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 输出：[[5,4,11,2],[5,8,4,5]] 示例 2： 输入：root = [1,2,3], targetSum = 5 输出：[] 示例 3： 输入：root = [1,2], targetSum = 0 输出：[] 提示： 树中节点总数在范围 [0, 5000] 内 -10","date":"2015-04-23","objectID":"/leetcode/0113/:1:0","tags":null,"title":"0113：路径总和 II（★）","uri":"/leetcode/0113/"},{"categories":null,"content":"分析 类似 0112，可以用递归或遍历，这里用递归。 ","date":"2015-04-23","objectID":"/leetcode/0113/:2:0","tags":null,"title":"0113：路径总和 II（★）","uri":"/leetcode/0113/"},{"categories":null,"content":"解答 def pathSum(self, root: TreeNode, targetSum: int) -\u003e List[List[int]]: def dfs(p, x): if not p: return [] if not p.left and not p.right and p.val==x: return [[x]] return [[p.val]+sub for sub in dfs(p.left, x-p.val) + dfs(p.right, x-p.val)] return dfs(root, targetSum) 60 ms ","date":"2015-04-23","objectID":"/leetcode/0113/:3:0","tags":null,"title":"0113：路径总和 II（★）","uri":"/leetcode/0113/"},{"categories":null,"content":" 力扣第 112 题 ","date":"2015-04-22","objectID":"/leetcode/0112/:0:0","tags":null,"title":"0112：路径总和","uri":"/leetcode/0112/"},{"categories":null,"content":"题目 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2： 输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在","date":"2015-04-22","objectID":"/leetcode/0112/:1:0","tags":null,"title":"0112：路径总和","uri":"/leetcode/0112/"},{"categories":null,"content":"分析 ","date":"2015-04-22","objectID":"/leetcode/0112/:2:0","tags":null,"title":"0112：路径总和","uri":"/leetcode/0112/"},{"categories":null,"content":"#1 令 dfs(p, x) 代表是否存在节点 p 到叶子节点的路径和为 x，即可递归。 def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u003e bool: def dfs(p, x): if not p: return False if not p.left and not p.right: return p.val == x return dfs(p.left, x-p.val) or dfs(p.right, x-p.val) return dfs(root, targetSum) 40 ms ","date":"2015-04-22","objectID":"/leetcode/0112/:2:1","tags":null,"title":"0112：路径总和","uri":"/leetcode/0112/"},{"categories":null,"content":"#2 也可以遍历树，维护当前节点到根节点的路径和。遇到叶子节点时，判断是否满足即可。 ","date":"2015-04-22","objectID":"/leetcode/0112/:2:2","tags":null,"title":"0112：路径总和","uri":"/leetcode/0112/"},{"categories":null,"content":"解答 def hasPathSum(self, root: TreeNode, targetSum: int) -\u003e bool: stack = [(root, 0)] while stack: node, val = stack.pop() if node: val += node.val if not node.left and not node.right and val == targetSum: return True stack.extend([(node.right, val), (node.left,val)]) return False 40 ms ","date":"2015-04-22","objectID":"/leetcode/0112/:3:0","tags":null,"title":"0112：路径总和","uri":"/leetcode/0112/"},{"categories":null,"content":" 力扣第 111 题 ","date":"2015-04-21","objectID":"/leetcode/0111/:0:0","tags":null,"title":"0111：二叉树的最小深度","uri":"/leetcode/0111/"},{"categories":null,"content":"题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2015-04-21","objectID":"/leetcode/0111/:1:0","tags":null,"title":"0111：二叉树的最小深度","uri":"/leetcode/0111/"},{"categories":null,"content":"分析 ","date":"2015-04-21","objectID":"/leetcode/0111/:2:0","tags":null,"title":"0111：二叉树的最小深度","uri":"/leetcode/0111/"},{"categories":null,"content":"#1 类似 0104 ，可以用递归。 def minDepth(self, root: TreeNode) -\u003e int: if not root: return 0 if not root.left or not root.right: return self.minDepth(root.right) + self.minDepth(root.left) + 1 return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 616 ms ","date":"2015-04-21","objectID":"/leetcode/0111/:2:1","tags":null,"title":"0111：二叉树的最小深度","uri":"/leetcode/0111/"},{"categories":null,"content":"#2 也可以层序遍历，遇到第一个叶子节点即返回。 ","date":"2015-04-21","objectID":"/leetcode/0111/:2:2","tags":null,"title":"0111：二叉树的最小深度","uri":"/leetcode/0111/"},{"categories":null,"content":"解答 def minDepth(self, root: TreeNode) -\u003e int: res, Q = 0, [root] if root else [] while Q: res += 1 if any(not node.left and not node.right for node in Q): break Q = [child for node in Q for child in [node.left, node.right] if child] return res 476 ms ","date":"2015-04-21","objectID":"/leetcode/0111/:3:0","tags":null,"title":"0111：二叉树的最小深度","uri":"/leetcode/0111/"},{"categories":null,"content":" 力扣第 110 题 ","date":"2015-04-20","objectID":"/leetcode/0110/:0:0","tags":null,"title":"0110：平衡二叉树","uri":"/leetcode/0110/"},{"categories":null,"content":"题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 \u003c= Node.val \u003c= 104 ","date":"2015-04-20","objectID":"/leetcode/0110/:1:0","tags":null,"title":"0110：平衡二叉树","uri":"/leetcode/0110/"},{"categories":null,"content":"分析 用 dfs(node) 同时返回 node 是否平衡、node 的深度，即可递归。 为了方便，可以用深度为 -1 来代表不平衡，dfs(node) 返回 node 的深度即可。 ","date":"2015-04-20","objectID":"/leetcode/0110/:2:0","tags":null,"title":"0110：平衡二叉树","uri":"/leetcode/0110/"},{"categories":null,"content":"解答 def isBalanced(self, root: TreeNode) -\u003e bool: def dfs(root): if not root: return 0 l, r = dfs(root.left), dfs(root.right) return -1 if l==-1 or r==-1 or abs(l-r)\u003e1 else 1+max(l, r) return dfs(root) != -1 52 ms ","date":"2015-04-20","objectID":"/leetcode/0110/:3:0","tags":null,"title":"0110：平衡二叉树","uri":"/leetcode/0110/"},{"categories":null,"content":" 力扣第 109 题 ","date":"2015-04-19","objectID":"/leetcode/0109/:0:0","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"题目 给定一个单链表的头节点 head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。 示例 1: 输入: head = [-10,-3,0,5,9] 输出: [0,-3,9,-10,null,5] 解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。 示例 2: 输入: head = [] 输出: [] 提示: head 中的节点数在[0, 2 * 104] 范围内 -105 \u003c= Node.val \u003c= 105 ","date":"2015-04-19","objectID":"/leetcode/0109/:1:0","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"分析 ","date":"2015-04-19","objectID":"/leetcode/0109/:2:0","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"#1 0108 升级版。可以先将链表转为数组，再转换。 def sortedListToBST(self, head: Optional[ListNode]) -\u003e Optional[TreeNode]: def dfs(i, j): mid = (i + j) // 2 return None if i == j else TreeNode(nums[mid], dfs(i, mid), dfs(mid + 1, j)) nums = [] while head: nums.append(head.val) head = head.next return dfs(0, len(nums)) ","date":"2015-04-19","objectID":"/leetcode/0109/:2:1","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"#2 也可以直接用快慢指针在链表上找到中点，然后转为递归子问题。 ","date":"2015-04-19","objectID":"/leetcode/0109/:2:2","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"解答 def sortedListToBST(self, head: Optional[ListNode]) -\u003e Optional[TreeNode]: def findMid(head): slow = fast = ListNode(next=head) while fast.next and fast.next.next: slow, fast = slow.next, fast.next.next return slow def dfs(head): if not head: return None if not head.next: return TreeNode(head.val","date":"2015-04-19","objectID":"/leetcode/0109/:3:0","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":" 力扣第 108 题 ","date":"2015-04-18","objectID":"/leetcode/0108/:0:0","tags":null,"title":"0108：将有序数组转换为二叉搜索树","uri":"/leetcode/0108/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 示例 1： 输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 示例 2： 输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示： 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[","date":"2015-04-18","objectID":"/leetcode/0108/:1:0","tags":null,"title":"0108：将有序数组转换为二叉搜索树","uri":"/leetcode/0108/"},{"categories":null,"content":"分析 将中点作为根节点，前半部分和后半部分分别作为左子树和右子树，即可转为递归子问题。 ","date":"2015-04-18","objectID":"/leetcode/0108/:2:0","tags":null,"title":"0108：将有序数组转换为二叉搜索树","uri":"/leetcode/0108/"},{"categories":null,"content":"解答 def sortedArrayToBST(self, nums: List[int]) -\u003e TreeNode: def dfs(i, j): mid = (i+j)//2 return None if i==j else TreeNode(nums[mid], dfs(i, mid), dfs(mid+1, j)) return dfs(0, len(nums)) 40 ms ","date":"2015-04-18","objectID":"/leetcode/0108/:3:0","tags":null,"title":"0108：将有序数组转换为二叉搜索树","uri":"/leetcode/0108/"},{"categories":null,"content":" 力扣第 107 题 ","date":"2015-04-17","objectID":"/leetcode/0107/:0:0","tags":null,"title":"0107：二叉树的层序遍历 II（★）","uri":"/leetcode/0107/"},{"categories":null,"content":"题目 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[[15,7],[9,20],[3]] 示例 2： 输入：root = [1] 输出：[[1]] 示例 3： 输入：root = [] 输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2015-04-17","objectID":"/leetcode/0107/:1:0","tags":null,"title":"0107：二叉树的层序遍历 II（★）","uri":"/leetcode/0107/"},{"categories":null,"content":"分析 将 0102 的结果反序即可。 ","date":"2015-04-17","objectID":"/leetcode/0107/:2:0","tags":null,"title":"0107：二叉树的层序遍历 II（★）","uri":"/leetcode/0107/"},{"categories":null,"content":"解答 def levelOrderBottom(self, root: TreeNode) -\u003e List[List[int]]: res, Q = [], [root] if root else [] while Q: res.append([node.val for node in Q]) Q = [child for node in Q for child in [node.left, node.right] if child] return res[::-1] 32 ms ","date":"2015-04-17","objectID":"/leetcode/0107/:3:0","tags":null,"title":"0107：二叉树的层序遍历 II（★）","uri":"/leetcode/0107/"},{"categories":null,"content":" 力扣第 106 题 ","date":"2015-04-16","objectID":"/leetcode/0106/:0:0","tags":null,"title":"0106：从中序与后序遍历序列构造二叉树（★）","uri":"/leetcode/0106/"},{"categories":null,"content":"题目 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例 1: 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] 示例 2: 输入：inorder = [-1], postorder = [-1] 输出：[-1] 提示: 1 \u003c= inorder.length \u003c= 3000 postorder.length == inorder.length -300","date":"2015-04-16","objectID":"/leetcode/0106/:1:0","tags":null,"title":"0106：从中序与后序遍历序列构造二叉树（★）","uri":"/leetcode/0106/"},{"categories":null,"content":"分析 类似 0105，只是从找 preorder[0] 变成了找 postorder[-1]。 ","date":"2015-04-16","objectID":"/leetcode/0106/:2:0","tags":null,"title":"0106：从中序与后序遍历序列构造二叉树（★）","uri":"/leetcode/0106/"},{"categories":null,"content":"解答 def buildTree(self, inorder: List[int], postorder: List[int]) -\u003e TreeNode: def dfs(io, po): if not po: return None i = io.index(po[-1]) return TreeNode(po[-1], dfs(io[:i], po[:i]), dfs(io[i+1:], po[i:-1])) return dfs(inorder, postorder) 112 ms ","date":"2015-04-16","objectID":"/leetcode/0106/:3:0","tags":null,"title":"0106：从中序与后序遍历序列构造二叉树（★）","uri":"/leetcode/0106/"},{"categories":null,"content":" 力扣第 105 题 ","date":"2015-04-15","objectID":"/leetcode/0105/:0:0","tags":null,"title":"0105：从前序与中序遍历序列构造二叉树（★）","uri":"/leetcode/0105/"},{"categories":null,"content":"题目 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例 1: 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] 示例 2: 输入: preorder = [-1], inorder = [-1] 输出: [-1] 提示: 1 \u003c= preorder.length \u003c= 3000 inorder.length == preorder.length -3000","date":"2015-04-15","objectID":"/leetcode/0105/:1:0","tags":null,"title":"0105：从前序与中序遍历序列构造二叉树（★）","uri":"/leetcode/0105/"},{"categories":null,"content":"分析 从上往下构造： 根节点即是 preorder[0] 在 inorder 中找到根节点位置 i，inorder[:i]、inorder[i+1:] 分别代表左/右子树 显然 preorder 和 inorder 中代表左子树的长度应该相等 那么 preorder[1:i+1]、preorder[i+1:] 分别代表左/右子树 然后可以对左/右子树递归 ","date":"2015-04-15","objectID":"/leetcode/0105/:2:0","tags":null,"title":"0105：从前序与中序遍历序列构造二叉树（★）","uri":"/leetcode/0105/"},{"categories":null,"content":"解答 def buildTree(self, preorder: List[int], inorder: List[int]) -\u003e TreeNode: def dfs(po, io): if not po: return None i = io.index(po[0]) return TreeNode(po[0], dfs(po[1:i+1], io[:i]), dfs(po[i+1:], io[i+1:])) return dfs(preorder, inorder) 132 ms ","date":"2015-04-15","objectID":"/leetcode/0105/:3:0","tags":null,"title":"0105：从前序与中序遍历序列构造二叉树（★）","uri":"/leetcode/0105/"},{"categories":null,"content":" 力扣第 104 题 ","date":"2015-04-14","objectID":"/leetcode/0104/:0:0","tags":null,"title":"0104：二叉树的最大深度","uri":"/leetcode/0104/"},{"categories":null,"content":"题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 ","date":"2015-04-14","objectID":"/leetcode/0104/:1:0","tags":null,"title":"0104：二叉树的最大深度","uri":"/leetcode/0104/"},{"categories":null,"content":"分析 ","date":"2015-04-14","objectID":"/leetcode/0104/:2:0","tags":null,"title":"0104：二叉树的最大深度","uri":"/leetcode/0104/"},{"categories":null,"content":"#1 层序遍历，记录有多少层即可。 def maxDepth(self, root: Optional[TreeNode]) -\u003e int: res, Q = 0, [root] if root else [] while Q: res += 1 Q = [child for node in Q for child in [node.left, node.right] if child] return res 44 ms ","date":"2015-04-14","objectID":"/leetcode/0104/:2:1","tags":null,"title":"0104：二叉树的最大深度","uri":"/leetcode/0104/"},{"categories":null,"content":"#2 也可以用递归。 ","date":"2015-04-14","objectID":"/leetcode/0104/:2:2","tags":null,"title":"0104：二叉树的最大深度","uri":"/leetcode/0104/"},{"categories":null,"content":"解答 def maxDepth(self, root: TreeNode) -\u003e int: return 0 if not root else max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 48 ms ","date":"2015-04-14","objectID":"/leetcode/0104/:3:0","tags":null,"title":"0104：二叉树的最大深度","uri":"/leetcode/0104/"},{"categories":null,"content":" 力扣第 103 题 ","date":"2015-04-13","objectID":"/leetcode/0103/:0:0","tags":null,"title":"0103：二叉树的锯齿形层序遍历（★）","uri":"/leetcode/0103/"},{"categories":null,"content":"题目 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[20,9],[15,7]] 示例 2： 输入：root = [1] 输出：[[1]] 示例 3： 输入：root = [] 输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-04-13","objectID":"/leetcode/0103/:1:0","tags":null,"title":"0103：二叉树的锯齿形层序遍历（★）","uri":"/leetcode/0103/"},{"categories":null,"content":"分析 0102 升级版，将奇数层的节点反序即可。 ","date":"2015-04-13","objectID":"/leetcode/0103/:2:0","tags":null,"title":"0103：二叉树的锯齿形层序遍历（★）","uri":"/leetcode/0103/"},{"categories":null,"content":"解答 def zigzagLevelOrder(self, root: TreeNode) -\u003e List[List[int]]: res, Q = [], [root] if root else [] while Q: A = [node.val for node in Q] res.append(A[::-1] if len(res)%2 else A) Q = [child for node in Q for child in [node.left, node.right] if child] return res 32 ms ","date":"2015-04-13","objectID":"/leetcode/0103/:3:0","tags":null,"title":"0103：二叉树的锯齿形层序遍历（★）","uri":"/leetcode/0103/"},{"categories":null,"content":" 力扣第 102 题 ","date":"2015-04-12","objectID":"/leetcode/0102/:0:0","tags":null,"title":"0102：二叉树的层序遍历（★）","uri":"/leetcode/0102/"},{"categories":null,"content":"题目 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例 2： 输入：root = [1] 输出：[[1]] 示例 3： 输入：root = [] 输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2015-04-12","objectID":"/leetcode/0102/:1:0","tags":null,"title":"0102：二叉树的层序遍历（★）","uri":"/leetcode/0102/"},{"categories":null,"content":"分析 迭代保存每层的节点即可。 ","date":"2015-04-12","objectID":"/leetcode/0102/:2:0","tags":null,"title":"0102：二叉树的层序遍历（★）","uri":"/leetcode/0102/"},{"categories":null,"content":"解答 def levelOrder(self, root: TreeNode) -\u003e List[List[int]]: res, Q = [], [root] if root else [] while Q: res.append([node.val for node in Q]) Q = [child for node in Q for child in [node.left, node.right] if child] return res 36 ms ","date":"2015-04-12","objectID":"/leetcode/0102/:3:0","tags":null,"title":"0102：二叉树的层序遍历（★）","uri":"/leetcode/0102/"},{"categories":null,"content":" 力扣第 101 题 ","date":"2015-04-11","objectID":"/leetcode/0101/:0:0","tags":null,"title":"0101：对称二叉树","uri":"/leetcode/0101/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false 提示： 树中节点数目在范围 [1, 1000] 内 -100 \u003c= Node.val \u003c= 100 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ ","date":"2015-04-11","objectID":"/leetcode/0101/:1:0","tags":null,"title":"0101：对称二叉树","uri":"/leetcode/0101/"},{"categories":null,"content":"分析 ","date":"2015-04-11","objectID":"/leetcode/0101/:2:0","tags":null,"title":"0101：对称二叉树","uri":"/leetcode/0101/"},{"categories":null,"content":"#1 0100 升级版，相当于判断左子树和右子树是否镜像对称。 令 dfs(p, q) 代表 p 和 q 是否镜像对称，即可递归。 def isSymmetric(self, root: Optional[TreeNode]) -\u003e bool: def dfs(p, q): if not p or not q: return not p and not q return p.val == q.val and dfs(p.left, q.right) and dfs(p.right, q.left) return dfs(root.left, root.right) 28 ms ","date":"2015-04-11","objectID":"/leetcode/0101/:2:1","tags":null,"title":"0101：对称二叉树","uri":"/leetcode/0101/"},{"categories":null,"content":"#2 也可以用迭代。与 0100 类似，只是要交叉比较，入栈顺序处理下即可。 ","date":"2015-04-11","objectID":"/leetcode/0101/:2:2","tags":null,"title":"0101：对称二叉树","uri":"/leetcode/0101/"},{"categories":null,"content":"解答 def isSymmetric(self, root: TreeNode) -\u003e bool: stack1, stack2 = [root], [root] while stack1: p, q = stack1.pop(), stack2.pop() if not p and not q: continue if not p or not q or p.val != q.val: return False stack1.extend([p.right, p.left]) stack2.extend([q.left, q.right]) return True 40 ms ","date":"2015-04-11","objectID":"/leetcode/0101/:3:0","tags":null,"title":"0101：对称二叉树","uri":"/leetcode/0101/"},{"categories":null,"content":" 力扣第 100 题 ","date":"2015-04-10","objectID":"/leetcode/0100/:0:0","tags":null,"title":"0100：相同的树","uri":"/leetcode/0100/"},{"categories":null,"content":"题目 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1： 输入：p = [1,2,3], q = [1,2,3] 输出：true 示例 2： 输入：p = [1,2], q = [1,null,2] 输出：false 示例 3： 输入：p = [1,2,1], q = [1,1,2] 输出：false 提示： 两棵树上的节点数目都在范围 [0, 100] 内 -104 \u003c= Node.val \u003c= 104 ","date":"2015-04-10","objectID":"/leetcode/0100/:1:0","tags":null,"title":"0100：相同的树","uri":"/leetcode/0100/"},{"categories":null,"content":"分析 ","date":"2015-04-10","objectID":"/leetcode/0100/:2:0","tags":null,"title":"0100：相同的树","uri":"/leetcode/0100/"},{"categories":null,"content":"#1 显然两个二叉树相同等价于根节点、左子树、右子树都相同，容易写出递归解法。 def isSameTree(self, p: TreeNode, q: TreeNode) -\u003e bool: if not p or not q: return not p and not q return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) 28 ms ","date":"2015-04-10","objectID":"/leetcode/0100/:2:1","tags":null,"title":"0100：相同的树","uri":"/leetcode/0100/"},{"categories":null,"content":"#2 也可以用迭代。 遍历一遍二叉树，如果每一步经过的节点都相同，那么两个二叉树相同。 为了方便，这里用前序遍历。 ","date":"2015-04-10","objectID":"/leetcode/0100/:2:2","tags":null,"title":"0100：相同的树","uri":"/leetcode/0100/"},{"categories":null,"content":"解答 def isSameTree(self, p: TreeNode, q: TreeNode) -\u003e bool: stack1, stack2 = [p], [q] while stack1: p, q = stack1.pop(), stack2.pop() if not p and not q: continue if not p or not q or p.val != q.val: return False stack1.extend([p.right, p.left]) stack2.extend([q.right, q.left]) return True 28 ms ","date":"2015-04-10","objectID":"/leetcode/0100/:3:0","tags":null,"title":"0100：相同的树","uri":"/leetcode/0100/"},{"categories":null,"content":" 力扣第 99 题 ","date":"2015-04-09","objectID":"/leetcode/0099/:0:0","tags":null,"title":"0099：恢复二叉搜索树（★）","uri":"/leetcode/0099/"},{"categories":null,"content":"题目 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。 示例 1： 输入：root = [1,3,null,null,2] 输出：[3,1,null,null,2] 解释：3 不能是 1 的左孩子，因为 3 \u003e 1 。交换 1 和 3 使二叉搜索树有效。 示例 2： 输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 \u003c 3 。交换 2 和 3 使二叉搜索树有效。 提示： 树上节点的数目在范围 [2, 1000] 内 -231 ","date":"2015-04-09","objectID":"/leetcode/0099/:1:0","tags":null,"title":"0099：恢复二叉搜索树（★）","uri":"/leetcode/0099/"},{"categories":null,"content":"分析 二叉搜索树等价于其中序遍历的节点值是递增的，所以可以遍历找到两个错误的节点，然后交换。 第一个错误节点就是第一个大于后继节点的节点，第二个错误节点就是最后一个小于前面节点的节点。 ","date":"2015-04-09","objectID":"/leetcode/0099/:2:0","tags":null,"title":"0099：恢复二叉搜索树（★）","uri":"/leetcode/0099/"},{"categories":null,"content":"解答 def recoverTree(self, root: TreeNode) -\u003e None: stack, prev = [(root, 0)], None x, y = None, None while stack: node, flag = stack.pop() if flag: if prev and prev.val \u003e node.val: x, y = x if x else prev, node prev = node elif node: stack.extend([(node.right, 0), (node, 1), (node.left, 0)]) x.val, y","date":"2015-04-09","objectID":"/leetcode/0099/:3:0","tags":null,"title":"0099：恢复二叉搜索树（★）","uri":"/leetcode/0099/"},{"categories":null,"content":"*附加 要求 O(1) 空间，需要用 Morris 中序遍历 Morris 遍历减少了空间但也增加了时间，一般不用。 def recoverTree(self, root: TreeNode) -\u003e None: x, y, prev = None, None, None while root: if root.left: predecessor = root.left while predecessor.right and predecessor.right != root: predecessor = predecessor.right if not predecessor.right: p","date":"2015-04-09","objectID":"/leetcode/0099/:4:0","tags":null,"title":"0099：恢复二叉搜索树（★）","uri":"/leetcode/0099/"},{"categories":null,"content":"“内裤被看到的话，人类就会灭亡！？”\n高中生伊里达游太以某起事件为契机而灵魂出窍了。在自己所居住的公寓古来馆醒来的游太，被突然现身的猫的幽灵千良之助告知“想要取回你的肉体的话，就去找到存在于古来馆某处的圣典吧野猫～”。游太因此而开始在馆内搜索，但在目击到居住在那里的女生的内裤大人的瞬间，地球就发生了不得了的灾难……！！游太使用特殊的灵力干涉着住民们的生活。他们偶尔会一边解开隐藏的谜团，一边直面人类灭亡的命运。究竟他们能否以最高的欢乐迎来和平的未来！？","date":"2015-04-09","objectID":"/anime/punch_line/","tags":null,"title":"Punch Line","uri":"/anime/punch_line/"},{"categories":null,"content":"简介 “内裤被看到的话，人类就会灭亡！？” 高中生伊里达游太以某起事件为契机而灵魂出窍了。在自己所居住的公寓古来馆醒来的游太，被突然现身的猫的幽灵千良之助告知“想要取回你的肉体的话，就去找到存在于古来馆某处的圣典吧野猫～”。游太因此而开始在馆内搜索，但在目击到居住在那里的女生的内裤大人的瞬间，地球就发生了不得了的灾难……！！游太使用特殊的灵力干涉着住民们的生活。他们偶尔会一边解开隐藏的谜团，一边直面人类灭亡的命运。究竟他们能否以最高的欢乐迎来和平的未来！？ 制作人员： 原作：美吉斯、富士电视台 导演：上村泰 脚本：打越钢太郎 分镜：塩月小鸟、石川健介、猪狩崇、朴性厚、林明伟 ","date":"2015-04-09","objectID":"/anime/punch_line/:1:0","tags":null,"title":"Punch Line","uri":"/anime/punch_line/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊里达游太 伊里達 遊太、いりだつ ゆうた、灵魂出窍、伊里达游、パイン 井上麻里奈 2 成木野美香丹 成木野 みかたん、なるぎの みかたん、ストレンジジュース、正义使者、ちよ子 女 雨宮天 3 曳尾谷爱 曳尾谷 愛、ひきおたに いと、hikiotani ito、家里蹲御宅NEET 女 寿美菜子 4 台初明香 台初 明香、だいはつ めいか、大发明家 女 釘宮理恵 5 秩父拉布拉 秩父 ラブラ、ちちぶ らぶら、欧派摇摇 女 戸松遥 6 千良之助 チラ之助、ちらのすけ、走光之助 吉田有里 7 台初天华 男 蓮岳大 8 寺冈龙都 てらおか りゅうと、Teraoka ","date":"2015-04-09","objectID":"/anime/punch_line/:2:0","tags":null,"title":"Punch Line","uri":"/anime/punch_line/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Punch Line 2015-04-09 12 bilibili ","date":"2015-04-09","objectID":"/anime/punch_line/:3:0","tags":null,"title":"Punch Line","uri":"/anime/punch_line/"},{"categories":null,"content":" 力扣第 98 题 ","date":"2015-04-08","objectID":"/leetcode/0098/:0:0","tags":null,"title":"0098：验证二叉搜索树（★）","uri":"/leetcode/0098/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 输入：root = [2,1,3] 输出：true 示例 2： 输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -231 \u003c= Node.val \u003c= 231 - 1 ","date":"2015-04-08","objectID":"/leetcode/0098/:1:0","tags":null,"title":"0098：验证二叉搜索树（★）","uri":"/leetcode/0098/"},{"categories":null,"content":"分析 有效的二叉搜索树等价于其中序遍历的节点值是递增的，所以中序遍历加个判断即可。 ","date":"2015-04-08","objectID":"/leetcode/0098/:2:0","tags":null,"title":"0098：验证二叉搜索树（★）","uri":"/leetcode/0098/"},{"categories":null,"content":"解答 def isValidBST(self, root: TreeNode) -\u003e bool: pre, stack = float('-inf'), [root] while stack: node = stack.pop() if isinstance(node, int): if node \u003c= pre: return False pre = node elif node: stack.extend([node.right, node.val, node.left]) return True 52 ms ","date":"2015-04-08","objectID":"/leetcode/0098/:3:0","tags":null,"title":"0098：验证二叉搜索树（★）","uri":"/leetcode/0098/"},{"categories":null,"content":"*附加 也可以用递归： 如果 node 的左子树和右子树都是二叉搜索树，且左子树的数都小于node.val，右子树的数都大于 node.val，node 即为二叉搜索树 于是令 dfs(node, low, high) 代表 node 子树是否为 [low, high] 范围内的二叉搜索树，即可递归 初始无限制，所以 low/high 设为极小/大值 def isValidBST(self, root: TreeNode) -\u003e bool: def dfs(node, low, high): if not node: return True if not low\u003cnode.val\u003chigh: ","date":"2015-04-08","objectID":"/leetcode/0098/:4:0","tags":null,"title":"0098：验证二叉搜索树（★）","uri":"/leetcode/0098/"},{"categories":null,"content":" 力扣第 97 题 ","date":"2015-04-07","objectID":"/leetcode/0097/:0:0","tags":null,"title":"0097：交错字符串（★）","uri":"/leetcode/0097/"},{"categories":null,"content":"题目 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。 两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串： s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| \u003c= 1 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ... 注意：a + b 意味着字符串 a 和 b 连接。 示例 1： 输入：s1 = \"aabcc\", s2 = \"dbbca\", s3","date":"2015-04-07","objectID":"/leetcode/0097/:1:0","tags":null,"title":"0097：交错字符串（★）","uri":"/leetcode/0097/"},{"categories":null,"content":"分析 典型的多串 dp，按 s3 的末尾由 s1 或 s2 末尾拼成，即可递归。 ","date":"2015-04-07","objectID":"/leetcode/0097/:2:0","tags":null,"title":"0097：交错字符串（★）","uri":"/leetcode/0097/"},{"categories":null,"content":"解答 def isInterleave(self, s1: str, s2: str, s3: str) -\u003e bool: @lru_cache(None) def dfs(s1, s2, s3): if not s3: return True if s1 and s3[-1]==s1[-1] and dfs(s1[:-1], s2, s3[:-1]): return True return len(s2)\u003e0 and s3[-1]==s2[-1] and dfs(s1, s2[:-1], s3[:-1]) return len(s3) == len(s1) + len(s2) and dfs","date":"2015-04-07","objectID":"/leetcode/0097/:3:0","tags":null,"title":"0097：交错字符串（★）","uri":"/leetcode/0097/"},{"categories":null,"content":"进入北宇治高中就读的主人公黄前久美子，在同班同学加藤叶月的热烈影响下加入了该校的吹奏部。北宇治高中吹奏部直到5年前还是关西大会的常客，并且过去还是全国大会出场过的强校代表，然而自从顾问换了之后，该吹奏部就再也没有挺进过关西大会。之后以新顾问的赴任为契机，怀揣着高远目标的部员们挥洒着奋斗的青春，过着波澜万丈的每一天。终于，比赛的日子也即将到来……","date":"2015-04-07","objectID":"/anime/hibike_euphonium/","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":"简介 进入北宇治高中就读的主人公黄前久美子，在同班同学加藤叶月的热烈影响下加入了该校的吹奏部。北宇治高中吹奏部直到5年前还是关西大会的常客，并且过去还是全国大会出场过的强校代表，然而自从顾问换了之后，该吹奏部就再也没有挺进过关西大会。之后以新顾问的赴任为契机，怀揣着高远目标的部员们挥洒着奋斗的青春，过着波澜万丈的每一天。终于，比赛的日子也即将到来…… 制作人员： 原作：武田绫乃 导演：石原立也 脚本：花田十辉 分镜：北之原孝将、河浪荣作、雪村爱、武本康弘、山村卓也 ","date":"2015-04-07","objectID":"/anime/hibike_euphonium/:1:0","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 黄前久美子 黄前 久美子、おうまえ くみこ、Oumae Kumiko 女 黒沢ともよ 2 加藤叶月 加藤葉月、かとう はづき、Katou Hazuki 女 朝井彩加 3 川岛绿辉 緑、Sapphire Kawashima、川島緑輝、かわしま さふぁいあ、Kawashima Safaia、みどり 女 豊田萌絵 4 高坂丽奈 高坂 麗奈、こうさか れいな、Kousaka Reina 女 安済知佳 5 田中明日香 たなか あすか、Tanaka Asuka 女 寿美菜子 6 小笠原晴香 おがさわら はるか、Ogasawara Haruka 女 早見沙織 7 中世古香","date":"2015-04-07","objectID":"/anime/hibike_euphonium/:2:0","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 吹响！悠风号 2015-04-07 14 bilibili 2 吹响！悠风号 第二季 2016-10-05 13 bilibili 3 莉兹与青鸟 2018-04-21 1 樱花 4 剧场版 吹响！悠风号～誓言的终章～ 2019-04-19 1 bilibili ","date":"2015-04-07","objectID":"/anime/hibike_euphonium/:3:0","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":"MAD ","date":"2015-04-07","objectID":"/anime/hibike_euphonium/:4:0","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":" 力扣第 96 题 ","date":"2015-04-06","objectID":"/leetcode/0096/:0:0","tags":null,"title":"0096：不同的二叉搜索树（★）","uri":"/leetcode/0096/"},{"categories":null,"content":"题目 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1： 输入：n = 3 输出：5 示例 2： 输入：n = 1 输出：1 提示： 1 \u003c= n \u003c= 19 ","date":"2015-04-06","objectID":"/leetcode/0096/:1:0","tags":null,"title":"0096：不同的二叉搜索树（★）","uri":"/leetcode/0096/"},{"categories":null,"content":"分析 按左右子树的节点数可以转为递归子问题。 显然有重复子问题，所以用动态规划。 ","date":"2015-04-06","objectID":"/leetcode/0096/:2:0","tags":null,"title":"0096：不同的二叉搜索树（★）","uri":"/leetcode/0096/"},{"categories":null,"content":"解答 def numTrees(self, n: int) -\u003e int: dp = [1] * (n+1) for i in range(1, n+1): dp[i] = sum(dp[j]*dp[i-1-j] for j in range(i)) return dp[-1] 36 ms ","date":"2015-04-06","objectID":"/leetcode/0096/:3:0","tags":null,"title":"0096：不同的二叉搜索树（★）","uri":"/leetcode/0096/"},{"categories":null,"content":"*附加 这个递推式得到的 dp[n] 在数学上被称为卡塔兰数，有个更简单的表达式： $$dp[n] = {(2n)! \\over (n!*(n+1)!)} $$ def numTrees(self, n: int) -\u003e int: res = 1 for i in range(1, n+1): res = res*(i+n)//i return res//(n+1) 32 ms ","date":"2015-04-06","objectID":"/leetcode/0096/:4:0","tags":null,"title":"0096：不同的二叉搜索树（★）","uri":"/leetcode/0096/"},{"categories":null,"content":" 力扣第 95 题 ","date":"2015-04-05","objectID":"/leetcode/0095/:0:0","tags":null,"title":"0095：不同的二叉搜索树 II（★）","uri":"/leetcode/0095/"},{"categories":null,"content":"题目 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。 示例 1： 输入：n = 3 输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] 示例 2： 输入：n = 1 输出：[[1]] 提示： 1 \u003c= n \u003c= 8 ","date":"2015-04-05","objectID":"/leetcode/0095/:1:0","tags":null,"title":"0095：不同的二叉搜索树 II（★）","uri":"/leetcode/0095/"},{"categories":null,"content":"分析 类似于 0096 ，不过需要生成所有实际的树。 令 dfs(i,j) 代表节点值 [i,j] 组成的不同二叉搜索树，即可递归。 ","date":"2015-04-05","objectID":"/leetcode/0095/:2:0","tags":null,"title":"0095：不同的二叉搜索树 II（★）","uri":"/leetcode/0095/"},{"categories":null,"content":"解答 def generateTrees(self, n: int) -\u003e List[TreeNode]: def dfs(i, j): if i \u003e j: return [None] res = [] for k in range(i, j+1): for l in dfs(i, k-1): for r in dfs(k+1, j): res.append(TreeNode(k, l, r)) return res return dfs(1, n) 56 ms ","date":"2015-04-05","objectID":"/leetcode/0095/:3:0","tags":null,"title":"0095：不同的二叉搜索树 II（★）","uri":"/leetcode/0095/"},{"categories":null,"content":" 力扣第 94 题 ","date":"2015-04-04","objectID":"/leetcode/0094/:0:0","tags":null,"title":"0094：二叉树的中序遍历","uri":"/leetcode/0094/"},{"categories":null,"content":"题目 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ ","date":"2015-04-04","objectID":"/leetcode/0094/:1:0","tags":null,"title":"0094：二叉树的中序遍历","uri":"/leetcode/0094/"},{"categories":null,"content":"分析 ","date":"2015-04-04","objectID":"/leetcode/0094/:2:0","tags":null,"title":"0094：二叉树的中序遍历","uri":"/leetcode/0094/"},{"categories":null,"content":"#1 先写出递归算法，显然，将左子树的中序遍历、根节点、右子树的中序遍历拼接起来即可。 def inorderTraversal(self, root: TreeNode) -\u003e List[int]: return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else [] 40 ms ","date":"2015-04-04","objectID":"/leetcode/0094/:2:1","tags":null,"title":"0094：二叉树的中序遍历","uri":"/leetcode/0094/"},{"categories":null,"content":"#2 可以借助栈改写成迭代算法： 初始栈保存根节点 每轮出栈，如果是节点，按 [右子树、节点值、左子树] 顺序入栈 如果出栈的是节点值，说明其左子树已经遍历完，将节点值添加到结果中 依此循环直到栈空即遍历完毕 ","date":"2015-04-04","objectID":"/leetcode/0094/:2:2","tags":null,"title":"0094：二叉树的中序遍历","uri":"/leetcode/0094/"},{"categories":null,"content":"解答 def inorderTraversal(self, root: TreeNode) -\u003e List[int]: res, stack = [], [root] while stack: node = stack.pop() if isinstance(node, int): res.append(node) elif node: stack.extend([node.right, node.val, node.left]) return res 32 ms ","date":"2015-04-04","objectID":"/leetcode/0094/:3:0","tags":null,"title":"0094：二叉树的中序遍历","uri":"/leetcode/0094/"},{"categories":null,"content":"故事发生在一个比现在的科学要进步的世界。18岁的水柿司高考失败，多亏父母找关系得以进入世界大企业SAI社工作。SAI社是制造管理拥有感情的人形智能机器人（通称：Giftia）的企业，司在其中被安排到终端服务部门工作。这个部门其实就是回收即将到期的Giftia，是所谓的“窗边部门（不被重视的部门）”。于是司和打杂的Giftia少女“艾拉”组成搭档，一起开始了工作……","date":"2015-04-04","objectID":"/anime/plastic_memories/","tags":null,"title":"可塑性记忆","uri":"/anime/plastic_memories/"},{"categories":null,"content":"简介 故事发生在一个比现在的科学要进步的世界。18岁的水柿司高考失败，多亏父母找关系得以进入世界大企业SAI社工作。SAI社是制造管理拥有感情的人形智能机器人（通称：Giftia）的企业，司在其中被安排到终端服务部门工作。这个部门其实就是回收即将到期的Giftia，是所谓的“窗边部门（不被重视的部门）”。于是司和打杂的Giftia少女“艾拉”组成搭档，一起开始了工作…… 制作人员： 原作：美吉斯、林直孝 导演：藤原佳幸 分镜：菅原静贵、福田道生、上坪亮树、入江泰浩 ","date":"2015-04-04","objectID":"/anime/plastic_memories/:1:0","tags":null,"title":"可塑性记忆","uri":"/anime/plastic_memories/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾拉 Isla、アイラ 女 雨宮天 2 水柿司 Tsukasa Mizugaki、水柿 ツカサ、みずがき つかさ 男 内匠靖明 3 绢岛满 絹島 ミチル、きぬしま ミチル、Kinushima Michiru 女 赤﨑千夏 4 札克 ザック 矢作紗友里 5 桑乃实香月 桑乃実 カヅキ、くわのみ カヅキ 女 豊口めぐみ 6 康斯坦斯 コンスタンス 男 日野聡 7 缥康孝 縹 ヤスタカ、はなだ ヤスタカ 男 津田健次郎 8 雪莉 シェリー 女 愛美 ","date":"2015-04-04","objectID":"/anime/plastic_memories/:2:0","tags":null,"title":"可塑性记忆","uri":"/anime/plastic_memories/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 可塑性记忆 2015-04-04 13 bilibili ","date":"2015-04-04","objectID":"/anime/plastic_memories/:3:0","tags":null,"title":"可塑性记忆","uri":"/anime/plastic_memories/"},{"categories":null,"content":"MAD ","date":"2015-04-04","objectID":"/anime/plastic_memories/:4:0","tags":null,"title":"可塑性记忆","uri":"/anime/plastic_memories/"},{"categories":null,"content":"从古以来，在暗夜的世界里有一种种族他们被称为“血界之族”这个种族拥有超乎于常人的力量！\n\n因此对人类的生存造成了威胁而对这一种族也出现了为了保护人类而存在的猎人们，他们通常被称为“獠牙狩猎者”……\n\n现时的纽约变成了歪曲的异界与人类的交界处，笼罩着浓浓的雾霭，众多势力与众多种族相互制约，取得了危险的平衡。\n\n克劳斯率领的“秘密结社LIBRA”，为了守护这个危险的平衡而挑战种种困难的事件。","date":"2015-04-04","objectID":"/anime/blood_blockade/","tags":null,"title":"血界战线","uri":"/anime/blood_blockade/"},{"categories":null,"content":"简介 从古以来，在暗夜的世界里有一种种族他们被称为“血界之族”这个种族拥有超乎于常人的力量！ 因此对人类的生存造成了威胁而对这一种族也出现了为了保护人类而存在的猎人们，他们通常被称为“獠牙狩猎者”…… 现时的纽约变成了歪曲的异界与人类的交界处，笼罩着浓浓的雾霭，众多势力与众多种族相互制约，取得了危险的平衡。 克劳斯率领的“秘密结社LIBRA”，为了守护这个危险的平衡而挑战种种困难的事件。 制作人员： 原作：内藤泰弘 导演：松本理惠 脚本：古家和尚 分镜：田村耕太郎、宫尾佳和、福田道生、伊藤智彦、平川哲生 ","date":"2015-04-04","objectID":"/anime/blood_blockade/:1:0","tags":null,"title":"血界战线","uri":"/anime/blood_blockade/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雷欧纳鲁德·渥奇 Leonardo Watch 男 阪口大助 2 克劳斯·V·莱因赫兹 Klaus V Reinherz 男 小山力也 3 札布·雷夫洛 Zapp Renfro 男 中井和哉 4 史蒂芬·A·斯塔菲斯 Steven A Starphase 男 宮本充 5 珍·皇 Chain Sumeragi、チェイン・すめらぎ、チェイン 女 小林ゆう 6 玛丽.麦克白 小白、White 女 釘宮理恵 7 威廉·麦克白 小黑、Black 男 釘宮理恵 8 绝望王 钉宫四猛 男 釘宮理恵 ","date":"2015-04-04","objectID":"/anime/blood_blockade/:2:0","tags":null,"title":"血界战线","uri":"/anime/blood_blockade/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 血界战线 2015-04-04 12 bilibili 2 血界战线 \u0026 BEYOND 2017-10-07 12 bilibili ","date":"2015-04-04","objectID":"/anime/blood_blockade/:3:0","tags":null,"title":"血界战线","uri":"/anime/blood_blockade/"},{"categories":null,"content":" 力扣第 93 题 ","date":"2015-04-03","objectID":"/leetcode/0093/:0:0","tags":null,"title":"0093：复原 IP 地址（★）","uri":"/leetcode/0093/"},{"categories":null,"content":"题目 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。 例如：\"0.1.2.201\" 和 \"192.168.1.1\" 是 有效 IP 地址，但是 \"0.011.255.245\"、\"192.168.1.312\" 和 \"192.168@1.1\" 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 示例 1： 输入：s = \"25525511","date":"2015-04-03","objectID":"/leetcode/0093/:1:0","tags":null,"title":"0093：复原 IP 地址（★）","uri":"/leetcode/0093/"},{"categories":null,"content":"分析 典型的回溯问题，每步选择分割位置即可。 ","date":"2015-04-03","objectID":"/leetcode/0093/:2:0","tags":null,"title":"0093：复原 IP 地址（★）","uri":"/leetcode/0093/"},{"categories":null,"content":"解答 def restoreIpAddresses(self, s: str) -\u003e List[str]: def dfs(s): if len(path) == 4: if not s: res.append('.'.join(path)) return for i in range(min(3, len(s))): if 0 \u003c= int(s[:i+1]) \u003c= 255 and not (i and s[0] == '0'): path.append(s[:i+1]) dfs(s[i+1:]) path.pop() res, path = [], [] dfs(s) return res ","date":"2015-04-03","objectID":"/leetcode/0093/:3:0","tags":null,"title":"0093：复原 IP 地址（★）","uri":"/leetcode/0093/"},{"categories":null,"content":"《食戟之灵》描述男主角幸平创真梦想在国中毕业後能够继承父亲经营的幸平餐馆，却在父亲指示下来到东京都内的料理名校远月学园中就读。料理技术高超的创真，却在插班考试中被拥有神之舌的少女薙切绘里奈评为不及格!?在学园长帮助下，创真依然成功入学，并立誓要让绘里奈认同他所作的料理。","date":"2015-04-03","objectID":"/anime/shokugeki_no_souma/","tags":null,"title":"食戟之灵","uri":"/anime/shokugeki_no_souma/"},{"categories":null,"content":"简介 《食戟之灵》描述男主角幸平创真梦想在国中毕业後能够继承父亲经营的幸平餐馆，却在父亲指示下来到东京都内的料理名校远月学园中就读。料理技术高超的创真，却在插班考试中被拥有神之舌的少女薙切绘里奈评为不及格!?在学园长帮助下，创真依然成功入学，并立誓要让绘里奈认同他所作的料理。 制作人员： 原作：附田祐斗、佐伯俊 导演：米谷良知 脚本：猪爪慎一、河锅俊、安川正吾 分镜：山崎隆、安藤良、宫繁之 ","date":"2015-04-03","objectID":"/anime/shokugeki_no_souma/:1:0","tags":null,"title":"食戟之灵","uri":"/anime/shokugeki_no_souma/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 幸平创真 幸平 創真、ゆきひら そうま、Yukihira souma、药王 男 松岡禎丞 2 薙切绘里奈 薙切绘理奈、薙切 えりな、なきり えりな、Nakiri erina 女 種田梨沙 3 田所惠 田所 恵、たどころ めぐみ、Tadokoro Megumi、極星の清涼剤 女 髙橋ミナミ 4 水原冬美 水原冬美、みずはら ふゆみ、Mizuhara fuyumi 女 川澄綾子 5 乾日向子 乾 日向子、いぬい ひなこ、Inui hinako、霧の女帝 女 能登麻美子 6 川岛丽 川島麗、かわしま うらら、Kawashima urara 女 日高里菜 7 千俵夏","date":"2015-04-03","objectID":"/anime/shokugeki_no_souma/:2:0","tags":null,"title":"食戟之灵","uri":"/anime/shokugeki_no_souma/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 食戟之灵 2015-04-03 24 bilibili 2 食戟之灵 贰之皿 2016-07-02 13 bilibili 3 食戟之灵 餐之皿 2017-10-03 24 bilibili 4 食戟之灵 神之皿 2019-10-11 12 樱花 5 食戟之灵 豪之皿 2020-04-10 13 樱花 ","date":"2015-04-03","objectID":"/anime/shokugeki_no_souma/:3:0","tags":null,"title":"食戟之灵","uri":"/anime/shokugeki_no_souma/"},{"categories":null,"content":" 力扣第 92 题 ","date":"2015-04-02","objectID":"/leetcode/0092/:0:0","tags":null,"title":"0092：反转链表 II（★）","uri":"/leetcode/0092/"},{"categories":null,"content":"题目 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left \u003c= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1： 输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5] 示例 2： 输入：head = [5], left = 1, right = 1 输出：[5] 提示： 链表中节点数目为 n 1 \u003c= n \u003c= 500 -500 \u003c= Node.val \u003c= 500 1 \u003c= left \u003c= right \u003c= n 进阶： 你可以使用一趟扫描完","date":"2015-04-02","objectID":"/leetcode/0092/:1:0","tags":null,"title":"0092：反转链表 II（★）","uri":"/leetcode/0092/"},{"categories":null,"content":"分析 类似 0206 ，只不过表头从哑节点变为了第 left-1 个节点。 ","date":"2015-04-02","objectID":"/leetcode/0092/:2:0","tags":null,"title":"0092：反转链表 II（★）","uri":"/leetcode/0092/"},{"categories":null,"content":"解答 def reverseBetween(self, head: ListNode, left: int, right: int) -\u003e ListNode: dummy = p = ListNode(next=head) for _ in range(left-1): p = p.next tail = p.next for _ in range(right-left): tmp = tail.next tail.next = tmp.next tmp.next = p.next p.next = tmp return dummy.next 40 ms ","date":"2015-04-02","objectID":"/leetcode/0092/:3:0","tags":null,"title":"0092：反转链表 II（★）","uri":"/leetcode/0092/"},{"categories":null,"content":" 力扣第 91 题 ","date":"2015-04-01","objectID":"/leetcode/0091/:0:0","tags":null,"title":"0091：解码方法（★）","uri":"/leetcode/0091/"},{"categories":null,"content":"题目 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： 'A' -\u003e \"1\" 'B' -\u003e \"2\" ... 'Z' -\u003e \"26\" 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\"11106\" 可以映射为： \"AAJF\" ，将消息分组为 (1 1 10 6) \"KJF\" ，将消息分组为 (11 10 6) 注意，消息不能分组为 (1 11 06) ，因为 \"06\" 不能映射为 \"F\" ，这是由于 \"6\" 和 \"06\" 在映射中并不等价。 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。 题目数据保证答案肯定是","date":"2015-04-01","objectID":"/leetcode/0091/:1:0","tags":null,"title":"0091：解码方法（★）","uri":"/leetcode/0091/"},{"categories":null,"content":"分析 ","date":"2015-04-01","objectID":"/leetcode/0091/:2:0","tags":null,"title":"0091：解码方法（★）","uri":"/leetcode/0091/"},{"categories":null,"content":"#1 典型的线性 dp 问题，令 dp[i] 代表 s[:i] 的解码总数，按 s[i-1] 和 s[i-2:i] 是否有效即可递推。 def numDecodings(self, s: str) -\u003e int: n = len(s) dp = [1]+[0]*n for i in range(1, n+1): if s[i-1]!='0': dp[i] += dp[i-1] if i\u003e=2 and 10\u003c=int(s[i-2:i])\u003c=26: dp[i] += dp[i-2] return dp[-1] 40 ms ","date":"2015-04-01","objectID":"/leetcode/0091/:2:1","tags":null,"title":"0091：解码方法（★）","uri":"/leetcode/0091/"},{"categories":null,"content":"#2 递推过程只和前两个状态有关，可以优化为两个变量。 ","date":"2015-04-01","objectID":"/leetcode/0091/:2:2","tags":null,"title":"0091：解码方法（★）","uri":"/leetcode/0091/"},{"categories":null,"content":"解答 def numDecodings(self, s: str) -\u003e int: a, b = 0, 1 for i in range(len(s)): a, b = b, b*(s[i]!='0')+a*(i and 10\u003c=int(s[i-1:i+1])\u003c=26) return b 40 ms ","date":"2015-04-01","objectID":"/leetcode/0091/:3:0","tags":null,"title":"0091：解码方法（★）","uri":"/leetcode/0091/"},{"categories":null,"content":" 力扣第 90 题 ","date":"2015-03-31","objectID":"/leetcode/0090/:0:0","tags":null,"title":"0090：子集 II（★）","uri":"/leetcode/0090/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 示例 1： 输入：nums = [1,2,2] 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2： 输入：nums = [0] 输出：[[],[0]] 提示： 1 \u003c= nums.length \u003c= 10 -10 \u003c= nums[i] \u003c= 10 ","date":"2015-03-31","objectID":"/leetcode/0090/:1:0","tags":null,"title":"0090：子集 II（★）","uri":"/leetcode/0090/"},{"categories":null,"content":"分析 0078 升级版，区别在于可能有重复数字，采用排序并跳过相同数字的通用方法即可。 ","date":"2015-03-31","objectID":"/leetcode/0090/:2:0","tags":null,"title":"0090：子集 II（★）","uri":"/leetcode/0090/"},{"categories":null,"content":"解答 def subsetsWithDup(self, nums: List[int]) -\u003e List[List[int]]: def dfs(i): res.append(path[:]) for j in range(i, n): if j \u003e i and nums[j] == nums[j - 1]: continue path.append(nums[j]) dfs(j + 1) path.pop() res, path, n = [], [], len(nums) nums.sort() dfs(0) return res 28 ms ","date":"2015-03-31","objectID":"/leetcode/0090/:3:0","tags":null,"title":"0090：子集 II（★）","uri":"/leetcode/0090/"},{"categories":null,"content":" 力扣第 89 题 ","date":"2015-03-30","objectID":"/leetcode/0089/:0:0","tags":null,"title":"0089：格雷编码（★）","uri":"/leetcode/0089/"},{"categories":null,"content":"题目 n 位格雷码序列 是一个由 2n 个整数组成的序列，其中： 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1） 第一个整数是 0 一个整数在序列中出现 不超过一次 每对 相邻 整数的二进制表示 恰好一位不同 ，且 第一个 和 最后一个 整数的二进制表示 恰好一位不同 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。 示例 1： 输入：n = 2 输出：[0,1,3,2] 解释： [0,1,3,2] 的二进制表示是 [00,01,11,10] 。 - 00 和 01 有一位不同 - 01 和 11 有一位不同 - 11 和 10 有一位不同 - 10 和 00","date":"2015-03-30","objectID":"/leetcode/0089/:1:0","tags":null,"title":"0089：格雷编码（★）","uri":"/leetcode/0089/"},{"categories":null,"content":"分析 考虑能否递推。发现先排 0 加 n-1 位的格雷编码，再排 1 加 n-1 位的格雷编码反序即可。 ","date":"2015-03-30","objectID":"/leetcode/0089/:2:0","tags":null,"title":"0089：格雷编码（★）","uri":"/leetcode/0089/"},{"categories":null,"content":"解答 def grayCode(self, n: int) -\u003e List[int]: res = [0] for i in range(n): res += [(1\u003c\u003ci)+x for x in res[::-1]] return res 44 ms ","date":"2015-03-30","objectID":"/leetcode/0089/:3:0","tags":null,"title":"0089：格雷编码（★）","uri":"/leetcode/0089/"},{"categories":null,"content":"*附加 格雷码的生成有个公式，可以直接套用：第 i 个格雷码等于 i^(i»1)。 def grayCode(self, n: int) -\u003e List[int]: return [i^(i\u003e\u003e1) for i in range(1\u003c\u003cn)] 40 ms ","date":"2015-03-30","objectID":"/leetcode/0089/:4:0","tags":null,"title":"0089：格雷编码（★）","uri":"/leetcode/0089/"},{"categories":null,"content":" 力扣第 88 题 ","date":"2015-03-29","objectID":"/leetcode/0088/:0:0","tags":null,"title":"0088：合并两个有序数组","uri":"/leetcode/0088/"},{"categories":null,"content":"题目 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1","date":"2015-03-29","objectID":"/leetcode/0088/:1:0","tags":null,"title":"0088：合并两个有序数组","uri":"/leetcode/0088/"},{"categories":null,"content":"分析 如果合并到新数组的话，遍历归并即可。 但这里要求合并到 nums1 中，考虑赋值： 直接赋值可能会覆盖 nums1 的元素，丢失信息 有个巧妙的想法是倒序遍历，从大到小归并，就不会覆盖了 ","date":"2015-03-29","objectID":"/leetcode/0088/:2:0","tags":null,"title":"0088：合并两个有序数组","uri":"/leetcode/0088/"},{"categories":null,"content":"解答 def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -\u003e None: i, j, k = m-1, n-1, m+n-1 while j \u003e= 0 and k \u003e= 0: if i \u003c 0 or nums1[i] \u003c= nums2[j]: nums1[k] = nums2[j] j -= 1 else: nums1[k] = nums1[i] i -= 1 k -= 1 32 ms ","date":"2015-03-29","objectID":"/leetcode/0088/:3:0","tags":null,"title":"0088：合并两个有序数组","uri":"/leetcode/0088/"},{"categories":null,"content":" 力扣第 87 题 ","date":"2015-03-28","objectID":"/leetcode/0087/:0:0","tags":null,"title":"0087：扰乱字符串（★★）","uri":"/leetcode/0087/"},{"categories":null,"content":"题目 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ： 如果字符串的长度为 1 ，算法停止 如果字符串的长度 \u003e 1 ，执行下述步骤： 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。 随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰","date":"2015-03-28","objectID":"/leetcode/0087/:1:0","tags":null,"title":"0087：扰乱字符串（★★）","uri":"/leetcode/0087/"},{"categories":null,"content":"分析 假设 s2 是 s1 的扰乱字符串，且对应的 s1 的第一个分割点在位置 i，那么有两种情况： 分割的两部分没有交换：s2[:i] 是 s1[:i] 的扰乱字符串，s2[i:] 是 s1[i:] 的扰乱字符串 分割开的两部分交换了：s2[-i:] 是 s1[:i] 的扰乱字符串，s2[:-i] 是 s1[i:] 的扰乱字符串 都可以转为递归子问题。显然有重复子问题，所以用记忆化递归。 ","date":"2015-03-28","objectID":"/leetcode/0087/:2:0","tags":null,"title":"0087：扰乱字符串（★★）","uri":"/leetcode/0087/"},{"categories":null,"content":"解答 def isScramble(self, s1: str, s2: str) -\u003e bool: @cache def dfs(s1, s2): if s1 == s2: return True if Counter(s1) != Counter(s2): return False for i in range(1, len(s1)): if dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:]): return True if dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i]): return True return","date":"2015-03-28","objectID":"/leetcode/0087/:3:0","tags":null,"title":"0087：扰乱字符串（★★）","uri":"/leetcode/0087/"},{"categories":null,"content":" 力扣第 86 题 ","date":"2015-03-27","objectID":"/leetcode/0086/:0:0","tags":null,"title":"0086：分隔链表（★）","uri":"/leetcode/0086/"},{"categories":null,"content":"题目 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 示例 1： 输入：head = [1,4,3,2,5,2], x = 3 输出：[1,2,2,4,3,5] 示例 2： 输入：head = [2,1], x = 2 输出：[1,2] 提示： 链表中节点的数目在范围 [0, 200] 内 -100 \u003c= Node.val \u003c= 100 -200 \u003c= x \u003c= 200 ","date":"2015-03-27","objectID":"/leetcode/0086/:1:0","tags":null,"title":"0086：分隔链表（★）","uri":"/leetcode/0086/"},{"categories":null,"content":"分析 遇到大于等于 x 的节点就先提出来，并按顺序链接，最后再跟到原链表的末尾即可。 ","date":"2015-03-27","objectID":"/leetcode/0086/:2:0","tags":null,"title":"0086：分隔链表（★）","uri":"/leetcode/0086/"},{"categories":null,"content":"解答 def partition(self, head: ListNode, x: int) -\u003e ListNode: dummy1 = p = ListNode(next=head) dummy2 = q = ListNode() while p.next: if p.next.val \u003e= x: q.next = p.next p.next = p.next.next q = q.next else: p = p.next q.next = None p.next = dummy2.next return dummy1.next 40 ms ","date":"2015-03-27","objectID":"/leetcode/0086/:3:0","tags":null,"title":"0086：分隔链表（★）","uri":"/leetcode/0086/"},{"categories":null,"content":" 力扣第 85 题 ","date":"2015-03-26","objectID":"/leetcode/0085/:0:0","tags":null,"title":"0085：最大矩形（★★）","uri":"/leetcode/0085/"},{"categories":null,"content":"题目 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例 1： 输入：matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] 输出：6 解释：最大矩形如上图所示。 示例 2： 输入：matrix = [] 输出：0 示例 3： 输入：matrix = [[\"0\"]] 输出：0 示例 4： 输入：matrix = [[\"1\"]] 输出：1 示例 5： 输入：matrix = [[","date":"2015-03-26","objectID":"/leetcode/0085/:1:0","tags":null,"title":"0085：最大矩形（★★）","uri":"/leetcode/0085/"},{"categories":null,"content":"分析 固定矩形的底在第 i 行，求出每列的高度 H[i][j]，即转为问题 0084。 注意 H[i][j] 可以由 H[i-1][j] 递推得到，故总的时间复杂度 $O(M*N)$。 ","date":"2015-03-26","objectID":"/leetcode/0085/:2:0","tags":null,"title":"0085：最大矩形（★★）","uri":"/leetcode/0085/"},{"categories":null,"content":"解答 def maximalRectangle(self, matrix: List[List[str]]) -\u003e int: def cal(H): res, stack = 0, [] for j, y in enumerate(H+[0]): while stack and stack[-1][1] \u003e= y: i, x = stack.pop() left = stack[-1][0] if stack else -1 res = max(res, x*(j-left-1)) stack.append((j, y)) return res m, n = len(matrix), len(","date":"2015-03-26","objectID":"/leetcode/0085/:3:0","tags":null,"title":"0085：最大矩形（★★）","uri":"/leetcode/0085/"},{"categories":null,"content":" 力扣第 84 题 ","date":"2015-03-25","objectID":"/leetcode/0084/:0:0","tags":null,"title":"0084：柱状图中最大的矩形（★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"题目 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例 1: 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2： 输入： heights = [2,4] 输出： 4 提示： 1 \u003c= heights.length \u003c=105 0 \u003c= heights[i] \u003c= 104 ","date":"2015-03-25","objectID":"/leetcode/0084/:1:0","tags":null,"title":"0084：柱状图中最大的矩形（★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"分析 ","date":"2015-03-25","objectID":"/leetcode/0084/:2:0","tags":null,"title":"0084：柱状图中最大的矩形（★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"#1 直接遍历矩形的底会超时，有个巧妙的想法是遍历矩形的高： 最大矩形的高度必然是某个柱子的高度 于是遍历每根柱子作为高，找左右能延伸的最大宽度即可 找左右第一根更矮的柱子，容易想到单调栈 def largestRectangleArea(self, heights: List[int]) -\u003e int: n = len(heights) left, stack = [-1] * n, [] for i in range(n): while stack and heights[stack[-1]] \u003e= heights[i]: stack.pop() left[i] = stack[-1] i","date":"2015-03-25","objectID":"/leetcode/0084/:2:1","tags":null,"title":"0084：柱状图中最大的矩形（★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"#2 其实可以一趟解决： 令栈中严格递增 遍历到位置 j 且出栈位置 i 时，i 的上一个更小元素即为 stack[-1] 如果 heights[i]\u003eheights[j]，i 的下一个更小元素即为 j，即得到 i 对应的最大宽度 如果 heights[i]==heights[j]，i 和 j 对应的最大宽度相同，可以留给 j 来计算 注意最后栈中可能还有剩余元素，需要遍历计算。一个更简单的做法是在 heights 末尾加一个极小值，让所有元素都出栈。 ","date":"2015-03-25","objectID":"/leetcode/0084/:2:2","tags":null,"title":"0084：柱状图中最大的矩形（★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"解答 def largestRectangleArea(self, heights: List[int]) -\u003e int: res, stack = 0, [] for j, y in enumerate(heights+[0]): while stack and stack[-1][1] \u003e= y: i, x = stack.pop() left = stack[-1][0] if stack else -1 res = max(res, x*(j-left-1)) stack.append((j, y)) return res 308 ms ","date":"2015-03-25","objectID":"/leetcode/0084/:3:0","tags":null,"title":"0084：柱状图中最大的矩形（★★）","uri":"/leetcode/0084/"},{"categories":null,"content":" 力扣第 83 题 ","date":"2015-03-24","objectID":"/leetcode/0083/:0:0","tags":null,"title":"0083：删除排序链表中的重复元素","uri":"/leetcode/0083/"},{"categories":null,"content":"题目 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例 1： 输入：head = [1,1,2] 输出：[1,2] 示例 2： 输入：head = [1,1,2,3,3] 输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 \u003c= Node.val \u003c= 100 题目数据保证链表已经按升序 排列 ","date":"2015-03-24","objectID":"/leetcode/0083/:1:0","tags":null,"title":"0083：删除排序链表中的重复元素","uri":"/leetcode/0083/"},{"categories":null,"content":"分析 遇到相邻的数相等时跳过即可。 ","date":"2015-03-24","objectID":"/leetcode/0083/:2:0","tags":null,"title":"0083：删除排序链表中的重复元素","uri":"/leetcode/0083/"},{"categories":null,"content":"解答 def deleteDuplicates(self, head: ListNode) -\u003e ListNode: p = head while p and p.next: if p.val == p.next.val: p.next = p.next.next else: p = p.next return head 44 ms ","date":"2015-03-24","objectID":"/leetcode/0083/:3:0","tags":null,"title":"0083：删除排序链表中的重复元素","uri":"/leetcode/0083/"},{"categories":null,"content":" 力扣第 82 题 ","date":"2015-03-23","objectID":"/leetcode/0082/:0:0","tags":null,"title":"0082：删除排序链表中的重复元素 II（★）","uri":"/leetcode/0082/"},{"categories":null,"content":"题目 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。 示例 1： 输入：head = [1,2,3,3,4,4,5] 输出：[1,2,5] 示例 2： 输入：head = [1,1,1,2,3] 输出：[2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 \u003c= Node.val \u003c= 100 题目数据保证链表已经按升序 排列 ","date":"2015-03-23","objectID":"/leetcode/0082/:1:0","tags":null,"title":"0082：删除排序链表中的重复元素 II（★）","uri":"/leetcode/0082/"},{"categories":null,"content":"分析 0083 进阶版，当后面两个节点的值相等时，跳过所有等于该值的节点即可。 表头可能也要跳过，因此新建个哑结点。 ","date":"2015-03-23","objectID":"/leetcode/0082/:2:0","tags":null,"title":"0082：删除排序链表中的重复元素 II（★）","uri":"/leetcode/0082/"},{"categories":null,"content":"解答 def deleteDuplicates(self, head: ListNode) -\u003e ListNode: dummy = p = ListNode(next=head) while p.next and p.next.next: if p.next.val == p.next.next.val: val = p.next.val p.next = p.next.next.next while p.next and p.next.val == val: p.next = p.next.next else: p = p.next return dummy.next 36 ms ","date":"2015-03-23","objectID":"/leetcode/0082/:3:0","tags":null,"title":"0082：删除排序链表中的重复元素 II（★）","uri":"/leetcode/0082/"},{"categories":null,"content":" 力扣第 81 题 ","date":"2015-03-22","objectID":"/leetcode/0081/:0:0","tags":null,"title":"0081：搜索旋转排序数组 II（★）","uri":"/leetcode/0081/"},{"categories":null,"content":"题目 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u003c= k \u003c nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标","date":"2015-03-22","objectID":"/leetcode/0081/:1:0","tags":null,"title":"0081：搜索旋转排序数组 II（★）","uri":"/leetcode/0081/"},{"categories":null,"content":"分析 由 0154 可以找到分割位置 x，然后在 nums[:x]，nums[x:] 中分别 二分查找 target 即可。 ","date":"2015-03-22","objectID":"/leetcode/0081/:2:0","tags":null,"title":"0081：搜索旋转排序数组 II（★）","uri":"/leetcode/0081/"},{"categories":null,"content":"解答 def search(self, nums: List[int], target: int) -\u003e bool: while len(nums) \u003e 1 and nums[-1] == nums[0]: nums.pop() n = len(nums) self.__class__.__getitem__ = lambda self, x: nums[x] \u003c= nums[-1] x = bisect_left(self, True, 0, n - 1) i = bisect_left(nums, target, 0, x - 1) if x else 0 j = bisect_left(","date":"2015-03-22","objectID":"/leetcode/0081/:3:0","tags":null,"title":"0081：搜索旋转排序数组 II（★）","uri":"/leetcode/0081/"},{"categories":null,"content":" 力扣第 80 题 ","date":"2015-03-21","objectID":"/leetcode/0080/:0:0","tags":null,"title":"0080：删除有序数组中的重复项 II（★）","uri":"/leetcode/0080/"},{"categories":null,"content":"题目 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 说明： 为什么返回数值是整数，但输出的答案是数组呢？ 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你","date":"2015-03-21","objectID":"/leetcode/0080/:1:0","tags":null,"title":"0080：删除有序数组中的重复项 II（★）","uri":"/leetcode/0080/"},{"categories":null,"content":"分析 类似 0026，只是元素最多出现次数从一次变成两次。 ","date":"2015-03-21","objectID":"/leetcode/0080/:2:0","tags":null,"title":"0080：删除有序数组中的重复项 II（★）","uri":"/leetcode/0080/"},{"categories":null,"content":"解答 def removeDuplicates(self, nums: List[int]) -\u003e int: i = 0 for num in nums: if i \u003c 2 or num != nums[i-2]: nums[i] = num i += 1 return i 40 ms ","date":"2015-03-21","objectID":"/leetcode/0080/:3:0","tags":null,"title":"0080：删除有序数组中的重复项 II（★）","uri":"/leetcode/0080/"},{"categories":null,"content":" 力扣第 79 题 ","date":"2015-03-20","objectID":"/leetcode/0079/:0:0","tags":null,"title":"0079：单词搜索（★）","uri":"/leetcode/0079/"},{"categories":null,"content":"题目 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例 1： 输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" 输出：true 示例 2： 输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"","date":"2015-03-20","objectID":"/leetcode/0079/:1:0","tags":null,"title":"0079：单词搜索（★）","uri":"/leetcode/0079/"},{"categories":null,"content":"分析 典型的回溯法，依次找单词的每个字符即可。 ","date":"2015-03-20","objectID":"/leetcode/0079/:2:0","tags":null,"title":"0079：单词搜索（★）","uri":"/leetcode/0079/"},{"categories":null,"content":"解答 def exist(self, board: List[List[str]], word: str) -\u003e bool: def dfs(k, i, j): if k==len(word): return True A = product(range(m),range(n)) if k==0 else [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] for x, y in A: if 0 \u003c=x\u003cm and 0\u003c=y\u003cn and board[x][y]==word[k]: c = board[x][y] board[x][y] = '0' if dfs(k+1, x, ","date":"2015-03-20","objectID":"/leetcode/0079/:3:0","tags":null,"title":"0079：单词搜索（★）","uri":"/leetcode/0079/"},{"categories":null,"content":"*附加 针对本题有个优化： 当 word 某个字符数大于 board，显然不可能，可以直接返回 False 这种优化只适用于特定的测试用例，属于 trick，一般不需要 def exist(self, board: List[List[str]], word: str) -\u003e bool: def dfs(k, i, j): if k==len(word): return True A = product(range(m),range(n)) if k==0 else [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] for x, y in A: if 0 \u003c=x\u003cm and ","date":"2015-03-20","objectID":"/leetcode/0079/:4:0","tags":null,"title":"0079：单词搜索（★）","uri":"/leetcode/0079/"},{"categories":null,"content":" 力扣第 78 题 ","date":"2015-03-19","objectID":"/leetcode/0078/:0:0","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 输入：nums = [0] 输出：[[],[0]] 提示： 1 \u003c= nums.length \u003c= 10 -10 \u003c= nums[i] \u003c= 10 nums 中的所有元素 互不相同 ","date":"2015-03-19","objectID":"/leetcode/0078/:1:0","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"分析 ","date":"2015-03-19","objectID":"/leetcode/0078/:2:0","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"#1 典型的回溯问题，遍历时有取或不取两种选择。 def subsets(self, nums: List[int]) -\u003e List[List[int]]: def dfs(i): res.append(path[:]) for j in range(i, n): path.append(nums[j]) dfs(j+1) path.pop() res, path, n = [], [], len(nums) dfs(0) return res 32 ms ","date":"2015-03-19","objectID":"/leetcode/0078/:2:1","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"#2 实际应用中常用递推式的写法。 令 dp[i] 代表 nums[:i] 的所有子集，则： $$dp[i] = dp[i-1]+[sub+[nums[i]] \\ for\\ sub\\ in\\ dp[i-1]]$$ ","date":"2015-03-19","objectID":"/leetcode/0078/:2:2","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"解答 def subsets(self, nums: List[int]) -\u003e List[List[int]]: res = [[]] for x in nums: res += [sub+[x] for sub in res] return res 40 ms ","date":"2015-03-19","objectID":"/leetcode/0078/:3:0","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":" 力扣第 77 题 ","date":"2015-03-18","objectID":"/leetcode/0077/:0:0","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"题目 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 示例 1： 输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 示例 2： 输入：n = 1, k = 1 输出：[[1]] 提示： 1 \u003c= n \u003c= 20 1 \u003c= k \u003c= n ","date":"2015-03-18","objectID":"/leetcode/0077/:1:0","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"分析 ","date":"2015-03-18","objectID":"/leetcode/0077/:2:0","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"#1 可以直接调库。 def combine(self, n: int, k: int) -\u003e List[List[int]]: return list(combinations(range(1, n+1), k)) 44 ms ","date":"2015-03-18","objectID":"/leetcode/0077/:2:1","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"#2 0078 升级版，添加了个数的限制。 ","date":"2015-03-18","objectID":"/leetcode/0077/:2:2","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"解答 def combine(self, n: int, k: int) -\u003e List[List[int]]: def dfs(i): if n + 1 - i + len(path) \u003c k: return if len(path) == k: res.append(path[:]) return for j in range(i, n + 1): path.append(j) dfs(j+1) path.pop() res, path = [], [] dfs(1) return res 44 ms ","date":"2015-03-18","objectID":"/leetcode/0077/:3:0","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":" 力扣第 76 题 ","date":"2015-03-17","objectID":"/leetcode/0076/:0:0","tags":null,"title":"0076：最小覆盖子串（★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"题目 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 输入：s = \"ADOBECODEBANC\", t = \"ABC\" 输出：\"BANC\" 解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。 示例 2： 输入：s = \"a\", t = \"a\" 输出：\"a\" 解释：整个字符串 s 是最小覆盖子串。 示","date":"2015-03-17","objectID":"/leetcode/0076/:1:0","tags":null,"title":"0076：最小覆盖子串（★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"分析 ","date":"2015-03-17","objectID":"/leetcode/0076/:2:0","tags":null,"title":"0076：最小覆盖子串（★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"#1 0209 升级版，遍历每个位置 j 作为结尾，找符合条件的最短子串 [i, j] 即可。 发现遍历中 i 必然是不动或向右移的，因此是滑动窗口，可以用 Counter 来判断是否符合。 def minWindow(self, s: str, t: str) -\u003e str: ct, ct2 = Counter(t), Counter() res, i = s+' ', 0 for j, char in enumerate(s): ct2[char] += 1 while not ct-ct2: res = res if len(res)\u003c=(j-i+1) else s[i:j+1] ct2","date":"2015-03-17","objectID":"/leetcode/0076/:2:1","tags":null,"title":"0076：最小覆盖子串（★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"#2 显然每次用 ct-ct2 来判断是否符合比较耗时。 有个巧妙的方法是新加一个变量 valid 维护有用字符的个数。 移动 j 时，如果 ct2[s[j]] \u003c ct[s[j]]，s[j] 就是有用的，cnt 增 1 移动 i 时，如果 ct2[s[i]] \u003e ct[s[i]]，s[i] 就是无用的，可以移动 ","date":"2015-03-17","objectID":"/leetcode/0076/:2:2","tags":null,"title":"0076：最小覆盖子串（★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"解答 def minWindow(self, s: str, t: str) -\u003e str: ct, ct2 = Counter(t), Counter() res, i, valid = s+' ', 0, 0 for j, char in enumerate(s): if ct2[char] \u003c ct[char]: valid += 1 ct2[char] += 1 if valid == len(t): while ct2[s[i]]\u003ect[s[i]]: ct2[s[i]] -= 1 i += 1 res = res if len(res)\u003c=(j-i+1) else s[i:j+1] ","date":"2015-03-17","objectID":"/leetcode/0076/:3:0","tags":null,"title":"0076：最小覆盖子串（★★）","uri":"/leetcode/0076/"},{"categories":null,"content":" 力扣第 75 题 ","date":"2015-03-16","objectID":"/leetcode/0075/:0:0","tags":null,"title":"0075：颜色分类（★）","uri":"/leetcode/0075/"},{"categories":null,"content":"题目 给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 必须在不使用库内置的 sort 函数的情况下解决这个问题。 示例 1： 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2： 输入：nums = [2,0,1] 输出：[0,1,2] 提示： n == nums.length 1 \u003c= n \u003c= 300 nums[i] 为 0、1 或 2 进阶： 你能想出一个仅使用常数空间的一趟扫描算法吗？ ","date":"2015-03-16","objectID":"/leetcode/0075/:1:0","tags":null,"title":"0075：颜色分类（★）","uri":"/leetcode/0075/"},{"categories":null,"content":"分析 ","date":"2015-03-16","objectID":"/leetcode/0075/:2:0","tags":null,"title":"0075：颜色分类（★）","uri":"/leetcode/0075/"},{"categories":null,"content":"#1 最简单的就是直接排序。 def sortColors(self, nums: List[int]) -\u003e None: nums.sort() 时间复杂度 O(N*log N)，36 ms ","date":"2015-03-16","objectID":"/leetcode/0075/:2:1","tags":null,"title":"0075：颜色分类（★）","uri":"/leetcode/0075/"},{"categories":null,"content":"#2 题目要求 O(1) 空间，只能考虑交换或赋值了。 有个巧妙的想法是将所有 0 放到头部，所有 2 放到尾部，剩下部分即为 1 本题不能直接赋值，可能会覆盖掉有用信息，所以考虑交换 特别注意，如果交换过来还是 0 或 2，应该循环操作 ","date":"2015-03-16","objectID":"/leetcode/0075/:2:2","tags":null,"title":"0075：颜色分类（★）","uri":"/leetcode/0075/"},{"categories":null,"content":"解答 def sortColors(self, nums: List[int]) -\u003e None: i, l, r = 0, 0, len(nums)-1 while i \u003c= r: if nums[i] == 0 and i \u003e l: nums[l], nums[i] = nums[i], nums[l] l += 1 elif nums[i] == 2 and i \u003c r: nums[i], nums[r] = nums[r], nums[i] r -= 1 else: i += 1 时间复杂度 O(N)，28 ms ","date":"2015-03-16","objectID":"/leetcode/0075/:3:0","tags":null,"title":"0075：颜色分类（★）","uri":"/leetcode/0075/"},{"categories":null,"content":" 力扣第 74 题 ","date":"2015-03-15","objectID":"/leetcode/0074/:0:0","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"题目 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1： 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 输出：true 示例 2： 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 输出：false 提示： m == matrix.length n == matrix[i].length 1 \u003c= m, n \u003c","date":"2015-03-15","objectID":"/leetcode/0074/:1:0","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"分析 ","date":"2015-03-15","objectID":"/leetcode/0074/:2:0","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"#1 可以先二分查找定位是哪一行，再在该行中二分查找。 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: i = bisect_right(matrix, target, 1, key=lambda x: x[0])-1 j = bisect_right(matrix[i], target, 1)-1 return matrix[i][j]==target 时间复杂度 O(log(M*N))，40 ms ","date":"2015-03-15","objectID":"/leetcode/0074/:2:1","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"#2 也可以将 matrix 看作一维升序数组，进行二分查找。注意下标的转换即可。 ","date":"2015-03-15","objectID":"/leetcode/0074/:2:2","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"解答 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: m, n = len(matrix), len(matrix[0]) x = bisect_left(range(m*n-1), target, key=lambda x: matrix[x//n][x%n]) return matrix[x//n][x%n] == target 时间复杂度 O(log(M*N))，40 ms ","date":"2015-03-15","objectID":"/leetcode/0074/:3:0","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":" 力扣第 73 题 ","date":"2015-03-14","objectID":"/leetcode/0073/:0:0","tags":null,"title":"0073：矩阵置零（★）","uri":"/leetcode/0073/"},{"categories":null,"content":"题目 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。 示例 1： 输入：matrix = [[1,1,1],[1,0,1],[1,1,1]] 输出：[[1,0,1],[0,0,0],[1,0,1]] 示例 2： 输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] 输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]] 提示： m == matrix.length n == matrix[0].length 1 \u003c= m, n \u003c= 200 -231 \u003c= matrix[i][j]","date":"2015-03-14","objectID":"/leetcode/0073/:1:0","tags":null,"title":"0073：矩阵置零（★）","uri":"/leetcode/0073/"},{"categories":null,"content":"分析 ","date":"2015-03-14","objectID":"/leetcode/0073/:2:0","tags":null,"title":"0073：矩阵置零（★）","uri":"/leetcode/0073/"},{"categories":null,"content":"#1 可以先遍历一趟记录有 0 的行和列，再遍历一趟将符合的元素置 0 即可。 def setZeroes(self, matrix: List[List[int]]) -\u003e None: row, col, m, n = set(), set(), len(matrix), len(matrix[0]) for i, j in product(range(m), range(n)): if matrix[i][j] == 0: row.add(i) col.add(j) for i, j in product(range(m), range(n)): if i in row or j in c","date":"2015-03-14","objectID":"/leetcode/0073/:2:1","tags":null,"title":"0073：矩阵置零（★）","uri":"/leetcode/0073/"},{"categories":null,"content":"#2 要求只用常数空间，所以考虑用矩阵内的元素来标记： 为了方便，直接把行首和列首变为 0 来作为标记 第二趟遍历时先根据首行和首列的信息改变其它位置的元素，最后再改变首行和首列。 注意首行和首列的标记位都是 matrix[0][0]，冲突了，所以添加一个额外参数来标记首行 ","date":"2015-03-14","objectID":"/leetcode/0073/:2:2","tags":null,"title":"0073：矩阵置零（★）","uri":"/leetcode/0073/"},{"categories":null,"content":"解答 def setZeroes(self, matrix: List[List[int]]) -\u003e None: m, n, first_row = len(matrix), len(matrix[0]), False for i, j in product(range(m), range(n)): if matrix[i][j] == 0: if i == 0: first_row = True else: matrix[i][0] = matrix[0][j] = 0 for i, j in product(range(1, m), range(1, n)): if matrix[i][0","date":"2015-03-14","objectID":"/leetcode/0073/:3:0","tags":null,"title":"0073：矩阵置零（★）","uri":"/leetcode/0073/"},{"categories":null,"content":" 力扣第 72 题 ","date":"2015-03-13","objectID":"/leetcode/0072/:0:0","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"题目 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 输入：word1 = \"horse\", word2 = \"ros\" 输出：3 解释： horse -\u003e rorse (将 'h' 替换为 'r') rorse -\u003e rose (删除 'r') rose -\u003e ros (删除 'e') 示例 2： 输入：word1 = \"intention\", word2 = \"execution\" 输出：5 解释： intention -\u003e inentio","date":"2015-03-13","objectID":"/leetcode/0072/:1:0","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"分析 ","date":"2015-03-13","objectID":"/leetcode/0072/:2:0","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"#1 典型的双串 dp，令 dp[i][j] 表示 word1[:i] 和 word2[:j] 的编辑距离，即可递推。 def minDistance(self, word1: str, word2: str) -\u003e int: m, n = len(word1), len(word2) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(m+1): for j in range(n+1): if i==0 or j==0: dp[i][j] = i+j elif word1[i-1] == word2[j-1]: dp[i][j] = dp[","date":"2015-03-13","objectID":"/leetcode/0072/:2:1","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"#2 可以用滚动数组优化空间。 ","date":"2015-03-13","objectID":"/leetcode/0072/:2:2","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"解答 def minDistance(self, word1: str, word2: str) -\u003e int: m, n = len(word1), len(word2) dp = list(range(n+1)) for i in range(1, m+1): prev = dp[:] dp[0] = i for j in range(1, n+1): if word1[i-1] == word2[j-1]: dp[j] = prev[j-1] else: dp[j] = 1+ min(dp[j-1], prev[j], prev[j-1]) return dp[-1] 112 ms ","date":"2015-03-13","objectID":"/leetcode/0072/:3:0","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":" 力扣第 71 题 ","date":"2015-03-12","objectID":"/leetcode/0071/:0:0","tags":null,"title":"0071：简化路径（★）","uri":"/leetcode/0071/"},{"categories":null,"content":"题目 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。 请注意，返回的 规范路径 必须遵循下述格式： 始终以斜杠 '/' 开头。 两个目录名之间必须只有一个斜杠 '/' 。 最后一个目录名（如果存在）不能 以 '/","date":"2015-03-12","objectID":"/leetcode/0071/:1:0","tags":null,"title":"0071：简化路径（★）","uri":"/leetcode/0071/"},{"categories":null,"content":"分析 典型的栈应用。遍历 ‘/’ 隔开的元素，遇到目录名入栈，遇到 ‘..’ 出栈即可。 ","date":"2015-03-12","objectID":"/leetcode/0071/:2:0","tags":null,"title":"0071：简化路径（★）","uri":"/leetcode/0071/"},{"categories":null,"content":"解答 def simplifyPath(self, path: str) -\u003e str: stack = [] for word in path.split('/'): if word == '..' and stack: stack.pop() elif word not in ['..', '.', '']: stack.append(word) return '/' + '/'.join(stack) 28 ms ","date":"2015-03-12","objectID":"/leetcode/0071/:3:0","tags":null,"title":"0071：简化路径（★）","uri":"/leetcode/0071/"},{"categories":null,"content":" 力扣第 70 题 ","date":"2015-03-11","objectID":"/leetcode/0070/:0:0","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 提示： 1 \u003c= n \u003c= 45 ","date":"2015-03-11","objectID":"/leetcode/0070/:1:0","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"分析 ","date":"2015-03-11","objectID":"/leetcode/0070/:2:0","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"#1 很经典的递归问题，最后必然爬 1 或 2 个台阶，转为递归子问题。 显然有很多重复子问题，用动态规划。 def climbStairs(self, n: int) -\u003e int: dp = [1]*(n+1) for i in range(2, n+1): dp[i] = dp[i-1]+dp[i-2] return dp[-1] 40 ms ","date":"2015-03-11","objectID":"/leetcode/0070/:2:1","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"#2 dp[i] 只依赖 dp[i-1] 和 dp[i-2] ，可以优化为两个变量。 ","date":"2015-03-11","objectID":"/leetcode/0070/:2:2","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"解答 def climbStairs(self, n: int) -\u003e int: a, b = 1, 1 for _ in range(n-1): a, b = b, a+b return b 32 ms ","date":"2015-03-11","objectID":"/leetcode/0070/:3:0","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":" 力扣第 69 题 ","date":"2015-03-10","objectID":"/leetcode/0069/:0:0","tags":null,"title":"0069：x 的平方根 ","uri":"/leetcode/0069/"},{"categories":null,"content":"题目 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 示例 1： 输入：x = 4 输出：2 示例 2： 输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示： 0 \u003c= x \u003c= 231 - 1 ","date":"2015-03-10","objectID":"/leetcode/0069/:1:0","tags":null,"title":"0069：x 的平方根 ","uri":"/leetcode/0069/"},{"categories":null,"content":"分析 ","date":"2015-03-10","objectID":"/leetcode/0069/:2:0","tags":null,"title":"0069：x 的平方根 ","uri":"/leetcode/0069/"},{"categories":null,"content":"#1 就是求满足 y * y \u003c= x 的最大整数 y 。y * y 单调递增，因此可以用二分查找。 python 中借助 bisect 和魔法方法可以节省代码。 def mySqrt(self, x: int) -\u003e int: self.__class__.__getitem__ = lambda self, i: i*i \u003e x return bisect_left(self, True, 0, x+1) - 1 36 ms ","date":"2015-03-10","objectID":"/leetcode/0069/:2:1","tags":null,"title":"0069：x 的平方根 ","uri":"/leetcode/0069/"},{"categories":null,"content":"#2 本题还可以用牛顿迭代法，对于初始较大的 n，迭代 $n=(n+x/n)/2$ 可以不断逼近 $\\sqrt x$。 注意若 $n \u003e \\sqrt x$，迭代后的 n 依然成立。所以对迭代后的 n 取整若得到 n’\u003c=$\\sqrt x$，n’ 即是所求。 ","date":"2015-03-10","objectID":"/leetcode/0069/:2:2","tags":null,"title":"0069：x 的平方根 ","uri":"/leetcode/0069/"},{"categories":null,"content":"解答 def mySqrt(self, x: int) -\u003e int: n = x while n * n \u003e x: n = (n + x // n) // 2 return n 44 ms ","date":"2015-03-10","objectID":"/leetcode/0069/:3:0","tags":null,"title":"0069：x 的平方根 ","uri":"/leetcode/0069/"},{"categories":null,"content":" 力扣第 68 题 ","date":"2015-03-09","objectID":"/leetcode/0068/:0:0","tags":null,"title":"0068：文本左右对齐（★★）","uri":"/leetcode/0068/"},{"categories":null,"content":"题目 给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。 你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。 文本的最后一行应为左对齐，且单词之间不插入额外的空格。 注意: 单词是指由非空格字符组成的字符序列。 每个单词的长度大于 0，小于等于 maxWidth。 输入单词数组 words","date":"2015-03-09","objectID":"/leetcode/0068/:1:0","tags":null,"title":"0068：文本左右对齐（★★）","uri":"/leetcode/0068/"},{"categories":null,"content":"分析 遍历单词放到第一行中，放不下了就调整第一行的空格分配，然后放到下一行。 具体分配空格时： 先得到空格总数 total 和单词数 n 求得平均空格数 q 和余数 r 前 r 个间隔分 q+1 个空格，后面的分 q 个空格即可 注意 n==1 和最后一行的特殊情况，在后面补空格即可 ","date":"2015-03-09","objectID":"/leetcode/0068/:2:0","tags":null,"title":"0068：文本左右对齐（★★）","uri":"/leetcode/0068/"},{"categories":null,"content":"解答 def fullJustify(self, words: List[str], maxWidth: int) -\u003e List[str]: res, row, s = [], [], 0 for word in words: if s + len(row) + len(word) \u003e maxWidth: if len(row) == 1: res.append(row[0].ljust(maxWidth)) else: q, r = divmod(maxWidth-s, len(row)-1) res.append(''.join(row[i]+' '*(q+(i\u003cr)) for i in","date":"2015-03-09","objectID":"/leetcode/0068/:3:0","tags":null,"title":"0068：文本左右对齐（★★）","uri":"/leetcode/0068/"},{"categories":null,"content":" 力扣第 67 题 ","date":"2015-03-08","objectID":"/leetcode/0067/:0:0","tags":null,"title":"0067：二进制求和","uri":"/leetcode/0067/"},{"categories":null,"content":"题目 给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。 示例 1： 输入:a = \"11\", b = \"1\" 输出：\"100\" 示例 2： 输入：a = \"1010\", b = \"1011\" 输出：\"10101\" 提示： 1 \u003c= a.length, b.length \u003c= 104 a 和 b 仅由字符 '0' 或 '1' 组成 字符串如果不是 \"0\" ，就不含前导零 ","date":"2015-03-08","objectID":"/leetcode/0067/:1:0","tags":null,"title":"0067：二进制求和","uri":"/leetcode/0067/"},{"categories":null,"content":"分析 ","date":"2015-03-08","objectID":"/leetcode/0067/:2:0","tags":null,"title":"0067：二进制求和","uri":"/leetcode/0067/"},{"categories":null,"content":"#1 可以直接调库。 def addBinary(self, a: str, b: str) -\u003e str: return bin(int(a, 2)+int(b, 2))[2:] 40 ms ","date":"2015-03-08","objectID":"/leetcode/0067/:2:1","tags":null,"title":"0067：二进制求和","uri":"/leetcode/0067/"},{"categories":null,"content":"#2 也可以模拟进位加法，将除数换成 2 即可。 def addBinary(self, a: str, b: str) -\u003e str: res, carry, i, j = '', 0, len(a)-1, len(b)-1 while i\u003e=0 or j\u003e=0 or carry: x = int(a[i]) if i\u003e=0 else 0 y = int(b[j]) if j\u003e=0 else 0 carry, r = divmod(x+y+carry, 2) res += str(r) i -= 1 j -= 1 return res[::-1] 36 ms ","date":"2015-03-08","objectID":"/leetcode/0067/:2:2","tags":null,"title":"0067：二进制求和","uri":"/leetcode/0067/"},{"categories":null,"content":" 力扣第 66 题 ","date":"2015-03-07","objectID":"/leetcode/0066/:0:0","tags":null,"title":"0066：加一","uri":"/leetcode/0066/"},{"categories":null,"content":"题目 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1： 输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2： 输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3： 输入：digits = [0] 输出：[1] 提示： 1 \u003c= digits.length \u003c= 100 0 \u003c= digits[i] \u003c= 9 ","date":"2015-03-07","objectID":"/leetcode/0066/:1:0","tags":null,"title":"0066：加一","uri":"/leetcode/0066/"},{"categories":null,"content":"分析 模拟进位加法即可，若最终还有进位，需要再加一位。 ","date":"2015-03-07","objectID":"/leetcode/0066/:2:0","tags":null,"title":"0066：加一","uri":"/leetcode/0066/"},{"categories":null,"content":"解答 def plusOne(self, digits: List[int]) -\u003e List[int]: res, carry = [], 1 for digit in digits[::-1]: s = digit + carry res.append(s % 10) carry = s//10 if carry: res.append(carry) return res[::-1] 36 ms ","date":"2015-03-07","objectID":"/leetcode/0066/:3:0","tags":null,"title":"0066：加一","uri":"/leetcode/0066/"},{"categories":null,"content":" 力扣第 65 题 ","date":"2015-03-06","objectID":"/leetcode/0065/:0:0","tags":null,"title":"0065：有效数字（★★）","uri":"/leetcode/0065/"},{"categories":null,"content":"题目 有效数字（按顺序）可以分成以下几个部分： 一个 小数 或者 整数 （可选）一个 'e' 或 'E' ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（'+' 或 '-'） 下述格式之一： 至少一位数字，后面跟着一个点 '.' 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字 一个点 '.' ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（'+' 或 '-'） 至少一位数字 部分有效数字列举如下：[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E","date":"2015-03-06","objectID":"/leetcode/0065/:1:0","tags":null,"title":"0065：有效数字（★★）","uri":"/leetcode/0065/"},{"categories":null,"content":"分析 首先想到用正则。 有效整数很简单: \"[+-]?\\d+\" 有效小数基于有效整数，考虑两种格式: '.' 之前至少一位数字 \"[+-]?\\d+\\.\\d*\" '.' 之前没有数字，之后至少一位 \"[+-]?\\.\\d+\" 有效整数或小数整合为： \"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)\" 有效数字基于有效整数和小数，考虑两种格式: 不存在 \"eE\", 就是一个整数或小数 \"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)\" 存在一个 \"eE\", 前面是整数或小数, 后面是整数 \"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)[eE][+-]?\\d+\" 整合一下即得最终表达式。 ","date":"2015-03-06","objectID":"/leetcode/0065/:2:0","tags":null,"title":"0065：有效数字（★★）","uri":"/leetcode/0065/"},{"categories":null,"content":"解答 def isNumber(self, s: str) -\u003e bool: return bool(re.match(r\"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$\", s)) 40 ms ","date":"2015-03-06","objectID":"/leetcode/0065/:3:0","tags":null,"title":"0065：有效数字（★★）","uri":"/leetcode/0065/"},{"categories":null,"content":"*附加 还有更加通用的 DFA（确定有限状态自动机）方法。 def isNumber(self, s: str) -\u003e bool: st = ['0_initial', '1_sign', '2_int', '3_dot', '4_dot_without_int', '5_decimal', '6_e', '7_e_sign', '8_e_int'] act = ['0_sign', '1_int', '2_dot', '3_e'] shift = {st[0]: {act[0]: st[1], act[1]: st[2], act[2]: st[4]}, st[1]: {act[1]: st","date":"2015-03-06","objectID":"/leetcode/0065/:4:0","tags":null,"title":"0065：有效数字（★★）","uri":"/leetcode/0065/"},{"categories":null,"content":" 力扣第 64 题 ","date":"2015-03-05","objectID":"/leetcode/0064/:0:0","tags":null,"title":"0064：最小路径和（★）","uri":"/leetcode/0064/"},{"categories":null,"content":"题目 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示： m == grid.length n == grid[i].length 1 \u003c= m, n \u003c= 200 0 \u003c= grid[i][j] \u003c= 100 ","date":"2015-03-05","objectID":"/leetcode/0064/:1:0","tags":null,"title":"0064：最小路径和（★）","uri":"/leetcode/0064/"},{"categories":null,"content":"分析 类似 0062，只是递推关系变成了： $$dp[i][j] = min(dp[-1][j], dp[i][j-1]) + grid[i][j]$$ ","date":"2015-03-05","objectID":"/leetcode/0064/:2:0","tags":null,"title":"0064：最小路径和（★）","uri":"/leetcode/0064/"},{"categories":null,"content":"解答 def minPathSum(self, grid: List[List[int]]) -\u003e int: m, n = len(grid), len(grid[0]) dp = [float('inf')] * (n + 1) for i, j in product(range(1, m + 1), range(1, n + 1)): dp[j] = grid[i-1][j-1] + (0 if i==j==1 else min(dp[j], dp[j-1])) return dp[-1] 36 ms ","date":"2015-03-05","objectID":"/leetcode/0064/:3:0","tags":null,"title":"0064：最小路径和（★）","uri":"/leetcode/0064/"},{"categories":null,"content":" 力扣第 63 题 ","date":"2015-03-04","objectID":"/leetcode/0063/:0:0","tags":null,"title":"0063：不同路径 II（★）","uri":"/leetcode/0063/"},{"categories":null,"content":"题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例 1： 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -\u003e 向右 -\u003e 向下 -\u003e 向下 2. 向下 -\u003e 向下 -\u003e 向右","date":"2015-03-04","objectID":"/leetcode/0063/:1:0","tags":null,"title":"0063：不同路径 II（★）","uri":"/leetcode/0063/"},{"categories":null,"content":"分析 0062 进阶版，递推时注意障碍的特殊情况即可。 ","date":"2015-03-04","objectID":"/leetcode/0063/:2:0","tags":null,"title":"0063：不同路径 II（★）","uri":"/leetcode/0063/"},{"categories":null,"content":"解答 def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -\u003e int: m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [0] * (n+1) for i, j in product(range(1, m+1), range(1, n+1)): if obstacleGrid[i-1][j-1] == 1: dp[j] = 0 else: dp[j] = 1 if i == j == 1 else dp[j] + dp[j-1] return dp[-1] ","date":"2015-03-04","objectID":"/leetcode/0063/:3:0","tags":null,"title":"0063：不同路径 II（★）","uri":"/leetcode/0063/"},{"categories":null,"content":" 力扣第 62 题 ","date":"2015-03-03","objectID":"/leetcode/0062/:0:0","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 输入：m = 3, n = 7 输出：28 示例 2： 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -\u003e 向下 -\u003e 向下 2. 向下 -\u003e 向下 -\u003e 向右 3. 向下 -\u003e 向右 -\u003e 向下 示例 3： 输入：m = 7, n = 3 输出：28 示例 4： 输入：m = 3, n =","date":"2015-03-03","objectID":"/leetcode/0062/:1:0","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"分析 ","date":"2015-03-03","objectID":"/leetcode/0062/:2:0","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"#1 要到达位置 (i, j)，只能从 (i-1, j) 或 (i, j-1) 到达，可以转为递归子问题。 显然有重复子问题，所以用动态规划。 def uniquePaths(self, m: int, n: int) -\u003e int: dp = [[0]*n for _ in range(m)] for i, j in product(range(m), range(n)): dp[i][j] = 1 if i==0 or j==0 else dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 36 ms ","date":"2015-03-03","objectID":"/leetcode/0062/:2:1","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"#2 dp[i][j] 只依赖于 dp[i-1][j] 和 dp[i][j-1]，可以优化为一维数组。 ","date":"2015-03-03","objectID":"/leetcode/0062/:2:2","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"解答 def uniquePaths(self, m: int, n: int) -\u003e int: dp = [1] * n for _, j in product(range(1, m), range(1, n)): dp[j] += dp[j-1] return dp[-1] 32 ms ","date":"2015-03-03","objectID":"/leetcode/0062/:3:0","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"*附加 还可以直接用排列组合解决： 机器人要到达右下角，要走 m+n-2 步，其中 m-1 步向下，n-1 步向右 路径一一对应于由 m-1 个’下’和 n-1 个’右’组成的序列 路径数即为 m+n-2 中选 m-1 个的方案数 def uniquePaths(self, m: int, n: int) -\u003e int: return comb(m+n-2, n-1) 32 ms ","date":"2015-03-03","objectID":"/leetcode/0062/:4:0","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":" 力扣第 61 题 ","date":"2015-03-02","objectID":"/leetcode/0061/:0:0","tags":null,"title":"0061：旋转链表（★）","uri":"/leetcode/0061/"},{"categories":null,"content":"题目 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 示例 1： 输入：head = [1,2,3,4,5], k = 2 输出：[4,5,1,2,3] 示例 2： 输入：head = [0,1,2], k = 4 输出：[2,0,1] 提示： 链表中节点的数目在范围 [0, 500] 内 -100 \u003c= Node.val \u003c= 100 0 \u003c= k \u003c= 2 * 109 ","date":"2015-03-02","objectID":"/leetcode/0061/:1:0","tags":null,"title":"0061：旋转链表（★）","uri":"/leetcode/0061/"},{"categories":null,"content":"分析 这个旋转操作其实相当于在某位置将链表断开，再将前半部分接到后半部分后面。 先找到表尾 tail 并计算出链表长度 n 若 k 是 n 的倍数直接返回，否则找到新表尾 newtail，是第 n - k % n 个元素 新表头 newhead=newtail.next，断开新表尾，再将 head 接到 tail 后面即可 ","date":"2015-03-02","objectID":"/leetcode/0061/:2:0","tags":null,"title":"0061：旋转链表（★）","uri":"/leetcode/0061/"},{"categories":null,"content":"解答 def rotateRight(self, head: ListNode, k: int) -\u003e ListNode: if not head: return head tail, n = head, 1 while tail.next: tail = tail.next n += 1 k %= n if not k: return head newtail = head for _ in range(n-k-1): newtail = newtail.next newhead = newtail.next tail.next = head newtail.next = None retu","date":"2015-03-02","objectID":"/leetcode/0061/:3:0","tags":null,"title":"0061：旋转链表（★）","uri":"/leetcode/0061/"},{"categories":null,"content":" 力扣第 60 题 ","date":"2015-03-01","objectID":"/leetcode/0060/:0:0","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"题目 给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" 给定 n 和 k，返回第 k 个排列。 示例 1： 输入：n = 3, k = 3 输出：\"213\" 示例 2： 输入：n = 4, k = 9 输出：\"2314\" 示例 3： 输入：n = 3, k = 1 输出：\"123\" 提示： 1 \u003c= n \u003c= 9 1 \u003c= k \u003c= n! ","date":"2015-03-01","objectID":"/leetcode/0060/:1:0","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"分析 ","date":"2015-03-01","objectID":"/leetcode/0060/:2:0","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"#1 可以直接调包得到所有排列，返回第 k 个排列。 def getPermutation(self, n: int, k: int) -\u003e str: res = list(permutations(range(1, n+1)))[k-1] return ''.join(map(str, res)) 1908 ms ","date":"2015-03-01","objectID":"/leetcode/0060/:2:1","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"#2 也可以递推： 为了方便，令 k-=1 使得从 0 开始 由排列组合知识可知，首位固定时有 (n-1)! 种情况 那么第 k 个排列的首位即为第 k//(n-1)! 小的元素 确定首位元素后，转为求剩下元素的第 k%(n-1)! 个排列，转为递归子问题 为了方便，维护一个有序数组 A，每次弹出确定的元素即可 ","date":"2015-03-01","objectID":"/leetcode/0060/:2:2","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"解答 def getPermutation(self, n: int, k: int) -\u003e str: res, A, k = '', list(range(1, n+1)), k-1 for i in range(n): q, k = divmod(k, factorial(n-1-i)) res += str(A.pop(q)) return res 32 ms ","date":"2015-03-01","objectID":"/leetcode/0060/:3:0","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":" 力扣第 59 题 ","date":"2015-02-28","objectID":"/leetcode/0059/:0:0","tags":null,"title":"0059：螺旋矩阵 II（★）","uri":"/leetcode/0059/"},{"categories":null,"content":"题目 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 1： 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 输入：n = 1 输出：[[1]] 提示： 1 \u003c= n \u003c= 20 ","date":"2015-02-28","objectID":"/leetcode/0059/:1:0","tags":null,"title":"0059：螺旋矩阵 II（★）","uri":"/leetcode/0059/"},{"categories":null,"content":"分析 与 0054 类似，模拟过程： 初始位置 \u003cx=0,y=0\u003e，初始方向 \u003cdx=0,dy=1\u003e 到达边界位置则改变方向为 \u003cdy,-dx\u003e 为了方便，初始 matrix 的值都为 0 ，当 matrix[(x+dx)%m][(y+dy)%n]!=0 即代表到达边界 ","date":"2015-02-28","objectID":"/leetcode/0059/:2:0","tags":null,"title":"0059：螺旋矩阵 II（★）","uri":"/leetcode/0059/"},{"categories":null,"content":"解答 def generateMatrix(self, n: int) -\u003e List[List[int]]: res = [[0]*n for _ in range(n)] x, y, dx, dy = 0, 0, 0, 1 for i in range(n*n): res[x][y] = i+1 if res[(x+dx)%n][(y+dy)%n]: dx, dy = dy, -dx x, y = x+dx, y+dy return res 28 ms ","date":"2015-02-28","objectID":"/leetcode/0059/:3:0","tags":null,"title":"0059：螺旋矩阵 II（★）","uri":"/leetcode/0059/"},{"categories":null,"content":" 力扣第 58 题 ","date":"2015-02-27","objectID":"/leetcode/0058/:0:0","tags":null,"title":"0058：最后一个单词的长度","uri":"/leetcode/0058/"},{"categories":null,"content":"题目 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。 示例 1： 输入：s = \"Hello World\" 输出：5 解释：最后一个单词是“World”，长度为5。 示例 2： 输入：s = \" fly me to the moon \" 输出：4 解释：最后一个单词是“moon”，长度为4。 示例 3： 输入：s = \"luffy is still joyboy\" 输出：6 解释：最后一个单词是长度为6的“joyboy”。 提示： 1 \u003c= s.length \u003c= 104 s 仅有","date":"2015-02-27","objectID":"/leetcode/0058/:1:0","tags":null,"title":"0058：最后一个单词的长度","uri":"/leetcode/0058/"},{"categories":null,"content":"分析 去掉末尾空格，按空格分隔即可。 ","date":"2015-02-27","objectID":"/leetcode/0058/:2:0","tags":null,"title":"0058：最后一个单词的长度","uri":"/leetcode/0058/"},{"categories":null,"content":"解答 def lengthOfLastWord(self, s: str) -\u003e int: return len(s.strip().split(' ')[-1]) 36 ms ","date":"2015-02-27","objectID":"/leetcode/0058/:3:0","tags":null,"title":"0058：最后一个单词的长度","uri":"/leetcode/0058/"},{"categories":null,"content":" 力扣第 57 题 ","date":"2015-02-26","objectID":"/leetcode/0057/:0:0","tags":null,"title":"0057：插入区间（★）","uri":"/leetcode/0057/"},{"categories":null,"content":"题目 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1： 输入：intervals = [[1,3],[6,9]], newInterval = [2,5] 输出：[[1,5],[6,9]] 示例 2： 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 输出：[[1,2],[3,10],[12,16]] 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 ","date":"2015-02-26","objectID":"/leetcode/0057/:1:0","tags":null,"title":"0057：插入区间（★）","uri":"/leetcode/0057/"},{"categories":null,"content":"分析 ","date":"2015-02-26","objectID":"/leetcode/0057/:2:0","tags":null,"title":"0057：插入区间（★）","uri":"/leetcode/0057/"},{"categories":null,"content":"#1 区间列表有序，因此与新区间重叠的必然是连续的。 因此遍历找到第一个重叠的，开始合并，直到不重叠为止。所有重叠的一段合并为一个区间，而前后其它区间不变。 def insert(self, intervals: List[List[int]], newInterval: List[int]) -\u003e List[List[int]]: i, (s, e) = 0, newInterval while i \u003c len(intervals) and intervals[i][1] \u003c s: i += 1 j = i while j \u003c len(intervals) and intervals[j][","date":"2015-02-26","objectID":"/leetcode/0057/:2:1","tags":null,"title":"0057：插入区间（★）","uri":"/leetcode/0057/"},{"categories":null,"content":"#2 也可以直接二分查找与新区间重叠的下标范围，替换为合并后的区间。 ","date":"2015-02-26","objectID":"/leetcode/0057/:2:2","tags":null,"title":"0057：插入区间（★）","uri":"/leetcode/0057/"},{"categories":null,"content":"解答 def insert(self, intervals: List[List[int]], newInterval: List[int]) -\u003e List[List[int]]: L, R = newInterval i = bisect_left(intervals, L, key=lambda x: x[1]) j = bisect_right(intervals, R, key=lambda x: x[0]) if i\u003cj: L, R = min(L, intervals[i][0]), max(R, intervals[j-1][1]) intervals[i:j] = [[L, ","date":"2015-02-26","objectID":"/leetcode/0057/:3:0","tags":null,"title":"0057：插入区间（★）","uri":"/leetcode/0057/"},{"categories":null,"content":" 力扣第 56 题 ","date":"2015-02-25","objectID":"/leetcode/0056/:0:0","tags":null,"title":"0056：合并区间（★）","uri":"/leetcode/0056/"},{"categories":null,"content":"题目 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例 1： 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区","date":"2015-02-25","objectID":"/leetcode/0056/:1:0","tags":null,"title":"0056：合并区间（★）","uri":"/leetcode/0056/"},{"categories":null,"content":"分析 显然能合并的区间范围必然相近，因此考虑先按起点排序，再遍历。 遍历过程中，如果当前区间的起点小于等于上一区间的终点，那么就可以合并；否则，就添加新区间。 ","date":"2015-02-25","objectID":"/leetcode/0056/:2:0","tags":null,"title":"0056：合并区间（★）","uri":"/leetcode/0056/"},{"categories":null,"content":"解答 def merge(self, intervals: List[List[int]]) -\u003e List[List[int]]: res = [] for s, e in sorted(intervals): if res and s \u003c= res[-1][1]: res[-1][1] = max(res[-1][1], e) else: res.append([s, e]) return res 56 ms ","date":"2015-02-25","objectID":"/leetcode/0056/:3:0","tags":null,"title":"0056：合并区间（★）","uri":"/leetcode/0056/"},{"categories":null,"content":" 力扣第 55 题 ","date":"2015-02-24","objectID":"/leetcode/0055/:0:0","tags":null,"title":"0055：跳跃游戏（★）","uri":"/leetcode/0055/"},{"categories":null,"content":"题目 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 \u003c= nums.length \u003c= 3 * 104 0 \u003c= nums","date":"2015-02-24","objectID":"/leetcode/0055/:1:0","tags":null,"title":"0055：跳跃游戏（★）","uri":"/leetcode/0055/"},{"categories":null,"content":"分析 和 0045 类似，考虑跳不了的特殊情况即可。 ","date":"2015-02-24","objectID":"/leetcode/0055/:2:0","tags":null,"title":"0055：跳跃游戏（★）","uri":"/leetcode/0055/"},{"categories":null,"content":"解答 def canJump(self, nums: List[int]) -\u003e bool: s, e = 0, 1 while s \u003c e \u003c len(nums): s, e = e, max(i + nums[i] for i in range(s, e)) + 1 return e \u003e= len(nums) 92 ms ","date":"2015-02-24","objectID":"/leetcode/0055/:3:0","tags":null,"title":"0055：跳跃游戏（★）","uri":"/leetcode/0055/"},{"categories":null,"content":" 力扣第 54 题 ","date":"2015-02-23","objectID":"/leetcode/0054/:0:0","tags":null,"title":"0054：螺旋矩阵（★）","uri":"/leetcode/0054/"},{"categories":null,"content":"题目 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.length n == matrix[i].length 1 \u003c= m, n \u003c= 10 -100 \u003c= matrix[i][j] \u003c= 100 ","date":"2015-02-23","objectID":"/leetcode/0054/:1:0","tags":null,"title":"0054：螺旋矩阵（★）","uri":"/leetcode/0054/"},{"categories":null,"content":"分析 考虑模拟过程: 初始位置 \u003cx=0,y=0\u003e，初始方向 \u003cdx=0,dy=1\u003e 到达边界位置则改变方向为 \u003cdy,-dx\u003e 为了方便，可以将走过的地方置 0 ，当 matrix[(x+dx)%m][(y+dy)%n]==0 即代表到达边界 ","date":"2015-02-23","objectID":"/leetcode/0054/:2:0","tags":null,"title":"0054：螺旋矩阵（★）","uri":"/leetcode/0054/"},{"categories":null,"content":"解答 def spiralOrder(self, matrix: List[List[int]]) -\u003e List[int]: res, m, n = [], len(matrix), len(matrix[0]) x, y, dx, dy = 0, 0, 0, 1 for _ in range(m*n): res.append(matrix[x][y]) matrix[x][y] = 0 if matrix[(x+dx)%m][(y+dy)%n] == 0: dx, dy = dy, -dx x, y = x+dx, y+dy return res 28 ms ","date":"2015-02-23","objectID":"/leetcode/0054/:3:0","tags":null,"title":"0054：螺旋矩阵（★）","uri":"/leetcode/0054/"},{"categories":null,"content":" 力扣第 53 题 ","date":"2015-02-22","objectID":"/leetcode/0053/:0:0","tags":null,"title":"0053：最大子数组和（★）","uri":"/leetcode/0053/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [5,4,-1,7,8] 输出：23 提示： 1 \u003c= nums.length \u003c= 105 -104 \u003c= nums[i] \u003c= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求","date":"2015-02-22","objectID":"/leetcode/0053/:1:0","tags":null,"title":"0053：最大子数组和（★）","uri":"/leetcode/0053/"},{"categories":null,"content":"分析 令 dp[j] 表示以位置 j 结尾的最大和，则 $$dp[j] = max(0, dp[j-1]) + nums[j]$$ 最后 max(dp) 即为所求。还可以优化为一个参数。 ","date":"2015-02-22","objectID":"/leetcode/0053/:2:0","tags":null,"title":"0053：最大子数组和（★）","uri":"/leetcode/0053/"},{"categories":null,"content":"解答 def maxSubArray(self, nums: List[int]) -\u003e int: res = dp = float('-inf') for num in nums: dp = max(0, dp) + num res = max(res, dp) return res 140 ms ","date":"2015-02-22","objectID":"/leetcode/0053/:3:0","tags":null,"title":"0053：最大子数组和（★）","uri":"/leetcode/0053/"},{"categories":null,"content":" 力扣第 52 题 ","date":"2015-02-21","objectID":"/leetcode/0052/:0:0","tags":null,"title":"0052：N 皇后 II（★★）","uri":"/leetcode/0052/"},{"categories":null,"content":"题目 n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。 示例 1： 输入：n = 4 输出：2 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2： 输入：n = 1 输出：1 提示： 1 \u003c= n \u003c= 9 ","date":"2015-02-21","objectID":"/leetcode/0052/:1:0","tags":null,"title":"0052：N 皇后 II（★★）","uri":"/leetcode/0052/"},{"categories":null,"content":"分析 类似 0051 ，还更简单一点。 ","date":"2015-02-21","objectID":"/leetcode/0052/:2:0","tags":null,"title":"0052：N 皇后 II（★★）","uri":"/leetcode/0052/"},{"categories":null,"content":"解答 def totalNQueens(self, n: int) -\u003e int: def dfs(i): if i == n: return 1 res = 0 for j in range(n): if col[j] == dia1[i + j] == dia2[i - j] == 0: col[j] = dia1[i + j] = dia2[i - j] = 1 res += dfs(i + 1) col[j] = dia1[i + j] = dia2[i - j] = 0 return res col, dia1, dia2 = (defaultdict(int) for _ in r","date":"2015-02-21","objectID":"/leetcode/0052/:3:0","tags":null,"title":"0052：N 皇后 II（★★）","uri":"/leetcode/0052/"},{"categories":null,"content":" 力扣第 51 题 ","date":"2015-02-20","objectID":"/leetcode/0051/:0:0","tags":null,"title":"0051：N 皇后（★★）","uri":"/leetcode/0051/"},{"categories":null,"content":"题目 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 示例 1： 输入：n = 4 输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2： 输入：n = 1 输","date":"2015-02-20","objectID":"/leetcode/0051/:1:0","tags":null,"title":"0051：N 皇后（★★）","uri":"/leetcode/0051/"},{"categories":null,"content":"分析 回溯法的典型应用。每一行只能有一个棋子，所以可以直接按行放，节省时间。 ","date":"2015-02-20","objectID":"/leetcode/0051/:2:0","tags":null,"title":"0051：N 皇后（★★）","uri":"/leetcode/0051/"},{"categories":null,"content":"解答 def solveNQueens(self, n: int) -\u003e List[List[str]]: def dfs(i): if i == n: res.append(['.'*j+'Q'+'.'*(n-j-1) for j in path]) return for j in range(n): if col[j] == dia1[i+j] == dia2[i-j] == 0: col[j] = dia1[i+j] = dia2[i-j] = 1 path.append(j) dfs(i + 1) path.pop() col[j] = dia1[i+j] = dia2[i-j] = ","date":"2015-02-20","objectID":"/leetcode/0051/:3:0","tags":null,"title":"0051：N 皇后（★★）","uri":"/leetcode/0051/"},{"categories":null,"content":"《花与爱丽丝杀人事件》是日本2015年2月20日上映的长篇动画电影，由岩井俊二导演并创作剧本，苍井优和铃木杏担任主要配音。该部作品是2004年电影《花与爱丽丝》的前传。\n影片中描述了少女时的两位女主角，转校生爱丽丝与不上学的花相识及被卷入一场神秘杀人事件当中的经过。 ","date":"2015-02-20","objectID":"/anime/hana_to_alice/","tags":null,"title":"花与爱丽丝杀人事件","uri":"/anime/hana_to_alice/"},{"categories":null,"content":"简介 《花与爱丽丝杀人事件》是日本2015年2月20日上映的长篇动画电影，由岩井俊二导演并创作剧本，苍井优和铃木杏担任主要配音。该部作品是2004年电影《花与爱丽丝》的前传。 影片中描述了少女时的两位女主角，转校生爱丽丝与不上学的花相识及被卷入一场神秘杀人事件当中的经过。 制作人员： 原作：岩井俊二 分镜：长滨博史 美术监督：泷口比吕志 色彩设计：片山由美子 原画：矶光雄 ","date":"2015-02-20","objectID":"/anime/hana_to_alice/:1:0","tags":null,"title":"花与爱丽丝杀人事件","uri":"/anime/hana_to_alice/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 有栖川彻子 Tetsuko Arisugawa、有栖川徹子、ありすがわ てつこ、Tetsuko \"Alice\" Arisugawa、爱丽丝 女 蒼井優 2 荒井花 Hana Arai、荒井花、あらい はな、花 女 鈴木杏 ","date":"2015-02-20","objectID":"/anime/hana_to_alice/:2:0","tags":null,"title":"花与爱丽丝杀人事件","uri":"/anime/hana_to_alice/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 花与爱丽丝杀人事件 2015-02-20 1 樱花 ","date":"2015-02-20","objectID":"/anime/hana_to_alice/:3:0","tags":null,"title":"花与爱丽丝杀人事件","uri":"/anime/hana_to_alice/"},{"categories":null,"content":" 力扣第 50 题 ","date":"2015-02-19","objectID":"/leetcode/0050/:0:0","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"题目 实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。 示例 1： 输入：x = 2.00000, n = 10 输出：1024.00000 示例 2： 输入：x = 2.10000, n = 3 输出：9.26100 示例 3： 输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示： -100.0 \u003c x \u003c 100.0 -231 \u003c= n \u003c= 231-1 n 是一个整数 -104 \u003c= xn \u003c= 104 ","date":"2015-02-19","objectID":"/leetcode/0050/:1:0","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"分析 ","date":"2015-02-19","objectID":"/leetcode/0050/:2:0","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"#1 递归的典型应用，特别注意下 n 为负数、x 为 0 的边界情况。 def myPow(self, x: float, n: int) -\u003e float: if n == 0: return 1 if x == 0: return 0 if n \u003c 0: x, n = 1 / x, -n return self.myPow(x, n // 2) ** 2 * (x if n % 2 else 1) 28 ms ","date":"2015-02-19","objectID":"/leetcode/0050/:2:1","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"#2 还可以写成非递归形式。假设 n 的二进制字符串为 s，可以递推求得 pow(x, s[:i]对应的数)。 （也可以迭代 s 的后缀，递推求得 pow(x, int(s[i:], 2))） ","date":"2015-02-19","objectID":"/leetcode/0050/:2:2","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"解答 def myPow(self, x: float, n: int) -\u003e float: if n == 0: return 1 if x == 0: return 0 if n \u003c 0: x, n = 1 / x, -n res = 1 for bit in bin(n)[2:]: res *= res res *= x if bit == '1' else 1 return res 28 ms ","date":"2015-02-19","objectID":"/leetcode/0050/:3:0","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":" 力扣第 49 题 ","date":"2015-02-18","objectID":"/leetcode/0049/:0:0","tags":null,"title":"0049：字母异位词分组（★）","uri":"/leetcode/0049/"},{"categories":null,"content":"题目 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。 示例 1: 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] 示例 2: 输入: strs = [\"\"] 输出: [[\"\"]] 示例 3: 输入: strs = [\"a\"] 输出: [[\"a\"]] 提示： 1 \u003c= strs.length \u003c= 104 0 \u003c= s","date":"2015-02-18","objectID":"/leetcode/0049/:1:0","tags":null,"title":"0049：字母异位词分组（★）","uri":"/leetcode/0049/"},{"categories":null,"content":"分析 显然字母异位词排序后相同，所以将排序后的字符串作为键存到哈希表即可。 ","date":"2015-02-18","objectID":"/leetcode/0049/:2:0","tags":null,"title":"0049：字母异位词分组（★）","uri":"/leetcode/0049/"},{"categories":null,"content":"解答 def groupAnagrams(self, strs: List[str]) -\u003e List[List[str]]: d = defaultdict(list) for s in strs: key = ''.join(sorted(s)) d[key].append(s) return list(d.values()) 60 ms ","date":"2015-02-18","objectID":"/leetcode/0049/:3:0","tags":null,"title":"0049：字母异位词分组（★）","uri":"/leetcode/0049/"},{"categories":null,"content":" 力扣第 48 题 ","date":"2015-02-17","objectID":"/leetcode/0048/:0:0","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"题目 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[[7,4,1],[8,5,2],[9,6,3]] 示例 2： 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] 提示： n =","date":"2015-02-17","objectID":"/leetcode/0048/:1:0","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"分析 ","date":"2015-02-17","objectID":"/leetcode/0048/:2:0","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"#1 观察可知，这个旋转操作等价于按主对角线翻转，再左右翻转。 def rotate(self, matrix: List[List[int]]) -\u003e None: for i in range(1, len(matrix)): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for row in matrix: row.reverse() 32 ms ","date":"2015-02-17","objectID":"/leetcode/0048/:2:1","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"#2 可以用 zip 一行实现。 ","date":"2015-02-17","objectID":"/leetcode/0048/:2:2","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"解答 def rotate(self, matrix: List[List[int]]) -\u003e None: matrix[:] = zip(*matrix[::-1]) 36 ms ","date":"2015-02-17","objectID":"/leetcode/0048/:3:0","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":" 力扣第 47 题 ","date":"2015-02-16","objectID":"/leetcode/0047/:0:0","tags":null,"title":"0047：全排列 II（★）","uri":"/leetcode/0047/"},{"categories":null,"content":"题目 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 1： 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示： 1 \u003c= nums.length \u003c= 8 -10 \u003c= nums[i] \u003c= 10 ","date":"2015-02-16","objectID":"/leetcode/0047/:1:0","tags":null,"title":"0047：全排列 II（★）","uri":"/leetcode/0047/"},{"categories":null,"content":"分析 ","date":"2015-02-16","objectID":"/leetcode/0047/:2:0","tags":null,"title":"0047：全排列 II（★）","uri":"/leetcode/0047/"},{"categories":null,"content":"#1 依然可以调库。 def permuteUnique(self, nums: List[int]) -\u003e List[List[int]]: return list(set(permutations(nums))) 64 ms ","date":"2015-02-16","objectID":"/leetcode/0047/:2:1","tags":null,"title":"0047：全排列 II（★）","uri":"/leetcode/0047/"},{"categories":null,"content":"#2 与 0046 的区别是有重复数字。 所以把 nums 排序后再遍历。 每个位置选数字时，在未标记集合中选重复数字最前面的，从而保证排列不重复。 ","date":"2015-02-16","objectID":"/leetcode/0047/:2:2","tags":null,"title":"0047：全排列 II（★）","uri":"/leetcode/0047/"},{"categories":null,"content":"解答 def permuteUnique(self, nums: List[int]) -\u003e List[List[int]]: def dfs(path): if len(path) == len(nums): res.append(path) return for i, num in enumerate(nums): if i and nums[i-1] == num and i-1 not in vis: continue if i not in vis: vis.add(i) dfs(path + [num]) vis.remove(i) res, vis = [], set() num","date":"2015-02-16","objectID":"/leetcode/0047/:3:0","tags":null,"title":"0047：全排列 II（★）","uri":"/leetcode/0047/"},{"categories":null,"content":" 力扣第 46 题 ","date":"2015-02-15","objectID":"/leetcode/0046/:0:0","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"题目 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3： 输入：nums = [1] 输出：[[1]] 提示： 1 \u003c= nums.length \u003c= 6 -10 \u003c= nums[i] \u003c= 10 nums 中的所有整数 互不相同 ","date":"2015-02-15","objectID":"/leetcode/0046/:1:0","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"分析 ","date":"2015-02-15","objectID":"/leetcode/0046/:2:0","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"#1 python 里可以直接调库。 def permute(self, nums: List[int]) -\u003e List[List[int]]: return list(permutations(nums)) 40 ms ","date":"2015-02-15","objectID":"/leetcode/0046/:2:1","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"#2 自己实现可以用 dfs，依次选择数字即可。 注意标记选过的数字。 ","date":"2015-02-15","objectID":"/leetcode/0046/:2:2","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"解答 def permute(self, nums: List[int]) -\u003e List[List[int]]: def dfs(path): if len(path) == len(nums): res.append(path) for i, num in enumerate(nums): if i not in vis: vis.add(i) dfs(path+[num]) vis.remove(i) res, vis = [], set() dfs([]) return res 28 ms ","date":"2015-02-15","objectID":"/leetcode/0046/:3:0","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":" 力扣第 45 题 ","date":"2015-02-14","objectID":"/leetcode/0045/:0:0","tags":null,"title":"0045：跳跃游戏 II（★）","uri":"/leetcode/0045/"},{"categories":null,"content":"题目 给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。 每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处: 0 \u003c= j \u003c= nums[i] i + j \u003c n 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。 示例 1: 输入: nums = [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 ","date":"2015-02-14","objectID":"/leetcode/0045/:1:0","tags":null,"title":"0045：跳跃游戏 II（★）","uri":"/leetcode/0045/"},{"categories":null,"content":"分析 根据最少跳 k 步到达的位置可以递推出最少跳 k+1 步到达的位置。循环递推直到到达末尾即可。 注意每轮能到达的位置必然是连续的，所以保存区间即可。为了方便，使用左闭右开的区间形式。 ","date":"2015-02-14","objectID":"/leetcode/0045/:2:0","tags":null,"title":"0045：跳跃游戏 II（★）","uri":"/leetcode/0045/"},{"categories":null,"content":"解答 def jump(self, nums: List[int]) -\u003e int: res, s, e = 0, 0, 1 while e \u003c len(nums): s, e = e, max(i+nums[i] for i in range(s, e))+1 res += 1 return res 32 ms ","date":"2015-02-14","objectID":"/leetcode/0045/:3:0","tags":null,"title":"0045：跳跃游戏 II（★）","uri":"/leetcode/0045/"},{"categories":null,"content":" 力扣第 44 题 ","date":"2015-02-13","objectID":"/leetcode/0044/:0:0","tags":null,"title":"0044：通配符匹配（★★）","uri":"/leetcode/0044/"},{"categories":null,"content":"题目 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。 '?' 可以匹配任何单个字符。 '*' 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1: 输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入: s = \"aa\" p = \"*\" 输出: true 解释: '*' 可以匹配任意字符串。 示例 3: 输入: s","date":"2015-02-13","objectID":"/leetcode/0044/:1:0","tags":null,"title":"0044：通配符匹配（★★）","uri":"/leetcode/0044/"},{"categories":null,"content":"分析 类似 0010，区别在于星号和前一个字符无关了。 ","date":"2015-02-13","objectID":"/leetcode/0044/:2:0","tags":null,"title":"0044：通配符匹配（★★）","uri":"/leetcode/0044/"},{"categories":null,"content":"解答 def isMatch(self, s: str, p: str) -\u003e bool: @cache def dfs(s, p): if not p: return not s if p[-1] == '*': return dfs(s, p[:-1]) or (bool(s) and dfs(s[:-1], p)) return bool(s) and p[-1] in [s[-1], '?'] and dfs(s[:-1], p[:-1]) return dfs(s, p) 1032 ms ","date":"2015-02-13","objectID":"/leetcode/0044/:3:0","tags":null,"title":"0044：通配符匹配（★★）","uri":"/leetcode/0044/"},{"categories":null,"content":"*附加 本题也可以用正则解决。 观察发现，将 p 按星号分割为一些子串，问题就等价于在 s 中依次搜索这些子串。 注意第一个子串要和 s 开头匹配，最后一个子串要和 s 末尾匹配。 def isMatch(self, s: str, p: str) -\u003e bool: subs, pos = re.split(r'\\*+', p.replace('?', '.')), 0 for i, sub in enumerate(subs): tmp = re.compile('^'*(i==0)+sub+'$'*(i==len(subs)-1)).search(s, pos) if not tmp: r","date":"2015-02-13","objectID":"/leetcode/0044/:4:0","tags":null,"title":"0044：通配符匹配（★★）","uri":"/leetcode/0044/"},{"categories":null,"content":" 力扣第 43 题 ","date":"2015-02-12","objectID":"/leetcode/0043/:0:0","tags":null,"title":"0043：字符串相乘（★）","uri":"/leetcode/0043/"},{"categories":null,"content":"题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。 示例 1: 输入: num1 = \"2\", num2 = \"3\" 输出: \"6\" 示例 2: 输入: num1 = \"123\", num2 = \"456\" 输出: \"56088\" 提示： 1 \u003c= num1.length, num2.length \u003c= 200 num1 和 num2 只能由数字组成。 num1 和 num2 都不包含任何前导零，除了数字0本身。 ","date":"2015-02-12","objectID":"/leetcode/0043/:1:0","tags":null,"title":"0043：字符串相乘（★）","uri":"/leetcode/0043/"},{"categories":null,"content":"分析 ","date":"2015-02-12","objectID":"/leetcode/0043/:2:0","tags":null,"title":"0043：字符串相乘（★）","uri":"/leetcode/0043/"},{"categories":null,"content":"#1 虽然题目说不能直接转为整数，不过还是试下看看速度。 def multiply(self, num1: str, num2: str) -\u003e str: return str(int(num1)*int(num2)) 40 ms ","date":"2015-02-12","objectID":"/leetcode/0043/:2:1","tags":null,"title":"0043：字符串相乘（★）","uri":"/leetcode/0043/"},{"categories":null,"content":"#2 考虑模拟竖式乘法： 为了从低到高计算，将 num1、num2 反序 结果最多 m * n 位，因此用 m * n 长度的数组 res 存储结果 对于每对 \u003cnums1[i], nums2[j]\u003e， 乘积结果对应第 i+j 和 i+j+1 位 遍历过程中注意进位，最后将 res 反序即为所求 注意最后要去掉前置 0。 ","date":"2015-02-12","objectID":"/leetcode/0043/:2:2","tags":null,"title":"0043：字符串相乘（★）","uri":"/leetcode/0043/"},{"categories":null,"content":"解答 def multiply(self, num1: str, num2: str) -\u003e str: m, n = len(num1), len(num2) res, A, B = [0] * (m+n), num1[::-1], num2[::-1] for i, j in product(range(m), range(n)): s = int(A[i]) * int(B[j]) + res[i+j] res[i+j] = s % 10 res[i+j+1] += s // 10 return ''.join(map(str, res[::-1])).lstrip('0') or '0'","date":"2015-02-12","objectID":"/leetcode/0043/:3:0","tags":null,"title":"0043：字符串相乘（★）","uri":"/leetcode/0043/"},{"categories":null,"content":" 力扣第 42 题 ","date":"2015-02-11","objectID":"/leetcode/0042/:0:0","tags":null,"title":"0042：接雨水（★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"题目 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 输入：height = [4,2,0,3,2,5] 输出：9 提示： n == height.length 1 \u003c= n \u003c= 2 * 104 0 \u003c= height[i] \u003c= 105 ","date":"2015-02-11","objectID":"/leetcode/0042/:1:0","tags":null,"title":"0042：接雨水（★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"分析 ","date":"2015-02-11","objectID":"/leetcode/0042/:2:0","tags":null,"title":"0042：接雨水（★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"#1 观察发现： 对于任一柱子，如果左右都有更高的柱子，那么该位置就能接到雨水。 设左右最高的柱子分别为 L, R, 该位置能接到的雨水数量为 min(L, R) - 柱子高度。 每根柱子对应的 L 和 R 可以一趟递推得到，优化为线性时间复杂度。 def trap(self, height: List[int]) -\u003e int: left = list(accumulate(height, max)) right = list(accumulate(height[::-1], max))[::-1] return sum(min(l, r)-h for h,l,r in zip(height","date":"2015-02-11","objectID":"/leetcode/0042/:2:1","tags":null,"title":"0042：接雨水（★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"#2 还有个巧妙的双指针方法可以一趟解决。 初始 i、j 分别指向数组首尾 若 max(height[:i+1]) \u003c= max(height[j:])，可求得位置 i 处的雨水，然后移动 i 若 max(height[:i+1]) \u003e= max(height[j:])，可求得位置 j 处的雨水，然后移动 j 循环操作直到 i、j 相遇，即可得到每个位置处的雨水 ","date":"2015-02-11","objectID":"/leetcode/0042/:2:2","tags":null,"title":"0042：接雨水（★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"解答 def trap(self, height: List[int]) -\u003e int: res, L, R = 0, 0, 0 i, j = 0, len(height)-1 while i \u003c= j: L, R = max(L, height[i]), max(R, height[j]) if L \u003c= R: res += L - height[i] i += 1 else: res += R - height[j] j -= 1 return res 时间 O(N)，64 ms ","date":"2015-02-11","objectID":"/leetcode/0042/:3:0","tags":null,"title":"0042：接雨水（★★）","uri":"/leetcode/0042/"},{"categories":null,"content":" 力扣第 41 题 ","date":"2015-02-10","objectID":"/leetcode/0041/:0:0","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"题目 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 示例 1： 输入：nums = [1,2,0] 输出：3 示例 2： 输入：nums = [3,4,-1,1] 输出：2 示例 3： 输入：nums = [7,8,9,11,12] 输出：1 提示： 1 \u003c= nums.length \u003c= 5 * 105 -231 \u003c= nums[i] \u003c= 231 - 1 ","date":"2015-02-10","objectID":"/leetcode/0041/:1:0","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"分析 ","date":"2015-02-10","objectID":"/leetcode/0041/:2:0","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"#1 最简单地，遍历 1 到 max(nums)+1，没出现就返回。 def firstMissingPositive(self, nums: List[int]) -\u003e int: nums = set(nums) for x in range(1, max(0, max(nums, default=0))+2): if x not in nums: return x 84 ms ","date":"2015-02-10","objectID":"/leetcode/0041/:2:1","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"#2 不过题目要求 O(1) 空间，那么只能考虑交换或赋值了。 有个巧妙的想法是把正数都放在对应的位置上，比如 1 放在第 1 位，3 放在第 3 位， 那么再遍历就能发现缺的第一个正数了 本题不能直接赋值，可能会覆盖掉有用信息，所以考虑交换 如果交换过来还是范围内的正数，应该循环操作 为了防止死循环，当要交换的两个数相等时就应跳出 ","date":"2015-02-10","objectID":"/leetcode/0041/:2:2","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"解答 def firstMissingPositive(self, nums: List[int]) -\u003e int: n = len(nums) for i, x in enumerate(nums): while 1 \u003c= x \u003c= n and x != nums[x-1]: nums[i], nums[x-1] = nums[x-1], nums[i] x = nums[i] for i, x in enumerate(nums): if x != i + 1: return i + 1 return n + 1 228 ms ","date":"2015-02-10","objectID":"/leetcode/0041/:3:0","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":" 力扣第 40 题 ","date":"2015-02-09","objectID":"/leetcode/0040/:0:0","tags":null,"title":"0040：组合总和 II（★）","uri":"/leetcode/0040/"},{"categories":null,"content":"题目 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 输出: [ [1,2,2], [5] ] 提示: 1 \u003c= ca","date":"2015-02-09","objectID":"/leetcode/0040/:1:0","tags":null,"title":"0040：组合总和 II（★）","uri":"/leetcode/0040/"},{"categories":null,"content":"分析 0090 升级版，添加了和的限制。 ","date":"2015-02-09","objectID":"/leetcode/0040/:2:0","tags":null,"title":"0040：组合总和 II（★）","uri":"/leetcode/0040/"},{"categories":null,"content":"解答 def combinationSum2(self, candidates: List[int], target: int) -\u003e List[List[int]]: def dfs(i, s): if s \u003e= target: if s == target: res.append(path[:]) return for j in range(i, n): if j \u003e i and candidates[j] == candidates[j - 1]: continue path.append(candidates[j]) dfs(j + 1, s + candidates[j]) path","date":"2015-02-09","objectID":"/leetcode/0040/:3:0","tags":null,"title":"0040：组合总和 II（★）","uri":"/leetcode/0040/"},{"categories":null,"content":" 力扣第 39 题 ","date":"2015-02-08","objectID":"/leetcode/0039/:0:0","tags":null,"title":"0039：组合总和（★）","uri":"/leetcode/0039/"},{"categories":null,"content":"题目 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例 1： 输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释： 2 和 3 可以形成一组候选，2 + 2 ","date":"2015-02-08","objectID":"/leetcode/0039/:1:0","tags":null,"title":"0039：组合总和（★）","uri":"/leetcode/0039/"},{"categories":null,"content":"分析 0078 升级版，添加了和的限制。 ","date":"2015-02-08","objectID":"/leetcode/0039/:2:0","tags":null,"title":"0039：组合总和（★）","uri":"/leetcode/0039/"},{"categories":null,"content":"解答 def combinationSum(self, candidates: List[int], target: int) -\u003e List[List[int]]: def dfs(i, s): if s \u003e= target: if s == target: res.append(path[:]) return for j in range(i, n): path.append(candidates[j]) dfs(j, s+candidates[j]) path.pop() res, path, n = [], [], len(candidates) dfs(0, 0) return re","date":"2015-02-08","objectID":"/leetcode/0039/:3:0","tags":null,"title":"0039：组合总和（★）","uri":"/leetcode/0039/"},{"categories":null,"content":" 力扣第 38 题 ","date":"2015-02-07","objectID":"/leetcode/0038/:0:0","tags":null,"title":"0038：外观数列（★）","uri":"/leetcode/0038/"},{"categories":null,"content":"题目 给定一个正整数 n ，输出外观数列的第 n 项。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 你可以将其视作是由递归公式定义的数字字符串序列： countAndSay(1) = \"1\" countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 \"11\" 描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 \"21\" 描述前一项，这个数是 2","date":"2015-02-07","objectID":"/leetcode/0038/:1:0","tags":null,"title":"0038：外观数列（★）","uri":"/leetcode/0038/"},{"categories":null,"content":"分析 迭代即可，可以用 itertools.groupby 简化。 ","date":"2015-02-07","objectID":"/leetcode/0038/:2:0","tags":null,"title":"0038：外观数列（★）","uri":"/leetcode/0038/"},{"categories":null,"content":"解答 def countAndSay(self, n: int) -\u003e str: s = '1' for _ in range(n-1): s = ''.join(str(len(list(g)))+x for x,g in groupby(s)) return s 48 ms ","date":"2015-02-07","objectID":"/leetcode/0038/:3:0","tags":null,"title":"0038：外观数列（★）","uri":"/leetcode/0038/"},{"categories":null,"content":" 力扣第 37 题 ","date":"2015-02-06","objectID":"/leetcode/0037/:0:0","tags":null,"title":"0037：解数独（★★）","uri":"/leetcode/0037/"},{"categories":null,"content":"题目 编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例 1： 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\"","date":"2015-02-06","objectID":"/leetcode/0037/:1:0","tags":null,"title":"0037：解数独（★★）","uri":"/leetcode/0037/"},{"categories":null,"content":"分析 回溯法的典型应用。可以直接遍历空格位置，节省时间。 ","date":"2015-02-06","objectID":"/leetcode/0037/:2:0","tags":null,"title":"0037：解数独（★★）","uri":"/leetcode/0037/"},{"categories":null,"content":"解答 def solveSudoku(self, board: List[List[str]]) -\u003e None: def dfs(cnt): if cnt == len(A): return True i, j = A[cnt] k = i//3*3+j//3 for x in range(1, 10): if row[i][x] == col[j][x] == box[k][x] == 0: board[i][j] = str(x) row[i][x] = col[j][x] = box[k][x] = 1 if dfs(cnt + 1): return True row[i][x] = ","date":"2015-02-06","objectID":"/leetcode/0037/:3:0","tags":null,"title":"0037：解数独（★★）","uri":"/leetcode/0037/"},{"categories":null,"content":" 力扣第 36 题 ","date":"2015-02-05","objectID":"/leetcode/0036/:0:0","tags":null,"title":"0036：有效的数独（★）","uri":"/leetcode/0036/"},{"categories":null,"content":"题目 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 空白格用 '.' 表示。 示例 1： 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\"","date":"2015-02-05","objectID":"/leetcode/0036/:1:0","tags":null,"title":"0036：有效的数独（★）","uri":"/leetcode/0036/"},{"categories":null,"content":"分析 遍历判断数字在所属的行、列、宫中是否出现过即可。宫的序号可以由 i//3*3+j//3 得到。 ","date":"2015-02-05","objectID":"/leetcode/0036/:2:0","tags":null,"title":"0036：有效的数独（★）","uri":"/leetcode/0036/"},{"categories":null,"content":"解答 def isValidSudoku(self, board: List[List[str]]) -\u003e bool: row, col, box = ([[0]*9 for _ in range(9)] for _ in range(3)) for i, j in product(range(9), range(9)): x, k = board[i][j], i//3*3+j//3 if x != '.': x = int(x)-1 if row[i][x] or col[j][x] or box[k][x]: return False row[i][x] = col[j][x] = bo","date":"2015-02-05","objectID":"/leetcode/0036/:3:0","tags":null,"title":"0036：有效的数独（★）","uri":"/leetcode/0036/"},{"categories":null,"content":" 力扣第 35 题 ","date":"2015-02-04","objectID":"/leetcode/0035/:0:0","tags":null,"title":"0035：搜索插入位置","uri":"/leetcode/0035/"},{"categories":null,"content":"题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 提示: 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 为 无重复元素 的 升序 排列数组 -","date":"2015-02-04","objectID":"/leetcode/0035/:1:0","tags":null,"title":"0035：搜索插入位置","uri":"/leetcode/0035/"},{"categories":null,"content":"分析 典型的二分查找。 ","date":"2015-02-04","objectID":"/leetcode/0035/:2:0","tags":null,"title":"0035：搜索插入位置","uri":"/leetcode/0035/"},{"categories":null,"content":"解答 def searchInsert(self, nums: List[int], target: int) -\u003e int: return bisect_left(nums, target) 28 ms ","date":"2015-02-04","objectID":"/leetcode/0035/:3:0","tags":null,"title":"0035：搜索插入位置","uri":"/leetcode/0035/"},{"categories":null,"content":" 力扣第 34 题 ","date":"2015-02-03","objectID":"/leetcode/0034/:0:0","tags":null,"title":"0034：在排序数组中查找元素的第一个和最后一个位置（★）","uri":"/leetcode/0034/"},{"categories":null,"content":"题目 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 \u003c= nums.length","date":"2015-02-03","objectID":"/leetcode/0034/:1:0","tags":null,"title":"0034：在排序数组中查找元素的第一个和最后一个位置（★）","uri":"/leetcode/0034/"},{"categories":null,"content":"分析 二分查找的典型应用。分别对应 bisect_left 和 bisect_right。 ","date":"2015-02-03","objectID":"/leetcode/0034/:2:0","tags":null,"title":"0034：在排序数组中查找元素的第一个和最后一个位置（★）","uri":"/leetcode/0034/"},{"categories":null,"content":"解答 def searchRange(self, nums: List[int], target: int) -\u003e List[int]: i, j = bisect_left(nums, target), bisect_right(nums, target) - 1 return [i, j] if i \u003c= j else [-1, -1] 24 ms ","date":"2015-02-03","objectID":"/leetcode/0034/:3:0","tags":null,"title":"0034：在排序数组中查找元素的第一个和最后一个位置（★）","uri":"/leetcode/0034/"},{"categories":null,"content":" 力扣第 33 题 ","date":"2015-02-02","objectID":"/leetcode/0033/:0:0","tags":null,"title":"0033：搜索旋转排序数组（★）","uri":"/leetcode/0033/"},{"categories":null,"content":"题目 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u003c= k \u003c nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回","date":"2015-02-02","objectID":"/leetcode/0033/:1:0","tags":null,"title":"0033：搜索旋转排序数组（★）","uri":"/leetcode/0033/"},{"categories":null,"content":"分析 由 0153 可以找到最小值位置 i，然后在 nums[:i]，nums[i:] 中分别二分查找 target 即可。 ","date":"2015-02-02","objectID":"/leetcode/0033/:2:0","tags":null,"title":"0033：搜索旋转排序数组（★）","uri":"/leetcode/0033/"},{"categories":null,"content":"解答 def search(self, nums: List[int], target: int) -\u003e int: n = len(nums) self.__class__.__getitem__ = lambda self, x: nums[x] \u003c= nums[-1] x = bisect_left(self, True, 0, n-1) i = bisect_left(nums, target, 0, x-1) if x else 0 j = bisect_left(nums, target, x, n-1) return i if nums[i] == target else j if","date":"2015-02-02","objectID":"/leetcode/0033/:3:0","tags":null,"title":"0033：搜索旋转排序数组（★）","uri":"/leetcode/0033/"},{"categories":null,"content":" 力扣第 32 题 ","date":"2015-02-01","objectID":"/leetcode/0032/:0:0","tags":null,"title":"0032：最长有效括号（★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"题目 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 输入：s = \"(()\" 输出：2 解释：最长有效括号子串是 \"()\" 示例 2： 输入：s = \")()())\" 输出：4 解释：最长有效括号子串是 \"()()\" 示例 3： 输入：s = \"\" 输出：0 提示： 0 \u003c= s.length \u003c= 3 * 104 s[i] 为 '(' 或 ')' ","date":"2015-02-01","objectID":"/leetcode/0032/:1:0","tags":null,"title":"0032：最长有效括号（★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"分析 ","date":"2015-02-01","objectID":"/leetcode/0032/:2:0","tags":null,"title":"0032：最长有效括号（★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"#1 基于 1249 ，可以得到不属于有效子串的括号的位置，找出最大的间隔即可。 def longestValidParentheses(self, s: str) -\u003e int: stack, invalid = [], [] for i, char in enumerate(s): if char == '(': stack.append(i) elif stack: stack.pop() else: invalid.append(i) invalid = [-1] + invalid + stack + [len(s)] return max(invalid[i + 1] - inva","date":"2015-02-01","objectID":"/leetcode/0032/:2:1","tags":null,"title":"0032：最长有效括号（★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"#2 也可以用动态规划解决： 令 dp[r] 代表右括号 r 结尾的最长有效子串长度，并假设 r 所对应的是左括号 l 如果 l-1 是左括号， dp[r] = r-l+1 如果 l-1 是右括号， dp[r] = r-l+1+dp[l-1] max(dp) 即为所求。 ","date":"2015-02-01","objectID":"/leetcode/0032/:2:2","tags":null,"title":"0032：最长有效括号（★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"解答 def longestValidParentheses(self, s: str) -\u003e int: stack, dp = [], {} for j, char in enumerate(s): if char == '(': stack.append(j) elif stack: i = stack.pop() dp[j] = j - i + 1 + dp.get(i-1, 0) return max(dp.values(), default=0) 时间 O(N)，28 ms ","date":"2015-02-01","objectID":"/leetcode/0032/:3:0","tags":null,"title":"0032：最长有效括号（★★）","uri":"/leetcode/0032/"},{"categories":null,"content":" 力扣第 31 题 ","date":"2015-01-31","objectID":"/leetcode/0031/:0:0","tags":null,"title":"0031：下一个排列（★）","uri":"/leetcode/0031/"},{"categories":null,"content":"题目 整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1]","date":"2015-01-31","objectID":"/leetcode/0031/:1:0","tags":null,"title":"0031：下一个排列（★）","uri":"/leetcode/0031/"},{"categories":null,"content":"分析 ","date":"2015-01-31","objectID":"/leetcode/0031/:2:0","tags":null,"title":"0031：下一个排列（★）","uri":"/leetcode/0031/"},{"categories":null,"content":"#1 下一个更大的排列就是增加得最小的排列。 若后缀 nums[i:] 能够增大，nums[:i] 就应该保持不变 从后往前，找到第一个能增大的后缀 nums[i:]，问题转为求 nums[i:] 的下一个排列 要让 nums[i] 增加得最小，应该从 nums[i+1:] 中找到比 nums[i] 大的最小数 nums[j]，替换到 nums[i] 然后重新排列 nums[i+1:] 使其最小即可 def nextPermutation(self, nums: List[int]) -\u003e None: n = len(nums) i = n-2 while i \u003e= 0 and nums[i]","date":"2015-01-31","objectID":"/leetcode/0031/:2:1","tags":null,"title":"0031：下一个排列（★）","uri":"/leetcode/0031/"},{"categories":null,"content":"#2 观察发现： nums[i+1:] 不能增大，故 nums[i+1:] 单调递减 因此从后往前遍历，找到第一个满足 nums[j]\u003enums[i] 的 j 即可 替换后 nums[i+1:] 依然单调递减，因此反转即可 ","date":"2015-01-31","objectID":"/leetcode/0031/:2:2","tags":null,"title":"0031：下一个排列（★）","uri":"/leetcode/0031/"},{"categories":null,"content":"解答 def nextPermutation(self, nums: List[int]) -\u003e None: n = len(nums) i = n-2 while i \u003e= 0 and nums[i] \u003e= nums[i+1]: i -= 1 if i \u003e= 0: j = n-1 while nums[j] \u003c= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i+1:] = nums[i+1:][::-1] 时间 O(N)，24 ms ","date":"2015-01-31","objectID":"/leetcode/0031/:3:0","tags":null,"title":"0031：下一个排列（★）","uri":"/leetcode/0031/"},{"categories":null,"content":" 力扣第 30 题 ","date":"2015-01-30","objectID":"/leetcode/0030/:0:0","tags":null,"title":"0030：串联所有单词的子串（★★）","uri":"/leetcode/0030/"},{"categories":null,"content":"题目 给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。 s 中的 串联子串 是指一个包含 words 中所有字符串以任意顺序排列连接起来的子串。 例如，如果 words = [\"ab\",\"cd\",\"ef\"]， 那么 \"abcdef\"， \"abefcd\"，\"cdabef\"， \"cdefab\"，\"efabcd\"， 和 \"efcdab\" 都是串联子串。 \"acdbef\" 不是串联子串，因为他不是任何 words 排列的连接。 返回所有串联字串在 s 中的开始索引。你可以以 任意顺序 返回答案。 示例 1： 输入：s = \"barfoothefoobarman\"","date":"2015-01-30","objectID":"/leetcode/0030/:1:0","tags":null,"title":"0030：串联所有单词的子串（★★）","uri":"/leetcode/0030/"},{"categories":null,"content":"分析 0438 的升级版，遍历 sum(words) 长度的子串，用 Counter 判断是否符合即可。 设每个单词的长度为 x， 则子串 [i,j] 的 Counter 可以由子串 [i-x, j-x] 的递推得到。 ","date":"2015-01-30","objectID":"/leetcode/0030/:2:0","tags":null,"title":"0030：串联所有单词的子串（★★）","uri":"/leetcode/0030/"},{"categories":null,"content":"解答 def findSubstring(self, s: str, words: List[str]) -\u003e List[int]: m, n, x = len(s), len(words), len(words[0]) res, ct0 = [], Counter(words) for start in range(x): ct = Counter() for j in range(start+x, m+1, x): ct[s[j-x:j]] += 1 if j \u003e start + n*x: old = s[j-(n+1)*x:j-n*x] ct[old] -= 1 if ct[old] =","date":"2015-01-30","objectID":"/leetcode/0030/:3:0","tags":null,"title":"0030：串联所有单词的子串（★★）","uri":"/leetcode/0030/"},{"categories":null,"content":" 力扣第 29 题 ","date":"2015-01-29","objectID":"/leetcode/0029/:0:0","tags":null,"title":"0029：两数相除（★）","uri":"/leetcode/0029/"},{"categories":null,"content":"题目 给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。 整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。 返回被除数 dividend 除以除数 divisor 得到的 商 。 注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231, 231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。 示例 1: 输入: dividend = 10,","date":"2015-01-29","objectID":"/leetcode/0029/:1:0","tags":null,"title":"0029：两数相除（★）","uri":"/leetcode/0029/"},{"categories":null,"content":"分析 ","date":"2015-01-29","objectID":"/leetcode/0029/:2:0","tags":null,"title":"0029：两数相除（★）","uri":"/leetcode/0029/"},{"categories":null,"content":"#1 最简单的想法就是把两个数都变成正的，然后被除数不断的减去除数直到小于除数为止，最后再加上正负号。 溢出的唯一可能是 −2^31 除以 -1 等于 2^31。 def divide(self, dividend: int, divisor: int) -\u003e int: res, flag = 0, int(dividend ^ divisor \u003e= 0) m, n = abs(dividend), abs(divisor) while m \u003e= n: m -= n res += 1 res = res if flag else -res return min(res, 2147483647)","date":"2015-01-29","objectID":"/leetcode/0029/:2:1","tags":null,"title":"0029：两数相除（★）","uri":"/leetcode/0029/"},{"categories":null,"content":"#2 显然超时是因为两个数的逼近太慢。考虑将除数不断自加，相当于乘 2，就可以快速的逼近了。 以求 divide(100, 3) 为例，将 3 不断自加直到 96 （3 的 32 倍），即转化为求 32+divide(4, 3) 因此求 divide(m, n) 的过程就是每一轮求最接近 m 的 n*(2^k)，并更新 m -= n*(2^k), res+=2^k 进一步地，0\u003c=k\u003c=31。因此直接遍历 k 从 31 到 0，判断是否减去 n*(2^k) 即可。 ","date":"2015-01-29","objectID":"/leetcode/0029/:2:2","tags":null,"title":"0029：两数相除（★）","uri":"/leetcode/0029/"},{"categories":null,"content":"解答 def divide(self, dividend: int, divisor: int) -\u003e int: res, flag = 0, int(dividend ^ divisor \u003e= 0) m, n = abs(dividend), abs(divisor) A = [(n, 1)] for _ in range(31): A.append((A[-1][0]+A[-1][0], A[-1][1]+A[-1][1])) res = 0 for i in range(31, -1, -1): if m \u003e= A[i][0]: m -= A[i][0] res += A[i][1] r","date":"2015-01-29","objectID":"/leetcode/0029/:3:0","tags":null,"title":"0029：两数相除（★）","uri":"/leetcode/0029/"},{"categories":null,"content":" 力扣第 28 题 ","date":"2015-01-28","objectID":"/leetcode/0028/:0:0","tags":null,"title":"0028：找出字符串中第一个匹配项的下标（★）","uri":"/leetcode/0028/"},{"categories":null,"content":"题目 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 示例 1： 输入：haystack = \"sadbutsad\", needle = \"sad\" 输出：0 解释：\"sad\" 在下标 0 和 6 处匹配。 第一个匹配项的下标是 0 ，所以返回 0 。 示例 2： 输入：haystack = \"leetcode\", needle = \"leeto\" 输出：-1 解释：\"leeto\" 没有在 \"leetcode\" 中出","date":"2015-01-28","objectID":"/leetcode/0028/:1:0","tags":null,"title":"0028：找出字符串中第一个匹配项的下标（★）","uri":"/leetcode/0028/"},{"categories":null,"content":"分析 ","date":"2015-01-28","objectID":"/leetcode/0028/:2:0","tags":null,"title":"0028：找出字符串中第一个匹配项的下标（★）","uri":"/leetcode/0028/"},{"categories":null,"content":"#1 实际应用中当然是直接调包。 def strStr(self, haystack: str, needle: str) -\u003e int: return haystack.find(needle) 40 ms ","date":"2015-01-28","objectID":"/leetcode/0028/:2:1","tags":null,"title":"0028：找出字符串中第一个匹配项的下标（★）","uri":"/leetcode/0028/"},{"categories":null,"content":"#2 自己写，最简单的就是遍历所有 len(needle) 长度的子串，判断是否等于 needle。 ","date":"2015-01-28","objectID":"/leetcode/0028/:2:2","tags":null,"title":"0028：找出字符串中第一个匹配项的下标（★）","uri":"/leetcode/0028/"},{"categories":null,"content":"解答 def strStr(self, haystack: str, needle: str) -\u003e int: m, n = len(haystack), len(needle) for i in range(m-n+1): if haystack[i:i+n] == needle: return i return -1 时间 O(M*N), 40 ms ","date":"2015-01-28","objectID":"/leetcode/0028/:3:0","tags":null,"title":"0028：找出字符串中第一个匹配项的下标（★）","uri":"/leetcode/0028/"},{"categories":null,"content":"*附加 本题有个经典的 KMP 算法， 能在 O(M) 时间内完成。 def strStr(self, haystack: str, needle: str) -\u003e int: if not needle: return 0 m, n = len(haystack), len(needle) nxt, j = [-1], -1 for i in range(n): while j \u003e= 0 and needle[i] != needle[j]: j = nxt[j] j += 1 nxt.append(j) j = 0 for i in range(m): while j \u003e= 0 and ha","date":"2015-01-28","objectID":"/leetcode/0028/:4:0","tags":null,"title":"0028：找出字符串中第一个匹配项的下标（★）","uri":"/leetcode/0028/"},{"categories":null,"content":" 力扣第 27 题 ","date":"2015-01-27","objectID":"/leetcode/0027/:0:0","tags":null,"title":"0027：移除元素","uri":"/leetcode/0027/"},{"categories":null,"content":"题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输","date":"2015-01-27","objectID":"/leetcode/0027/:1:0","tags":null,"title":"0027：移除元素","uri":"/leetcode/0027/"},{"categories":null,"content":"分析 和 0026 的思路完全相同，还更简单一点。 ","date":"2015-01-27","objectID":"/leetcode/0027/:2:0","tags":null,"title":"0027：移除元素","uri":"/leetcode/0027/"},{"categories":null,"content":"解答 def removeElement(self, nums: List[int], val: int) -\u003e int: i = 0 for num in nums: if num != val: nums[i] = num i += 1 return i 32 ms ","date":"2015-01-27","objectID":"/leetcode/0027/:3:0","tags":null,"title":"0027：移除元素","uri":"/leetcode/0027/"},{"categories":null,"content":" 力扣第 26 题 ","date":"2015-01-26","objectID":"/leetcode/0026/:0:0","tags":null,"title":"0026：删除有序数组中的重复项","uri":"/leetcode/0026/"},{"categories":null,"content":"题目 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 判题标准: 系统会用下面的代码来测试你的题解: int[] nums = [...]; // 输入数组 ","date":"2015-01-26","objectID":"/leetcode/0026/:1:0","tags":null,"title":"0026：删除有序数组中的重复项","uri":"/leetcode/0026/"},{"categories":null,"content":"分析 先想想用额外数组怎么做，就是遍历到不重复的元素就添加到新数组。 不用额外数组的话，就将原数组的相应位置赋值即可。 ","date":"2015-01-26","objectID":"/leetcode/0026/:2:0","tags":null,"title":"0026：删除有序数组中的重复项","uri":"/leetcode/0026/"},{"categories":null,"content":"解答 def removeDuplicates(self, nums: List[int]) -\u003e int: i = 0 for num in nums: if i \u003c 1 or num != nums[i-1]: nums[i] = num i += 1 return i 32 ms ","date":"2015-01-26","objectID":"/leetcode/0026/:3:0","tags":null,"title":"0026：删除有序数组中的重复项","uri":"/leetcode/0026/"},{"categories":null,"content":" 力扣第 25 题 ","date":"2015-01-25","objectID":"/leetcode/0025/:0:0","tags":null,"title":"0025：K 个一组翻转链表（★★）","uri":"/leetcode/0025/"},{"categories":null,"content":"题目 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例 1： 输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5] 示例 2： 输入：head = [1,2,3,4,5], k = 3 输出：[3,2,1,4,5] 提示： 链表中的节点数目为 n 1 \u003c= k \u003c= n \u003c= 5000 0 \u003c= Node.val \u003c= 1000 进阶：你可以设计一","date":"2015-01-25","objectID":"/leetcode/0025/:1:0","tags":null,"title":"0025：K 个一组翻转链表（★★）","uri":"/leetcode/0025/"},{"categories":null,"content":"分析 0024 的升级版。 链表前新建一个哑节点，指针 p 初始指向哑节点 当 p 后面存在 k 个节点时，将这一段翻转 将 p 移动 k 步准备下一轮翻转，如此循环即可 反转某段链表的方法可以参考 0092。 ","date":"2015-01-25","objectID":"/leetcode/0025/:2:0","tags":null,"title":"0025：K 个一组翻转链表（★★）","uri":"/leetcode/0025/"},{"categories":null,"content":"解答 def reverseKGroup(self, head: ListNode, k: int) -\u003e ListNode: dummy = p = ListNode(next=head) while True: fast = p for _ in range(k): fast = fast.next if not fast: return dummy.next tail = p.next for _ in range(k - 1): tmp = tail.next tail.next = tmp.next tmp.next = p.next p.next = tmp p = tail 44","date":"2015-01-25","objectID":"/leetcode/0025/:3:0","tags":null,"title":"0025：K 个一组翻转链表（★★）","uri":"/leetcode/0025/"},{"categories":null,"content":" 力扣第 24 题 ","date":"2015-01-24","objectID":"/leetcode/0024/:0:0","tags":null,"title":"0024：两两交换链表中的节点（★）","uri":"/leetcode/0024/"},{"categories":null,"content":"题目 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 \u003c= Node.val \u003c= 100 ","date":"2015-01-24","objectID":"/leetcode/0024/:1:0","tags":null,"title":"0024：两两交换链表中的节点（★）","uri":"/leetcode/0024/"},{"categories":null,"content":"分析 新建一个链表前的哑节点，指针 p 初始指向哑节点 当 p 后面存在至少两个节点时，改变 p 和两个节点的指向来交换节点 再把 p 移动两步准备下一轮交换，如此循环即可 ","date":"2015-01-24","objectID":"/leetcode/0024/:2:0","tags":null,"title":"0024：两两交换链表中的节点（★）","uri":"/leetcode/0024/"},{"categories":null,"content":"解答 def swapPairs(self, head: ListNode) -\u003e ListNode: dummy = p = ListNode(next=head) while p.next and p.next.next: q = p.next p.next = p.next.next q.next = q.next.next p.next.next = q p = q return dummy.next 28 ms ","date":"2015-01-24","objectID":"/leetcode/0024/:3:0","tags":null,"title":"0024：两两交换链表中的节点（★）","uri":"/leetcode/0024/"},{"categories":null,"content":" 力扣第 23 题 ","date":"2015-01-23","objectID":"/leetcode/0023/:0:0","tags":null,"title":"0023：合并 K 个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"题目 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-\u003e4-\u003e5, 1-\u003e3-\u003e4, 2-\u003e6 ] 将它们合并到一个有序链表中得到。 1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6 示例 2： 输入：lists = [] 输出：[] 示例 3： 输入：lists = [[]] 输出：[] 提示： k == lists.length 0 \u003c= k \u003c= 10^4 0 \u003c= lists[i].l","date":"2015-01-23","objectID":"/leetcode/0023/:1:0","tags":null,"title":"0023：合并 K 个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"分析 ","date":"2015-01-23","objectID":"/leetcode/0023/:2:0","tags":null,"title":"0023：合并 K 个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"#1 本题类似于归并排序，可以用分治法。 def mergeKLists(self, lists: List[ListNode]) -\u003e ListNode: def merge(l1, l2): dummy = l3 = ListNode() while l1 and l2: if l1.val \u003c= l2.val: l3.next = l1 l1 = l1.next else: l3.next = l2 l2 = l2.next l3 = l3.next l3.next = l1 if l1 else l2 return dummy.next n = len(lists) if n \u003c 2:","date":"2015-01-23","objectID":"/leetcode/0023/:2:1","tags":null,"title":"0023：合并 K 个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"#2 也可以维护一个堆，初始将每个链表的头节点的值入堆，然后每轮弹出最小数， 将对应的链表前进一步，并将新的值入堆。 ","date":"2015-01-23","objectID":"/leetcode/0023/:2:2","tags":null,"title":"0023：合并 K 个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"解答 def mergeKLists(self, lists: List[ListNode]) -\u003e ListNode: pq = [(node.val, i) for i, node in enumerate(lists) if node] heapify(pq) dummy = p = ListNode(next=None) while pq: val, i = heappop(pq) p.next = ListNode(val) p = p.next if lists[i].next: lists[i] = lists[i].next heappush(pq, (lists[i].val","date":"2015-01-23","objectID":"/leetcode/0023/:3:0","tags":null,"title":"0023：合并 K 个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":" 力扣第 22 题 ","date":"2015-01-22","objectID":"/leetcode/0022/:0:0","tags":null,"title":"0022：括号生成（★）","uri":"/leetcode/0022/"},{"categories":null,"content":"题目 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 输入：n = 3 输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] 示例 2： 输入：n = 1 输出：[\"()\"] 提示： 1 \u003c= n \u003c= 8 ","date":"2015-01-22","objectID":"/leetcode/0022/:1:0","tags":null,"title":"0022：括号生成（★）","uri":"/leetcode/0022/"},{"categories":null,"content":"分析 典型的回溯问题，每一步添加 ‘(’ 或 ‘)’，若无效则回到上一步。 ","date":"2015-01-22","objectID":"/leetcode/0022/:2:0","tags":null,"title":"0022：括号生成（★）","uri":"/leetcode/0022/"},{"categories":null,"content":"解答 def generateParenthesis(self, n: int) -\u003e List[str]: def dfs(l, r, tmp): if l \u003e n or r \u003e l: return if r == n: res.append(tmp) return dfs(l + 1, r, tmp + '(') dfs(l, r + 1, tmp + ')') res = [] dfs(0, 0, '') return res 时间 O(N)，36 ms ","date":"2015-01-22","objectID":"/leetcode/0022/:3:0","tags":null,"title":"0022：括号生成（★）","uri":"/leetcode/0022/"},{"categories":null,"content":" 力扣第 21 题 ","date":"2015-01-21","objectID":"/leetcode/0021/:0:0","tags":null,"title":"0021：合并两个有序链表","uri":"/leetcode/0021/"},{"categories":null,"content":"题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 \u003c= Node.val \u003c= 100 l1 和 l2 均按 非递减顺序 排列 ","date":"2015-01-21","objectID":"/leetcode/0021/:1:0","tags":null,"title":"0021：合并两个有序链表","uri":"/leetcode/0021/"},{"categories":null,"content":"分析 与归并两个有序数组的思路一样，用双指针即可。 区别在于这里是拼接，所以不需要造一个新链表，只需要建一个哑结点即可。 ","date":"2015-01-21","objectID":"/leetcode/0021/:2:0","tags":null,"title":"0021：合并两个有序链表","uri":"/leetcode/0021/"},{"categories":null,"content":"解答 def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -\u003e Optional[ListNode]: dummy = p = ListNode() while list1 and list2: if list1.val \u003c= list2.val: p.next = list1 list1 = list1.next else: p.next = list2 list2 = list2.next p = p.next p.next = list1 if list1 else list2 ret","date":"2015-01-21","objectID":"/leetcode/0021/:3:0","tags":null,"title":"0021：合并两个有序链表","uri":"/leetcode/0021/"},{"categories":null,"content":" 力扣第 20 题 ","date":"2015-01-20","objectID":"/leetcode/0020/:0:0","tags":null,"title":"0020：有效的括号","uri":"/leetcode/0020/"},{"categories":null,"content":"题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 示例 1： 输入：s = \"()\" 输出：true 示例 2： 输入：s = \"()[]{}\" 输出：true 示例 3： 输入：s = \"(]\" 输出：false 提示： 1 \u003c= s.length \u003c= 104 s 仅由括号 '()[]{}' 组成 ","date":"2015-01-20","objectID":"/leetcode/0020/:1:0","tags":null,"title":"0020：有效的括号","uri":"/leetcode/0020/"},{"categories":null,"content":"分析 栈的典型应用，左括号入栈，右括号出栈栈顶。若栈顶不匹配或最终栈不空即返回 False。 ","date":"2015-01-20","objectID":"/leetcode/0020/:2:0","tags":null,"title":"0020：有效的括号","uri":"/leetcode/0020/"},{"categories":null,"content":"解答 def isValid(self, s: str) -\u003e bool: stack, d = [], dict(zip(')]}', '([{')) for char in s: if char not in d: stack.append(char) elif not stack or stack.pop() != d[char]: return False return not stack 时间 O(N)，32 ms ","date":"2015-01-20","objectID":"/leetcode/0020/:3:0","tags":null,"title":"0020：有效的括号","uri":"/leetcode/0020/"},{"categories":null,"content":" 力扣第 19 题 ","date":"2015-01-19","objectID":"/leetcode/0019/:0:0","tags":null,"title":"0019：删除链表的倒数第 N 个结点（★）","uri":"/leetcode/0019/"},{"categories":null,"content":"题目 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 提示： 链表中结点的数目为 sz 1 \u003c= sz \u003c= 30 0 \u003c= Node.val \u003c= 100 1 \u003c= n \u003c= sz 进阶：你能尝试使用一趟扫描实现吗？ ","date":"2015-01-19","objectID":"/leetcode/0019/:1:0","tags":null,"title":"0019：删除链表的倒数第 N 个结点（★）","uri":"/leetcode/0019/"},{"categories":null,"content":"分析 可以用经典的快慢指针解法： 一开始快慢指针都指向哑结点 快指针先走 n 步 然后两个指针同时走直到快指针到尾部 这时慢指针指向的就是倒数第 n+1 个结点 ","date":"2015-01-19","objectID":"/leetcode/0019/:2:0","tags":null,"title":"0019：删除链表的倒数第 N 个结点（★）","uri":"/leetcode/0019/"},{"categories":null,"content":"解答 def removeNthFromEnd(self, head: ListNode, n: int) -\u003e ListNode: dummy = slow = fast = ListNode(next=head) for _ in range(n): fast = fast.next while fast.next: slow = slow.next fast = fast.next slow.next = slow.next.next return dummy.next 时间 O(N)，36 ms ","date":"2015-01-19","objectID":"/leetcode/0019/:3:0","tags":null,"title":"0019：删除链表的倒数第 N 个结点（★）","uri":"/leetcode/0019/"},{"categories":null,"content":" 力扣第 18 题 ","date":"2015-01-18","objectID":"/leetcode/0018/:0:0","tags":null,"title":"0018：四数之和（★）","uri":"/leetcode/0018/"},{"categories":null,"content":"题目 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 \u003c= a, b, c, d \u003c n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],","date":"2015-01-18","objectID":"/leetcode/0018/:1:0","tags":null,"title":"0018：四数之和（★）","uri":"/leetcode/0018/"},{"categories":null,"content":"分析 ","date":"2015-01-18","objectID":"/leetcode/0018/:2:0","tags":null,"title":"0018：四数之和（★）","uri":"/leetcode/0018/"},{"categories":null,"content":"#1 类似 0015，不过是多加了一重循环。 def fourSum(self, nums: List[int], target: int) -\u003e List[List[int]]: nums.sort() d = {x: i for i, x in enumerate(nums)} res, n = [], len(nums) for i in range(n-3): if i and nums[i]==nums[i-1]: continue for j in range(i+1, n-2): if j\u003ei+1 and nums[j]==nums[j-1]: continue for k in","date":"2015-01-18","objectID":"/leetcode/0018/:2:1","tags":null,"title":"0018：四数之和（★）","uri":"/leetcode/0018/"},{"categories":null,"content":"#2 本题的循环轮数较多，可以加强限制，例如： sum(nums[i:i+4])\u003etarget 时可以跳出循环 nums[i]+sum(nums[-3:])\u003ctarget 时，可以跳过 i ","date":"2015-01-18","objectID":"/leetcode/0018/:2:2","tags":null,"title":"0018：四数之和（★）","uri":"/leetcode/0018/"},{"categories":null,"content":"解答 def fourSum(self, nums: List[int], target: int) -\u003e List[List[int]]: nums.sort() d = {x: i for i, x in enumerate(nums)} res, n = [], len(nums) for i in range(n-3): if sum(nums[i:i+4])\u003etarget: break if (i and nums[i]==nums[i-1]) or nums[i]+sum(nums[-3:])\u003ctarget: continue for j in range(i+1, n-2): i","date":"2015-01-18","objectID":"/leetcode/0018/:3:0","tags":null,"title":"0018：四数之和（★）","uri":"/leetcode/0018/"},{"categories":null,"content":" 力扣第 17 题 ","date":"2015-01-17","objectID":"/leetcode/0017/:0:0","tags":null,"title":"0017：电话号码的字母组合（★）","uri":"/leetcode/0017/"},{"categories":null,"content":"题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 输入：digits = \"23\" 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] 示例 2： 输入：digits = \"\" 输出：[] 示例 3： 输入：digits = \"2\" 输出：[\"a\",\"b\",\"c\"] 提示： 0 \u003c= digits.length \u003c= 4 digits[i] 是范围 ['2', '9'] 的一个数字。 ","date":"2015-01-17","objectID":"/leetcode/0017/:1:0","tags":null,"title":"0017：电话号码的字母组合（★）","uri":"/leetcode/0017/"},{"categories":null,"content":"分析 可以递推前 i 个字符能代表的组合。 ","date":"2015-01-17","objectID":"/leetcode/0017/:2:0","tags":null,"title":"0017：电话号码的字母组合（★）","uri":"/leetcode/0017/"},{"categories":null,"content":"解答 def letterCombinations(self, digits: str) -\u003e List[str]: d = dict(zip('23456789', ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'])) res = [] for x in digits: res = [sub+c for c in d[x] for sub in res or ['']] return res 52 ms ","date":"2015-01-17","objectID":"/leetcode/0017/:3:0","tags":null,"title":"0017：电话号码的字母组合（★）","uri":"/leetcode/0017/"},{"categories":null,"content":" 力扣第 16 题 ","date":"2015-01-16","objectID":"/leetcode/0016/:0:0","tags":null,"title":"0016：最接近的三数之和（★）","uri":"/leetcode/0016/"},{"categories":null,"content":"题目 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 示例 1： 输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 示例 2： 输入：nums = [0,0,0], target = 1 输出：0 提示： 3 \u003c= nums.length \u003c= 1000 -1000 \u003c= nums[i] \u003c= 1000 -104 \u003c= target \u003c= 1","date":"2015-01-16","objectID":"/leetcode/0016/:1:0","tags":null,"title":"0016：最接近的三数之和（★）","uri":"/leetcode/0016/"},{"categories":null,"content":"分析 ","date":"2015-01-16","objectID":"/leetcode/0016/:2:0","tags":null,"title":"0016：最接近的三数之和（★）","uri":"/leetcode/0016/"},{"categories":null,"content":"#1 类似 0015 ，可以先排序再取元组 \u003ca, b, c\u003e。 但本题最后一个数 c 不能直接用哈希表获得。 要查找一个最接近 target-a-b 的数，容易想到用二分查找。 def threeSumClosest(self, nums: List[int], target: int) -\u003e int: nums.sort() res, n = float('inf'), len(nums) for i in range(n-2): for j in range(i+1, n-1): t0 = target-nums[i]-nums[j] pos = bisect_left(nums, t0","date":"2015-01-16","objectID":"/leetcode/0016/:2:1","tags":null,"title":"0016：最接近的三数之和（★）","uri":"/leetcode/0016/"},{"categories":null,"content":"#2 还有个更巧妙的双指针解法。 排序后先固定数 nums[i]，然后寻找 nums[j]、nums[k] 使得两数之和最接近 target-nums[i]。 初始指针 j、k 分别指向 i+1, n-1。 如果 nums[j]+nums[k]\u003ctarget-nums[i]，则 nums[j] 与任意 [j+1,k-1] 内的数相加都更小，离 target 更远，故可以不再考虑 nums[j]，缩小查找范围为 [j+1,k] 同理，如果 nums[j]+nums[k]\u003ctarget-nums[i]，可以缩小查找范围为 [j, k-1] 循环操作直到 j、k 相遇，取过程中最接近的和即可 ","date":"2015-01-16","objectID":"/leetcode/0016/:2:2","tags":null,"title":"0016：最接近的三数之和（★）","uri":"/leetcode/0016/"},{"categories":null,"content":"解答 def threeSumClosest(self, nums: List[int], target: int) -\u003e int: nums.sort() res, n = float('inf'), len(nums) for i in range(n - 2): j, k = i + 1, n - 1 while j \u003c k: s = nums[i] + nums[j] + nums[k] if abs(s - target) \u003c abs(res - target): res = s if s \u003c target: j += 1 else: k -= 1 return res 时间 $O(","date":"2015-01-16","objectID":"/leetcode/0016/:3:0","tags":null,"title":"0016：最接近的三数之和（★）","uri":"/leetcode/0016/"},{"categories":null,"content":" 力扣第 15 题 ","date":"2015-01-15","objectID":"/leetcode/0015/:0:0","tags":null,"title":"0015：三数之和（★）","uri":"/leetcode/0015/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4","date":"2015-01-15","objectID":"/leetcode/0015/:1:0","tags":null,"title":"0015：三数之和（★）","uri":"/leetcode/0015/"},{"categories":null,"content":"分析 取不重复元组的问题，采用排序并跳过相同数字的通用方法即可。 然后类似 0001 ，可以用哈希表优化最后一层的查找。 ","date":"2015-01-15","objectID":"/leetcode/0015/:2:0","tags":null,"title":"0015：三数之和（★）","uri":"/leetcode/0015/"},{"categories":null,"content":"解答 def threeSum(self, nums: List[int]) -\u003e List[List[int]]: nums.sort() d = {num: i for i, num in enumerate(nums)} res, n = [], len(nums) for i in range(n - 2): if i and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 1): if j \u003e i + 1 and nums[j] == nums[j - 1]: continue k = d.get(-nums[i]","date":"2015-01-15","objectID":"/leetcode/0015/:3:0","tags":null,"title":"0015：三数之和（★）","uri":"/leetcode/0015/"},{"categories":null,"content":" 力扣第 14 题 ","date":"2015-01-14","objectID":"/leetcode/0014/:0:0","tags":null,"title":"0014：最长公共前缀","uri":"/leetcode/0014/"},{"categories":null,"content":"题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1： 输入：strs = [\"flower\",\"flow\",\"flight\"] 输出：\"fl\" 示例 2： 输入：strs = [\"dog\",\"racecar\",\"car\"] 输出：\"\" 解释：输入不存在公共前缀。 提示： 1 \u003c= strs.length \u003c= 200 0 \u003c= strs[i].length \u003c= 200 strs[i] 仅由小写英文字母组成 ","date":"2015-01-14","objectID":"/leetcode/0014/:1:0","tags":null,"title":"0014：最长公共前缀","uri":"/leetcode/0014/"},{"categories":null,"content":"分析 遍历判断即可。 ","date":"2015-01-14","objectID":"/leetcode/0014/:2:0","tags":null,"title":"0014：最长公共前缀","uri":"/leetcode/0014/"},{"categories":null,"content":"解答 def longestCommonPrefix(self, strs: List[str]) -\u003e str: res = '' for row in zip(*strs): if len(set(row)) != 1: break res += row[0] return res 28 ms ","date":"2015-01-14","objectID":"/leetcode/0014/:3:0","tags":null,"title":"0014：最长公共前缀","uri":"/leetcode/0014/"},{"categories":null,"content":" 力扣第 13 题 ","date":"2015-01-13","objectID":"/leetcode/0013/:0:0","tags":null,"title":"0013：罗马数字转整数","uri":"/leetcode/0013/"},{"categories":null,"content":"题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (","date":"2015-01-13","objectID":"/leetcode/0013/:1:0","tags":null,"title":"0013：罗马数字转整数","uri":"/leetcode/0013/"},{"categories":null,"content":"分析 观察发现，如果小数字放在大数字左边，则小数字代表负数。因此遍历判断即可。 ","date":"2015-01-13","objectID":"/leetcode/0013/:2:0","tags":null,"title":"0013：罗马数字转整数","uri":"/leetcode/0013/"},{"categories":null,"content":"解答 def romanToInt(self, s: str) -\u003e int: d = dict(zip('IVXLCDM', [1, 5, 10, 50, 100, 500, 1000])) A = [d[c] for c in s] return sum(-a if a\u003cb else a for a,b in pairwise(A)) + A[-1] 40 ms ","date":"2015-01-13","objectID":"/leetcode/0013/:3:0","tags":null,"title":"0013：罗马数字转整数","uri":"/leetcode/0013/"},{"categories":null,"content":" 力扣第 12 题 ","date":"2015-01-12","objectID":"/leetcode/0012/:0:0","tags":null,"title":"0012：整数转罗马数字（★）","uri":"/leetcode/0012/"},{"categories":null,"content":"题目 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5","date":"2015-01-12","objectID":"/leetcode/0012/:1:0","tags":null,"title":"0012：整数转罗马数字（★）","uri":"/leetcode/0012/"},{"categories":null,"content":"分析 从大到小放字符，如果数字大于 1000，就先放 M 直到剩余数小于 1000，如果还大于 900，就放 CM，依此类推。 ","date":"2015-01-12","objectID":"/leetcode/0012/:2:0","tags":null,"title":"0012：整数转罗马数字（★）","uri":"/leetcode/0012/"},{"categories":null,"content":"解答 def intToRoman(self, num: int) -\u003e str: d = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")] res = '' for w, x in d: res += x * (num // w) num %= w return res 48 ms ","date":"2015-01-12","objectID":"/leetcode/0012/:3:0","tags":null,"title":"0012：整数转罗马数字（★）","uri":"/leetcode/0012/"},{"categories":null,"content":" 力扣第 11 题 ","date":"2015-01-11","objectID":"/leetcode/0011/:0:0","tags":null,"title":"0011：盛最多水的容器（★）","uri":"/leetcode/0011/"},{"categories":null,"content":"题目 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2： 输入：height = [1,1] 输出：1 提示： n == height.length 2 \u003c= n \u003c= ","date":"2015-01-11","objectID":"/leetcode/0011/:1:0","tags":null,"title":"0011：盛最多水的容器（★）","uri":"/leetcode/0011/"},{"categories":null,"content":"分析 本题是经典的双指针问题。 初始指针 i、j 分别指向 height 的首尾，组成容器 C。 如果 height[i]\u003c=height[j]，则 i 与任意 [i+1,j-1] 内的线组成的容器都小于 C，故可以不再考虑 height[i]，缩小查找范围为 [i+1,j] 同理，如果 height[i]\u003e=height[j]，可以缩小查找范围为 [i, j-1] 循环操作直到 i、j 相遇，取过程中的最大容器即可。 ","date":"2015-01-11","objectID":"/leetcode/0011/:2:0","tags":null,"title":"0011：盛最多水的容器（★）","uri":"/leetcode/0011/"},{"categories":null,"content":"解答 def maxArea(self, height: List[int]) -\u003e int: res, i, j = 0, 0, len(height)-1 while i \u003c j: res = max(res, (j-i)*min(height[i], height[j])) if height[i] \u003c= height[j]: i += 1 else: j -= 1 return res 时间 O(N)，236 ms ","date":"2015-01-11","objectID":"/leetcode/0011/:3:0","tags":null,"title":"0011：盛最多水的容器（★）","uri":"/leetcode/0011/"},{"categories":null,"content":"以中世纪的法兰西王国为舞台，讲述了在百年战争的时代，身为最强魔女同时也是圣女的玛利亚十分厌恶战争，她拥有的强大魔力足以让纷争消失。然而，如果她失去了自己的处女之身，那么届时也将失去强大的力量。","date":"2015-01-11","objectID":"/anime/maria_the_virgin_witch/","tags":null,"title":"纯洁的玛利亚","uri":"/anime/maria_the_virgin_witch/"},{"categories":null,"content":"简介 以中世纪的法兰西王国为舞台，讲述了在百年战争的时代，身为最强魔女同时也是圣女的玛利亚十分厌恶战争，她拥有的强大魔力足以让纷争消失。然而，如果她失去了自己的处女之身，那么届时也将失去强大的力量。 制作人员： 原作：石川雅之 导演：谷口悟朗 脚本：仓田英之 分镜：须永司、井端义秀、新留俊哉、远藤广隆、细川秀树 ","date":"2015-01-11","objectID":"/anime/maria_the_virgin_witch/:1:0","tags":null,"title":"纯洁的玛利亚","uri":"/anime/maria_the_virgin_witch/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 玛利亚 女 金元寿子 2 阿耳忒弥斯 女 日笠陽子 3 普里阿普斯 男 小松未可子 4 以西结 女 花澤香菜 5 约瑟夫 男 小野賢章 6 安 女 加隈亜衣 7 玛莎 女 一城みゆ希 8 维弗 能登麻美子 ","date":"2015-01-11","objectID":"/anime/maria_the_virgin_witch/:2:0","tags":null,"title":"纯洁的玛利亚","uri":"/anime/maria_the_virgin_witch/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 纯洁的玛利亚 2015-01-11 12 樱花 ","date":"2015-01-11","objectID":"/anime/maria_the_virgin_witch/:3:0","tags":null,"title":"纯洁的玛利亚","uri":"/anime/maria_the_virgin_witch/"},{"categories":null,"content":"《夜之小双侠》以系列作品中的反派角色”杜伦布贼党“的后裔为主人公。小双侠在打败杜伦布后所建立的王国并非如此美好，相反地却让人民饱受苦难。新生杜伦布的首领继承了多龙芝之名，向小双侠发动了复仇...... ","date":"2015-01-11","objectID":"/anime/yatterman_night/","tags":null,"title":"夜之小双侠","uri":"/anime/yatterman_night/"},{"categories":null,"content":"简介 《夜之小双侠》以系列作品中的反派角色”杜伦布贼党“的后裔为主人公。小双侠在打败杜伦布后所建立的王国并非如此美好，相反地却让人民饱受苦难。新生杜伦布的首领继承了多龙芝之名，向小双侠发动了复仇…… 制作人员： 原作：龙之子企画室 导演：吉原达矢 分镜：柊阳菜、中野英明 演出：野木森达哉 音乐：加藤达也 ","date":"2015-01-11","objectID":"/anime/yatterman_night/:1:0","tags":null,"title":"夜之小双侠","uri":"/anime/yatterman_night/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 多龙芝 蕾帕特、Doronjo、レパード 女 喜多村英梨 2 伯亚基 伯尔特卡切、Boyacky、ヴォルトカッツェ 男 平田広明 3 东兹拉 艾列潘图斯、Tonzura、エレパントゥス 男 三宅健太 4 欧达 オダ たかはし智秋 5 多萝西 女 伊藤静 ","date":"2015-01-11","objectID":"/anime/yatterman_night/:2:0","tags":null,"title":"夜之小双侠","uri":"/anime/yatterman_night/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 夜之小双侠 2015-01-11 12 bilibili ","date":"2015-01-11","objectID":"/anime/yatterman_night/:3:0","tags":null,"title":"夜之小双侠","uri":"/anime/yatterman_night/"},{"categories":null,"content":" 力扣第 10 题 ","date":"2015-01-10","objectID":"/leetcode/0010/:0:0","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"题目 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 示例 1： 输入：s = \"aa\", p = \"a\" 输出：false 解释：\"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入：s = \"aa\", p = \"a*\" 输出：true 解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3： 输入：s = \"","date":"2015-01-10","objectID":"/leetcode/0010/:1:0","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"分析 ","date":"2015-01-10","objectID":"/leetcode/0010/:2:0","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"#1 最简单的就是直接调用正则。 def isMatch(self, s: str, p: str) -\u003e bool: return bool(re.match(p+'$', s)) 68 ms ","date":"2015-01-10","objectID":"/leetcode/0010/:2:1","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"#2 尝试自己实现： 因为 ‘*’ 与前一个字符相关，所以考虑从后往前看。 如果 p[-1] == ‘*’，那么 p 匹配 s 必然是两种情况之一： ‘*’ 代表零个，p[:-2] 匹配 s ‘*’ 代表多个，p[-2] 匹配 s[-1] 且 p 匹配 s[:-1] 如果 p[-1] != ‘*’，那么 p 匹配 s 必然是 p[-1] 匹配 s[-1] 且 p[:-1] 匹配 s[:-1]。 都能转成递归子问题。注意到有重复子问题，所以用记忆化递归。 ","date":"2015-01-10","objectID":"/leetcode/0010/:2:2","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"解答 def isMatch(self, s: str, p: str) -\u003e bool: @cache def dfs(s, p): if not p: return not s if p[-1] == '*': return dfs(s, p[:-2]) or (bool(s) and p[-2] in [s[-1],'.'] and dfs(s[:-1], p)) return bool(s) and p[-1] in [s[-1],'.'] and dfs(s[:-1], p[:-1]) return dfs(s, p) 40 ms ","date":"2015-01-10","objectID":"/leetcode/0010/:3:0","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"在“东京大决战”结束十年之后，日本各地区已经成为了一个个独立国家。而一名任职于自警团、成绩平平的女孩森友望未，某日心血来潮地踏上了横跨日本列岛诸国的旅程。 她沿途邂逅了响逢衣、御园千绫、小坂结季奈等人，这四个女孩将背负起守护和平的使命。而在旅途前方等待着他们的有魔法师、怪兽与巨大机器人。由这四名少女所交织而成，新感觉公路青春故事即将上演！","date":"2015-01-10","objectID":"/anime/the_rolling_girls/","tags":null,"title":"旋转少女","uri":"/anime/the_rolling_girls/"},{"categories":null,"content":"简介 在“东京大决战”结束十年之后，日本各地区已经成为了一个个独立国家。而一名任职于自警团、成绩平平的女孩森友望未，某日心血来潮地踏上了横跨日本列岛诸国的旅程。 她沿途邂逅了响逢衣、御园千绫、小坂结季奈等人，这四个女孩将背负起守护和平的使命。而在旅途前方等待着他们的有魔法师、怪兽与巨大机器人。由这四名少女所交织而成，新感觉公路青春故事即将上演！ 制作人员： 导演：出合小都美 脚本：武藤康之 分镜：柳沼和良、平川哲生、宫地昌幸、今井有文、村田俊治、橘正纪 ","date":"2015-01-10","objectID":"/anime/the_rolling_girls/:1:0","tags":null,"title":"旋转少女","uri":"/anime/the_rolling_girls/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 森友望未 もりとも のぞみ 小澤亜李 2 小坂结季奈 こさか ゆきな 日高里菜 3 响逢衣 ひびき あい 種田梨沙 4 御园千绫 みその ちあや、misono chiaya 花守ゆみり 5 宇德真茶未/抹茶绿 うとく まさみ、Utoku Masami 女 藤村歩 6 执行玖仁子 しぎょう くにこ 女 緒乃冬華 7 音无绿 おとなしゆかり 古木のぞみ 8 御园遥 所沢大統領、みその ハルカ、Misono Haruka 大原さやか ","date":"2015-01-10","objectID":"/anime/the_rolling_girls/:2:0","tags":null,"title":"旋转少女","uri":"/anime/the_rolling_girls/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 旋转少女 2015-01-10 12 樱花 ","date":"2015-01-10","objectID":"/anime/the_rolling_girls/:3:0","tags":null,"title":"旋转少女","uri":"/anime/the_rolling_girls/"},{"categories":null,"content":" 力扣第 9 题 ","date":"2015-01-09","objectID":"/leetcode/0009/:0:0","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"题目 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 示例 1： 输入：x = 121 输出：true 示例 2： 输入：x = -121 输出：false 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3： 输入：x = 10 输出：false 解释：从右向左读, 为 01 。因此它不是一个回文数。 提示： -231 \u003c= x \u003c= 231 - 1 进阶：你能不将整数转为字符串来解决这个问题吗","date":"2015-01-09","objectID":"/leetcode/0009/:1:0","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"分析 ","date":"2015-01-09","objectID":"/leetcode/0009/:2:0","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"#1 最简单的就是转为字符串判断。 def isPalindrome(self, x: int) -\u003e bool: return str(x) == str(x)[::-1] 80 ms ","date":"2015-01-09","objectID":"/leetcode/0009/:2:1","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"#2 也可以类似 0007 将整数反转，判断是否相等。 注意负数必然不是回文数。 ","date":"2015-01-09","objectID":"/leetcode/0009/:2:2","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"解答 def isPalindrome(self, x: int) -\u003e bool: if x \u003c 0: return False y, tmp = 0, x while tmp: y = y * 10 + tmp % 10 tmp //= 10 return y == x 72 ms ","date":"2015-01-09","objectID":"/leetcode/0009/:3:0","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":" 力扣第 8 题 ","date":"2015-01-08","objectID":"/leetcode/0008/:0:0","tags":null,"title":"0008：字符串转换整数 (atoi)（★）","uri":"/leetcode/0008/"},{"categories":null,"content":"题目 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，\"123\" -\u003e 123， \"0032\" -\u003e 32）。如果没有读入数字，则整数为 0 。必要时","date":"2015-01-08","objectID":"/leetcode/0008/:1:0","tags":null,"title":"0008：字符串转换整数 (atoi)（★）","uri":"/leetcode/0008/"},{"categories":null,"content":"分析 最直接的就是用正则提取出整数，再判断是否溢出。 ","date":"2015-01-08","objectID":"/leetcode/0008/:2:0","tags":null,"title":"0008：字符串转换整数 (atoi)（★）","uri":"/leetcode/0008/"},{"categories":null,"content":"解答 def myAtoi(self, s: str) -\u003e int: tmp = re.match('[+-]?\\d+', s.strip()) return max(min(int(tmp.group()), 2**31-1), -2**31) if tmp else 0 36 ms ","date":"2015-01-08","objectID":"/leetcode/0008/:3:0","tags":null,"title":"0008：字符串转换整数 (atoi)（★）","uri":"/leetcode/0008/"},{"categories":null,"content":"春假时，为了购买动画蓝光片而打工的御宅族安艺伦也，在开满樱花的坡道上邂逅一位少女，帮她捡一顶被风吹走的帽子。于是有了以该少女为女主角制作同人游戏的构想。一个月后，才知道该少女是他的同班同学，名叫加藤惠。\n\n为了制作游戏，安艺伦也还要说服同年级美术部的绘画高手泽村·史宾瑟·英梨梨，以及优等生学姐霞之丘诗羽和加藤惠共组同人游戏社团，开始同人游戏的制作。之后又有波岛出海及擅长音乐的冰堂美智留等人的加入。","date":"2015-01-08","objectID":"/anime/saekano/","tags":null,"title":"路人女主的养成方法","uri":"/anime/saekano/"},{"categories":null,"content":"简介 春假时，为了购买动画蓝光片而打工的御宅族安艺伦也，在开满樱花的坡道上邂逅一位少女，帮她捡一顶被风吹走的帽子。于是有了以该少女为女主角制作同人游戏的构想。一个月后，才知道该少女是他的同班同学，名叫加藤惠。 为了制作游戏，安艺伦也还要说服同年级美术部的绘画高手泽村·史宾瑟·英梨梨，以及优等生学姐霞之丘诗羽和加藤惠共组同人游戏社团，开始同人游戏的制作。之后又有波岛出海及擅长音乐的冰堂美智留等人的加入。 制作人员： 原作：丸户史明 导演：龟井干太 分镜：小寺胜之、山崎雄太、志村宏明、神户守、福田道生 ","date":"2015-01-08","objectID":"/anime/saekano/:1:0","tags":null,"title":"路人女主的养成方法","uri":"/anime/saekano/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安艺伦也 あき ともや、Aki Tomoya、伦理君 男 松岡禎丞 2 泽村·史宾瑟·英梨梨 柏木英理、柏木エリ、さわむら・スペンサー・えりり、Sawamura Spencer Eriri 女 大西沙織 3 霞之丘诗羽 かすみがおか うたは、Kasumigaoka Utaha 女 茅野愛衣 4 加藤惠 Katou Megumi、かとう めぐみ、Kato Megumi、圣人惠 女 安野希世乃 5 冰堂美智留 ひょうどう みちる、Hyodo Michiru 女 矢作紗友里 6 波岛出海 はしま いずみ、Hashima Izumi 女 赤﨑千夏 7 波岛伊织 はし","date":"2015-01-08","objectID":"/anime/saekano/:2:0","tags":null,"title":"路人女主的养成方法","uri":"/anime/saekano/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 路人女主的养成方法 2015-01-08 13 bilibili 2 路人女主的养成方法 ♭ 2017-04-06 12 bilibili 3 路人女主的养成方法 Fine 2019-10-26 1 bilibili ","date":"2015-01-08","objectID":"/anime/saekano/:3:0","tags":null,"title":"路人女主的养成方法","uri":"/anime/saekano/"},{"categories":null,"content":"MAD ","date":"2015-01-08","objectID":"/anime/saekano/:4:0","tags":null,"title":"路人女主的养成方法","uri":"/anime/saekano/"},{"categories":null,"content":" 力扣第 7 题 ","date":"2015-01-07","objectID":"/leetcode/0007/:0:0","tags":null,"title":"0007：整数反转（★）","uri":"/leetcode/0007/"},{"categories":null,"content":"题目 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 示例 4： 输入：x = 0 输出：0 提示： -231 \u003c= x \u003c= 231 - 1 ","date":"2015-01-07","objectID":"/leetcode/0007/:1:0","tags":null,"title":"0007：整数反转（★）","uri":"/leetcode/0007/"},{"categories":null,"content":"分析 ","date":"2015-01-07","objectID":"/leetcode/0007/:2:0","tags":null,"title":"0007：整数反转（★）","uri":"/leetcode/0007/"},{"categories":null,"content":"#1 最直接的就是转为字符串反转，再判断是否溢出。 注意负数的负号。 def reverse(self, x: int) -\u003e int: y = int('-'*(x \u003c 0) + str(abs(x))[::-1]) return y if -2**31 \u003c= y \u003c2**31 else 0 40 ms ","date":"2015-01-07","objectID":"/leetcode/0007/:2:1","tags":null,"title":"0007：整数反转（★）","uri":"/leetcode/0007/"},{"categories":null,"content":"#2 也可以按位依次构建，python 中不需要担心溢出。 ","date":"2015-01-07","objectID":"/leetcode/0007/:2:2","tags":null,"title":"0007：整数反转（★）","uri":"/leetcode/0007/"},{"categories":null,"content":"解答 def reverse(self, x: int) -\u003e int: flag = -1 if x \u003c 0 else 1 x, y = abs(x), 0 while x: y = y * 10 + x % 10 x //= 10 return y*flag if -2**31 \u003c= y*flag \u003c 2**31 else 0 28 ms ","date":"2015-01-07","objectID":"/leetcode/0007/:3:0","tags":null,"title":"0007：整数反转（★）","uri":"/leetcode/0007/"},{"categories":null,"content":" 力扣第 6 题 ","date":"2015-01-06","objectID":"/leetcode/0006/:0:0","tags":null,"title":"0006：N 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"题目 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列如下： P A H N A P L S I I G Y I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"PAHNAPLSIIGYIR\"。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1： 输入：s = \"PAYPALISHIRING\", numRows = 3 输出：\"PAHNAPLSIIGYIR\" 示例 2：","date":"2015-01-06","objectID":"/leetcode/0006/:1:0","tags":null,"title":"0006：N 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"分析 ","date":"2015-01-06","objectID":"/leetcode/0006/:2:0","tags":null,"title":"0006：N 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"#1 最直接的就是模拟排列的过程。遍历 s，将每个字符添加到 Z 字形中对应的行，最后再拼接所有行即可。 判断字符所属行时，可以用 flag 标志方向，遇到边界时调转方向。 def convert(self, s: str, numRows: int) -\u003e str: if numRows \u003c 2: return s res = [''] * numRows row, flag = 0, 1 for char in s: res[row] += char row += flag flag *= -1 if row in [0, numRows-1] else 1 return ''.join(","date":"2015-01-06","objectID":"/leetcode/0006/:2:1","tags":null,"title":"0006：N 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"#2 也可以用数学方法直接求出每个下标对应的行。 显然变换周期为 loop=max(1, 2*(numRows-1))，一个周期中的第 k 个字符属于第 min(k, loop-k) 行。 ","date":"2015-01-06","objectID":"/leetcode/0006/:2:2","tags":null,"title":"0006：N 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"解答 def convert(self, s: str, numRows: int) -\u003e str: loop = max(1, (numRows-1)*2) A = ['']*numRows for i, c in enumerate(s): k = min(i%loop, loop-i%loop) A[k] += c return ''.join(A) 64 ms ","date":"2015-01-06","objectID":"/leetcode/0006/:3:0","tags":null,"title":"0006：N 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":" 力扣第 5 题 ","date":"2015-01-05","objectID":"/leetcode/0005/:0:0","tags":null,"title":"0005：最长回文子串（★）","uri":"/leetcode/0005/"},{"categories":null,"content":"题目 给你一个字符串 s，找到 s 中最长的回文子串。 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。 示例 1： 输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案。 示例 2： 输入：s = \"cbbd\" 输出：\"bb\" 提示： 1 \u003c= s.length \u003c= 1000 s 仅由数字和英文字母组成 ","date":"2015-01-05","objectID":"/leetcode/0005/:1:0","tags":null,"title":"0005：最长回文子串（★）","uri":"/leetcode/0005/"},{"categories":null,"content":"分析 ","date":"2015-01-05","objectID":"/leetcode/0005/:2:0","tags":null,"title":"0005：最长回文子串（★）","uri":"/leetcode/0005/"},{"categories":null,"content":"#1 暴力法是直接遍历所有子串，判断是否是回文。显然有很多不必要的判断，观察发现回文子串是可以递推的。 s[i:j+1] 是回文等价于 s[i-1:j] 是回文且 s[i]==s[j]。 因此考虑从短到长递推判断所有子串，取最长的即可。 注意到递推中很多子串是重复使用的，因此可以保存中间结果，避免重复递推。 这种递推方式被称为区间 dp。 具体实现时： 令 dp[i][j] 代表 s[i:j+1] 是否回文，递推式为： $$dp[i][j] = dp[i+1][j-1] \\ and \\ s[i]==s[j]$$ dp[i][j] 依赖 dp[i+1][j-1]，要特别注意遍历顺序： 可以先遍历","date":"2015-01-05","objectID":"/leetcode/0005/:2:1","tags":null,"title":"0005：最长回文子串（★）","uri":"/leetcode/0005/"},{"categories":null,"content":"#2 注意到递推过程中假如 dp[i+1][j-1] 非真，那么就没必要递推 dp[i][j] 了。 因此考虑从初始的 dp[i][i-1] 或 dp[i][i] 往两边递推，一旦非真，就无需考虑了。 于是得到中心扩展法： 遍历所有中心 (i, i-1) 或 (i, i) 对于每个中心，往两边扩展找到最长的回文子串 过程中找到的最长的即为所求 def longestPalindrome(self, s: str) -\u003e str: def expand(l, r): while l and r\u003cn-1 and s[l-1]==s[r+1]: l -= 1 r += 1 return l, r r","date":"2015-01-05","objectID":"/leetcode/0005/:2:2","tags":null,"title":"0005：最长回文子串（★）","uri":"/leetcode/0005/"},{"categories":null,"content":"#3 还有个更巧妙的想法。 令 dp[j] 代表 s[:j] 的最长回文子串长度。那么: s[:j] 的回文子串要么是 s[:j-1] 的回文子串，要么是某个 s[i:j] 如果 s[i:j] 是回文子串，其长度是 s[i+1:j-1] 的长度加 2 因此 dp[j] 不可能超过 dp[j-1]+2，也就是说 dp[j] 只有 3 种可能值，分别判断即可 这种递推方式则被称为线性 dp。 特别的，因为 dp[j] 只依赖 dp[j-1]，所以可以只用一个变量。 ","date":"2015-01-05","objectID":"/leetcode/0005/:2:3","tags":null,"title":"0005：最长回文子串（★）","uri":"/leetcode/0005/"},{"categories":null,"content":"解答 def longestPalindrome(self, s: str) -\u003e str: res, dp = '', 0 for j in range(1, len(s)+1): for L in [dp+1, min(dp+2, j)]: tmp = s[j-L:j] if tmp == tmp[::-1]: res, dp = tmp, L return res 时间 $O(N^2)$，104 ms ","date":"2015-01-05","objectID":"/leetcode/0005/:3:0","tags":null,"title":"0005：最长回文子串（★）","uri":"/leetcode/0005/"},{"categories":null,"content":"*附加 此题还有一个经典的的 Manacher算法。 它在 O(N) 时间内不仅能找到最长回文子串，而且能得到所有中心子串的扩展距离。 因此在与回文相关的问题中，都可以试试能否用 Manacher 算法解决。 def longestPalindrome(self, s: str) -\u003e str: def expand(l, r): while l and r\u003clen(ss)-1 and ss[l-1]==ss[r+1]: l -= 1 r += 1 return (r-l)//2 pair, ss = (0, 0), '#' + '#'.join(s) + '#' A, center, rig","date":"2015-01-05","objectID":"/leetcode/0005/:4:0","tags":null,"title":"0005：最长回文子串（★）","uri":"/leetcode/0005/"},{"categories":null,"content":"有一天，小行星熊玛利亚星在宇宙的某处爆发，成就一群坠落地球的流星，使地球各处的熊发生异变。熊大举进食人类，人类再报以还击，结果造成没有战果和充满仇恨的恶性循环，直至两边不约而同筑起断绝之墙，期望以后互不侵犯……一天早上，呼啸山庄学园的学生——椿辉红羽和泉乃纯花，在学园的百合花坛里一同看见百合之花。二人于是成就“既为朋友，亦为恋人”的关系，并将花坛视为最重要的地方。就在此时，熊警报突然响起，揭示对方再度入侵人类世界，准备陷入混战。揭示这些熊的真实身份和目的之时，新谜题的出现带来新一波的怒涛，揭开背后华丽的每一幕……","date":"2015-01-05","objectID":"/anime/yurikuma_arashi/","tags":null,"title":"百合熊风暴","uri":"/anime/yurikuma_arashi/"},{"categories":null,"content":"简介 有一天，小行星熊玛利亚星在宇宙的某处爆发，成就一群坠落地球的流星，使地球各处的熊发生异变。熊大举进食人类，人类再报以还击，结果造成没有战果和充满仇恨的恶性循环，直至两边不约而同筑起断绝之墙，期望以后互不侵犯……一天早上，呼啸山庄学园的学生——椿辉红羽和泉乃纯花，在学园的百合花坛里一同看见百合之花。二人于是成就“既为朋友，亦为恋人”的关系，并将花坛视为最重要的地方。就在此时，熊警报突然响起，揭示对方再度入侵人类世界，准备陷入混战。揭示这些熊的真实身份和目的之时，新谜题的出现带来新一波的怒涛，揭开背后华丽的每一幕…… 制作人员： 导演：几原邦彦 脚本：伊神贵世 分镜：黑泽雅之、柴田胜纪、酒井","date":"2015-01-05","objectID":"/anime/yurikuma_arashi/:1:0","tags":null,"title":"百合熊风暴","uri":"/anime/yurikuma_arashi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 百合城银子 百合城 銀子、ゆりしろ ぎんこ、Yurishiro Ginko 女 荒川美穂 2 百合咲露露 百合ヶ咲 るる、ゆりがさき るる、Yurigasaki Lulu 女 生田善子 3 椿辉红羽 椿輝 紅羽、つばき くれは、Tsubaki Kureha 女 山根希美 4 Life Sexy らいふ・せくしー、Raifu Sekushi- 男 諏訪部順一 5 Life Cool らいふ・くーる、Raifu Ku-ru 男 斎賀みつき 6 Life Beauty 一生·优雅、らいふ・びゅーてぃー、Raifu Byu-thi- 男 山本和臣 7 泉乃纯花 泉乃","date":"2015-01-05","objectID":"/anime/yurikuma_arashi/:2:0","tags":null,"title":"百合熊风暴","uri":"/anime/yurikuma_arashi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 百合熊风暴 2015-01-05 12 9anime ","date":"2015-01-05","objectID":"/anime/yurikuma_arashi/:3:0","tags":null,"title":"百合熊风暴","uri":"/anime/yurikuma_arashi/"},{"categories":null,"content":" 力扣第 4 题 ","date":"2015-01-04","objectID":"/leetcode/0004/:0:0","tags":null,"title":"0004：寻找两个正序数组的中位数（★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"题目 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 提示： nums1.length == m nums2.length == n 0 ","date":"2015-01-04","objectID":"/leetcode/0004/:1:0","tags":null,"title":"0004：寻找两个正序数组的中位数（★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"分析 ","date":"2015-01-04","objectID":"/leetcode/0004/:2:0","tags":null,"title":"0004：寻找两个正序数组的中位数（★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"#1 最直接的就是合并后排序得到中位数。 def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003e float: nums, m, n = sorted(nums1+nums2), len(nums1), len(nums2) return (nums[(m+n-1)//2] + nums[(m+n)//2]) / 2 时间 $O((M+N)*log(M+N))$，44 ms ","date":"2015-01-04","objectID":"/leetcode/0004/:2:1","tags":null,"title":"0004：寻找两个正序数组的中位数（★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"#2 有个巧妙的想法: 假设 nums1[i-1]\u003c=nums2[j] 且 nums2[j-1]\u003c=nums1[i]，nums1[:i] 和 nums2[:j] 就是最小的 i+j 个数 当 i+j==(m+n)//2 时，即找到了最小的一半数，即可求出中位数 因此遍历和为 (m+n)//2 的 \u003ci, j\u003e 对，找到满足 nums1[i-1]\u003c=nums2[j] 且 nums2[j-1]\u003c=nums1[i] 的即可 注意 i 递增时，nums1[i-1]、nums1[i] 递增，nums2[j]、nums2[j-1] 递减，因此遍历找到第一个满足 nums2[j-1]\u003c=nums1[i] 的","date":"2015-01-04","objectID":"/leetcode/0004/:2:2","tags":null,"title":"0004：寻找两个正序数组的中位数（★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"#3 注意到如果 nums1[i] \u003e= nums2[j-1]，必然有 nums1[i+1] \u003e= nums2[j-2]，符合单调性，因此可以二分查找 i。 ","date":"2015-01-04","objectID":"/leetcode/0004/:2:3","tags":null,"title":"0004：寻找两个正序数组的中位数（★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"解答 def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003e float: m, n = len(nums1), len(nums2) if m \u003e n: return self.findMedianSortedArrays(nums2, nums1) self.__class__.__getitem__ = lambda self, i: i == m or nums1[i] \u003e= nums2[(m+n)//2-i-1] i = bisect_left(self, True, 0, m) j = (m+n","date":"2015-01-04","objectID":"/leetcode/0004/:3:0","tags":null,"title":"0004：寻找两个正序数组的中位数（★★）","uri":"/leetcode/0004/"},{"categories":null,"content":" 力扣第 3 题 ","date":"2015-01-03","objectID":"/leetcode/0003/:0:0","tags":null,"title":"0003：无重复字符的最长子串（★）","uri":"/leetcode/0003/"},{"categories":null,"content":"题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 提示： 0 \u003c= s.length \u003c= 5 * 104 s 由英文","date":"2015-01-03","objectID":"/leetcode/0003/:1:0","tags":null,"title":"0003：无重复字符的最长子串（★）","uri":"/leetcode/0003/"},{"categories":null,"content":"分析 遍历每个位置 j 作为结尾，找符合条件的最长子串 [i, j] 即可。 发现遍历中 i 必然是不动或向右移的，因此是滑动窗口。 还可以用哈希表记录字符的上一个位置，加速 i 的移动。 ","date":"2015-01-03","objectID":"/leetcode/0003/:2:0","tags":null,"title":"0003：无重复字符的最长子串（★）","uri":"/leetcode/0003/"},{"categories":null,"content":"解答 def lengthOfLongestSubstring(self, s: str) -\u003e int: res, i, d = 0, 0, {} for j, char in enumerate(s): i = max(i, d.get(char, -1)+1) res = max(res, j-i+1) d[char] = j return res 52 ms ","date":"2015-01-03","objectID":"/leetcode/0003/:3:0","tags":null,"title":"0003：无重复字符的最长子串（★）","uri":"/leetcode/0003/"},{"categories":null,"content":" 力扣第 2 题 ","date":"2015-01-02","objectID":"/leetcode/0002/:0:0","tags":null,"title":"0002：两数相加（★）","uri":"/leetcode/0002/"},{"categories":null,"content":"题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的","date":"2015-01-02","objectID":"/leetcode/0002/:1:0","tags":null,"title":"0002：两数相加（★）","uri":"/leetcode/0002/"},{"categories":null,"content":"分析 链表是逆序存储，所以取到的数字依次是个十百千位。很自然的想到普通人算加法的方式，先算低位，再结合进位算高位。 要注意边界条件，两个链表长度可能不一样，结果可能比两个链表都长，需要再添加新节点。 ","date":"2015-01-02","objectID":"/leetcode/0002/:2:0","tags":null,"title":"0002：两数相加（★）","uri":"/leetcode/0002/"},{"categories":null,"content":"解答 def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u003e ListNode: dummy = p = ListNode() carry = 0 while l1 or l2: a = l1.val if l1 else 0 b = l2.val if l2 else 0 s = a + b + carry p.next = ListNode(s % 10) carry = s // 10 p = p.next l1 = l1.next if l1 else l1 l2 = l2.next if l2 else l2 p.next = L","date":"2015-01-02","objectID":"/leetcode/0002/:3:0","tags":null,"title":"0002：两数相加（★）","uri":"/leetcode/0002/"},{"categories":null,"content":" 力扣第 1 题 ","date":"2015-01-01","objectID":"/leetcode/0001/:0:0","tags":null,"title":"0001：两数之和","uri":"/leetcode/0001/"},{"categories":null,"content":"题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = ","date":"2015-01-01","objectID":"/leetcode/0001/:1:0","tags":null,"title":"0001：两数之和","uri":"/leetcode/0001/"},{"categories":null,"content":"分析 ","date":"2015-01-01","objectID":"/leetcode/0001/:2:0","tags":null,"title":"0001：两数之和","uri":"/leetcode/0001/"},{"categories":null,"content":"#1 最直接的就是是两次遍历，找出答案。 def twoSum(self, nums: List[int], target: int) -\u003e List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i, j] 时间 O(N^2)，2860 ms ","date":"2015-01-01","objectID":"/leetcode/0001/:2:1","tags":null,"title":"0001：两数之和","uri":"/leetcode/0001/"},{"categories":null,"content":"#2 注意到第二层遍历等价于查询一个数，所以可以用哈希表节省时间。 边遍历边用哈希存储元素位置，每轮查询前面是否有对应的数即可。 ","date":"2015-01-01","objectID":"/leetcode/0001/:2:2","tags":null,"title":"0001：两数之和","uri":"/leetcode/0001/"},{"categories":null,"content":"解答 def twoSum(self, nums: List[int], target: int) -\u003e List[int]: d = {} for j, num in enumerate(nums): if target-num in d: return [d[target-num], j] d[num] = j 时间 O(N)，28 ms ","date":"2015-01-01","objectID":"/leetcode/0001/:3:0","tags":null,"title":"0001：两数之和","uri":"/leetcode/0001/"},{"categories":null,"content":"在地球爆发“纳米危机”大部分生态被摧毁后，98%的人类舍弃肉身，将自己人格数据化迁往部署在地月系L1点的太空站“迪瓦（Deva）”的虚拟数据空间中生活。在2400年一股名为“弗隆提亚·赛格（Frontier Setter）”的力量不断骇入“迪瓦”，并广播寻求自愿参加宇宙移民的成员，“迪瓦”高层认为来源是来自地球地面上，所以派遣特工“安吉拉·巴尔扎克（Angela Balzac）”使用重新生成的肉体素体（Material Body）返回地面。和地面协助人员“丁格（Dingo）”寻找并摧毁其。安吉拉和丁格汇合后，在不断的追寻中发现该力量并非原先所想的简单，并且也改变了对自己所处的世界和地面人的世界的态度…… ","date":"2014-11-15","objectID":"/anime/expelled_from_paradise/","tags":null,"title":"乐园追放 -Expelled From Paradise-","uri":"/anime/expelled_from_paradise/"},{"categories":null,"content":"简介 在地球爆发“纳米危机”大部分生态被摧毁后，98%的人类舍弃肉身，将自己人格数据化迁往部署在地月系L1点的太空站“迪瓦（Deva）”的虚拟数据空间中生活。在2400年一股名为“弗隆提亚·赛格（Frontier Setter）”的力量不断骇入“迪瓦”，并广播寻求自愿参加宇宙移民的成员，“迪瓦”高层认为来源是来自地球地面上，所以派遣特工“安吉拉·巴尔扎克（Angela Balzac）”使用重新生成的肉体素体（Material Body）返回地面。和地面协助人员“丁格（Dingo）”寻找并摧毁其。安吉拉和丁格汇合后，在不断的追寻中发现该力量并非原先所想的简单，并且也改变了对自己所处的世界和地面人","date":"2014-11-15","objectID":"/anime/expelled_from_paradise/:1:0","tags":null,"title":"乐园追放 -Expelled From Paradise-","uri":"/anime/expelled_from_paradise/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安吉拉·巴尔扎克 安洁拉·巴尔扎克、angela balzac 女 釘宮理恵 2 扎里克·卡吉瓦拉 dingo、ディンゴ、丁格、zarik kajiwara 男 三木眞一郎 3 弗隆提亚·赛格 Frontier Setter ？？ 神谷浩史 4 广播 アナウンサー、Announcer、播音员、Announce 森下由樹子 ","date":"2014-11-15","objectID":"/anime/expelled_from_paradise/:2:0","tags":null,"title":"乐园追放 -Expelled From Paradise-","uri":"/anime/expelled_from_paradise/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 乐园追放 -Expelled From Paradise- 2014-11-15 01:43:38 樱花 ","date":"2014-11-15","objectID":"/anime/expelled_from_paradise/:3:0","tags":null,"title":"乐园追放 -Expelled From Paradise-","uri":"/anime/expelled_from_paradise/"},{"categories":null,"content":"“日本动画展会”，是一项短篇动画系列企划，将由动画制作公司Khara和NICONICO视频网站运营方DWANGO共同负责实施。\n在既定的预算和时间内，动画制作者可以自由制作各种不分类型的短篇动画，然后在每周的星期五公开一集。\n除了原创动画之外，还接受外传动画、宣传动画、音乐视频等作品类型的制作。DWANGO和Khara在谈及该企划的理念时表示：“我们将会提供一个不限制创作表现的\n‘自由的创作平台’，探索在日本动画制作过程中的企划开发、研究开发、人才培养等方面的可能性”。DWANGO的川上量生会长还说道：“我们没有考虑过要收支平衡”。","date":"2014-11-07","objectID":"/anime/japan_animator_expo/","tags":null,"title":"日本动画（人）博览会","uri":"/anime/japan_animator_expo/"},{"categories":null,"content":"简介 “日本动画展会”，是一项短篇动画系列企划，将由动画制作公司Khara和NICONICO视频网站运营方DWANGO共同负责实施。 在既定的预算和时间内，动画制作者可以自由制作各种不分类型的短篇动画，然后在每周的星期五公开一集。 除了原创动画之外，还接受外传动画、宣传动画、音乐视频等作品类型的制作。DWANGO和Khara在谈及该企划的理念时表示：“我们将会提供一个不限制创作表现的 ‘自由的创作平台’，探索在日本动画制作过程中的企划开发、研究开发、人才培养等方面的可能性”。DWANGO的川上量生会长还说道：“我们没有考虑过要收支平衡”。 制作人员： 原作：凯乐股份有限公司、庵野秀明、安野梦洋","date":"2014-11-07","objectID":"/anime/japan_animator_expo/:1:0","tags":null,"title":"日本动画（人）博览会","uri":"/anime/japan_animator_expo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 日本动画（人）博览会 2014-11-07 35 下方 ","date":"2014-11-07","objectID":"/anime/japan_animator_expo/:2:0","tags":null,"title":"日本动画（人）博览会","uri":"/anime/japan_animator_expo/"},{"categories":null,"content":"CARTOON NETWORK出品 讲述了两兄弟在一片神秘的森林中迷失，并寻找回家的路的故事","date":"2014-11-03","objectID":"/anime/over_the_garden_wall/","tags":null,"title":"花园墙外","uri":"/anime/over_the_garden_wall/"},{"categories":null,"content":"简介 CARTOON NETWORK出品 讲述了两兄弟在一片神秘的森林中迷失，并寻找回家的路的故事 ","date":"2014-11-03","objectID":"/anime/over_the_garden_wall/:1:0","tags":null,"title":"花园墙外","uri":"/anime/over_the_garden_wall/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 花园墙外 2014-11-03 10 樱花 ","date":"2014-11-03","objectID":"/anime/over_the_garden_wall/:2:0","tags":null,"title":"花园墙外","uri":"/anime/over_the_garden_wall/"},{"categories":null,"content":"故事发生在洋溢着青春气息的校园里，在这里，活跃着各种各样的可爱的女孩子们。 \n\n虽然成绩非常的优秀但实际上整个人都有些天然呆的椎名心实（佐藤聪美 配音）、个性活泼开朗非常热爱广播事业的樱井明音（佐藤利奈 配音）、看上去非常冷淡但是实际上拥有一颗炙热心灵的村上文绪（名冢佳织 配音）、虽然是来自法国的留学生，但是对日本的一切文化都充满了好奇心和热情的克洛伊·勒梅尔（丹下樱 配音）、对可爱的女孩子完全没有抵抗力，到哪里都带着单反照相机的望月艾蕾娜（原田瞳 配音），被这些个性迥异的女生们环绕的日常就此拉开了序幕。","date":"2014-10-12","objectID":"/anime/girl_friend_beta/","tags":null,"title":"临时女友","uri":"/anime/girl_friend_beta/"},{"categories":null,"content":"简介 故事发生在洋溢着青春气息的校园里，在这里，活跃着各种各样的可爱的女孩子们。 虽然成绩非常的优秀但实际上整个人都有些天然呆的椎名心实（佐藤聪美 配音）、个性活泼开朗非常热爱广播事业的樱井明音（佐藤利奈 配音）、看上去非常冷淡但是实际上拥有一颗炙热心灵的村上文绪（名冢佳织 配音）、虽然是来自法国的留学生，但是对日本的一切文化都充满了好奇心和热情的克洛伊·勒梅尔（丹下樱 配音）、对可爱的女孩子完全没有抵抗力，到哪里都带着单反照相机的望月艾蕾娜（原田瞳 配音），被这些个性迥异的女生们环绕的日常就此拉开了序幕。 制作人员： 导演：林直孝（动画人） 脚本：下山健人、佐佐木奈文、吉田玲子、高山克彦、横","date":"2014-10-12","objectID":"/anime/girl_friend_beta/:1:0","tags":null,"title":"临时女友","uri":"/anime/girl_friend_beta/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 椎名心实 椎名 心実、しいな ここみ、Shiina Kokomi 女 佐藤聡美 2 朝比奈桃子 朝比奈 桃子、あさひな ももこ、Asahina Momoko 女 小倉唯 3 樱井明音 櫻井 明音、さくらい あかね、Sakurai Akane 女 佐藤利奈 4 望月惠丽奈 望月 エレナ、もちづき えれな、Mochizuki Erena 女 原田ひとみ 5 克洛艾·鲁梅尔 Chloé Lemaire、くろえるめーる、Kuroe Rumeeru 女 丹下桜 6 村上文绪 村上 文緒、むらかみ ふみお、Murakami Fumio 女 名塚佳織 7 夏目真寻 夏目 ","date":"2014-10-12","objectID":"/anime/girl_friend_beta/:2:0","tags":null,"title":"临时女友","uri":"/anime/girl_friend_beta/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 临时女友 2014-10-12 12 bilibili ","date":"2014-10-12","objectID":"/anime/girl_friend_beta/:3:0","tags":null,"title":"临时女友","uri":"/anime/girl_friend_beta/"},{"categories":null,"content":"本作的故事主要围绕追逐梦想的五名女生——宫森葵、安原绘麻、坂木静香、藤堂美沙、今井绿展开，是一部描写以白箱的完成为目标而奋斗的她们，每天遇到的麻烦以及策划工作时碰到的纠葛与挫折，还有制作组在制作作品时的团结和冲突的动画业界的日常的群像剧作品。 ","date":"2014-10-09","objectID":"/anime/shirobako/","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"简介 本作的故事主要围绕追逐梦想的五名女生——宫森葵、安原绘麻、坂木静香、藤堂美沙、今井绿展开，是一部描写以白箱的完成为目标而奋斗的她们，每天遇到的麻烦以及策划工作时碰到的纠葛与挫折，还有制作组在制作作品时的团结和冲突的动画业界的日常的群像剧作品。 制作人员： 原作：武藏野Animation 导演：水岛努 脚本：浦畑达彦、横手美智子、吉田玲子 分镜：筱原俊哉、驹井一也、柿本广大、平井义通 ","date":"2014-10-09","objectID":"/anime/shirobako/:1:0","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫森葵 宮森 あおい、みやもり あおい、Miyamori Aoi、みゃーもり、喵森 女 木村珠莉 2 安原绘麻 安原 絵麻、やすはら えま、Yasuhara Ema 女 佳村はるか 3 坂木静香 坂木 しずか、さかき しずか、Sakaki Shizuka、ずかちゃん 女 千菅春香 4 藤堂美沙 藤堂 美沙、とうどう みさ 女 髙野麻美 5 今井绿 今井 みどり、いまい みどり、Imai Midori、ディーゼル 女 大和田仁美 6 本田丰 本田豊、ほんだ ゆたか、Honda Yutaka 男 西地修哉 7 高梨太郎 高梨 太郎、たかなし たろう、Takana","date":"2014-10-09","objectID":"/anime/shirobako/:2:0","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 白箱 2014-10-09 24 acfun 2 剧场版 白箱 2020-02-29 1 樱花 ","date":"2014-10-09","objectID":"/anime/shirobako/:3:0","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"MAD ","date":"2014-10-09","objectID":"/anime/shirobako/:4:0","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"　　有马公生的母亲一心想把有马培育成举世闻名的钢琴家，而有马也不负母亲的期望，在念小学时就赢得许多钢琴比赛的大奖。11岁的秋天，有马的母亲过世，从此他再也听不见自己弹奏的钢琴声，沮丧的他也只好放弃演奏，但在14岁那年，经由儿时玩伴的介绍，有马认识了小提琴手宫园薰，并被薰的自由奔放吸引，没想到薰竟开口邀请公生在比赛时担任她的伴奏… ","date":"2014-10-09","objectID":"/anime/your_lie_in_april/","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"简介 有马公生的母亲一心想把有马培育成举世闻名的钢琴家，而有马也不负母亲的期望，在念小学时就赢得许多钢琴比赛的大奖。11岁的秋天，有马的母亲过世，从此他再也听不见自己弹奏的钢琴声，沮丧的他也只好放弃演奏，但在14岁那年，经由儿时玩伴的介绍，有马认识了小提琴手宫园薰，并被薰的自由奔放吸引，没想到薰竟开口邀请公生在比赛时担任她的伴奏… 制作人员： 原作：新川直司 导演：石黑恭平 脚本：吉冈孝夫 分镜：神户守、石滨真史、柴山智隆、仓田绫子、黑木美幸、后藤圭二 ","date":"2014-10-09","objectID":"/anime/your_lie_in_april/:1:0","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 有马公生 有馬 公生、ありま こうせい、arima kousei、有马公主 男 花江夏樹 2 宫园薰 宫园香织、みやぞの かをり、Miyazono Kaori 女 種田梨沙 3 泽部椿 澤部 椿、さわべ つばき、Sawabe Tsubaki 女 佐倉綾音 4 渡亮太 渡 亮太、わたり りょうた、watari ryouta 男 逢坂良太 5 相座武士 相座 武士、あいざ たけし、aiza takeshi 男 梶裕貴 6 井川绘见 井川 絵見、いがわ えみ、igawa emi 女 早見沙織 7 有马早希 有馬 早希、ありま さき、Arima Saki 女 能登麻","date":"2014-10-09","objectID":"/anime/your_lie_in_april/:2:0","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 四月是你的谎言 2014-10-09 22 bilibili 2 四月是你的谎言 OAD 2015-05-15 1 bilibili ","date":"2014-10-09","objectID":"/anime/your_lie_in_april/:3:0","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"MAD ","date":"2014-10-09","objectID":"/anime/your_lie_in_april/:4:0","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"　　《我，要成为双马尾》是由日本轻小说家水泽梦原作、春日步负责插画的轻小说，第六回小学馆轻小说大奖‧审查员特别奖作品。故事描写钟爱少女发型“双马尾”的高中1年级男子学生 观束总二 变身为双马尾的幼女战士“红尾战士”，与“蓝尾战士”“黄尾战士”等一起守卫地球和平的发型控战队故事。 ","date":"2014-10-09","objectID":"/anime/twintail/","tags":null,"title":"我，要成为双马尾","uri":"/anime/twintail/"},{"categories":null,"content":"简介 《我，要成为双马尾》是由日本轻小说家水泽梦原作、春日步负责插画的轻小说，第六回小学馆轻小说大奖‧审查员特别奖作品。故事描写钟爱少女发型“双马尾”的高中1年级男子学生 观束总二 变身为双马尾的幼女战士“红尾战士”，与“蓝尾战士”“黄尾战士”等一起守卫地球和平的发型控战队故事。 制作人员： 原作：水泽梦 导演：神户洋行 脚本：和智正喜、荒川稔久 分镜：冲田宫奈、吉田英俊、平野俊贵 演出：阿部雅司 ","date":"2014-10-09","objectID":"/anime/twintail/:1:0","tags":null,"title":"我，要成为双马尾","uri":"/anime/twintail/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 观束总二 Tail Red、红马尾、テイルレッド、観束総二、みつか そうじ、Mitsuka Souji 上坂すみれ 2 津边爱香 テイルブルー、津辺愛香、つべ あいか、Tsube Aika 女 相坂優歌 3 神堂慧理那 テイルイエロー、黄马尾、神堂慧理那、しんどう えりな、Shindou Erina 女 赤﨑千夏 4 朵艾儿 女 内田真礼 5 观束未春 みつか みはる 女 五十嵐裕美 6 依丝娜 善沙暗子、いいすな あんこ、テイルブラック、黑马尾、善沙闇子 女 日笠陽子 7 樱川尊 さくらがわ みこと 女 M・A・O 8 神堂慧梦 しんどう えむ 井上喜久子","date":"2014-10-09","objectID":"/anime/twintail/:2:0","tags":null,"title":"我，要成为双马尾","uri":"/anime/twintail/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我，要成为双马尾 2014-10-09 12 bilibili ","date":"2014-10-09","objectID":"/anime/twintail/:3:0","tags":null,"title":"我，要成为双马尾","uri":"/anime/twintail/"},{"categories":null,"content":"某天于地球上空出现许多孢子，其中诞生的幼虫侵入人体后，可以吞噬掉宿主的头部取而代之，从而管理这个“死掉的身体”，它们能任意变形，其食物便是与寄生体相同的物种。男主角泉新一就是被寄生生物寄生的人类之一，但是由于某种意外，寄生在他体内的生物并没有吃掉他的大脑，而只是取代了他的右手。本性善良正直的泉新一没有被这突如其来的残酷命运击倒，为了被寄生兽杀死的亲友，以及所有人类的未来，他决心与其他完全体寄生兽进行殊死搏斗。","date":"2014-10-08","objectID":"/anime/parasyte/","tags":null,"title":"寄生兽 生命的准则","uri":"/anime/parasyte/"},{"categories":null,"content":"简介 某天于地球上空出现许多孢子，其中诞生的幼虫侵入人体后，可以吞噬掉宿主的头部取而代之，从而管理这个“死掉的身体”，它们能任意变形，其食物便是与寄生体相同的物种。男主角泉新一就是被寄生生物寄生的人类之一，但是由于某种意外，寄生在他体内的生物并没有吃掉他的大脑，而只是取代了他的右手。本性善良正直的泉新一没有被这突如其来的残酷命运击倒，为了被寄生兽杀死的亲友，以及所有人类的未来，他决心与其他完全体寄生兽进行殊死搏斗。 制作人员： 原作：岩明均 导演：清水健一 脚本：米村正二、藤田伸三 分镜：青山弘、高桥亨、原博、泽井幸次、宍户淳 ","date":"2014-10-08","objectID":"/anime/parasyte/:1:0","tags":null,"title":"寄生兽 生命的准则","uri":"/anime/parasyte/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 泉新一 いずみ しんいち、Izumi Shin`ichi 男 島﨑信長 2 米奇 右、Migi、小右 平野綾 3 村野里美 むらの さとみ、Murano Satomi 女 花澤香菜 4 君岛加奈 きみしま かな、Kimishima Kana 女 沢城みゆき 5 田宫良子 田村玲子、たみや りょうこ、Tamiya Ryouko 女 田中敦子 6 铃木秋穗 すずき アキホ、Suzuki Akiho 女 前田玲奈 7 早濑真树子 はやせまきこ、まき 女 芹澤優 8 立川裕子 立川 裕子、たちかわ ゆうこ、Tachikawa Yuuko 女 安野希世乃 ","date":"2014-10-08","objectID":"/anime/parasyte/:2:0","tags":null,"title":"寄生兽 生命的准则","uri":"/anime/parasyte/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 寄生兽 生命的准则 2014-10-08 24 樱花 ","date":"2014-10-08","objectID":"/anime/parasyte/:3:0","tags":null,"title":"寄生兽 生命的准则","uri":"/anime/parasyte/"},{"categories":null,"content":"　　从小备受父王及哈克宝贝呵护的高华国公主‧优娜，在她16岁生日的当天，她的心上人蘇芳来到宫殿，并送她漂亮的发簪。不过优娜的父亲并不允许她跟蘇芳的交往，依旧对蘇芳无法死心的优娜决定向父王表明她的心意时，却意外地撞见父亲被刺杀的惊人场面。不肯面对事实的优娜从此便与护卫哈克展开一连串的逃亡生活… ","date":"2014-10-07","objectID":"/anime/yona_of_the_dawn/","tags":null,"title":"拂晓的尤娜","uri":"/anime/yona_of_the_dawn/"},{"categories":null,"content":"简介 从小备受父王及哈克宝贝呵护的高华国公主‧优娜，在她16岁生日的当天，她的心上人蘇芳来到宫殿，并送她漂亮的发簪。不过优娜的父亲并不允许她跟蘇芳的交往，依旧对蘇芳无法死心的优娜决定向父王表明她的心意时，却意外地撞见父亲被刺杀的惊人场面。不肯面对事实的优娜从此便与护卫哈克展开一连串的逃亡生活… 制作人员： 原作：草凪みずほ 导演：米田和弘 脚本：猪爪慎一、森下直、高桥奈津子、高木圣子、大西信介 分镜：宫崎渚、美袋一 ","date":"2014-10-07","objectID":"/anime/yona_of_the_dawn/:1:0","tags":null,"title":"拂晓的尤娜","uri":"/anime/yona_of_the_dawn/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 尤娜 优娜、Yona 女 斎藤千和 2 孙·哈克 孙·白、Son Haku 男 高垣彩陽 3 苏芳 Swansea、守元、Suon 男 山本希望 4 季夏 白蛇、白龍、Kija 男 森田成一 5 弦亚 席安、青龍 男 小林沙苗 6 翟鹤 杰巴、緑龍 男 諏訪部順一 7 泽诺 黄龍 下野紘 8 悠 Yun 男 皆川純子 ","date":"2014-10-07","objectID":"/anime/yona_of_the_dawn/:2:0","tags":null,"title":"拂晓的尤娜","uri":"/anime/yona_of_the_dawn/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 拂晓的尤娜 2014-10-07 24 bilibili ","date":"2014-10-07","objectID":"/anime/yona_of_the_dawn/:3:0","tags":null,"title":"拂晓的尤娜","uri":"/anime/yona_of_the_dawn/"},{"categories":null,"content":"　　这里是人、神、魔等种族共同生活的神秘世界，密斯塔尔希亚。过去，黑银之翼的巴哈姆特曾几乎令这个世界毁灭，但人，神，魔三族共同战斗，作出了巨大的牺牲后，终于把它的力量封印了起来。接着，神与魔两方分别保存着封印钥匙的一半。二千年以后，世界始终和平安宁。　不知从什么时候起，人类将巴哈姆特当作了独一无二的尊贵存在，畏惧并崇拜它。某一天，一位少女夺走了保护严密的神族的钥匙。世界的均衡渐渐被打破。当巴哈姆特再次发出吼声之时，世界再次落入绝望的深渊。世界啊，毁灭吧！某个声音如此恳求着。 ","date":"2014-10-06","objectID":"/anime/bahamut/","tags":null,"title":"巴哈姆特之怒 GENESIS","uri":"/anime/bahamut/"},{"categories":null,"content":"简介 这里是人、神、魔等种族共同生活的神秘世界，密斯塔尔希亚。过去，黑银之翼的巴哈姆特曾几乎令这个世界毁灭，但人，神，魔三族共同战斗，作出了巨大的牺牲后，终于把它的力量封印了起来。接着，神与魔两方分别保存着封印钥匙的一半。二千年以后，世界始终和平安宁。　不知从什么时候起，人类将巴哈姆特当作了独一无二的尊贵存在，畏惧并崇拜它。某一天，一位少女夺走了保护严密的神族的钥匙。世界的均衡渐渐被打破。当巴哈姆特再次发出吼声之时，世界再次落入绝望的深渊。世界啊，毁灭吧！某个声音如此恳求着。 制作人员： 原作：Cygames 导演：佐藤敬一 脚本：谷崎晃、赤星政尚、长谷川圭一 分镜：初见浩一、岩泷智、武藤健司","date":"2014-10-06","objectID":"/anime/bahamut/:1:0","tags":null,"title":"巴哈姆特之怒 GENESIS","uri":"/anime/bahamut/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 法瓦罗·雷欧涅 FAVARO 男 吉野裕行 2 凯撒·利德法尔德 KAISAR 男 井上剛 3 阿米拉 AMIRA 女 清水理沙 4 莉塔 RITA 沢城みゆき 5 拉瓦雷 LAVALLEY 男 平田広明 6 贞德 Jeanne D’arc 女 潘めぐみ 7 巴克科斯 BACCHUS 男 岩崎ひろし 8 汉萨 HAMSA 鸭 森久保祥太郎 ","date":"2014-10-06","objectID":"/anime/bahamut/:2:0","tags":null,"title":"巴哈姆特之怒 GENESIS","uri":"/anime/bahamut/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 巴哈姆特之怒 GENESIS 2014-10-06 12 bilibili 2 巴哈姆特之怒 VIRGIN SOUL 2017-04-07 24 bilibili ","date":"2014-10-06","objectID":"/anime/bahamut/:3:0","tags":null,"title":"巴哈姆特之怒 GENESIS","uri":"/anime/bahamut/"},{"categories":null,"content":"——这样子好吗？\n那是成长于连1分1秒也无法宽恕的少年心中，重复了无数遍的疑问。\n在给人一种仿如罪恶的感觉一般的平稳的生活中相遇的少女们，就像是看见了过去自己一样，刺痛着少年的心。\n——那个少女所发现的、活着的意义\n无需伪装的、真正的自己——\n——拼命活下去是怎么一回事\n被自己保护的一方变成了保护自己的一方——\n——活着是有意义的，真的是有意义的。\n因为少年的干涉，少女们灰色的果树园再次染上颜色。\n我们无法拥有永远。\n但是，不放开已经抓住了的手还是办得到的吧。\n这就是，一个少年隐藏在心里的一个决定——","date":"2014-10-05","objectID":"/anime/grisaia/","tags":null,"title":"灰色三部曲","uri":"/anime/grisaia/"},{"categories":null,"content":"简介 ——这样子好吗？ 那是成长于连1分1秒也无法宽恕的少年心中，重复了无数遍的疑问。 在给人一种仿如罪恶的感觉一般的平稳的生活中相遇的少女们，就像是看见了过去自己一样，刺痛着少年的心。 ——那个少女所发现的、活着的意义 无需伪装的、真正的自己—— ——拼命活下去是怎么一回事 被自己保护的一方变成了保护自己的一方—— ——活着是有意义的，真的是有意义的。 因为少年的干涉，少女们灰色的果树园再次染上颜色。 我们无法拥有永远。 但是，不放开已经抓住了的手还是办得到的吧。 这就是，一个少年隐藏在心里的一个决定—— 制作人员： 原作：前翼 导演：天冲 脚本：仓田英之、高桥龙也 分镜：佐藤真二、名村英敏","date":"2014-10-05","objectID":"/anime/grisaia/:1:0","tags":null,"title":"灰色三部曲","uri":"/anime/grisaia/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 榊由美子 榊 由美子、さかき ゆみこ、Sakaki Yumiko 女 田中涼子 2 周防天音 周防 天音、すおう あまね、Suou Amane 女 田口宏子 3 松岛满 松嶋 みちる、まつしま みちる、Matsushima Michiru 女 水橋かおり 4 入巢莳菜 イリス・マキナ、Iris、入巣 蒔菜、いりす まきな、Irisu Makina 女 民安ともえ 5 小岭幸 小嶺 幸、こみね さち、Komine Sachi 女 清水愛 6 风见雄二 Yuuji Kazami、風見 雄二、かざみ ゆうじ、Kazami Yūji 男 櫻井孝宏 7 橘千鹤 橘 千","date":"2014-10-05","objectID":"/anime/grisaia/:2:0","tags":null,"title":"灰色三部曲","uri":"/anime/grisaia/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 灰色的果实 2014-10-05 13 樱花 2 灰色的迷宫 2015-04-12 1 樱花 3 灰色的乐园 2015-04-19 10 樱花 ","date":"2014-10-05","objectID":"/anime/grisaia/:3:0","tags":null,"title":"灰色三部曲","uri":"/anime/grisaia/"},{"categories":null,"content":"　　故事主要发生在虚构的大陆『布里塔利亚』上的国家『里昂妮丝王国』，王国的圣骑士们为了准备传说中的圣战而进行军备强化，然而圣骑士团的诸多暴行使得整个国家民不聊生，甚至发动政变囚禁了国王。担忧着国家现状的第三王女『伊丽莎白』，将救国的希望寄托于十年前因涉嫌颠覆王国而被通缉的骑士团『七大罪』从而独自踏上寻找的旅程。注定无果的旅程中，疲惫不堪的伊丽莎白误入某个酒店，被酒店的主人、一名金发少年救下，这名少年正是『七大罪』的团长梅利奥达斯。在将公主从追兵的危机中解救出来后，他们踏上了拯救国家未来的旅途","date":"2014-10-05","objectID":"/anime/the_seven_deadly_sins/","tags":null,"title":"七大罪","uri":"/anime/the_seven_deadly_sins/"},{"categories":null,"content":"简介 故事主要发生在虚构的大陆『布里塔利亚』上的国家『里昂妮丝王国』，王国的圣骑士们为了准备传说中的圣战而进行军备强化，然而圣骑士团的诸多暴行使得整个国家民不聊生，甚至发动政变囚禁了国王。担忧着国家现状的第三王女『伊丽莎白』，将救国的希望寄托于十年前因涉嫌颠覆王国而被通缉的骑士团『七大罪』从而独自踏上寻找的旅程。注定无果的旅程中，疲惫不堪的伊丽莎白误入某个酒店，被酒店的主人、一名金发少年救下，这名少年正是『七大罪』的团长梅利奥达斯。在将公主从追兵的危机中解救出来后，他们踏上了拯救国家未来的旅途 制作人员： 原作：铃木央 导演：冈村天斋 脚本：绫奈由仁子、菅正太郎、花田十辉 分镜：田口智久、白金","date":"2014-10-05","objectID":"/anime/the_seven_deadly_sins/:1:0","tags":null,"title":"七大罪","uri":"/anime/the_seven_deadly_sins/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 梅利奥达斯 Dragon’s Sin of Wrath、憤怒の罪（ドラゴン・シン）、Meliodas 男 梶裕貴 2 伊丽莎白·里昂尼丝 Elizabeth Liones 女 雨宮天 3 霍克 Hawk 久野美咲 4 班 Fox’s Sin of Greed、強欲の罪（フォックス・シン）、Ban 男 鈴木達央 5 金 怠惰の罪（グリズリー・シン）、Grizzly’s Sin of Sloth、ハーレクイン、赫勒昆、克立昆、金恩、Harlequin、哈勒昆、King 男 福山潤 6 黛安 嫉妬の罪（サーペント・シン）、Serpent’s Sin of Envy","date":"2014-10-05","objectID":"/anime/the_seven_deadly_sins/:2:0","tags":null,"title":"七大罪","uri":"/anime/the_seven_deadly_sins/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 七大罪 2014-10-05 24 樱花 2 七大罪 戒律的复活 2018-01-06 24 bilibili ","date":"2014-10-05","objectID":"/anime/the_seven_deadly_sins/:3:0","tags":null,"title":"七大罪","uri":"/anime/the_seven_deadly_sins/"},{"categories":null,"content":"某日在雾弥湖的上空中出现了谜样的圆盘，一度造成全世界的混乱与恐慌，但飞碟却只停留在空中，并没有进一步的行动。在时间流逝中人们渐渐对这件事失去了兴趣......就在两名少女相遇后，静止的时间再次流动，让众人有所改变的全新故事展开，中学生活最后那一年，将拥有一生无法忘怀的回忆。","date":"2014-10-05","objectID":"/anime/sora_no_method/","tags":null,"title":"天体的秩序","uri":"/anime/sora_no_method/"},{"categories":null,"content":"简介 某日在雾弥湖的上空中出现了谜样的圆盘，一度造成全世界的混乱与恐慌，但飞碟却只停留在空中，并没有进一步的行动。在时间流逝中人们渐渐对这件事失去了兴趣……就在两名少女相遇后，静止的时间再次流动，让众人有所改变的全新故事展开，中学生活最后那一年，将拥有一生无法忘怀的回忆。 制作人员： 导演：迫井政行 脚本：久弥直树 分镜：岛津裕行、若林信 演出：铃木拓磨（动画人）、熨斗谷充孝、室谷靖、佐土原武之 ","date":"2014-10-05","objectID":"/anime/sora_no_method/:1:0","tags":null,"title":"天体的秩序","uri":"/anime/sora_no_method/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 古宫乃乃香 こみやののか、Komiya Nonoka、BB香 女 夏川椎菜 2 诺艾尔 Noel、ノエル 女 水瀬いのり 3 户川汐音 とがわ しおね、Togawa Shione 女 小松未可子 4 水坂柚季 みずさかゆずき、Mizusaka Yuzuki 女 豊崎愛生 5 椎原小春 椎原 こはる、しいはらこはる、Shiihara Koharu 女 佳村はるか 6 水坂凑太 みずさかそうた、Mizusaka Yuuta 男 潘めぐみ 7 古宫修一 こみやしゅういち、Komiya Shuuichi 男 土田大 8 古宫花织 こみやしゅ かおり、Komiya K","date":"2014-10-05","objectID":"/anime/sora_no_method/:2:0","tags":null,"title":"天体的秩序","uri":"/anime/sora_no_method/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天体的秩序 2014-10-05 13 bilibili ","date":"2014-10-05","objectID":"/anime/sora_no_method/:3:0","tags":null,"title":"天体的秩序","uri":"/anime/sora_no_method/"},{"categories":null,"content":"MAD ","date":"2014-10-05","objectID":"/anime/sora_no_method/:4:0","tags":null,"title":"天体的秩序","uri":"/anime/sora_no_method/"},{"categories":null,"content":"有个宅男老公也许也是一件挺有趣的事吧？\n热心于工作的OL“薰”是个普通人，而她的老公则是沉迷于某大型网路留言版的阿宅，两人的虽然彼此都有不太合得来的部分但是仍然过得很恩爱的新婚生活。\n于是故事就围绕着这样的夫妻二人的日常展开。","date":"2014-10-02","objectID":"/anime/danna_ga_nani/","tags":null,"title":"关于完全听不懂老公在说什么的事","uri":"/anime/danna_ga_nani/"},{"categories":null,"content":"简介 有个宅男老公也许也是一件挺有趣的事吧？ 热心于工作的OL“薰”是个普通人，而她的老公则是沉迷于某大型网路留言版的阿宅，两人的虽然彼此都有不太合得来的部分但是仍然过得很恩爱的新婚生活。 于是故事就围绕着这样的夫妻二人的日常展开。 制作人员： 原作：酷教信徒 导演：永居慎平 分镜：北村淳一、三浦三郎、伊魔崎斋 ","date":"2014-10-02","objectID":"/anime/danna_ga_nani/:1:0","tags":null,"title":"关于完全听不懂老公在说什么的事","uri":"/anime/danna_ga_nani/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 薰 佐村薰、十薰、十カオル 女 田村ゆかり 2 一 志贵、Tsunashi Hajime、十一（つなし はじめ） 男 鈴村健一 3 树濑理乃 じゅせ リノ 女 釘宮理恵 4 蛋黄蛋 阳太、十陽太（ようた） 男 堀野紗也加 5 田中 女 新谷良子 6 三木 デスティニーファッカー（Destiny Fucker） 男 清水香里 7 树濑望 男 坂井俊文 8 山田 男 外崎大輔 ","date":"2014-10-02","objectID":"/anime/danna_ga_nani/:2:0","tags":null,"title":"关于完全听不懂老公在说什么的事","uri":"/anime/danna_ga_nani/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 关于完全听不懂老公在说什么的事 2014-10-02 13 bilibili 2 关于完全听不懂老公在说什么的事 第二季 2015-04-02 13 bilibili ","date":"2014-10-02","objectID":"/anime/danna_ga_nani/:3:0","tags":null,"title":"关于完全听不懂老公在说什么的事","uri":"/anime/danna_ga_nani/"},{"categories":null,"content":"　　故事背景设置在了现代社会，是有关于一个塞尔奇小精灵的民间传说，她是最后一个拥有着海豹外貌却能化为人形的生物，尝试着想要重新回到大海里——那是一个童话世界即将终结的时间点，所有只存在于民间传说中的生物全部在现代社会的影响下，愈加地堕落、腐败，他们根本就不想回去，可小精灵的歌声却是让他们回归的惟一办法…… \n　　一个有点悲伤的故事，却以一种非常美好的方式呈现出来。 ","date":"2014-09-06","objectID":"/anime/song_of_the_sea/","tags":null,"title":"海洋之歌","uri":"/anime/song_of_the_sea/"},{"categories":null,"content":"简介 故事背景设置在了现代社会，是有关于一个塞尔奇小精灵的民间传说，她是最后一个拥有着海豹外貌却能化为人形的生物，尝试着想要重新回到大海里——那是一个童话世界即将终结的时间点，所有只存在于民间传说中的生物全部在现代社会的影响下，愈加地堕落、腐败，他们根本就不想回去，可小精灵的歌声却是让他们回归的惟一办法…… 一个有点悲伤的故事，却以一种非常美好的方式呈现出来。 制作人员： 导演：汤姆·摩尔 音乐：布鲁诺·库莱斯 动画制作：卡通沙龙 ","date":"2014-09-06","objectID":"/anime/song_of_the_sea/:1:0","tags":null,"title":"海洋之歌","uri":"/anime/song_of_the_sea/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海洋之歌 2014-09-06 1 樱花 ","date":"2014-09-06","objectID":"/anime/song_of_the_sea/:2:0","tags":null,"title":"海洋之歌","uri":"/anime/song_of_the_sea/"},{"categories":null,"content":"原本宁静的阿尔特里亚大陆，被黑龙及其魔物追随者的势力所席卷。乱世下，民不聊生。\n绰号小鱼的兰伯特，是生活在小村庄里的普通少年，却为了保护村庄，在误打误撞中作为小跟班加入了为讨伐黑龙而建立的英雄联盟。这支由精灵、魔法师、游侠和传奇战士组成的临时杂牌联盟，踏上了失落已久的古道，翻越诡异的丛林和奇幻的雪山寻觅黑龙的巢穴。可前方，却有意想不到的危机等着他们的到来。\n　　旅程的艰辛和奇异的境遇让兰伯特迅速成长起来，可他最终能找到属于自己的战斗的意义吗？","date":"2014-07-31","objectID":"/anime/dragon_nest/","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"简介 原本宁静的阿尔特里亚大陆，被黑龙及其魔物追随者的势力所席卷。乱世下，民不聊生。 绰号小鱼的兰伯特，是生活在小村庄里的普通少年，却为了保护村庄，在误打误撞中作为小跟班加入了为讨伐黑龙而建立的英雄联盟。这支由精灵、魔法师、游侠和传奇战士组成的临时杂牌联盟，踏上了失落已久的古道，翻越诡异的丛林和奇幻的雪山寻觅黑龙的巢穴。可前方，却有意想不到的危机等着他们的到来。 旅程的艰辛和奇异的境遇让兰伯特迅速成长起来，可他最终能找到属于自己的战斗的意义吗？ 制作人员： 动画制作：苏州米粒影视文化传播有限公司 制作协力：盛趣游戏 ","date":"2014-07-31","objectID":"/anime/dragon_nest/:1:0","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 莉雅 Liya 女 徐娇 ","date":"2014-07-31","objectID":"/anime/dragon_nest/:2:0","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙之谷：破晓奇兵 2014-07-31 1 bilibili 2 精灵王座 2016-08-19 1 樱花 ","date":"2014-07-31","objectID":"/anime/dragon_nest/:3:0","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"MAD ","date":"2014-07-31","objectID":"/anime/dragon_nest/:4:0","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"海边村庄的老夫妇收养了一个内向的女主人公安娜。少女安娜内心封闭，终日在村中孤独的生活。某一天安娜遇到了神秘少女玛妮，并与她成为了好朋友。然而村中除了安娜，谁都不知道玛妮的存在。\n","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"简介 海边村庄的老夫妇收养了一个内向的女主人公安娜。少女安娜内心封闭，终日在村中孤独的生活。某一天安娜遇到了神秘少女玛妮，并与她成为了好朋友。然而村中除了安娜，谁都不知道玛妮的存在。 制作人员： 原作：Joan Gale Robinson 导演：米林宏昌 脚本：安藤雅司、丹羽圭子 音乐：村松崇继 美术监督：种田阳平 作画监督：稻村武志 ","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/:1:0","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐佐木杏奈 ささき あんな、Sasaki Anna 女 高月彩良 2 玛妮 Marnie、マーニー、Mānī 女 有村架純 ","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/:2:0","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 回忆中的玛妮 2014-07-19 1 樱花 ","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/:3:0","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"MAD ","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/:4:0","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"讨厌念书，对日本史毫无兴趣的高中生三郎，某一天突然时光穿越到了战国时代。他在那里见到体弱多病的织田信长本人，而信长的相貌竟然与三郎一模一样。信长拜托三郎代替体弱多病自己，以织田信长的身分活下去…！？用全新的手法诠释出来的织田信长，叫人出乎意料之外却又莫名地符合信长形象的三郎。对历史发展可说是毫无头绪的他，在战国时代会如何生存下去？","date":"2014-07-11","objectID":"/anime/oda_nobunaga_concerto/","tags":null,"title":"信长协奏曲","uri":"/anime/oda_nobunaga_concerto/"},{"categories":null,"content":"简介 讨厌念书，对日本史毫无兴趣的高中生三郎，某一天突然时光穿越到了战国时代。他在那里见到体弱多病的织田信长本人，而信长的相貌竟然与三郎一模一样。信长拜托三郎代替体弱多病自己，以织田信长的身分活下去…！？用全新的手法诠释出来的织田信长，叫人出乎意料之外却又莫名地符合信长形象的三郎。对历史发展可说是毫无头绪的他，在战国时代会如何生存下去？ 制作人员： 原作：石井步 导演：富士川佑辅 脚本：高桥奈津子 分镜：森田纯平 音乐：横山克 ","date":"2014-07-11","objectID":"/anime/oda_nobunaga_concerto/:1:0","tags":null,"title":"信长协奏曲","uri":"/anime/oda_nobunaga_concerto/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 三郎 男 宮野真守 2 织田信长 男 梶裕貴 3 归蝶 女 水樹奈々 4 木下藤吉郎 田原伝二郎、木下秀吉、羽柴秀吉 男 中村悠一 5 阿市 女 悠木碧 6 池田恒兴 男 興津和幸 7 柴田胜家 男 小山力也 8 前田利家 男 浅沼晋太郎 ","date":"2014-07-11","objectID":"/anime/oda_nobunaga_concerto/:2:0","tags":null,"title":"信长协奏曲","uri":"/anime/oda_nobunaga_concerto/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 信长协奏曲 2014-07-11 10 bilibili ","date":"2014-07-11","objectID":"/anime/oda_nobunaga_concerto/:3:0","tags":null,"title":"信长协奏曲","uri":"/anime/oda_nobunaga_concerto/"},{"categories":null,"content":"某个平凡的夏日。\n突然，东京遭到了大规模炸弹恐怖袭击。\n这个导致日本从平稳的睡梦中惊醒的事件的犯人，仅仅是两个少年。\n自称为“斯芬克斯”的犯人们，将把全日本卷中一场壮大的游戏。","date":"2014-07-10","objectID":"/anime/terror_in_resonance/","tags":null,"title":"东京残响","uri":"/anime/terror_in_resonance/"},{"categories":null,"content":"简介 某个平凡的夏日。 突然，东京遭到了大规模炸弹恐怖袭击。 这个导致日本从平稳的睡梦中惊醒的事件的犯人，仅仅是两个少年。 自称为“斯芬克斯”的犯人们，将把全日本卷中一场壮大的游戏。 制作人员： 导演：渡边信一郎 脚本：熊谷纯、猪原健太、濑古浩司、矢野焦点 分镜：三原三千夫、宫繁之、鹿间贵裕、青井小夜 ","date":"2014-07-10","objectID":"/anime/terror_in_resonance/:1:0","tags":null,"title":"东京残响","uri":"/anime/terror_in_resonance/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 ナイン Nine、九重 新、ここのえ あらた、Kokonoe Arata 男 石川界人 2 ツエルブ Twelve、久見冬二、ひさみ とうじ、Hisami Tōji 男 斉藤壮馬 3 三岛理沙 Lisa、みしま りさ、Mishima Risa 女 種﨑敦美 4 柴崎健次郎 しばざき けんじろう、Shibazaki Kenjirou 男 咲野俊介 5 ハイヴ Five 女 潘めぐみ 6 仓桥 くらはし、Kurahashi 男 手塚秀彰 7 羽村 はねむら、Hamura 男 逢笠恵祐 8 冈野 おかの、Okano 男 坂本くんぺい ","date":"2014-07-10","objectID":"/anime/terror_in_resonance/:2:0","tags":null,"title":"东京残响","uri":"/anime/terror_in_resonance/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 东京残响 2014-07-10 11 樱花 ","date":"2014-07-10","objectID":"/anime/terror_in_resonance/:3:0","tags":null,"title":"东京残响","uri":"/anime/terror_in_resonance/"},{"categories":null,"content":"高中女生佐仓千代好不容易提起勇气向同年级的野崎梅太郎告白，得到的却是野崎的亲笔签名，和“要不要来我家？”的邀请。佐仓虽然对意料之外的展开感到困惑，却还是带着期待来到野崎家，没想到等着她的却是漫画原稿，不知不觉间就顺着野崎的指示开始进行涂黑作业。到这时佐仓才发现野崎是知名少女漫画家梦野咲子。","date":"2014-07-06","objectID":"/anime/monthly_girls/","tags":null,"title":"月刊少女野崎君","uri":"/anime/monthly_girls/"},{"categories":null,"content":"简介 高中女生佐仓千代好不容易提起勇气向同年级的野崎梅太郎告白，得到的却是野崎的亲笔签名，和“要不要来我家？”的邀请。佐仓虽然对意料之外的展开感到困惑，却还是带着期待来到野崎家，没想到等着她的却是漫画原稿，不知不觉间就顺着野崎的指示开始进行涂黑作业。到这时佐仓才发现野崎是知名少女漫画家梦野咲子。 制作人员： 原作：椿泉 导演：山崎光惠 脚本：中村能子 分镜：吉川博明、渡部稳宽、竹下良平、齐藤哲人、山崎理 ","date":"2014-07-06","objectID":"/anime/monthly_girls/:1:0","tags":null,"title":"月刊少女野崎君","uri":"/anime/monthly_girls/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 野崎梅太郎 夢野咲子、梦野咲子、野崎 梅太郎、のざき　うめたろう、Nozaki Umetarō 男 中村悠一 2 佐仓千代 さくら ちよ、Sakura Chiyo 女 小澤亜李 3 御子柴实琴 小御子、みこしば みこと、Mikoshiba Mikoto、みこりん 男 岡本信彦 4 堀政行 ほり まさゆき、Hori Masayuki 男 小野友樹 5 鹿岛游 かしま ゆう、Kashima Yu 女 中原麻衣 6 若松博隆 わかまつ ひろたか、Wakamatsu Hirotaka 男 木村良平 7 濑尾结月 せお ゆづき、Seo Yuzuki 女 沢城みゆき 8","date":"2014-07-06","objectID":"/anime/monthly_girls/:2:0","tags":null,"title":"月刊少女野崎君","uri":"/anime/monthly_girls/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 月刊少女野崎君 2014-07-06 12 bilibili ","date":"2014-07-06","objectID":"/anime/monthly_girls/:3:0","tags":null,"title":"月刊少女野崎君","uri":"/anime/monthly_girls/"},{"categories":null,"content":"MAD ","date":"2014-07-06","objectID":"/anime/monthly_girls/:4:0","tags":null,"title":"月刊少女野崎君","uri":"/anime/monthly_girls/"},{"categories":null,"content":"这部动画片根据卡里·纪伯伦的同名作品改编，每一部分由不同导演执导，其中包括《狮子王》导演罗杰·阿勒斯和《海洋之歌》导演汤姆·摩尔，声优云集连姆·尼森、塞尔玛·海耶克、奎文赞妮·瓦利斯等。","date":"2014-05-17","objectID":"/anime/the_prophet/","tags":null,"title":"先知","uri":"/anime/the_prophet/"},{"categories":null,"content":"简介 这部动画片根据卡里·纪伯伦的同名作品改编，每一部分由不同导演执导，其中包括《狮子王》导演罗杰·阿勒斯和《海洋之歌》导演汤姆·摩尔，声优云集连姆·尼森、塞尔玛·海耶克、奎文赞妮·瓦利斯等。 ","date":"2014-05-17","objectID":"/anime/the_prophet/:1:0","tags":null,"title":"先知","uri":"/anime/the_prophet/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 先知 2014-05-17 1 樱花 ","date":"2014-05-17","objectID":"/anime/the_prophet/:2:0","tags":null,"title":"先知","uri":"/anime/the_prophet/"},{"categories":null,"content":"时已入春，已经进入高中三年级的北白川玉子仍然总是想着打糕的事情。\n春天傍晚的放学路上，玉子好友四人组谈论着关于将来出路的事情。大家虽然对此感到不安，但似乎对将来的事情都有好好地考虑过。玉子也无意中说出自己将来想要继承家业。\n同时，住在玉子家的对面、一直和她在一起的饼藏，也下定了某种决心。\n周围的各种事物都在逐渐改变着，一点一点地动摇着玉子的心。","date":"2014-04-26","objectID":"/anime/tamako_love_story/","tags":null,"title":"玉子爱情故事","uri":"/anime/tamako_love_story/"},{"categories":null,"content":"简介 时已入春，已经进入高中三年级的北白川玉子仍然总是想着打糕的事情。 春天傍晚的放学路上，玉子好友四人组谈论着关于将来出路的事情。大家虽然对此感到不安，但似乎对将来的事情都有好好地考虑过。玉子也无意中说出自己将来想要继承家业。 同时，住在玉子家的对面、一直和她在一起的饼藏，也下定了某种决心。 周围的各种事物都在逐渐改变着，一点一点地动摇着玉子的心。 制作人员： 原作：京都动画 导演：山田尚子 脚本：吉田玲子 分镜：石原立也 演出：河浪荣作、小川太一 ","date":"2014-04-26","objectID":"/anime/tamako_love_story/:1:0","tags":null,"title":"玉子爱情故事","uri":"/anime/tamako_love_story/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 北白川玉子 きたしらかわ たまこ、Kitashirakawa Tamako 女 洲崎綾 2 大路饼藏 おおじ もちぞう、ooji mochizou 男 升望 3 常盘绿 ときわ みどり、Tokiwa Midori 女 金子有希 4 牧野神奈 まきの かんな、makino kanna 女 長妻樹里 5 朝雾史织 あさぎり しおり、Asagiri Siori 女 山下百合恵 6 北白川馅子 北白川杏子、Kitashirakawa Anko、きたしらかわ あんこ 女 日高里菜 7 北白川豆大 きたしらかわ まめだい、Kirasirakawa Mamedai 男 藤","date":"2014-04-26","objectID":"/anime/tamako_love_story/:2:0","tags":null,"title":"玉子爱情故事","uri":"/anime/tamako_love_story/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 玉子爱情故事 2014-04-26 01:23:52 bilibili ","date":"2014-04-26","objectID":"/anime/tamako_love_story/:3:0","tags":null,"title":"玉子爱情故事","uri":"/anime/tamako_love_story/"},{"categories":null,"content":"MAD ","date":"2014-04-26","objectID":"/anime/tamako_love_story/:4:0","tags":null,"title":"玉子爱情故事","uri":"/anime/tamako_love_story/"},{"categories":null,"content":"星野裕（阿扁）是乒乓球天才，月本诚（笑匠）则是极具天赋的乒乓球好手。他们俩从小一起长大，同为片濑高中乒乓球队队员。在高校联赛中，遇上来自中国上海的孔文革、上届冠军风间龙一，关于乒乓联赛的成长的故事拉开序幕……","date":"2014-04-10","objectID":"/anime/ping_pong/","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"简介 星野裕（阿扁）是乒乓球天才，月本诚（笑匠）则是极具天赋的乒乓球好手。他们俩从小一起长大，同为片濑高中乒乓球队队员。在高校联赛中，遇上来自中国上海的孔文革、上届冠军风间龙一，关于乒乓联赛的成长的故事拉开序幕…… 制作人员： 原作：松本大洋 导演：汤浅政明 演出：上野史博、伊藤良太、伊藤秀树、久保田雄大 ","date":"2014-04-10","objectID":"/anime/ping_pong/:1:0","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 星野裕 阿扁、ほしの ゆたか、Hoshino Yutaka、ペコ 男 片山福十郎 2 月本诚 笑爷、つきもと　まこと、Tsukimoto　Makoto、スマイル 男 内山昂輝 3 孔文革 コン・ウエンガ、チャイナ、辻堂文革 男 文晔星 4 佐久间学 さくま　まなぶ、Sakuma　Manabu、アクマ 男 木村昴 5 风间龙一 かざま　りゅういち、Kazama　Ryūichi、ドラゴン 男 咲野俊介 6 小泉丈 こいずみ じょう、バタフライジョー 男 屋良有作 7 田村 たむら、Tamura、オババ 女 野沢雅子 8 孔的教练 男 程波 ","date":"2014-04-10","objectID":"/anime/ping_pong/:2:0","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 乒乓 2014-04-10 11 bilibili ","date":"2014-04-10","objectID":"/anime/ping_pong/:3:0","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"MAD ","date":"2014-04-10","objectID":"/anime/ping_pong/:4:0","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"为了便于上高中，高中入学新生心爱准备搬来这由石板路、木制房组成的街道。她在寻找寄宿的地点时迷路了，迷茫之中来到了一家名为“rabbit house”的咖啡店门前。看到这间名字都充满小兔风格的可爱咖啡店，心爱忍不住踏进了店门。在店里，她遇见了娇小的少女智乃，以及一只软乎乎的可爱小兔子提比。\n心爱一边喝着咖啡一边询问路线时，才惊讶的得知这家咖啡店就是自己将要寄宿的地方。因为心爱将要入学的高中有着“学生要在寄宿的家里帮忙做事”的规定，心爱便开始当起了“rabbit house”的店员，并“自称”是智乃的姐姐，一边过起了咖啡店员的生活。","date":"2014-04-10","objectID":"/anime/is_the_order_a_rabbit/","tags":null,"title":"请问您今天要来点兔子吗？","uri":"/anime/is_the_order_a_rabbit/"},{"categories":null,"content":"简介 为了便于上高中，高中入学新生心爱准备搬来这由石板路、木制房组成的街道。她在寻找寄宿的地点时迷路了，迷茫之中来到了一家名为“rabbit house”的咖啡店门前。看到这间名字都充满小兔风格的可爱咖啡店，心爱忍不住踏进了店门。在店里，她遇见了娇小的少女智乃，以及一只软乎乎的可爱小兔子提比。 心爱一边喝着咖啡一边询问路线时，才惊讶的得知这家咖啡店就是自己将要寄宿的地方。因为心爱将要入学的高中有着“学生要在寄宿的家里帮忙做事”的规定，心爱便开始当起了“rabbit house”的店员，并“自称”是智乃的姐姐，一边过起了咖啡店员的生活。 制作人员： 原作：Koi 导演：桥本裕之 脚本：井上美绪、","date":"2014-04-10","objectID":"/anime/is_the_order_a_rabbit/:1:0","tags":null,"title":"请问您今天要来点兔子吗？","uri":"/anime/is_the_order_a_rabbit/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 保登心爱 ココア、Cocoa、ほと ここあ、Hoto Kokoa 女 佐倉綾音 2 香风智乃 チノ、Chino、かふう ちの、Kafuu Chino 女 水瀬いのり 3 天天座理世 リゼ、Rize、天々座 理世、てでざ りぜ、Tedeza Rize 女 種田梨沙 4 宇治松千夜 鬼畜和菓子、千夜、Chiya、うじまつ ちや、Ujimatsu Chiya 女 佐藤聡美 5 桐间纱路 シャロ、Syaro、きりま しゃろ、Kirima Sharo 女 内田真礼 6 条河麻耶 条河 麻耶、じょうが まや、Jyōga Maya、マヤ 女 徳井青空 7 奈津惠 奈津 恵","date":"2014-04-10","objectID":"/anime/is_the_order_a_rabbit/:2:0","tags":null,"title":"请问您今天要来点兔子吗？","uri":"/anime/is_the_order_a_rabbit/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 请问您今天要来点兔子吗？ 2014-04-10 12 bilibili 2 请问您今天要来点兔子吗？？ 2015-10-10 12 bilibili 3 请问您今天要来点兔子吗？？～Dear My Sister～ 2017-11-11 1 bilibili 4 请问您今天要来点兔子吗？？～Sing for You～ 2019-09-26 1 bilibili 5 请问您今天要来点兔子吗？BLOOM 2020-10-10 12 bilibili ","date":"2014-04-10","objectID":"/anime/is_the_order_a_rabbit/:3:0","tags":null,"title":"请问您今天要来点兔子吗？","uri":"/anime/is_the_order_a_rabbit/"},{"categories":null,"content":"被无法与人类沟通的异生物·奇居子破坏的太阳系，只剩下一小部分的人类尚存活。他们为了生存制作了如同小行星本巨大的宇宙播种船希德尼娅，并在宇宙中进行旅行。\n经过了1000年后，时值希德尼娅出航纪元1009年，由地下层部培育的少年谷风长道自祖父死后而来到上层市区。并入学巨大人型兵器「卫人」的操控师训练学校，这也是谷风长道首次与外界人接触。\n令谷风长道首次抱有异性意识的女性是——星白闲。\n谷风长道首次的友人是无性别的科戸濑伊佐奈。\n令谷风长道意识到挫折的少年是——岐神海苔夫。\n在和各式各样的训练师一同度过校园生活的谷风长道，获得了首次的任务。虽然不是非常艰难的任务，但在谷风长道和队友们面前，突然出现了奇居子！遭遇沉寂了100年后的突袭，作为人类的谷风长道将如何抉择？\n关乎人类存亡的战斗现在开始了！……","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"简介 被无法与人类沟通的异生物·奇居子破坏的太阳系，只剩下一小部分的人类尚存活。他们为了生存制作了如同小行星本巨大的宇宙播种船希德尼娅，并在宇宙中进行旅行。 经过了1000年后，时值希德尼娅出航纪元1009年，由地下层部培育的少年谷风长道自祖父死后而来到上层市区。并入学巨大人型兵器「卫人」的操控师训练学校，这也是谷风长道首次与外界人接触。 令谷风长道首次抱有异性意识的女性是——星白闲。 谷风长道首次的友人是无性别的科戸濑伊佐奈。 令谷风长道意识到挫折的少年是——岐神海苔夫。 在和各式各样的训练师一同度过校园生活的谷风长道，获得了首次的任务。虽然不是非常艰难的任务，但在谷风长道和队友们面前，突然","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/:1:0","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 谷风长道 谷風 長道、たにかぜ ながて、Tanikaze Nagate 男 逢坂良太 2 星白闲 星白 閑、ほしじろ しずか、Hoshijiro Shizuka 女 洲崎綾 3 科户濑伊扎那 科戸瀬 イザナ、しなとせ いざな、Shinatose Izana 中性 豊崎愛生 4 崎神海苔夫 岐神海苔夫、くなと のりお、Kunato Norio ♂ 櫻井孝宏 5 绿川缬 緑川 纈、みどりかわ ゆはた、Midorikawa Yuhata 金元寿子 6 小林艦長 小林艦長、こばやし　かんじょう ♀ 大原さやか 7 仄姉妹 仄　姉妹 喜多村英梨 8 莎玛莉·伊丹 沙万","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/:2:0","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 希德尼娅的骑士 2014-04-10 12 bilibili 2 希德尼娅的骑士 第九惑星战役 2015-04-10 12 bilibili 3 希德尼娅的骑士 编织爱的行星 2021-06-04 1 樱花 ","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/:3:0","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"MAD ","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/:4:0","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"“听说游戏玩家兄妹要征服幻想世界”空与白既是尼特族又是家里蹲，但是在网路上却是被奉为都市传说的天才游戏玩家兄妹。称世界为「烂游戏」的两人，某一天被自称是“神”的少年召唤至异世界，那是个战争为神所禁止，“游戏决定一切”的世界──没错，甚至连国界也一样。\n被其他种族逼至绝境，只剩下最后都市的『人类种』，空与白这两个废人兄妹能够成为异世界的『人类救世主』吗？“──来吧，游戏开始了。”","date":"2014-04-09","objectID":"/anime/no_game_no_life/","tags":null,"title":"NO GAME NO LIFE 游戏人生","uri":"/anime/no_game_no_life/"},{"categories":null,"content":"简介 “听说游戏玩家兄妹要征服幻想世界”空与白既是尼特族又是家里蹲，但是在网路上却是被奉为都市传说的天才游戏玩家兄妹。称世界为「烂游戏」的两人，某一天被自称是“神”的少年召唤至异世界，那是个战争为神所禁止，“游戏决定一切”的世界──没错，甚至连国界也一样。 被其他种族逼至绝境，只剩下最后都市的『人类种』，空与白这两个废人兄妹能够成为异世界的『人类救世主』吗？“──来吧，游戏开始了。” 制作人员： 原作：榎宫祐 导演：石塚敦子 脚本：下山健人、青岛崇、花田十辉 分镜：佐山圣子、薮田修平 ","date":"2014-04-09","objectID":"/anime/no_game_no_life/:1:0","tags":null,"title":"NO GAME NO LIFE 游戏人生","uri":"/anime/no_game_no_life/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 空 そら、Sora 男 松岡禎丞 2 白 しろ、Shiro 女 茅野愛衣 3 史蒂芬妮·多拉 女 日笠陽子 4 吉普莉尔 女 田村ゆかり 5 克拉米 女 井口裕香 6 菲尔·尼尔巴连 女 能登麻美子 7 特图 Tet、teto 釘宮理恵 8 初濑伊纲 いづな 女 沢城みゆき ","date":"2014-04-09","objectID":"/anime/no_game_no_life/:2:0","tags":null,"title":"NO GAME NO LIFE 游戏人生","uri":"/anime/no_game_no_life/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 NO GAME NO LIFE 游戏人生 2014-04-09 12 bilibili 2 NO GAME NO LIFE 游戏人生 ZERO 2017-07-15 1 樱花 MAD ","date":"2014-04-09","objectID":"/anime/no_game_no_life/:3:0","tags":null,"title":"NO GAME NO LIFE 游戏人生","uri":"/anime/no_game_no_life/"},{"categories":null,"content":"于战乱后的菲尔毕斯特大陆流浪的乱破师——托鲁·亚裘拉，因为失去了乱破师的生存目的，而每天过着庸庸碌碌，并被妹妹阿卡莉责备的生活。某日，在托鲁前往山中的时候，与谜之少女嘉依卡相遇了……","date":"2014-04-09","objectID":"/anime/chaika/","tags":null,"title":"棺姬嘉依卡","uri":"/anime/chaika/"},{"categories":null,"content":"简介 于战乱后的菲尔毕斯特大陆流浪的乱破师——托鲁·亚裘拉，因为失去了乱破师的生存目的，而每天过着庸庸碌碌，并被妹妹阿卡莉责备的生活。某日，在托鲁前往山中的时候，与谜之少女嘉依卡相遇了…… 制作人员： 原作：榊一郎 导演：增井壮一 脚本：土屋理敬、待田堂子 分镜：塚田拓郎、小林孝志、大桥誉志光、寺冈岩 ","date":"2014-04-09","objectID":"/anime/chaika/:1:0","tags":null,"title":"棺姬嘉依卡","uri":"/anime/chaika/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 托鲁·亚裘拉 男 間島淳司 2 嘉依卡·托勒庞特 Chaika Trabant、柴卡 女 安済知佳 3 阿卡莉·亚裘拉 女 原優子 4 亚伯力克·基烈特 男 細谷佳正 5 芙蕾多妮卡 女 斎藤千和 6 ニコライ・アフトトル 男 佐藤健輔 7 薇薇 女 野水伊織 8 芷依塔·布鲁萨斯可 女 幸田夢波 ","date":"2014-04-09","objectID":"/anime/chaika/:2:0","tags":null,"title":"棺姬嘉依卡","uri":"/anime/chaika/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 棺姬嘉依卡 2014-04-09 12 樱花 2 棺姬嘉依卡 AVENGING BATTLE 2014-10-08 10 樱花 ","date":"2014-04-09","objectID":"/anime/chaika/:3:0","tags":null,"title":"棺姬嘉依卡","uri":"/anime/chaika/"},{"categories":null,"content":"「但是，我…关于朋友的记忆，一周就会消失呢—」一直都是一个人的同班同学藤宫香织所述的事实。主人公长谷祐树，即使是这样也想和香织成为朋友。一周的记忆开始又结束，两个人不断成为朋友。一次又一次—。对于你，我永远都是你的朋友。然后，总有一天能告诉你，我是你的朋友。 ","date":"2014-04-06","objectID":"/anime/one_week_friends/","tags":null,"title":"一周的朋友。","uri":"/anime/one_week_friends/"},{"categories":null,"content":"简介 「但是，我…关于朋友的记忆，一周就会消失呢—」一直都是一个人的同班同学藤宫香织所述的事实。主人公长谷祐树，即使是这样也想和香织成为朋友。一周的记忆开始又结束，两个人不断成为朋友。一次又一次—。对于你，我永远都是你的朋友。然后，总有一天能告诉你，我是你的朋友。 制作人员： 原作：叶月抹茶 导演：岩崎太郎 脚本：国泽真理子、清水惠、菅正太郎 分镜：今挂勇、中川聪、小柴纯弥 ","date":"2014-04-06","objectID":"/anime/one_week_friends/:1:0","tags":null,"title":"一周的朋友。","uri":"/anime/one_week_friends/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 长谷祐树 長谷 祐樹、はせ ゆうき、Hase Yūki 男 山谷祥生 2 藤宫香织 藤宮 香織、ふじみや かおり、Fujimiya Kaori 雨宮天 3 山岸沙希 山岸 沙希、やまぎし さき、Yamagishi Saki、沙希 女 大久保瑠美 4 桐生将吾 桐生 将吾、きりゅう しょうご、Kiryū Syougo、将吾 男 細谷佳正 5 藤宫志穗 藤宮 志穂、ふじみや しほ 女 中原麻衣 6 井上润 井上 潤、いのうえ じゅん 男 間島淳司 7 九条一 九条 一、くじょう はじめ、Kujyou Hajime 男 浅沼晋太郎 8 芹泽舞子 Maiko Ser","date":"2014-04-06","objectID":"/anime/one_week_friends/:2:0","tags":null,"title":"一周的朋友。","uri":"/anime/one_week_friends/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 一周的朋友。 2014-04-06 12 bilibili ","date":"2014-04-06","objectID":"/anime/one_week_friends/:3:0","tags":null,"title":"一周的朋友。","uri":"/anime/one_week_friends/"},{"categories":null,"content":"MAD ","date":"2014-04-06","objectID":"/anime/one_week_friends/:4:0","tags":null,"title":"一周的朋友。","uri":"/anime/one_week_friends/"},{"categories":null,"content":"故事发生在二十一世纪末的日本。魔法，这不是一个传说，而是现代科学的一项技术。它被应用至今已经过了一个世纪。曾经被称为「超能力」的先天具有的能力被以“魔法”这个名字的体系替代，高超的的魔法师被认为是国家的实力。西历 2095 年的春天，新生入学的季节。国立魔法大学附属第一高校——通称“魔法科高校”，是由成绩优秀的“一科生”，和作为一科生替补的“二科生”所构成，他们也各自被冠上了“花冠（bloom）”，以及“杂草（weed）”之名。就在这样的魔法科高校里，一对兄妹入学了。\n兄长是，拥有着缺陷的劣等生。\n妹妹是，完美无缺的的优等生。\n无论什么事都抱着乐观态度的劣等生兄长，和对他抱着作为血亲以上感情的优等生妹妹。随着这两人进入这间精英学校的大门，这平稳的学院，也开始了骚乱的日常。","date":"2014-04-05","objectID":"/anime/the_irregular_at_magic_high_school/","tags":null,"title":"魔法科高校的劣等生","uri":"/anime/the_irregular_at_magic_high_school/"},{"categories":null,"content":"简介 故事发生在二十一世纪末的日本。魔法，这不是一个传说，而是现代科学的一项技术。它被应用至今已经过了一个世纪。曾经被称为「超能力」的先天具有的能力被以“魔法”这个名字的体系替代，高超的的魔法师被认为是国家的实力。西历 2095 年的春天，新生入学的季节。国立魔法大学附属第一高校——通称“魔法科高校”，是由成绩优秀的“一科生”，和作为一科生替补的“二科生”所构成，他们也各自被冠上了“花冠（bloom）”，以及“杂草（weed）”之名。就在这样的魔法科高校里，一对兄妹入学了。 兄长是，拥有着缺陷的劣等生。 妹妹是，完美无缺的的优等生。 无论什么事都抱着乐观态度的劣等生兄长，和对他抱着作为血亲以上","date":"2014-04-05","objectID":"/anime/the_irregular_at_magic_high_school/:1:0","tags":null,"title":"魔法科高校的劣等生","uri":"/anime/the_irregular_at_magic_high_school/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 司波达也 司波 達也、しば たつや、Shiba Tatsuya、司波大爷 男 中村悠一 2 司波深雪 司波 深雪、しば みゆき、Shiba Miyuki 女 早見沙織 3 千叶艾莉卡 千叶艾丽卡、千葉 エリカ、ちば えりか、Chiba Erika 女 内山夕実 4 西城雷欧赫特 さいじょう れおんはると 男 寺島拓篤 5 柴田美月 しばた みづき、Shibata Mizuki 女 佐藤聡美 6 吉田干比古 よしだ みきひこ、Yoshida Mikihiko 男 田丸篤志 7 光井穗香 光井穗乃香、光井 ほのか、みつい ほのか、Mitsui Honoka 女 ","date":"2014-04-05","objectID":"/anime/the_irregular_at_magic_high_school/:2:0","tags":null,"title":"魔法科高校的劣等生","uri":"/anime/the_irregular_at_magic_high_school/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔法科高校的劣等生 2014-04-05 26 樱花 2 魔法科高校的劣等生 来访者篇 2020-10-03 13 樱花 3 魔法科高校的劣等生 追忆篇 2021-12-31 1 樱花 ","date":"2014-04-05","objectID":"/anime/the_irregular_at_magic_high_school/:3:0","tags":null,"title":"魔法科高校的劣等生","uri":"/anime/the_irregular_at_magic_high_school/"},{"categories":null,"content":"　　艾米特（克里斯·帕拉特 Chris Pratt 配音）是乐高世界中一个普通到没有任何存在感的建筑师，他每天精神饱满，乐观向上，按照说明书的指示从事一天的活动。某天收工后，他意外掉入一个深洞，后背还黏了奇怪的东西，随后就被兼具凶暴和善良两面的警察（利亚姆·尼森 Liam Neeson 配音）带走问话。原来统治乐高世界的总裁（威尔·法瑞尔 Will Ferrell 配音）对那些极富创造力的小人极为不满，他讨厌不同系列的乐高世界相互交叉，更讨厌脱离了说明书独辟蹊径的发明创造。因此他将所有世界隔开，囚禁了那些创意大师，还策划着一场可怕的阴谋。艾米特危机时刻被露西（伊丽莎白·班克斯 Elizabeth Banks 配音），并被先知维特鲁维斯（摩根·弗里曼 Morgan Freeman 配音）认定为救世主。 \n　　暴风雨般的迫害袭向创意大师们，想象力贫乏的艾米特能否担此重任？","date":"2014-02-07","objectID":"/anime/the_lego_movie/","tags":null,"title":"乐高大电影","uri":"/anime/the_lego_movie/"},{"categories":null,"content":"简介 艾米特（克里斯·帕拉特 Chris Pratt 配音）是乐高世界中一个普通到没有任何存在感的建筑师，他每天精神饱满，乐观向上，按照说明书的指示从事一天的活动。某天收工后，他意外掉入一个深洞，后背还黏了奇怪的东西，随后就被兼具凶暴和善良两面的警察（利亚姆·尼森 Liam Neeson 配音）带走问话。原来统治乐高世界的总裁（威尔·法瑞尔 Will Ferrell 配音）对那些极富创造力的小人极为不满，他讨厌不同系列的乐高世界相互交叉，更讨厌脱离了说明书独辟蹊径的发明创造。因此他将所有世界隔开，囚禁了那些创意大师，还策划着一场可怕的阴谋。艾米特危机时刻被露西（伊丽莎白·班克斯 Elizabe","date":"2014-02-07","objectID":"/anime/the_lego_movie/:1:0","tags":null,"title":"乐高大电影","uri":"/anime/the_lego_movie/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 乐高大电影 2014-02-07 1 下方 ","date":"2014-02-07","objectID":"/anime/the_lego_movie/:2:0","tags":null,"title":"乐高大电影","uri":"/anime/the_lego_movie/"},{"categories":null,"content":"这是在“偶像战国时代”的当下，在这惊涛骇浪之中挣扎生存的7位少女“Wake Up,Girls!”的物语。在东北仙台，某个濒临倒闭的弱小事务所Greenleaves娱乐公司，虽然旗下曾有多位魔术师、写真偶像、占卜师，但现在最后一位仍在活动的艺人也终于辞职，事务所陷入了所属艺人0人的危机状况。经过思考，事务所社长丹下决定推出一个偶像组合。经纪人松田虽然抱有不满，但还是上街开始寻找“偶像原石”。在这时，松田和某个少女实现了必然的邂逅...\n《Wake Up,Girls!》是为在2011年东日本大地震中受灾的东北地区应援的动画。而剧中的七位主角将由avex和81produce举办的试音会中选拔出的新人声优担当。 ","date":"2014-01-10","objectID":"/anime/wake_up_girls/","tags":null,"title":"Wake Up, Girls!","uri":"/anime/wake_up_girls/"},{"categories":null,"content":"简介 这是在“偶像战国时代”的当下，在这惊涛骇浪之中挣扎生存的7位少女“Wake Up,Girls!”的物语。在东北仙台，某个濒临倒闭的弱小事务所Greenleaves娱乐公司，虽然旗下曾有多位魔术师、写真偶像、占卜师，但现在最后一位仍在活动的艺人也终于辞职，事务所陷入了所属艺人0人的危机状况。经过思考，事务所社长丹下决定推出一个偶像组合。经纪人松田虽然抱有不满，但还是上街开始寻找“偶像原石”。在这时，松田和某个少女实现了必然的邂逅… 《Wake Up,Girls!》是为在2011年东日本大地震中受灾的东北地区应援的动画。而剧中的七位主角将由avex和81produce举办的试音会中选拔出的新","date":"2014-01-10","objectID":"/anime/wake_up_girls/:1:0","tags":null,"title":"Wake Up, Girls!","uri":"/anime/wake_up_girls/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 岛田真梦 しまだ まゆ、Shimada Mayu 女 吉岡茉祐 2 林田蓝里 はやしだ あいり、Hayashida Airi 女性 永野愛理 3 片山实波 かたやま みなみ、Katayama Minami 女性 田中美海 4 七濑佳乃 ななせ よしの、Nanase Yoshino 女性 青山吉能 5 久海菜菜美 ひさみ ななみ、Hisami Nanami 女性 山下七海 6 菊间夏夜 きくま かや、Kikuma Kaya 女性 奥野香耶 7 冈本未夕 おかもと みゆ、Okamoto Miyu 女性 高木美佑 8 松田耕平 松田 耕平、まつだ こうへい、Mat","date":"2014-01-10","objectID":"/anime/wake_up_girls/:2:0","tags":null,"title":"Wake Up, Girls!","uri":"/anime/wake_up_girls/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Wake Up, Girls! 2014-01-10 12 樱花 2 Wake Up, Girls! 七人的偶像 2014-01-10 1 西瓜 ","date":"2014-01-10","objectID":"/anime/wake_up_girls/:3:0","tags":null,"title":"Wake Up, Girls!","uri":"/anime/wake_up_girls/"},{"categories":null,"content":"宇宙浪子是宇宙中一位叫作丹迪的人。身为宇宙猎人的他积极寻找未知的外星物种、因此与搭档旧型清扫机器人QT以及长得像猫的外星人阿喵一起在宇宙中到处冒险，并又为此卷入一场即将发生的阴谋之中。","date":"2014-01-05","objectID":"/anime/space_dandy/","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"简介 宇宙浪子是宇宙中一位叫作丹迪的人。身为宇宙猎人的他积极寻找未知的外星物种、因此与搭档旧型清扫机器人QT以及长得像猫的外星人阿喵一起在宇宙中到处冒险，并又为此卷入一场即将发生的阴谋之中。 制作人员： 原作：骨头社 导演：夏目真悟 脚本：圆城塔、上野贵美子、渡边信一郎、佐藤大、大河内一楼、信本敬子 分镜：宫地昌幸 ","date":"2014-01-05","objectID":"/anime/space_dandy/:1:0","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 丹迪 Dandy、ダンディ 男 諏訪部順一 2 QT QT、QT 佐武宇綺 3 阿喵 喵呜、Meow、ミャウ 吉野裕行 4 格尔博士 男 石塚運昇 5 比 Bee 男 畠山航輔 6 哈妮 Honey 女 ユリン千晶 7 斯卡蕾特 女 桑島法子 8 玛米妲丝 女 竹達彩奈 ","date":"2014-01-05","objectID":"/anime/space_dandy/:2:0","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 太空丹迪 2014-01-05 13 樱花 2 太空丹迪 第二季 2014-07-06 13 樱花 ","date":"2014-01-05","objectID":"/anime/space_dandy/:3:0","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"MAD ","date":"2014-01-05","objectID":"/anime/space_dandy/:4:0","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"没有神社供奉、缺少香火的落魄神明夜斗，因为性格缺陷，导致手下的神器纷纷跳槽。怀抱“受万民景仰”这个伟大理想的他，只好只身在此岸与彼岸间徘徊，为五块钱的香油钱（五斗米）折腰，接受上至斩妖除魔，下至修东修西的各类委托……","date":"2014-01-05","objectID":"/anime/noragami/","tags":null,"title":"野良神","uri":"/anime/noragami/"},{"categories":null,"content":"简介 没有神社供奉、缺少香火的落魄神明夜斗，因为性格缺陷，导致手下的神器纷纷跳槽。怀抱“受万民景仰”这个伟大理想的他，只好只身在此岸与彼岸间徘徊，为五块钱的香油钱（五斗米）折腰，接受上至斩妖除魔，下至修东修西的各类委托…… 制作人员： 原作：安达渡嘉 导演：田村耕太郎 脚本：福田裕子、三重野瞳、和场明子 分镜：平川哲生、大桥誉志光、望月智充、末田宜史 ","date":"2014-01-05","objectID":"/anime/noragami/:1:0","tags":null,"title":"野良神","uri":"/anime/noragami/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 夜斗 やと、Yato、夜卜(やぼく) 男 神谷浩史 2 一岐日和 壱岐 ひより、いき ひより、Iki hiyori 女 内田真礼 3 雪音 雪音、ゆきね 男 梶裕貴 4 小福 惠比寿小福、エビス小福、えびすこふく、Ebisukofuku 女 豊崎愛生 5 大黑 だいこく、黒 男 小野大輔 6 毗沙门 ヴィーナ、毗沙门天、毘沙門天、びしゃもんてん、Bishamonnten 女 沢城みゆき 7 兆麻 兆麻、かずま、Kazuma 男 福山潤 8 天神 すがわらのみちざね、菅原道真、天神、てんじん 男 大川透 ","date":"2014-01-05","objectID":"/anime/noragami/:2:0","tags":null,"title":"野良神","uri":"/anime/noragami/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 野良神 2014-01-05 12 bilibili 2 野良神 ARAGOTO 2015-10-02 13 bilibili ","date":"2014-01-05","objectID":"/anime/noragami/:3:0","tags":null,"title":"野良神","uri":"/anime/noragami/"},{"categories":null,"content":"MAD ","date":"2014-01-05","objectID":"/anime/noragami/:4:0","tags":null,"title":"野良神","uri":"/anime/noragami/"},{"categories":null,"content":"故事发生在未来，“Z组合”平时在东京练马区大泉学园光子力町进行新型能源“光子能源”的宣传活动，偶尔将前来搞破坏的地下帝国的尖兵（机械兽少女们）揍飞（顺便发泄压力）。是日常搞笑与暴力相结合的动画。","date":"2014-01-04","objectID":"/anime/robot_girls_z/","tags":null,"title":"机器人少女Z","uri":"/anime/robot_girls_z/"},{"categories":null,"content":"简介 故事发生在未来，“Z组合”平时在东京练马区大泉学园光子力町进行新型能源“光子能源”的宣传活动，偶尔将前来搞破坏的地下帝国的尖兵（机械兽少女们）揍飞（顺便发泄压力）。是日常搞笑与暴力相结合的动画。 制作人员： 原作：永井豪 导演：博史池畠 脚本：兵头一步 人物设定：川上哲也 美术监督：渡边绅 色彩设计：佐佐木雅人 ","date":"2014-01-04","objectID":"/anime/robot_girls_z/:1:0","tags":null,"title":"机器人少女Z","uri":"/anime/robot_girls_z/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 Zちゃん マジンガーZ 女 本多真梨子 2 グレちゃん グレートマジンガー 女 水瀬いのり 3 グレンダさん グレンダイザー 女 荒浪和沙 4 达布拉斯M2 达普拉斯M2、Doublas M2、ダブラスＭ２、ダブラスちゃん、M2 ♀ 東山奈央 5 ゲっちゃん ゲッターロボ 女 内田真礼 6 ジーグさん 鋼鉄ジーグ 女 津田美波 7 あしゅら男爵 女 久川綾 8 ガラダちゃん ガラダK7 女 森下由樹子 ","date":"2014-01-04","objectID":"/anime/robot_girls_z/:2:0","tags":null,"title":"机器人少女Z","uri":"/anime/robot_girls_z/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 机器人少女Z 2014-01-04 12 bilibili ","date":"2014-01-04","objectID":"/anime/robot_girls_z/:3:0","tags":null,"title":"机器人少女Z","uri":"/anime/robot_girls_z/"},{"categories":null,"content":"在魔法的世界里，小魔女优优（諸星すみれ 配音）和妹妹宁宁（加隈亜衣 配音）共同经营着诅咒业务，她们每天在魔法的帮助下上天入地，为他人排忧解难，生活悠闲自在，无忧无虑。可就在某个平常的日子里，魔法世界突然出现前所未有的震动，城镇和森林仿佛被某个淘气的孩子用胶水和泥巴杂乱无 章地捏在了一起。优优趋前调查，结果竟意外地来到了另一个世界。在那里她的身形意外变大，好像比实际年龄长了几岁，她遇到了丢失父母的少年孝洋（泽城美雪 配音）一家，得知这是一个没有魔法的世界。为了找到返回魔法世界的办法，并找到孝洋的父母，优优和另一边的姐姐合作，踏上未知的征程……","date":"2013-12-28","objectID":"/anime/magical_sisters/","tags":null,"title":"小魔女姐妹悠悠与妮妮","uri":"/anime/magical_sisters/"},{"categories":null,"content":"简介 在魔法的世界里，小魔女优优（諸星すみれ 配音）和妹妹宁宁（加隈亜衣 配音）共同经营着诅咒业务，她们每天在魔法的帮助下上天入地，为他人排忧解难，生活悠闲自在，无忧无虑。可就在某个平常的日子里，魔法世界突然出现前所未有的震动，城镇和森林仿佛被某个淘气的孩子用胶水和泥巴杂乱无 章地捏在了一起。优优趋前调查，结果竟意外地来到了另一个世界。在那里她的身形意外变大，好像比实际年龄长了几岁，她遇到了丢失父母的少年孝洋（泽城美雪 配音）一家，得知这是一个没有魔法的世界。为了找到返回魔法世界的办法，并找到孝洋的父母，优优和另一边的姐姐合作，踏上未知的征程…… 制作人员： 原作：ひらりん 导演：平尾隆之 脚","date":"2013-12-28","objectID":"/anime/magical_sisters/:1:0","tags":null,"title":"小魔女姐妹悠悠与妮妮","uri":"/anime/magical_sisters/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 悠悠 优优、ヨヨ、Yoyo 女 諸星すみれ 2 妮妮 宁宁、ネネ、Nene 女 加隈亜衣 3 孝洋 孝洋、Takahiro 男 沢城みゆき 4 健生 健生 男 櫻井孝宏 5 西浦亚纪 西浦 亜紀、にしうら あき、Nishiura Aki 女 佐々木りお 6 尼鲁斯 ニルス 男 子安武人 7 比哈克 ビハク 中川翔子 8 树老长 樹老長 長克巳 ","date":"2013-12-28","objectID":"/anime/magical_sisters/:2:0","tags":null,"title":"小魔女姐妹悠悠与妮妮","uri":"/anime/magical_sisters/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 小魔女姐妹悠悠与妮妮 2013-12-28 100m bilibili ","date":"2013-12-28","objectID":"/anime/magical_sisters/:3:0","tags":null,"title":"小魔女姐妹悠悠与妮妮","uri":"/anime/magical_sisters/"},{"categories":null,"content":"　　天才兼疯子科学家Rick在失踪多年后突然回到女儿Beth的身边，并且在她的车库里搞了一个科学实验室。Rick有一把“传送门枪”，可以穿越到宇宙的各个次元。孙子Morty莫名其妙就成了他的助手，经常被拖进他的自制太空船内，跟他一同开展各种疯狂刺激的宇宙冒险。女儿女婿对他的疯狂行为感到不满，却又对这个天才科学家无可奈何。 ","date":"2013-12-02","objectID":"/anime/rick_and_morty/","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"简介 天才兼疯子科学家Rick在失踪多年后突然回到女儿Beth的身边，并且在她的车库里搞了一个科学实验室。Rick有一把“传送门枪”，可以穿越到宇宙的各个次元。孙子Morty莫名其妙就成了他的助手，经常被拖进他的自制太空船内，跟他一同开展各种疯狂刺激的宇宙冒险。女儿女婿对他的疯狂行为感到不满，却又对这个天才科学家无可奈何。 制作人员： 导演：丹 哈蒙、贾斯汀·罗伊兰 脚本：麦克·麦克马汉、汤姆·考夫曼、瑞安·里德利 演出：杰夫·迈尔斯、约翰·赖斯 ","date":"2013-12-02","objectID":"/anime/rick_and_morty/:1:0","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 瑞克·桑切斯 Rick Sanchez、Rick 男 Justin Roiland 2 莫蒂·史密斯 Morty Smith、Morty 男 Justin Roiland 3 贝丝·史密斯 Beth Sanchez、Beth Smith、Beth 女 Sarah Chalke 4 杰里·史密斯 Jerry Smith、Jerry 男 Chris Parnell 5 萨默·史密斯 Summer Smith、Summer 女 Spencer Grammer 6 Jessica 女 ","date":"2013-12-02","objectID":"/anime/rick_and_morty/:2:0","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 瑞克和莫蒂 第一季 2013-12-02 11 樱花 2 瑞克和莫蒂 第二季 2015-07-26 10 樱花 3 瑞克和莫蒂 第三季 2017-04-01 10 acfun 4 瑞克和莫蒂 第四季 2019-11-10 10 acfun 5 瑞克和莫蒂 第五季 2021-06-20 10 樱花 6 瑞克和莫蒂 第六季 2022-09-04 10 樱花 ","date":"2013-12-02","objectID":"/anime/rick_and_morty/:3:0","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"MAD ","date":"2013-12-02","objectID":"/anime/rick_and_morty/:4:0","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"艾伦戴尔王国有着两位个性截然不同的公主-艾莎与安娜，姊姊艾莎冷若冰霜，举止优雅合宜，安娜生性活泼冲动，热爱冒险。艾莎拥有冷冻的魔法，小时候和妹妹安娜玩耍不小心击中妹妹，所以及后一直不敢接近人群，尤其是不敢靠近安娜，怕再次伤害到亲爱的妹妹。至艾莎成年后，必须接下统领王国的重任，故而闭关多年的城门再次开启。艾莎一直收藏拥有魔法的秘密，压力甚大。两相助的一场争吵让艾莎压抑的情绪爆发，愤而离家，但一时使出的魔法却让整个王国变成冰封的雪国。安娜为了解除魔法，只得冒着风雪寻找姊姊，在路上碰上喜爱冒险的登山人阿克与他如忠犬般个性的驯鹿以及天真搞笑的雪人雪宝，四人一同携手踏上伟大的旅程，它们必须挑战冷峻的雪山以及一路上种种险境才能拯救面临灭亡的王国……","date":"2013-11-27","objectID":"/anime/frozen/","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"简介 艾伦戴尔王国有着两位个性截然不同的公主-艾莎与安娜，姊姊艾莎冷若冰霜，举止优雅合宜，安娜生性活泼冲动，热爱冒险。艾莎拥有冷冻的魔法，小时候和妹妹安娜玩耍不小心击中妹妹，所以及后一直不敢接近人群，尤其是不敢靠近安娜，怕再次伤害到亲爱的妹妹。至艾莎成年后，必须接下统领王国的重任，故而闭关多年的城门再次开启。艾莎一直收藏拥有魔法的秘密，压力甚大。两相助的一场争吵让艾莎压抑的情绪爆发，愤而离家，但一时使出的魔法却让整个王国变成冰封的雪国。安娜为了解除魔法，只得冒着风雪寻找姊姊，在路上碰上喜爱冒险的登山人阿克与他如忠犬般个性的驯鹿以及天真搞笑的雪人雪宝，四人一同携手踏上伟大的旅程，它们必须挑战冷峻","date":"2013-11-27","objectID":"/anime/frozen/:1:0","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾莎 爱莎 女 Idina Menzel 2 安娜 女 諸星すみれ 3 雪宝 男 ピエール瀧 4 克里斯托夫 男 Jonathan Groff 5 汉斯·韦斯特加德 男 Santino Fontana 6 Duke of Weselton 男 Alan Tudyk 7 路人 モブ、モブキャラ、闲角、mob character、端役、エキストラ、extra Fred Tatasciore 8 乐佩 瑞普兹、蕾芬洁、萝庞柔、ラプンツェル 女 ","date":"2013-11-27","objectID":"/anime/frozen/:2:0","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 冰雪奇缘 2013-11-27 1 樱花 2 冰雪奇缘2 2019-11-22 1 樱花 ","date":"2013-11-27","objectID":"/anime/frozen/:3:0","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"MAD ","date":"2013-11-27","objectID":"/anime/frozen/:4:0","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"《辉夜姬物语》（日语：かぐや姫の物語）是日本吉卜力工作室的动画导演高畑勋以日本古典文学《竹取物语》为蓝本所改编的动画电影。かぐや姬，汉译有不同写法，如“辉夜姬”、“赫映姬”、“竹取公主”等等。但据日本语言学家山田孝雄考证，此词源出汉语“赫奕”一词。","date":"2013-11-23","objectID":"/anime/kaguya_hime/","tags":null,"title":"辉夜姬物语","uri":"/anime/kaguya_hime/"},{"categories":null,"content":"简介 《辉夜姬物语》（日语：かぐや姫の物語）是日本吉卜力工作室的动画导演高畑勋以日本古典文学《竹取物语》为蓝本所改编的动画电影。かぐや姬，汉译有不同写法，如“辉夜姬”、“赫映姬”、“竹取公主”等等。但据日本语言学家山田孝雄考证，此词源出汉语“赫奕”一词。 制作人员： 导演：高畑勋 脚本：坂口理子 分镜：桥本晋治、佐藤雅子、笹木信作、百濑义行 音乐：久石让 人物设定：田边修 ","date":"2013-11-23","objectID":"/anime/kaguya_hime/:1:0","tags":null,"title":"辉夜姬物语","uri":"/anime/kaguya_hime/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 辉夜姬 竹子、かぐやひめ 女 朝倉あき 2 舍丸 Sutemaru 男 高良健吾 3 翁 男 4 媼 女 ","date":"2013-11-23","objectID":"/anime/kaguya_hime/:2:0","tags":null,"title":"辉夜姬物语","uri":"/anime/kaguya_hime/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 辉夜姬物语 2013-11-23 137min 樱花 ","date":"2013-11-23","objectID":"/anime/kaguya_hime/:3:0","tags":null,"title":"辉夜姬物语","uri":"/anime/kaguya_hime/"},{"categories":null,"content":"这是一个一个寻找快乐的故事。十年前，钢琴家Sergio与兄长Alfredo分道扬镳：两位都是热爱音乐的人，却无法在音乐事业上如愿发展。Alfredo遂决定抛开世俗的一切去寻找快乐，离家前住印度达兰萨拉出家修练成为和尚；Sergio则在拿破里当上的士司机。他日复日的听着收音机穿过大街小巷，遇上了不同的人，聆听不同的故事。导演以动画画出哲理与智慧，通过两兄弟的故事，探讨音乐、生命、以及快乐的真谛。你，快乐吗？","date":"2013-11-21","objectID":"/anime/the_art_of_happiness/","tags":null,"title":"寻找隐世快乐","uri":"/anime/the_art_of_happiness/"},{"categories":null,"content":"简介 这是一个一个寻找快乐的故事。十年前，钢琴家Sergio与兄长Alfredo分道扬镳：两位都是热爱音乐的人，却无法在音乐事业上如愿发展。Alfredo遂决定抛开世俗的一切去寻找快乐，离家前住印度达兰萨拉出家修练成为和尚；Sergio则在拿破里当上的士司机。他日复日的听着收音机穿过大街小巷，遇上了不同的人，聆听不同的故事。导演以动画画出哲理与智慧，通过两兄弟的故事，探讨音乐、生命、以及快乐的真谛。你，快乐吗？ ","date":"2013-11-21","objectID":"/anime/the_art_of_happiness/:1:0","tags":null,"title":"寻找隐世快乐","uri":"/anime/the_art_of_happiness/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 寻找隐世快乐 2013-11-21 1 其它 ","date":"2013-11-21","objectID":"/anime/the_art_of_happiness/:2:0","tags":null,"title":"寻找隐世快乐","uri":"/anime/the_art_of_happiness/"},{"categories":null,"content":"　　那个世界，无论到哪里都在预料之外 \n　　无论哪里，无论哪里都是由隧道连接着的地下世界。虽然那里的人住在黑暗封闭的空间里，但他们却穿着防护衣过着宁静快乐的日子。地底集落的公主——帕特玛是爱在地下隧道中到处探索的女孩。她最喜欢的地方是被当地人禁止进入的“危险地区”。即使挨骂也阻止 不了帕特玛的好奇心。毕竟从来没人说过那所谓的“危险”究竟是什么。有一天，在去“危险地区”探险的途中，帕特玛终于遇到难以想象的事件，一步步发现了惊人的秘密… ","date":"2013-11-09","objectID":"/anime/patema_inverted/","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"简介 那个世界，无论到哪里都在预料之外 无论哪里，无论哪里都是由隧道连接着的地下世界。虽然那里的人住在黑暗封闭的空间里，但他们却穿着防护衣过着宁静快乐的日子。地底集落的公主——帕特玛是爱在地下隧道中到处探索的女孩。她最喜欢的地方是被当地人禁止进入的“危险地区”。即使挨骂也阻止 不了帕特玛的好奇心。毕竟从来没人说过那所谓的“危险”究竟是什么。有一天，在去“危险地区”探险的途中，帕特玛终于遇到难以想象的事件，一步步发现了惊人的秘密… 制作人员： 原作：吉浦康裕 音乐：大岛满 人物原案：茶山隆介、杏仁豆腐 人物设定：又贺大介 美术监督：金子雄司 ","date":"2013-11-09","objectID":"/anime/patema_inverted/:1:0","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 帕特玛 Patema 女 藤井ゆきよ 2 英治 Age 男 岡本信彦 3 拉格斯 Lagos 男 加藤将之 4 波尔塔 Porta 大畑伸太郎 5 カホ Kaho 女 内田真礼 6 ジィ Jii 男 ふくまつ進紗 7 ジャク Jack 男 安元洋貴 8 イザムラ Izamura 男 土師孝也 ","date":"2013-11-09","objectID":"/anime/patema_inverted/:2:0","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 颠倒的帕特玛 2013-11-09 1 bilibili ","date":"2013-11-09","objectID":"/anime/patema_inverted/:3:0","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"MAD ","date":"2013-11-09","objectID":"/anime/patema_inverted/:4:0","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"主人公是自称“武士·弗拉明戈”的青年，以及一位年轻警察。两名男子相识后活跃在为正义而战的战斗中。紧张而有漫画风格的情节即将展开，这是一场英雄的演出。","date":"2013-10-10","objectID":"/anime/samurai_flamenco/","tags":null,"title":"武士弗拉明戈","uri":"/anime/samurai_flamenco/"},{"categories":null,"content":"简介 主人公是自称“武士·弗拉明戈”的青年，以及一位年轻警察。两名男子相识后活跃在为正义而战的战斗中。紧张而有漫画风格的情节即将展开，这是一场英雄的演出。 制作人员： 原作：Manglobe 导演：大森贵弘 脚本：贵博、仓田英之 分镜：菅沼荣治、佐藤阳、冲田宫奈、东出太 ","date":"2013-10-10","objectID":"/anime/samurai_flamenco/:1:0","tags":null,"title":"武士弗拉明戈","uri":"/anime/samurai_flamenco/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 羽佐间正义 Masayoshi Hazama、羽佐間　正義、はざま　まさよし、Hazama Masayoshi 男 増田俊樹 2 后藤英德 Hidenori Goto、後藤　英徳、ごとう　ひでのり、Goto Hidenori 男 杉田智和 3 真野真理 真野茉莉、Mari Maya、まや　まり、Maya Mari 女 戸松遥 4 三泽瑞希 Mizuki Misawa、みさわ　みずき、Misawa Mizuki 女 M・A・O 5 森田萌 Moe Morita、もりた　もえ、Morita Moe 女 山崎エリイ 6 要丈治 Joji Kaname、要　丈治、か","date":"2013-10-10","objectID":"/anime/samurai_flamenco/:2:0","tags":null,"title":"武士弗拉明戈","uri":"/anime/samurai_flamenco/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 武士弗拉明戈 2013-10-10 22 bilibili ","date":"2013-10-10","objectID":"/anime/samurai_flamenco/:3:0","tags":null,"title":"武士弗拉明戈","uri":"/anime/samurai_flamenco/"},{"categories":null,"content":"在21世纪初，人类因全球暖化的影响而失去了大半的陆地。此时，在世界各地突然出现了搭载着神秘超兵器被称为“雾之舰队”的战舰群，对其毫无招架之力的人类失去了制海权，并且再也无法自由航行于大海之上。17年后，千早群像与其同伴们在不知觉中搭上了潜水舰伊401，并与伊401的心智范本伊欧娜一起挑起了与雾之舰队间的战火。","date":"2013-10-07","objectID":"/anime/arpeggio_of_blue_steel/","tags":null,"title":"苍蓝钢铁的琶音","uri":"/anime/arpeggio_of_blue_steel/"},{"categories":null,"content":"简介 在21世纪初，人类因全球暖化的影响而失去了大半的陆地。此时，在世界各地突然出现了搭载着神秘超兵器被称为“雾之舰队”的战舰群，对其毫无招架之力的人类失去了制海权，并且再也无法自由航行于大海之上。17年后，千早群像与其同伴们在不知觉中搭上了潜水舰伊401，并与伊401的心智范本伊欧娜一起挑起了与雾之舰队间的战火。 制作人员： 原作：Ark Performance 导演：岸诚二 脚本：森田繁、中村浩二郎、上江洲诚、日暮茶坊 分镜：吉冈忍、高桥正典、政木伸一 ","date":"2013-10-07","objectID":"/anime/arpeggio_of_blue_steel/:1:0","tags":null,"title":"苍蓝钢铁的琶音","uri":"/anime/arpeggio_of_blue_steel/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 千早群像 千早 群像、ちはや ぐんぞう、Gunzou Chihaya 男 興津和幸 2 伊欧娜 イオナ、Iona 渕上舞 3 高雄 タカオ、たかお 沼倉愛美 4 织部僧 織部 僧、おりべ そう、Sou Oribe 松本忍 5 橿原杏平 橿原杏平、かしはら きょうへい、Kyouhei Kashihara 男 宮下栄治 6 四月一日伊织 四月一日いおり、わたぬき いおり 女 津田美波 7 八月一日静 八月一日静、ほづみ しずか 女 東山奈央 8 榛名 ハルナ、はるな 山村響 ","date":"2013-10-07","objectID":"/anime/arpeggio_of_blue_steel/:2:0","tags":null,"title":"苍蓝钢铁的琶音","uri":"/anime/arpeggio_of_blue_steel/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 苍蓝钢铁的琶音 2013-10-07 12 樱花 2 苍蓝钢铁的琶音 DC 2015-01-31 1 樱花 3 苍蓝钢铁的琶音 Cadenza 2015-10-03 1 樱花 ","date":"2013-10-07","objectID":"/anime/arpeggio_of_blue_steel/:3:0","tags":null,"title":"苍蓝钢铁的琶音","uri":"/anime/arpeggio_of_blue_steel/"},{"categories":null,"content":"作品舞台是一个挂著“牛经过注意”的看板，公车不等上5个小时不会来的乡下农村，而主角一条萤因父亲工作调职的关系从东京迁居此地，故事即是描写萤与越谷姐妹及宫内姐妹渡过的日常光景。","date":"2013-10-07","objectID":"/anime/non_non_biyori/","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"简介 作品舞台是一个挂著“牛经过注意”的看板，公车不等上5个小时不会来的乡下农村，而主角一条萤因父亲工作调职的关系从东京迁居此地，故事即是描写萤与越谷姐妹及宫内姐妹渡过的日常光景。 制作人员： 原作：あっと 导演：川面真也 脚本：吉田玲子、山田由香、志茂文彦 分镜：岩崎良明、锦织博、小柴纯弥 ","date":"2013-10-07","objectID":"/anime/non_non_biyori/:1:0","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫内莲华 宮内 れんげ、みやうち れんげ、Miyauchi Renge、れんちょん、喵帕斯 女 小岩井ことり 2 一条萤 一条虫、いちじょう　ほたる、Ichijou Hotaru、ほたるん 女 村川梨衣 3 越谷夏海 こしがや なつみ、Koshigaya Natsumi、なっつん 女 佐倉綾音 4 越谷小鞠 小小鞠、こしがや こまり、Koshigaya Komari、コマちゃん 女 阿澄佳奈 5 加贺山枫 かがやま かえで、Kagayama Kaede、卖零食的 (駄菓子屋/駄菓子屋さん) 女 佐藤利奈 6 宫内一穗 みやうち かずほ、Miyauchi Ka","date":"2013-10-07","objectID":"/anime/non_non_biyori/:2:0","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 悠哉日常大王 2013-10-07 12 樱花 2 悠哉日常大王 OAD 2014-07-23 1 bilibili 3 悠哉日常大王 Repeat 2015-07-06 12 樱花 4 悠哉日常大王 Repeat OAD 2016-09-23 1 bilibili 5 剧场版 悠哉日常大王 Vacation 2018-08-25 1 bilibili 6 悠哉日常大王 Nonstop 2021-01-10 12 bilibili 7 悠哉日常大王 Nonstop OAD 2022-03-23 1 樱花 ","date":"2013-10-07","objectID":"/anime/non_non_biyori/:3:0","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"MAD ","date":"2013-10-07","objectID":"/anime/non_non_biyori/:4:0","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"故事发生在2007年秋季的东京都。峰城大附属3年级学生北原春希为了制造学生时代最后的回忆加入了轻音乐同好会，而乐队却因为感情的纠葛而崩溃。春希为了能够在学园祭上成功演出而开始召集成员，并成功劝诱了在屋顶唱歌的学院偶像小木曾雪菜。在发现了班级的问题儿童冬马和纱的天才般音乐才能之后，两人经过千辛万苦最终使她也加入了乐队。原本毫不相关的三个人经过全神贯注的、拼命的奋斗之后在学园祭上大获成功，三个人从心底结合了起来……虽然大家都是这样认为的，但从这以后各自的爱恋却走向了残酷的悲剧……","date":"2013-10-05","objectID":"/anime/white_album_2/","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"简介 故事发生在2007年秋季的东京都。峰城大附属3年级学生北原春希为了制造学生时代最后的回忆加入了轻音乐同好会，而乐队却因为感情的纠葛而崩溃。春希为了能够在学园祭上成功演出而开始召集成员，并成功劝诱了在屋顶唱歌的学院偶像小木曾雪菜。在发现了班级的问题儿童冬马和纱的天才般音乐才能之后，两人经过千辛万苦最终使她也加入了乐队。原本毫不相关的三个人经过全神贯注的、拼命的奋斗之后在学园祭上大获成功，三个人从心底结合了起来……虽然大家都是这样认为的，但从这以后各自的爱恋却走向了残酷的悲剧…… 制作人员： 原作：アクアプラス 导演：安藤正臣 脚本：丸户史明 分镜：小野胜巳、沼田诚也、渡边哲哉、大和直道、安","date":"2013-10-05","objectID":"/anime/white_album_2/:1:0","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小木曾雪菜 小木曽 雪菜、おぎそ せつな、Ogiso Setsuna 女 米澤円 2 冬马和纱 冬马和咲、冬馬 かずさ、とうま かずさ、Touma Kazusa 女 生天目仁美 3 北原春希 北原 春希、きたはら はるき、Kitahara Haruki 男 水島大宙 4 饭冢武也 飯塚 武也、いいづか たけや、Iizuka Takeya 男 寺島拓篤 5 水泽依绪 水沢 依緒、みずさわ いお、Mizusawa Io 女 中上育実 6 小木曽孝宏 Ogiso Takahiro 男 梶裕貴 7 早坂亲志 Hayasaka Chikashi 男 杉山紀彰 8 冬马","date":"2013-10-05","objectID":"/anime/white_album_2/:2:0","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 白色相簿2 2013-10-05 13 樱花 ","date":"2013-10-05","objectID":"/anime/white_album_2/:3:0","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"MAD ","date":"2013-10-05","objectID":"/anime/white_album_2/:4:0","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"本故事以被武力和恐怖支配的本能字学院为舞台，以为父报仇的转校生少女为中心， 围绕着在学园中“执牛耳者”的学生及学生会四大天王间的激战故事展开。\n\n缠流子和鬼龙院皋月，两人为本作的主人公。在本作中，皋月用极制服的力量支配着学园， 而流子为查明父亲死亡的真相而与皋月对抗。\n\n在这由力量支配的学园中，由于手持片太刀铗的转校生的到来，引起了动乱， 这一场各个能力者均被打倒的故事因此而开始！","date":"2013-10-03","objectID":"/anime/kill_la_kill/","tags":null,"title":"斩服少女","uri":"/anime/kill_la_kill/"},{"categories":null,"content":"简介 本故事以被武力和恐怖支配的本能字学院为舞台，以为父报仇的转校生少女为中心， 围绕着在学园中“执牛耳者”的学生及学生会四大天王间的激战故事展开。 缠流子和鬼龙院皋月，两人为本作的主人公。在本作中，皋月用极制服的力量支配着学园， 而流子为查明父亲死亡的真相而与皋月对抗。 在这由力量支配的学园中，由于手持片太刀铗的转校生的到来，引起了动乱， 这一场各个能力者均被打倒的故事因此而开始！ 制作人员： 原作：中岛一基、TRIGGER 导演：今石洋之 脚本：若林广海、濑古浩司 分镜：横山彰利、吉成曜、立川让 ","date":"2013-10-03","objectID":"/anime/kill_la_kill/:1:0","tags":null,"title":"斩服少女","uri":"/anime/kill_la_kill/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 缠流子 纏 流子、まとい りゅうこ、Matoi Ryuuko 女 小清水亜美 2 鬼龙院皐月 鬼龍院 皐月、きりゅういん さつき、Kiryuuin Satsuki 女 柚木涼香 3 鲜血 せんけつ、senketsu 関俊彦 4 满舰饰真子 満艦飾 マコ、まんかんしょく まこ、Mankanshoku Mako 女 洲崎綾 5 猿投山涡 猿投山 渦、さなげやま うず、Sanageyama Uzu 男 檜山修之 6 蛇崩乃音 蛇崩 乃音、じゃくずれ ののん、Jakuzure Nonon 女 新谷真弓 7 犬牟田宝火 犬牟田 宝火、いぬむた ほうか、Inumuta ","date":"2013-10-03","objectID":"/anime/kill_la_kill/:2:0","tags":null,"title":"斩服少女","uri":"/anime/kill_la_kill/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 斩服少女 2013-10-03 24 bilibili ","date":"2013-10-03","objectID":"/anime/kill_la_kill/:3:0","tags":null,"title":"斩服少女","uri":"/anime/kill_la_kill/"},{"categories":null,"content":"在与外界隔绝，时间静止的镜都内，主角筝和不同势力的代表，为了寻找共同的目标——黑兔古都，而每天上演着奇幻缤纷的格斗。众人对自身过去的执著，以及对特殊现象的好奇，渐渐弄清世界的所有现象的前因后果。","date":"2013-10-02","objectID":"/anime/kyousogiga/","tags":null,"title":"京骚戏画","uri":"/anime/kyousogiga/"},{"categories":null,"content":"简介 在与外界隔绝，时间静止的镜都内，主角筝和不同势力的代表，为了寻找共同的目标——黑兔古都，而每天上演着奇幻缤纷的格斗。众人对自身过去的执著，以及对特殊现象的好奇，渐渐弄清世界的所有现象的前因后果。 制作人员： 原作：东堂泉 导演：松本理惠 脚本：丸尾未步、中濑理香 分镜：角铜博之、志水淳儿 ","date":"2013-10-02","objectID":"/anime/kyousogiga/:1:0","tags":null,"title":"京骚戏画","uri":"/anime/kyousogiga/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 筝 琴、琴子、Koto 女 釘宮理恵 2 明惠 药师丸、みょうえ 男 鈴村健一 3 古都 コト 女 久川綾 4 翔子 女 斎藤千和 5 八濑 Hachise 女 喜多村英梨 6 阿 A 男 日髙のり子 7 吽 Un 男 白石涼子 8 稻荷 いなりの、Inonari 男 石田彰 ","date":"2013-10-02","objectID":"/anime/kyousogiga/:2:0","tags":null,"title":"京骚戏画","uri":"/anime/kyousogiga/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 京骚戏画 2013-10-02 13 樱花 ","date":"2013-10-02","objectID":"/anime/kyousogiga/:3:0","tags":null,"title":"京骚戏画","uri":"/anime/kyousogiga/"},{"categories":null,"content":"想更加出人头地！为了实现这样的理想，黑白小姐以成为卖座偶像为目标开始活动，尽管天然性格的黑白小姐总是给周围带来麻烦，但还是每日奔走于偶像业界！","date":"2013-10-01","objectID":"/anime/miss_monochrome/","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"简介 想更加出人头地！为了实现这样的理想，黑白小姐以成为卖座偶像为目标开始活动，尽管天然性格的黑白小姐总是给周围带来麻烦，但还是每日奔走于偶像业界！ 制作人员： 导演：岩崎良明 脚本：笔安一幸 分镜：山下英美、臼井文明、大岛博之 ","date":"2013-10-01","objectID":"/anime/miss_monochrome/:1:0","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 黑白小姐 黑白姑娘、单色小姐、Miss Monochrome 女 堀江由衣 2 经纪夫 瑪莉歐、Maneo 男 藤原啓治 3 喜久子 女 井上喜久子 4 真奈 女 神田朱未 5 宇宙人 村田太志 6 露酱 Ruuchan 7 旁白 ナレーター、解説、Narration/Narrator、Nareeshon、天之声、páng bái 藤原啓治 8 路人 モブ、モブキャラ、闲角、mob character、端役、エキストラ、extra 大地葉 ","date":"2013-10-01","objectID":"/anime/miss_monochrome/:2:0","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 黑白小姐 2013-10-01 13 樱花 ","date":"2013-10-01","objectID":"/anime/miss_monochrome/:3:0","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"MAD ","date":"2013-10-01","objectID":"/anime/miss_monochrome/:4:0","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"剧情为混合改编了零式舰上战斗机设计者堀越二郎的故事、以及小说家堀辰雄作品《风吹了》的内容，并预计2013年夏季上映。另外，男主角堀越二郎的配音，则由《新世纪福音战士》的导演庵野秀明出任。","date":"2013-07-20","objectID":"/anime/the_wind_rises/","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"简介 剧情为混合改编了零式舰上战斗机设计者堀越二郎的故事、以及小说家堀辰雄作品《风吹了》的内容，并预计2013年夏季上映。另外，男主角堀越二郎的配音，则由《新世纪福音战士》的导演庵野秀明出任。 制作人员： 原作：宫崎骏 音乐：久石让 美术监督：武重洋二 色彩设计：保田道世 作画监督：高坂希太郎 摄影监督：奥井敦 原画：山下明彦 ","date":"2013-07-20","objectID":"/anime/the_wind_rises/:1:0","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 堀越二郎 堀越 二郎、ほりこし じろう、Horikoshi Jirou 男 庵野秀明 2 里见菜穗子 里見菜穂子、さとみ なおこ、satomi naoko 女 瀧本美織 3 堀越加代 堀越加代、ほりこし かよ、Horikoshi Kayo 女 志田未来 4 二郎的母亲 二郎の母、Jirou no Haha 女 竹下景子 5 本庄季郎 本庄季郎、Honjou Kirou 男 西島秀俊 6 黑川 黒川、Kurokawa 男 西村雅彦 7 卡普罗尼 Caproni、カプローニ 男 野村萬斎 8 カストルプ Castorp、カストルプ 男 Steve Alpert ","date":"2013-07-20","objectID":"/anime/the_wind_rises/:2:0","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 起风了 2013-07-20 1 bilibili ","date":"2013-07-20","objectID":"/anime/the_wind_rises/:3:0","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"MAD ","date":"2013-07-20","objectID":"/anime/the_wind_rises/:4:0","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"　　“想把一切忘记”——留下一封充满谜团的笔信，她从身边消失了。为了寻找真实，我前往了你所在的小镇。\n　　桐岛青大追随突然消失的柚叶枝希，离开故乡广岛前往东京。在那里她遇到的是性格强气、很在意自己贫乳的御岛明日香，长发而好女色的风间恭辅、以及柚希奔放的妹妹懔。\n　　在那里，邂逅、互恋、离别、伤害、受伤接踵而至。最后挑明的事实，以及最终找到的真实感情则是——\n　　以东京和广岛为舞台，被残酷的命运所翻弄，在友情和爱情的夹缝间挣扎，寻找着真正的恋爱的男女，甘甜而又苦涩的青春恋爱故事。","date":"2013-07-13","objectID":"/anime/a_town_where_you_live/","tags":null,"title":"有你的小镇","uri":"/anime/a_town_where_you_live/"},{"categories":null,"content":"简介 “想把一切忘记”——留下一封充满谜团的笔信，她从身边消失了。为了寻找真实，我前往了你所在的小镇。 桐岛青大追随突然消失的柚叶枝希，离开故乡广岛前往东京。在那里她遇到的是性格强气、很在意自己贫乳的御岛明日香，长发而好女色的风间恭辅、以及柚希奔放的妹妹懔。 在那里，邂逅、互恋、离别、伤害、受伤接踵而至。最后挑明的事实，以及最终找到的真实感情则是—— 以东京和广岛为舞台，被残酷的命运所翻弄，在友情和爱情的夹缝间挣扎，寻找着真正的恋爱的男女，甘甜而又苦涩的青春恋爱故事。 制作人员： 原作：濑尾公治 导演：山内重保 脚本：国泽真理子、吉田玲子、国井桂 分镜：木村延景、仓谷凉一 ","date":"2013-07-13","objectID":"/anime/a_town_where_you_live/:1:0","tags":null,"title":"有你的小镇","uri":"/anime/a_town_where_you_live/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 桐岛青大 桐島 青大、きりしま はると、Kirishima Haruto 男 細谷佳正 2 枝叶柚希 枝葉 柚希、えば ゆずき、Eba Yuzuki、桐島柚希 女 中島愛 3 御岛明日香 御島 明日香、みしま あすか、Mishima Asuka 女 佐倉綾音 4 风间恭辅 風間 恭輔、かざま きょうすけ、Kazama Kyōsuke 男 小野大輔 5 枝叶懔 枝葉 懍、えば りん、Eba Rin 女 藤田咲 6 桐岛葵 桐島 葵、きりしま あおい、Kirishima Aoi 女 たかはし智秋 7 夏越美奈 夏越 美奈、なごし みな、Nagoshi Mina ","date":"2013-07-13","objectID":"/anime/a_town_where_you_live/:2:0","tags":null,"title":"有你的小镇","uri":"/anime/a_town_where_you_live/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 有你的小镇 2013-07-13 12 樱花 ","date":"2013-07-13","objectID":"/anime/a_town_where_you_live/:3:0","tags":null,"title":"有你的小镇","uri":"/anime/a_town_where_you_live/"},{"categories":null,"content":"MAD ","date":"2013-07-13","objectID":"/anime/a_town_where_you_live/:4:0","tags":null,"title":"有你的小镇","uri":"/anime/a_town_where_you_live/"},{"categories":null,"content":"故事发生在虚构的日本第二首都——2015年的东京都立川市，在高科技的应用下智能手机和社交网络已经成为和人们不可分割的一部分。不过在城市中出现了麻烦与骚乱的未知存在“MESS”，而主角一行则是作为解决此事的“Gatchaman”，利用特殊的笔记本“NOTE”将灵魂的特殊能力实体化为铠甲，并利用这种力量介入事件，维护城市的和平。但同时网络社交媒体“GALAX”也已经悄然对城市有所改变，而“GALAX”的一位名人“LOAD”并不认同“Gatchaman”为城市和带来的意义。\n通过“GALAX”，不同职业和身份的“GALAXER”——“GALAX”的用户可以各司其职的帮助周围的人，每当“GALAXER”遇到困难时，他们能受到软件自带的人工智能“X总裁”的指导，掌握紧急事件的状况、保持冷静并尝试通过自己和周围的人解决事态。“GALAX”称其为“更新”，GALAX的创立者想通过这个方式创立理想的横向社会。","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"简介 故事发生在虚构的日本第二首都——2015年的东京都立川市，在高科技的应用下智能手机和社交网络已经成为和人们不可分割的一部分。不过在城市中出现了麻烦与骚乱的未知存在“MESS”，而主角一行则是作为解决此事的“Gatchaman”，利用特殊的笔记本“NOTE”将灵魂的特殊能力实体化为铠甲，并利用这种力量介入事件，维护城市的和平。但同时网络社交媒体“GALAX”也已经悄然对城市有所改变，而“GALAX”的一位名人“LOAD”并不认同“Gatchaman”为城市和带来的意义。 通过“GALAX”，不同职业和身份的“GALAXER”——“GALAX”的用户可以各司其职的帮助周围的人，每当“GALA","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/:1:0","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 一之濑初 一ノ瀬 はじめ、いちのせ はじめ、Ichinose Hajime 女 内田真礼 2 橘清音 橘 清音、たちばな すがね、Tachibana Sugane 男 逢坂良太 3 枇枇木丈 Joe Hibiki、枇々木 丈、ひびき じょう、Hibiki Jō 男 浪川大輔 4 宫现 宮 うつつ、みや うつつ、Miya Utsutsu 女 小岩井ことり 5 派曼 平野綾 6 O·D オー・ディー 男 細見大輔 7 尔乃美家累 爾乃美家 累、にのみや るい、Ninomiya Rui 男 村瀬歩 8 皮尔·卡切 Berg-Katze 男 宮野真守 ","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/:2:0","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 科学小飞侠Crowds 2013-07-12 13 bilibili 2 科学小飞侠Crowds insight 2015-07-05 13 bilibili ","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/:3:0","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"MAD ","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/:4:0","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"伊莉雅是一个就读穗群原学园的普通女孩子，在某天遇到了自称人工天然精灵的魔法露比万花筒之杖，并强制地被缔结契约，成为了魔法少女伊莉雅。而已是红宝石之星持有人的她，还变成了万花筒之杖原持有者的魔术师远坂凛的奴隶，在其的命令之下，被迫帮忙回收沉睡于冬木市的某危险的卡片……","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"简介 伊莉雅是一个就读穗群原学园的普通女孩子，在某天遇到了自称人工天然精灵的魔法露比万花筒之杖，并强制地被缔结契约，成为了魔法少女伊莉雅。而已是红宝石之星持有人的她，还变成了万花筒之杖原持有者的魔术师远坂凛的奴隶，在其的命令之下，被迫帮忙回收沉睡于冬木市的某危险的卡片…… 制作人员： 原作：广山弘、型月 导演：大沼心 脚本：水濑叶月、井上坚二 分镜：高桥贤、野田惠、二瓶勇一、川口敬一郎 ","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/:1:0","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊莉雅斯菲尔·冯·爱因兹贝伦 伊莉雅丝菲尔·冯·爱因兹贝伦、伊莉亚丝菲尔·冯·艾因兹贝伦、依莉雅苏菲尔·冯·爱因兹贝伦、伊莉雅、Illyasviel von Einzbern、イリヤ 女 門脇舞以 2 美游·艾德费尔特 朔月美游、美游、Miyu Edelfelt、美遊・エーデルフェルト、みゆ エーデルフェルト、Miyu Ēderuferuto、みゆきち 女 名塚佳織 3 阿尔托莉雅·潘德拉贡 Saber、呆毛王、吾王、青王、骑士王、棉被王、亚瑟王、蓝Saber、元祖Saber、Altria Pendragon、セイバー 女 川澄綾子 4 卫宫士郎 衛宮 士郎","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/:2:0","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Fate/kaleid liner 魔法少女☆伊莉雅 2013-07-12 10 樱花 2 Fate/kaleid liner 魔法少女☆伊莉雅 OAD 2014-03-07 1 bilibili 3 Fate/kaleid liner 魔法少女☆伊莉雅 2wei! 2014-07-09 10 bilibili 4 Fate/kaleid liner 魔法少女☆伊莉雅 2wei OAD 2015-07-25 1 樱花 5 Fate/kaleid liner 魔法少女☆伊莉雅 2wei Herz! 2015-07-24 10 樱花 6 Fate/","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/:3:0","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"MAD ","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/:4:0","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"    大虾夷农业高等学校（通称：虾夷农高）是一所坐落于北海道的农业高中，校内学生多为以将从事农业当作目标的农家子女。这所拥有在全日本所有高中中最多的占地面积，被北海道壮丽的大自然和乡村风情环抱的虾夷农高，在新学年里迎来了一位特殊的学生——八轩勇吾。这位来自城市、毕业于升学初中的文弱学生，因发现在一年级的同学中只有他自己找不到明确的人生目标而开始焦躁不安。自此，写作“就读于农高的每一天”、读作“在青春岁月中找寻自己的梦想”的八轩勇吾的高中生活开始了。","date":"2013-07-11","objectID":"/anime/silver_spoon/","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"简介 大虾夷农业高等学校（通称：虾夷农高）是一所坐落于北海道的农业高中，校内学生多为以将从事农业当作目标的农家子女。这所拥有在全日本所有高中中最多的占地面积，被北海道壮丽的大自然和乡村风情环抱的虾夷农高，在新学年里迎来了一位特殊的学生——八轩勇吾。这位来自城市、毕业于升学初中的文弱学生，因发现在一年级的同学中只有他自己找不到明确的人生目标而开始焦躁不安。自此，写作“就读于农高的每一天”、读作“在青春岁月中找寻自己的梦想”的八轩勇吾的高中生活开始了。 制作人员： 原作：荒川弘 导演：伊藤智彦 脚本：岸本卓 分镜：许平康、柴山智隆、村山靖、室井康雄、藤森一真、冈村天斋 ","date":"2013-07-11","objectID":"/anime/silver_spoon/:1:0","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 八轩勇吾 八軒 勇吾、はちけん ゆうご、Hachiken Yuugo、ハチ 男 木村良平 2 御影秋 御影亚季、御影亚纪、みかげ アキ、Mikage Aki 女 三宅麻理恵 3 驹场一郎 駒場 一郎、こまば いちろう、Komaba Ichirou 男 櫻井トオル 4 常盘惠次 常盤 恵次、ときわ けいじ、Tokiwa Keiji 男 庄司将之 5 稻田多摩子 稲田 多摩子、いなだ たまこ、Inada Tamako、タマコ / 鸡蛋子 女 高垣彩陽 6 相川进之介 相川 進之介、あいかわ しんのすけ、Aikawa Shinnosike 男 島﨑信長 7 吉野真","date":"2013-07-11","objectID":"/anime/silver_spoon/:2:0","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 银之匙 Silver Spoon 2013-07-11 11 acfun 2 银之匙 Silver Spoon 第二季 2014-01-09 11 acfun ","date":"2013-07-11","objectID":"/anime/silver_spoon/:3:0","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"MAD ","date":"2013-07-11","objectID":"/anime/silver_spoon/:4:0","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"曾在英国寄住的忍，归国后开始了高中1年生的生活，然而某一天忍在英国的朋友爱丽丝竟然不远万里跑来日本了，说着“这次轮到我来日本了”的爱丽丝，将忍和同学绫与阳子，以及另一位英国少女九条可怜卷入了日本和英国美少女之间的休闲百合日常。","date":"2013-07-06","objectID":"/anime/kin-iro_mosaic/","tags":null,"title":"黄金拼图","uri":"/anime/kin-iro_mosaic/"},{"categories":null,"content":"简介 曾在英国寄住的忍，归国后开始了高中1年生的生活，然而某一天忍在英国的朋友爱丽丝竟然不远万里跑来日本了，说着“这次轮到我来日本了”的爱丽丝，将忍和同学绫与阳子，以及另一位英国少女九条可怜卷入了日本和英国美少女之间的休闲百合日常。 制作人员： 原作：原悠衣 导演：天冲 脚本：高桥龙也、浦畑达彦、绫奈由仁子 分镜：木宫茂、佐藤真二、安食圭 ","date":"2013-07-06","objectID":"/anime/kin-iro_mosaic/:1:0","tags":null,"title":"黄金拼图","uri":"/anime/kin-iro_mosaic/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 大宫忍 忍叔、おおみや しのぶ、Oomiya Shinobu、小忍 女 西明日香 2 爱丽丝·卡塔雷特 艾莉丝·卡达列特、Alice Cartelet 女 田中真奈美 3 小路绫 小路 綾、こみち あや、Komichi Aya、Ayaya 女 種田梨沙 4 猪熊阳子 猪熊 陽子、いのくま ようこ、Inokuma Youko 女 内山夕実 5 九条可怜 九条 カレン、くじょう カレン、Kujou Karen 女 東山奈央 6 大宫勇 大宮 勇、おおみや いさみ、Oomiya Isami 女 田村ゆかり 7 忍的妈妈 女 高橋美佳子 8 可怜的妈妈 女 木村亜希","date":"2013-07-06","objectID":"/anime/kin-iro_mosaic/:2:0","tags":null,"title":"黄金拼图","uri":"/anime/kin-iro_mosaic/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 黄金拼图 2013-07-06 12 bilibili ","date":"2013-07-06","objectID":"/anime/kin-iro_mosaic/:3:0","tags":null,"title":"黄金拼图","uri":"/anime/kin-iro_mosaic/"},{"categories":null,"content":"作品的舞台是以“尽可能快乐地度过放学后的时光”为主导思想的“归宅部”，故事描绘出其不意地进入了归宅部的女主角安藤夏希与部长道明寺樱等部员谱写的异乎常人的日常。","date":"2013-07-04","objectID":"/anime/going_home_club/","tags":null,"title":"归宅部活动记录","uri":"/anime/going_home_club/"},{"categories":null,"content":"简介 作品的舞台是以“尽可能快乐地度过放学后的时光”为主导思想的“归宅部”，故事描绘出其不意地进入了归宅部的女主角安藤夏希与部长道明寺樱等部员谱写的异乎常人的日常。 制作人员： 原作：くろは 导演：佐藤光 脚本：杂破业、真藤ユキヲ 分镜：宫崎渚、后信治、高田耕一、秋田谷典昭、大畑晃一 ","date":"2013-07-04","objectID":"/anime/going_home_club/:1:0","tags":null,"title":"归宅部活动记录","uri":"/anime/going_home_club/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安藤夏希 安藤 夏希、あんどう なつき、Andō Natsuki 女 木戸衣吹 2 塔野花梨 塔野 花梨、とうの かりん、Tōno Karin 女 結名美月 3 道明寺樱 道明寺 桜、どうみょうじ さくら、Dōmyōji Sakura 女 桜井美晴 4 大荻牡丹 おおはぎ ぼたん 女 相内沙英 5 九重克蕾雅 (九重久礼亚、九重 クレア、ここのえ クレア、Kokonoe Kurea 女 千本木彩花 6 高圆礼奈 高円 レイナ、たかまど レイナ、Takamado Reina 女 三澤紗千香 7 海豹 あざらし M・A・O 8 黑影人 小黑、黒い犯人 男 / 女","date":"2013-07-04","objectID":"/anime/going_home_club/:2:0","tags":null,"title":"归宅部活动记录","uri":"/anime/going_home_club/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 归宅部活动记录 2013-07-04 12 bilibili ","date":"2013-07-04","objectID":"/anime/going_home_club/:3:0","tags":null,"title":"归宅部活动记录","uri":"/anime/going_home_club/"},{"categories":null,"content":"　　「为了让来未回想起活着的感觉，我成为了人类。」\n　　春和来未过着平淡而幸福的生活。本以为会一直这样下去，突如其来的飞机事故却打破了这一切。\n　　刚吵完架还没有解开误会的来未就这么失去了至爱的春，来未失去了活下去的力气。\n　　为了找回春的笑容，来未找来了和春长相一摸一样的智能机器人。于是，来未和机器人春生活在了一起。机器人春的依靠是来未曾经写下愿望的——魔方。只要对齐魔方的颜色，就能够看到来未满溢的思念。\n　　正当机器人春和来未渐渐的接受了对方，这时却……\n\n　　《HAL》以近未来为背景，是一部描写人和机器人传奇般的爱情故事的中篇动画。故事讲述了在一场事故中失去了至爱的主人公和替身机器人开始交心的悲剧感情故事。\n　　剧场版动画「HAL」请来了以描绘细腻感情著称的漫画家咲坂伊绪担当动画人设原案，而导演则是曾参与动画「四畳半神话大系」、「罪恶王冠」等作品制作的牧原亮太郎负责，动画脚本时活跃在电视剧、舞台剧等创作领域的脚本家木皿泉，他过去的代表作有知名电视剧「野猪大改造」。而动画的世界观以及视觉效果设计则依然是由艺术家清川浅见负责。音乐方面，本作请来了曾为「钢之炼金术师」、「四畳半神话大系」等作配乐的大岛满，相信配合张新锐制作公司WIT STUDIO的动画制作。\n","date":"2013-06-08","objectID":"/anime/hal/","tags":null,"title":"HAL","uri":"/anime/hal/"},{"categories":null,"content":"简介 「为了让来未回想起活着的感觉，我成为了人类。」 春和来未过着平淡而幸福的生活。本以为会一直这样下去，突如其来的飞机事故却打破了这一切。 刚吵完架还没有解开误会的来未就这么失去了至爱的春，来未失去了活下去的力气。 为了找回春的笑容，来未找来了和春长相一摸一样的智能机器人。于是，来未和机器人春生活在了一起。机器人春的依靠是来未曾经写下愿望的——魔方。只要对齐魔方的颜色，就能够看到来未满溢的思念。 正当机器人春和来未渐渐的接受了对方，这时却…… 《HAL》以近未来为背景，是一部描写人和机器人传奇般的爱情故事的中篇动画。故事讲述了在一场事故中失去了至爱的主人公和替身机器人开始交心的悲剧感情故事。","date":"2013-06-08","objectID":"/anime/hal/:1:0","tags":null,"title":"HAL","uri":"/anime/hal/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 春 男 細谷佳正 2 来未 胡桃 女 日笠陽子 3 龙 男 宮野真守 ","date":"2013-06-08","objectID":"/anime/hal/:2:0","tags":null,"title":"HAL","uri":"/anime/hal/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 HAL 2013-06-08 1 bilibili ","date":"2013-06-08","objectID":"/anime/hal/:3:0","tags":null,"title":"HAL","uri":"/anime/hal/"},{"categories":null,"content":"作品以爱情来临前的孤独——“孤悲”来呈现“恋爱”的主题。梅雨时节，以成为鞋匠为目标的高中生孝雄与神秘的女性百香里，在雨中的日本庭园中相遇。以女性留给少年的一篇万叶集为契机，故事就此开展……。","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"简介 作品以爱情来临前的孤独——“孤悲”来呈现“恋爱”的主题。梅雨时节，以成为鞋匠为目标的高中生孝雄与神秘的女性百香里，在雨中的日本庭园中相遇。以女性留给少年的一篇万叶集为契机，故事就此开展……。 制作人员： 原作：新海诚 音乐：柏 大辅 人物设定：土屋坚一 美术监督：泷口比吕志 色彩设计：三木阳子 ","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/:1:0","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 秋月孝雄 タカオ、あきづきたかお 男 入野自由 2 雪野百香里 ユキちゃん先生、ユキノ、雪野 百香里、ゆきの ゆかり、Yukino Yukari 女 花澤香菜 3 タカオの母 女 平野文 4 タカオの兄の彼女 女 寺崎裕香 5 タカオの兄 男 前田剛 6 松本 男 井上優 7 佐藤 女 潘めぐみ 8 相泽 あいざわ、Aizawa 女 小松未可子 ","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/:2:0","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 言叶之庭 2013-05-31 46min bilibili ","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/:3:0","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"MAD ","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/:4:0","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"刚升上高中一年级的佐藤一郎，某天在晚上潜入学校拿东西时，遇见了身穿蓝色斗篷，拿着金属杖的美少女。自从遇到她之后，佐藤期望的平稳学生生活渐渐的离他而去。","date":"2013-04-13","objectID":"/anime/aura/","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"简介 刚升上高中一年级的佐藤一郎，某天在晚上潜入学校拿东西时，遇见了身穿蓝色斗篷，拿着金属杖的美少女。自从遇到她之后，佐藤期望的平稳学生生活渐渐的离他而去。 制作人员： 原作：田中罗密欧 导演：岸诚二 脚本：熊谷纯 分镜：田口智久、斋藤久 演出：西本由纪夫、小坂春女 音乐：大岛满 ","date":"2013-04-13","objectID":"/anime/aura/:1:0","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐藤一郎 Men’s佐藤、魔龙院光牙、佐藤 一郎、さとう いちろう 男 島﨑信長 2 佐藤良子 佐藤　良子、さとう　りょうこ、Satou Ryouko 女 花澤香菜 ","date":"2013-04-13","objectID":"/anime/aura/:2:0","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 AURA ～魔龙院光牙最后的战斗～ 2013-04-13 83m bilibili ","date":"2013-04-13","objectID":"/anime/aura/:3:0","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"MAD ","date":"2013-04-13","objectID":"/anime/aura/:4:0","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"免费游戏制作者Dark†Knight（网名）今天也在苦于作品都不叫座而闷在家中发霉。某一天，他突然收到了一位热情洋溢的女粉丝发来的邮件。Dark†Knight，年方二十七岁，这个站在摇摇欲坠的断崖峭壁上，活在社会最底层的男人，他的人生即将因为与她的相遇而充满了光明。\n\n从此驱使Dark†Knight制作游戏的原动力从“想被社会所认可”转变成了对这位女性的爱慕之心。到了2013年，他突然有股预感，现在的自己能够制作出与至今为止的作品完全不同的杰作。\n\n与此同时，在他所经营的网站“极乐天堂”上，忠实用户们也依然在随心所欲地发着各种内容。其中一位老用户J.B由于Dark†Knight出现频率大幅下降而气急败坏，频频在“极乐天堂”的论坛上发泄着他的怨气——“黑企还不出新作吗，你要摸到什么时候啊垃圾作者快出新作”。\n\n终于有一天，Dark†Knight本人突然出现，并留下了一句话。\n\n“新作将在愚人节发布”\n\n愚人节当天，一部游戏出现在了论坛上，其名为《第七境》。然而，从游戏下载完成的那一刻开始，Dark†Knight和网站的忠实用户们便穿越到了RPG世界观的异世界！\n\n充满纯情以及绝望的网站联动型meta幻想故事就此拉开了帷幕！","date":"2013-04-06","objectID":"/game/seventh_coat/","tags":null,"title":"第七境","uri":"/game/seventh_coat/"},{"categories":null,"content":"简介 免费游戏制作者Dark†Knight（网名）今天也在苦于作品都不叫座而闷在家中发霉。某一天，他突然收到了一位热情洋溢的女粉丝发来的邮件。Dark†Knight，年方二十七岁，这个站在摇摇欲坠的断崖峭壁上，活在社会最底层的男人，他的人生即将因为与她的相遇而充满了光明。 从此驱使Dark†Knight制作游戏的原动力从“想被社会所认可”转变成了对这位女性的爱慕之心。到了2013年，他突然有股预感，现在的自己能够制作出与至今为止的作品完全不同的杰作。 与此同时，在他所经营的网站“极乐天堂”上，忠实用户们也依然在随心所欲地发着各种内容。其中一位老用户J.B由于Dark†Knight出现频率大幅下","date":"2013-04-06","objectID":"/game/seventh_coat/:1:0","tags":null,"title":"第七境","uri":"/game/seventh_coat/"},{"categories":null,"content":"系列 系列名 发行时间 1 第七境 2013-04-06 ","date":"2013-04-06","objectID":"/game/seventh_coat/:2:0","tags":null,"title":"第七境","uri":"/game/seventh_coat/"},{"categories":null,"content":"悠长的历史之中,人类曾一度因被巨人捕食而崩溃。幸存下来的人们建造了一面巨大的墙壁,防止了巨人的入侵。不过,作为“和平”的代价,人类失去了到墙壁的外面去这一“自由”。主人公艾伦·耶格尔对还没见过的外面的世界抱有兴趣。在他正做着到墙壁的外面去这个梦的时候,毁坏墙壁的大巨人出现了！","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"简介 悠长的历史之中,人类曾一度因被巨人捕食而崩溃。幸存下来的人们建造了一面巨大的墙壁,防止了巨人的入侵。不过,作为“和平”的代价,人类失去了到墙壁的外面去这一“自由”。主人公艾伦·耶格尔对还没见过的外面的世界抱有兴趣。在他正做着到墙壁的外面去这个梦的时候,毁坏墙壁的大巨人出现了！ 制作人员： 原作：谏山创 导演：荒木哲郎 脚本：高木登、小林靖子、濑古浩司 分镜：別所诚人、小松田大全、大原实 ","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/:1:0","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾伦·耶格尔 艾连・叶卡、Eren Yeager 男 梶裕貴 2 三笠·阿克曼 米卡莎・阿卡曼、Mikasa Ackerman 女 石川由依 3 阿明·阿诺德 阿尔敏·亚鲁雷特、艾尔敏·阿莱尔特、爱尔敏·亚鲁雷特、Armin Arlert 男？ 井上麻里奈 4 利威尔 利维尔、兵长、一米六、里维、Levi、李白 男 神谷浩史 5 让·基尔休坦 Jean Kirstein 男 谷山紀章 6 克里斯塔·连兹 Historia Reiss、ヒストリア・レイス、希斯特莉亚·雷斯、Krista Lenz 女 三上枝織 7 柯尼·史普林格 Connie Springer","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/:2:0","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 进击的巨人 2013-04-06 25 樱花 2 进击的巨人 第二季 2017-04-01 12 樱花 3 进击的巨人 第三季 2018-07-22 12 樱花 4 进击的巨人 第三季 Part.2 2019-04-28 10 樱花 5 进击的巨人 最终季 2020-12-06 16 樱花 6 进击的巨人 最终季 Part.2 2022-01-09 12 樱花 ","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/:3:0","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"MAD ","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/:4:0","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"以说博多腔的人鱼室见小姐以及常钓到室见的少年向岛拓郎为中心，描写人类与传说生物之间的搞笑互动。","date":"2013-04-06","objectID":"/anime/muromi_san/","tags":null,"title":"人鱼又上钩","uri":"/anime/muromi_san/"},{"categories":null,"content":"简介 以说博多腔的人鱼室见小姐以及常钓到室见的少年向岛拓郎为中心，描写人类与传说生物之间的搞笑互动。 制作人员： 原作：名岛启二 导演：吉原达矢 脚本：笔安一幸、凉村千夏 分镜：濑藤健嗣、中村宪由、中野英明 演出：野木森达哉 ","date":"2013-04-06","objectID":"/anime/muromi_san/:1:0","tags":null,"title":"人鱼又上钩","uri":"/anime/muromi_san/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 室见小姐 女 田村ゆかり 2 向岛拓朗 向島 拓朗、むこうじま たくろう、Mukōjima Takurō 男 水島大宙 3 小樋 女 野中藍 4 隅田 女 上坂すみれ 5 富士 女 原田ひとみ 6 利维雅 女 中原麻衣 7 哈比 女 さかいかな 8 耶提 不明 斎藤千和 ","date":"2013-04-06","objectID":"/anime/muromi_san/:2:0","tags":null,"title":"人鱼又上钩","uri":"/anime/muromi_san/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 人鱼又上钩 2013-04-06 13 樱花 ","date":"2013-04-06","objectID":"/anime/muromi_san/:3:0","tags":null,"title":"人鱼又上钩","uri":"/anime/muromi_san/"},{"categories":null,"content":"管你是魔王还是勇者，想填饱肚子就得工作！\n原本即将征服世界的魔王撒旦却遭勇者击败，被迫漂流到异世界“日本”。为了赚取生活费，魔王将三坪大的公寓当成临时魔王城，开始过着打工族的生活。没想到勇者竟追随他的脚步穿越时空而来……一出平民路线的奇幻故事就此展开！","date":"2013-04-04","objectID":"/anime/the_devil_is_a_part_timer/","tags":null,"title":"打工吧！魔王大人","uri":"/anime/the_devil_is_a_part_timer/"},{"categories":null,"content":"简介 管你是魔王还是勇者，想填饱肚子就得工作！ 原本即将征服世界的魔王撒旦却遭勇者击败，被迫漂流到异世界“日本”。为了赚取生活费，魔王将三坪大的公寓当成临时魔王城，开始过着打工族的生活。没想到勇者竟追随他的脚步穿越时空而来……一出平民路线的奇幻故事就此展开！ 制作人员： 原作：和之原聪司 导演：细田直人 脚本：横谷昌宏、下山健人、待田堂子 分镜：新留俊哉、增井壮一、岩畑刚一、村川健一郎 ","date":"2013-04-04","objectID":"/anime/the_devil_is_a_part_timer/:1:0","tags":null,"title":"打工吧！魔王大人","uri":"/anime/the_devil_is_a_part_timer/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 真奥贞夫 魔王撒旦、魔王サタン、サタン・ジャコブ、まおう さだお、Maou Sadao 男 逢坂良太 2 游佐惠美 勇者エミリア、艾米莉亚·尤斯提纳、Emilia Justina、エミリア・ユスティーナ、ゆさ えみ、Yusa Emi、勇者 女 日笠陽子 3 东海林佳织 女 山崎はるか 4 中山孝太郎 男 花江夏樹 5 佐佐木里穗 女 本田貴子 6 芦屋四郎 艾尔西尔、Alsiel、アルシエル、あしや しろう、Ashiya Shirou、管家 男 小野友樹 7 漆原半藏 路西菲尔、Lucifer、ルシフェル、うるしはら はんぞう、Urushihara Hanz","date":"2013-04-04","objectID":"/anime/the_devil_is_a_part_timer/:2:0","tags":null,"title":"打工吧！魔王大人","uri":"/anime/the_devil_is_a_part_timer/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 打工吧！魔王大人 2013-04-04 13 bilibili ","date":"2013-04-04","objectID":"/anime/the_devil_is_a_part_timer/:3:0","tags":null,"title":"打工吧！魔王大人","uri":"/anime/the_devil_is_a_part_timer/"},{"categories":null,"content":"　　别扭的，没有朋友，没有女朋友，对着那些讴歌青春的同学吐槽着“他们都是骗子，都在说谎，快点爆发把我”的男主角的爱情物语，将来的梦想是“不工作”——\n这样的高中生八幡被生活指导老师的带到了学校第一美少女雪乃所属的“侍奉部”，与美少女意想不到的相遇……怎么想都是恋爱故事的展开吧！？\n但是雪乃却无论如何都原谅不了八幡那令人残念的糟糕性格！\n不断轮回着的充满问题的青春——我的青春，到底怎么了！？","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"简介 别扭的，没有朋友，没有女朋友，对着那些讴歌青春的同学吐槽着“他们都是骗子，都在说谎，快点爆发把我”的男主角的爱情物语，将来的梦想是“不工作”—— 这样的高中生八幡被生活指导老师的带到了学校第一美少女雪乃所属的“侍奉部”，与美少女意想不到的相遇……怎么想都是恋爱故事的展开吧！？ 但是雪乃却无论如何都原谅不了八幡那令人残念的糟糕性格！ 不断轮回着的充满问题的青春——我的青春，到底怎么了！？ 制作人员： 原作：渡航 导演：吉村爱 脚本：高山克彦、待田堂子、菅正太郎 分镜：RoydenB、高桥秀弥、工藤利春 ","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/:1:0","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 比企谷八幡 大老师、比企谷 八幡、ひきがや はちまん、Hikigaya Hachiman、ヒッキー 男 江口拓也 2 雪之下雪乃 雪基百科、Yukino Yukinoshita、雪ノ下 雪乃、ゆきのした ゆきの、Yukinoshita Yukino、二小姐 女 早見沙織 3 由比滨结衣 ゆいがはま ゆい、Yuigahama Yui、团子 女 東山奈央 4 户冢彩加 戸塚 彩加、とつか さいか、Totsuka Saika 男 小松未可子 5 材木座义辉 材木座 義輝、Zaimokuza Yoshiteru 男 檜山修之 6 比企谷小町 ひきがや こまち、Hik","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/:2:0","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我的青春恋爱物语果然有问题 2013-04-04 13 bilibili 2 我的青春恋爱物语果然有问题 OVA 2013-09-19 1 bilibili 3 我的青春恋爱物语果然有问题 续 2015-04-02 13 bilibili 4 我的青春恋爱物语果然有问题 续 OVA 2016-10-27 1 bilibili 5 我的青春恋爱物语果然有问题 完 2020-07-09 12 bilibili ","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/:3:0","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"MAD ","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/:4:0","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"就读凤城学园的15岁少女泉水子，自少便在熊野古道的玉仓神社之中长大。泉水子是名颇害羞的少女，而且所有给她触碰到的电子产品也必定损坏。当她想到想离开这熊野古道并往城巿里居住的时候，她的监护人雪政却建议她往东京的鳯城学园就读，并逼他的儿子深行与泉水子同行，以便照顾她。起初，泉水子与深行也互相讨厌大家，但当一件怪异的事件发生在今年以「战国时代」为主题的学园祭上，他们的关系便产生变化。在这事件中，泉水子得知她是姬神的最后一名依代，而深行则是泉水子的山伏守护者。作为姬神的最后一名依代，作为濒临灭絶的姬神依代，泉水子与深行将展开改变世界的事件。 ","date":"2013-04-03","objectID":"/anime/red_data_girl/","tags":null,"title":"RDG 濒危物种少女","uri":"/anime/red_data_girl/"},{"categories":null,"content":"简介 就读凤城学园的15岁少女泉水子，自少便在熊野古道的玉仓神社之中长大。泉水子是名颇害羞的少女，而且所有给她触碰到的电子产品也必定损坏。当她想到想离开这熊野古道并往城巿里居住的时候，她的监护人雪政却建议她往东京的鳯城学园就读，并逼他的儿子深行与泉水子同行，以便照顾她。起初，泉水子与深行也互相讨厌大家，但当一件怪异的事件发生在今年以「战国时代」为主题的学园祭上，他们的关系便产生变化。在这事件中，泉水子得知她是姬神的最后一名依代，而深行则是泉水子的山伏守护者。作为姬神的最后一名依代，作为濒临灭絶的姬神依代，泉水子与深行将展开改变世界的事件。 制作人员： 原作：荻原规子 导演：筱原俊哉 脚本：横手","date":"2013-04-03","objectID":"/anime/red_data_girl/:1:0","tags":null,"title":"RDG 濒危物种少女","uri":"/anime/red_data_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 铃原泉水子 鈴原 泉水子、すずはら いずみこ、Suzuhara Izumiko 女 早見沙織 2 相乐深行 さがら みゆき、Sagara Miyuki 男 内山昂輝 3 宗田真响 宗田 真響、そうだ まゆら、Souda Mayura 女 米澤円 4 宗田真夏 宗田 真夏、そうだ まなつ、Souda Manatsu 男 石川界人 5 宗田真澄 宗田 真澄、そうだ ますみ 男 木村良平 6 高柳一条 高柳 一条、たかやなぎ いちじょう、Takayanagi Ichijō 男 野島裕史 7 如月·珍·仄香 きさらぎ・ジーン・ほのか 女 ブリドカットセーラ恵美 8 ","date":"2013-04-03","objectID":"/anime/red_data_girl/:2:0","tags":null,"title":"RDG 濒危物种少女","uri":"/anime/red_data_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 RDG 濒危物种少女 2013-04-03 12 bilibili ","date":"2013-04-03","objectID":"/anime/red_data_girl/:3:0","tags":null,"title":"RDG 濒危物种少女","uri":"/anime/red_data_girl/"},{"categories":null,"content":"      某个已经对世界厌烦的男生——逆回十六夜收到了一封邀请函，当他看清信中内容写着：「望你舍弃一切，前来‘箱庭’」的瞬间，他被带到奇妙的异世界！眼前是带著猫的沉默少女与态度高傲的大小姐，还有召唤他们的罪魁祸首──黑兔。当黑兔正在说明箱庭世界的规则时，十六夜却突然表示：「来打倒魔王吧！」，但黑兔并没有拜托那种事情呀！于是三个超级问题儿和萌少女黑兔的「打倒魔王」冒险故事开始上演！？","date":"2013-01-11","objectID":"/anime/problem_children/","tags":null,"title":"问题儿童都来自异世界？","uri":"/anime/problem_children/"},{"categories":null,"content":"简介 某个已经对世界厌烦的男生——逆回十六夜收到了一封邀请函，当他看清信中内容写着：「望你舍弃一切，前来‘箱庭’」的瞬间，他被带到奇妙的异世界！眼前是带著猫的沉默少女与态度高傲的大小姐，还有召唤他们的罪魁祸首──黑兔。当黑兔正在说明箱庭世界的规则时，十六夜却突然表示：「来打倒魔王吧！」，但黑兔并没有拜托那种事情呀！于是三个超级问题儿和萌少女黑兔的「打倒魔王」冒险故事开始上演！？ 制作人员： 原作：龙之湖太郎 导演：山本靖贵 脚本：白根秀树、木村畅、山田靖智 分镜：三宅雄一郎、所俊克、吉田泰三 ","date":"2013-01-11","objectID":"/anime/problem_children/:1:0","tags":null,"title":"问题儿童都来自异世界？","uri":"/anime/problem_children/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 逆回十六夜 逆廻 十六夜、さかまき いざよい、Sakamaki Izayoi 男 浅沼晋太郎 2 久远飞鸟 久遠 飛鳥、くどう あすか、Kudou Asuka 女 ブリドカットセーラ恵美 3 春日部耀 春日部 耀、かすかべ よう、Kasukabe You 女 中島愛 4 黑兔 くろウサギ、Kurousagi、受兔 女 野水伊織 5 莉莉 リリ、Riri 女 三上枝織 6 白夜叉 しろやしゃ、Shiroyasha 女 新井里美 7 仁·拉塞尔 ジン・ラッセル、Jin Rasseru 男 五十嵐裕美 8 蕾蒂西亚·德克雷亚 レーティシア・ドラクレア 女 巽悠衣子","date":"2013-01-11","objectID":"/anime/problem_children/:2:0","tags":null,"title":"问题儿童都来自异世界？","uri":"/anime/problem_children/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 问题儿童都来自异世界？ 2013-01-11 10 bilibili 2 问题儿童都来自异世界？ OAD 2013-07-21 1 bilibili ","date":"2013-01-11","objectID":"/anime/problem_children/:3:0","tags":null,"title":"问题儿童都来自异世界？","uri":"/anime/problem_children/"},{"categories":null,"content":"原作是由江之木津（えのきづ）绘制的四格漫画，讲述拥有读心术的少女琴浦，和她喜欢的少年真锅君，以及同班同学兼esp研究会员鸟卷，以及其他社员在一起的校园恋爱剧。","date":"2013-01-10","objectID":"/anime/miss_kotoura/","tags":null,"title":"琴浦小姐","uri":"/anime/miss_kotoura/"},{"categories":null,"content":"简介 原作是由江之木津（えのきづ）绘制的四格漫画，讲述拥有读心术的少女琴浦，和她喜欢的少年真锅君，以及同班同学兼esp研究会员鸟卷，以及其他社员在一起的校园恋爱剧。 制作人员： 原作：enokids 导演：太田雅彦 脚本：青岛崇 分镜：今泉贤一、林宏树、三原武宪、玉川真人、田村正文、小泽一浩 ","date":"2013-01-10","objectID":"/anime/miss_kotoura/:1:0","tags":null,"title":"琴浦小姐","uri":"/anime/miss_kotoura/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 琴浦春香 ことうら はるか、Kotoura Haruka 女 金元寿子 2 真锅义久 まなべ よしひさ、Yoshihisa Manabe、エロス（の貴公子） 男 福島潤 3 御舟百合子 みふね ゆりこ、Yuriko Mifune 女 花澤香菜 4 森谷日和 もりたに ヒヨリ、Hiyori Moritani 女 久保ユリカ 5 室户大智 室戸 大智、むろと だいち、Muroto Daichi 男 下野紘 6 路人 モブ、モブキャラ、闲角、mob character、端役、エキストラ、extra 飯田友子 ","date":"2013-01-10","objectID":"/anime/miss_kotoura/:2:0","tags":null,"title":"琴浦小姐","uri":"/anime/miss_kotoura/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 琴浦小姐 2013-01-10 12 bilibili ","date":"2013-01-10","objectID":"/anime/miss_kotoura/:3:0","tags":null,"title":"琴浦小姐","uri":"/anime/miss_kotoura/"},{"categories":null,"content":"改编自号称“四格小说”的同名轻小说。\n故事主要讲述了主人公四之宫京夜与他所属的活动内容不明的GJ部的部员们——有着要强性格的部长天使真央、游戏天才皇紫音、性格我行我素的天使惠、身体丰满的绮罗々・伯恩斯坦以及之后的新入部员的神无月环交织而成的日常小故事。","date":"2013-01-09","objectID":"/anime/gj_club/","tags":null,"title":"GJ部","uri":"/anime/gj_club/"},{"categories":null,"content":"简介 改编自号称“四格小说”的同名轻小说。 故事主要讲述了主人公四之宫京夜与他所属的活动内容不明的GJ部的部员们——有着要强性格的部长天使真央、游戏天才皇紫音、性格我行我素的天使惠、身体丰满的绮罗々・伯恩斯坦以及之后的新入部员的神无月环交织而成的日常小故事。 制作人员： 原作：新木伸 导演：藤原佳幸 脚本：子安秀明 分镜：冲田宫奈、原口浩、井出安轨、三原武宪、青井小夜 ","date":"2013-01-09","objectID":"/anime/gj_club/:1:0","tags":null,"title":"GJ部","uri":"/anime/gj_club/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 四之宫京夜 四ノ宮 京夜、しのみや きょうや 男 下野紘 2 天使真央 天使 真央、あまつか まお、Amatsuka Mao 女 内田真礼 3 皇紫音 皇 紫音、すめらぎ しおん 女 三森すずこ 4 天使惠 天使 恵、あまつか めぐみ、Amatsuka Megumi 女 宮本侑芽 5 绮罗罗·伯恩斯坦 きらら・バーンシュタイン 女 荒川ちか 6 神无月环 神無月 環、かんなづき たまき、Kannaduki Tamaki、タマ 女 上坂すみれ 7 四之宫霞 四ノ宮 霞、しのみや かすみ 女 木戸衣吹 8 森小姐 もりさん 女 恒松あゆみ ","date":"2013-01-09","objectID":"/anime/gj_club/:2:0","tags":null,"title":"GJ部","uri":"/anime/gj_club/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 GJ部 2013-01-09 12 bilibili 2 GJ部@ 2014-05-05 1 bilibili ","date":"2013-01-09","objectID":"/anime/gj_club/:3:0","tags":null,"title":"GJ部","uri":"/anime/gj_club/"},{"categories":null,"content":"位于东京都千代田区的传统高校“音乃木阪学院”，因为入读的学生人数骤减，所以正面临着废校的危机。其中九位少女为了保护她们喜爱的学校而决定成为偶像，因为只要她们成为偶像，学校的名气便会増加，而入读学生的人数也会随之上升。就这样，九位个性鲜明的少女开始朝着她们的偶像之路而努力迈进了！","date":"2013-01-06","objectID":"/anime/love_live/","tags":null,"title":"Love Live!","uri":"/anime/love_live/"},{"categories":null,"content":"简介 位于东京都千代田区的传统高校“音乃木阪学院”，因为入读的学生人数骤减，所以正面临着废校的危机。其中九位少女为了保护她们喜爱的学校而决定成为偶像，因为只要她们成为偶像，学校的名气便会増加，而入读学生的人数也会随之上升。就这样，九位个性鲜明的少女开始朝着她们的偶像之路而努力迈进了！ 制作人员： 原作：矢立肇 导演：京极尚彦 脚本：子安秀明、花田十辉 分镜：酒井和男、渡边哲哉、古田丈司 演出：三宅和男 ","date":"2013-01-06","objectID":"/anime/love_live/:1:0","tags":null,"title":"Love Live!","uri":"/anime/love_live/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 高坂穗乃果 Kousaka Honoka、こうさか ほのか、Kousaka Honoka、穗乃果、穗乃果酱、果果、穂乃果ちゃん、果皇 女 新田恵海 2 绚濑绘里 KKE、エリーチカ、あやせ えり、Ayase Eri、绘里、绘里酱、绘里亲、エリー、エリチカ、Эри Аясэ 女 南條愛乃 3 南琴梨 南小鸟、みなみ ことり、Minami Kotori、小鸟、小鸟酱、ことりちゃん、Minalinsky 女 内田彩 4 园田海未 颜艺、海爷、園田海未、そのだ うみ、Sonoda Umi、海未、海未酱、海未ちゃん 女 三森すずこ 5 星空凛 星空 凛、ほしぞら りん","date":"2013-01-06","objectID":"/anime/love_live/:2:0","tags":null,"title":"Love Live!","uri":"/anime/love_live/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Love Live! 2013-01-06 13 bilibili 2 Love Live! 第二季 2014-04-06 13 bilibili 3 Love Live! 学园偶像 电影 2015-06-13 1 bilibili ","date":"2013-01-06","objectID":"/anime/love_live/:3:0","tags":null,"title":"Love Live!","uri":"/anime/love_live/"},{"categories":null,"content":"MAD ","date":"2013-01-06","objectID":"/anime/love_live/:4:0","tags":null,"title":"Love Live!","uri":"/anime/love_live/"},{"categories":null,"content":"主人公季堂锐太是个成绩优秀的高中一年级学生，同时也是个恋爱反对派。本来是和像自己妹妹一般的青梅竹马一起过着普通的高中生活的，但某天却被校内公认的第一美人，归国子女夏川真凉表白了。然而真凉的真实意图却是为了骗过众人而需要锐太与她假扮情侣。被真凉掌握了自己的某个“秘密”的锐太被迫假扮“男友”这一角色……之后“前女友”姬香、“未婚妻”爱衣也加了进来，围绕锐太的壮烈修罗场就此拉开帷幕！","date":"2013-01-05","objectID":"/anime/oreshura/","tags":null,"title":"我女友与青梅竹马的惨烈修罗场","uri":"/anime/oreshura/"},{"categories":null,"content":"简介 主人公季堂锐太是个成绩优秀的高中一年级学生，同时也是个恋爱反对派。本来是和像自己妹妹一般的青梅竹马一起过着普通的高中生活的，但某天却被校内公认的第一美人，归国子女夏川真凉表白了。然而真凉的真实意图却是为了骗过众人而需要锐太与她假扮情侣。被真凉掌握了自己的某个“秘密”的锐太被迫假扮“男友”这一角色……之后“前女友”姬香、“未婚妻”爱衣也加了进来，围绕锐太的壮烈修罗场就此拉开帷幕！ 制作人员： 原作：裕时悠示 导演：龟井干太 脚本：浦畑达彦、富田赖子 分镜：福田道生、柳沼和良 ","date":"2013-01-05","objectID":"/anime/oreshura/:1:0","tags":null,"title":"我女友与青梅竹马的惨烈修罗场","uri":"/anime/oreshura/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 季堂锐太 季堂 鋭太、きどう えいた、Kidou Eita 男 逢坂良太 2 春咲千和 春咲 千和、はるさき ちわ、Harusaki Chiwa、Chiwawa，吉娃娃 女 赤﨑千夏 3 夏川真凉 夏川 真涼、なつかわ ますず、Natsukawa Masuzu 女 田村ゆかり 4 秋筱姬香 秋篠 姫香、あきしの ひめか、Akishino Himeka 女 金元寿子 5 冬海爱衣 冬海 愛衣、ふゆうみ あい、Fuyuumi Ai 女 茅野愛衣 6 夏川真那 夏川 真那、なつかわ まな 女 東山奈央 7 游井薰 遊井 カオル、あそい カオル 種田梨沙 8 桐生冴","date":"2013-01-05","objectID":"/anime/oreshura/:2:0","tags":null,"title":"我女友与青梅竹马的惨烈修罗场","uri":"/anime/oreshura/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我女友与青梅竹马的惨烈修罗场 2013-01-05 13 bilibili ","date":"2013-01-05","objectID":"/anime/oreshura/:3:0","tags":null,"title":"我女友与青梅竹马的惨烈修罗场","uri":"/anime/oreshura/"},{"categories":null,"content":"      这是一个人类与魔族持续着征战的世界。\n      某日，拥有着强大力量的“勇者”闯入了魔王的城堡，他为了拯救人类世界而向魔王挑战。但是，等着他的却是一位外貌与人类女性极其相似的“魔王”。这位魔王并没有选择与勇者开战，而是希望立下让勇者成为她的所有物的契约。而面对着一口回绝并要求决斗的勇者，魔王开始冷静地向勇者分析了人类与魔族间的实际情形，分析了当下的社会秩序是依存于这场战争的这一事实，还分析了即便是在打倒魔王后也无法在根本上解决这场战争的源头的这个真相。\n      魔王本人希冀的是新的可能性——既不是战争结束后的悲惨结局，也不是使战争继续延续下去。勇者在明白了魔王为何需要他的协助之后，决定接受她的契约，帮助她完成心愿。于是，勇者和魔王隐藏了各自的真实身份，以一介剑士和一名学者的名义，开始改革这个世界。","date":"2013-01-04","objectID":"/anime/maoyu/","tags":null,"title":"魔王勇者","uri":"/anime/maoyu/"},{"categories":null,"content":"简介 这是一个人类与魔族持续着征战的世界。 某日，拥有着强大力量的“勇者”闯入了魔王的城堡，他为了拯救人类世界而向魔王挑战。但是，等着他的却是一位外貌与人类女性极其相似的“魔王”。这位魔王并没有选择与勇者开战，而是希望立下让勇者成为她的所有物的契约。而面对着一口回绝并要求决斗的勇者，魔王开始冷静地向勇者分析了人类与魔族间的实际情形，分析了当下的社会秩序是依存于这场战争的这一事实，还分析了即便是在打倒魔王后也无法在根本上解决这场战争的源头的这个真相。 魔王本人希冀的是新的可能性——既不是战争结束后的悲惨结局，也不是使战争继续延续下去。勇者在明白了魔王为何需要他的协助之后，决定接受她的契约，帮助她","date":"2013-01-04","objectID":"/anime/maoyu/:1:0","tags":null,"title":"魔王勇者","uri":"/anime/maoyu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 魔王 Maou、まおう 女 小清水亜美 2 勇者 Yuusha、ゆうしゃ 男 福山潤 3 女骑士 Female Knight、おんなきし、Onna Kishi 女 沢城みゆき 4 女仆长 Chief Maid、メイドちょう、Maid Chou 女 斎藤千和 5 女仆姐 Big Sister Maid、メイドあね、Maid Ane 女 戸松遥 6 女仆妹 Little Sister Maid、メイドいもうと、Maid Imouto 女 東山奈央 7 女魔法使 おんなまほうつかい、Onna Mahoutsukai 女 福圓美里 8 火龙公女 女 伊藤静 ","date":"2013-01-04","objectID":"/anime/maoyu/:2:0","tags":null,"title":"魔王勇者","uri":"/anime/maoyu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔王勇者 2013-01-04 12 bilibili ","date":"2013-01-04","objectID":"/anime/maoyu/:3:0","tags":null,"title":"魔王勇者","uri":"/anime/maoyu/"},{"categories":null,"content":"MAD ","date":"2013-01-04","objectID":"/anime/maoyu/:4:0","tags":null,"title":"魔王勇者","uri":"/anime/maoyu/"},{"categories":null,"content":"在古都镰仓的一所中学，升上初中二年级的关健二，在早晨的海边，同将爱慕之意埋藏于心底的学生会书记春河佳惠梨开始了初次的对话。与他是青梅竹马又是佳惠梨的好友的凉浦夏希，怀着复杂的心情在一旁看着他们。然后，健二在高台上与沐浴着樱花花瓣，仿佛能操纵风力的少年遭遇。这个少年看着有几分不可思议，而和他的再会也比预想中的更早——这个少年正是转到健二班上的转校生——京极龙一，在健二，夏希，佳惠梨所在班级出现的京极，马上融入班级的氛围，却又好似浮现出一丝与周围气氛不相容的东西。佳惠梨开始悄悄的注意着京极。突如其来，学园不可思议的突发事件开始了。事件不仅牵涉到健二、夏希、佳惠梨，学生会的各方面，班主任，健二的祖父关耕儿，甚至连休学中的山际百合子一行人也被卷入其中。各种各样的心思开始浮出水面，健二和夏希的距离感也开始发生显而易见的变化。最后，京极究竟是谁？而学园里又正发生着什么……","date":"2012-11-10","objectID":"/anime/psychic_school_wars/","tags":null,"title":"被狙击的学园","uri":"/anime/psychic_school_wars/"},{"categories":null,"content":"简介 在古都镰仓的一所中学，升上初中二年级的关健二，在早晨的海边，同将爱慕之意埋藏于心底的学生会书记春河佳惠梨开始了初次的对话。与他是青梅竹马又是佳惠梨的好友的凉浦夏希，怀着复杂的心情在一旁看着他们。然后，健二在高台上与沐浴着樱花花瓣，仿佛能操纵风力的少年遭遇。这个少年看着有几分不可思议，而和他的再会也比预想中的更早——这个少年正是转到健二班上的转校生——京极龙一，在健二，夏希，佳惠梨所在班级出现的京极，马上融入班级的氛围，却又好似浮现出一丝与周围气氛不相容的东西。佳惠梨开始悄悄的注意着京极。突如其来，学园不可思议的突发事件开始了。事件不仅牵涉到健二、夏希、佳惠梨，学生会的各方面，班主任，健二","date":"2012-11-10","objectID":"/anime/psychic_school_wars/:1:0","tags":null,"title":"被狙击的学园","uri":"/anime/psychic_school_wars/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 关健二 ケンジ、kenji 男 本城雄太郎 2 凉浦夏希 ナツキ、natsuki 女 渡辺麻友 3 京极龙一 京極、kyogoku 男 小野大輔 4 春河佳惠梨 カホリ、kahori 女 花澤香菜 5 神野宇 男 木村良平 6 山際ゆりこ 女 戸松遥 7 齐藤 塞钱 男 木内秀信 8 使魔 平田広明 ","date":"2012-11-10","objectID":"/anime/psychic_school_wars/:2:0","tags":null,"title":"被狙击的学园","uri":"/anime/psychic_school_wars/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 被狙击的学园 2012-11-10 1:46:31 bilibili ","date":"2012-11-10","objectID":"/anime/psychic_school_wars/:3:0","tags":null,"title":"被狙击的学园","uri":"/anime/psychic_school_wars/"},{"categories":null,"content":"RWBY，即红白黑黄，也被称作小红帽的逆袭。RWBY是红白黑黄的开头大写字母，代表的是红、白、黑、黄系列。\nRWBY是由外国知名同人（非职业）创作团队Monty Oum工作室制作。虽然在动画特效和声光处理方面，Monty Oum 的技术稍显业余，但他们对分镜和场面的用心度受到一致肯定，甚至能给观众带来超出好莱坞动作片的刺激临场感！","date":"2012-11-07","objectID":"/anime/rwby/","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"简介 RWBY，即红白黑黄，也被称作小红帽的逆袭。RWBY是红白黑黄的开头大写字母，代表的是红、白、黑、黄系列。 RWBY是由外国知名同人（非职业）创作团队Monty Oum工作室制作。虽然在动画特效和声光处理方面，Monty Oum 的技术稍显业余，但他们对分镜和场面的用心度受到一致肯定，甚至能给观众带来超出好莱坞动作片的刺激临场感！ 制作人员： 导演：蒙蒂·温 音乐：Jeff Williams 插入歌演出：Casey Lee Williams 动画制作：Rooster Teeth Productions ","date":"2012-11-07","objectID":"/anime/rwby/:1:0","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 露比·萝丝 小红帽、ルビー・ローズ 女 Lindsay Jones 2 怀丝·雪倪 ワイス・シュニー 女 Kara Eberle 3 布蕾克·贝拉多娜 ブレイク・ベラドンナ 女 Arryn Zech 4 阳小龙 ヤン・シャオロン 女 Barbara Dunkelman 5 亚当·托鲁斯 アダム・トーラス 男 Garrett Hunter 6 Roman Torchwick ローマン・トーチウィック 男 Gray G. Haddock 7 黑熊 Junior、ジュニア、Hei Xiong、ヘイ・ション 男 Jack Pattillo 8 Melanie Mal","date":"2012-11-07","objectID":"/anime/rwby/:2:0","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 RWBY预告片 2012-11-07 4 下方 2 红白黑黄 2013-07-18 16 bilibili 3 红白黑黄 第二季 2014-07-24 12 bilibili ","date":"2012-11-07","objectID":"/anime/rwby/:3:0","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"MAD ","date":"2012-11-07","objectID":"/anime/rwby/:4:0","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"时代背景设定在世界变动率为“1.048596%”的2019年。在这样一个机器人已经普遍实用化的未来，种子岛中央高校的“机器人研究部”正面临废部危机，而仅有的两名部员之一——八汐海翔就算面临着这样的情况，仍旧对“机器人研究部”感到兴趣盎然，并且依旧热衷于机器人格斗游戏。而另一位一根筋的废材部长瀬乃宮秋穂为了避免被废部，正在以“完成巨型机器人”为目标奋斗着。然而某天，海翔发现了一份名为“君岛报告”的A.R.笔记。在这份笔记里面，记录着名为君岛安科的人将会把整个世界都卷进来的大阴谋。","date":"2012-10-11","objectID":"/anime/robotics_notes/","tags":null,"title":"机器人笔记","uri":"/anime/robotics_notes/"},{"categories":null,"content":"简介 时代背景设定在世界变动率为“1.048596%”的2019年。在这样一个机器人已经普遍实用化的未来，种子岛中央高校的“机器人研究部”正面临废部危机，而仅有的两名部员之一——八汐海翔就算面临着这样的情况，仍旧对“机器人研究部”感到兴趣盎然，并且依旧热衷于机器人格斗游戏。而另一位一根筋的废材部长瀬乃宮秋穂为了避免被废部，正在以“完成巨型机器人”为目标奋斗着。然而某天，海翔发现了一份名为“君岛报告”的A.R.笔记。在这份笔记里面，记录着名为君岛安科的人将会把整个世界都卷进来的大阴谋。 制作人员： 原作：美吉斯、志仓千代丸 导演：野村和也 脚本：花田十辉、横谷昌宏、根元岁三 分镜：木村延景、泽井","date":"2012-10-11","objectID":"/anime/robotics_notes/:1:0","tags":null,"title":"机器人笔记","uri":"/anime/robotics_notes/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 八汐海翔 八汐 海翔、やしお かいと、Yashio Kaito 男 木村良平 2 濑乃宫秋穗 せのみや あきほ、Senomiya Akiho 女 南條愛乃 3 日高昴 ひだか すばる、Hidaka Subaru 男 細谷佳正 4 神代芙拉 古郡こな、ふるごおり こな、神代 フラウ、こうじろ ふらう、Koujiro Furau、コナちゃん 女 名塚佳織 5 大德淳和 大徳 淳和、だいとく じゅんな、Daitoku Junna 女 徳井青空 6 爱理 愛理、あいり、Airi 女 釘宮理恵 7 濑乃宫美纱希 瀬乃宮 みさ希、せのみや みさき、Senomiya Mi","date":"2012-10-11","objectID":"/anime/robotics_notes/:2:0","tags":null,"title":"机器人笔记","uri":"/anime/robotics_notes/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 机器人笔记 2012-10-11 22 bilibili ","date":"2012-10-11","objectID":"/anime/robotics_notes/:3:0","tags":null,"title":"机器人笔记","uri":"/anime/robotics_notes/"},{"categories":null,"content":"　　故事舞台设置在一个将使用战车的武技“战车道”、“华道”与“茶道”并列为大和抚子必须掌握的三大本领的架空世界。因为讨厌战车道，才转学到没有战车道的大洗女子学园的美穗，没想到才刚刚转学过来就被学生会长叫了过去，会长要求美穗选择战车道的修行并且还要在全国大会中出场。而且，队伍中聚集的成员全部都是超个性派——花道本家的大小姐五十铃华、热衷于恋爱的武部沙织、对战车无比狂热的秋山优花里、早上起不来的优等生冷泉麻子。希望与朋友们一起快乐的度过高中生活的美穗，到底能否如愿呢？","date":"2012-10-08","objectID":"/anime/girls_und_panzer/","tags":null,"title":"少女与战车","uri":"/anime/girls_und_panzer/"},{"categories":null,"content":"简介 故事舞台设置在一个将使用战车的武技“战车道”、“华道”与“茶道”并列为大和抚子必须掌握的三大本领的架空世界。因为讨厌战车道，才转学到没有战车道的大洗女子学园的美穗，没想到才刚刚转学过来就被学生会长叫了过去，会长要求美穗选择战车道的修行并且还要在全国大会中出场。而且，队伍中聚集的成员全部都是超个性派——花道本家的大小姐五十铃华、热衷于恋爱的武部沙织、对战车无比狂热的秋山优花里、早上起不来的优等生冷泉麻子。希望与朋友们一起快乐的度过高中生活的美穗，到底能否如愿呢？ 制作人员： 导演：水岛努 脚本：吉田玲子 分镜：山内则康、小林敦、畑博之、内藤明吾、山本靖贵 演出：池端隆史 ","date":"2012-10-08","objectID":"/anime/girls_und_panzer/:1:0","tags":null,"title":"少女与战车","uri":"/anime/girls_und_panzer/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 西住美穗 西住美保、西住 みほ、にしずみ みほ、Nishizumi Miho、军神 女 渕上舞 2 武部沙织 武部 沙織、たけべ さおり、Takebe Saori 女 茅野愛衣 3 五十铃华 五十鈴 華、いすず はな、Isuzu Hana 女 尾崎真実 4 秋山优花里 秋山 優花里、あきやま ゆかり、Akiyama Yukari 女 中上育実 5 冷泉麻子 冷泉 麻子、れいせい まこ、Reizei Mako 女 井口裕香 6 角谷杏 角谷 杏、かどたに あんず、Kadoutani Anzu 女 福圓美里 7 小山柚子 小山 柚子、こやま ゆず、Koyama ","date":"2012-10-08","objectID":"/anime/girls_und_panzer/:2:0","tags":null,"title":"少女与战车","uri":"/anime/girls_und_panzer/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 少女与战车 2012-10-08 12 樱花 2 少女与战车 这次是真正的安齐奥战！ 2014-07-05 1 bilibili 3 少女与战车 剧场版 2015-11-21 1 樱花 4 少女与战车 最终章 第1话 2017-12-09 1 bilibili 5 少女与战车 最终章 第2话 2019-06-15 1 樱花 6 少女与战车 最终章 第3话 2021-03-26 1 樱花 ","date":"2012-10-08","objectID":"/anime/girls_und_panzer/:3:0","tags":null,"title":"少女与战车","uri":"/anime/girls_und_panzer/"},{"categories":null,"content":"　　就读水明艺术大学附属高中的神田空太，一年级夏天时在宿舍养猫，而被校长叫去问话，并要他把猫赶走，不然就搬出宿舍。身为爱猫一族的空太，企图反抗权威，结果被撵出宿舍，流落到恶名昭彰的“樱花庄”。 隔年春天，随着世界级天才画家椎名真白搬进了樱花庄，空太开始过著被这名缺乏常识的少女耍得团团转的日子","date":"2012-10-08","objectID":"/anime/the_pet_girl_of_sakurasou/","tags":null,"title":"樱花庄的宠物女孩","uri":"/anime/the_pet_girl_of_sakurasou/"},{"categories":null,"content":"简介 就读水明艺术大学附属高中的神田空太，一年级夏天时在宿舍养猫，而被校长叫去问话，并要他把猫赶走，不然就搬出宿舍。身为爱猫一族的空太，企图反抗权威，结果被撵出宿舍，流落到恶名昭彰的“樱花庄”。 隔年春天，随着世界级天才画家椎名真白搬进了樱花庄，空太开始过著被这名缺乏常识的少女耍得团团转的日子 制作人员： 原作：鸭志田一 导演：石塚敦子 脚本：志茂文彦、小柳启伍、伊藤美智子、花田十辉、冈田麿里 分镜：佐藤真人 ","date":"2012-10-08","objectID":"/anime/the_pet_girl_of_sakurasou/:1:0","tags":null,"title":"樱花庄的宠物女孩","uri":"/anime/the_pet_girl_of_sakurasou/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 神田空太 かんだ そらた、Kanda Sorata 男 松岡禎丞 2 椎名真白 しいな ましろ、Shiina Mashiro 女 茅野愛衣 3 青山七海 あおやま ななみ、Aoyama Nanami 女 中津真莉 4 上井草美咲 上井草 美咲、かみいぐさ みさき、Kamiigusa Misaki、上井草 美咲（かみいぐさ みさき）→三鷹 美咲（みたか みさき） 女 高森奈津美 5 三鷹仁 三鷹 仁、みたか じん、Mitaka Jin 男 櫻井孝宏 6 千石千寻 千石 千寻、せんごく ちひろ、Sengoku Chihiro 女 豊口めぐみ 7 赤坂龙之介 赤坂","date":"2012-10-08","objectID":"/anime/the_pet_girl_of_sakurasou/:2:0","tags":null,"title":"樱花庄的宠物女孩","uri":"/anime/the_pet_girl_of_sakurasou/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 樱花庄的宠物女孩 2012-10-08 24 bilibili ","date":"2012-10-08","objectID":"/anime/the_pet_girl_of_sakurasou/:3:0","tags":null,"title":"樱花庄的宠物女孩","uri":"/anime/the_pet_girl_of_sakurasou/"},{"categories":null,"content":"MAD ","date":"2012-10-08","objectID":"/anime/the_pet_girl_of_sakurasou/:4:0","tags":null,"title":"樱花庄的宠物女孩","uri":"/anime/the_pet_girl_of_sakurasou/"},{"categories":null,"content":"幼年时，主人公直枝理树因双亲去世而陷入自闭。某日，在时常被痛苦所萦绕的少年面前出现了四个孩子——自称名为“Little Busters”的少年们：枣恭介、枣铃、井之原真人、宫泽谦吾，他们宣布由于世界面临巨大的危机，不得不借助理树的力量来对抗强敌。随即，他们来到了近处的蜜蜂巢穴，与蜜蜂们展开了搏斗，最终弄得浑身被蜇伤，又引起了火灾，召唤来了救火车和无数大人……而后孩子们被校长狠狠地训斥了一顿。但也由此，他们带领着理树走到了外面的世界。虽然理树经常被卷入他们所造成的骚动，却也渐渐忘记了自己的寂寞和伤痛。\n《Little Busters》不停的尝试各种新活动，经历了许许多多成败。虽然像傻瓜一样尽做蠢事，但却过得非常快乐。理树也渴望着“这样的时光能永远延续下去就好了”。\n长大后五人一同进了全宿制高中。如今已是二年级生的他们，依然过着快乐而温馨的每一天。某日，三年级的恭介提议组建棒球队。在恭介的提案下，为了凑够人数大家开始寻找队员。\n随后，理树和铃在一只名为列侬的猫身上找到一张纸条，上面写着这样的讯息：请找出这个世界的秘密……","date":"2012-10-06","objectID":"/anime/little_busters/","tags":null,"title":"Little Busters!","uri":"/anime/little_busters/"},{"categories":null,"content":"简介 幼年时，主人公直枝理树因双亲去世而陷入自闭。某日，在时常被痛苦所萦绕的少年面前出现了四个孩子——自称名为“Little Busters”的少年们：枣恭介、枣铃、井之原真人、宫泽谦吾，他们宣布由于世界面临巨大的危机，不得不借助理树的力量来对抗强敌。随即，他们来到了近处的蜜蜂巢穴，与蜜蜂们展开了搏斗，最终弄得浑身被蜇伤，又引起了火灾，召唤来了救火车和无数大人……而后孩子们被校长狠狠地训斥了一顿。但也由此，他们带领着理树走到了外面的世界。虽然理树经常被卷入他们所造成的骚动，却也渐渐忘记了自己的寂寞和伤痛。 《Little Busters》不停的尝试各种新活动，经历了许许多多成败。虽然像傻瓜一样","date":"2012-10-06","objectID":"/anime/little_busters/:1:0","tags":null,"title":"Little Busters!","uri":"/anime/little_busters/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 直枝理树 Riki Naoe、直枝 理樹、なおえ りき、Naoe Riki 男 堀江由衣 2 枣铃 なつめ りん、Natsume Rin、不擅长与他人交流的高贵小猫 女 民安ともえ 3 枣恭介 Kyousuke Natsume、棗 恭介、なつめ きょうすけ、Natsume Kyōsuke 男 緑川光 4 神北小毬 Komari Kamikita、かみきた こまり、Kamikita Komari 女 やなせなつみ 5 三枝叶留佳 Haruka Saigusa、三枝 葉留佳、さいぐさ はるか、Saigusa Haruka 女 すずきけいこ 6 能美·库特莉亚芙卡","date":"2012-10-06","objectID":"/anime/little_busters/:2:0","tags":null,"title":"Little Busters!","uri":"/anime/little_busters/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Little Busters! 2012-10-06 26 bilibili 2 Little Busters! 〜Refrain〜 2013-10-05 13 bilibili 3 Little Busters! EX 2014-01-29 8 bilibili ","date":"2012-10-06","objectID":"/anime/little_busters/:3:0","tags":null,"title":"Little Busters!","uri":"/anime/little_busters/"},{"categories":null,"content":"MAD ","date":"2012-10-06","objectID":"/anime/little_busters/:4:0","tags":null,"title":"Little Busters!","uri":"/anime/little_busters/"},{"categories":null,"content":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n\n时光飞逝，来到了19世纪末的英国。在这个人们的思想与生活产生激烈变化的时代，乔纳森·乔斯达与迪奥·布兰度相遇。二人一同渡过了少年时代到青年时代，最后因为「石鬼面」，而步上了奇特怪异的命运。\n\n以及在1938年的美国，乔纳森·乔斯达的孙子——乔瑟夫·乔斯达长大成人后的故事。为了守护他重视的人们，与苏醒的超级生物柱之男不停的战斗。","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"简介 在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。 时光飞逝，来到了19世纪末的英国。在这个人们的思想与生活产生激烈变化的时代，乔纳森·乔斯达与迪奥·布兰度相遇。二人一同渡过了少年时代到青年时代，最后因为「石鬼面」，而步上了奇特怪异的命运。 以及在1938年的美国，乔纳森·乔斯达的孙子——乔瑟夫·乔斯达长大成人后的故事。为了守护他重视的人们，与苏醒的超级生物柱之男不停的战斗。 制作人员： 原作：荒木飞吕彦 导演：津田尚克 脚本：笔安一幸、小林靖子、","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/:1:0","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 乔纳森·乔斯达 ジョナサン・ジョースター、Jonathan Joestar、jojo 男 興津和幸 2 迪奥·布兰多 迪奥、DIO（3部）、Dio Brando、ディオ・ブランドー、屌爷，屌·不懒惰 男 子安武人 3 乔瑟夫·乔斯达 ジョセフ・ジョースター、Joseph Joestar、jojo 男 杉田智和 4 西撒·安东尼奥·齐佩利 Caesar Antonio Zeppeli 男 佐藤拓也 5 艾莉娜·班魯多 Erina Pendleton 女 川澄綾子 6 莉莎莉莎 エリザベス・ジョースター、伊丽莎白·乔斯达、Lisa Lisa 女 田中敦子 7 罗","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/:2:0","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 JOJO的奇妙冒险 2012-10-05 26 bilibili 2 JOJO的奇妙冒险 星尘斗士 2014-04-04 24 bilibili 3 JOJO的奇妙冒险 星尘斗士 埃及篇 2015-01-09 24 bilibili 4 JOJO的奇妙冒险 不灭钻石 2016-04-01 39 bilibili 5 JOJO的奇妙冒险 黄金之风 2018-10-05 39 bilibili 6 JOJO的奇妙冒险 石之海 2022-01-07 12 bilibili 7 JOJO的奇妙冒险 石之海 Part.2 2022-10-07 12 bi","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/:3:0","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"MAD ","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/:4:0","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"       某一天，最强的魔法使公主锁部叶风被部下左门暗算，困在了无人荒岛；又有一天，一位少女被唐突杀害，犯人还未逮捕时间却已流逝；然后又在某一天，围绕着复仇与魔法，超越时间与空间的战斗正式揭开了序幕！\n       正气和狂气，理性和知性，自信和确信。\n       在悲剧性的不合理的世界里，少年少女们的命运交缠纠结，故事开始了！","date":"2012-10-04","objectID":"/anime/blast_of_tempest/","tags":null,"title":"绝园的暴风雨","uri":"/anime/blast_of_tempest/"},{"categories":null,"content":"简介 某一天，最强的魔法使公主锁部叶风被部下左门暗算，困在了无人荒岛；又有一天，一位少女被唐突杀害，犯人还未逮捕时间却已流逝；然后又在某一天，围绕着复仇与魔法，超越时间与空间的战斗正式揭开了序幕！ 正气和狂气，理性和知性，自信和确信。 在悲剧性的不合理的世界里，少年少女们的命运交缠纠结，故事开始了！ 制作人员： 原作：彩崎廉、城平京、左有秀 导演：安藤真裕 脚本：山口宏、大西信介、小柳启伍、冈田麿里 分镜：寺冈岩 ","date":"2012-10-04","objectID":"/anime/blast_of_tempest/:1:0","tags":null,"title":"绝园的暴风雨","uri":"/anime/blast_of_tempest/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 泷川吉野 たきがわ よしの、Takigawa Yoshino 男 桑島法子 2 不破真广 不破 真広、ふわ まひろ、Fuwa Mahiro 男 三瓶由布子 3 锁部叶风 くさりべ はかぜ、Kusaribe Hakaze 女 沢城みゆき 4 不破爱花 不破 愛花、ふわ あいか、Fuwa Aika 女 花澤香菜 5 锁部左门 くさりべ さもん、Kusaribe Samon 男 小山力也 6 伊凡洁丽·山本 えヴぁんじぇりん やまもと 女 水樹奈々 7 星村润一郎 ほしむら じゅんいちろう、Hoshimura Junichirou 男 野島裕史 8 锁部夏村 くさ","date":"2012-10-04","objectID":"/anime/blast_of_tempest/:2:0","tags":null,"title":"绝园的暴风雨","uri":"/anime/blast_of_tempest/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 绝园的暴风雨 2012-10-04 24 bilibili ","date":"2012-10-04","objectID":"/anime/blast_of_tempest/:3:0","tags":null,"title":"绝园的暴风雨","uri":"/anime/blast_of_tempest/"},{"categories":null,"content":"富㭴勇太于初中毕业的时候，决定同时为自己举办中二病毕业的仪式。打算顺利渡过高中生活的他，在开学日以最后的中二语录完全封锁这段黑历史。可惜天意弄人，勇太遇上了现任中二病患者暨同班同学小鸟游六花，更被对方看出中二病的残余症状。六花于是以此威逼勇太与她“立下契约”。对方的行为举止惹来了不少同学、家人、甚至青梅竹马的注目，使勇太在享受“现充”的生活同时，又充满著难言之隐……","date":"2012-10-03","objectID":"/anime/chuunibyou/","tags":null,"title":"中二病也要谈恋爱！","uri":"/anime/chuunibyou/"},{"categories":null,"content":"简介 富㭴勇太于初中毕业的时候，决定同时为自己举办中二病毕业的仪式。打算顺利渡过高中生活的他，在开学日以最后的中二语录完全封锁这段黑历史。可惜天意弄人，勇太遇上了现任中二病患者暨同班同学小鸟游六花，更被对方看出中二病的残余症状。六花于是以此威逼勇太与她“立下契约”。对方的行为举止惹来了不少同学、家人、甚至青梅竹马的注目，使勇太在享受“现充”的生活同时，又充满著难言之隐…… 制作人员： 原作：虎虎 导演：石原立也 脚本：花田十辉 分镜：木上益治、石立太一、武本康弘、坂本一也、河浪荣作、内海纮子 ","date":"2012-10-03","objectID":"/anime/chuunibyou/:1:0","tags":null,"title":"中二病也要谈恋爱！","uri":"/anime/chuunibyou/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 富樫勇太 富樫 勇太、とがし ゆうた、Togashi Yuuta、Dark Flame Master 男 福山潤 2 小鸟游六花 たかなし りっか、Takanashi Rikka 女 内田真礼 3 丹生谷森夏 にぶたに しんか、Nibutani Shinka、森夏，もりさま，森大人，ニセモリ 女 赤﨑千夏 4 五月七日枯茗 五月七日茴香、五月七日小茴香、五月七日久民、栗花落小茴香、五月七日 くみん、つゆり くみん、Tsuyuri Kumin 女 浅倉杏美 5 凸守早苗 凸守 早苗、でこもり さなえ、Dekomori Sanae 女 上坂すみれ 6 奇美拉 C","date":"2012-10-03","objectID":"/anime/chuunibyou/:2:0","tags":null,"title":"中二病也要谈恋爱！","uri":"/anime/chuunibyou/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 中二病也要谈恋爱！ 2012-10-03 13 bilibili 2 中二病也要谈恋爱！恋 2014-01-08 13 bilibili 3 电影 中二病也要谈恋爱！ -Take On Me- 2018-01-06 1 bilibili ","date":"2012-10-03","objectID":"/anime/chuunibyou/:3:0","tags":null,"title":"中二病也要谈恋爱！","uri":"/anime/chuunibyou/"},{"categories":null,"content":"MAD ","date":"2012-10-03","objectID":"/anime/chuunibyou/:4:0","tags":null,"title":"中二病也要谈恋爱！","uri":"/anime/chuunibyou/"},{"categories":null,"content":"　　作品背景以1000年后的未来世界为基调，讲述了在1000年后日本的孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会「新世界」，是口吐真言凭藉「咒力」就能移动物体的人类，与有著等同于普通人智力的生物「妖鼠」共存的世界。乍看之下一切和平，但「新世界」的孩子们的行动被彻底地控制和管束著，不合适的记忆被消去，被认为有问题的孩子，如同不良产品般被分开处理。因为一些违反规则的小事而莫名地失去不少朋友的主人公早季，卷进了人类与妖鼠之间的战争。本作除了令人毛骨悚然的故事情节外，还对未来社会持续破坏自然环境所引发的一系列问题进行了一番探讨和思辨，也因此取得了08年的日本SF大赏殊荣。","date":"2012-09-28","objectID":"/anime/from_the_new_world/","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"简介 作品背景以1000年后的未来世界为基调，讲述了在1000年后日本的孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会「新世界」，是口吐真言凭藉「咒力」就能移动物体的人类，与有著等同于普通人智力的生物「妖鼠」共存的世界。乍看之下一切和平，但「新世界」的孩子们的行动被彻底地控制和管束著，不合适的记忆被消去，被认为有问题的孩子，如同不良产品般被分开处理。因为一些违反规则的小事而莫名地失去不少朋友的主人公早季，卷进了人类与妖鼠之间的战争。本作除了令人毛骨悚然的故事情节外，还对未来社会持续破坏自然环境所引发的一系列问题进行了一番探讨和思辨，也因此取得了08年的日本","date":"2012-09-28","objectID":"/anime/from_the_new_world/:1:0","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 渡边早季 Saki Watanabe、渡辺 早季、わたなべ さき、Watanabe Saki 女 遠藤綾 2 朝比奈觉 あさひな さとる 男 梶裕貴 3 秋月真理亚 あきづき まりあ 女 花澤香菜 4 伊东守 いとうまもる 男 工藤晴香 5 青沼瞬 あおぬま しゅん 男 藤堂真衣 6 野狐丸 斯奎拉、野狐丸、やこまる 男 浪川大輔 7 奇狼丸 きろうまる 男 平田広明 8 天野丽子 あまの れいこ 女 堀江由衣 ","date":"2012-09-28","objectID":"/anime/from_the_new_world/:2:0","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 来自新世界 2012-09-28 25 bilibili ","date":"2012-09-28","objectID":"/anime/from_the_new_world/:3:0","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"MAD ","date":"2012-09-28","objectID":"/anime/from_the_new_world/:4:0","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"女大学生的花，与一个在大学教室认识的男子结婚，并成为两个孩子的母亲。\n\n不过，那个男子是“狼人”，姐姐“雪”和弟弟“雨”都是“狼的孩子”。即便如此，一家人还是在城市里过着幸福的生活。然而，在“雨”出生之后，男子却因为意外而去世。\n\n对于丈夫去世的悲伤，同时也为孩子未来“人·狼”抉择的担心。花决定带着孩子移居到深山的古居中，于是三人开始了新的生活……","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"简介 女大学生的花，与一个在大学教室认识的男子结婚，并成为两个孩子的母亲。 不过，那个男子是“狼人”，姐姐“雪”和弟弟“雨”都是“狼的孩子”。即便如此，一家人还是在城市里过着幸福的生活。然而，在“雨”出生之后，男子却因为意外而去世。 对于丈夫去世的悲伤，同时也为孩子未来“人·狼”抉择的担心。花决定带着孩子移居到深山的古居中，于是三人开始了新的生活…… 制作人员： 原作：细田守、MADHOUSE 脚本：奥寺佐渡子 音乐：高木正胜 人物设定：贞本义行 美术监督：大野广司 色彩设计：三笠修 作画监督：山下高明 ","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/:1:0","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 花 Hana、はな、Hana 女 宮﨑あおい 2 他 おおかみおとこ 男 大沢たかお 3 雪 ゆき、Yuki 女 黒木華 4 雨 あめ、Ame 男 5 庄子 Souko 女 春名風花 6 藤井草平 男 ","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/:2:0","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 狼的孩子雨和雪 2012-07-21 1 bilibili ","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/:3:0","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"MAD ","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/:4:0","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"本作的舞台位于私立山星高中，在这所学校的文化研究部内，八重樫太一、永濑伊织、稻叶姬子、桐山唯、青木义文这五名成员目前面临着不可思议的现象。起初是成员中的唯及义文，在毫无前兆的情况下发生了人格交换，之后周围的其他成员也是如此。爱与青春的五角形喜剧从此正式开演了。","date":"2012-07-07","objectID":"/anime/kokoro_connect/","tags":null,"title":"心灵链环","uri":"/anime/kokoro_connect/"},{"categories":null,"content":"简介 本作的舞台位于私立山星高中，在这所学校的文化研究部内，八重樫太一、永濑伊织、稻叶姬子、桐山唯、青木义文这五名成员目前面临着不可思议的现象。起初是成员中的唯及义文，在毫无前兆的情况下发生了人格交换，之后周围的其他成员也是如此。爱与青春的五角形喜剧从此正式开演了。 制作人员： 原作：庵田定夏 导演：川面真也 脚本：志茂文彦 分镜：石黑恭平、增田敏彦、黑川智之、岛津裕行、山本秀世、佐山圣子 ","date":"2012-07-07","objectID":"/anime/kokoro_connect/:1:0","tags":null,"title":"心灵链环","uri":"/anime/kokoro_connect/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 八重樫太一 やえがし たいち、yaegashi taichi 男 水島大宙 2 永濑伊织 ながせ いおり、Nagase Iori 女 豊崎愛生 3 稻叶姬子 いなば ひめこ、inaba himeko 女 沢城みゆき 4 桐山唯 きりやま ゆい、Kiriyama Yui 女 金元寿子 5 青木义文 あおき よしふみ、aoki yoshifumi 男 寺島拓篤 6 藤岛麻衣子 藤島 麻衣子、ふじしま まいこ 女 伊藤静 7 后藤龙善 後藤 龍善、ごとう りゅうぜん、gotou ryouuzen 男 藤原啓治 8 八重樫莉奈 八重樫 莉奈、やえがし りな、Yaeg","date":"2012-07-07","objectID":"/anime/kokoro_connect/:2:0","tags":null,"title":"心灵链环","uri":"/anime/kokoro_connect/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 心灵链环 2012-07-07 17 bilibili ","date":"2012-07-07","objectID":"/anime/kokoro_connect/:3:0","tags":null,"title":"心灵链环","uri":"/anime/kokoro_connect/"},{"categories":null,"content":"舞台设立在神奈川县的江之岛，进入了高中音乐系的坂井和奏却在半途因为母亲突然的去世在自责的情况下放弃了音乐的道路，之后便转入了普通系。在她升入高中三年级时，以与宫本来夏、冲田纱羽的相遇为契机组成了合唱部，藉由音乐的力量，在高中最后的暑假，追寻着属于她们的梦想，编织出细小而闪耀的故事。","date":"2012-07-01","objectID":"/anime/tari_tari/","tags":null,"title":"TARI TARI","uri":"/anime/tari_tari/"},{"categories":null,"content":"简介 舞台设立在神奈川县的江之岛，进入了高中音乐系的坂井和奏却在半途因为母亲突然的去世在自责的情况下放弃了音乐的道路，之后便转入了普通系。在她升入高中三年级时，以与宫本来夏、冲田纱羽的相遇为契机组成了合唱部，藉由音乐的力量，在高中最后的暑假，追寻着属于她们的梦想，编织出细小而闪耀的故事。 制作人员： 导演：桥本昌和 脚本：佐藤梨香、横手美智子 分镜：本乡满、浅井义之、多田俊介、冈村天斋 ","date":"2012-07-01","objectID":"/anime/tari_tari/:1:0","tags":null,"title":"TARI TARI","uri":"/anime/tari_tari/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 坂井和奏 さかい わかな、Sakai Wakana 女 高垣彩陽 2 宫本来夏 みやもと こなつ、Miyamoto Konatsu 女 瀬戸麻沙美 3 冲田纱羽 おきた さわ、Okita Sawa 女 早見沙織 4 田中大智 たなか たいち、Tanaka Taichi 男 島﨑信長 5 维也纳 前田敦博、前田敦博、まえだ あつひろ、Maeda Atsuhiro 男 花江夏樹 6 高桥智子 高橋 智子、たかはし ともこ、Takahashi Tomoko 女 木村亜希子 7 坂井圭介 さかい けいすけ、Sakai Keisuke 男 浜田賢二 8 高仓直子 たか","date":"2012-07-01","objectID":"/anime/tari_tari/:2:0","tags":null,"title":"TARI TARI","uri":"/anime/tari_tari/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 TARI TARI 2012-07-01 13 bilibili ","date":"2012-07-01","objectID":"/anime/tari_tari/:3:0","tags":null,"title":"TARI TARI","uri":"/anime/tari_tari/"},{"categories":null,"content":"世界的人口因为不明原因而急降，逐渐步出历史的舞台，取而代之的是一种平均身高只有10公分、三头身的妖精。妖精的平均身高只有10公分，三头身的妖精们却拥有高度的智慧，而且非常喜欢吃糖果点心。主人公作为最后一届的毕业生毕业之后就回到故乡樟树之里去接续祖父的工作，成为负责斡旋在妖精与人类之间的重要国际公务员“调停官”。虽然如此，由于妖精很少跟人类接触，因此她根本没啥工作可作，因此她想要好好研究妖精的生态。","date":"2012-07-01","objectID":"/anime/humanity_has_declined/","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"简介 世界的人口因为不明原因而急降，逐渐步出历史的舞台，取而代之的是一种平均身高只有10公分、三头身的妖精。妖精的平均身高只有10公分，三头身的妖精们却拥有高度的智慧，而且非常喜欢吃糖果点心。主人公作为最后一届的毕业生毕业之后就回到故乡樟树之里去接续祖父的工作，成为负责斡旋在妖精与人类之间的重要国际公务员“调停官”。虽然如此，由于妖精很少跟人类接触，因此她根本没啥工作可作，因此她想要好好研究妖精的生态。 制作人员： 原作：田中罗密欧 导演：岸诚二 脚本：上江洲诚、绫奈由仁子、熊谷纯 分镜：森义博、大畑晃一、小坂春女、江上洁 ","date":"2012-07-01","objectID":"/anime/humanity_has_declined/:1:0","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 我 お菓子ちゃん、人类小姐 女 中原麻衣 2 助手 男 福山潤 3 爷爷 男 石塚運昇 4 友人Y 银发姑娘、丫、銀髪ちゃん、銀髪ちゃん/银发姑娘 女 沢城みゆき 5 P子 ぴおね、ピオン、PIONEER、パイオニア 女 水樹奈々 6 O太郎 おやげ、おやじ、VOYAGER、ボイジャー 男 檜山修之 7 一条先生 吐司 間宮くるみ 8 卷发 まきげ 女 金元寿子 ","date":"2012-07-01","objectID":"/anime/humanity_has_declined/:2:0","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 人类衰退之后 2012-07-01 12 bilibili ","date":"2012-07-01","objectID":"/anime/humanity_has_declined/:3:0","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"MAD ","date":"2012-07-01","objectID":"/anime/humanity_has_declined/:4:0","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"作品改编自川口雅幸老师创作的同名小说，故事讲述由于交通事故而失去了父亲的小学六年级学生裕太，在水库那里穿越时空回到已经被掩埋的30年前的乡村，描写了1970年代的日本乡村的自然景观以及裕太与孩子们的友情。","date":"2012-05-19","objectID":"/anime/rainbow_fireflies/","tags":null,"title":"虹色萤火虫～永远的暑假～","uri":"/anime/rainbow_fireflies/"},{"categories":null,"content":"简介 作品改编自川口雅幸老师创作的同名小说，故事讲述由于交通事故而失去了父亲的小学六年级学生裕太，在水库那里穿越时空回到已经被掩埋的30年前的乡村，描写了1970年代的日本乡村的自然景观以及裕太与孩子们的友情。 制作人员： 原作：川口雅幸 导演：宇田钢之介 脚本：国井桂 人物设定：森久司 分镜构图：山下高明 美术监督：田村盛挥 ","date":"2012-05-19","objectID":"/anime/rainbow_fireflies/:1:0","tags":null,"title":"虹色萤火虫～永远的暑假～","uri":"/anime/rainbow_fireflies/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 虹色萤火虫～永远的暑假～ 2012-05-19 1 bilibili ","date":"2012-05-19","objectID":"/anime/rainbow_fireflies/:2:0","tags":null,"title":"虹色萤火虫～永远的暑假～","uri":"/anime/rainbow_fireflies/"},{"categories":null,"content":"以节能为座右铭的高中生折木奉太郎， 为一个小小的原因而加入了濒临废社的“古典文学部”。古典文学部的社员，包括他在社里认识的好奇宝宝，也就是女主角千反田爱瑠，还有他从国中就认识的伊原摩耶花和福部里志。这是他们四人以神山高中为舞台，对一桩桩事件展开推理的青春学园推理剧。“我很好奇！”奉太郎平静的灰色高中生活，因为千反田的这一句话而为之一变！","date":"2012-04-22","objectID":"/anime/hyouka/","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"简介 以节能为座右铭的高中生折木奉太郎， 为一个小小的原因而加入了濒临废社的“古典文学部”。古典文学部的社员，包括他在社里认识的好奇宝宝，也就是女主角千反田爱瑠，还有他从国中就认识的伊原摩耶花和福部里志。这是他们四人以神山高中为舞台，对一桩桩事件展开推理的青春学园推理剧。“我很好奇！”奉太郎平静的灰色高中生活，因为千反田的这一句话而为之一变！ 制作人员： 原作：米泽穗信 导演：武本康弘 脚本：贺东招二、村元克彦、江上美幸、西冈麻衣子 分镜：内海纮子、石立太一、河浪荣作 ","date":"2012-04-22","objectID":"/anime/hyouka/:1:0","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 折木奉太郎 折棒太郎、おれき ほうたろう、Oreki Houtarou、节能环保男 男 中村悠一 2 千反田爱瑠 吃蛋挞、千反田惠瑠、ちたんだ える、Chitanda Eru、L 女 佐藤聡美 3 福部里志 ふくべ さとし、Fukube Satoshi 男 阪口大助 4 伊原摩耶花 いばら まやか、Ibara Mayaka 女 茅野愛衣 5 远垣内将司 とうがいと まさし 男 置鮎龍太郎 6 折木供惠 折木 供恵、おれき ともえ、Oreki Tomoe 女 ゆきのさつき 7 糸鱼川养子 いといがわ ようこ 女 小山茉美 8 入须冬实 いりす ふゆみ 女 ゆか","date":"2012-04-22","objectID":"/anime/hyouka/:2:0","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 冰菓 2012-04-22 22 bilibili 2 冰菓 应该持有之物 2013-01-12 1 樱花 ","date":"2012-04-22","objectID":"/anime/hyouka/:3:0","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"MAD ","date":"2012-04-22","objectID":"/anime/hyouka/:4:0","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"　　原作为小玉ユキ于2007年到2012年初在小学館《月刊flowers》所连载的漫画，在2009年度“这本漫画真厉害·女性篇”中获得第一位。\n　　故事发生在1966年初夏，高中一年生西见薰因父亲工作调动而独自一人从横须贺市搬到亲戚所在的九州。自闭的优等生薰在与同班同学川渕千太郎相遇之后逐渐发生了改变。薰通过千太郎了解到了爵士乐的魅力，并初次交到了“朋友”，享受与同伴一起演奏音乐的乐趣。其他还有与千太郎青梅竹马的律子、神秘学姐百合香、崇拜的淳兄……这是一出在受美国文化所影响的海边城镇展开的以友情、恋爱、音乐为主题的青春群像剧。","date":"2012-04-12","objectID":"/anime/kids_on_the_slope/","tags":null,"title":"坂道上的阿波罗","uri":"/anime/kids_on_the_slope/"},{"categories":null,"content":"简介 原作为小玉ユキ于2007年到2012年初在小学館《月刊flowers》所连载的漫画，在2009年度“这本漫画真厉害·女性篇”中获得第一位。 故事发生在1966年初夏，高中一年生西见薰因父亲工作调动而独自一人从横须贺市搬到亲戚所在的九州。自闭的优等生薰在与同班同学川渕千太郎相遇之后逐渐发生了改变。薰通过千太郎了解到了爵士乐的魅力，并初次交到了“朋友”，享受与同伴一起演奏音乐的乐趣。其他还有与千太郎青梅竹马的律子、神秘学姐百合香、崇拜的淳兄……这是一出在受美国文化所影响的海边城镇展开的以友情、恋爱、音乐为主题的青春群像剧。 制作人员： 原作：小玉由起 导演：渡边信一郎 脚本：柿原优子、加藤绫","date":"2012-04-12","objectID":"/anime/kids_on_the_slope/:1:0","tags":null,"title":"坂道上的阿波罗","uri":"/anime/kids_on_the_slope/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 西见薰 西見 薫、にしみ かおる、Nishimi Kaoru 男 木村良平 2 川渊千太郎 かわぶち せんたろう、Kawabuchi Sentarou 男 細谷佳正 3 迎律子 むかえ りつこ、Mukae Ritsuko 女 南里侑香 4 深堀百合香 ふかほり ゆりか、Fukahori Yurika 女 遠藤綾 5 桂木淳一 かつらぎ じゅんいち、Katsuragi Junichi 男 諏訪部順一 6 丸尾重虎 まるお しげとら、Maruo Shigetora 男 村瀬歩 7 松冈星儿 松岡 星児、まつおか せいじ、Matsuoka Seiji 男 岡本信彦","date":"2012-04-12","objectID":"/anime/kids_on_the_slope/:2:0","tags":null,"title":"坂道上的阿波罗","uri":"/anime/kids_on_the_slope/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 坂道上的阿波罗 2012-04-12 12 bilibili ","date":"2012-04-12","objectID":"/anime/kids_on_the_slope/:3:0","tags":null,"title":"坂道上的阿波罗","uri":"/anime/kids_on_the_slope/"},{"categories":null,"content":"MAD ","date":"2012-04-12","objectID":"/anime/kids_on_the_slope/:4:0","tags":null,"title":"坂道上的阿波罗","uri":"/anime/kids_on_the_slope/"},{"categories":null,"content":"约拿是个沉默寡言的银发少年，因为父母在战争中被炸死，从小就过着在战场上杀人而生存的生活，对武器、军火十分的厌恶。由于看到自己的伙伴被军营强行命令去踩雷区，一怒之下一人杀掉所有民兵，被蔻蔻的哥哥卡斯帕抓住后，以卡斯帕保护自己的伙伴为条件答应成为蔻蔻的保镖。这个把自己比喻成北欧神话中的巨蛇的年轻的女人是个自称“贩卖军火是为了世界和平”，以平衡各国军备实力的理念来避免战争，而非以利润为单纯目标的商人。她性格和处世方法都很特别，随着组织周转世界各国进行各种危险的交易，习惯了在战场上生存的约拿的生活也发生了潜移默化的改变。","date":"2012-04-10","objectID":"/anime/jormungand/","tags":null,"title":"军火女王","uri":"/anime/jormungand/"},{"categories":null,"content":"简介 约拿是个沉默寡言的银发少年，因为父母在战争中被炸死，从小就过着在战场上杀人而生存的生活，对武器、军火十分的厌恶。由于看到自己的伙伴被军营强行命令去踩雷区，一怒之下一人杀掉所有民兵，被蔻蔻的哥哥卡斯帕抓住后，以卡斯帕保护自己的伙伴为条件答应成为蔻蔻的保镖。这个把自己比喻成北欧神话中的巨蛇的年轻的女人是个自称“贩卖军火是为了世界和平”，以平衡各国军备实力的理念来避免战争，而非以利润为单纯目标的商人。她性格和处世方法都很特别，随着组织周转世界各国进行各种危险的交易，习惯了在战场上生存的约拿的生活也发生了潜移默化的改变。 制作人员： 原作：高桥庆太郎 导演：元永庆太郎 脚本：黑田洋介 分镜：若林","date":"2012-04-10","objectID":"/anime/jormungand/:1:0","tags":null,"title":"军火女王","uri":"/anime/jormungand/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 蔻蔻 海克玛提亚 Koko Hekmatyar、koko hekumatiaru 女 伊藤静 2 乔那 Jonah、ジョナサン・マル 男 田村睦心 3 瓦尔梅 ソフィア・ヴェルマー、Valmet 女 大原さやか 4 雷姆 Lehm 男 石塚運昇 5 鲁兹 Lutz 男 羽多野渉 6 伍戈 Ugo 男 勝沼紀義 7 毛 Mao 男 四宮豪 8 威利 ウィリアム・ネルソン、Wilee 男 乃村健次 ","date":"2012-04-10","objectID":"/anime/jormungand/:2:0","tags":null,"title":"军火女王","uri":"/anime/jormungand/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 军火女王 2012-04-10 12 bilibili 2 军火女王 PERFECT ORDER 2012-10-09 12 bilibili ","date":"2012-04-10","objectID":"/anime/jormungand/:3:0","tags":null,"title":"军火女王","uri":"/anime/jormungand/"},{"categories":null,"content":"椿明和卜部美琴这两个刚开始交往的高中生，对椿来说，卜部是个充满谜团的女孩，而这谜团也正待他去揭开……","date":"2012-04-07","objectID":"/anime/mysterious_girlfriend_x/","tags":null,"title":"谜样女友X","uri":"/anime/mysterious_girlfriend_x/"},{"categories":null,"content":"简介 椿明和卜部美琴这两个刚开始交往的高中生，对椿来说，卜部是个充满谜团的女孩，而这谜团也正待他去揭开…… 制作人员： 原作：植芝理一 导演：渡边步 脚本：三重野瞳 分镜：名村英敏、志村宏明、小岛正幸、山内重保、关野昌弘 ","date":"2012-04-07","objectID":"/anime/mysterious_girlfriend_x/:1:0","tags":null,"title":"谜样女友X","uri":"/anime/mysterious_girlfriend_x/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 卜部美琴 Urabe Mikoto、卜部 女 吉谷彩子 2 椿明 Tsubaki Akira 男 入野自由 3 丘步子 おか あゆこ、Oka Ayuko 女 広橋涼 4 上野公平 上野 公平、うえの こうへい、ueno kouhei 男 梶裕貴 5 椿阳子 つばき ようこ 女 福圓美里 6 圣光君 圣光、Holy Light 7 户川安里香 とがわ ありか 女 8 松笛篁臣 まつぶえ たかおみ 男 ","date":"2012-04-07","objectID":"/anime/mysterious_girlfriend_x/:2:0","tags":null,"title":"谜样女友X","uri":"/anime/mysterious_girlfriend_x/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 谜样女友X 2012-04-07 13 樱花 ","date":"2012-04-07","objectID":"/anime/mysterious_girlfriend_x/:3:0","tags":null,"title":"谜样女友X","uri":"/anime/mysterious_girlfriend_x/"},{"categories":null,"content":"早上起床、去了学校、放学后和朋友一起度过。不论是高兴的事情还是难过的事情、4个人总是一起体验。一直以为可以持续过着每一天。\n这样的女孩们、舞动着夏日的奇迹。这就是在下田町长大的4个女孩的故事。\n虽然炙热、但却明朗的夏色奇迹一定将你团团包围。\n本作由声优组合Sphere担纲出演。","date":"2012-04-05","objectID":"/anime/a_summer_colored_miracle/","tags":null,"title":"夏色奇迹","uri":"/anime/a_summer_colored_miracle/"},{"categories":null,"content":"简介 早上起床、去了学校、放学后和朋友一起度过。不论是高兴的事情还是难过的事情、4个人总是一起体验。一直以为可以持续过着每一天。 这样的女孩们、舞动着夏日的奇迹。这就是在下田町长大的4个女孩的故事。 虽然炙热、但却明朗的夏色奇迹一定将你团团包围。 本作由声优组合Sphere担纲出演。 制作人员： 原作：日昇 导演：水岛精二 脚本：高桥龙也、浦畑达彦、绫奈由仁子、村井贞之 分镜：龟井治、木村隆一 ","date":"2012-04-05","objectID":"/anime/a_summer_colored_miracle/:1:0","tags":null,"title":"夏色奇迹","uri":"/anime/a_summer_colored_miracle/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 逢泽夏海 逢沢夏海、あいざわ なつみ、aizawa natsumi 女 寿美菜子 2 水越纱季 水越紗季、みずこし さき 女 高垣彩陽 3 花木优香 花木優香、はなき ゆか 女 戸松遥 4 环凛子 環凛子、たまき りんこ、tamasa rinko 女 豊崎愛生 5 夏海の母 女 沢城みゆき 6 紗季の母 女 山崎和佳奈 7 凛子の母 女 恒松あゆみ 8 冲山千晴 おきやま ちはる、Okiyama Chiharu 女 茅野愛衣 ","date":"2012-04-05","objectID":"/anime/a_summer_colored_miracle/:2:0","tags":null,"title":"夏色奇迹","uri":"/anime/a_summer_colored_miracle/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 夏色奇迹 2012-04-05 12 bilibili ","date":"2012-04-05","objectID":"/anime/a_summer_colored_miracle/:3:0","tags":null,"title":"夏色奇迹","uri":"/anime/a_summer_colored_miracle/"},{"categories":null,"content":"MAD ","date":"2012-04-05","objectID":"/anime/a_summer_colored_miracle/:4:0","tags":null,"title":"夏色奇迹","uri":"/anime/a_summer_colored_miracle/"},{"categories":null,"content":"近乎现实的世界中，有一位看似平凡的少女黑衣麻陶，于新一年展开其丰富璀璨的中学生活。这时，一位名为小鸟游优美的同班同学吸引了她的注意。起初对方不欲作深层交往，后来却因为彩虹小鸟的话题，而被麻陶见到小鸟游受到委屈的一面……\n充满怪异的世界中，一群人生活于如眼泪般蔚蓝的天空之下，每天都仿如战士般进行着明争暗斗，仿如正为他人承受遇到的苦恼和混乱不堪的思绪……","date":"2012-02-02","objectID":"/anime/black_rock_shooter/","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"简介 近乎现实的世界中，有一位看似平凡的少女黑衣麻陶，于新一年展开其丰富璀璨的中学生活。这时，一位名为小鸟游优美的同班同学吸引了她的注意。起初对方不欲作深层交往，后来却因为彩虹小鸟的话题，而被麻陶见到小鸟游受到委屈的一面…… 充满怪异的世界中，一群人生活于如眼泪般蔚蓝的天空之下，每天都仿如战士般进行着明争暗斗，仿如正为他人承受遇到的苦恼和混乱不堪的思绪…… 制作人员： 原作：B★RS Project 导演：吉冈忍 脚本：冈田麿里 分镜：江崎慎平、筱原俊哉、今石洋之、大州鹤太郎、雨宫哲 ","date":"2012-02-02","objectID":"/anime/black_rock_shooter/:1:0","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 黑衣麻陶 黑衣真透、黑衣真兔、黒衣 マト、くろい マト、Kuroi Mato 女 花澤香菜 2 小鸟游黄泉 小鸟游优美、小鳥遊 ヨミ、たかなし ヨミ、Takanashi Yomi 女 沢城みゆき 3 神足由宇 神足 ユウ、こうたり ユウ、Koutari Yu 女 阿澄佳奈 4 纳野沙耶 納野 サヤ、いりの サヤ、Irino Saya 女 能登麻美子 5 出灰篝 出灰加贺里、出灰 カガリ、いずりは カガリ、Izuriha Kagari 女 喜多村英梨 6 黑岩射手 BLACK★ROCK SHOOTER、ブラックロックシューター、B★RS、BRS 女 花澤香菜 ","date":"2012-02-02","objectID":"/anime/black_rock_shooter/:2:0","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 黑岩射手 2012-02-02 8 bilibili ","date":"2012-02-02","objectID":"/anime/black_rock_shooter/:3:0","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"MAD ","date":"2012-02-02","objectID":"/anime/black_rock_shooter/:4:0","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"　　26年前夜见山北中学的三年三班里，曾经有一位名叫「misaki」的学生。她不仅是位运动天才还是个优等生，个性平易近人广受众人喜爱的她却在某日突然猝死，极度悲伤的同班同学们无法接受这件事实，众人决定到毕业之前仍想像见崎还活著般度过每一天。因此见崎的座位就这样一大早上课会有人来打招呼，偶而还会有人藉机搭话——但这段美丽的插曲却对三年三班带来某种扭曲的现象。而在1998年春天，转到三年三班的榊原恒一，莫名感到班上的气氛持续著不安感。在这样的班级里，有位行事异于常人，孤高的美少女见崎鸣——一只眼睛遮著眼罩总是独自一人在画画，拥有不可思议的存在感让恒一不禁想试著接近她，但却就此陷入更深的谜团之中。\n　　随著故事的进展，班上的气氛越来越紧张，也有越来越多的人不知是巧合还是「诅咒」而意外生亡。在绫辻大师的笔触下，恐怖的气氛越发浓厚。","date":"2012-01-09","objectID":"/anime/another/","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"简介 26年前夜见山北中学的三年三班里，曾经有一位名叫「misaki」的学生。她不仅是位运动天才还是个优等生，个性平易近人广受众人喜爱的她却在某日突然猝死，极度悲伤的同班同学们无法接受这件事实，众人决定到毕业之前仍想像见崎还活著般度过每一天。因此见崎的座位就这样一大早上课会有人来打招呼，偶而还会有人藉机搭话——但这段美丽的插曲却对三年三班带来某种扭曲的现象。而在1998年春天，转到三年三班的榊原恒一，莫名感到班上的气氛持续著不安感。在这样的班级里，有位行事异于常人，孤高的美少女见崎鸣——一只眼睛遮著眼罩总是独自一人在画画，拥有不可思议的存在感让恒一不禁想试著接近她，但却就此陷入更深的谜团之中。","date":"2012-01-09","objectID":"/anime/another/:1:0","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 榊原恒一 さかきばら こういち、Sakakibara Koichi 男 阿部敦 2 见崎鸣 みさき めい、Misaki Mei 女 高森奈津美 3 敕使河原直哉 Naoya Teshigawara、敕使河原直哉、てしがわら なおや、炮哥 男 前野智昭 4 风见智彦 かざみともひこ 男 市来光弘 5 樱木由加利 樱木由香里、桜木ゆかり 女 野中藍 6 赤泽泉美 赤澤泉美、あかざわいずみ、Akazawa Izumi 女 米澤円 7 三神老师 三神先生、みかみ せんせい、Mikami Sensei 女 宮牧美沙代 8 怜子 女 榊原奈緒子 ","date":"2012-01-09","objectID":"/anime/another/:2:0","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Another 2012-01-09 12 樱花 2 Another 第0话 2012-05-25 1 bilibili ","date":"2012-01-09","objectID":"/anime/another/:3:0","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"MAD ","date":"2012-01-09","objectID":"/anime/another/:4:0","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"原作为山內泰延连载于《ガンガンONLINE》的漫画，是描写男子高中生的日常生活的轻喜剧作品。","date":"2012-01-09","objectID":"/anime/daily_lives_of_high_school_boys/","tags":null,"title":"男子高中生的日常","uri":"/anime/daily_lives_of_high_school_boys/"},{"categories":null,"content":"简介 原作为山內泰延连载于《ガンガンONLINE》的漫画，是描写男子高中生的日常生活的轻喜剧作品。 制作人员： 原作：山内泰延 导演：高松信司 分镜：池野昭二、吉村爱、高桥顺、河村智之 ","date":"2012-01-09","objectID":"/anime/daily_lives_of_high_school_boys/:1:0","tags":null,"title":"男子高中生的日常","uri":"/anime/daily_lives_of_high_school_boys/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 忠邦 男 入野自由 2 秀则 田畑ヒデノリ、Hidenori 男 杉田智和 3 吉武 吉竹、田中吉武、田中ヨシタケ、Yoshitake 男 鈴村健一 4 文学少女 小也、やっさん 女 日笠陽子 5 忠邦之妹 タダクニの妹 女 高垣彩陽 6 小苹果 女 悠木碧 7 元治 男 浪川大輔 8 唐泽俊之 からさわとしゆき 男 小野友樹 ","date":"2012-01-09","objectID":"/anime/daily_lives_of_high_school_boys/:2:0","tags":null,"title":"男子高中生的日常","uri":"/anime/daily_lives_of_high_school_boys/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 男子高中生的日常 2012-01-09 12 bilibili ","date":"2012-01-09","objectID":"/anime/daily_lives_of_high_school_boys/:3:0","tags":null,"title":"男子高中生的日常","uri":"/anime/daily_lives_of_high_school_boys/"},{"categories":null,"content":"天空湛蓝，万里无云。\n　　积雨云翻涌，仿佛要将彼岸的山隐藏。\n　　这是我们小镇上常见的风景。\n　　但是，也是无可替代的“盛夏”。\n　　那个男孩有一个模糊的想法“一无所有却想做点什么”，\n　　所以和同伴商量一起拍电影。\n　　就在那时，一个“特别”的女孩来到了这个小镇，\n　　然后将男孩的想法视为“特别”。\n　　男孩的名字是——雾岛海人。\n　　女孩的名字是——贵月一夏。\n　　他们的盛夏开始了。\n　　我们在那个盛夏等待——","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"简介 天空湛蓝，万里无云。 积雨云翻涌，仿佛要将彼岸的山隐藏。 这是我们小镇上常见的风景。 但是，也是无可替代的“盛夏”。 那个男孩有一个模糊的想法“一无所有却想做点什么”， 所以和同伴商量一起拍电影。 就在那时，一个“特别”的女孩来到了这个小镇， 然后将男孩的想法视为“特别”。 男孩的名字是——雾岛海人。 女孩的名字是——贵月一夏。 他们的盛夏开始了。 我们在那个盛夏等待—— 制作人员： 导演：长井龙雪 脚本：黑田洋介 分镜：铃木健太郎、樱井亲良、佐藤卓哉、樱美胜志、二瓶勇一、博史池畠 ","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/:1:0","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 贵月一夏 贵月一花、贵月一歌、貴月 イチカ、たかつき いちか、Takatsuki Ichika 女 戸松遥 2 雾岛海人 Kaito Kirishima、きりしま かいと、KIRISHIMA KAITO 男 島﨑信長 3 谷川柑菜 谷川柑菜、たにがわ かんな、TANIGAWA KANNA 女 石原夏織 4 石垣哲朗 石垣哲郎、石垣 哲朗、いしがき てつろう、Ishigaki Tetsurou 男 荻原秀樹 5 北原美樱 きたはら みお、Kitahara Mio 女 阿澄佳奈 6 山乃柠檬 やまの れもん、Yamano Remon、柠檬大魔王, Agent L","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/:2:0","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 在盛夏等待 2012-01-09 12 bilibili 2 在盛夏等待 特别篇 2014-08-29 1 bilibili ","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/:3:0","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"MAD ","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/:4:0","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"故事讲述了活跃于宇宙快艇社团，并在高级咖啡厅打工的充满朝气的女子高中生茉莉香，某天在她的面前突然出现自称是已逝的父亲的部下的一男一女，还受到了担任宇宙海贼船“弁天丸”的船长的邀请。一个世纪以前，根据在独立战争中发行的私船免许证，船长死后所有的海贼船由其子孙接班。踏入无法预料的新生活的茉莉香，在前方等待她的究竟是……","date":"2012-01-07","objectID":"/anime/bodacious_space_pirates/","tags":null,"title":"暴力宇宙海贼","uri":"/anime/bodacious_space_pirates/"},{"categories":null,"content":"简介 故事讲述了活跃于宇宙快艇社团，并在高级咖啡厅打工的充满朝气的女子高中生茉莉香，某天在她的面前突然出现自称是已逝的父亲的部下的一男一女，还受到了担任宇宙海贼船“弁天丸”的船长的邀请。一个世纪以前，根据在独立战争中发行的私船免许证，船长死后所有的海贼船由其子孙接班。踏入无法预料的新生活的茉莉香，在前方等待她的究竟是…… 制作人员： 原作：笹本祐一 导演：佐藤龙雄 脚本：伊藤美智子、水野健太郎、宫崎真一 分镜：岛崎奈奈子、安田贤司、森健 ","date":"2012-01-07","objectID":"/anime/bodacious_space_pirates/:1:0","tags":null,"title":"暴力宇宙海贼","uri":"/anime/bodacious_space_pirates/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 格里埃尔·塞雷尼提 Gruier Serenity、グリューエル・セレニティ 女 戸松遥 2 加藤茉莉香 加藤 茉莉香、かとう まりか、Katou Marika 女 小松未可子 3 千秋·栗原 栗原千秋、栗原千明、チアキ・クリハラ、Chiaki Kurihara 女 花澤香菜 4 百眼 ひゃくめ 男 藤原啓治 5 加藤梨理香 かとう りりか 女 甲斐田裕子 6 库里尔 クーリエ 堀江由衣 7 远藤麻美 遠藤 マミ、えんどう マミ、Endou Mami 女 小見川千明 8 杰妮·德里特尔 女 佐藤利奈 ","date":"2012-01-07","objectID":"/anime/bodacious_space_pirates/:2:0","tags":null,"title":"暴力宇宙海贼","uri":"/anime/bodacious_space_pirates/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 暴力宇宙海贼 2012-01-07 26 bilibili ","date":"2012-01-07","objectID":"/anime/bodacious_space_pirates/:3:0","tags":null,"title":"暴力宇宙海贼","uri":"/anime/bodacious_space_pirates/"},{"categories":null,"content":"RPGMAKER引擎制作的角色扮演游戏。这虽然是个像素画微型游戏，流程只有几个小时并且没有真正的战斗；\n但是本作凭借精美细腻的演出效果，和感人的故事发展获得了许多好评。尤其是在2011年GameSpot的年度最佳游戏中，胜过凯瑟琳，\n传送门2等众多大作而获得了最佳剧本奖。","date":"2011-11-01","objectID":"/game/to_the_moon/","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"简介 RPGMAKER引擎制作的角色扮演游戏。这虽然是个像素画微型游戏，流程只有几个小时并且没有真正的战斗； 但是本作凭借精美细腻的演出效果，和感人的故事发展获得了许多好评。尤其是在2011年GameSpot的年度最佳游戏中，胜过凯瑟琳， 传送门2等众多大作而获得了最佳剧本奖。 制作人员： 开发：自由鸟工作室 发行：心动 遊戲設計師：高瞰 主题歌演出：劳拉·鴫原 ","date":"2011-11-01","objectID":"/game/to_the_moon/:1:0","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 Johnathan Wyles Johnny H. Wyles 男 2 River E. Wyles River Elisabeth Wyles 女 3 Neil Watts 男 4 Eva Rosalene 女 5 Robert Lin Rob 男 6 Roxanne Winters Roxie 女 ","date":"2011-11-01","objectID":"/game/to_the_moon/:2:0","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"系列 系列名 发行时间 1 去月球 2011-11-01 ","date":"2011-11-01","objectID":"/game/to_the_moon/:3:0","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"配乐 ","date":"2011-11-01","objectID":"/game/to_the_moon/:4:0","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"MAD ","date":"2011-11-01","objectID":"/game/to_the_moon/:5:0","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"多年前，一个红衣男人向全宇宙宣称：能够吞噬一切物质的超巨型黑洞深处，隐藏着一个叫做彩虹海的奇迹之地。那里宝石遍地，黄金像河水般流淌，最重要的是，空中横跨着无数种颜色的巨大彩虹，可以实现人的任何愿望。被这个美妙的描绘所吸引，人们从宇宙的各个角落聚集，跟随红衣男人出发。但这个庞大的舰队却再没有回来。彩虹海被视为最可憎的谎言，而那个名叫麦林的红衣男人，从此被后人称为“红魔鬼”。\n十年后，麦林的儿子---麦当在地球上成长为少年，为了完成与父亲拉钩定下的承诺，决心再次出发寻找那个被视为谎言的彩虹海。麦当依靠父亲留下的彩虹石，得到属于自己的神奇力量：以烹饪手法进行战斗的能力。以此突破了邪恶组织“银河眼”在地球上设置的禁飞设施。","date":"2011-10-30","objectID":"/anime/rainbow_sea/","tags":null,"title":"星游记","uri":"/anime/rainbow_sea/"},{"categories":null,"content":"简介 多年前，一个红衣男人向全宇宙宣称：能够吞噬一切物质的超巨型黑洞深处，隐藏着一个叫做彩虹海的奇迹之地。那里宝石遍地，黄金像河水般流淌，最重要的是，空中横跨着无数种颜色的巨大彩虹，可以实现人的任何愿望。被这个美妙的描绘所吸引，人们从宇宙的各个角落聚集，跟随红衣男人出发。但这个庞大的舰队却再没有回来。彩虹海被视为最可憎的谎言，而那个名叫麦林的红衣男人，从此被后人称为“红魔鬼”。 十年后，麦林的儿子—麦当在地球上成长为少年，为了完成与父亲拉钩定下的承诺，决心再次出发寻找那个被视为谎言的彩虹海。麦当依靠父亲留下的彩虹石，得到属于自己的神奇力量：以烹饪手法进行战斗的能力。以此突破了邪恶组织“银河眼”","date":"2011-10-30","objectID":"/anime/rainbow_sea/:1:0","tags":null,"title":"星游记","uri":"/anime/rainbow_sea/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 麦当 男 阎萌萌 2 笛亚 女 山新 3 咕咚萌西 待定 郝幽玥 4 红眼 男 边江 5 米龙（现任） 米小龙 男 张杰 6 克拉 男 姜广涛 7 沙丁 男 龚格尔 8 旁白 ナレーター、解説、Narration/Narrator、Nareeshon、天之声、páng bái ","date":"2011-10-30","objectID":"/anime/rainbow_sea/:2:0","tags":null,"title":"星游记","uri":"/anime/rainbow_sea/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 星游记 2011-10-30 26 樱花 MAD ","date":"2011-10-30","objectID":"/anime/rainbow_sea/:3:0","tags":null,"title":"星游记","uri":"/anime/rainbow_sea/"},{"categories":null,"content":"以日本著名文学家坂口安吾所作《明治开化安吾捕物帖》为蓝本，将这部时代剧作品放置在近未来舞台大胆重现的原创作品，讲述侦探二人组：被称为最后的名侦探的结城新十郎，以及他的搭档——不可思议的美少年因果的故事。","date":"2011-10-13","objectID":"/anime/un-go/","tags":null,"title":"UN-GO","uri":"/anime/un-go/"},{"categories":null,"content":"简介 以日本著名文学家坂口安吾所作《明治开化安吾捕物帖》为蓝本，将这部时代剧作品放置在近未来舞台大胆重现的原创作品，讲述侦探二人组：被称为最后的名侦探的结城新十郎，以及他的搭档——不可思议的美少年因果的故事。 制作人员： 导演：水岛精二 脚本：会川升 分镜：黑川智之、难波日登志、五十岚卓哉、和田纯一、增井壮一、长崎健司 ","date":"2011-10-13","objectID":"/anime/un-go/:1:0","tags":null,"title":"UN-GO","uri":"/anime/un-go/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 结城新十郎 ゆうき しんじゅうろう 男 勝地涼 2 因果 いんが 双性 豊崎愛生 3 佐佐风守 ささ かざもり、Sasa Kazamori 松本まりか 4 海胜麟六 かいしょうりんろく 男 三木眞一郎 5 海胜梨江 かいしょう りえ 女 山本希望 6 虎山泉 こやま いずみ 女 本田貴子 7 速水星玄 はやみ せいげん 男 入野自由 8 别天王 べってんおう、bettenou ","date":"2011-10-13","objectID":"/anime/un-go/:2:0","tags":null,"title":"UN-GO","uri":"/anime/un-go/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 UN-GO 2011-10-13 11 bilibili ","date":"2011-10-13","objectID":"/anime/un-go/:3:0","tags":null,"title":"UN-GO","uri":"/anime/un-go/"},{"categories":null,"content":"朝浦的日本轻小说作品，由柴乃棹人负责插画。\n走进宿舍附近超市的高中一年级学生佐藤洋，在将手伸向面前贴有半价标签的便当后立刻失去了意识，醒来后已经倒在肉品区前面，而半价便当早已失去踪影，剩下的配菜也几乎都被买光了。在他要拿剩下的梅子饭团时，遇到了同校女生白粉花，以及看着两人样子的女学生。\n隔天再次前往超商的佐藤，从人称“寒冰魔女”的女学生枪水仙处得知发生在超市的半价便当争夺战后，自己踏进了半价便当争夺战的世界。","date":"2011-10-08","objectID":"/anime/ben_to/","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"简介 朝浦的日本轻小说作品，由柴乃棹人负责插画。 走进宿舍附近超市的高中一年级学生佐藤洋，在将手伸向面前贴有半价标签的便当后立刻失去了意识，醒来后已经倒在肉品区前面，而半价便当早已失去踪影，剩下的配菜也几乎都被买光了。在他要拿剩下的梅子饭团时，遇到了同校女生白粉花，以及看着两人样子的女学生。 隔天再次前往超商的佐藤，从人称“寒冰魔女”的女学生枪水仙处得知发生在超市的半价便当争夺战后，自己踏进了半价便当争夺战的世界。 制作人员： 原作：朝浦 导演：板垣伸 脚本：安川正吾、岸本美雪、山田由香、笔安一幸 分镜：向井雅浩、加藤敏幸 ","date":"2011-10-08","objectID":"/anime/ben_to/:1:0","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐藤洋 さとうよう、satou you 男 下野紘 2 枪水仙 槍水 仙、やりずい せん、Yarizui Sen 女 伊瀬茉莉也 3 著莪菖蒲 しゃが あやめ、Shaga ayame 女 加藤英美里 4 白粉花 おしろい はな、Oshiroi Hana 女 悠木碧 5 白梅梅 しらうめうめ 女 茅野愛衣 6 金城优 かねしろ ゆう 男 宮野真守 7 井上马醉木 井ノ上 あせび、いのうえ あせび、Inoue Asebi 女 竹達彩奈 8 泽桔梗 沢桔梗、さわぎ きょう、Kyo Sawagi 女 田村ゆかり ","date":"2011-10-08","objectID":"/anime/ben_to/:2:0","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 便·当 2011-10-08 12 bilibili ","date":"2011-10-08","objectID":"/anime/ben_to/:3:0","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"MAD ","date":"2011-10-08","objectID":"/anime/ben_to/:4:0","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"由于混血的外貌和金色的头发，个性其实十分善良的少年羽濑川小鹰成为了众人孤立的对象，这让他十分的苦恼。同样的，脸色难看个性孤僻的少女三日月夜空也只能在课后和自己幻想中的朋友有说有笑。这样两个孤独的人相遇了，一个专门为了交朋友而成立的社团“邻人社”应运而生。\n没想到，社团一经成立，居然招来了诸多个性奇怪的美少女——喜欢玩美少女游戏的美少女柏崎星奈，外表是妹子实则是爷们的楠辛村，超级高智商少女志熊理科，中二病重度患者羽濑川小鸠等等。这些没有朋友的家伙们聚在一起，居然也在不知不觉中交到了许多的朋友。","date":"2011-10-06","objectID":"/anime/haganai/","tags":null,"title":"我的朋友很少","uri":"/anime/haganai/"},{"categories":null,"content":"简介 由于混血的外貌和金色的头发，个性其实十分善良的少年羽濑川小鹰成为了众人孤立的对象，这让他十分的苦恼。同样的，脸色难看个性孤僻的少女三日月夜空也只能在课后和自己幻想中的朋友有说有笑。这样两个孤独的人相遇了，一个专门为了交朋友而成立的社团“邻人社”应运而生。 没想到，社团一经成立，居然招来了诸多个性奇怪的美少女——喜欢玩美少女游戏的美少女柏崎星奈，外表是妹子实则是爷们的楠辛村，超级高智商少女志熊理科，中二病重度患者羽濑川小鸠等等。这些没有朋友的家伙们聚在一起，居然也在不知不觉中交到了许多的朋友。 制作人员： 原作：平坂读 导演：斋藤久 脚本：浦畑达彦 分镜：远藤广隆、喜多幡彻、金崎贵臣 演出","date":"2011-10-06","objectID":"/anime/haganai/:1:0","tags":null,"title":"我的朋友很少","uri":"/anime/haganai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 羽濑川小鹰 はせがわ こだか、Hasegawa Kodoka、鹰 男 木村良平 2 三日月夜空 みかづき よぞら、Mikazuki Yozora、空 女 井上麻里奈 3 柏崎星奈 Sena Kashiwazaki、柏崎 星奈、かしわざき せな、Kashiwazaki Sena、肉，星摸笨泥 女 伊藤かな恵 4 楠幸村 くすのき ゆきむら、Kusunoki Yukimura 女 山本希望 5 志熊理科 しぐま りか、Shiguma Rika 女 福圓美里 6 羽濑川小鸠 はせがわ こばと、Hasegawa Kobato 女 花澤香菜 7 高山玛利亚 たかやま ","date":"2011-10-06","objectID":"/anime/haganai/:2:0","tags":null,"title":"我的朋友很少","uri":"/anime/haganai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我的朋友很少 2011-10-06 12 bilibili 2 我的朋友很少NEXT 2013-01-10 12 bilibili ","date":"2011-10-06","objectID":"/anime/haganai/:3:0","tags":null,"title":"我的朋友很少","uri":"/anime/haganai/"},{"categories":null,"content":"       从小时候起，绫濑千早的理想就只有一个——辅佐姐姐绫濑千岁称为日本第一的模特，为了实现这个理想，千早可谓是不择手段。但是，一个名为绵谷新的转学生彻底打碎了她的幻觉。“不是自己的事就不算梦想！”被绵谷一语点醒的千早决定将理想转移到绵谷教会她的“小仓百人一首竞技歌牌”上，一个全新的，为了自己的理想而不断奋斗的千早新鲜出炉了！\n作为青梅竹马，完美少年真岛太一一直暗恋着千早，可不知如何表达感情的他却总是忍不住的要欺负心爱着的千早。眼看着千早和绵谷因为歌牌越走越近，太一决定加入他们的“歌牌部”，同时也开始了千早的争夺战。时光飞逝，三人早已因为歌牌而结下了深厚的友谊，毕业在即，三人约定，只要歌牌存在一天，他们就终会再见面。","date":"2011-10-04","objectID":"/anime/chihaya_furu/","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"简介 从小时候起，绫濑千早的理想就只有一个——辅佐姐姐绫濑千岁称为日本第一的模特，为了实现这个理想，千早可谓是不择手段。但是，一个名为绵谷新的转学生彻底打碎了她的幻觉。“不是自己的事就不算梦想！”被绵谷一语点醒的千早决定将理想转移到绵谷教会她的“小仓百人一首竞技歌牌”上，一个全新的，为了自己的理想而不断奋斗的千早新鲜出炉了！ 作为青梅竹马，完美少年真岛太一一直暗恋着千早，可不知如何表达感情的他却总是忍不住的要欺负心爱着的千早。眼看着千早和绵谷因为歌牌越走越近，太一决定加入他们的“歌牌部”，同时也开始了千早的争夺战。时光飞逝，三人早已因为歌牌而结下了深厚的友谊，毕业在即，三人约定，只要歌牌存在一","date":"2011-10-04","objectID":"/anime/chihaya_furu/:1:0","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 绫濑千早 綾瀬 千早、あやせ ちはや、Ayase Chihaya 女 瀬戸麻沙美 2 绵谷新 わたや あらた、Wataya Arata、メガネくん 男 寺崎裕香 3 真岛太一 真島 太一、ましま たいち、Mashima Taichi 男 宮野真守 4 大江奏 大江 奏、おおえ かなで、Ooe Kanade 女 茅野愛衣 5 西田优征 西田 優征、にしだ ゆうせい、Nishida Yuusei 男 奈良徹 6 驹野勉 駒野 勉、こまの つとむ、Komano Tsutomu 男 代永翼 7 若宫诗畅 若宮 詩暢、わかみや しのぶ、wakamiya shinobu","date":"2011-10-04","objectID":"/anime/chihaya_furu/:2:0","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 歌牌情缘 2011-10-04 25 bilibili 2 歌牌情缘2 2013-01-11 25 bilibili 3 歌牌情缘3 2019-10-22 24 bilibili ","date":"2011-10-04","objectID":"/anime/chihaya_furu/:3:0","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"MAD ","date":"2011-10-04","objectID":"/anime/chihaya_furu/:4:0","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"被各国分割统治的中世纪的神州·日本。在那上空中由八艘船组成的都市舰“武藏”航行着……在遥远的未来。经过了“重奏统合争乱”，并把联繫着人类的命运的“圣谱”作为原本历史的再现而执行的各国。然后，是各式各样把迷惑与决意藏于胸口，前进开拓着未来的人们。把互相重合的中世纪世界作为舞台，学生们在学园国家间的抗争正式上演了！","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"简介 被各国分割统治的中世纪的神州·日本。在那上空中由八艘船组成的都市舰“武藏”航行着……在遥远的未来。经过了“重奏统合争乱”，并把联繫着人类的命运的“圣谱”作为原本历史的再现而执行的各国。然后，是各式各样把迷惑与决意藏于胸口，前进开拓着未来的人们。把互相重合的中世纪世界作为舞台，学生们在学园国家间的抗争正式上演了！ 制作人员： 原作：川上稔 导演：小野学 脚本：水上清资、富田赖子、浦畑达彦、砂山藏澄 分镜：京极尚彦、宅野诚起、田边泰裕 ","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/:1:0","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 葵·托利 Tori Aoi、あおい・トーリ、“不可能男” / 「インポッシブル」 男 福山潤 2 赫莱森·阿利亚达斯特 Horizon Ariadust、ホライゾン・アリアダスト、P-01s 女 茅原実里 3 本多·正纯 Honda Masazumi、ほんだ まさずみ 女 沢城みゆき 4 葵·喜美 Aoi Kimi、あおい・きみ 女 斎藤千和 5 点蔵・クロスユナイト てんぞう・クロスユナイト 男 小野大輔 6 マルゴット・ナイト 女 東山奈央 7 マルガ・ナルゼ 女 新田恵海 8 直政 なおまさ 女 真堂圭 ","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/:2:0","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 境界线上的地平线 2011-10-01 13 bilibili 2 境界线上的地平线 第二季 2012-07-07 13 樱花 3 境界线上的地平线 Blu-ray BOX 特典动画 2018-12-21 1 bilibili ","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/:3:0","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"MAD ","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/:4:0","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"　　夜知春亮收到了父亲突如其来自国外寄回家的宅配，那是一个非常重的神秘黑色立方体。感到疑惑的春亮，虽然隐约觉得有麻烦的事要发生，但还是漫不在意地将其搁置不管。\n　　——就在当晚，睡醒的春亮听到了可疑的声响。\n　　难道遭小偷了……？\n　　在紧张的气氛之中，春亮发现了一名入侵者。\n　　那竟然是个在明月照耀下散发著梦幻气息的——“全裸的女煎饼小偷！？”\n　　自不凡的邂逅展开序曲，人气作家水濑叶月的新系列作品登场！\n　　标题中的C是C的三次方的意思，集Cube「立方体」×Cursed「诅咒」×Curious「好奇」三层的意义，也是女主角受诅咒的道具菲娅的特征。","date":"2011-10-01","objectID":"/anime/c3/","tags":null,"title":"C3 -魔方少女-","uri":"/anime/c3/"},{"categories":null,"content":"简介 夜知春亮收到了父亲突如其来自国外寄回家的宅配，那是一个非常重的神秘黑色立方体。感到疑惑的春亮，虽然隐约觉得有麻烦的事要发生，但还是漫不在意地将其搁置不管。 ——就在当晚，睡醒的春亮听到了可疑的声响。 难道遭小偷了……？ 在紧张的气氛之中，春亮发现了一名入侵者。 那竟然是个在明月照耀下散发著梦幻气息的——“全裸的女煎饼小偷！？” 自不凡的邂逅展开序曲，人气作家水濑叶月的新系列作品登场！ 标题中的C是C的三次方的意思，集Cube「立方体」×Cursed「诅咒」×Curious「好奇」三层的意义，也是女主角受诅咒的道具菲娅的特征。 制作人员： 原作：水濑叶月 导演：大沼心 脚本：横手美智子 分","date":"2011-10-01","objectID":"/anime/c3/:1:0","tags":null,"title":"C3 -魔方少女-","uri":"/anime/c3/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 夜知春亮 夜知 春亮、やち はるあき、Yachi Haruaki 男 梶裕貴 2 菲雅 Fear、フィア 女 田村ゆかり 3 村正此叶 村正 このは、むらまさ このは、Muramasa Konoha 女 茅原実里 4 上野锥霞 うえの きりか、Ueno Kirika 女 喜多村英梨 5 樱参白穗 桜参 白穂、さくらまいり しらほ、Sakuramairi Shiraho 女 斎藤千和 6 萨文蕾提 サヴェレンティ 井口裕香 7 人形原黑绘 にんぎょうはら くろえ、Ningyouhara Kuroe 女 小倉唯 8 木乃伊师 Mummy Maker、阿曼达·咖咯","date":"2011-10-01","objectID":"/anime/c3/:2:0","tags":null,"title":"C3 -魔方少女-","uri":"/anime/c3/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 C3 -魔方少女- 2011-10-01 12 樱花 ","date":"2011-10-01","objectID":"/anime/c3/:3:0","tags":null,"title":"C3 -魔方少女-","uri":"/anime/c3/"},{"categories":null,"content":"《Fate/Zero》，2006年12月29日由TYPE-MOON与Nitro+合作发售的小说。为《Fate/stay night》的前传，以描述第四次圣杯之战为主，故事原著《Fate/stay night》则为第五次圣杯之战。\n\n这里是故事的原点（zero）---\n\n为了获得圣杯能实现奇迹的法力，七个魔术士召唤出七人的英灵，展开了一场直到剩下最后一个人为止的终极战争----圣杯战争。\n之前三次没有结果的战役不足以让这场战争结束，第四场战役如今有如弦上之箭，一触即发。\n寄托着必胜的信念，魔术师们来到了被称作「冬木」的战场。但是在他们当中有一个人却不知道自己是为何而战。他叫---言峰绮礼。\n命运的引导让绮礼逐渐失去了自己的判断力，他不明白为什么自己会被授予令咒。但是，命运很快地安排他遇到了一个命中注定的宿敌---卫宫切嗣。\n这个男人想要得到圣杯的欲望比任何人都要强烈，使用的手段也是最残忍的。\n在大人气游戏『Fate/stay night』中仅略有提到过的，十年前发生的「第四次圣杯战争」的真相。士郎的养父，凛的父亲，以及年轻气盛的言峰绮礼是如何参与这场战争的，真相即将浮出水面。","date":"2011-10-01","objectID":"/anime/fate_zero/","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"简介 《Fate/Zero》，2006年12月29日由TYPE-MOON与Nitro+合作发售的小说。为《Fate/stay night》的前传，以描述第四次圣杯之战为主， 故事原著《Fate/stay night》则为第五次圣杯之战。 这里是故事的原点（zero）— 为了获得圣杯能实现奇迹的法力，七个魔术士召唤出七人的英灵，展开了一场直到剩下最后一个人为止的终极战争—-圣杯战争。 之前三次没有结果的战役不足以让这场战争结束，第四场战役如今有如弦上之箭，一触即发。 寄托着必胜的信念，魔术师们来到了被称作「冬木」的战场。但是在他们当中有一个人却不知道自己是为何而战。他叫—言峰绮礼。 命运的引导让","date":"2011-10-01","objectID":"/anime/fate_zero/:1:0","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 卫宫切嗣 衛宮切嗣、えみや きりつぐ、Emiya Kiritsugu、アサシン / Assassin 男 小山力也 2 阿尔托莉雅·潘德拉贡 Saber、呆毛王、吾王、青王、骑士王、棉被王、亚瑟王、蓝Saber、元祖Saber、Altria Pendragon、セイバー 女 川澄綾子 3 爱丽丝菲尔·冯·爱因兹贝伦 Irisviel von Einzbern、アイリスフィール・フォン・アインツベルン、Airisufīru fon aintsuberun 女 大原さやか 4 远坂时臣 遠坂時臣、とおさか ときおみ、Tōsaka Tokiomi 男 速水奨 5 ","date":"2011-10-01","objectID":"/anime/fate_zero/:2:0","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Fate/Zero 2011-10-01 25 bilibili ","date":"2011-10-01","objectID":"/anime/fate_zero/:3:0","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"MAD ","date":"2011-10-01","objectID":"/anime/fate_zero/:4:0","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"某年夏天，6岁小女孩竹川萤来到爷爷家度假，她闯进了传说住满妖怪的山神森林。正当她因为迷路而焦急万分的时候，一个戴着狐狸面具的大男孩出现在她面前，并引领着萤找到回家的路。虽然萤分外感激，可是男孩却禁止她碰触自己的身体，原来这名叫银的男孩并非人类，他一旦被人类碰触就会烟消云散。在此后的日子里，萤和银成为好朋友，他们走遍了森林的每一个角落玩耍。日复一日，年复一年，每到夏天的时候萤就会如约来到森林和好朋友见面。她遵守着和银的约定，无论如何也不碰触银的身体。随着年龄的增长，萤和银对彼此的情感都悄悄发生了变化，他们共同期待相聚的日子，共同期待拥抱对方……","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"简介 某年夏天，6岁小女孩竹川萤来到爷爷家度假，她闯进了传说住满妖怪的山神森林。正当她因为迷路而焦急万分的时候，一个戴着狐狸面具的大男孩出现在她面前，并引领着萤找到回家的路。虽然萤分外感激，可是男孩却禁止她碰触自己的身体，原来这名叫银的男孩并非人类，他一旦被人类碰触就会烟消云散。在此后的日子里，萤和银成为好朋友，他们走遍了森林的每一个角落玩耍。日复一日，年复一年，每到夏天的时候萤就会如约来到森林和好朋友见面。她遵守着和银的约定，无论如何也不碰触银的身体。随着年龄的增长，萤和银对彼此的情感都悄悄发生了变化，他们共同期待相聚的日子，共同期待拥抱对方…… 制作人员： 原作：绿川幸 导演：大森贵弘 音","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/:1:0","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 银 男 内山昂輝 2 竹川萤 竹川 蛍、たけかわほたる 女 佐倉綾音 ","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/:2:0","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 萤火之森 2011-09-17 45m bilibili ","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/:3:0","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"MAD ","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/:4:0","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"在一间由猫经营的酒吧里，有一群猫在谈话。从他们的言谈之间可以隐约得知，一场可能会打破时空之间界限的狂凶之盛宴即将到来。\n冬木市再度举行了让魔术师为之疯狂得“圣杯争霸战”，参与争夺的卫宫士郎、Saber、远坂凛、Archer、葛木宗一郎、Rider等人，结成不同的小组并且对圣杯都抱着势在必得的野心。然而出人意料的是，这一次必须改以网球、花牌、抽卡片、黑胡子等民间游戏来决定胜负。\n就在所有参赛者纷纷于游戏中精疲力尽之时，圣杯赫然出现在大家面前。对圣杯痛恨无比的卫宫士郎，决定以投影出来的武器将之毁灭，不料被劈开的圣杯中竟然冒出了原本不属于这个时空里的猫姬！\n随着猫姬的到来，一场将不同次元里的魔术师纠缠在一起的厮杀，无可避免地正式揭开了序幕。","date":"2011-08-14","objectID":"/anime/carnival_phantasm/","tags":null,"title":"幻想嘉年华","uri":"/anime/carnival_phantasm/"},{"categories":null,"content":"简介 在一间由猫经营的酒吧里，有一群猫在谈话。从他们的言谈之间可以隐约得知，一场可能会打破时空之间界限的狂凶之盛宴即将到来。 冬木市再度举行了让魔术师为之疯狂得“圣杯争霸战”，参与争夺的卫宫士郎、Saber、远坂凛、Archer、葛木宗一郎、Rider等人，结成不同的小组并且对圣杯都抱着势在必得的野心。然而出人意料的是，这一次必须改以网球、花牌、抽卡片、黑胡子等民间游戏来决定胜负。 就在所有参赛者纷纷于游戏中精疲力尽之时，圣杯赫然出现在大家面前。对圣杯痛恨无比的卫宫士郎，决定以投影出来的武器将之毁灭，不料被劈开的圣杯中竟然冒出了原本不属于这个时空里的猫姬！ 随着猫姬的到来，一场将不同次元里的魔","date":"2011-08-14","objectID":"/anime/carnival_phantasm/:1:0","tags":null,"title":"幻想嘉年华","uri":"/anime/carnival_phantasm/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿尔托莉雅·潘德拉贡 Saber、呆毛王、吾王、青王、骑士王、棉被王、亚瑟王、蓝Saber、元祖Saber、Altria Pendragon、セイバー 女 川澄綾子 2 卫宫士郎 衛宮 士郎、えみや しろう、Emiya Shirou 男 杉山紀彰 3 猫姬 猫アルク、猫arc、Neco-Arc、ねこあるく、Neko Aruku 柚木涼香 4 混沌猫姬 Neco-Arc·Chaos、Neko Aruku Kaosu 中田譲治 5 爱尔奎特·布伦史坦德 Arcueid Brunestud、真祖Arcueid 女 柚木涼香 6 远野志贵 遠野 志貴、とうの しき、","date":"2011-08-14","objectID":"/anime/carnival_phantasm/:2:0","tags":null,"title":"幻想嘉年华","uri":"/anime/carnival_phantasm/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 幻想嘉年华 2011-08-14 12 bilibili ","date":"2011-08-14","objectID":"/anime/carnival_phantasm/:3:0","tags":null,"title":"幻想嘉年华","uri":"/anime/carnival_phantasm/"},{"categories":null,"content":"1963年，日本横滨。在可以望见海港的小山丘上，松崎家的三姐弟居住于此。她们的父亲亡故，母亲又忙于工作，16岁的长女松崎海不仅肩负起照顾弟弟妹妹的重任，还要负责照料寄宿于家中的客人们的起居。每天早晨，松崎海面朝大海，为过往的船只升起信号旗，衷心祈愿平安航行。乘坐拖船上学的17岁男孩风间俊，每日见证着信号旗迎风飞舞。\n东京奥运会即将召开，日本上下试图建立美好崭新的世界，被认为古旧落后的东西理所应当便遭到破坏。在汹涌躁动的时代大潮下，横滨的某所高中也正经历着一场不大不小的纷争。委身于一幢历史悠久的建筑物内的校文化部，承载着数代学生的依恋与回忆，这里更被学生们亲昵地称作“拉丁区（Quartier Latin）”。而如今，这幢古老的建筑面临着拆除的命运。为了保护心中的圣地，在新闻部任职的俊以极其激烈的方式向校方以及同学们传达着保留建筑物的意义。在这一过程中，海也不知不觉参与进来，她提议对“拉丁区”进行大扫除，让人们知道这里是一个多么优雅舒适的所在。借着这一事件，海和俊渐渐熟捻，且相互吸引。但是无情的现实摆在了两个不谙世事的年轻人面前。\n“如果讨厌我了，请清楚地说出来。”\n“我们可能是兄妹。”\n战争的残酷，战后的混乱，以及父辈们的爱恋周转，无不左右着海和俊的未来。","date":"2011-07-16","objectID":"/anime/from_up_on_poppy_hill/","tags":null,"title":"来自虞美人之坡","uri":"/anime/from_up_on_poppy_hill/"},{"categories":null,"content":"简介 1963年，日本横滨。在可以望见海港的小山丘上，松崎家的三姐弟居住于此。她们的父亲亡故，母亲又忙于工作，16岁的长女松崎海不仅肩负起照顾弟弟妹妹的重任，还要负责照料寄宿于家中的客人们的起居。每天早晨，松崎海面朝大海，为过往的船只升起信号旗，衷心祈愿平安航行。乘坐拖船上学的17岁男孩风间俊，每日见证着信号旗迎风飞舞。 东京奥运会即将召开，日本上下试图建立美好崭新的世界，被认为古旧落后的东西理所应当便遭到破坏。在汹涌躁动的时代大潮下，横滨的某所高中也正经历着一场不大不小的纷争。委身于一幢历史悠久的建筑物内的校文化部，承载着数代学生的依恋与回忆，这里更被学生们亲昵地称作“拉丁区（Quartie","date":"2011-07-16","objectID":"/anime/from_up_on_poppy_hill/:1:0","tags":null,"title":"来自虞美人之坡","uri":"/anime/from_up_on_poppy_hill/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 来自虞美人之坡 2011-07-16 1:30:51 樱花 ","date":"2011-07-16","objectID":"/anime/from_up_on_poppy_hill/:2:0","tags":null,"title":"来自虞美人之坡","uri":"/anime/from_up_on_poppy_hill/"},{"categories":null,"content":"幾原邦彦所监督的原创动画，以高仓家的三兄妹——双子兄弟高仓冠叶和高仓晶马，以及体弱多病的妹妹高仓阳毬为中心展开的故事。\n某天兄弟二人带着时日无多的妹妹去水族馆游玩，久未外出的阳毬在人群中忽然倒下气绝。之后在停尸间，在绝望的兄弟二人面前，死去的妹妹又突然戴着企鹅帽子站起来，大喊道“生存战略！”“妾身已为此女续命！”然而当企鹅帽子掉落时，阳毬又恢复成了平常的样子。\n靠着不可思议的企鹅帽子，阳毬的生命得以延续。当戴着企鹅帽的阳毬再次出现时，她对高仓兄弟下令道：“去拿到企鹅罐！”","date":"2011-07-07","objectID":"/anime/penguin_drum/","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"简介 幾原邦彦所监督的原创动画，以高仓家的三兄妹——双子兄弟高仓冠叶和高仓晶马，以及体弱多病的妹妹高仓阳毬为中心展开的故事。 某天兄弟二人带着时日无多的妹妹去水族馆游玩，久未外出的阳毬在人群中忽然倒下气绝。之后在停尸间，在绝望的兄弟二人面前，死去的妹妹又突然戴着企鹅帽子站起来，大喊道“生存战略！”“妾身已为此女续命！”然而当企鹅帽子掉落时，阳毬又恢复成了平常的样子。 靠着不可思议的企鹅帽子，阳毬的生命得以延续。当戴着企鹅帽的阳毬再次出现时，她对高仓兄弟下令道：“去拿到企鹅罐！” 制作人员： 导演：几原邦彦 脚本：古川知宏、伊神贵世、金子伸吾 分镜：山崎光惠、后藤圭二 ","date":"2011-07-07","objectID":"/anime/penguin_drum/:1:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 高仓冠叶 たかくらかんば、Takakura Kanba 男 木村昴 2 高仓晶马 たかくら しょうま、Takakura Shouma 男 木村良平 3 高仓阳毬 たかくら ひまり、Takakura Himari 女 荒川美穂 4 荻野目苹果 おぎのめ りんご、Oginome Ringo 女 三宅麻理恵 5 多蕗桂树 たぶき　けいじゅ、Tabuki Keijyu 男 石田彰 6 时笼百合 女 能登麻美子 7 夏芽真砂子 なつめ まさこ、Natsume Masako、碾碎姐 女 堀江由衣 8 渡濑真悧 わたせ さねとし、沉醉哥 男 小泉豊 ","date":"2011-07-07","objectID":"/anime/penguin_drum/:2:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 回转企鹅罐 2011-07-07 24 樱花 ","date":"2011-07-07","objectID":"/anime/penguin_drum/:3:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"配乐 ","date":"2011-07-07","objectID":"/anime/penguin_drum/:4:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"MAD ","date":"2011-07-07","objectID":"/anime/penguin_drum/:5:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"30岁的单身爸爸养6岁女儿(非亲生)的温情故事。\n由制作过《东之伊甸》和《好想告诉你》的Production I.G担任动画制作。\n同年夏天将公映由松山健一主演的三次元电影。","date":"2011-07-07","objectID":"/anime/usagi_drop/","tags":null,"title":"白兔糖","uri":"/anime/usagi_drop/"},{"categories":null,"content":"简介 30岁的单身爸爸养6岁女儿(非亲生)的温情故事。 由制作过《东之伊甸》和《好想告诉你》的Production I.G担任动画制作。 同年夏天将公映由松山健一主演的三次元电影。 制作人员： 原作：宇仁田由美 导演：龟井干太 脚本：岸本卓 分镜：宇井良和、金子秀一、鹤冈耕次郎、井上锐、满仲劝、森田宏幸 ","date":"2011-07-07","objectID":"/anime/usagi_drop/:1:0","tags":null,"title":"白兔糖","uri":"/anime/usagi_drop/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鹿贺凛 鹿賀りん、かが りん、Kaga Rin 女 松浦愛弓 2 河地大吉 河地 大吉、かわち だいきち、Kawachi Daikichi 男 土田大 3 二谷由佳里 二谷ゆかり、にたに ゆかり、コウキママ 女 大原さやか 4 前田春子 まえだ はるこ、Maeda Haruko 女 植田佳奈 5 前田丽奈 まえだ れな、Maeda Rena 女 須藤菜々子 6 吉井正子 よしい まさこ、Yoshii Masako 女 坂本真綾 7 鹿贺宋一 鹿賀 宋一、かが そういち、Kaga Souichi 男 有川博 8 后藤 後藤さん、ごとうさん、Gotou-san ","date":"2011-07-07","objectID":"/anime/usagi_drop/:2:0","tags":null,"title":"白兔糖","uri":"/anime/usagi_drop/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 白兔糖 2011-07-07 11 bilibili ","date":"2011-07-07","objectID":"/anime/usagi_drop/:3:0","tags":null,"title":"白兔糖","uri":"/anime/usagi_drop/"},{"categories":null,"content":"MAD ","date":"2011-07-07","objectID":"/anime/usagi_drop/:4:0","tags":null,"title":"白兔糖","uri":"/anime/usagi_drop/"},{"categories":null,"content":"　　男主角坂町近次郎是私立浪岚学园的一位普通的二年级学生，他具有一种非常特殊的体质，那就是女性恐惧症－－只要肌肤接触到女性，就会起排斥反应引起痉挛抽搐，严重的时候就是鼻血乱喷气绝身亡。自己的名字中也含有了标题中的「胆怯、懦弱」的成份在里面。\n\n　　而女主角近卫昴是坂町近次郎的同班同学凉月奏的管家，因为小时候的事故而导致自己具备了「刀具恐惧症」，虽然是女子之身却女扮男装做起了管家，平时也穿着男装陪同大小姐去学校。不过凉月家的当家对她提出了「三年内，只要被任何一个人识破自己的女孩身份，立刻解雇管家工作」的要求，结果她还是非常戏剧性地被男主角给发现了自己的秘密。\n\n　　坂町近次郎究竟能否保守住这份秘密？自此，他和凉月奏以及近卫昴之间不得不说的故事就此展开！","date":"2011-07-07","objectID":"/anime/mayo_chiki/","tags":null,"title":"迷茫管家与懦弱的我","uri":"/anime/mayo_chiki/"},{"categories":null,"content":"简介 男主角坂町近次郎是私立浪岚学园的一位普通的二年级学生，他具有一种非常特殊的体质，那就是女性恐惧症－－只要肌肤接触到女性，就会起排斥反应引起痉挛抽搐，严重的时候就是鼻血乱喷气绝身亡。自己的名字中也含有了标题中的「胆怯、懦弱」的成份在里面。 而女主角近卫昴是坂町近次郎的同班同学凉月奏的管家，因为小时候的事故而导致自己具备了「刀具恐惧症」，虽然是女子之身却女扮男装做起了管家，平时也穿着男装陪同大小姐去学校。不过凉月家的当家对她提出了「三年内，只要被任何一个人识破自己的女孩身份，立刻解雇管家工作」的要求，结果她还是非常戏剧性地被男主角给发现了自己的秘密。 坂町近次郎究竟能否保守住这份秘密？自此，","date":"2011-07-07","objectID":"/anime/mayo_chiki/:1:0","tags":null,"title":"迷茫管家与懦弱的我","uri":"/anime/mayo_chiki/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 近卫昴 近衛 スバル、このえ スバル、Konoe Subaru 女 井口裕香 2 坂町近次郎 坂町 近次郎、さかまち きんじろう、Sakamachi Kinjirou 男 日野聡 3 凉月奏 涼月 奏、すずつき かなで、Suzutsuki Kanade 女 喜多村英梨 4 坂町红羽 坂町 紅羽、さかまち くれは、Sakamachi Kureha 女 花澤香菜 5 宇佐美政宗 宇佐美 マサムネ、うさみ マサムネ、Usami Masamune 女 伊瀬茉莉也 6 鸣海奈香流 鳴海 ナクル、なるみ ナクル、Narumi Nakuru 女 阿澄佳奈 7 早乙女莓 早","date":"2011-07-07","objectID":"/anime/mayo_chiki/:2:0","tags":null,"title":"迷茫管家与懦弱的我","uri":"/anime/mayo_chiki/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 迷茫管家与懦弱的我 2011-07-07 13 樱花 ","date":"2011-07-07","objectID":"/anime/mayo_chiki/:3:0","tags":null,"title":"迷茫管家与懦弱的我","uri":"/anime/mayo_chiki/"},{"categories":null,"content":"　　偶像，是女孩子们一直以来的憧憬。但能站在顶点的，只有仅仅数人。13位少女，就此经她们所属的事务所“765 Prodution”，跨进了那个充满竞争的世界……出道约半年，事务所来了一位全新的制作人。他跟少女们都下定决心，向顶级偶像之路进发…… 本作是由『A-1 Pictures』改编同名游戏于2011年7月制作的最新版动画，讲述了『765production』所属的偶像们活跃与成长的物语。\n\n2011年1月10日，在“The Idolm@ster 2 765pro H@ppiness New Ye@r P@rty!! 2011”的现场活动中，隆重地隆动地宣布了一个使所有fans非常雀跃的消息——「THE IDOLM@STER(偶像大师)」的动画化计划正式启动了! 那时虽然已经宣布了动画化，但是以什么媒传播放则还没有公布，再次TV动画，还是直接剧场版，还是只推出OVA? 这些疑问都在最新一号的「Megami杂志 3月号」上得以解答了，「THE IDOLM@STER」TV动画化正式决定!! ","date":"2011-07-07","objectID":"/anime/the_idolmaster/","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"简介 偶像，是女孩子们一直以来的憧憬。但能站在顶点的，只有仅仅数人。13位少女，就此经她们所属的事务所“765 Prodution”，跨进了那个充满竞争的世界……出道约半年，事务所来了一位全新的制作人。他跟少女们都下定决心，向顶级偶像之路进发…… 本作是由『A-1 Pictures』改编同名游戏于2011年7月制作的最新版动画，讲述了『765production』所属的偶像们活跃与成长的物语。 2011年1月10日，在“The Idolm@ster 2 765pro H@ppiness New Ye@r P@rty!! 2011”的现场活动中，隆重地隆动地宣布了一个使所有fans非常雀跃的消息","date":"2011-07-07","objectID":"/anime/the_idolmaster/:1:0","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天海春香 あまみ はるか、Amami Haruka、阁下 女 中村繪里子 2 星井美希 ほしい みき、Hoshii Miki 女 長谷川明子 3 如月千早 きさらぎ ちはや、Kisaragi Chihaya、72, 歌神 女 今井麻美 4 高槻弥生 たかつき やよい、Takatsuki Yayoi、やよいっち 女 仁後真耶子 5 萩原雪步 萩原雪歩、はぎわら ゆきほ、Hagiwara Yukiho、ゆきぴょん 女 浅倉杏美 6 菊地真 菊地 真、きくち まこと、Kikuchi Makoto 女 平田宏美 7 双海亚美 Ami Futami、ふたみ あみ、Fu","date":"2011-07-07","objectID":"/anime/the_idolmaster/:2:0","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 偶像大师 2011-07-07 26 bilibili 2 偶像大师 闪耀祭典 2012-10-25 3 bilibili 3 偶像大师 剧场版 向着光辉的彼岸！ 2014-01-25 1 bilibili ","date":"2011-07-07","objectID":"/anime/the_idolmaster/:3:0","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"MAD ","date":"2011-07-07","objectID":"/anime/the_idolmaster/:4:0","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"原作是由山村哉(やまむらはじめ)创作、在漫画杂志《月刊少年GENE-X》上连载的漫画。\n在大学生匡平长大的空手村中，祭祀着一种被称为“玖吼理”的“案山子”人偶。匡平舍弃故乡、来到东京，开始了愉快的学生生活，但在妹妹诗绪和从村子中逃出的阿幾带着玖吼理到来之后，生活完全改变了……匡平到底能够逃离故乡吗？","date":"2011-07-05","objectID":"/anime/kamisama_dolls/","tags":null,"title":"神样DOLLS","uri":"/anime/kamisama_dolls/"},{"categories":null,"content":"简介 原作是由山村哉(やまむらはじめ)创作、在漫画杂志《月刊少年GENE-X》上连载的漫画。 在大学生匡平长大的空手村中，祭祀着一种被称为“玖吼理”的“案山子”人偶。匡平舍弃故乡、来到东京，开始了愉快的学生生活，但在妹妹诗绪和从村子中逃出的阿幾带着玖吼理到来之后，生活完全改变了……匡平到底能够逃离故乡吗？ 制作人员： 原作：山村哉 导演：岸诚二 脚本：上江洲诚 分镜：菅原静贵、奥胁雅晴、后藤圭二、筱原俊哉、平井义通 ","date":"2011-07-05","objectID":"/anime/kamisama_dolls/:1:0","tags":null,"title":"神样DOLLS","uri":"/anime/kamisama_dolls/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 枸雅匡平 枸雅 匡平、くが キョウヘイ、Kuga Kyouhei 男 岡本信彦 2 史场日日乃 史場 日々乃、しば ヒビノ、Shiba Hibino 女 茅野愛衣 3 枸雅诗绪 枸雅 詩緒、くが ウタオ、Kuga Utao 女 福圓美里 4 玖吼理 玖吼理、ククリ、Kukuri 5 枸雅阿几 枸雅 阿幾、くが アキ、Kuga Aki 男 木村良平 6 日向真昼 Mahiru Hyuuga、ひゅうがまひる 女 花澤香菜 7 暗密刀 クラミツハ、kuramitsuha ","date":"2011-07-05","objectID":"/anime/kamisama_dolls/:2:0","tags":null,"title":"神样DOLLS","uri":"/anime/kamisama_dolls/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 神样DOLLS 2011-07-05 13 bilibili ","date":"2011-07-05","objectID":"/anime/kamisama_dolls/:3:0","tags":null,"title":"神样DOLLS","uri":"/anime/kamisama_dolls/"},{"categories":null,"content":"原作是《百合姫》连载中的百合漫画。\n在七森中学的校园里，无所事事四人帮——女主角赤座灯里、暴走的岁纳京子、吐糟役的船见结衣，以及在人前会伪装成可爱女孩的吉川千夏，擅自把废了部的茶道社部室据为己用，并且自称地建立了娱乐部。什么是娱乐部，当然就如其名字般只供娱乐(玩乐)的一个社部，作为学生会当然不能坐视不理，所以又以学生会副会长杉浦绫为首的4名学生会成员誓要与这“邪恶”的娱乐部周旋到底。另外，娱乐部的4位主角今次全采用次世代新人声优。","date":"2011-07-04","objectID":"/anime/yuruyuri/","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"简介 原作是《百合姫》连载中的百合漫画。 在七森中学的校园里，无所事事四人帮——女主角赤座灯里、暴走的岁纳京子、吐糟役的船见结衣，以及在人前会伪装成可爱女孩的吉川千夏，擅自把废了部的茶道社部室据为己用，并且自称地建立了娱乐部。什么是娱乐部，当然就如其名字般只供娱乐(玩乐)的一个社部，作为学生会当然不能坐视不理，所以又以学生会副会长杉浦绫为首的4名学生会成员誓要与这“邪恶”的娱乐部周旋到底。另外，娱乐部的4位主角今次全采用次世代新人声优。 制作人员： 原作：なもり 导演：太田雅彦 脚本：鸿野贵光、子安秀明、青岛崇、杉原研二 分镜：中西伸彰、志村宏明 ","date":"2011-07-04","objectID":"/anime/yuruyuri/:1:0","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 赤座灯里 Akkariin、Akkarin、Akarin、あかざ あかり、Akaza Akari、阿卡林/アッカリ〜ン 女 三上枝織 2 岁纳京子 としのう きょうこ、Toshinou Kyouko 女 大坪由佳 3 船见结衣 ふなみ ゆい、Funami Yui 女 津田美波 4 吉川千夏 しかわ ちなつ、Yoshikawa Chinatsu、China-chan、Chinacchi(ゆるゆり♪♪ep.2自述)、China(ゆるゆり♪♪ep.2) 女 大久保瑠美 5 杉浦绫乃 すぎうら あやの、Sugiura Ayano 女 藤田咲 6 池田千岁 いけだ ち","date":"2011-07-04","objectID":"/anime/yuruyuri/:2:0","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 摇曳百合 2011-07-04 12 樱花 2 摇曳百合♪♪ 2012-07-02 12 樱花 3 摇曳百合 夏日时光！ 2015-02-18 1 bilibili 4 摇曳百合 夏日时光！+ 2015-08-20 2 bilibili 5 摇曳百合 3☆High! 2015-10-05 12 樱花 6 摇曳百合、 2019-11-13 1 樱花 ","date":"2011-07-04","objectID":"/anime/yuruyuri/:3:0","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"MAD ","date":"2011-07-04","objectID":"/anime/yuruyuri/:4:0","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"　　原作是武田日向在月刊《Dragon AGE》连载的漫画作品。\n　　19世纪后半、是西欧正好流行日本文化的时代。一位单身前往法国的日本少女汤音，在巴黎街上的工艺店“国王的招牌店（アンセーニュ・ド・ロア）”工作著。本故事即是描述她的成长，与年轻老板的克洛德的往来的巴黎滞留记。","date":"2011-07-03","objectID":"/anime/foreign_labyrinth/","tags":null,"title":"异国迷宫的十字路口","uri":"/anime/foreign_labyrinth/"},{"categories":null,"content":"简介 原作是武田日向在月刊《Dragon AGE》连载的漫画作品。 19世纪后半、是西欧正好流行日本文化的时代。一位单身前往法国的日本少女汤音，在巴黎街上的工艺店“国王的招牌店（アンセーニュ・ド・ロア）”工作著。本故事即是描述她的成长，与年轻老板的克洛德的往来的巴黎滞留记。 制作人员： 原作：武田日向 导演：安田贤司 脚本：佐藤顺一、池田真美子 分镜：岛津裕行、后藤圭二、布施木一喜 ","date":"2011-07-03","objectID":"/anime/foreign_labyrinth/:1:0","tags":null,"title":"异国迷宫的十字路口","uri":"/anime/foreign_labyrinth/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 汤音 Yune、ユネ 女 東山奈央 2 克洛德·克劳戴 Claude 男 近藤隆 3 奥斯卡·克劳戴 Oscar 男 田中秀幸 4 艾丽丝·白朗奇 Alice 女 悠木碧 5 卡蜜儿·白朗奇 Camille 女 矢作紗友里 6 汐音 しおね、Shione 女 能登麻美子 ","date":"2011-07-03","objectID":"/anime/foreign_labyrinth/:2:0","tags":null,"title":"异国迷宫的十字路口","uri":"/anime/foreign_labyrinth/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 异国迷宫的十字路口 2011-07-03 13 bilibili ","date":"2011-07-03","objectID":"/anime/foreign_labyrinth/:3:0","tags":null,"title":"异国迷宫的十字路口","uri":"/anime/foreign_labyrinth/"},{"categories":null,"content":"舞台是都市市中心附近的地方。描寫著普通的高中生藤島鳴海與僱主偵探愛麗絲、與她的助手尼特族們活躍的故事。故事當中有些描寫了現實中暴力集團、與毒品等事件。同時也是描寫尼特族青少年有點不堪、有點可笑，又帶著一絲淡淡哀愁的青春冒險故事。","date":"2011-07-02","objectID":"/anime/heavens_memo_pad/","tags":null,"title":"神的记事本","uri":"/anime/heavens_memo_pad/"},{"categories":null,"content":"简介 舞台是都市市中心附近的地方。描寫著普通的高中生藤島鳴海與僱主偵探愛麗絲、與她的助手尼特族們活躍的故事。故事當中有些描寫了現實中暴力集團、與毒品等事件。同時也是描寫尼特族青少年有點不堪、有點可笑，又帶著一絲淡淡哀愁的青春冒險故事。 制作人员： 原作：杉井光 导演：樱美胜志 脚本：绫奈由仁子、伊神贵世、水上清资 分镜：川面真也、岛津裕行、柳泽哲也 ","date":"2011-07-02","objectID":"/anime/heavens_memo_pad/:1:0","tags":null,"title":"神的记事本","uri":"/anime/heavens_memo_pad/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 爱丽丝 しおんじ ゆうこ、Shionji Yuuko、紫苑寺有子 女 小倉唯 2 藤岛鸣海 ふじしま　なるみ、Fujishima Narumi、藤島中将 男 松岡禎丞 3 筱崎彩夏 しのざき あやか、Shinozaki Ayaka 女 茅野愛衣 4 明老板 ファン・ミンリー 女 生天目仁美 5 阿哲学长 一宮哲雄、いちのみや てつお、Ichinomiya Tetsuo 男 松風雅也 6 少校 向井均、むかい ひとし、Mukai Hitoshi 男 宮田幸季 7 宏哥 桑原宏明、くわはら ひろあき、Kuwahara Hiroaki 男 櫻井孝宏 8 第四代 雏","date":"2011-07-02","objectID":"/anime/heavens_memo_pad/:2:0","tags":null,"title":"神的记事本","uri":"/anime/heavens_memo_pad/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 神的记事本 2011-07-02 12 bilibili ","date":"2011-07-02","objectID":"/anime/heavens_memo_pad/:3:0","tags":null,"title":"神的记事本","uri":"/anime/heavens_memo_pad/"},{"categories":null,"content":"MAD ","date":"2011-07-02","objectID":"/anime/heavens_memo_pad/:4:0","tags":null,"title":"神的记事本","uri":"/anime/heavens_memo_pad/"},{"categories":null,"content":"国中时期曾获得最优秀选手奖的男主角长谷川昴，因为篮球社社长的关系而使他在高中的篮球活动被禁止，正当他灰心之际，他那在国小当老师的阿姨篁美星介绍他到私立慧心学园初等部教萝莉打篮球。\n于是就这样，被半强迫的他成为国小女子篮球社的临时顾问。成为临时顾问的头一天就受到五个女仆装的小女生列队欢迎。原来这五个小女生是篮球社仅有的社员，只有一个有篮球经验，其他都是新手。于是他也就此展开了和萌萌少女们在篮球之路上共同奋斗的一段故事。五位性格各异的萝莉喊着哥哥、哥哥，教练、教练的篮球生活开始了。","date":"2011-07-01","objectID":"/anime/ro_kyu_bu/","tags":null,"title":"萝球社！","uri":"/anime/ro_kyu_bu/"},{"categories":null,"content":"简介 国中时期曾获得最优秀选手奖的男主角长谷川昴，因为篮球社社长的关系而使他在高中的篮球活动被禁止，正当他灰心之际，他那在国小当老师的阿姨篁美星介绍他到私立慧心学园初等部教萝莉打篮球。 于是就这样，被半强迫的他成为国小女子篮球社的临时顾问。成为临时顾问的头一天就受到五个女仆装的小女生列队欢迎。原来这五个小女生是篮球社仅有的社员，只有一个有篮球经验，其他都是新手。于是他也就此展开了和萌萌少女们在篮球之路上共同奋斗的一段故事。五位性格各异的萝莉喊着哥哥、哥哥，教练、教练的篮球生活开始了。 制作人员： 原作：苍山探 导演：草川启造 脚本：伊藤美智子、吉田泰三、吉冈孝夫 分镜：池添隆博、小坂春女、水野","date":"2011-07-01","objectID":"/anime/ro_kyu_bu/:1:0","tags":null,"title":"萝球社！","uri":"/anime/ro_kyu_bu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 湊智花 みなと ともか、Minato Tomoka 女 花澤香菜 2 三泽真帆 みさわ まほ、Misawa Maho 女 井口裕香 3 永冢纱季 ながつか さき、Nagatsuka Saki 女 日笠陽子 4 香椎爱莉 かしい あいり、Kashii Airi 女 日高里菜 5 袴田日向 はかまだ　ひなた、Hakamada Hinata 女 小倉唯 6 长谷川昴 長谷川 昴、はせがわ すばる、Hasegawa Subaru 男 梶裕貴 7 蓝田未有 あいだ みゆ、Aida Miyu 女 伊瀬茉莉也 8 久井奈圣 くいな ひじり、Kuina Hijiri 女 佐","date":"2011-07-01","objectID":"/anime/ro_kyu_bu/:2:0","tags":null,"title":"萝球社！","uri":"/anime/ro_kyu_bu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 萝球社！ 2011-07-01 12 bilibili 2 萝球社！SS 2013-07-05 12 bilibili ","date":"2011-07-01","objectID":"/anime/ro_kyu_bu/:3:0","tags":null,"title":"萝球社！","uri":"/anime/ro_kyu_bu/"},{"categories":null,"content":"在一片宁静的小山村，少女渡濑明日菜（金元寿子 配音）时常站在山顶，用父亲留给她的神秘矿石作二极管，收听着来自外面世界的美妙音乐。在一次放学途中，明日菜遭到一头怪兽的袭击，关键时刻她被俊美少年瞬（入野自由 配音）救下，纯洁的友谊在少男少女之间开始萌芽。明日菜体味着友谊的甜蜜，却不知瞬在某天悄然离开人世。新来的男老师森崎龙司（井上和彦 配音）为孩子们讲述了死国的传说，明日菜这才意识到瞬正是来自另一个世界雅戈泰的人。森崎真实身份隶属某个神秘组织，他和明日菜的心中都有想要复活的人，于是经过一波三折，他们随着瞬的弟弟心一同来到了传说中的雅戈泰。\n在这个绝美而凄惶的国度，他们展开了似乎永无止境的旅程……","date":"2011-05-07","objectID":"/anime/children_who_chase_lost_voices/","tags":null,"title":"追逐繁星的孩子","uri":"/anime/children_who_chase_lost_voices/"},{"categories":null,"content":"简介 在一片宁静的小山村，少女渡濑明日菜（金元寿子 配音）时常站在山顶，用父亲留给她的神秘矿石作二极管，收听着来自外面世界的美妙音乐。在一次放学途中，明日菜遭到一头怪兽的袭击，关键时刻她被俊美少年瞬（入野自由 配音）救下，纯洁的友谊在少男少女之间开始萌芽。明日菜体味着友谊的甜蜜，却不知瞬在某天悄然离开人世。新来的男老师森崎龙司（井上和彦 配音）为孩子们讲述了死国的传说，明日菜这才意识到瞬正是来自另一个世界雅戈泰的人。森崎真实身份隶属某个神秘组织，他和明日菜的心中都有想要复活的人，于是经过一波三折，他们随着瞬的弟弟心一同来到了传说中的雅戈泰。 在这个绝美而凄惶的国度，他们展开了似乎永无止境的旅程","date":"2011-05-07","objectID":"/anime/children_who_chase_lost_voices/:1:0","tags":null,"title":"追逐繁星的孩子","uri":"/anime/children_who_chase_lost_voices/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 渡濑明日菜 Asuna 女 金元寿子 2 瞬 Shun 男 入野自由 ","date":"2011-05-07","objectID":"/anime/children_who_chase_lost_voices/:2:0","tags":null,"title":"追逐繁星的孩子","uri":"/anime/children_who_chase_lost_voices/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 追逐繁星的孩子 2011-05-07 1 樱花 ","date":"2011-05-07","objectID":"/anime/children_who_chase_lost_voices/:3:0","tags":null,"title":"追逐繁星的孩子","uri":"/anime/children_who_chase_lost_voices/"},{"categories":null,"content":"曾以一款《夜明前的琉璃色》备受好评和赞誉的游戏公司オーガスト——八月社本次在2010年2月初春在官网放出新作制作消息——“秽翼的尤斯蒂娅”。八月社毅然抛弃了以往的纯真柔和的风格，以独特的阴郁、忧伤的暗黑悲情戏，通过人生相谈模式来架构剧情发展。 \n\n作品获得极大的好评，在日本美少女游戏与动画相关商品销售网站Getchu.com的2011年上半年销量榜上排名第一；2011年4月排名第一；2011年全年排名第一名。","date":"2011-04-28","objectID":"/game/eustia/","tags":null,"title":"秽翼的尤斯蒂娅","uri":"/game/eustia/"},{"categories":null,"content":"简介 曾以一款《夜明前的琉璃色》备受好评和赞誉的游戏公司オーガスト——八月社本次在2010年2月初春在官网放出新作制作消息——“秽翼的尤斯蒂娅”。八月社毅然抛弃了以往的纯真柔和的风格，以独特的阴郁、忧伤的暗黑悲情戏，通过人生相谈模式来架构剧情发展。 作品获得极大的好评，在日本美少女游戏与动画相关商品销售网站Getchu.com的2011年上半年销量榜上排名第一；2011年4月排名第一；2011年全年排名第一名。 制作人员： 开发：八月 剧本：安西秀明、榊原拓、内田ヒロユキ 音乐：Active Planets 主题歌作曲：小高光太郎、Ceui ","date":"2011-04-28","objectID":"/game/eustia/:1:0","tags":null,"title":"秽翼的尤斯蒂娅","uri":"/game/eustia/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 凯姆·阿斯托利亚 Caim Astraea 男 近藤隆 2 尤斯蒂娅·阿斯托利亚 Eustia Astraea、缇娅 女 南條愛乃 3 艾莉丝·弗罗拉莉 Eris Floralia 女 浅川悠 4 圣女伊莲娜 柯蕾特·阿纳斯塔西娅、Saint Irene、コレット・アナスタシア 女 岡嶋妙 5 莉西娅·德·诺瓦斯·尤利 Licia de novus Yurii 女 中村繪里子 6 菲奥奈·希尔瓦利亚 Fione Silvaria 女 斉藤佑圭 7 吉克弗里德·古拉德 Siegfried Grado、ジーク 男 三木眞一郎 8 拉维丽娅 Lavria、拉菲 女","date":"2011-04-28","objectID":"/game/eustia/:2:0","tags":null,"title":"秽翼的尤斯蒂娅","uri":"/game/eustia/"},{"categories":null,"content":"系列 系列名 发行时间 1 秽翼的尤斯蒂娅 2011-04-28 ","date":"2011-04-28","objectID":"/game/eustia/:3:0","tags":null,"title":"秽翼的尤斯蒂娅","uri":"/game/eustia/"},{"categories":null,"content":"配乐 ","date":"2011-04-28","objectID":"/game/eustia/:4:0","tags":null,"title":"秽翼的尤斯蒂娅","uri":"/game/eustia/"},{"categories":null,"content":"故事背景设定在 20XX 年的日本，国家背负着巨大的财政赤字，被称为是经济崩坏、日本的末日。但是，某个叫做“Sovereign Wealth Fund”的新兴政府系金融机构，凭着成功运用政府资金，实现了财政再建的奇迹。另一方面，虽然政府经济复苏，但长久以来所引发的社会现象却不会因此消解：年轻人的就业问题、裁员与失业问题、面对未来的绝望感、逃避现实、结婚率下降以及少子化、还有失业者因此自暴自弃而引发的无差别暴力事件、失踪人口与自杀人口的激增……\n某一天，就读都内经济学部的大学生余贺公麿面前，出现了一名神秘男子，询问道“以你的未来作为抵押借给你金钱，你将会如何利用自身才能去使用这笔钱？”公麿的人生自此展开了重大转变。","date":"2011-04-14","objectID":"/anime/the_money_and_soul_of_possibility/","tags":null,"title":"「C」","uri":"/anime/the_money_and_soul_of_possibility/"},{"categories":null,"content":"简介 故事背景设定在 20XX 年的日本，国家背负着巨大的财政赤字，被称为是经济崩坏、日本的末日。但是，某个叫做“Sovereign Wealth Fund”的新兴政府系金融机构，凭着成功运用政府资金，实现了财政再建的奇迹。另一方面，虽然政府经济复苏，但长久以来所引发的社会现象却不会因此消解：年轻人的就业问题、裁员与失业问题、面对未来的绝望感、逃避现实、结婚率下降以及少子化、还有失业者因此自暴自弃而引发的无差别暴力事件、失踪人口与自杀人口的激增…… 某一天，就读都内经济学部的大学生余贺公麿面前，出现了一名神秘男子，询问道“以你的未来作为抵押借给你金钱，你将会如何利用自身才能去使用这笔钱？”公麿","date":"2011-04-14","objectID":"/anime/the_money_and_soul_of_possibility/:1:0","tags":null,"title":"「C」","uri":"/anime/the_money_and_soul_of_possibility/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 余贺公磨 余賀公麿、よが きみまろ、Yoga Kimimaro 男 内山昂輝 2 真朱 真朱、ましゅ、Mashyu 女 戸松遥 3 三国壮一郎 みくに そういちろう、Mikuni Souichirou 男 細見大輔 4 Q Q、キュー 女 後藤沙緒里 5 真坂木 まさかき、Masakaki 男 櫻井孝宏 6 生田羽奈日 いくた はなび、Ikuta Hanabi 女 牧野由依 7 カカズズ Kakazuzu 白川周作 8 堀井一郎 ほりい いちろう 男 高橋直純 ","date":"2011-04-14","objectID":"/anime/the_money_and_soul_of_possibility/:2:0","tags":null,"title":"「C」","uri":"/anime/the_money_and_soul_of_possibility/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 「C」 2011-04-14 11 bilibili ","date":"2011-04-14","objectID":"/anime/the_money_and_soul_of_possibility/:3:0","tags":null,"title":"「C」","uri":"/anime/the_money_and_soul_of_possibility/"},{"categories":null,"content":"故事的主角是将“青春点数”分配到自己的行动和相关的事情上、有时欢喜有时忧愁的少年丹羽真，及把被子卷在身上、自称外星人的“电波女”（却是美少女）的藤和艾莉欧（藤和エリオ）。作品以这二人为中心，展开了有点奇怪、却又非常清爽的青春故事。","date":"2011-04-14","objectID":"/anime/psychoelectric_girl/","tags":null,"title":"电波女与青春男","uri":"/anime/psychoelectric_girl/"},{"categories":null,"content":"简介 故事的主角是将“青春点数”分配到自己的行动和相关的事情上、有时欢喜有时忧愁的少年丹羽真，及把被子卷在身上、自称外星人的“电波女”（却是美少女）的藤和艾莉欧（藤和エリオ）。作品以这二人为中心，展开了有点奇怪、却又非常清爽的青春故事。 制作人员： 原作：入间人间 脚本：绫奈由仁子 分镜：平川哲生、添田和弘、佐山圣子、杉山延宽、板村智幸、笹木信作、八濑佑树 ","date":"2011-04-14","objectID":"/anime/psychoelectric_girl/:1:0","tags":null,"title":"电波女与青春男","uri":"/anime/psychoelectric_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 丹羽真 にわ まこと、Niwa Makoto、マコ君、真っち 男 入野自由 2 藤和艾莉欧 电波女,棉被女,棉被卷卷女、とうわ　えりお、Touwa Erio、エリちゃん、エリたん 女 大亀あすか 3 御船流子 みふね りゅうこ、Mifune Ryuuko、粒子(リュウシ) 女 加藤英美里 4 前川同学 まえかわさん、Maekawa san 女 渕上舞 5 藤和女女 とうわ めめ、Towa Meme、モチモチ先生（自称）,ジョジョ（自称） 女 野中藍 6 星宫社 ほしみや やしろ、Hosimiya Yashiro 女 井口裕香 7 花泽 はなざわさん、Hana","date":"2011-04-14","objectID":"/anime/psychoelectric_girl/:2:0","tags":null,"title":"电波女与青春男","uri":"/anime/psychoelectric_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 电波女与青春男 2011-04-14 13 bilibili ","date":"2011-04-14","objectID":"/anime/psychoelectric_girl/:3:0","tags":null,"title":"电波女与青春男","uri":"/anime/psychoelectric_girl/"},{"categories":null,"content":"MAD ","date":"2011-04-14","objectID":"/anime/psychoelectric_girl/:4:0","tags":null,"title":"电波女与青春男","uri":"/anime/psychoelectric_girl/"},{"categories":null,"content":"从小时候起一直青梅竹马的6人，却在升上高中之后彼此有了距离。不太与人们接触的主角宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道、只有幼年死去的本间芽衣子（灵魂，只有仁太能看见）还是一如从前。有一天，芽衣子对仁太说：“帮我实现一个愿望吧”。仁太虽然有点为难，却还是答应帮助面码实现愿望。以此为契机，为了实现芽衣子的愿望，分散在各处的大家又再次地聚集在一起。","date":"2011-04-14","objectID":"/anime/anohana/","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"简介 从小时候起一直青梅竹马的6人，却在升上高中之后彼此有了距离。不太与人们接触的主角宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道、只有幼年死去的本间芽衣子（灵魂，只有仁太能看见）还是一如从前。有一天，芽衣子对仁太说：“帮我实现一个愿望吧”。仁太虽然有点为难，却还是答应帮助面码实现愿望。以此为契机，为了实现芽衣子的愿望，分散在各处的大家又再次地聚集在一起。 制作人员： 原作：超和平Busters 导演：长井龙雪 脚本：冈田麿里 分镜：今泉贤一、吉村爱、森田宏幸、伊藤智彦、筱原俊哉 ","date":"2011-04-14","objectID":"/anime/anohana/:1:0","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 本间芽衣子 间芽、ほんま めいこ、Honma Meiko、めんま 女 茅野愛衣 2 宿海仁太 やどみ じんた、Yadomi Jinta、じんたん 男 入野自由 3 安城鸣子 安城 鳴子、あんじょう なるこ、Anjou Naruko、アナル,あなる 女 戸松遥 4 松雪集 松雪 集、まつゆき あつむ、Matsuyuki Atsumu、ゆきあつ 男 櫻井孝宏 5 鹤见知利子 つるみ ちりこ、Tsurumi Chiriko、つるこ 女 早見沙織 6 久川铁道 久川 鉄道、ひさかわ てつどう、Hisakawa Tetsudou、ぽっぽ 男 近藤孝行 7 本间伊伦 И","date":"2011-04-14","objectID":"/anime/anohana/:2:0","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我们仍未知道那天所看见的花的名字。 2011-04-14 11 bilibili ","date":"2011-04-14","objectID":"/anime/anohana/:3:0","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"MAD ","date":"2011-04-14","objectID":"/anime/anohana/:4:0","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"       故事发生在「CHAOS;HEAD」的“涩谷崩坏”事件一年半之后的世界，而舞台则从涩谷转移到了秋叶原。主角冈部伦太郎是一位深度中二病的大学生，时常幻想自己身肩重任，并自称“狂气的疯狂科学家・凤凰院凶真”，不过说到底其作为不过就是在名为“未来道具研究所”中与两个伙伴开发着奇奇怪怪又不切实际的东西。然而，这样的他们却在偶然间发明出可以把电子讯息传送过去的时间机器。在他们对未来及过去知道得越多的同时，却不知道危难正渐渐临到自己身上……","date":"2011-04-06","objectID":"/anime/steins_gate/","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"简介 故事发生在「CHAOS;HEAD」的“涩谷崩坏”事件一年半之后的世界，而舞台则从涩谷转移到了秋叶原。主角冈部伦太郎是一位深度中二病的大学生，时常幻想自己身肩重任，并自称“狂气的疯狂科学家・凤凰院凶真”，不过说到底其作为不过就是在名为“未来道具研究所”中与两个伙伴开发着奇奇怪怪又不切实际的东西。然而，这样的他们却在偶然间发明出可以把电子讯息传送过去的时间机器。在他们对未来及过去知道得越多的同时，却不知道危难正渐渐临到自己身上…… 制作人员： 原作：5pb.、Nitro+ 导演：佐藤卓哉、滨崎博嗣、小林智树 脚本：横谷昌宏、花田十辉、根元岁三、林直孝 ","date":"2011-04-06","objectID":"/anime/steins_gate/:1:0","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 冈部伦太郎 岡部倫太郎、おかべ りんたろう、Okabe Rintarou、冈伦（真由理对冈部伦太郎的“爱称”），凤凰院变态凶真、狂气的疯狂科学家、凤凰院凶真(鳳凰院 凶真,ほうおういん きょうま,Hooin Kyoma) 男 宮野真守 2 牧濑红莉栖 Chris Makise、牧瀬 紅莉栖、まきせ くりす、Makise Kurisu、天才少女，THE ZOMBIE/复苏者，克里斯蒂娜，天才，天才变态少女，放荡天才变态少女，助手，变态，セレブ・セブンティーン/Celeb Seventeen/土豪十七，セレセブ/Celeb Sev/土七，最爱实验妹， 蒙古斑少女","date":"2011-04-06","objectID":"/anime/steins_gate/:2:0","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 命运石之门 2011-04-06 25 樱花 2 命运石之门 负荷领域的既视感 2013-04-20 1 bilibili 3 命运石之门 0 2018-04-11 24 樱花 ","date":"2011-04-06","objectID":"/anime/steins_gate/:3:0","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"MAD ","date":"2011-04-06","objectID":"/anime/steins_gate/:4:0","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"——大都市“柳木原”。巨大的繁华街道。\n——冬季。抬头，映入眼帘便是毫无表情的纯白天空。\n逃避现实的学生羽田隆；贫困自由业者千岁鹫介；还有无业游民成田隼人。\n各自怀抱着不同烦恼的年轻人们。他们也将与属于他们的恋爱相遇","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"简介 ——大都市“柳木原”。巨大的繁华街道。 ——冬季。抬头，映入眼帘便是毫无表情的纯白天空。 逃避现实的学生羽田隆；贫困自由业者千岁鹫介；还有无业游民成田隼人。 各自怀抱着不同烦恼的年轻人们。他们也将与属于他们的恋爱相遇 制作人员： 原作：Navel 导演：后信治 脚本：青岛崇、中村浩二郎、鸿野贵光、王雀孙 分镜：及川启、德本善信、星野真 ","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/:1:0","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 羽田鹰志 はねだ たかし、Haneda Takashi、ホーク、ホーク卿、汰架示、チェリーボーイ 男 下野紘 2 千岁鹫介 ちとせ しゅうすけ、Chitose Shusuke、イーグル、シュウちゃん、糞ワシ、チィ兄ちゃん 男 三浦祥朗 3 成田隼人 なりた はやと、Narita Hayato、ファルコン、ドラ、ハマユリ 男 諏訪部順一 4 伊丹伽楼罗 いたみ かるら、Itami Karura、ガルーダ、陛下 男 稲田徹 5 渡来明日香 超特急わたライナー、わたらい あすか、Watarai Asuka、渡らないさん 女 吉田真弓 6 玉泉日和子 細川玉木、细川","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/:2:0","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我们没有翅膀 2011-04-03 12 樱花 2 我们没有翅膀 OVA 2011-06-26 1 ","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/:3:0","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"MAD ","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/:4:0","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"故事的主角机器人——东云名乃，一直憧憬成为一名普通的女生，却因为背上的发条而感到自卑，在被自称为博士的8岁萝莉胡乱改造之后，每次都无可奈何地感到自己与“普通女生”的距离越来越远了。除了萝莉博士外，故事还出现了很多非日常角色，如年龄为20岁且戴上博士制作的项圈能说话的黑猫、活泼且天然呆的吐槽女、擅长绘画的腐女、黑发眼镜女、外表看似不良少年实质很乖巧的男生、热爱麻糬的爆炸头男、被枪或火箭炮打到都不会死的演剧社社长等等。","date":"2011-04-02","objectID":"/anime/nichijou/","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"简介 故事的主角机器人——东云名乃，一直憧憬成为一名普通的女生，却因为背上的发条而感到自卑，在被自称为博士的8岁萝莉胡乱改造之后，每次都无可奈何地感到自己与“普通女生”的距离越来越远了。除了萝莉博士外，故事还出现了很多非日常角色，如年龄为20岁且戴上博士制作的项圈能说话的黑猫、活泼且天然呆的吐槽女、擅长绘画的腐女、黑发眼镜女、外表看似不良少年实质很乖巧的男生、热爱麻糬的爆炸头男、被枪或火箭炮打到都不会死的演剧社社长等等。 制作人员： 原作：新井圭一 导演：石原立也 脚本：石立太一、伊藤敦、村元克彦、西冈麻衣子、花田十辉 ","date":"2011-04-02","objectID":"/anime/nichijou/:1:0","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 相生祐子 あいおい ゆうこ、Aioi Yuuko、小祐 女 本多真梨子 2 长野原美绪 ながのはら みお、Naganohara Mio 女 相沢舞 3 水上麻衣 みなかみ まい、Minakami Mai 女 富樫美鈴 4 东云名乃 しののめ なの、Shinonome Nano 女 古谷静佳 5 博士 Hakase 女 今野宏美 6 阪本先生 大將、さかもとさん、sakamotosan、阪本 雄 白石稔 7 立花美里 立花 みさと、たちばな みさと、Tachibana Misato 女 堀川千華 8 笹原幸治郎 笹原 幸治郎、ささはら こうじろう、Sasaha","date":"2011-04-02","objectID":"/anime/nichijou/:2:0","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 日常 2011-04-02 26 bilibili ","date":"2011-04-02","objectID":"/anime/nichijou/:3:0","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"MAD ","date":"2011-04-02","objectID":"/anime/nichijou/:4:0","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"这是讲述一个少女养猫的平淡故事。\n号称耗资三千元打造的中国动画癫疯之作。\n故事主要讲述一个少女养猫而发生的种种离奇事件，整个作品画面风格很“中国式”。故事情节搞笑！目前正在连载中。","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"简介 这是讲述一个少女养猫的平淡故事。 号称耗资三千元打造的中国动画癫疯之作。 故事主要讲述一个少女养猫而发生的种种离奇事件，整个作品画面风格很“中国式”。故事情节搞笑！目前正在连载中。 制作人员： 导演：章平 配音监督：北斗企鹅（北京）文化传播有限公司 动画制作：北京寒木春华动画技术有限公司 ","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/:1:0","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 罗小黑 Luo、小黑 男 山新 2 罗小白 小白 女 山新 3 谛听 男 皇贞季 4 阿根 玄离 男 山新 5 山新 女 山新 6 比丢 Biu 7 皇受 ♂ 8 老君 男 ","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/:2:0","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 罗小黑战记 2011-03-17 40 bilibili 2 罗小黑战记电影版 2019-09-07 1 bilibili ","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/:3:0","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"MAD ","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/:4:0","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"本作为一款由Atlus公司旗下之前曾经开发人气RPG“女神异闻录”（Persona）系列的开发团队针对PS3／Xbox 360等高画质HD主机所开发制作的一款新作游戏，游戏作品由之前曾经开发“真．女神转生III”、“女神异闻录3”跟“女神异闻录4”等系列作的“桥野桂”担任制作人＆监督导演，并由“副岛成记”担任角色设计、“目黑将司”负责音效音乐，并由日本人气动画制作公司“Studio4℃”负责动画制作部份，更因为是“女神异闻录”开发团队首款HD高画质主机作品而备受瞩目。\n\n　　在本作中，玩家们将扮演32岁的独居男子文森，在他所居住的街道里，最近发生了一连串据传跟梦境有关的连续怪异死亡事件。而在某一天，在文森的身边突然出现一名之前未曾谋面的神秘美女凯塞琳，而这也是文森恶梦的开始。究竟有关这个“恶梦”的传闻到底是…？而文森又是否能够从死亡的命运中逃出生天？","date":"2011-02-17","objectID":"/game/catherine/","tags":null,"title":"凯瑟琳","uri":"/game/catherine/"},{"categories":null,"content":"简介 本作为一款由Atlus公司旗下之前曾经开发人气RPG“女神异闻录”（Persona）系列的开发团队针对PS3／Xbox 360等高画质HD主机所开发制作的一款新作游戏，游戏作品由之前曾经开发“真．女神转生III”、“女神异闻录3”跟“女神异闻录4”等系列作的“桥野桂”担任制作人＆监督导演，并由“副岛成记”担任角色设计、“目黑将司”负责音效音乐，并由日本人气动画制作公司“Studio4℃”负责动画制作部份，更因为是“女神异闻录”开发团队首款HD高画质主机作品而备受瞩目。 在本作中，玩家们将扮演32岁的独居男子文森，在他所居住的街道里，最近发生了一连串据传跟梦境有关的连续怪异死亡事件。而在某","date":"2011-02-17","objectID":"/game/catherine/:1:0","tags":null,"title":"凯瑟琳","uri":"/game/catherine/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 凯瑟琳 キャサリン 女 沢城みゆき 2 凯瑟琳 キャサリン 女 三石琴乃 3 文森特 ヴィンセント 男 山寺宏一 4 托比 トビー 男 谷山紀章 5 乔纳森 ジョニー 男 子安武人 6 奥兰多 オーランド 男 平田広明 7 艾丽卡 エリカ 女 皆川純子 8 店长 マスター 男 若本規夫 ","date":"2011-02-17","objectID":"/game/catherine/:2:0","tags":null,"title":"凯瑟琳","uri":"/game/catherine/"},{"categories":null,"content":"系列 系列名 发行时间 1 凯瑟琳 2011-02-17 ","date":"2011-02-17","objectID":"/game/catherine/:3:0","tags":null,"title":"凯瑟琳","uri":"/game/catherine/"},{"categories":null,"content":"想变成女生的男孩二鸟修一，在新转校的小学遇到帅气的女生高槻佳乃。最初修一一直压抑着想成为女生的心情，之后发现佳乃经常穿着男生学生服到远方城镇。彼此共享秘密的两人，修一穿着水手服、佳乃穿着男生学生服，一起到远方的城镇冒险。然而当二人升入中学后，新的人际关系以及青春期的烦恼给他们带来了新的问题。","date":"2011-01-13","objectID":"/anime/wandering_son/","tags":null,"title":"放浪男孩","uri":"/anime/wandering_son/"},{"categories":null,"content":"简介 想变成女生的男孩二鸟修一，在新转校的小学遇到帅气的女生高槻佳乃。最初修一一直压抑着想成为女生的心情，之后发现佳乃经常穿着男生学生服到远方城镇。彼此共享秘密的两人，修一穿着水手服、佳乃穿着男生学生服，一起到远方的城镇冒险。然而当二人升入中学后，新的人际关系以及青春期的烦恼给他们带来了新的问题。 制作人员： 原作：志村贵子 导演：青木英 脚本：冈田麿里 分镜：笹岛启一、石黑恭平、星川孝文、別所诚人、林宏树 ","date":"2011-01-13","objectID":"/anime/wandering_son/:1:0","tags":null,"title":"放浪男孩","uri":"/anime/wandering_son/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 二鸟修一 にとり しゅういち、Nitori Shuichi、修 男 畠山航輔 2 高槻佳乃 たかつき よしの、Takatsuki Yoshino、高槻くん 女 瀬戸麻沙美 3 千叶沙织 ちば さおり、Chiba Saori、さおりん 女 南里侑香 4 末广安那 すえひろ あんな、Suehiro Anna、あんなちゃん 女 堀江由衣 5 二鸟真穗 にとり まほ、Nitori Maho 女 水樹奈々 6 有贺诚 ありが まこと、Ariga Makoto、マコちゃん 男 井口祐一 7 佐佐加奈子 ささ かなこ、Sasa Kanako、ささちゃん 女 南條愛乃 8 ","date":"2011-01-13","objectID":"/anime/wandering_son/:2:0","tags":null,"title":"放浪男孩","uri":"/anime/wandering_son/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 放浪男孩 2011-01-13 12 bilibili ","date":"2011-01-13","objectID":"/anime/wandering_son/:3:0","tags":null,"title":"放浪男孩","uri":"/anime/wandering_son/"},{"categories":null,"content":"MAD ","date":"2011-01-13","objectID":"/anime/wandering_son/:4:0","tags":null,"title":"放浪男孩","uri":"/anime/wandering_son/"},{"categories":null,"content":"升上高中后一个人来到山形的高中生筒井雪隆住进了学生附近的宿舍，却发自己的租处已被入侵，里面有个自称自己是外星人的失忆男子。本来打算将他赶出去，但是在同情心及对方的说服下开始相信他是外星人并和他同居。安定下来不久后，王子的护卫军紧追而来，却发现降落在了好战的狄肯星人地盘上，同时研究外星人的机构也在追查，情况变的十分危急。就在雪隆为了外星王子的安危心急如焚时，王子本人却悠闲的在逛街买衣服。","date":"2011-01-10","objectID":"/anime/level_e/","tags":null,"title":"灵异E接触","uri":"/anime/level_e/"},{"categories":null,"content":"简介 升上高中后一个人来到山形的高中生筒井雪隆住进了学生附近的宿舍，却发自己的租处已被入侵，里面有个自称自己是外星人的失忆男子。本来打算将他赶出去，但是在同情心及对方的说服下开始相信他是外星人并和他同居。安定下来不久后，王子的护卫军紧追而来，却发现降落在了好战的狄肯星人地盘上，同时研究外星人的机构也在追查，情况变的十分危急。就在雪隆为了外星王子的安危心急如焚时，王子本人却悠闲的在逛街买衣服。 制作人员： 原作：富坚义博 导演：加藤敏幸 脚本：笔安一幸、花田十辉、铃木雅词 分镜：筱原俊哉、木宫茂、中原礼、市村彻夫 ","date":"2011-01-10","objectID":"/anime/level_e/:1:0","tags":null,"title":"灵异E接触","uri":"/anime/level_e/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 马鹿·基·艾尔·多古拉 马鹿王子、バカ=キ=エル・ドグラ 男 浪川大輔 2 克拉夫特队长 酷拉法特、Kraft、队长 男 子安武人 3 筒井雪隆 つつい ゆきたか、Tsutsui Yukitaka 男 細谷佳正 4 沙得队员 サド 男 高塚正也 5 克林队员 コリン 男 朝比奈拓見 6 江戸川美步 えどがわ みほ、Edogawa Miho 女 明坂聡美 7 清水良树 しみず よしき 男 金田アキ 8 横田国光 よこた くにみつ 男 金谷ヒデユキ ","date":"2011-01-10","objectID":"/anime/level_e/:2:0","tags":null,"title":"灵异E接触","uri":"/anime/level_e/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 灵异E接触 2011-01-10 13 bilibili ","date":"2011-01-10","objectID":"/anime/level_e/:3:0","tags":null,"title":"灵异E接触","uri":"/anime/level_e/"},{"categories":null,"content":"平凡的高中生相川步，在莫名其妙的因缘下被卷入震惊社会的连环杀人案身亡，但他竟然死而复生了。原来在事件发生之前与步偶然邂逅的死灵法师“优”，将他变成了不死身而复活。再加上来自魔法世界的少女战士春奈，与另一个吸血忍者少女瑟拉芬，甚至演变成步跟她们全住在一起的局面。","date":"2011-01-10","objectID":"/anime/is_this_a_zombie/","tags":null,"title":"这个是僵尸吗？","uri":"/anime/is_this_a_zombie/"},{"categories":null,"content":"简介 平凡的高中生相川步，在莫名其妙的因缘下被卷入震惊社会的连环杀人案身亡，但他竟然死而复生了。原来在事件发生之前与步偶然邂逅的死灵法师“优”，将他变成了不死身而复活。再加上来自魔法世界的少女战士春奈，与另一个吸血忍者少女瑟拉芬，甚至演变成步跟她们全住在一起的局面。 制作人员： 原作：木村心一 导演：金崎贵臣 脚本：上江洲诚、森田繁、待田堂子 分镜：齐藤哲人、井出安轨、田头忍 ","date":"2011-01-10","objectID":"/anime/is_this_a_zombie/:1:0","tags":null,"title":"这个是僵尸吗？","uri":"/anime/is_this_a_zombie/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 相川步 あいかわ あゆむ 男 間島淳司 2 春奈 haruna 女 野水伊織 3 瑟拉芬 塞拉、塞拉菲姆、Seraphim、セラ 女 日笠陽子 4 优克莉伍德·海尔赛兹 Eucliwood Hellscythe、ユー 女 金田朋子 5 吉田友纪 トモノリ 女 金元寿子 6 织户 おりと 男 吉野裕行 7 平松妙子 女 山口理恵 8 三原加奈美 女 美名 ","date":"2011-01-10","objectID":"/anime/is_this_a_zombie/:2:0","tags":null,"title":"这个是僵尸吗？","uri":"/anime/is_this_a_zombie/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 这个是僵尸吗？ 2011-01-10 12 樱花 2 这个是僵尸吗？OF THE DEAD 2012-04-04 10 樱花 ","date":"2011-01-10","objectID":"/anime/is_this_a_zombie/:3:0","tags":null,"title":"这个是僵尸吗？","uri":"/anime/is_this_a_zombie/"},{"categories":null,"content":"由直木赏作家樱庭一树所著、武田日向担当插画的侦探类轻小说作品「GOSICK」，故事主要讲述了就读于拥有悠久庄严历史的圣玛格丽特学园的少年久城一弥某天与在学园图书馆塔上方的房间内一位身穿华丽服饰如洋娃娃般的少女维多利加相遇，之后两人便遭遇到了种种离奇事件，种种难题正等着洞察力灵敏的维多利加与一弥。","date":"2011-01-07","objectID":"/anime/gosick/","tags":null,"title":"GOSICK","uri":"/anime/gosick/"},{"categories":null,"content":"简介 由直木赏作家樱庭一树所著、武田日向担当插画的侦探类轻小说作品「GOSICK」，故事主要讲述了就读于拥有悠久庄严历史的圣玛格丽特学园的少年久城一弥某天与在学园图书馆塔上方的房间内一位身穿华丽服饰如洋娃娃般的少女维多利加相遇，之后两人便遭遇到了种种离奇事件，种种难题正等着洞察力灵敏的维多利加与一弥。 制作人员： 原作：樱庭一树 导演：难波日登志 脚本：猪爪慎一、根元岁三、冈田麿里 分镜：森邦宏、和田纯一、田村耕太郎 ","date":"2011-01-07","objectID":"/anime/gosick/:1:0","tags":null,"title":"GOSICK","uri":"/anime/gosick/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 维多利加·德·布洛瓦 Victorique de Blois、Vikutorika do Burowa 女 悠木碧 2 久城一弥 くじょう かずや 男 江口拓也 3 古雷温·德·布洛瓦 男 木内秀信 4 艾薇儿·布莱德利 Avril Bradley、アブリル・ブラッドリー、Aburiru Buraddorī 女 下屋則子 5 赛西尔 女 鹿野優以 6 柯蒂丽亚·盖洛 女 沢城みゆき 7 布莱恩·罗斯可 男 大川透 8 苏菲 女 根谷美智子 ","date":"2011-01-07","objectID":"/anime/gosick/:2:0","tags":null,"title":"GOSICK","uri":"/anime/gosick/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 GOSICK 2011-01-07 24 bilibili ","date":"2011-01-07","objectID":"/anime/gosick/:3:0","tags":null,"title":"GOSICK","uri":"/anime/gosick/"},{"categories":null,"content":"MAD ","date":"2011-01-07","objectID":"/anime/gosick/:4:0","tags":null,"title":"GOSICK","uri":"/anime/gosick/"},{"categories":null,"content":"出生良好家庭，亲朋好友团聚，时哭时笑，这是谁都拥有的日常生活。\n市立见泷原中学的平凡初二女生鹿目圆，就是其中一位。\n一天，一个不可思议的人出现在她眼前。\n不知是偶然抑或注定，可以肯定的是，这相遇改变了她的命运，一个新的魔法少女故事亦随即开始。","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"简介 出生良好家庭，亲朋好友团聚，时哭时笑，这是谁都拥有的日常生活。 市立见泷原中学的平凡初二女生鹿目圆，就是其中一位。 一天，一个不可思议的人出现在她眼前。 不知是偶然抑或注定，可以肯定的是，这相遇改变了她的命运，一个新的魔法少女故事亦随即开始。 制作人员： 原作：Magica Quartet 导演：新房昭之 脚本：虚渊玄 分镜：龙轮直征、芦野芳晴、西田正义、岩崎安利、笹木信作、伊藤智彦 ","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/:1:0","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鹿目圆 小圆、鹿目圆香、鹿目 まどか、かなめ まどか、Kaname Madoka、圆神、小圆、馒头卡 女 悠木碧 2 晓美焰 晓美炎、暁美 ほむら、あけみ ほむら、Akemi Homura、吼姆拉、吼姆辣酱、焰魔 女 斎藤千和 3 美树沙耶香 美树沙耶加、美樹 さやか、みき さやか、Miki Sayaka、蓝毛、美树爽 女 喜多村英梨 4 巴麻美 巴 マミ、ともえ マミ、Tomoe Mami、学姐 女 水橋かおり 5 佐仓杏子 佐倉 杏子、さくら きょうこ、Sakura Kyouko、红毛 女 野中藍 6 丘比 久兵衛（时女一族称）、淫兽、安利始祖、QB、Q","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/:2:0","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔法少女小圆 2011-01-07 12 bilibili 2 剧场版 魔法少女小圆 [新篇] 叛逆的物语 2013-10-26 1 bilibili ","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/:3:0","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"MAD ","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/:4:0","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"只对女性有反应、世界最强的超级兵器“Infinite Stratos（IS）”。\n\n因为IS的问世，性别平等被破坏，世界变成女尊男卑的社会。主角“织斑一夏”在高中的入学试验误入IS操纵者育成学校“IS学园”的试验会场并意外地启动了IS。成为全世界关注的“世界上唯一能操纵IS的男性”的一夏，被政府强制就读向来只有女性的IS学园，在全校师生对他充满好奇心的视线下，一夏波澜壮阔校园生活就此展开。","date":"2011-01-06","objectID":"/anime/infinite_stratos/","tags":null,"title":"IS〈无限斯特拉托斯〉","uri":"/anime/infinite_stratos/"},{"categories":null,"content":"简介 只对女性有反应、世界最强的超级兵器“Infinite Stratos（IS）”。 因为IS的问世，性别平等被破坏，世界变成女尊男卑的社会。主角“织斑一夏”在高中的入学试验误入IS操纵者育成学校“IS学园”的试验会场并意外地启动了IS。成为全世界关注的“世界上唯一能操纵IS的男性”的一夏，被政府强制就读向来只有女性的IS学园，在全校师生对他充满好奇心的视线下，一夏波澜壮阔校园生活就此展开。 制作人员： 原作：弓弦逸鹤 导演：菊地康仁 脚本：北条千夏、志茂文彦、富冈淳广 分镜：山本裕介、松田清、福田道生 ","date":"2011-01-06","objectID":"/anime/infinite_stratos/:1:0","tags":null,"title":"IS〈无限斯特拉托斯〉","uri":"/anime/infinite_stratos/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 织斑一夏 織斑一夏、おりむら いちか、orimura ichika 男 内山昂輝 2 筱之之帚 篠ノ之箒、しののの ほうき、shinonono houki 女 日笠陽子 3 塞西莉娅·奥尔科特 塞西莉亚·奥卢卡多、赛西莉亚、Cecilia Alcott、セシリア オルコット、Seshiria Orukotto、西西莉亚 女 ゆかな 4 凰铃音 Lingyin HUANG、凰 鈴音、ファン リンイン、Fan Rinin 女 下田麻美 5 夏洛特·迪诺亚 Charlotte Dunois、シャルロット・デュノア、Sharurotto Dunoa、夏露、夏尔·迪诺","date":"2011-01-06","objectID":"/anime/infinite_stratos/:2:0","tags":null,"title":"IS〈无限斯特拉托斯〉","uri":"/anime/infinite_stratos/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 IS〈无限斯特拉托斯〉 2011-01-06 12 bilibili ","date":"2011-01-06","objectID":"/anime/infinite_stratos/:3:0","tags":null,"title":"IS〈无限斯特拉托斯〉","uri":"/anime/infinite_stratos/"},{"categories":null,"content":"名为葛索（Gothel）的老妇目睹纯净的阳光滴下坠落地面，生出一朵神奇的花，为它歌唱就能保持自己年轻不老。几年后，邻近王国的皇后怀孕体弱，可能会难产。国王下令寻找传说中神秘的花，守卫找到后，烹煮花治愈了皇后，顺利生下一名金发女婴乐佩（Rapunzel）。葛索得知乐佩的金色头发拥有了花的治疗能力，但剪下后魔力消失会变回棕发，所以她带走女婴，闭关在高塔与世隔绝，作为自己的女儿抚养长大。然而，每年乐佩的生日，王国发送成千上万的天灯在天空，期望有朝一日能引导失踪的公主回国。","date":"2010-11-24","objectID":"/anime/tangled/","tags":null,"title":"魔发奇缘","uri":"/anime/tangled/"},{"categories":null,"content":"简介 名为葛索（Gothel）的老妇目睹纯净的阳光滴下坠落地面，生出一朵神奇的花，为它歌唱就能保持自己年轻不老。几年后，邻近王国的皇后怀孕体弱，可能会难产。国王下令寻找传说中神秘的花，守卫找到后，烹煮花治愈了皇后，顺利生下一名金发女婴乐佩（Rapunzel）。葛索得知乐佩的金色头发拥有了花的治疗能力，但剪下后魔力消失会变回棕发，所以她带走女婴，闭关在高塔与世隔绝，作为自己的女儿抚养长大。然而，每年乐佩的生日，王国发送成千上万的天灯在天空，期望有朝一日能引导失踪的公主回国。 制作人员： 导演：拜伦·霍华德 人物设定：Jin Kim 製作：迪士尼电影公司 动画制作：华特·迪士尼动画工作室 ","date":"2010-11-24","objectID":"/anime/tangled/:1:0","tags":null,"title":"魔发奇缘","uri":"/anime/tangled/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 乐佩 瑞普兹、蕾芬洁、萝庞柔、ラプンツェル 女 諸星すみれ 2 尤金·费兹柏特 Flynn Rider、フリン・ライダー、费林·雷德、ユージーン・フィッツハーバート 男 ","date":"2010-11-24","objectID":"/anime/tangled/:2:0","tags":null,"title":"魔发奇缘","uri":"/anime/tangled/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔发奇缘 2010-11-24 1 樱花 ","date":"2010-11-24","objectID":"/anime/tangled/:3:0","tags":null,"title":"魔发奇缘","uri":"/anime/tangled/"},{"categories":null,"content":"被草食系恐龙母亲抚养长大的霸王龙 Heart 一天天长高长大，也一天天发现身边出现了很多害怕它的声音。一天，Heart 敲碎了一个蛋壳，于是，它遇上了从蛋壳里蹦出来的草食系小甲龙。Heart 脱口而出，“你看起来好像很好吃。”令它意外的是，小甲龙跳上了它的身体并兴高采烈的喊到，“你叫我的名字了，你就是我的爸爸吧。‘你看起来好像很好吃’真是个好名字，这个名字是什么意思阿？”于是，一段不可思议的霸王龙和小甲龙之间的父子亲情故事诞生了。","date":"2010-10-16","objectID":"/anime/heart_and_yummie/","tags":null,"title":"你看起来很好吃","uri":"/anime/heart_and_yummie/"},{"categories":null,"content":"简介 被草食系恐龙母亲抚养长大的霸王龙 Heart 一天天长高长大，也一天天发现身边出现了很多害怕它的声音。一天，Heart 敲碎了一个蛋壳，于是，它遇上了从蛋壳里蹦出来的草食系小甲龙。Heart 脱口而出，“你看起来好像很好吃。”令它意外的是，小甲龙跳上了它的身体并兴高采烈的喊到，“你叫我的名字了，你就是我的爸爸吧。‘你看起来好像很好吃’真是个好名字，这个名字是什么意思阿？”于是，一段不可思议的霸王龙和小甲龙之间的父子亲情故事诞生了。 制作人员： 原作：宫西达也 导演：藤森雅也 脚本：神野浩昌、村上修 演出：大庭秀昭、根岸宏树 音乐：寺岛民哉 人物设定：柳田义明 ","date":"2010-10-16","objectID":"/anime/heart_and_yummie/:1:0","tags":null,"title":"你看起来很好吃","uri":"/anime/heart_and_yummie/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哈特 Heart 山口勝平 2 很美味 加藤清史郎 3 妈妈 原田知世 4 莱特 Light 折笠富美子 5 萨贡 桐本拓哉 6 老别肯 矢田稔 7 贝洛贝洛 川村万梨阿 8 巴克 ","date":"2010-10-16","objectID":"/anime/heart_and_yummie/:2:0","tags":null,"title":"你看起来很好吃","uri":"/anime/heart_and_yummie/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 你看起来很好吃 2010-10-16 1 bilibili ","date":"2010-10-16","objectID":"/anime/heart_and_yummie/:3:0","tags":null,"title":"你看起来很好吃","uri":"/anime/heart_and_yummie/"},{"categories":null,"content":"仓下月海是一名梦想着成为插画家，并且非常喜欢水母的女孩。她为了梦想而来到东京，后入住了女生公寓“天水馆”，这里的住客大多是宅女，对她们来讲拥有时尚感的人就全是她们的敌人。一天，为了营救水母，月海遇到了一名超美的伪娘。于是发生在宅女、伪娘之间的故事就此展开。","date":"2010-10-14","objectID":"/anime/princess_jellyfish/","tags":null,"title":"海月姬","uri":"/anime/princess_jellyfish/"},{"categories":null,"content":"简介 仓下月海是一名梦想着成为插画家，并且非常喜欢水母的女孩。她为了梦想而来到东京，后入住了女生公寓“天水馆”，这里的住客大多是宅女，对她们来讲拥有时尚感的人就全是她们的敌人。一天，为了营救水母，月海遇到了一名超美的伪娘。于是发生在宅女、伪娘之间的故事就此展开。 制作人员： 原作：东村明子 导演：大森贵弘 脚本：待田堂子、江夏由结、花田十辉 分镜：寺东克己、古谷田顺久、大畑清隆 ","date":"2010-10-14","objectID":"/anime/princess_jellyfish/:1:0","tags":null,"title":"海月姬","uri":"/anime/princess_jellyfish/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 仓下月海 くらした つきみ、Kurashita Tsukimi 女 花澤香菜 2 鲤渊藏之介 こいぶち くらのすけ、Koibuchi Kuranosuke、藏子 男 斎賀みつき 3 鲤渊修 こいぶち しゅう、Koibuchi Shuu、修修 男 諏訪部順一 4 千绘子 女 斉藤貴美子 5 玛亚亚 女 岡村明美 6 邦邦 女 くまいもとこ 7 吉吉 女 能登麻美子 8 Kurara 雌？ 諸星すみれ ","date":"2010-10-14","objectID":"/anime/princess_jellyfish/:2:0","tags":null,"title":"海月姬","uri":"/anime/princess_jellyfish/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海月姬 2010-10-14 11 bilibili ","date":"2010-10-14","objectID":"/anime/princess_jellyfish/:3:0","tags":null,"title":"海月姬","uri":"/anime/princess_jellyfish/"},{"categories":null,"content":"　　这是一个关于遥远未来的故事。\n五年一度的宇宙速度对决“REDLINE”马上就要开幕！\n表面上看起来很酷，梳着飞机头身穿夹克的JP实际上是一个非常害羞的男性，为了得到初恋女孩索诺西的眷顾，JP参加了“REDLINE”的速度盛宴。“REDLINE”的比赛没有规则，为了取得胜利参赛者可以随身装载武器，这是一场赌上性命的对决。最糟的还不仅于此，这次比赛的举办场地竟然是号称史上最恶的军事国家罗伯瓦尔特（机器人世界），参赛者得知消息后纷纷退出比赛。然而，JP和他心仪的女孩索诺西毅然决定参加比赛。在比赛当天，JP的儿时玩伴天才机械师弗里斯彼为JP准备了最棒的跑车。但是跑车上却被安装了炸弹。弗里斯彼因为某个原因与人合谋了这场比赛。知道真相的JP毅然决然踩下了跑车的油门。这个时候，罗伯瓦尔特下达了阻止“REDLINE”开赛的出击命令。对索诺西的爱恋，与弗里斯彼的纠葛以及罗伯瓦尔特的妨碍，JP要如何打破这纠缠交错的命运！","date":"2010-10-09","objectID":"/anime/redline/","tags":null,"title":"红线","uri":"/anime/redline/"},{"categories":null,"content":"简介 这是一个关于遥远未来的故事。 五年一度的宇宙速度对决“REDLINE”马上就要开幕！ 表面上看起来很酷，梳着飞机头身穿夹克的JP实际上是一个非常害羞的男性，为了得到初恋女孩索诺西的眷顾，JP参加了“REDLINE”的速度盛宴。“REDLINE”的比赛没有规则，为了取得胜利参赛者可以随身装载武器，这是一场赌上性命的对决。最糟的还不仅于此，这次比赛的举办场地竟然是号称史上最恶的军事国家罗伯瓦尔特（机器人世界），参赛者得知消息后纷纷退出比赛。然而，JP和他心仪的女孩索诺西毅然决定参加比赛。在比赛当天，JP的儿时玩伴天才机械师弗里斯彼为JP准备了最棒的跑车。但是跑车上却被安装了炸弹。弗里斯彼因为","date":"2010-10-09","objectID":"/anime/redline/:1:0","tags":null,"title":"红线","uri":"/anime/redline/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 JP Joshua·Punkhead 男 木村拓哉 2 索诺西·玛格雷 女 蒼井優 3 Trava Trava、Trava 男 津田寛治 ","date":"2010-10-09","objectID":"/anime/redline/:2:0","tags":null,"title":"红线","uri":"/anime/redline/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 红线 2010-10-09 1 bilibili ","date":"2010-10-09","objectID":"/anime/redline/:3:0","tags":null,"title":"红线","uri":"/anime/redline/"},{"categories":null,"content":"女高中生岚山步鸟，在丸子商店街的咖啡厅SEASIDE的做兼职服务生。有一天，店长宣告为了咖啡厅的繁盛要构想新策略。于是，最终敲定把咖啡厅改造成时下流行的女仆咖啡厅。但是，店里的相关人员没人了解女仆咖啡厅，最后就只让服务员换上女仆装就宣布重新开业了。步鸟学校的前辈双叶、单恋步鸟的同级生广章，围绕在步鸟身边发生的各种闹剧就此展开……","date":"2010-10-07","objectID":"/anime/and_yet_the_town_moves/","tags":null,"title":"女仆咖啡厅","uri":"/anime/and_yet_the_town_moves/"},{"categories":null,"content":"简介 女高中生岚山步鸟，在丸子商店街的咖啡厅SEASIDE的做兼职服务生。有一天，店长宣告为了咖啡厅的繁盛要构想新策略。于是，最终敲定把咖啡厅改造成时下流行的女仆咖啡厅。但是，店里的相关人员没人了解女仆咖啡厅，最后就只让服务员换上女仆装就宣布重新开业了。步鸟学校的前辈双叶、单恋步鸟的同级生广章，围绕在步鸟身边发生的各种闹剧就此展开…… 制作人员： 原作：石黑正数 脚本：高山克彦、大嶋实句 分镜：新房昭之、今泉贤一、佐藤卓哉、板村智幸、森义博、藤森一真 ","date":"2010-10-07","objectID":"/anime/and_yet_the_town_moves/:1:0","tags":null,"title":"女仆咖啡厅","uri":"/anime/and_yet_the_town_moves/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 岚山步鸟 嵐山 歩鳥、あらしやま ほとり、Hotori Arashiyama 女 小見川千明 2 绀双叶 紺 双葉、こん ふたば、Kon Futaba 女 矢澤りえか 3 辰野俊子 辰野 トシ子、辰野 俊子、たつの としこ、Tatsuno Toshiko 女 悠木碧 4 矶端浮子 磯端 ウキ、いそはた うき、Isohata Uki 女 櫻井孝宏 5 约瑟芬 Josephine 母 松来未祐 6 真田广章 真田 広章、工口广章 男 入野自由 7 森秋夏彦 もりあき なつひこ、Moriaki Natsuhiko 男 杉田智和 8 针原春江 針原 春江、はりばら ","date":"2010-10-07","objectID":"/anime/and_yet_the_town_moves/:2:0","tags":null,"title":"女仆咖啡厅","uri":"/anime/and_yet_the_town_moves/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 女仆咖啡厅 2010-10-07 12 bilibili ","date":"2010-10-07","objectID":"/anime/and_yet_the_town_moves/:3:0","tags":null,"title":"女仆咖啡厅","uri":"/anime/and_yet_the_town_moves/"},{"categories":null,"content":"舞岛学园的桂木桂马是个喜欢玩恋爱模拟游戏——也就是Galgame——的高中生。他有着无论怎样的女性（限定Galgame中的二次元可攻略角色）都能攻略的技巧，在游戏界中被称为“攻陷之神”；而他本人也比谁都深爱着这些二次元美少女们。\n\n某日，桂马意外地与恶魔订下契约，眼前出现了一位从遥远的地狱来到这里的恶魔少女艾鲁西。她的目的是拜托桂马帮忙捕获从地狱逃走的“驱魂”。驱魂会躲藏在女性的内心空隙，而填满内心空隙、赶出驱魂的其中一个方法就是“恋爱”。在不履行契约就会身首异处的威胁下，二次元的攻陷之神开始了未曾挑战过的三次元女性攻略之路。","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"简介 舞岛学园的桂木桂马是个喜欢玩恋爱模拟游戏——也就是Galgame——的高中生。他有着无论怎样的女性（限定Galgame中的二次元可攻略角色）都能攻略的技巧，在游戏界中被称为“攻陷之神”；而他本人也比谁都深爱着这些二次元美少女们。 某日，桂马意外地与恶魔订下契约，眼前出现了一位从遥远的地狱来到这里的恶魔少女艾鲁西。她的目的是拜托桂马帮忙捕获从地狱逃走的“驱魂”。驱魂会躲藏在女性的内心空隙，而填满内心空隙、赶出驱魂的其中一个方法就是“恋爱”。在不履行契约就会身首异处的威胁下，二次元的攻陷之神开始了未曾挑战过的三次元女性攻略之路。 制作人员： 原作：若木民喜 导演：高柳滋仁 脚本：高桥龙也、仓","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/:1:0","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 桂木桂马 かつらぎ けいま、Katsuragi Keima 男 下野紘 2 中川奏音 中川花音、中川嘉音、中川加侬、Kanon Nakagawa、なかがわ かのん、Nakagawa Kanon 女 東山奈央 3 高原步美 たかはら あゆみ、takahara ayumi 女 竹達彩奈 4 汐宫栞 汐宫刊、しおみや しおり、shiomiya shiori 女 花澤香菜 5 青山美生 あおやま みお 女 悠木碧 6 艾利由西亚·D·鲁德·伊玛 艾鲁西、Elsea De Lute Irma、エルシィ 女 伊藤かな恵 7 飞鸟空 あすか そら 女 櫻井智 8 桂木麻里","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/:2:0","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 只有神知道的世界 2010-10-06 12 樱花 2 只有神知道的世界II 2011-04-11 12 樱花 3 只有神知道的世界 天理篇 2012-10-18 2 樱花 4 只有神知道的世界 女神篇 2013-07-08 12 樱花 ","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/:3:0","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"MAD ","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/:4:0","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"为了征服持续污染海洋的人类，乌贼娘从深海来到了陆地。但是，原定为第一个侵略据点的海之家“LEMON”却被她破坏了，为了赚取修理费，她只能开始干活。连经营LEMON的相泽姐妹都无法压制的乌贼娘，是否能迎来征服人类的一天呢……\n\n由安部真弘创作、在「周刊少年Champion」上连载的以拟人化的乌贼娘形象为主角展开的搞笑类漫画「侵略！乌贼娘」，将于今秋动画化。尽管原作漫画在日本算不上大热之作，但宣告动画化后却引起了不少的关注。这部充斥恶搞与吐槽气的动画将由曾执导「热带雨林的爆笑生活」「钢铁新娘」等恶搞动画的水岛努操刀，可谓十分搭调。","date":"2010-10-04","objectID":"/anime/squid_girl/","tags":null,"title":"侵略！乌贼娘","uri":"/anime/squid_girl/"},{"categories":null,"content":"简介 为了征服持续污染海洋的人类，乌贼娘从深海来到了陆地。但是，原定为第一个侵略据点的海之家“LEMON”却被她破坏了，为了赚取修理费，她只能开始干活。连经营LEMON的相泽姐妹都无法压制的乌贼娘，是否能迎来征服人类的一天呢…… 由安部真弘创作、在「周刊少年Champion」上连载的以拟人化的乌贼娘形象为主角展开的搞笑类漫画「侵略！乌贼娘」，将于今秋动画化。尽管原作漫画在日本算不上大热之作，但宣告动画化后却引起了不少的关注。这部充斥恶搞与吐槽气的动画将由曾执导「热带雨林的爆笑生活」「钢铁新娘」等恶搞动画的水岛努操刀，可谓十分搭调。 制作人员： 原作：安部真弘 导演：水岛努 脚本：横手美智子、国","date":"2010-10-04","objectID":"/anime/squid_girl/:1:0","tags":null,"title":"侵略！乌贼娘","uri":"/anime/squid_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 乌贼娘 イカむすめ、Ika Musume、一个牧师妹 金元寿子 2 相泽荣子 あいざわ えいこ、Aizawa Eiko 女 藤村歩 3 相泽千鹤 あいざわ ちづる、Aizawa Chizuru 女 田中理恵 4 相泽武 あいざわ たける、Aizawa Takeru 男 大谷美貴 5 长月早苗 ながつき さなえ、Nagatsuki Sanae 女 伊藤かな恵 6 岚山悟郎 あらしやま ごろう、Arashiyama Gorou 男 中村悠一 7 齐藤渚 さいとう なぎさ、Saito Nagisa 女 片岡あづさ 8 辛迪·坎贝尔 Cindy Cambell 女 ","date":"2010-10-04","objectID":"/anime/squid_girl/:2:0","tags":null,"title":"侵略！乌贼娘","uri":"/anime/squid_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 侵略！乌贼娘 2010-10-04 12 樱花 2 侵略！？乌贼娘 2011-09-27 12 樱花 3 侵略！！乌贼娘 OAD 2012-08-08 3 bilibili ","date":"2010-10-04","objectID":"/anime/squid_girl/:3:0","tags":null,"title":"侵略！乌贼娘","uri":"/anime/squid_girl/"},{"categories":null,"content":"远离都市的乡间、奥木染。春日野悠带着他的妹妹·春日野穹来到了这里。\n兄妹俩幼时暑假期间曾来过多次奥木染，这里有着祖父的家，是个令人怀念的地方。\n因为意外事故而失去了双亲与去处的兄妹，决定移居至现在没有人居住的祖父家，在此开始新的生活。\n\n觉得自小以来就没怎么变化的街道与居民、教人怀念的回忆与静谧的环境，让悠倍感舒适。但徐徐地，变化来到了。\n阳光日渐变得强烈的初夏天空之下，故事开始了。","date":"2010-10-04","objectID":"/anime/yosuga_no_sora/","tags":null,"title":"缘之空","uri":"/anime/yosuga_no_sora/"},{"categories":null,"content":"简介 远离都市的乡间、奥木染。春日野悠带着他的妹妹·春日野穹来到了这里。 兄妹俩幼时暑假期间曾来过多次奥木染，这里有着祖父的家，是个令人怀念的地方。 因为意外事故而失去了双亲与去处的兄妹，决定移居至现在没有人居住的祖父家，在此开始新的生活。 觉得自小以来就没怎么变化的街道与居民、教人怀念的回忆与静谧的环境，让悠倍感舒适。但徐徐地，变化来到了。 阳光日渐变得强烈的初夏天空之下，故事开始了。 制作人员： 原作：Sphere 导演：高桥丈夫 脚本：荒川稔久、秋月ひろ、网谷正治 分镜：岛崎奈奈子、岛津聪行、山崎光惠 ","date":"2010-10-04","objectID":"/anime/yosuga_no_sora/:1:0","tags":null,"title":"缘之空","uri":"/anime/yosuga_no_sora/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 春日野悠 春日野悠、かすがの はるか、Ksugano Haruka 男 下野紘 2 春日野穹 かすがの そら、Kasugano Sora、穹妹 女 田口宏子 3 天女目瑛 あまつめ あきら 女 阪田佳代 4 依媛奈绪 よりひめ なお 女 いのくちゆか 5 渚一叶 みぎわ かずは 小野涼子 6 乃木坂初佳 乃木坂 初佳、のぎさか もとか、Nogisaka Motoka 女 岡嶋妙 7 伊福部八寻 伊福部 八寻、いふくべ やひろ、Ifukube Yahiro 女 田中涼子 8 仓永梢 仓永 梢、くらなが こずえ、Kuranaga Kozue 女 峰岸由香里 ","date":"2010-10-04","objectID":"/anime/yosuga_no_sora/:2:0","tags":null,"title":"缘之空","uri":"/anime/yosuga_no_sora/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 缘之空 2010-10-04 12 樱花 ","date":"2010-10-04","objectID":"/anime/yosuga_no_sora/:3:0","tags":null,"title":"缘之空","uri":"/anime/yosuga_no_sora/"},{"categories":null,"content":"由伏见司创作的轻小说「我的妹妹哪有这么可爱」仅仅推出了六卷，但销量已经突破了150万部，绝对是现今电击文库中人气飙升得最快的新贵。作品本身以萌妹作为招徕，配上傲娇、御宅、吐糟男等喜剧元素，可谓一部王道作品应该有的她都有了。但「我的妹妹哪有这么可爱」的魅力绝不仅于此，本身和妹妹的关系势成水火般互相漠不关心，竟然因为一张「和妹妹谈恋爱吧♪」的成人游戏DVD的关系，和妹妹之间的冰山便开始慢慢地融解，现在更发展成兄妹暧昧的关系，其破坏力绝对是在大家的想像之上。\n\n既然作品以萌妹作为招徕，当中的的两大萌角桐乃及黑猫也分别请来了现今萌妹系的代表声优竹达梓喵及花泽抚子来扮演。这种萌妹组合本身的“毒”性已经非常高，而负责音乐的还是创作了不少高萌性音乐的神前晓，看来「我的妹妹哪有这么可爱」的动画将会使不少宅们出现严重的中毒现象了。\n\n「我的妹妹哪有这么可爱」本身的故事和「乃木坂春香的秘密」有若干程度相似，都是女主角害怕自己的“御宅”被人鄙视，之后秘密给男主角知道后的喜剧作品，但不同的是少了无谓的闪光，多了桐乃对自身兴趣喜怒哀乐的描写，确实成就了校园、爱情、生活感情的小喜剧。希望大家看过「我的妹妹哪有这么可爱」的动画之后，便能感受她的魅力所在。","date":"2010-10-03","objectID":"/anime/oreimo/","tags":null,"title":"我的妹妹哪有这么可爱！","uri":"/anime/oreimo/"},{"categories":null,"content":"简介 由伏见司创作的轻小说「我的妹妹哪有这么可爱」仅仅推出了六卷，但销量已经突破了150万部，绝对是现今电击文库中人气飙升得最快的新贵。作品本身以萌妹作为招徕，配上傲娇、御宅、吐糟男等喜剧元素，可谓一部王道作品应该有的她都有了。但「我的妹妹哪有这么可爱」的魅力绝不仅于此，本身和妹妹的关系势成水火般互相漠不关心，竟然因为一张「和妹妹谈恋爱吧♪」的成人游戏DVD的关系，和妹妹之间的冰山便开始慢慢地融解，现在更发展成兄妹暧昧的关系，其破坏力绝对是在大家的想像之上。 既然作品以萌妹作为招徕，当中的的两大萌角桐乃及黑猫也分别请来了现今萌妹系的代表声优竹达梓喵及花泽抚子来扮演。这种萌妹组合本身的“毒”性已","date":"2010-10-03","objectID":"/anime/oreimo/:1:0","tags":null,"title":"我的妹妹哪有这么可爱！","uri":"/anime/oreimo/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 高坂桐乃 こうさかきりの、Kousaka Kirino 女 竹達彩奈 2 高坂京介 漆黑的贵公子、高坂 京介、こうさか きょうすけ、ko u sa ka kyou su ke、凶介 男 中村悠一 3 五更琉璃 黑猫、ごこう るり、Gokou Ruri、黒猫、千叶的堕天圣、Kuroneko、くろねこ 女 花澤香菜 4 槙岛沙织 さおり・バジーナ、沙織・バジーナ、沙织·巴吉纳、まきしま さおり 女 生天目仁美 5 田村麻奈实 地味子、たむら まなみ、tamura manami、土妹子 女 佐藤聡美 6 新垣绫濑 新垣 あやせ、あらがき あやせ、Aragaki A","date":"2010-10-03","objectID":"/anime/oreimo/:2:0","tags":null,"title":"我的妹妹哪有这么可爱！","uri":"/anime/oreimo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我的妹妹哪有这么可爱！ 2010-10-03 16 bilibili 2 我的妹妹哪有这么可爱。 2013-04-06 16 bilibili ","date":"2010-10-03","objectID":"/anime/oreimo/:3:0","tags":null,"title":"我的妹妹哪有这么可爱！","uri":"/anime/oreimo/"},{"categories":null,"content":"MAD ","date":"2010-10-03","objectID":"/anime/oreimo/:4:0","tags":null,"title":"我的妹妹哪有这么可爱！","uri":"/anime/oreimo/"},{"categories":null,"content":"在天堂和地狱的裂缝之间有一座城市—堕天城（Daten City），在那里人们一直饱受“恶灵（Ghost）”的袭击。\n腐蚀人心的黑暗，至今仍在悄悄地侵蚀这个城市，有人正试图以超自然力，消灭这些由欲望产生的恶灵，担负了这驱逐黑暗的使命。\n因行为不检而被踢出天堂的天使姐妹——Panty与Stocking，必须在Garterbelt的指示下歼灭恶灵，并得到代表功绩的天堂金币（Heaven Coins）作为回报，达成目标即可回到天堂。\n然而天使姐妹对在堕天使城的日常生活，显然有相当程度的病态兴趣……","date":"2010-10-01","objectID":"/anime/panty_stocking/","tags":null,"title":"吊带袜天使","uri":"/anime/panty_stocking/"},{"categories":null,"content":"简介 在天堂和地狱的裂缝之间有一座城市—堕天城（Daten City），在那里人们一直饱受“恶灵（Ghost）”的袭击。 腐蚀人心的黑暗，至今仍在悄悄地侵蚀这个城市，有人正试图以超自然力，消灭这些由欲望产生的恶灵，担负了这驱逐黑暗的使命。 因行为不检而被踢出天堂的天使姐妹——Panty与Stocking，必须在Garterbelt的指示下歼灭恶灵，并得到代表功绩的天堂金币（Heaven Coins）作为回报，达成目标即可回到天堂。 然而天使姐妹对在堕天使城的日常生活，显然有相当程度的病态兴趣…… 制作人员： 原作：GAINAX 导演：今石洋之 脚本：濑古浩司、小山重人、若林广海、板垣伸、大冢雅","date":"2010-10-01","objectID":"/anime/panty_stocking/:1:0","tags":null,"title":"吊带袜天使","uri":"/anime/panty_stocking/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 Panty Anarchy Panty、アナーキー・パンティ 女 小笠原亜里沙 2 Stocking Anarchy Stocking、アナーキー・ストッキング 女 伊瀬茉莉也 3 Garterbelt ガーターベルト 男 石井康嗣 4 恰库 拉链狗、Chuck、チャック 公 5 Brief Briefers Rock、ブリーファス・ロック、Geek Boy 男 吉野裕行 6 妮索克丝 Kneesocks 女 藤村歩 7 丝坎蒂 Scanty 女 小松由佳 8 法斯特内尔 Fastener ？？ 槙口みき ","date":"2010-10-01","objectID":"/anime/panty_stocking/:2:0","tags":null,"title":"吊带袜天使","uri":"/anime/panty_stocking/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 吊带袜天使 2010-10-01 13 樱花 ","date":"2010-10-01","objectID":"/anime/panty_stocking/:3:0","tags":null,"title":"吊带袜天使","uri":"/anime/panty_stocking/"},{"categories":null,"content":"　　一个前世作恶多端、永世不得投胎的灵魂，却因天使的抽签活动，获得复活的机会。他借用了一位14岁的少年身体，展开一段奇妙的寄身生活。在守护天使的帮助下，他在生活中感受到酸甜苦辣，从开始的不甘情愿到体会活著的美妙。逐渐地他与家人、同学产生感情，并找到自己的生活目标。\n　　死后浮在天界与下界夹缝中的“我”的面前，出现了一名天使，他对“我”说，“犯下大过而死去的罪孽的灵魂，现在再给你一次机会回到下界，希望你能够明白你犯下的罪孽。”之后“我”进入了因为自杀刚刚死去的中学三年级生“小林真”的身体里，作为“小林真”活了过来……","date":"2010-08-21","objectID":"/anime/colorful/","tags":null,"title":"意外的幸运签","uri":"/anime/colorful/"},{"categories":null,"content":"简介 一个前世作恶多端、永世不得投胎的灵魂，却因天使的抽签活动，获得复活的机会。他借用了一位14岁的少年身体，展开一段奇妙的寄身生活。在守护天使的帮助下，他在生活中感受到酸甜苦辣，从开始的不甘情愿到体会活著的美妙。逐渐地他与家人、同学产生感情，并找到自己的生活目标。 死后浮在天界与下界夹缝中的“我”的面前，出现了一名天使，他对“我”说，“犯下大过而死去的罪孽的灵魂，现在再给你一次机会回到下界，希望你能够明白你犯下的罪孽。”之后“我”进入了因为自杀刚刚死去的中学三年级生“小林真”的身体里，作为“小林真”活了过来…… 制作人员： 原作：森绘都 导演：原惠一 脚本：丸尾未步 音乐：大谷幸 人物设定：","date":"2010-08-21","objectID":"/anime/colorful/:1:0","tags":null,"title":"意外的幸运签","uri":"/anime/colorful/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小林真 Kobayashi Makoto、こばやし まこと 男 冨澤風斗 2 佐野唱子 Shōko Sano、さの しょうこ、Sano Shouko 女 宮﨑あおい 3 桑原祐华 Kuwabara Hiroka、くわばら ひろか 女 南明奈 4 普拉普拉 Purapura 男 まいける 5 早乙女 Saotome、さおとめ 男 入江甚儀 ","date":"2010-08-21","objectID":"/anime/colorful/:2:0","tags":null,"title":"意外的幸运签","uri":"/anime/colorful/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 意外的幸运签 2010-08-21 1 樱花 ","date":"2010-08-21","objectID":"/anime/colorful/:3:0","tags":null,"title":"意外的幸运签","uri":"/anime/colorful/"},{"categories":null,"content":"在《借东西的小人阿丽埃蒂》故事里，身高只有10公分的少女“阿丽埃蒂”与她的迷你家族，在日常生活中必须跟老鼠作战、还必须要躲过杀虫剂和补蟑屋等各种不同的危险。\n由于必须“借用”许多人类的日用品来生活，又不能被人类发现他们的存在，因此自古以来人类只要有东西忽然间不知去向，就会认为是被这些迷你的小矮人借走。而艾莉媞却在偶然的机遇下，与人类的男孩“翔”成为了朋友，却也因为被人类发现必须移居到野外展开新生活…。\n目前公布的参演名单中，包括了初次参与配音工作就饰演主角艾莉媞的女演员志田未来，还有饰演翔的神木隆之介，神木隆之介过去曾为《夏日大作战》中的男主角配音。\n除此之外，还有大竹忍、竹下景子、三浦友和、树木希林…等演员也将参与演出，《借东西的小人阿莉埃蒂》预定于7月17日在日本上映。","date":"2010-07-17","objectID":"/anime/the_secret_world_of_arrietty/","tags":null,"title":"借东西的小人阿丽埃蒂","uri":"/anime/the_secret_world_of_arrietty/"},{"categories":null,"content":"简介 在《借东西的小人阿丽埃蒂》故事里，身高只有10公分的少女“阿丽埃蒂”与她的迷你家族，在日常生活中必须跟老鼠作战、还必须要躲过杀虫剂和补蟑屋等各种不同的危险。 由于必须“借用”许多人类的日用品来生活，又不能被人类发现他们的存在，因此自古以来人类只要有东西忽然间不知去向，就会认为是被这些迷你的小矮人借走。而艾莉媞却在偶然的机遇下，与人类的男孩“翔”成为了朋友，却也因为被人类发现必须移居到野外展开新生活…。 目前公布的参演名单中，包括了初次参与配音工作就饰演主角艾莉媞的女演员志田未来，还有饰演翔的神木隆之介，神木隆之介过去曾为《夏日大作战》中的男主角配音。 除此之外，还有大竹忍、竹下景子、三浦","date":"2010-07-17","objectID":"/anime/the_secret_world_of_arrietty/:1:0","tags":null,"title":"借东西的小人阿丽埃蒂","uri":"/anime/the_secret_world_of_arrietty/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿丽埃蒂 Arrietty 女 志田未来 2 翔 Shou 男 神木隆之介 ","date":"2010-07-17","objectID":"/anime/the_secret_world_of_arrietty/:2:0","tags":null,"title":"借东西的小人阿丽埃蒂","uri":"/anime/the_secret_world_of_arrietty/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 借东西的小人阿丽埃蒂 2010-07-17 1 樱花 ","date":"2010-07-17","objectID":"/anime/the_secret_world_of_arrietty/:3:0","tags":null,"title":"借东西的小人阿丽埃蒂","uri":"/anime/the_secret_world_of_arrietty/"},{"categories":null,"content":"初代作品《古剑奇谭：琴心剑魄今何在》于2010年7月10日发售，为中国首部全程配音的单机游戏，2014年被改编为同名电视剧。\n二代作品《古剑奇谭二：永夜初晗凝碧天》于2013年8月18日在两岸三地同步发售，该作放弃了回合制战斗方式而尝试即时制战斗，\n剧情方面则采用了电影化的表现手法。三代作品《古剑奇谭三：梦付千秋星垂野》于2018年11于23日上市，采用全即时制战斗。","date":"2010-07-10","objectID":"/game/gu_jian/","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"简介 初代作品《古剑奇谭：琴心剑魄今何在》于2010年7月10日发售，为中国首部全程配音的单机游戏，2014年被改编为同名电视剧。 二代作品《古剑奇谭二：永夜初晗凝碧天》于2013年8月18日在两岸三地同步发售，该作放弃了回合制战斗方式而尝试即时制战斗， 剧情方面则采用了电影化的表现手法。 三代作品《古剑奇谭三：梦付千秋星垂野》于2018年11于23日上市，采用全即时制战斗。 制作人员： 开发：上海烛龙信息科技有限公司 发行：北京网元圣唐娱乐科技有限公司 遊戲設計師：邵芸 剧本：张毅君 音乐：骆集益、周志华 人物设定：寸身言 ","date":"2010-07-10","objectID":"/game/gu_jian/:1:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 百里屠苏 韩云溪、苏苏 男 陈家恒 2 风晴雪 女 朱雀橙 3 襄铃 女 阎萌萌 4 尹千觞 风广陌 男 陆揆 5 欧阳少恭 男 彭尧 6 方兰生 男 7 红玉 女 8 陵越 大师兄 男 边江 ","date":"2010-07-10","objectID":"/game/gu_jian/:2:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"系列 系列名 发行时间 1 古剑奇谭 琴心剑魄今何在 2010-07-10 2 古剑奇谭二 永夜初晗凝碧天 2013-08-18 3 古剑奇谭三 梦付千秋星垂野 2018-11-23 ","date":"2010-07-10","objectID":"/game/gu_jian/:3:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"配乐 ","date":"2010-07-10","objectID":"/game/gu_jian/:4:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"MAD ","date":"2010-07-10","objectID":"/game/gu_jian/:5:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"外场村是一个几乎与外界隔绝的村落，虽然距离大城市只有一小时的车程，但是很少与外界接触。这里的村民一直以来都保留着土葬和其他古老的传统习俗。\n于八月份晚，村民举行送虫祭的晚上，村民发现一辆神秘的搬运公司货车正驶入村子。不久村民发现住在山入的三名长者离奇死亡，尸体被野狗咬得残缺不全。之后村子里不断地有村民死亡和搬迁。正当大家讨论着连大屋一起新搬进来的一户人家之时，尾崎医院院长敏夫和寺院副住持静信开始调查令村民离奇死亡的 “传染病”，发现了惊人的内幕……","date":"2010-07-08","objectID":"/anime/shiki/","tags":null,"title":"尸鬼","uri":"/anime/shiki/"},{"categories":null,"content":"简介 外场村是一个几乎与外界隔绝的村落，虽然距离大城市只有一小时的车程，但是很少与外界接触。这里的村民一直以来都保留着土葬和其他古老的传统习俗。 于八月份晚，村民举行送虫祭的晚上，村民发现一辆神秘的搬运公司货车正驶入村子。不久村民发现住在山入的三名长者离奇死亡，尸体被野狗咬得残缺不全。之后村子里不断地有村民死亡和搬迁。正当大家讨论着连大屋一起新搬进来的一户人家之时，尾崎医院院长敏夫和寺院副住持静信开始调查令村民离奇死亡的 “传染病”，发现了惊人的内幕…… 制作人员： 原作：藤崎龙、小野不由美 导演：网野哲郎 脚本：新宅纯一、石川麻美、杉原研二、平林佐和子、高木登 分镜：寺泽伸介 ","date":"2010-07-08","objectID":"/anime/shiki/:1:0","tags":null,"title":"尸鬼","uri":"/anime/shiki/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 结城夏野 小出夏野、結城 夏野、ゆうき なつの、Yuuki Natsuno、Koide Natsuno 男 内山昂輝 2 桐敷沙子 桐敷 沙子、きりしき すなこ、Kirishiki Sunako 女 悠木碧 3 清水惠 清水 恵、しみず めぐみ、Shimizu Megumi 女 戸松遥 4 室井静信 室井 静信、むろい せいしん、Muroi Seishin 男 興津和幸 5 尾崎敏夫 尾崎 敏夫、おざき としお、Ozaki Toshio 男 大川透 6 武藤彻 武藤 徹、むとう とおる、Tohru Mutou 男 岡本信彦 7 村迫正雄 村迫 正雄、むらさこ","date":"2010-07-08","objectID":"/anime/shiki/:2:0","tags":null,"title":"尸鬼","uri":"/anime/shiki/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 尸鬼 2010-07-08 22 樱花 ","date":"2010-07-08","objectID":"/anime/shiki/:3:0","tags":null,"title":"尸鬼","uri":"/anime/shiki/"},{"categories":null,"content":"故事的舞台——私立樱才学园，原本是传统的女子高中，但因少子化问题影响，不得不改制为男女合校。作为改制后第一年入学的28名男性新生之一的津田隆利，偶然之下被拉入了学校的学生会。在外人看来，学生会是美女如云的天堂，但是津田身边的三位学生会女干部性格都非常独特，津田开始了他每天学生会的吐槽生活……","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"简介 故事的舞台——私立樱才学园，原本是传统的女子高中，但因少子化问题影响，不得不改制为男女合校。作为改制后第一年入学的28名男性新生之一的津田隆利，偶然之下被拉入了学校的学生会。在外人看来，学生会是美女如云的天堂，但是津田身边的三位学生会女干部性格都非常独特，津田开始了他每天学生会的吐槽生活…… 制作人员： 原作：氏家ト全 导演：金泽洪充 脚本：小山知子、中村诚 分镜：博史池畠、安川胜 演出：渡边哲哉 ","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/:1:0","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 津田隆利 つだ たかとし、Tsuda Takatoshi、烧棍、当代柳下惠 男 小林ゆう 2 天草筱 あまくさ しの、Amakusa Shino 女 日笠陽子 3 七条天空 しちじょう ありあ、Shichijou Aria、七条真空 女 佐藤聡美 4 萩村铃 はぎむら すず、Hagimura Suzu 女 矢作紗友里 5 津田琴美 つだ ことみ、Tsuda kotomi 女 下田麻美 6 五十岚枫 いがらし かえで、Igarashi Kaede 女 加藤英美里 7 道下老师 みちした 女 大山早稀 8 海辺ナナコ Umibe Nanako 女 安済知佳 ","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/:2:0","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 妄想学生会 2010-07-03 21 樱花 2 妄想学生会＊ 2014-01-04 23 樱花 3 剧场版 妄想学生会 2017-07-21 2 樱花 4 剧场版 妄想学生会2 2021-01-01 1 樱花 ","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/:3:0","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"MAD ","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/:4:0","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"大神凉子（通称为‘大神’）是就读私立御伽学园高中一年级，与赤井林檎（通称为‘小红帽’）合伙，虽然与御伽学园学生互助协会（通称为‘御伽银行’）的每个人合作，但是今天也为了任意改造社会而持续战斗著！！","date":"2010-07-01","objectID":"/anime/okami-san_and_her_seven_companions/","tags":null,"title":"大神与七位伙伴","uri":"/anime/okami-san_and_her_seven_companions/"},{"categories":null,"content":"简介 大神凉子（通称为‘大神’）是就读私立御伽学园高中一年级，与赤井林檎（通称为‘小红帽’）合伙，虽然与御伽学园学生互助协会（通称为‘御伽银行’）的每个人合作，但是今天也为了任意改造社会而持续战斗著！！ 制作人员： 原作：沖田雅 导演：岩崎良明 脚本：白根秀树、伊藤美智子 分镜：青井小夜、柳泽哲也、二瓶勇一、铃木洋平 ","date":"2010-07-01","objectID":"/anime/okami-san_and_her_seven_companions/:1:0","tags":null,"title":"大神与七位伙伴","uri":"/anime/okami-san_and_her_seven_companions/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 大神凉子 おおかみ りょうこ、Okami Ryouko 女 伊藤静 2 赤井林檎 あかい りんご、Akai Ringo 女 伊藤かな恵 3 森野亮士 もりの りょうし、Morino Ryoushi 男 入野自由 4 桐木李斯特 きりき りすと、Kiriki Risuto 男 野島裕史 5 桐木爱丽丝 きりき ありす、Kiriki Arisu 女 堀江由衣 6 鹤谷乙卯 つるがや おつう、Tsurugaya Otsu 女 川澄綾子 7 浦岛太郎 うらしま たろう、Urashima Tarou 男 浅沼晋太郎 8 龙宫乙姬 りゅうぐう おとひめ、Ryugu Ot","date":"2010-07-01","objectID":"/anime/okami-san_and_her_seven_companions/:2:0","tags":null,"title":"大神与七位伙伴","uri":"/anime/okami-san_and_her_seven_companions/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 大神与七位伙伴 2010-07-01 12 bilibili ","date":"2010-07-01","objectID":"/anime/okami-san_and_her_seven_companions/:3:0","tags":null,"title":"大神与七位伙伴","uri":"/anime/okami-san_and_her_seven_companions/"},{"categories":null,"content":"橘纯一是一个高中二年级生，由于过去的经历变得不擅长应对恋爱和圣诞节这类事情，一直过着没女朋友的寂寞的校园生活。这样的纯一某一天突然想到：“直到高中毕业就这样什么都不做真的好吗？”于是，他克服自己的缺点，抱着今年的圣诞节要和女孩子过的想法，与不同的女孩子邂逅。纯一将会迎来一个怎么样的圣诞节……","date":"2010-07-01","objectID":"/anime/amagami/","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"简介 橘纯一是一个高中二年级生，由于过去的经历变得不擅长应对恋爱和圣诞节这类事情，一直过着没女朋友的寂寞的校园生活。这样的纯一某一天突然想到：“直到高中毕业就这样什么都不做真的好吗？”于是，他克服自己的缺点，抱着今年的圣诞节要和女孩子过的想法，与不同的女孩子邂逅。纯一将会迎来一个怎么样的圣诞节…… 制作人员： 原作：enterbrain 导演：平池芳正 脚本：待田堂子、木村畅 分镜：筱原俊哉、畑博之、金崎贵臣、木村真一郎 ","date":"2010-07-01","objectID":"/anime/amagami/:1:0","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 橘纯一 Junichi Tachibana、橘 純一、たちばな じゅんいち、Tachibana Junichi 男 斎藤桃子 2 森岛遥 森島・ラブリー・はるか、森島・L・はるか、森岛·L·遥、Haruka Lovely Morishima、森島 はるか、もりしま はるか、Morishima Haruka、学姐 女 伊藤静 3 棚町薰 Kaoru Tanamachi、棚町 薫、たなまち かおる、Tanamachi Kaoru 女 佐藤利奈 4 中多纱江 Sae Nakata、中多 紗江、なかた さえ、Nakata Sae 女 今野宏美 5 七咲逢 Ai Na","date":"2010-07-01","objectID":"/anime/amagami/:2:0","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 圣诞之吻SS 2010-07-01 26 bilibili 2 圣诞之吻SS+ plus 2012-01-05 13 bilibili ","date":"2010-07-01","objectID":"/anime/amagami/:3:0","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"MAD ","date":"2010-07-01","objectID":"/anime/amagami/:4:0","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"NDS推理AVG游戏《幽灵欺诈》是由《逆转裁判》系列的制作者“巧舟”制作推出的完全新作，玩家要扮演已经死了的“幽灵侦探”西塞鲁，追踪自己死亡的真相。游戏的风格类似《时空之穴》，画风则与著名逃脱游戏《EXIT》类似。(via TGBUS)","date":"2010-06-24","objectID":"/game/ghost_trick/","tags":null,"title":"幽灵诡计","uri":"/game/ghost_trick/"},{"categories":null,"content":"简介 NDS推理AVG游戏《幽灵欺诈》是由《逆转裁判》系列的制作者“巧舟”制作推出的完全新作，玩家要扮演已经死了的“幽灵侦探”西塞鲁，追踪自己死亡的真相。游戏的风格类似《时空之穴》，画风则与著名逃脱游戏《EXIT》类似。(via TGBUS) 制作人员： 开发：卡普空 音乐：杉森雅和 导演：巧舟 制作总指挥：稻船敬二 ","date":"2010-06-24","objectID":"/game/ghost_trick/:1:0","tags":null,"title":"幽灵诡计","uri":"/game/ghost_trick/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 西塞路 西塞尔、Sissel 男 2 琳奈 Lynne 女 3 米赛璐 导弹、Missile 4 卡农 Kanon 女 5 库内里 Kuneri ","date":"2010-06-24","objectID":"/game/ghost_trick/:2:0","tags":null,"title":"幽灵诡计","uri":"/game/ghost_trick/"},{"categories":null,"content":"系列 系列名 发行时间 1 幽灵诡计 2010-06-24 ","date":"2010-06-24","objectID":"/game/ghost_trick/:3:0","tags":null,"title":"幽灵诡计","uri":"/game/ghost_trick/"},{"categories":null,"content":"在散发着青春朝气的圣条学院，高一新生井上心叶（入野自由 配音）偶然结识了高二前辈天野远子（花泽香菜 配音），由此加入了天野担任部长只有她一名成员的文学部。天野是个奇怪的女孩，文学对她来说就是味道不同的食物，她拒绝着写满文字的纸片，动人优美的笔触甘之若饴，糟糕的文字则如鲠在喉却不忍弃之。除此之外，他们还面对全校开展代写情书的业务，只不过应者寥寥。这一天，信箱里收到久违的信件，可是纸上却只有一幅涂鸦。经过查询，那个涂鸦竟然来自诗人兼童话作家宫崎贤治。看似是一桩恶作剧，但却勾起了心叶对天才文学少女井上美羽和那名自杀女孩的痛苦记忆……   本片根据野村美月的轻小说改编。","date":"2010-05-01","objectID":"/anime/bungaku_shoujo/","tags":null,"title":"文学少女","uri":"/anime/bungaku_shoujo/"},{"categories":null,"content":"简介 在散发着青春朝气的圣条学院，高一新生井上心叶（入野自由 配音）偶然结识了高二前辈天野远子（花泽香菜 配音），由此加入了天野担任部长只有她一名成员的文学部。天野是个奇怪的女孩，文学对她来说就是味道不同的食物，她拒绝着写满文字的纸片，动人优美的笔触甘之若饴，糟糕的文字则如鲠在喉却不忍弃之。除此之外，他们还面对全校开展代写情书的业务，只不过应者寥寥。这一天，信箱里收到久违的信件，可是纸上却只有一幅涂鸦。经过查询，那个涂鸦竟然来自诗人兼童话作家宫崎贤治。看似是一桩恶作剧，但却勾起了心叶对天才文学少女井上美羽和那名自杀女孩的痛苦记忆…… 本片根据野村美月的轻小说改编。 制作人员： 原作：野村美月 ","date":"2010-05-01","objectID":"/anime/bungaku_shoujo/:1:0","tags":null,"title":"文学少女","uri":"/anime/bungaku_shoujo/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天野远子 天野 遠子、あまの とおこ、amano tooko、吃書妖怪 女 花澤香菜 2 井上心叶 井上 心葉、いのうえ このは、inoue konoha 男 斎藤千和 3 琴吹七濑 琴吹 ななせ、ことぶき ななせ、kotobuki nanase、ななせちゃん 女 水樹奈々 4 芥川一诗 芥川 一詩、あくたがわ かずし 小野大輔 5 朝仓美羽 あくたがわ かずし、あさくら みう、Asakura Miu、美羽大魔王 女 平野綾 6 姬仓麻贵 姫倉 麻貴、ひめくら まき、himekura maki、公主 女 伊藤静 7 竹田千爱 竹田 千愛、たけだ ちあ 女 豊","date":"2010-05-01","objectID":"/anime/bungaku_shoujo/:2:0","tags":null,"title":"文学少女","uri":"/anime/bungaku_shoujo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 文学少女 剧场版 2010-05-01 100:48 bilibili ","date":"2010-05-01","objectID":"/anime/bungaku_shoujo/:3:0","tags":null,"title":"文学少女","uri":"/anime/bungaku_shoujo/"},{"categories":null,"content":"MAD ","date":"2010-05-01","objectID":"/anime/bungaku_shoujo/:4:0","tags":null,"title":"文学少女","uri":"/anime/bungaku_shoujo/"},{"categories":null,"content":"身为大三学生的“我”，梦想着多采多姿的校园生活却过了两年毫无意义的生活。虽然入学时在众多社团中选择了网球社，但是因为无法与人对话而失去容身之处。这时，他遇上有同样际遇的小津，两人组成了在社团内外四处妨碍人恋爱、恶名昭彰的“黑色丘比特”。没有遇到小津的话肯定能与黑发少女过着缤纷的人生！如果那时候选了其他社团……","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"简介 身为大三学生的“我”，梦想着多采多姿的校园生活却过了两年毫无意义的生活。虽然入学时在众多社团中选择了网球社，但是因为无法与人对话而失去容身之处。这时，他遇上有同样际遇的小津，两人组成了在社团内外四处妨碍人恋爱、恶名昭彰的“黑色丘比特”。没有遇到小津的话肯定能与黑发少女过着缤纷的人生！如果那时候选了其他社团…… 制作人员： 原作：森见登美彦 导演：汤浅政明 脚本：上田诚 分镜：牧原亮太郎、清水洋、三原三千夫、崔恩映 ","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/:1:0","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 我 男 浅沼晋太郎 2 小津 おづ 男 吉野裕行 3 明石 あかしさん 女 坂本真綾 4 樋口清太郎 樋口 清太郎、樋口師匠 男 藤原啓治 5 羽贯凉子 羽貫さん、羽貫 涼子 女 甲斐田裕子 6 城崎先辈 城崎学长、城崎 男 諏訪部順一 7 相岛 相岛学长 男 佐藤せつじ 8 香织 女 能登麻美子 ","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/:2:0","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 四叠半神话大系 2010-04-22 11 bilibili ","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/:3:0","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"MAD ","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/:4:0","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"男子之间的友情与美少女要素满载的超级爆笑恋爱喜剧开始了！\n平凡的男生都筑巧与没有血缘关系的姐姐都筑乙女两人生活在一起。\n并不擅长经营的姐姐把自己家里的西点店STRAY CATS弄得惨淡不堪，幸亏有家住附近的青梅竹马芹泽文乃帮忙，才勉强维持着每日的营业。\n正在这种情况下，姐姐乙女还捡回了一个不得了的东西，更新奇的是那位学园排名第一的大小姐还想创立一个新的社团。\n面对这状况，文乃只会在那里大喊着“给我去死两次！！！”。\n这可真是……平静的日子早就一起不复返了。","date":"2010-04-06","objectID":"/anime/stray_cats_overrun/","tags":null,"title":"迷途猫OVER RUN","uri":"/anime/stray_cats_overrun/"},{"categories":null,"content":"简介 男子之间的友情与美少女要素满载的超级爆笑恋爱喜剧开始了！ 平凡的男生都筑巧与没有血缘关系的姐姐都筑乙女两人生活在一起。 并不擅长经营的姐姐把自己家里的西点店STRAY CATS弄得惨淡不堪，幸亏有家住附近的青梅竹马芹泽文乃帮忙，才勉强维持着每日的营业。 正在这种情况下，姐姐乙女还捡回了一个不得了的东西，更新奇的是那位学园排名第一的大小姐还想创立一个新的社团。 面对这状况，文乃只会在那里大喊着“给我去死两次！！！”。 这可真是……平静的日子早就一起不复返了。 制作人员： 原作：松智洋 导演：八谷贤一、平池芳正、板垣伸、大地丙太郎、福田道生、平田智浩、久城理音、佐藤卓哉 ","date":"2010-04-06","objectID":"/anime/stray_cats_overrun/:1:0","tags":null,"title":"迷途猫OVER RUN","uri":"/anime/stray_cats_overrun/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雾谷希 きりや のぞみ、Kiriya Nozomi 女 竹達彩奈 2 芹泽文乃 せりざわ ふみの、Serizawa Fumino 女 伊藤かな恵 3 梅之森千世 うめのもり ちせ、Umenomori Chise 女 井口裕香 4 都筑巧 都築 巧、つづき たくみ、Tsuzuki Takumi 男 岡本信彦 5 都筑乙女 都築 乙女、つづき おとめ、Tsuzuki Otome 女 佐藤聡美 6 鸣子叶绘 なるこ かなえ、Naruko Kanae 女 堀江由衣 7 竹马园夏帆 ちくまえん かほ、Chikumaen Kaho 女 田村ゆかり 8 菊池家康 きくち ","date":"2010-04-06","objectID":"/anime/stray_cats_overrun/:2:0","tags":null,"title":"迷途猫OVER RUN","uri":"/anime/stray_cats_overrun/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 迷途猫OVER RUN 2010-04-06 13 樱花 ","date":"2010-04-06","objectID":"/anime/stray_cats_overrun/:3:0","tags":null,"title":"迷途猫OVER RUN","uri":"/anime/stray_cats_overrun/"},{"categories":null,"content":"在史克威尔艾尼克斯的漫画杂志YOUNG GANGAN2005年1号开始连载的四格漫画。以北海道某处被常客评论为“危险的感觉令人上瘾”的餐厅“瓦古娜利亚”为舞台，充满各种奇人异事的四格漫画。登场角色彼此间吐槽相当轻快。\n\n平时以六页为一个单位连载，有时一次刊登两话。有时也有不是四格漫画的短篇故事。四格漫画和后来的故事有巧妙的连结，节奏掌握良好。每回的第一页有一半的部分相当于扉页，刊登时为角色的独白或对话，但没有收录进漫画单行本中。\n\n原本是作者在自己的网站上不定期连载的网络四格漫画《WORKING!!》，为了杂志连载，将加入新的舞台设定与登场人物而成为本作。舞台是在和网络漫画不同的餐厅“瓦古娜利亚”，但具有共通的世界观。里面有店长的旧识与佐藤的乐团伙伴等，设定相联的角色存在。以下将网络连载的部分称为猫组，杂志连载称为犬组。登场人物也有一部分以打广告的名义在网站上登场，杂志连载人物还有在网站上出场次数比较多的角色。但因为权利的关系，猫组的人物并未在犬组登场。\n\n2006月30日开始也有手机发送的番外篇。2007年1月25日发售广播剧CD。2010年4月预定开始播放TV版动画。","date":"2010-04-04","objectID":"/anime/working/","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"简介 在史克威尔艾尼克斯的漫画杂志YOUNG GANGAN2005年1号开始连载的四格漫画。以北海道某处被常客评论为“危险的感觉令人上瘾”的餐厅“瓦古娜利亚”为舞台，充满各种奇人异事的四格漫画。登场角色彼此间吐槽相当轻快。 平时以六页为一个单位连载，有时一次刊登两话。有时也有不是四格漫画的短篇故事。四格漫画和后来的故事有巧妙的连结，节奏掌握良好。每回的第一页有一半的部分相当于扉页，刊登时为角色的独白或对话，但没有收录进漫画单行本中。 原本是作者在自己的网站上不定期连载的网络四格漫画《WORKING!!》，为了杂志连载，将加入新的舞台设定与登场人物而成为本作。舞台是在和网络漫画不同的餐厅“瓦古娜","date":"2010-04-04","objectID":"/anime/working/:1:0","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小鸟游宗太 たかなし そうた、Takanashi Souta 男 福山潤 2 佐藤润 さとうじゅん、Sato Jun 男 小野大輔 3 相马博臣 そうま ひろおみ、Soma Hiroomi 男 神谷浩史 4 种岛白杨 たねしま ぽぷら、Taneshima Popura 女 阿澄佳奈 5 伊波真昼 いなみ まひる、Inami Mahiru 女 藤田咲 6 轰八千代 Todorok Yachiyo 女 喜多村英梨 7 白藤杏子 白藤 杏子、しらふじ きょうこ、Shirafuji Kyouko 女 渡辺久美子 8 山田葵 やまだ あおい、Yamada Aoi 女 ","date":"2010-04-04","objectID":"/anime/working/:2:0","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 迷糊餐厅 2010-04-04 13 bilibili 2 迷糊餐厅 第二季 2011-10-01 13 bilibili 3 迷糊餐厅 第三季 2015-07-04 13 bilibili 4 WWW. 迷糊餐厅 2016-10-01 13 bilibili ","date":"2010-04-04","objectID":"/anime/working/:3:0","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"MAD ","date":"2010-04-04","objectID":"/anime/working/:4:0","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"　　故事从男主角死亡之后从“死后的世界”醒来开始，在“死后的世界”中的学校里，他与一位名为由利(ゆり)、在“死后的世界”率领着一个名为“死んだ(Shinda)世界(Sekai)战线(Sensen)”简称“SSS”的组织的少女相遇了。“SSS”成立的主要目的是与赐予他们生前悲哀命运的神以及神之使者——天使交战，在天使超乎常理的异能面前，“SSS”只能用枪来反抗。就这样一场发生在“死后的世界”的学校里的超能大战物语开始了……\n\n","date":"2010-04-02","objectID":"/anime/angel_beats/","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"简介 故事从男主角死亡之后从“死后的世界”醒来开始，在“死后的世界”中的学校里，他与一位名为由利(ゆり)、在“死后的世界”率领着一个名为“死んだ(Shinda)世界(Sekai)战线(Sensen)”简称“SSS”的组织的少女相遇了。“SSS”成立的主要目的是与赐予他们生前悲哀命运的神以及神之使者——天使交战，在天使超乎常理的异能面前，“SSS”只能用枪来反抗。就这样一场发生在“死后的世界”的学校里的超能大战物语开始了…… 制作人员： 原作：Visual Art’s、Key、麻枝准 导演：岸诚二 分镜：平井义通、青木英、政木伸一 ","date":"2010-04-02","objectID":"/anime/angel_beats/:1:0","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 仲村由理 仲村百合、仲村 ゆり、なかむら ゆり、Nakamura Yuri、游离子、小百合、伪团长 女 櫻井浩美 2 音无结弦 音無 結弦、おとなし ゆづる、Otonashi Yuzuru 男 神谷浩史 3 立华奏 立花奏、橘奏、立華 かなで、たちばな かなで、Tachibana Kanade、天使 女 花澤香菜 4 日向秀树 ひなた ひでき、Hinada Hideki 男 木村良平 5 查 Chaa 男 東地宏樹 6 由依 结衣、唯、ユイ、Yui、由依喵、由依酱 女 喜多村英梨 7 岩泽雅美 岩泽正美、岩泽麻美（误译）、岩沢 雅美、いわさわ まさみ、Iwa","date":"2010-04-02","objectID":"/anime/angel_beats/:2:0","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天使的心跳！ 2010-04-02 13 bilibili ","date":"2010-04-02","objectID":"/anime/angel_beats/:3:0","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"MAD ","date":"2010-04-02","objectID":"/anime/angel_beats/:4:0","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"三里洋子在「周刊Young Jump」上连载的四格漫画「B型H系」，将被改编成TV动画，于今年春番档期播出。「B型H系」是一部糟糕中带点轻喜的作品，讲述了超级人气美少女山田以进入高中后要找到100个伴侣为目标，在一次意外中找到了非常适合她初次体验的男生小须田，谁料小须田竟然是对感情非常迟钝的人，为小须田不理会自己的魅力而受到打击的山田发现其实小须田还有个青梅竹马的女生在偷偷暗恋着他，并擅长山田所薄弱的料理，一气之下山田为展现自己的魅力夺得了学年皇后的称号，然而另一个超级人气美少女出现了，并以夺取山田的一切为目标……","date":"2010-04-01","objectID":"/anime/b_gata_h_kei/","tags":null,"title":"B型H系","uri":"/anime/b_gata_h_kei/"},{"categories":null,"content":"简介 三里洋子在「周刊Young Jump」上连载的四格漫画「B型H系」，将被改编成TV动画，于今年春番档期播出。「B型H系」是一部糟糕中带点轻喜的作品，讲述了超级人气美少女山田以进入高中后要找到100个伴侣为目标，在一次意外中找到了非常适合她初次体验的男生小须田，谁料小须田竟然是对感情非常迟钝的人，为小须田不理会自己的魅力而受到打击的山田发现其实小须田还有个青梅竹马的女生在偷偷暗恋着他，并擅长山田所薄弱的料理，一气之下山田为展现自己的魅力夺得了学年皇后的称号，然而另一个超级人气美少女出现了，并以夺取山田的一切为目标…… 制作人员： 原作：さんりようこ 导演：山本裕介 脚本：西园悟、与口奈津江","date":"2010-04-01","objectID":"/anime/b_gata_h_kei/:1:0","tags":null,"title":"B型H系","uri":"/anime/b_gata_h_kei/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 山田 山田、やまだ、Yamada 女 田村ゆかり 2 小须田崇 こすだ たかし 男 阿部敦 3 竹下美春 たけした みはる 女 堀江由衣 4 宫野茧 みやの まゆ 女 花澤香菜 5 金城京香 かねじょう きょうか 女 小林ゆう 6 三乡麻美 みさと まみ、Misato Mami 女 岩崎愛 7 片濑葵 かたせ あおい、Katase Aoi 女 橘田いずみ 8 山田千夏 やまだ ちか、Yamada Chika 女 下田麻美 ","date":"2010-04-01","objectID":"/anime/b_gata_h_kei/:2:0","tags":null,"title":"B型H系","uri":"/anime/b_gata_h_kei/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 B型H系 2010-04-01 12 樱花 ","date":"2010-04-01","objectID":"/anime/b_gata_h_kei/:3:0","tags":null,"title":"B型H系","uri":"/anime/b_gata_h_kei/"},{"categories":null,"content":"　　维京岛国的少年小嗝嗝（杰伊•巴鲁切尔 Jay Baruchel 配音）是部落统领伟大的斯托里克（杰拉德·巴特勒 Gerard Butler 配音）的儿子，他非常想像自己的父亲一样亲手屠龙——这些飞龙是岛上维京人放牧羊群的主要天敌——但他每次出现在部落屠龙的战斗中都只给大家徒增烦恼。在一次对抗飞龙的战斗中，希卡普偷偷用射龙器击伤了一只最神秘的“夜之怒龙”，并背着族人放生、豢养，甚至驯服了这只龙，还给它起名“无牙”。希卡普的神秘行径引起了一同训练屠龙技巧的女孩阿斯特丽德（亚美莉卡·费雷拉 America Ferrera 配音）的怀疑。阿斯特丽德发现了希卡普的秘密，却同时被身骑“无牙”御风而飞的美妙体验所震撼。格雷决定在屠龙成人礼上向远征归来的斯托里克和族人讲明真相，说服大家放弃屠龙，却偏偏弄巧成拙，害得“无牙”被俘，一场更大的灾难就在眼前。","date":"2010-03-26","objectID":"/anime/how_to_train_your_dragon/","tags":null,"title":"驯龙高手","uri":"/anime/how_to_train_your_dragon/"},{"categories":null,"content":"简介 维京岛国的少年小嗝嗝（杰伊•巴鲁切尔 Jay Baruchel 配音）是部落统领伟大的斯托里克（杰拉德·巴特勒 Gerard Butler 配音）的儿子，他非常想像自己的父亲一样亲手屠龙——这些飞龙是岛上维京人放牧羊群的主要天敌——但他每次出现在部落屠龙的战斗中都只给大家徒增烦恼。在一次对抗飞龙的战斗中，希卡普偷偷用射龙器击伤了一只最神秘的“夜之怒龙”，并背着族人放生、豢养，甚至驯服了这只龙，还给它起名“无牙”。希卡普的神秘行径引起了一同训练屠龙技巧的女孩阿斯特丽德（亚美莉卡·费雷拉 America Ferrera 配音）的怀疑。阿斯特丽德发现了希卡普的秘密，却同时被身骑“无牙”御风而飞","date":"2010-03-26","objectID":"/anime/how_to_train_your_dragon/:1:0","tags":null,"title":"驯龙高手","uri":"/anime/how_to_train_your_dragon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 没牙仔 没牙、无牙、Toothless 雄 2 Hiccup Horrendous Haddock III 男 3 Astrid Hofferson 女 4 Ack 男 ","date":"2010-03-26","objectID":"/anime/how_to_train_your_dragon/:2:0","tags":null,"title":"驯龙高手","uri":"/anime/how_to_train_your_dragon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 驯龙高手 2010-03-26 1 樱花 ","date":"2010-03-26","objectID":"/anime/how_to_train_your_dragon/:3:0","tags":null,"title":"驯龙高手","uri":"/anime/how_to_train_your_dragon/"},{"categories":null,"content":"MAD ","date":"2010-03-26","objectID":"/anime/how_to_train_your_dragon/:4:0","tags":null,"title":"驯龙高手","uri":"/anime/how_to_train_your_dragon/"},{"categories":null,"content":"中学二年级的花咲蕾，在搬家的卡车上梦见心之大树被沙漠使徒袭击、Cure Moonlight被击败的场面。从镰仓移居到祖母所在的希望之花市、转入私立明堂学园的蕾希望借着搬家的机会改变内向的自己，却总被我行我素而爱管闲事的同学——来海绘理香牵着鼻子走。在面对新环境而不知所措的蕾面前，曾在梦中看到过的心之大树的妖精，Chypre和Coffret出现了。与此同时沙漠使徒中的一人，蝎子丽娜追赶他们而来，并夺走了绘理香的心之花。为了拯救她，蕾决定变身为Pretty Cure。","date":"2010-02-07","objectID":"/anime/heart_catch_precure/","tags":null,"title":"Heart Catch 光之美少女!","uri":"/anime/heart_catch_precure/"},{"categories":null,"content":"简介 中学二年级的花咲蕾，在搬家的卡车上梦见心之大树被沙漠使徒袭击、Cure Moonlight被击败的场面。从镰仓移居到祖母所在的希望之花市、转入私立明堂学园的蕾希望借着搬家的机会改变内向的自己，却总被我行我素而爱管闲事的同学——来海绘理香牵着鼻子走。在面对新环境而不知所措的蕾面前，曾在梦中看到过的心之大树的妖精，Chypre和Coffret出现了。与此同时沙漠使徒中的一人，蝎子丽娜追赶他们而来，并夺走了绘理香的心之花。为了拯救她，蕾决定变身为Pretty Cure。 制作人员： 原作：东堂泉 导演：长峰达也 脚本：井上美绪、米村正二、成田良美、伊藤睦美、山田隆司 演出：地冈公俊、志水淳儿 ","date":"2010-02-07","objectID":"/anime/heart_catch_precure/:1:0","tags":null,"title":"Heart Catch 光之美少女!","uri":"/anime/heart_catch_precure/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 花咲蕾／花蕾天使 Cure Blossom、花咲 つぼみ、はなさき つぼみ、Hanasaki Tsubomi 女 水樹奈々 2 来海绘里香／海洋天使 Cure Marine、くるみ えりか、Kurumi Erika、马琳 女 水沢史絵 3 明堂院树／阳光天使 Cure Sunshine、明堂院 いつき、みょうどういん いつき、Myōdōin Itsuki 女 桑島法子 4 月影百合／月光天使 Cure Moonlight、月影 ゆり、つきかげ ゆり、Tsukikage Yuri 女 久川綾 5 花咲薰子 花咲 薫子、はなさき かおるこ、Hanasaki Ka","date":"2010-02-07","objectID":"/anime/heart_catch_precure/:2:0","tags":null,"title":"Heart Catch 光之美少女!","uri":"/anime/heart_catch_precure/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Heart Catch 光之美少女! 2010-02-07 49 爱奇艺 ","date":"2010-02-07","objectID":"/anime/heart_catch_precure/:3:0","tags":null,"title":"Heart Catch 光之美少女!","uri":"/anime/heart_catch_precure/"},{"categories":null,"content":"在地图上没有记载的无人岛・不承岛，岛上生活着不使用刀的剑术・虚刀流第七代当家鑢七花与其姐姐鑢七实。\n幼年时随父亲漂流到此岛上，生活至今已经20年了。\n在父亲去世后，本以为在这个世上已经没有人记得他们了。某日，一位自称咎的奇策士突然来到岛上拜访。\n她是为了收集传说中的锻刀师・四季崎记纪终其一生冶炼的十二套变刀体，而来求助于虚刀流的当家七花。\n但是，在他们的交谈中突然遭到了袭击！袭击者是真庭忍军十二头领中的真庭蝙蝠。七花愤怒地追着蝙蝠而去……。\n在世外桃源之地长大、对外界一无所知的剑士鑢七花的旅途开始了。在前方等待他的究竟会是地狱般的决战抑或是命悬一线的……恋爱泥潭！？","date":"2010-01-25","objectID":"/anime/katanagatari/","tags":null,"title":"刀语","uri":"/anime/katanagatari/"},{"categories":null,"content":"简介 在地图上没有记载的无人岛・不承岛，岛上生活着不使用刀的剑术・虚刀流第七代当家鑢七花与其姐姐鑢七实。 幼年时随父亲漂流到此岛上，生活至今已经20年了。 在父亲去世后，本以为在这个世上已经没有人记得他们了。某日，一位自称咎的奇策士突然来到岛上拜访。 她是为了收集传说中的锻刀师・四季崎记纪终其一生冶炼的十二套变刀体，而来求助于虚刀流的当家七花。 但是，在他们的交谈中突然遭到了袭击！袭击者是真庭忍军十二头领中的真庭蝙蝠。七花愤怒地追着蝙蝠而去……。 在世外桃源之地长大、对外界一无所知的剑士鑢七花的旅途开始了。在前方等待他的究竟会是地狱般的决战抑或是命悬一线的……恋爱泥潭！？ 制作人员： 原作：西","date":"2010-01-25","objectID":"/anime/katanagatari/:1:0","tags":null,"title":"刀语","uri":"/anime/katanagatari/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鑢七花 鑢七花、やすり しちか、Yasuri Shichika 男 くまいもとこ 2 咎儿 咎、容赦姬、容赦姫、ようしゃひめ、Togame、奇策士 女 田村ゆかり 3 鑢七实 鑢七実、やすり ななみ、Yasuri Nanami 女 中原麻衣 4 锖白兵 錆 白兵、さび はくへい、Sabi hakuhei 男 緑川光 5 宇练银阁 宇練 銀閣、うねり ぎんかく、Uneri ginkaku 男 宮本充 6 否定姬 ひていひめ、Hiteihime 女 戸松遥 7 左右田右卫门左卫门 左右田右衛門左衛門、そうだ えもんざえもん、Souda emonzaemon 男 ","date":"2010-01-25","objectID":"/anime/katanagatari/:2:0","tags":null,"title":"刀语","uri":"/anime/katanagatari/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 刀语 2010-01-25 12 bilibili MAD ","date":"2010-01-25","objectID":"/anime/katanagatari/:3:0","tags":null,"title":"刀语","uri":"/anime/katanagatari/"},{"categories":null,"content":"欢迎来到花丸幼稚园！这里是一群活泼可爱的孩子们每天生活的乐园。\n陷入恋爱的女孩子杏一直都喜欢着自己的班主任土田老师，为杏的恋爱加油的同伴有“万事通”之称的小柊与天真可爱的小梅。让人砰砰心跳的恋爱大作战，到幼稚园外面进行作战侦察……虽然有时也因为和其他孩子们吵架而被责备，但是要好的三人组正在一点一点成长。","date":"2010-01-10","objectID":"/anime/hanamaru_kindergarten/","tags":null,"title":"花丸幼稚园","uri":"/anime/hanamaru_kindergarten/"},{"categories":null,"content":"简介 欢迎来到花丸幼稚园！这里是一群活泼可爱的孩子们每天生活的乐园。 陷入恋爱的女孩子杏一直都喜欢着自己的班主任土田老师，为杏的恋爱加油的同伴有“万事通”之称的小柊与天真可爱的小梅。让人砰砰心跳的恋爱大作战，到幼稚园外面进行作战侦察……虽然有时也因为和其他孩子们吵架而被责备，但是要好的三人组正在一点一点成长。 制作人员： 原作：勇人 导演：水岛精二 脚本：小黑祐一郎、佐伯昭志 分镜：角田一树、名取孝浩、镰田佑辅、铃木薰（动画师） ","date":"2010-01-10","objectID":"/anime/hanamaru_kindergarten/:1:0","tags":null,"title":"花丸幼稚园","uri":"/anime/hanamaru_kindergarten/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 杏 杏、あんず、Anzu 女 真堂圭 2 山本菜菜子 山本先生、やまもと ななこ、Yamamoto-sensei、山本老师 女 葉月絵理乃 3 柊 柊、ひいらぎ、Hiiragi 女 高垣彩陽 4 小梅 こうめ、Koume 女 MAKO 5 土田直纯 つっち、小土、土田老师、つちだ なおずみ、阿土 男 日野聡 6 土田五月 さつき、つちだ さつき、Satsuki 女 廣田詩夢 7 川代先生 Kawashiro-sensei、川代先生 女 若林直美 8 山本真弓 山本 真弓、Yamamoto Mayumi 女 斎藤千和 ","date":"2010-01-10","objectID":"/anime/hanamaru_kindergarten/:2:0","tags":null,"title":"花丸幼稚园","uri":"/anime/hanamaru_kindergarten/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 花丸幼稚园 2010-01-10 12 bilibili ","date":"2010-01-10","objectID":"/anime/hanamaru_kindergarten/:3:0","tags":null,"title":"花丸幼稚园","uri":"/anime/hanamaru_kindergarten/"},{"categories":null,"content":"文月学园的学生的学习成绩一直十分低下，而在偶然的机会下，学园以科学和超自然能力为基础开发出了“考试召唤系统”，系统的应用在学园里掀起了一股新风潮。学园实行按成绩分班制，主人公·吉井明久自信满满地接受了考试，而迎接他的却是最差的班级·F班，这里的教室简直简陋得不像教室。为了改善现状，就要在以召唤兽来战斗的战争“试召战争”中获胜。一部新感觉战斗学园恋爱喜剧诞生了！","date":"2010-01-06","objectID":"/anime/baka_and_test/","tags":null,"title":"笨蛋，测验，召唤兽","uri":"/anime/baka_and_test/"},{"categories":null,"content":"简介 文月学园的学生的学习成绩一直十分低下，而在偶然的机会下，学园以科学和超自然能力为基础开发出了“考试召唤系统”，系统的应用在学园里掀起了一股新风潮。学园实行按成绩分班制，主人公·吉井明久自信满满地接受了考试，而迎接他的却是最差的班级·F班，这里的教室简直简陋得不像教室。为了改善现状，就要在以召唤兽来战斗的战争“试召战争”中获胜。一部新感觉战斗学园恋爱喜剧诞生了！ 制作人员： 原作：井上坚二 导演：大沼心 脚本：高山克彦 分镜：青木英、齐藤良成、细田直人、渡边慎一、岩畑刚一 ","date":"2010-01-06","objectID":"/anime/baka_and_test/:1:0","tags":null,"title":"笨蛋，测验，召唤兽","uri":"/anime/baka_and_test/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 吉井明久 吉井 明久、よしい あきひさ、Yoshii Akihisa 男 下野紘 2 姬路瑞希 姫路 瑞希、ひめじ みずき、Himeji Mizuki 女 原田ひとみ 3 岛田美波 島田 美波、しまだ みなみ、Shimada Minami、小美 女 水橋かおり 4 木下秀吉 木下 秀吉、きのした ひでよし、Kinoshita Hideyoshi 秀吉 加藤英美里 5 坂本雄二 坂本 雄二、さかもと ゆうじ、Sakamoto Yuuji 男 鈴木達央 6 土屋康太 つちや こうた、闷声色狼 男 宮田幸季 7 雾岛翔子 きりしま しょうこ 女 磯村知美 8 清水","date":"2010-01-06","objectID":"/anime/baka_and_test/:2:0","tags":null,"title":"笨蛋，测验，召唤兽","uri":"/anime/baka_and_test/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 笨蛋，测验，召唤兽 2010-01-06 13 bilibili 2 笨蛋，测验，召唤兽2 2011-07-07 13 bilibili ","date":"2010-01-06","objectID":"/anime/baka_and_test/:3:0","tags":null,"title":"笨蛋，测验，召唤兽","uri":"/anime/baka_and_test/"},{"categories":null,"content":"　　就读小学三年级的女孩「新子」居住在群山环绕着的防府市中，这里曾是平安时代的地方行政首府，喜欢发呆和幻想的她常会想着朋友、家人和想像着远在千年前平安时代的街道和过去人们的生活。\n　　新子认识了从东京来的转学生「贵伊子」，贵伊子和过去新子所认识的人都不一样，所以对她产生了浓厚的兴趣，两人也因此成为了好朋友。透过新子，贵伊子认识了更多的好伙伴，而众人就在游玩的时候在池子里发现了一只金鱼，并替金鱼取了和他们喜欢的老师一样的名字「ひづる」。\n　　在伙伴们都很喜欢的金鱼死去后，却听说有一只和它很相似的金鱼存在，当众人团结一心找寻传闻中的金鱼时，就发生了不可思议的事情。 ","date":"2009-11-21","objectID":"/anime/mai-mai_miracle/","tags":null,"title":"新子与千年魔法","uri":"/anime/mai-mai_miracle/"},{"categories":null,"content":"简介 就读小学三年级的女孩「新子」居住在群山环绕着的防府市中，这里曾是平安时代的地方行政首府，喜欢发呆和幻想的她常会想着朋友、家人和想像着远在千年前平安时代的街道和过去人们的生活。 新子认识了从东京来的转学生「贵伊子」，贵伊子和过去新子所认识的人都不一样，所以对她产生了浓厚的兴趣，两人也因此成为了好朋友。透过新子，贵伊子认识了更多的好伙伴，而众人就在游玩的时候在池子里发现了一只金鱼，并替金鱼取了和他们喜欢的老师一样的名字「ひづる」。 在伙伴们都很喜欢的金鱼死去后，却听说有一只和它很相似的金鱼存在，当众人团结一心找寻传闻中的金鱼时，就发生了不可思议的事情。 制作人员： 原作：高树信子 导演：片渊","date":"2009-11-21","objectID":"/anime/mai-mai_miracle/:1:0","tags":null,"title":"新子与千年魔法","uri":"/anime/mai-mai_miracle/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 青木新子 新子 女 福田麻由子 2 岛津贵伊子 贵伊子、しまづきいこ、Shimatsu Kiiko 女 水沢奈子 ","date":"2009-11-21","objectID":"/anime/mai-mai_miracle/:2:0","tags":null,"title":"新子与千年魔法","uri":"/anime/mai-mai_miracle/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 新子与千年魔法 2009-11-21 1 bilibili ","date":"2009-11-21","objectID":"/anime/mai-mai_miracle/:3:0","tags":null,"title":"新子与千年魔法","uri":"/anime/mai-mai_miracle/"},{"categories":null,"content":"　　突然遭遇失败的空中秋千运动员、有极度恐高证的小流氓、有妄想证且自我感觉过分良好的模特……像这些抱着各种烦恼的病人，不断地拜访伊良部综合医院。在这里担任心理治疗的是院长的儿子伊良部一郎，他的助手是拥有F-CUP的性感护士真由美。对待病人，伊良部向他们注射不明所以的药水，给他们提出同治疗两字贴不上边的建议，为此他们都感到很迷惑。那么究竟这些病人能否医好心病，重拾健康呢？","date":"2009-10-15","objectID":"/anime/kuuchuu_buranko/","tags":null,"title":"空中秋千","uri":"/anime/kuuchuu_buranko/"},{"categories":null,"content":"简介 突然遭遇失败的空中秋千运动员、有极度恐高证的小流氓、有妄想证且自我感觉过分良好的模特……像这些抱着各种烦恼的病人，不断地拜访伊良部综合医院。在这里担任心理治疗的是院长的儿子伊良部一郎，他的助手是拥有F-CUP的性感护士真由美。对待病人，伊良部向他们注射不明所以的药水，给他们提出同治疗两字贴不上边的建议，为此他们都感到很迷惑。那么究竟这些病人能否医好心病，重拾健康呢？ 制作人员： 导演：中村健治 脚本：石川学、村山功 分镜：羽多野浩平、角铜博之、植田秀仁、铃木清崇、地冈公俊 ","date":"2009-10-15","objectID":"/anime/kuuchuu_buranko/:1:0","tags":null,"title":"空中秋千","uri":"/anime/kuuchuu_buranko/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊良部一郎 いらぶ いちろう、Irabu Ichirou、伊良部一郎 男 三ツ矢雄二 2 田口哲也 たぐち てつや、Taguchi Tetsuya、田口哲也 男 櫻井孝宏 3 坂東真一 ばんどう しんいち、Bandou Shin`ichi、坂東真一 男 浪川大輔 4 津田雄太 つだ ゆうた、Tsuda Yuuta、津田雄太 男 入野自由 5 岩村義雄 いわむら よしお、Iwamura Yoshio、岩村義雄 男 岩田光央 6 津田英雄 つだ ひでお、Tsuda Hideo、津田英雄 男 古谷徹 7 福井っち ふくい、Fukui、福井っち 男 8 真由美 Ma","date":"2009-10-15","objectID":"/anime/kuuchuu_buranko/:2:0","tags":null,"title":"空中秋千","uri":"/anime/kuuchuu_buranko/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 空中秋千 2009-10-15 11 bilibili ","date":"2009-10-15","objectID":"/anime/kuuchuu_buranko/:3:0","tags":null,"title":"空中秋千","uri":"/anime/kuuchuu_buranko/"},{"categories":null,"content":"2009年是日本文学名将太宰治诞辰100周年，在这一年中，包括小林多喜二创作的《螃工船》在内，众多的日本文学名作被制作成电影。\n嗅觉敏感的集英社乘着这股追赶文学大潮的东风，及时发售了由旗下超人气漫画家重新绘制封面的文学名作，博得了极大好评。这些作品分别是由《死亡笔记》作者小畑健重新绘制封面的太宰治原作的《人间失格》；由《死神》作者久保带人重新绘制封面的坂口安吾原作的《盛开的樱花林下》；由《网球王子》作者许斐刚重新绘制封面的太宰治原作的《快跑！梅乐斯》，以及由小畑健重新绘制封面的夏目漱石原作的《心》，由久保带人重新绘制封面的芥川龙之介原作的《蜘蛛之丝》和《地狱变》。","date":"2009-10-10","objectID":"/anime/aoi_bungaku_series/","tags":null,"title":"青之文学","uri":"/anime/aoi_bungaku_series/"},{"categories":null,"content":"简介 2009年是日本文学名将太宰治诞辰100周年，在这一年中，包括小林多喜二创作的《螃工船》在内，众多的日本文学名作被制作成电影。 嗅觉敏感的集英社乘着这股追赶文学大潮的东风，及时发售了由旗下超人气漫画家重新绘制封面的文学名作，博得了极大好评。这些作品分别是由《死亡笔记》作者小畑健重新绘制封面的太宰治原作的《人间失格》；由《死神》作者久保带人重新绘制封面的坂口安吾原作的《盛开的樱花林下》；由《网球王子》作者许斐刚重新绘制封面的太宰治原作的《快跑！梅乐斯》，以及由小畑健重新绘制封面的夏目漱石原作的《心》，由久保带人重新绘制封面的芥川龙之介原作的《蜘蛛之丝》和《地狱变》。 制作人员： 原作：芥川","date":"2009-10-10","objectID":"/anime/aoi_bungaku_series/:1:0","tags":null,"title":"青之文学","uri":"/anime/aoi_bungaku_series/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 大庭叶藏 男 堺雅人 2 竹一 男 3 恒子 女 朴璐美 4 堀木 男 高木渉 5 ヒラメ 男 塚田正昭 6 志津子 女 久川綾 7 茂子 女 こたにともこ 8 彰子 女 水樹奈々 ","date":"2009-10-10","objectID":"/anime/aoi_bungaku_series/:2:0","tags":null,"title":"青之文学","uri":"/anime/aoi_bungaku_series/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 青之文学 2009-10-10 12 bilibili ","date":"2009-10-10","objectID":"/anime/aoi_bungaku_series/:3:0","tags":null,"title":"青之文学","uri":"/anime/aoi_bungaku_series/"},{"categories":null,"content":"故事围绕着一个外表看起来阴暗到会被周围人称为“贞子”的女高中生黑沼爽子展开，描述她通过努力逐渐消除周围人的误解，并得到友情与爱情的故事。有着浓黑长发，惨白皮肤的黑沼爽子的座右铭是“日行一善”，喜欢帮助他人，所以一直担任班级委员，由于小学时不小心得到了“贞子”这个绰号，导致周围人以为和她接触会受到诅咒而不敢与她交朋友。上高中后，在受到过自己帮助的同学风早的带动下，逐渐融合到班级中，被改称为“座敷童子”，认为“看到贞子笑的话会有好运”。爽朗王子与“贞子”女生的校园轻喜剧登场啦……","date":"2009-10-06","objectID":"/anime/kimi_ni_todoke/","tags":null,"title":"好想告诉你","uri":"/anime/kimi_ni_todoke/"},{"categories":null,"content":"简介 故事围绕着一个外表看起来阴暗到会被周围人称为“贞子”的女高中生黑沼爽子展开，描述她通过努力逐渐消除周围人的误解，并得到友情与爱情的故事。有着浓黑长发，惨白皮肤的黑沼爽子的座右铭是“日行一善”，喜欢帮助他人，所以一直担任班级委员，由于小学时不小心得到了“贞子”这个绰号，导致周围人以为和她接触会受到诅咒而不敢与她交朋友。上高中后，在受到过自己帮助的同学风早的带动下，逐渐融合到班级中，被改称为“座敷童子”，认为“看到贞子笑的话会有好运”。爽朗王子与“贞子”女生的校园轻喜剧登场啦…… 制作人员： 原作：椎名轻穗 导演：镝木宏 脚本：金春智子、池田真美子 分镜：矢野雄一郎、盐谷直义、长滨博史、小松","date":"2009-10-06","objectID":"/anime/kimi_ni_todoke/:1:0","tags":null,"title":"好想告诉你","uri":"/anime/kimi_ni_todoke/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 黒沼爽子 黒沼 爽子、くろぬま さわこ、Kuronuma Sawako、貞子、座敷童子 女 能登麻美子 2 风早翔太 風早 翔太、かぜはや しょうた、Kazehaya Shouta 男 浪川大輔 3 矢野绫音 矢野 あやね、やの あやね、Yano Ayane、やのちん、あやねちゃん 女 沢城みゆき 4 吉田千鹤 吉田 千鶴、よしだ ちづる、Yoshida Chizuru 女 三瓶由布子 5 真田龙 真田 龍、さなだ りゅう、Sanada Ryuu 男 中村悠一 6 胡桃泽梅 胡桃沢 梅、くるみざわ うめ、Kurumizawa Ume、くるみ 女 平野綾 7 ","date":"2009-10-06","objectID":"/anime/kimi_ni_todoke/:2:0","tags":null,"title":"好想告诉你","uri":"/anime/kimi_ni_todoke/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 好想告诉你 2009-10-06 25 bilibili 2 好想告诉你 第二季 2011-01-04 12 bilibili ","date":"2009-10-06","objectID":"/anime/kimi_ni_todoke/:3:0","tags":null,"title":"好想告诉你","uri":"/anime/kimi_ni_todoke/"},{"categories":null,"content":"MAD ","date":"2009-10-06","objectID":"/anime/kimi_ni_todoke/:4:0","tags":null,"title":"好想告诉你","uri":"/anime/kimi_ni_todoke/"},{"categories":null,"content":"被美丽的自然所包围的小镇，空美町。住在那里的樱井智树是一名将“和平第一”作为标语的普通学生。不过，自从某日从天空中掉下一位名为伊卡洛斯的女孩，他平静的日常生活开始脱轨了。自称“娱乐用万能天使”的她，将降落后见到的第一位人类，也就是智树称呼为“主人”，并有着能实现他一切愿望的不可思议的能力。入手一千亿现金，成为透明人，让时间停止，总之什么都可以！满足了一个健全男子的全部欲望的智树，最后的愿望是！？","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"简介 被美丽的自然所包围的小镇，空美町。住在那里的樱井智树是一名将“和平第一”作为标语的普通学生。不过，自从某日从天空中掉下一位名为伊卡洛斯的女孩，他平静的日常生活开始脱轨了。自称“娱乐用万能天使”的她，将降落后见到的第一位人类，也就是智树称呼为“主人”，并有着能实现他一切愿望的不可思议的能力。入手一千亿现金，成为透明人，让时间停止，总之什么都可以！满足了一个健全男子的全部欲望的智树，最后的愿望是！？ 制作人员： 原作：水无月嵩 导演：斋藤久 脚本：柿原优子 分镜：柳泽哲也、东海林真一、中村宪由、五十岚达也、古川顺康 ","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/:1:0","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 樱井智树 智神、桜井智樹、さくらい ともき、Sakurai tomoki、小智 男 保志総一朗 2 伊卡洛斯 Ikaros、イカロス、螺丝 女 早見沙織 3 妮姆芙 恁胡、Nymph、ニンフ 女 野水伊織 4 见月楚原 みつき そはら 女 美名 5 守形英四郎 守形英四郎、すがた えいしろう、Sugata Eishirou 男 鈴木達央 6 五月田根美香子 さつきたね みかこ、会长 女 高垣彩陽 7 圣光君 圣光、Holy Light 8 卡奥斯 Chaos、カオス 女 豊崎愛生 ","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/:2:0","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天降之物 2009-10-04 14 樱花 2 天降之物f 2010-10-01 12 樱花 3 天降之物 计时的悲伤女神 2011-06-25 1 樱花 4 天降之物Final 永远的我的鸟笼 2014-04-26 1 bilibili ","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/:3:0","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"MAD ","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/:4:0","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"故事发生在面积占据东京都的三分之一，居住着230万名人口且其中八成人口是学生的巨大都市“学园都市”。学园都市的所有学生均会接受超能力开发，借由药物、催眠术与通电刺激等方式取得超能力。能力者以范围和威力分为LV0至LV5。\n\n主角御坂美琴是学园都市中仅七位LV5（超能力者）的其中一人，排行第三。她是拥有操纵电击能力的“电击使”，站在电击能力的顶峰，因而被称为“超电磁炮”。\n\n本作不但通过美琴的视角来描绘学园都市的平常而不平凡的日常生活，也叙述了学园都市秘密进行非人道性质的实验，从而使大家对于本作及本篇《魔法禁书目录》的背景（世界观）的认识也慢慢变得清楚。","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"简介 故事发生在面积占据东京都的三分之一，居住着230万名人口且其中八成人口是学生的巨大都市“学园都市”。学园都市的所有学生均会接受超能力开发，借由药物、催眠术与通电刺激等方式取得超能力。能力者以范围和威力分为LV0至LV5。 主角御坂美琴是学园都市中仅七位LV5（超能力者）的其中一人，排行第三。她是拥有操纵电击能力的“电击使”，站在电击能力的顶峰，因而被称为“超电磁炮”。 本作不但通过美琴的视角来描绘学园都市的平常而不平凡的日常生活，也叙述了学园都市秘密进行非人道性质的实验，从而使大家对于本作及本篇《魔法禁书目录》的背景（世界观）的认识也慢慢变得清楚。 制作人员： 原作：镰池和马、冬川基 导","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/:1:0","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 御坂美琴 Mikoto Misaka、御坂美琴、みさかみこと、Misaka Mikoto、炮姐 / ビリビリ/Bilibili、超电磁炮/レールガン/Railgun 女 佐藤利奈 2 白井黑子 Teleport、白井 黒子、しらい くろこ、Shirai Kuroko、空间移动 女 新井里美 3 初春饰利 初春飾利、ういはる かざり、Uiharu Kazari 女 豊崎愛生 4 佐天泪子 佐天 涙子、さてん るいこ、Saten Ruiko 女 伊藤かな恵 5 上条当麻 上条当麻、かみじょとうま、Kamijou Touma、小上条，上条，当麻，大妈 男 阿部敦 ","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/:2:0","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 某科学的超电磁炮 2009-10-02 24 bilibili 2 某科学的超电磁炮 OVA 2010-10-29 1 bilibili 3 某科学的超电磁炮S 2013-04-12 24 bilibili 4 某科学的超电磁炮S OVA 2014-03-27 1 bilibili 5 某科学的超电磁炮T 2020-01-10 25 bilibili ","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/:3:0","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"MAD ","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/:4:0","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"在私立碧阳学园。学生会成员的选举，有一套特殊的制度。\n不举行一般的选举，只是单纯地用《人气投票》来选取学生会成员。\n因此，每年被选出的基本上是《可爱的女孩》。这是因为美男子会遭到男性学生的不满，而美少女对男女学生来说，都是喜欢的对象。\n可是，用人气和外表来确定这样重要的人选，这样合适吗？\n在发生了异议之后，妥协的结果是选取《优秀者》。在各年级学习成绩顶尖的学生，只要本人愿意，就有机会加入学生会。\n于是，有学生开始猛学，却没能得到进入学生会的机会……。\n但是，有一个男学生，坚持了自己的信念，终于打破了常规！\n杉崎鍵。他梦想着自己能进入《除了自己之外全是美少女的团体》，他以此为目标，开始猛学，于是终于在年末的考试中取得了第一名。\n他抵达的目标，是个性鲜明的、美少女云集的学生会。\nLOLI娘学生会会长・樱野真红。\n冰冷而理性的前辈・红叶知弦。\n少年风的傲娇・椎名深夏。\n可爱的梦幻妹妹・椎名真冬。\n最终，杉崎能过上理想的后宫生活么？","date":"2009-10-02","objectID":"/anime/seitokai_no_ichizon/","tags":null,"title":"学生会的一己之见","uri":"/anime/seitokai_no_ichizon/"},{"categories":null,"content":"简介 在私立碧阳学园。学生会成员的选举，有一套特殊的制度。 不举行一般的选举，只是单纯地用《人气投票》来选取学生会成员。 因此，每年被选出的基本上是《可爱的女孩》。这是因为美男子会遭到男性学生的不满，而美少女对男女学生来说，都是喜欢的对象。 可是，用人气和外表来确定这样重要的人选，这样合适吗？ 在发生了异议之后，妥协的结果是选取《优秀者》。在各年级学习成绩顶尖的学生，只要本人愿意，就有机会加入学生会。 于是，有学生开始猛学，却没能得到进入学生会的机会……。 但是，有一个男学生，坚持了自己的信念，终于打破了常规！ 杉崎鍵。他梦想着自己能进入《除了自己之外全是美少女的团体》，他以此为目标，开始猛学","date":"2009-10-02","objectID":"/anime/seitokai_no_ichizon/:1:0","tags":null,"title":"学生会的一己之见","uri":"/anime/seitokai_no_ichizon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 杉崎键 杉崎 鍵、すぎさき けん、Sugisaki Ken 男 近藤隆 2 樱野栗梦 さくらの くりむ、Sakurano Kurimu 女 本多真梨子 3 红叶知弦 紅葉知弦、あかば ちづる、Akaba Chizuru 女 斉藤佑圭 4 椎名深夏 しいな みなつ、Shiina Minatsu 女 富樫美鈴 5 椎名真冬 椎名真冬、しいな まふゆ、Shiina Mafuyu 女 堀中優希 6 藤堂莉莉西亚 藤堂リリシア、とうどう リリシア、Toudou Lilicia 女 能登麻美子 7 真仪琉纱鸟 真儀瑠紗鳥、Magiru Satori 女 小菅真美 8 中","date":"2009-10-02","objectID":"/anime/seitokai_no_ichizon/:2:0","tags":null,"title":"学生会的一己之见","uri":"/anime/seitokai_no_ichizon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 学生会的一己之见 2009-10-02 12 bilibili 2 学生会的一己之见 Lv.2 2013-01-09 10 bilibili ","date":"2009-10-02","objectID":"/anime/seitokai_no_ichizon/:3:0","tags":null,"title":"学生会的一己之见","uri":"/anime/seitokai_no_ichizon/"},{"categories":null,"content":"MAD ","date":"2009-10-02","objectID":"/anime/seitokai_no_ichizon/:4:0","tags":null,"title":"学生会的一己之见","uri":"/anime/seitokai_no_ichizon/"},{"categories":null,"content":"《eden*》是由日本游戏公司minori于2009年所推出的一款恋爱冒险游戏。\n该作品是一款以恋爱为题材，架设在虚幻未来为背景下的交互式小说。eden*是minori的第6部作品，\n也是在继取得成功的《ef -a fairy tale of the two》（悠久之翼）之后的作品。","date":"2009-09-18","objectID":"/game/eden/","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"简介 《eden*》是由日本游戏公司minori于2009年所推出的一款恋爱冒险游戏。 该作品是一款以恋爱为题材，架设在虚幻未来为背景下的交互式小说。eden*是minori的第6部作品， 也是在继取得成功的《ef -a fairy tale of the two》（悠久之翼）之后的作品。 制作人员： 开发：minori 剧本：镜游 美工：结城辰也 音乐：柳英一郎、天门 主题歌作词：酒井伸和 主题歌演出：原田瞳 原画：ちこたむ ","date":"2009-09-18","objectID":"/game/eden/:1:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 榛名亮 はるな りょう 男 間島淳司 2 诗音 紫苑、Sion 女 志村由美 3 艾莉卡 Erica 女 中島裕美子 4 稻叶直人 いなば なおと 男 遠近孝一 5 浅井·F·拉维尼娅 あさい・えふ・らう゛ぃにあ、Asai･F･Lavinia 女 中村繪里子 6 塔野真夜 とうの まや 後藤麻衣 7 夏目 枣 岡田純子 ","date":"2009-09-18","objectID":"/game/eden/:2:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"系列 系列名 发行时间 1 伊甸园 2009-09-18 ","date":"2009-09-18","objectID":"/game/eden/:3:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"配乐 ","date":"2009-09-18","objectID":"/game/eden/:4:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"MAD ","date":"2009-09-18","objectID":"/game/eden/:5:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"　在一个人心越来越冷漠的架空未来世界里，每个人都一边怀念着过去温暖的人心，一边扔弃着自己温暖的心。城市在过去分为很多块，不同的城市里的人们所拥有最多的品德特质也不同，但是在架空的未来世界里，所有的城市都越来越相近，人们都像一块冰冷的钢铁。因为莫莫的到来，人们才渐渐找回了被层层面具所掩盖的自我。","date":"2009-09-01","objectID":"/anime/mo_mo/","tags":null,"title":"莫莫","uri":"/anime/mo_mo/"},{"categories":null,"content":"简介 在一个人心越来越冷漠的架空未来世界里，每个人都一边怀念着过去温暖的人心，一边扔弃着自己温暖的心。城市在过去分为很多块，不同的城市里的人们所拥有最多的品德特质也不同，但是在架空的未来世界里，所有的城市都越来越相近，人们都像一块冰冷的钢铁。因为莫莫的到来，人们才渐渐找回了被层层面具所掩盖的自我。 制作人员： 动画制作：视美动画、重庆漫想族文化传播有限公司 ","date":"2009-09-01","objectID":"/anime/mo_mo/:1:0","tags":null,"title":"莫莫","uri":"/anime/mo_mo/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小原 女 山新 2 莫莫 3 阿其 ","date":"2009-09-01","objectID":"/anime/mo_mo/:2:0","tags":null,"title":"莫莫","uri":"/anime/mo_mo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 莫莫 2009-09-01 52 bilibili ","date":"2009-09-01","objectID":"/anime/mo_mo/:3:0","tags":null,"title":"莫莫","uri":"/anime/mo_mo/"},{"categories":null,"content":"高二的暑假，性格懦弱的天才数学少年小矶健二答应为憧憬的前辈夏希打工。于是，两人来到夏希的长野老家。没想到夏希的老家是一个有着27人的大家族。夏希的曾祖母荣则是从室町时代起就延续下来的战国一家·阵内家的大当家，也是这一族的一家之主。全家人为了2010年8月1日荣的90岁生日从全国各地赶来祝寿。这个时候，夏希突然拜托健二假装成她的未婚夫……于是，在荣的强留下，健二不得不在乡下多住几天。面对夏希亲戚的盛情款待，健二拼命扮演着未婚夫的角色倍感压力。然后一天夜里，他突然收到一封有着神秘数字的短信。擅长数学的健二立刻对这些数字沉迷起来并想方法解读……第二天，世界发生了天翻地覆的变化。欺骗了健二的神秘人物将世界陷入了混乱……“一切都由我们一族一力承担！”在荣的号令下，健二、夏希还有阵内家的人们团结起来一致对抗世界危机……","date":"2009-08-01","objectID":"/anime/summer_wars/","tags":null,"title":"夏日大作战","uri":"/anime/summer_wars/"},{"categories":null,"content":"简介 高二的暑假，性格懦弱的天才数学少年小矶健二答应为憧憬的前辈夏希打工。于是，两人来到夏希的长野老家。没想到夏希的老家是一个有着27人的大家族。夏希的曾祖母荣则是从室町时代起就延续下来的战国一家·阵内家的大当家，也是这一族的一家之主。全家人为了2010年8月1日荣的90岁生日从全国各地赶来祝寿。这个时候，夏希突然拜托健二假装成她的未婚夫……于是，在荣的强留下，健二不得不在乡下多住几天。面对夏希亲戚的盛情款待，健二拼命扮演着未婚夫的角色倍感压力。然后一天夜里，他突然收到一封有着神秘数字的短信。擅长数学的健二立刻对这些数字沉迷起来并想方法解读……第二天，世界发生了天翻地覆的变化。欺骗了健二的神秘","date":"2009-08-01","objectID":"/anime/summer_wars/:1:0","tags":null,"title":"夏日大作战","uri":"/anime/summer_wars/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小矶健二 小磯 健二、こいそ けんじ、Koiso Kenji 男 神木隆之介 2 筱原夏希 篠原 夏希、しのはら なつき、Shinohara Natsuki 女 桜庭ななみ 3 池泽佳主马 池沢 佳主馬、いけざわ かずま、Ikezawa Kazuma 男 谷村美月 4 阵内荣 陣内 栄、じんのうち さかえ、Jinnouchi Sakae 女 富司純子 5 阵内侘助 陣内 侘助、じんのうち わびすけ、Jinnouchi Wabisuke 男 6 佐久间敬 佐久間 敬、さくま たかし、Sakuma Takashi 男 横川貴大 7 筱原雪子 篠原 雪子、しのはら","date":"2009-08-01","objectID":"/anime/summer_wars/:2:0","tags":null,"title":"夏日大作战","uri":"/anime/summer_wars/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 夏日大作战 2009-08-01 01:54:00 bilibili ","date":"2009-08-01","objectID":"/anime/summer_wars/:3:0","tags":null,"title":"夏日大作战","uri":"/anime/summer_wars/"},{"categories":null,"content":"所谓怪异——是因为世界上没有那种东西的存在。\n与生物有所不同——但与世界紧紧相连。\n故事主人公阿良良木历，因为知道了同班同学战场原的某个“秘密”，从此被卷入一连串的怪异事件中……。","date":"2009-07-03","objectID":"/anime/bakemonogatari/","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"简介 所谓怪异——是因为世界上没有那种东西的存在。 与生物有所不同——但与世界紧紧相连。 故事主人公阿良良木历，因为知道了同班同学战场原的某个“秘密”，从此被卷入一连串的怪异事件中……。 制作人员： 原作：西尾维新 导演：新房昭之 脚本：中本宗应、木泽行人 分镜：福田道生、铃木利正、杉山延宽、尾石达也 ","date":"2009-07-03","objectID":"/anime/bakemonogatari/:1:0","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿良良木历 あららぎ　こよみ、Araragi Koyomi、こよこよ、こよみん 男 神谷浩史 2 战场原黑仪 战场原绯多木、ツンデレちゃん、战场原荡漾、雅原小姐、がはらさん、战场原直木、せんじょうがはら ひたぎ、Senjougahara Hitagi 女 斎藤千和 3 八九寺真宵 はちくじ まよい、Hachikuji Mayoi 女 加藤英美里 4 神原骏河 かんばる するが、Kanbaru Suruga、臥煙駿河 女 沢城みゆき 5 千石抚子 千石 撫子、せんごく なでこ、Sengoku Nadeko 女 花澤香菜 6 羽川翼 羽川 翼、はねかわ つばさ、","date":"2009-07-03","objectID":"/anime/bakemonogatari/:2:0","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 化物语 2009-07-03 15 acfun 2 伪物语 2012-01-07 11 acfun 3 猫物语（黑） 2012-12-31 4 acfun 4 物语系列 第二季 2013-07-06 26 acfun 5 花物语 2014-08-16 5 acfun 6 凭物语 2014-12-31 4 acfun 7 终物语 2015-10-03 13 bilibili 8 历物语 2016-01-09 12 bilibili 9 终物语（下） 2017-08-12 7 bilibili 10 续·终物语 2018-11-10 6 bilib","date":"2009-07-03","objectID":"/anime/bakemonogatari/:3:0","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"MAD ","date":"2009-07-03","objectID":"/anime/bakemonogatari/:4:0","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"舞台在日本伊豆群岛中，一个名为六轩岛的小岛上。这个长度只有10公里的小岛，是大富豪右代宫家的私有领地。 \n1986年10月4日～5日，由于召开一年一度的家庭会议，右代宫全族成员都集中在岛上。由于家族首脑，右代宫金藏已病入膏肓，他的子孙们都妄图在遗产分割中独占岛的所有权。除了岛屿之外，右代宫金藏还将10吨黄金藏在了岛上的某处。原本为分割遗产而举行的家族会议，却因为台风的缘故而将聚集而来的18个人完全困在了岛上，电话无法接通、船只也无法起锚，岛屿成了一个彻底封闭的空间。而与此同时，在岛上又发生了神秘的连续杀人事件！ \n为了这些财宝而勾心斗角的人们，突然收到到了来自“魔女”的可疑信件，原本应该只有18个人的岛上，竟然还存在着第19个人？不断出现的残酷杀人事件，留在现场的无法解开的谜团。接下来究竟谁会死去，谁能活下来，或是所有人都会被杀？犯人就在这18人中间么，还是那个神秘的“魔女”？","date":"2009-07-01","objectID":"/anime/umineko/","tags":null,"title":"海猫鸣泣之时","uri":"/anime/umineko/"},{"categories":null,"content":"简介 舞台在日本伊豆群岛中，一个名为六轩岛的小岛上。这个长度只有10公里的小岛，是大富豪右代宫家的私有领地。 1986年10月4日～5日，由于召开一年一度的家庭会议，右代宫全族成员都集中在岛上。由于家族首脑，右代宫金藏已病入膏肓，他的子孙们都妄图在遗产分割中独占岛的所有权。除了岛屿之外，右代宫金藏还将10吨黄金藏在了岛上的某处。原本为分割遗产而举行的家族会议，却因为台风的缘故而将聚集而来的18个人完全困在了岛上，电话无法接通、船只也无法起锚，岛屿成了一个彻底封闭的空间。而与此同时，在岛上又发生了神秘的连续杀人事件！ 为了这些财宝而勾心斗角的人们，突然收到到了来自“魔女”的可疑信件，原本应该只有","date":"2009-07-01","objectID":"/anime/umineko/:1:0","tags":null,"title":"海猫鸣泣之时","uri":"/anime/umineko/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 右代宫战人 无能、右代宮 戦人、うしろみや ばとら、Ushiromiya Battler 男 小野大輔 2 贝阿朵莉切 Beatrice、贝熊 女（？） 大原さやか 3 右代宫朱志香 うしろみや じぇしか、Ushiromiya Jessica 女 井上麻里奈 4 右代宫让治 右代宮 譲治、うしろみや じょうじ、Ushiromiya George 男 鈴村健一 5 右代宫真理亚 右代宮 真里亞、うしろみや まりあ、Ushiromiya Maria 女 堀江由衣 6 右代宫金蔵 右代宮 金蔵、うしろみや きんぞう、Ushiromiya Kinzou 男 麦人 7","date":"2009-07-01","objectID":"/anime/umineko/:2:0","tags":null,"title":"海猫鸣泣之时","uri":"/anime/umineko/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海猫鸣泣之时 2009-07-01 26 樱花 ","date":"2009-07-01","objectID":"/anime/umineko/:3:0","tags":null,"title":"海猫鸣泣之时","uri":"/anime/umineko/"},{"categories":null,"content":"MAD ","date":"2009-07-01","objectID":"/anime/umineko/:4:0","tags":null,"title":"海猫鸣泣之时","uri":"/anime/umineko/"},{"categories":null,"content":"万城目富美在入学典礼的那一天，与分别10年、就读于另一所女校的青梅竹马奥平明相遇了。活泼爽朗的明与打扮朴素的爱哭鬼富美，两名女生不久就回忆起儿时的情谊。酷酷的篮球部部长、校内的大好人杉本恭己；明的同学、总给人一种成熟感的井汲京子。两所女校的四个女生，从此展开似恋非恋、复杂细腻的青春故事……。\n“如果我喜欢的人是女生你会怎么办？”","date":"2009-07-01","objectID":"/anime/aoi_hana/","tags":null,"title":"青之花","uri":"/anime/aoi_hana/"},{"categories":null,"content":"简介 万城目富美在入学典礼的那一天，与分别10年、就读于另一所女校的青梅竹马奥平明相遇了。活泼爽朗的明与打扮朴素的爱哭鬼富美，两名女生不久就回忆起儿时的情谊。酷酷的篮球部部长、校内的大好人杉本恭己；明的同学、总给人一种成熟感的井汲京子。两所女校的四个女生，从此展开似恋非恋、复杂细腻的青春故事……。 “如果我喜欢的人是女生你会怎么办？” 制作人员： 原作：志村贵子 导演：笠井贤一 脚本：高山文彦、绫奈由仁子、水上清资 分镜：几原邦彦、樱美胜志、铃木洋平 ","date":"2009-07-01","objectID":"/anime/aoi_hana/:1:0","tags":null,"title":"青之花","uri":"/anime/aoi_hana/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 万城目富美 まんじょうめ ふみ、Manjoume Fumi 女 高部あい 2 奥平明 奥平晶、おくだいら あきら、Okudaira Akira 女 儀武ゆう子 3 杉本恭己 杉本 恭己、すぎもと やすこ、Sugimoto Yasuko 女 石松千恵美 4 井汲京子 井汲 京子、いくみ きょうこ、Ikumi Kyouko 女 堀江由衣 5 本厚木洋子 本厚木 洋子、ほんあつぎ ようこ 女 矢作紗友里 6 安田美沙子 やすだ みさこ、Yasuda Misako 女 井口裕香 7 茂木美和 もてぎ みわ、Motegi Miwa 女 豊崎愛生 8 川崎文子 川崎 文","date":"2009-07-01","objectID":"/anime/aoi_hana/:2:0","tags":null,"title":"青之花","uri":"/anime/aoi_hana/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 青之花 2009-07-01 11 bilibili ","date":"2009-07-01","objectID":"/anime/aoi_hana/:3:0","tags":null,"title":"青之花","uri":"/anime/aoi_hana/"},{"categories":null,"content":"故事叙述父子三鼠住在河边过着平静的生活，原以为能在河畔眺望河光度过一生，死后化成雨、汇成小流，与喜爱的河川永远融合一体。不料，东京都建设局打算兴建工程将河川铺成暗渠，它们只能离开家园，展开漫长惊险的旅程。","date":"2009-06-20","objectID":"/anime/kawa_no_hikari/","tags":null,"title":"川之光","uri":"/anime/kawa_no_hikari/"},{"categories":null,"content":"简介 故事叙述父子三鼠住在河边过着平静的生活，原以为能在河畔眺望河光度过一生，死后化成雨、汇成小流，与喜爱的河川永远融合一体。不料，东京都建设局打算兴建工程将河川铺成暗渠，它们只能离开家园，展开漫长惊险的旅程。 制作人员： 原作：松浦寿辉 导演：平川哲生 脚本：吉冈孝夫 音乐：栗原正己 人物设定：丹内司 美术监督：山本二三 作画监督：小林一幸 ","date":"2009-06-20","objectID":"/anime/kawa_no_hikari/:1:0","tags":null,"title":"川之光","uri":"/anime/kawa_no_hikari/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 川之光 2009-06-20 1 bilibili ","date":"2009-06-20","objectID":"/anime/kawa_no_hikari/:2:0","tags":null,"title":"川之光","uri":"/anime/kawa_no_hikari/"},{"categories":null,"content":"小男孩卡尔（Carl Fredricksen）怀揣着对于冒险的热爱偶遇假小子艾丽（Ellie），而艾丽把整个屋子当成一艘大飞船游戏居然使他对这个女孩子有些着迷，相同的爱好最终使两个人成为了一生的爱侣。\n\n他们有一个梦想，那就是有朝一日要去南美洲的“仙境瀑布”探险，但直到艾丽去世，这个梦想也未能实现。终于有一天，曾经专卖气球的老人卡尔居然用五颜六色的气球拽着他的房子飞上了天空，他决定要去实现他们未曾实现的梦想。令卡尔始料不及的是，门廊居然搭上了一个自称是“荒野开拓者”的小男孩小罗（Russell），小罗的喋喋不休让卡尔对这个小胖墩格外讨厌。\n\n一老一少在飞行中经过了千难万险终于看到了传说中的“仙境瀑布”，在相处过程中卡尔发现小罗其实是个惹人怜爱的孩子。在步行穿越一座森林时，他们遇到了不会飞的大鸟凯文（Kevin）和一只会说话的狗狗逗逗（Dug），让老人惊讶的是他们还遇到了他少年的崇拜偶像——探险家查尔斯·蒙兹（Charles Muntz），而且他发现蒙兹居然是一个为达目的不择手段的坏人。这时，老人离自己的梦想之地只有一步之遥……\n\n本片荣获第82届奥斯卡最佳动画长片、最佳配乐2项大奖。\n\n简介来自 豆瓣（https://movie.douban.com/subject/2129039/）。","date":"2009-05-29","objectID":"/anime/up/","tags":null,"title":"飞屋环游记","uri":"/anime/up/"},{"categories":null,"content":"简介 小男孩卡尔（Carl Fredricksen）怀揣着对于冒险的热爱偶遇假小子艾丽（Ellie），而艾丽把整个屋子当成一艘大飞船游戏居然使他对这个女孩子有些着迷，相同的爱好最终使两个人成为了一生的爱侣。 他们有一个梦想，那就是有朝一日要去南美洲的“仙境瀑布”探险，但直到艾丽去世，这个梦想也未能实现。终于有一天，曾经专卖气球的老人卡尔居然用五颜六色的气球拽着他的房子飞上了天空，他决定要去实现他们未曾实现的梦想。令卡尔始料不及的是，门廊居然搭上了一个自称是“荒野开拓者”的小男孩小罗（Russell），小罗的喋喋不休让卡尔对这个小胖墩格外讨厌。 一老一少在飞行中经过了千难万险终于看到了传说中的“","date":"2009-05-29","objectID":"/anime/up/:1:0","tags":null,"title":"飞屋环游记","uri":"/anime/up/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 飞屋环游记 2009-05-29 1 樱花 ","date":"2009-05-29","objectID":"/anime/up/:2:0","tags":null,"title":"飞屋环游记","uri":"/anime/up/"},{"categories":null,"content":"2010年11月22日（星期一）\n日本各地被投下了10枚导弹，然而却出现了没有一人牺牲的局面，人们称此次事件为“愚蠢的星期一”，并很快地被人们所淡忘。\n事件过后3个月\n前往美国进行毕业旅行的森美咲，在白宫前被卷入冲突事件，被一个日本人救下。那人名叫泷泽朗，他失去记忆，一丝不挂，手里握着手枪和被冲入82亿日元的电子货币的手机……。\n泷泽朗是什么人？谜一般的手机的实体是什么？泷泽朗失去的记忆又是什么？\n","date":"2009-04-09","objectID":"/anime/eden_of_the_east/","tags":null,"title":"东之伊甸","uri":"/anime/eden_of_the_east/"},{"categories":null,"content":"简介 2010年11月22日（星期一） 日本各地被投下了10枚导弹，然而却出现了没有一人牺牲的局面，人们称此次事件为“愚蠢的星期一”，并很快地被人们所淡忘。 事件过后3个月 前往美国进行毕业旅行的森美咲，在白宫前被卷入冲突事件，被一个日本人救下。那人名叫泷泽朗，他失去记忆，一丝不挂，手里握着手枪和被冲入82亿日元的电子货币的手机……。 泷泽朗是什么人？谜一般的手机的实体是什么？泷泽朗失去的记忆又是什么？ 制作人员： 原作：神山健治 脚本：冈田俊平、佐藤大、菅正太郎、伊藤千寻、福岛直浩 分镜：柿本广大 ","date":"2009-04-09","objectID":"/anime/eden_of_the_east/:1:0","tags":null,"title":"东之伊甸","uri":"/anime/eden_of_the_east/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 泷泽朗 滝沢 朗、たきざわ あきら、Takizawa Akira 男 木村良平 2 森美咲 森美 咲、もりみ さき、Morimi Saki 女 早見沙織 3 大杉智 大杉 智、おおすぎ さとし、Oosugi Satoshi 男 江口拓也 4 平泽一臣 平澤一臣、ひらさわ かずおみ、Hirasawa Kazuomi 男 川原元幸 5 葛原未来 葛原 みくる、かつはら みくる、Katsuhara Mikuru、みっちょん 女 齋藤彩夏 6 阿姐 おネエ、Onee 女 斉藤貴美子 7 春日晴男 春日 晴男、かすが はるお、Kasuga Haruo 田谷隼 8 森美","date":"2009-04-09","objectID":"/anime/eden_of_the_east/:2:0","tags":null,"title":"东之伊甸","uri":"/anime/eden_of_the_east/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 东之伊甸 2009-04-09 11 bilibili ","date":"2009-04-09","objectID":"/anime/eden_of_the_east/:3:0","tags":null,"title":"东之伊甸","uri":"/anime/eden_of_the_east/"},{"categories":null,"content":"1976年，9岁的玛丽·黛西·丁格尔是澳大利亚墨尔本的一个小女孩，喜欢动画片“诺布利特”、甜炼乳和巧克力。玛丽的妈妈是个酒鬼，而在茶叶包装厂工作的父亲平日只喜欢制作鸟标本。孤独的玛丽没有朋友，某一天心血来潮给美国纽约市的马克思·杰瑞·霍罗威茨写了一封信询问美国小孩从哪里来，并附上一根樱桃巧克力棒。44岁的马克思患有自闭症及肥胖，碰巧也喜欢看“诺布利特”动画片及吃巧克力。二人的笔友关系从1976年维持到1994年，期间各自经历了许多人生起伏，直到成年的玛丽终于来到纽约看望马克思……","date":"2009-04-09","objectID":"/anime/mary_and_max/","tags":null,"title":"玛丽和马克思","uri":"/anime/mary_and_max/"},{"categories":null,"content":"简介 1976年，9岁的玛丽·黛西·丁格尔是澳大利亚墨尔本的一个小女孩，喜欢动画片“诺布利特”、甜炼乳和巧克力。玛丽的妈妈是个酒鬼，而在茶叶包装厂工作的父亲平日只喜欢制作鸟标本。孤独的玛丽没有朋友，某一天心血来潮给美国纽约市的马克思·杰瑞·霍罗威茨写了一封信询问美国小孩从哪里来，并附上一根樱桃巧克力棒。44岁的马克思患有自闭症及肥胖，碰巧也喜欢看“诺布利特”动画片及吃巧克力。二人的笔友关系从1976年维持到1994年，期间各自经历了许多人生起伏，直到成年的玛丽终于来到纽约看望马克思…… 制作人员： 导演：亚当·艾略特 ","date":"2009-04-09","objectID":"/anime/mary_and_max/:1:0","tags":null,"title":"玛丽和马克思","uri":"/anime/mary_and_max/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 玛丽和马克思 2009-04-09 1 樱花 ","date":"2009-04-09","objectID":"/anime/mary_and_max/:2:0","tags":null,"title":"玛丽和马克思","uri":"/anime/mary_and_max/"},{"categories":null,"content":"天才麻将少女宫永咲虽然还是一位刚升入高中一年级的学生，但是便能以正负0分的方式打完牌局从而创下赫赫威名。故事二号女主角原村和则是在全国中学生麻将大赛个人组中夺得冠军的少女，两人因缘而聚到了麻将部，并以高中校际比赛的顶点为目标展开一番自摸放炮的故事。","date":"2009-04-05","objectID":"/anime/saki/","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"简介 天才麻将少女宫永咲虽然还是一位刚升入高中一年级的学生，但是便能以正负0分的方式打完牌局从而创下赫赫威名。故事二号女主角原村和则是在全国中学生麻将大赛个人组中夺得冠军的少女，两人因缘而聚到了麻将部，并以高中校际比赛的顶点为目标展开一番自摸放炮的故事。 制作人员： 原作：小林立 导演：小野学 脚本：浦畑达彦 分镜：木村宽、濑藤健嗣、山本珠代、小泷礼、熊泽佑嗣 ","date":"2009-04-05","objectID":"/anime/saki/:1:0","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫永咲 宮永咲、みやなが さき、Miyanaga Saki、魔王，大魔王，清澄的岭上开花使者 女 植田佳奈 2 原村和 原村和、はらむら のどか、Haramura Nodoka、小和和，乳和，奶和，奶奶香 女 小清水亜美 3 片冈优希 Taco、かたおか ゆうき、Kataoka Yuuki、卷饼 女 釘宮理恵 4 竹井久 竹井久 / 上埜久、たけい ひさ / うえの ひさ、Takei Hisa / Ueno Hisa、久帝、渣久 女 伊藤静 5 染谷真子 そめや まこ、Someya Mako 女 白石涼子 6 须贺京太郎 須賀 京太郎、すが　きょうたろう、S","date":"2009-04-05","objectID":"/anime/saki/:2:0","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天才麻将少女 2009-04-05 25 樱花 2 天才麻将少女 阿知贺篇 2012-04-08 16 樱花 3 天才麻将少女 全国篇 2014-01-05 13 樱花 4 咲日和 OAD 2015-07-25 1 bilibili ","date":"2009-04-05","objectID":"/anime/saki/:3:0","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"MAD ","date":"2009-04-05","objectID":"/anime/saki/:4:0","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"春天，在新生决定社团的时候，田井中律硬拉着青梅竹马的秋山澪参观轻音部让其入部，在得知前辈们毕业后由于人数不足将面临闭部结局，秋山澪与琴吹紬成为了轻音部成员，但离4人指标还差1位名额。这时，一名弄错了部名的少女平泽唯误打误撞之下填补了最后一位空位，但这位少女却是一个连乐谱也看不懂的新人，学习成绩又差。而就是这样的4名少女，却展开了奏响青春的音乐之旅。","date":"2009-04-02","objectID":"/anime/k-on/","tags":null,"title":"轻音少女","uri":"/anime/k-on/"},{"categories":null,"content":"简介 春天，在新生决定社团的时候，田井中律硬拉着青梅竹马的秋山澪参观轻音部让其入部，在得知前辈们毕业后由于人数不足将面临闭部结局，秋山澪与琴吹紬成为了轻音部成员，但离4人指标还差1位名额。这时，一名弄错了部名的少女平泽唯误打误撞之下填补了最后一位空位，但这位少女却是一个连乐谱也看不懂的新人，学习成绩又差。而就是这样的4名少女，却展开了奏响青春的音乐之旅。 制作人员： 原作：かきふらい、芳文社 导演：山田尚子 脚本：吉田玲子、村元克彦、花田十辉 分镜：石原立也、坂本一也、石立太一 ","date":"2009-04-02","objectID":"/anime/k-on/:1:0","tags":null,"title":"轻音少女","uri":"/anime/k-on/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 平泽唯 Yui Hirasawa、平沢 唯、ひらさわゆい、Hirasawa Yui、呆唯 女 豊崎愛生 2 秋山澪 Mio Akiyama、秋山 澪、あきやまみお、Akiyama Mio、Mio 女 日笠陽子 3 田井中律 たいなか りつ、Tainaka Ritsu、律队 女 佐藤聡美 4 琴吹紬 ことぶき つむぎ、Kotobuki Tsumugi 女 寿美菜子 5 中野梓 梓喵、阿梓喵、なかのあずさ、Nakano Azusa、あずにゃん 女 竹達彩奈 6 山中佐和子 やまなか さわこ、Yamanaka Sawako 女 真田アサミ 7 平泽忧 平沢憂、ひら","date":"2009-04-02","objectID":"/anime/k-on/:2:0","tags":null,"title":"轻音少女","uri":"/anime/k-on/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 轻音少女 2009-04-02 14 bilibili 2 轻音少女 第二季 2010-04-06 27 bilibili 3 轻音少女 剧场版 2011-12-03 1 bilibili ","date":"2009-04-02","objectID":"/anime/k-on/:3:0","tags":null,"title":"轻音少女","uri":"/anime/k-on/"},{"categories":null,"content":"小女孩卡洛琳搬进新居后，破旧而又死气沉沉的环境让她感觉无聊透顶。无趣古板的父母，怪异的邻居，还有一个讨厌的小男孩和他的小黑猫，这样的生活对于满脑子都是奇思妙想的她来说，简直要了命。 不过事情并不是一直都那么糟，一个夜晚，她居然在家里的第13个门后面，发现一条秘密通道，喜欢刺激冒险的卡洛琳当然不会放弃一探究竟的机会，于是她顺着那条通道慢慢的爬了过去。卡洛琳发现通道另一边是一个和现实完全相同但又不同的世界，一切现在都似乎在这里得到了复制，但是自己那些梦想却又在这里得到了实现。而最让卡洛琳高兴的是，这个世界里的妈妈对自己和善可亲、百依百顺。可是后来，她发现了这位“鬼妈妈”准备给自己换上眼睛，并把自己永远留在这个“奇妙”的世界。卡洛琳发现自己大祸临头了，她必须想办法逃出“鬼妈妈”的魔掌。","date":"2009-02-06","objectID":"/anime/coraline/","tags":null,"title":"鬼妈妈","uri":"/anime/coraline/"},{"categories":null,"content":"简介 小女孩卡洛琳搬进新居后，破旧而又死气沉沉的环境让她感觉无聊透顶。无趣古板的父母，怪异的邻居，还有一个讨厌的小男孩和他的小黑猫，这样的生活对于满脑子都是奇思妙想的她来说，简直要了命。 不过事情并不是一直都那么糟，一个夜晚，她居然在家里的第13个门后面，发现一条秘密通道，喜欢刺激冒险的卡洛琳当然不会放弃一探究竟的机会，于是她顺着那条通道慢慢的爬了过去。卡洛琳发现通道另一边是一个和现实完全相同但又不同的世界，一切现在都似乎在这里得到了复制，但是自己那些梦想却又在这里得到了实现。而最让卡洛琳高兴的是，这个世界里的妈妈对自己和善可亲、百依百顺。可是后来，她发现了这位“鬼妈妈”准备给自己换上眼睛，并","date":"2009-02-06","objectID":"/anime/coraline/:1:0","tags":null,"title":"鬼妈妈","uri":"/anime/coraline/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 鬼妈妈 2009-02-06 1 bilibili ","date":"2009-02-06","objectID":"/anime/coraline/:2:0","tags":null,"title":"鬼妈妈","uri":"/anime/coraline/"},{"categories":null,"content":"　　Leaf社於1998年發售的18X美少女PC用AVG「WHITE ALBUM」，就當時來說、該遊戲的情節性、音樂和人物刻畫可算是比較優秀的鎮社之作。其實這部作品提出要動畫化已經是多年前的事情了，而最近才終於被正式列入製作日程，預定於2009年1月開播。目前、其PS3移植版也在銳意製作中，TV版的故事將會與PS3版的不同，是一個只有TV版才能完美演繹出的故事。角色的基本定位和以演藝界為舞台的戀愛故事主題將不會改變，人氣聲優平野綾和水樹奈奈分別飾演兩位女主角森川由綺、緒方理奈。本次公開的是兩位女主角的人設。\n　　時間是1986年，被泡沫經濟侵襲的日本。出生在那個年代的青年籐井冬彌在度過平凡大學生活的同時與明星森川由綺交往著。工作與學習之餘，本以為已互相確定感情的兩人，因由綺的人氣上升，而使得距離越拉越遠。這樣一來，冬彌就和與由綺同屬一間演藝公司的當紅明星緒方理奈相遇了。這樣的相遇會給他帶來什麼樣的影響呢？","date":"2009-01-03","objectID":"/anime/white_album/","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"简介 Leaf社於1998年發售的18X美少女PC用AVG「WHITE ALBUM」，就當時來說、該遊戲的情節性、音樂和人物刻畫可算是比較優秀的鎮社之作。其實這部作品提出要動畫化已經是多年前的事情了，而最近才終於被正式列入製作日程，預定於2009年1月開播。目前、其PS3移植版也在銳意製作中，TV版的故事將會與PS3版的不同，是一個只有TV版才能完美演繹出的故事。角色的基本定位和以演藝界為舞台的戀愛故事主題將不會改變，人氣聲優平野綾和水樹奈奈分別飾演兩位女主角森川由綺、緒方理奈。本次公開的是兩位女主角的人設。 時間是1986年，被泡沫經濟侵襲的日本。出生在那個年代的青年籐井冬彌在度過平凡大學生","date":"2009-01-03","objectID":"/anime/white_album/:1:0","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤井冬弥 藤井 冬弥、ふじい とうや、Fujii Touya 男 木村はるか 2 森川由绮 森川由綺、もりかわ　ゆき、Morikawa Yuki 女 平野綾 3 绪方理奈 緒方 理奈、おがた りな、Ogata Rina 女 水樹奈々 4 泽仓美咲 澤倉 美咲、さわくら みさき、Sawakura Misaki 女 高本めぐみ 5 河岛遥 河島 はるか、かわしま はるか、Kawashima Haruka 女 升望 6 观月真名 観月 マナ、みづき マナ、Mizuki Mana 女 戸松遥 7 筱冢弥生 篠塚 弥生、しのづか やよい、Shinozuka Yayoi","date":"2009-01-03","objectID":"/anime/white_album/:2:0","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 白色相簿 2009-01-03 13 bilibili 2 白色相簿 下半编章 2009-10-02 13 bilibili ","date":"2009-01-03","objectID":"/anime/white_album/:3:0","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"MAD ","date":"2009-01-03","objectID":"/anime/white_album/:4:0","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"幻想乡\n那是隔了一层结界悄然存于现代的内侧的另一个世界\n那里是能够让人类与非人的妖精 妖怪 神明等和平共处的理想乡\n居住着守护结界的巫女博丽灵梦的神社——博丽神社\n每到夏天 那里会举办一场大宴会\n每逢宴会 神社就会因幻想乡的住民们的共聚一堂而热闹非凡\n今年的幻想乡也一如往常 迎来了夏天\n","date":"2008-12-30","objectID":"/anime/touhou_project/","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"简介 幻想乡 那是隔了一层结界悄然存于现代的内侧的另一个世界 那里是能够让人类与非人的妖精 妖怪 神明等和平共处的理想乡 居住着守护结界的巫女博丽灵梦的神社——博丽神社 每到夏天 那里会举办一场大宴会 每逢宴会 神社就会因幻想乡的住民们的共聚一堂而热闹非凡 今年的幻想乡也一如往常 迎来了夏天 制作人员： 原作：ZUN、上海爱丽丝幻乐团 导演：时音 ","date":"2008-12-30","objectID":"/anime/touhou_project/:1:0","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 博丽灵梦 博麗靈夢、はくれい れいむ、Hakurei Reimu、无节操，红白，露腋巫女，十万巫女，城管 女 中原麻衣 2 雾雨魔理沙 霧雨魔理沙、Kirisame Marisa、黑白、霧雨魔梨沙 女 沢城みゆき 3 射命丸文 しゃめいまる あや、Shameimaru Aya、文文 女 藤村歩 4 帕秋莉·诺蕾姬 知识与避世的少女、不动的大图书馆、不明的魔法之元、花昙的魔女、广藿香·知识、Patchouli Knowledge、香草、图书、帕琪、姆Q、一周少女 女 高橋美佳子 5 蕾米莉亚·斯卡蕾特 蕾米莉亚·斯卡雷特、红之恶魔、永远的红色幼月、红色的世界、","date":"2008-12-30","objectID":"/anime/touhou_project/:2:0","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 东方梦想夏乡 2008-12-30 00:20:30 bilibili 2 东方活动写真馆 2009-04-26 bilibili 3 东方PVD 2010-08-13 bilibili 4 幻想万华镜 春雪异变之章 2011-08-13 bilibili ","date":"2008-12-30","objectID":"/anime/touhou_project/:3:0","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"MAD ","date":"2008-12-30","objectID":"/anime/touhou_project/:4:0","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"《428 ～被封锁的涩谷～》是日本Chunsoft公司开发的游戏。该作于2008年12月4日以Wii为平台正式发售。\n该作故事情节围绕一起发生在日本东京涩谷地区的绑架案展开。\n2017年，发行商Spike Chunsoft正式宣布，该作于2018年登陆PC，PS4平台。","date":"2008-12-04","objectID":"/game/shibuya_scramble/","tags":null,"title":"428 ～被封锁的涩谷～","uri":"/game/shibuya_scramble/"},{"categories":null,"content":"简介 《428 ～被封锁的涩谷～》是日本Chunsoft公司开发的游戏。该作于2008年12月4日以Wii为平台正式发售。 该作故事情节围绕一起发生在日本东京涩谷地区的绑架案展开。 2017年，发行商Spike Chunsoft正式宣布，该作于2018年登陆PC，PS4平台。 制作人员： 开发：CHUNSOFT 发行：Spike、世嘉 剧本：奈须蘑菇、北岛行德、我孙子武丸 音乐：佐藤直纪 人物设定：武内崇 导演：石井次郎 ","date":"2008-12-04","objectID":"/game/shibuya_scramble/:1:0","tags":null,"title":"428 ～被封锁的涩谷～","uri":"/game/shibuya_scramble/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小玉 女 2 加纳慎也 男 3 远藤亚智 男 4 御法川实 御法川実、Minorikawa Minoru 男 5 大泽贤治 男 6 大泽玛利亚 大沢マリア、Oosawa Maria 女 7 大泽瞳 女 8 杰克·斯坦利 男 ","date":"2008-12-04","objectID":"/game/shibuya_scramble/:2:0","tags":null,"title":"428 ～被封锁的涩谷～","uri":"/game/shibuya_scramble/"},{"categories":null,"content":"系列 系列名 发行时间 1 428 ～被封锁的涩谷～ 2008-12-04 ","date":"2008-12-04","objectID":"/game/shibuya_scramble/:3:0","tags":null,"title":"428 ～被封锁的涩谷～","uri":"/game/shibuya_scramble/"},{"categories":null,"content":"孤儿哈金从小被神父收养，没想到，表面上光鲜伪善的神职人员背地里却是个以虐待儿童为乐的禽兽。虽然生活在非人的待遇之下，但单纯的哈金从来都没有放弃过可以获得自由的梦想，没想到，这一天，她的梦想竟然成为了现实。当那个名为道子的美丽女人出现在她的面前时，当哈金坐上她那造型夸张的坐骑时，当身后的警察马不停蹄的追赶她们二人的时，哈金明白，从此以后，她的命运，将完完全全的由她自己来掌控。\n就这样，哈金和道子踏上了逃亡与流浪的旅程。她们的终点在哪里？桀骜不驯的道子又究竟有着怎样的神秘过往？","date":"2008-10-15","objectID":"/anime/michiko_to_hatchin/","tags":null,"title":"道子与哈金","uri":"/anime/michiko_to_hatchin/"},{"categories":null,"content":"简介 孤儿哈金从小被神父收养，没想到，表面上光鲜伪善的神职人员背地里却是个以虐待儿童为乐的禽兽。虽然生活在非人的待遇之下，但单纯的哈金从来都没有放弃过可以获得自由的梦想，没想到，这一天，她的梦想竟然成为了现实。当那个名为道子的美丽女人出现在她的面前时，当哈金坐上她那造型夸张的坐骑时，当身后的警察马不停蹄的追赶她们二人的时，哈金明白，从此以后，她的命运，将完完全全的由她自己来掌控。 就这样，哈金和道子踏上了逃亡与流浪的旅程。她们的终点在哪里？桀骜不驯的道子又究竟有着怎样的神秘过往？ 制作人员： 原作：Manglobe 导演：山本沙代 脚本：宇治田隆史 分镜：冈佳广、大桥誉志光、增井壮一、安寿、米","date":"2008-10-15","objectID":"/anime/michiko_to_hatchin/:1:0","tags":null,"title":"道子与哈金","uri":"/anime/michiko_to_hatchin/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 道子·马朗多洛 michiko marandoro 女 日高里菜 2 花儿·莫雷诺斯 Hana Morenos 女 大後寿々花 3 浩司·莫雷诺斯 男 津田寛治 4 淳子·杰克逊 Atsuko Jackson 女 坂井真紀 5 シンスケ・サッセ・ロドリゲス Shinsuke Rodriguez 男 村上淳 6 リカルド Ricardo 男 光石研 7 广播 アナウンサー、Announcer、播音员、Announce 河内孝博 ","date":"2008-10-15","objectID":"/anime/michiko_to_hatchin/:2:0","tags":null,"title":"道子与哈金","uri":"/anime/michiko_to_hatchin/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 道子与哈金 2008-10-15 22 bilibili ","date":"2008-10-15","objectID":"/anime/michiko_to_hatchin/:3:0","tags":null,"title":"道子与哈金","uri":"/anime/michiko_to_hatchin/"},{"categories":null,"content":"“埼京彩珠豺狼”队的儿岛弘道，虽然具备实力，但却一次优胜也没有得到过，因此被称为“不走运的天才击球手”。\n不能得到估胜，应该是哪里尚有不足之处。为了找出那个缺点而自己来到了冲绳进行私下特训。在那里，他遇到了一个叫渡久地东亚的男人——称为“ONE OUTS”的赌博棒球中不败的传说。\n在第二次的比赛中，最后儿岛以力气取胜。为了利卡恩兹的光明未来，他向东亚发出了邀请的。\n随着东亚的入团，万年B级队的弱小球队“埼京彩珠利卡恩兹”的命运迎来了巨大的转变。","date":"2008-10-07","objectID":"/anime/one_outs/","tags":null,"title":"超智游戏","uri":"/anime/one_outs/"},{"categories":null,"content":"简介 “埼京彩珠豺狼”队的儿岛弘道，虽然具备实力，但却一次优胜也没有得到过，因此被称为“不走运的天才击球手”。 不能得到估胜，应该是哪里尚有不足之处。为了找出那个缺点而自己来到了冲绳进行私下特训。在那里，他遇到了一个叫渡久地东亚的男人——称为“ONE OUTS”的赌博棒球中不败的传说。 在第二次的比赛中，最后儿岛以力气取胜。为了利卡恩兹的光明未来，他向东亚发出了邀请的。 随着东亚的入团，万年B级队的弱小球队“埼京彩珠利卡恩兹”的命运迎来了巨大的转变。 制作人员： 原作：甲斐谷忍 导演：佐藤雄三 脚本：高屋敷英夫、广田光毅 分镜：细田雅弘、佐佐木守（动画人）、岩城忠雄、笹木信作、坂田纯一 ","date":"2008-10-07","objectID":"/anime/one_outs/:1:0","tags":null,"title":"超智游戏","uri":"/anime/one_outs/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 渡久地东亚 TOA TOKUCHI 男 萩原聖人 2 兒島弘道 儿岛弘道、児島 弘道、こじま ひろみち、Kojima Hiromichi 男 磯部勉 3 彩川恒雄 Saikawa Tsuneo 男 内海賢二 4 出口智志 Ideguchi Satoshi 男 山口勝平 5 三原雄三郎 Mihara Yuuzaburou 男 飯塚昭三 6 河中纯一 かわなか じゅんいち、Jun’ichi Kawanaka 男 寺島拓篤 7 冴岛明夫 Saejima Aki 男 内田直哉 8 今井建一 今井 建一、いまい けんいち、Imai Kenichi 男 奈良徹 ","date":"2008-10-07","objectID":"/anime/one_outs/:2:0","tags":null,"title":"超智游戏","uri":"/anime/one_outs/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 超智游戏 2008-10-07 25 bilibili ","date":"2008-10-07","objectID":"/anime/one_outs/:3:0","tags":null,"title":"超智游戏","uri":"/anime/one_outs/"},{"categories":null,"content":"漫画版前传，讲述女主角土宫神乐与谏山黄泉相识之初的一段往事。\n土宫家是世世代代保护京都的家族，在一次与强大恶灵的战斗中，土宫家现任家主土宫雅乐的夫人因重伤不治去世。一心要继承夫人体内最强灵兽“白叡”的土宫雅乐，专心于法术的修炼与恶灵的退治，因此冷落了失去母亲后陷入悲伤中的女儿神乐。然而谏山家的养女谏山黄泉却以明朗的性格，逐渐感化了封闭内心的神乐，二人在朝夕相处中，姐妹之情日益加深。\n继承了谏山家祖传宝刀“狮子王”的黄泉，在她平时高中生身份之外，还身为环境省超自然灾害对策室的战斗主力，不断清除着各式各样的恶灵。怀着对黄泉的憧憬，以及对死去母亲的怀念，神乐也以实习生的身份加入了超自然灾害对策室，成为队伍里备受大家关爱的小妹妹。\n充满残酷战斗但也始终洋溢着温情的日子在一天天的延续，然而随着黄泉的姐姐谏山冥的登场，残酷的命运渐渐将二人卷入其中，走向注定的悲剧……","date":"2008-10-05","objectID":"/anime/ga_rei_zero/","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"简介 漫画版前传，讲述女主角土宫神乐与谏山黄泉相识之初的一段往事。 土宫家是世世代代保护京都的家族，在一次与强大恶灵的战斗中，土宫家现任家主土宫雅乐的夫人因重伤不治去世。一心要继承夫人体内最强灵兽“白叡”的土宫雅乐，专心于法术的修炼与恶灵的退治，因此冷落了失去母亲后陷入悲伤中的女儿神乐。然而谏山家的养女谏山黄泉却以明朗的性格，逐渐感化了封闭内心的神乐，二人在朝夕相处中，姐妹之情日益加深。 继承了谏山家祖传宝刀“狮子王”的黄泉，在她平时高中生身份之外，还身为环境省超自然灾害对策室的战斗主力，不断清除着各式各样的恶灵。怀着对黄泉的憧憬，以及对死去母亲的怀念，神乐也以实习生的身份加入了超自然灾害对策","date":"2008-10-05","objectID":"/anime/ga_rei_zero/:1:0","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 谏山黄泉 諫山 黄泉、いさやま よみ、Isayama Yomi、黄泉姐姐 女 水原薫 2 土宫神乐 土宮 神楽、つちみや かぐら、Tsuchimiya Kagura 女 茅原実里 3 饭纲纪之 飯綱 紀之、いづな のりゆき、Izuna Noriyuki 男 高橋伸也 4 樱庭一骑 桜庭 一騎、さくらば かずき、Sakuraba Kazuki 男 白石稔 5 岩端晃司 岩端 晃司、いわはた こうじ、Iwahata Kouji 男 稲田徹 6 纳布兄弟 なぶー きょうだい、Nabu Kyoudai 男 若本規夫 7 神宫寺菖蒲 神宮寺菖蒲、じんぐうじ あやめ、J","date":"2008-10-05","objectID":"/anime/ga_rei_zero/:2:0","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 食灵-零- 2008-10-05 12 樱花 ","date":"2008-10-05","objectID":"/anime/ga_rei_zero/:3:0","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"MAD ","date":"2008-10-05","objectID":"/anime/ga_rei_zero/:4:0","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"自己的阳台栏杆上出现了像被单一样挂在上面的少女，这种非现实的情节出现在了上条当麻的眼前。虽然在这个城市——最先进科学引导的学院都市中，超能力已经可以通过科学技术创造出来，但是眼前这位自称“茵蒂克丝”的少女还是把上条当麻吓了一条。茵蒂克丝自称因拥有十万三千本魔导书而被魔法师追杀，而上条当麻靠自己的超能力也认定了少女的魔法。少女以危险为由离开上条家，上条如往日一般去学校学习，但放学回家，却发现茵蒂克丝倒在血泊之中。在科学与魔术交叉的世界中，上条当麻与茵蒂克丝的故事开始了。","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"简介 自己的阳台栏杆上出现了像被单一样挂在上面的少女，这种非现实的情节出现在了上条当麻的眼前。虽然在这个城市——最先进科学引导的学院都市中，超能力已经可以通过科学技术创造出来，但是眼前这位自称“茵蒂克丝”的少女还是把上条当麻吓了一条。茵蒂克丝自称因拥有十万三千本魔导书而被魔法师追杀，而上条当麻靠自己的超能力也认定了少女的魔法。少女以危险为由离开上条家，上条如往日一般去学校学习，但放学回家，却发现茵蒂克丝倒在血泊之中。在科学与魔术交叉的世界中，上条当麻与茵蒂克丝的故事开始了。 制作人员： 原作：镰池和马 导演：锦织博 脚本：赤星政尚、谷崎晃、水上清资、西园悟 分镜：中津环、大原实、杉岛邦久 ","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/:1:0","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 茵蒂克斯 小黄书、Index Librorum Prohibitorum、indekkusu、Dedicatus545（献身的な子羊は強者の知識を守る） 女 井口裕香 2 上条当麻 上条当麻、かみじょとうま、Kamijou Touma、小上条，上条，当麻，大妈 男 阿部敦 3 御坂美琴 Mikoto Misaka、御坂美琴、みさかみこと、Misaka Mikoto、炮姐 / ビリビリ/Bilibili、超电磁炮/レールガン/Railgun 女 佐藤利奈 4 一方通行 Accelerator、アクセラレータ、Accelerator、铃科百合子 不明 岡本信彦 ","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/:2:0","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔法禁书目录 2008-10-04 24 bilibili 2 魔法禁书目录 第二季 2010-10-08 24 bilibili 3 魔法禁书目录 恩底弥翁的奇迹 2013-02-23 1 bilibili 4 魔法禁书目录 第三季 2018-10-05 26 bilibili ","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/:3:0","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"MAD ","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/:4:0","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"　　天上掉下美少女的故事已经落伍了，今次是美少女破土而出！\n　　高中生御厨仁用古树的木材雕刻了精灵像木雕，本打算以此参加地区展览会。不想搬运中，木雕掉在地上，竟然突然变出一位蓝发美少女！\n　　这是怎么回事？漫画中美少女出现，住进主角家的荒唐剧情难道要发生在仁身上了吗？正当仁因这突如其来的变化而不知所措之际，少女开口说道：“吾乃产土神也。”\n　　这位叫做薙的少女自称是神灵显灵，手拿动画片中的魔法棒去消灭“秽”。但是无论怎么看，薙不过是个爱耍大小姐脾气的可爱女孩。\n　　仁，面对这位破土而出的少女，到底该怎么办？  ","date":"2008-10-04","objectID":"/anime/kannagi/","tags":null,"title":"神薙","uri":"/anime/kannagi/"},{"categories":null,"content":"简介 天上掉下美少女的故事已经落伍了，今次是美少女破土而出！ 高中生御厨仁用古树的木材雕刻了精灵像木雕，本打算以此参加地区展览会。不想搬运中，木雕掉在地上，竟然突然变出一位蓝发美少女！ 这是怎么回事？漫画中美少女出现，住进主角家的荒唐剧情难道要发生在仁身上了吗？正当仁因这突如其来的变化而不知所措之际，少女开口说道：“吾乃产土神也。” 这位叫做薙的少女自称是神灵显灵，手拿动画片中的魔法棒去消灭“秽”。但是无论怎么看，薙不过是个爱耍大小姐脾气的可爱女孩。 仁，面对这位破土而出的少女，到底该怎么办？ 制作人员： 原作：武梨绘里 导演：山本宽 脚本：仓田英之、高桥龙也、本田透 分镜：伊藤智彦、畑博之、","date":"2008-10-04","objectID":"/anime/kannagi/:1:0","tags":null,"title":"神薙","uri":"/anime/kannagi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 薙 ナギ、Nagi 女 戸松遥 2 御厨仁 御厨 仁、みくりや じん、Mikuriya Jin 男 沢城みゆき 3 青叶鸫 あおば つぐみ、Aoba Tsugumi 女 沢城みゆき 4 忏悔 女 花澤香菜 5 凉城白亚 涼城 白亜、Suzushiro Hakua 花澤香菜 6 响大铁 響 大鉄、ひびき だいてつ、Hibiki Daitetsu 男 星野貴紀 7 秋叶巡 秋葉 巡、あきば めぐる、Akiba Meguru 男 柿原徹也 8 木村贵子 きむら たかこ 女 早水リサ ","date":"2008-10-04","objectID":"/anime/kannagi/:2:0","tags":null,"title":"神薙","uri":"/anime/kannagi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 神薙 2008-10-04 14 bilibili ","date":"2008-10-04","objectID":"/anime/kannagi/:3:0","tags":null,"title":"神薙","uri":"/anime/kannagi/"},{"categories":null,"content":"　　因眼神凶恶而被班里同学看作不良少年的高须龙儿，进入了高中二年级，并幸运地和暗恋的少女栉枝实乃梨同班，对崭新的校园生活满怀希望。\n　　开学典礼后龙儿与校内最恐怖的有“掌上老虎”之称的逢坂大河狭路相逢，周围人一同陷入了惊恐状态。然而他意外地发现，逢坂同时也是实乃梨的闺蜜。\n　　在二人相遇的当晚，龙儿知道了原来她暗恋的是自己的好友北村祐作，而自己暗恋实乃梨的事也被大河知道了！互相了解对方情况的两人结成了“恋爱同盟战线”，开始了半共同生活……","date":"2008-10-01","objectID":"/anime/toradora/","tags":null,"title":"龙与虎","uri":"/anime/toradora/"},{"categories":null,"content":"简介 因眼神凶恶而被班里同学看作不良少年的高须龙儿，进入了高中二年级，并幸运地和暗恋的少女栉枝实乃梨同班，对崭新的校园生活满怀希望。 开学典礼后龙儿与校内最恐怖的有“掌上老虎”之称的逢坂大河狭路相逢，周围人一同陷入了惊恐状态。然而他意外地发现，逢坂同时也是实乃梨的闺蜜。 在二人相遇的当晚，龙儿知道了原来她暗恋的是自己的好友北村祐作，而自己暗恋实乃梨的事也被大河知道了！互相了解对方情况的两人结成了“恋爱同盟战线”，开始了半共同生活…… 制作人员： 原作：竹宫悠由子 导演：长井龙雪 脚本：冈田麿里、横谷昌宏、樋口达人、冈崎纯子 分镜：笠井贤一、二瓶勇一、铃木洋平 ","date":"2008-10-01","objectID":"/anime/toradora/:1:0","tags":null,"title":"龙与虎","uri":"/anime/toradora/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 高须龙儿 高須 竜児、たかす りゅうじ、Takasu Ryuji 男 間島淳司 2 逢坂大河 Aisaka Taiga、あいさか たいが、逢坂 大河、あいさかたいが、AisakaTaiga、钉宫四萌 女 釘宮理恵 3 栉枝实乃梨 Minori Kushieda、櫛枝 実乃梨、くしえだ みのり、Kushieda Minori、みのり 女 堀江由衣 4 川岛亚美 八嘎吉、亚美美、川嶋 亜美、かわしま あみ、Kawashima Ami、ばかちー、バカチワワ、吉娃娃 女 喜多村英梨 5 北村佑作 きたむら ゆうさく、Kitamura Yuusaku 男 野島裕史 6","date":"2008-10-01","objectID":"/anime/toradora/:2:0","tags":null,"title":"龙与虎","uri":"/anime/toradora/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙与虎 2008-10-01 25 bilibili ","date":"2008-10-01","objectID":"/anime/toradora/:3:0","tags":null,"title":"龙与虎","uri":"/anime/toradora/"},{"categories":null,"content":"MAD ","date":"2008-10-01","objectID":"/anime/toradora/:4:0","tags":null,"title":"龙与虎","uri":"/anime/toradora/"},{"categories":null,"content":"　　吉姆·派克（安东尼·拉帕格利亚 Anthony LaPaglia 配音）在街上碰到了一个向他要钱买咖啡的流浪汉（杰弗里·拉什 Geoffrey Rush 配音），他没给钱，没想到那流浪汉竟在他面前饮弹自尽。吉姆的小儿子，28岁的大卫·派克（塞缪尔·约翰逊 Samuel Johnson 配音）找不到工作，就连电话营销都嫌他“经验不足”。吉姆劝说大卫加入哥哥莱尼（本·门德尔森 Ben Mendelsohn 配音）的讨债公司，但大卫只对寻找生命的意义这类哲学问题感兴趣，勉为其难试工，却还是令父亲大失所望。除了派克一家，居住在同一幢悉尼公寓楼里的还有与未婚妻分手的吸毒者、鳏居的寂寞老人、破产的魔术师、新搬来的超级名模和热爱足球的小孩等。在这些形形色色人等的日常生活中，究竟什么才是生命的意义，如何才能找到幸福呢？ \n　　本片获斯德哥尔摩电影节铜马奖提名，美国动画安尼奖最佳动画及最佳动画导演奖提名，并获墨西哥城国际现代电影节观众票选奖和最佳女导演奖。","date":"2008-09-04","objectID":"/anime/9.99/","tags":null,"title":"9.99澳元","uri":"/anime/9.99/"},{"categories":null,"content":"简介 吉姆·派克（安东尼·拉帕格利亚 Anthony LaPaglia 配音）在街上碰到了一个向他要钱买咖啡的流浪汉（杰弗里·拉什 Geoffrey Rush 配音），他没给钱，没想到那流浪汉竟在他面前饮弹自尽。吉姆的小儿子，28岁的大卫·派克（塞缪尔·约翰逊 Samuel Johnson 配音）找不到工作，就连电话营销都嫌他“经验不足”。吉姆劝说大卫加入哥哥莱尼（本·门德尔森 Ben Mendelsohn 配音）的讨债公司，但大卫只对寻找生命的意义这类哲学问题感兴趣，勉为其难试工，却还是令父亲大失所望。除了派克一家，居住在同一幢悉尼公寓楼里的还有与未婚妻分手的吸毒者、鳏居的寂寞老人、破产的魔","date":"2008-09-04","objectID":"/anime/9.99/:1:0","tags":null,"title":"9.99澳元","uri":"/anime/9.99/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 9.99澳元 2008-09-04 1 暂无 ","date":"2008-09-04","objectID":"/anime/9.99/:2:0","tags":null,"title":"9.99澳元","uri":"/anime/9.99/"},{"categories":null,"content":"《时空幻境》是由Number None开发，微软游戏工作室及Number None发行的一款动作类解谜游戏。于2008年8月6日发布，游戏亦于2009年登陆PC、Mac、PS3平台。\n\n《时空幻境》允许玩家随时使用时间倒退功能让主角回到以前的位置。玩家需要灵活运用时间倒退功能以及各种加快、减慢甚至倒退时间的机关，收集散落在关卡角落的拼图碎片，方可完成游戏。","date":"2008-08-06","objectID":"/game/braid/","tags":null,"title":"时空幻境","uri":"/game/braid/"},{"categories":null,"content":"简介 《时空幻境》是由Number None开发，微软游戏工作室及Number None发行的一款动作类解谜游戏。于2008年8月6日发布，游戏亦于2009年登陆PC、Mac、PS3平台。 《时空幻境》允许玩家随时使用时间倒退功能让主角回到以前的位置。玩家需要灵活运用时间倒退功能以及各种加快、减慢甚至倒退时间的机关，收集散落在关卡角落的拼图碎片，方可完成游戏。 制作人员： 遊戲設計師：Jonathan Blow ","date":"2008-08-06","objectID":"/game/braid/:1:0","tags":null,"title":"时空幻境","uri":"/game/braid/"},{"categories":null,"content":"系列 系列名 发行时间 1 时空幻境 2008-08-06 ","date":"2008-08-06","objectID":"/game/braid/:2:0","tags":null,"title":"时空幻境","uri":"/game/braid/"},{"categories":null,"content":"战斗机飞行员函南优一来到基地报道，等待他的是全新的生活环境与熟悉的飞行战斗。在这里，函南优一遇到了各式各样的战友，与不苟言笑的长官草薙水素。函南优一获得了一架新战斗机，但是，基地里的战友们都对战斗机的前任驾驶员缄默不语。于是函南优一开始留意相关的消息，他渐渐知道，前任驾驶员的最后故事，而这故事本身与草薙水素有莫大的关系。随着调查的深入，函南优一逐渐发现记忆背后隐藏的秘密，而他每天与敌人的战斗，似乎也有着向着界限迈步的一天。","date":"2008-08-02","objectID":"/anime/the_sky_crawlers/","tags":null,"title":"空中杀手","uri":"/anime/the_sky_crawlers/"},{"categories":null,"content":"简介 战斗机飞行员函南优一来到基地报道，等待他的是全新的生活环境与熟悉的飞行战斗。在这里，函南优一遇到了各式各样的战友，与不苟言笑的长官草薙水素。函南优一获得了一架新战斗机，但是，基地里的战友们都对战斗机的前任驾驶员缄默不语。于是函南优一开始留意相关的消息，他渐渐知道，前任驾驶员的最后故事，而这故事本身与草薙水素有莫大的关系。随着调查的深入，函南优一逐渐发现记忆背后隐藏的秘密，而他每天与敌人的战斗，似乎也有着向着界限迈步的一天。 制作人员： 原作：森博嗣 导演：押井守 脚本：伊藤千寻 演出：西久保瑞穗 音乐：川井宪次 人物设定：西尾铁也 分镜构图：渡部隆 美术监督：永井一男 ","date":"2008-08-02","objectID":"/anime/the_sky_crawlers/:1:0","tags":null,"title":"空中杀手","uri":"/anime/the_sky_crawlers/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 草薙水素 クサナギ・スイト 女 菊地凛子 2 函南优一 カンナミ・ユーヒチ 加瀬亮 3 路人 モブ、モブキャラ、闲角、mob character、端役、エキストラ、extra 下野紘 ","date":"2008-08-02","objectID":"/anime/the_sky_crawlers/:2:0","tags":null,"title":"空中杀手","uri":"/anime/the_sky_crawlers/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 空中杀手 2008-08-02 122min 樱花 ","date":"2008-08-02","objectID":"/anime/the_sky_crawlers/:3:0","tags":null,"title":"空中杀手","uri":"/anime/the_sky_crawlers/"},{"categories":null,"content":"夏娃的时间（日语：イヴの時間）是2008年8月的一部科幻在线动画。讲述了未来的日本，机器人十分普及的情况。主人公陆夫偶然间发现了一间咖啡店，在里面人与机器人是平等的。\n（Via wikipedia）","date":"2008-08-01","objectID":"/anime/time_of_eve/","tags":null,"title":"夏娃的时间","uri":"/anime/time_of_eve/"},{"categories":null,"content":"简介 夏娃的时间（日语：イヴの時間）是2008年8月的一部科幻在线动画。讲述了未来的日本，机器人十分普及的情况。主人公陆夫偶然间发现了一间咖啡店，在里面人与机器人是平等的。 （Via wikipedia） 制作人员： 原作：吉浦康裕 人物设定：茶山隆介 美术监督：安喰秀一 色彩设计：井上あきこ ","date":"2008-08-01","objectID":"/anime/time_of_eve/:1:0","tags":null,"title":"夏娃的时间","uri":"/anime/time_of_eve/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 サミイ 女 田中理恵 2 向坂陆夫 男 福山潤 3 真崎正和 マサキ 男 野島健児 4 凪 女 佐藤利奈 5 亚纪子 ゆかな 6 耕次 男 中尾みち雄 7 莉娜 伊藤美紀 8 千惠 女 沢城みゆき ","date":"2008-08-01","objectID":"/anime/time_of_eve/:2:0","tags":null,"title":"夏娃的时间","uri":"/anime/time_of_eve/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 夏娃的时间 2008-08-01 6 bilibili ","date":"2008-08-01","objectID":"/anime/time_of_eve/:3:0","tags":null,"title":"夏娃的时间","uri":"/anime/time_of_eve/"},{"categories":null,"content":"MAD ","date":"2008-08-01","objectID":"/anime/time_of_eve/:4:0","tags":null,"title":"夏娃的时间","uri":"/anime/time_of_eve/"},{"categories":null,"content":"5 岁的宗介生长在海边小城,他的家就在临海的悬崖上。一天,宗介捡到了一个被海浪冲上岸的废玻璃瓶,里面有条受困的小金鱼。小金鱼名叫波尼,她是人鱼女王的女儿,偷偷驾着水母溜出来玩的时候撞进了瓶子里。宗介把波尼带回了自己家,养在塑料盆里。波尼在宗介家过得很愉快,她很喜欢宗介,宗介也喜欢她。然而,快乐的日子很快就过去了。\n\n波尼的爸爸藤本把女儿带回了海底。藤本原是一个渔夫,后来和人鱼女王相爱成了海底居民。波尼回家后,十分思念宗介,她做出了一个大胆的决定——她要变成人,和宗介在一起。在妹妹们的帮助下,波尼偷出了父亲的法宝,向人类世界游去。不料,蕴含着危险魔力的生命之水失控了,于是,海水暴涨,暴风狂作,妹妹们变成了可怕的巨型鱼,海浪向宗介一家所在的悬崖扑去……\n\n海边小城被淹没了,波尼没想到自己的美好愿望竟然招来了这样的大祸。她能挽救宗介么?","date":"2008-07-19","objectID":"/anime/ponyo/","tags":null,"title":"崖上的波妞","uri":"/anime/ponyo/"},{"categories":null,"content":"简介 5 岁的宗介生长在海边小城,他的家就在临海的悬崖上。一天,宗介捡到了一个被海浪冲上岸的废玻璃瓶,里面有条受困的小金鱼。小金鱼名叫波尼,她是人鱼女王的女儿,偷偷驾着水母溜出来玩的时候撞进了瓶子里。宗介把波尼带回了自己家,养在塑料盆里。波尼在宗介家过得很愉快,她很喜欢宗介,宗介也喜欢她。然而,快乐的日子很快就过去了。 波尼的爸爸藤本把女儿带回了海底。藤本原是一个渔夫,后来和人鱼女王相爱成了海底居民。波尼回家后,十分思念宗介,她做出了一个大胆的决定——她要变成人,和宗介在一起。在妹妹们的帮助下,波尼偷出了父亲的法宝,向人类世界游去。不料,蕴含着危险魔力的生命之水失控了,于是,海水暴涨,暴风狂作","date":"2008-07-19","objectID":"/anime/ponyo/:1:0","tags":null,"title":"崖上的波妞","uri":"/anime/ponyo/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 波妞 Ponyo 女 神月柚莉愛 2 宗介 宗介、Sousuke 男 土井洋輝 3 理莎 女 山口智子 4 耕一 耕一、Kouichi 男 長嶋一茂 5 藤本 フジモト、Fujimoto 男 所ジョージ 6 时 トキ、Toki 女 吉行和子 7 波妞的妹妹们 ポニョのいもうと達、Ponyo no Imouto-tachi 女 矢野顕子 ","date":"2008-07-19","objectID":"/anime/ponyo/:2:0","tags":null,"title":"崖上的波妞","uri":"/anime/ponyo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 崖上的波妞 2008-07-19 1 樱花 ","date":"2008-07-19","objectID":"/anime/ponyo/:3:0","tags":null,"title":"崖上的波妞","uri":"/anime/ponyo/"},{"categories":null,"content":"因为看得见妖怪而被人类疏远的女子夏目玲子，为了打发寂寞的日子，她向妖怪们发起挑战，并将败在自己手下的妖怪的名字写在一纸契约上，以此做为妖怪们成为自己属下的证据。 \n玲子的孙子夏目贵志得到了那些契约书所做成的“友人帐”，还继承了玲子的力量，能看到不会显现在人前的物体。而且也和玲子一样成为了被周围人疏远的一员。 \n可是，作为唯一继续了玲子血统的他却做出了一个重要的决定：将玲子夺过来的姓怪们的名字一一归还。在这样的夏目的身边，开始聚集起各种各样的妖怪们…… \n能看到妖怪的少年夏目贵志，与招财猫外表的妖怪喵先生一起，为大家讲述一个奇异、悲伤，怀念、令人感动的怪谈故事。","date":"2008-07-07","objectID":"/anime/natsume_yuujinchou/","tags":null,"title":"夏目友人帐","uri":"/anime/natsume_yuujinchou/"},{"categories":null,"content":"简介 因为看得见妖怪而被人类疏远的女子夏目玲子，为了打发寂寞的日子，她向妖怪们发起挑战，并将败在自己手下的妖怪的名字写在一纸契约上，以此做为妖怪们成为自己属下的证据。 玲子的孙子夏目贵志得到了那些契约书所做成的“友人帐”，还继承了玲子的力量，能看到不会显现在人前的物体。而且也和玲子一样成为了被周围人疏远的一员。 可是，作为唯一继续了玲子血统的他却做出了一个重要的决定：将玲子夺过来的姓怪们的名字一一归还。在这样的夏目的身边，开始聚集起各种各样的妖怪们…… 能看到妖怪的少年夏目贵志，与招财猫外表的妖怪喵先生一起，为大家讲述一个奇异、悲伤，怀念、令人感动的怪谈故事。 制作人员： 原作：绿川幸 导演：","date":"2008-07-07","objectID":"/anime/natsume_yuujinchou/:1:0","tags":null,"title":"夏目友人帐","uri":"/anime/natsume_yuujinchou/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 夏目贵志 なつめ　たかし、Natsume Takashi 男 神谷浩史 2 喵先生/斑 猫咪老师、ニャンコ先生、Nyanko-sensei、娘口三三 未知 井上和彦 3 夏目玲子 夏目レイコ、Natsume Reiko 女 小林沙苗 4 笹田纯 笹田純、Sasada Jun 女 沢城みゆき 5 西村悟 西村悟、Nishimura Satoru 男 木村良平 6 藤原塔子 藤原塔子、Fujiwara Touko 女 伊藤美紀 7 藤原滋 藤原滋、Fujiwara Shigeru 男 伊藤栄次 8 田沼要 たぬま　かなめ、Tanuma Kaname 男 堀江一眞","date":"2008-07-07","objectID":"/anime/natsume_yuujinchou/:2:0","tags":null,"title":"夏目友人帐","uri":"/anime/natsume_yuujinchou/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 夏目友人帐 2008-07-07 13 bilibili 2 续 夏目友人帐 2009-01-05 13 bilibili 3 夏目友人帐 参 2011-07-04 13 bilibili 4 夏目友人帐 肆 2012-01-02 13 bilibili 5 夏目友人帐 伍 2016-10-04 11 bilibili 6 夏目友人帐 陆 2017-04-11 11 bilibili 7 剧场版 夏目友人帐～缘结空蝉～ 2018-09-29 1 樱花 8 夏目友人帐 唤石者与怪异的访客 2021-01-16 1 bilibili ","date":"2008-07-07","objectID":"/anime/natsume_yuujinchou/:3:0","tags":null,"title":"夏目友人帐","uri":"/anime/natsume_yuujinchou/"},{"categories":null,"content":"“WALL· E”是Waste Allocation Load Lifters - Earth（地球废品分装员）的缩写，这种职业出现在2700年，因为地球的垃圾多到爆炸，整个星球几乎被垃圾掩埋了，罪魁祸首-人类-只得移居到太空船上，并且请一家叫Buynlarge公司清除地球的垃圾，待万物更新时再飞回地球安居。Buynlarge公司把这种叫WALL· E的机器人大批送往地球捡垃圾，但WALL· E并不适合地球的环境，大批量地来也大批量地坏，最后只剩下一个机器人还在日复一日的按照程序收拾废品。就这么过了几百年，仅存的WALL· E还在垃圾堆里淘到不少人造宝贝，它也开始有了自我意识，懂得什么是孤独。有一天一艘飞船突然降落，一个女机器人夏娃来到地球执行搜寻任务，捡垃圾的机器人“爱”上了Eve，但是它面临着两难的抉择，是跟夏娃飞离地球，还是继续按照身体里的程序捡一辈子的垃圾……　　","date":"2008-06-27","objectID":"/anime/wall-e/","tags":null,"title":"机器人总动员","uri":"/anime/wall-e/"},{"categories":null,"content":"简介 “WALL· E”是Waste Allocation Load Lifters - Earth（地球废品分装员）的缩写，这种职业出现在2700年，因为地球的垃圾多到爆炸，整个星球几乎被垃圾掩埋了，罪魁祸首-人类-只得移居到太空船上，并且请一家叫Buynlarge公司清除地球的垃圾，待万物更新时再飞回地球安居。Buynlarge公司把这种叫WALL· E的机器人大批送往地球捡垃圾，但WALL· E并不适合地球的环境，大批量地来也大批量地坏，最后只剩下一个机器人还在日复一日的按照程序收拾废品。就这么过了几百年，仅存的WALL· E还在垃圾堆里淘到不少人造宝贝，它也开始有了自我意识，懂得什么是","date":"2008-06-27","objectID":"/anime/wall-e/:1:0","tags":null,"title":"机器人总动员","uri":"/anime/wall-e/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 瓦力 WALL.E 2 伊芙 伊娃、EVE ","date":"2008-06-27","objectID":"/anime/wall-e/:2:0","tags":null,"title":"机器人总动员","uri":"/anime/wall-e/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 机器人总动员 2008-06-27 1 樱花 ","date":"2008-06-27","objectID":"/anime/wall-e/:3:0","tags":null,"title":"机器人总动员","uri":"/anime/wall-e/"},{"categories":null,"content":"《G线上的魔王》，是由AKABEiSOFT2研发的恋爱冒险游戏第9作。本作原计划于2007年11月29日发行，但由于开发延迟，正式发行一再推迟，最终于2008年5月29日在日本本土发行，比原计划发布日期晚了半年。2015年11月6日，Sekai Project代理发行Steam英文版《G-senjou no Maou》。\n\n喜欢古典音乐的普通少年浅井京介，与同学美轮椿姬、相泽荣一、义妹浅井花音熟识。而在夜晚，则是养父浅井权三的公司中的重要人物。在冬天，少女宇佐美春转校来到京介的学校，她就是以前和京介一起的“勇者”。在这时，“魔王”出现在这个城市，一连串事件亦开始出现。勇者与魔王间的心理战，斗智的纯爱故事就此揭幕。\n\n游戏宣传语为“赌上性命的、纯爱”（命をかけた、純愛）。","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"简介 《G线上的魔王》，是由AKABEiSOFT2研发的恋爱冒险游戏第9作。本作原计划于2007年11月29日发行，但由于开发延迟，正式发行一再推迟，最终于2008年5月29日在日本本土发行，比原计划发布日期晚了半年。2015年11月6日，Sekai Project代理发行Steam英文版《G-senjou no Maou》。 喜欢古典音乐的普通少年浅井京介，与同学美轮椿姬、相泽荣一、义妹浅井花音熟识。而在夜晚，则是养父浅井权三的公司中的重要人物。在冬天，少女宇佐美春转校来到京介的学校，她就是以前和京介一起的“勇者”。在这时，“魔王”出现在这个城市，一连串事件亦开始出现。勇者与魔王间的心理战，","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/:1:0","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 浅井京介 浅井 京介、あざい きょうすけ 男 2 宇佐美春 女 瑞沢渓 3 浅井花音 あざい かのん 女 こおろぎさとみ 4 美轮桩姬 みわ つばき 女 神崎ちろ 5 白鸟水羽 白鳥 水羽、しらとり みずは 女 氷青 6 时田雪 時田 ユキ、ときた ゆき 女 ひと美 7 浅井权三 浅井 権三、あざい ごんぞう 男 稲田徹 8 魔王 男 福山潤 ","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/:2:0","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"系列 系列名 发行时间 1 G线上的魔王 2008-05-29 ","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/:3:0","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"配乐 ","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/:4:0","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"MAD ","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/:5:0","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"　　关于孪生姐妹之间超过亲情以上的暧昧关系，以及两姐妹在一个学妹的出现所产生的隔阂。剧中樱井雪乃和樱井奏是双胞胎。在同学的渲染下，奏误会雪乃对学妹神山咲夜产生情愫，进而疏远和雪乃的关系。雪乃察觉奏对自己的冷漠，大胆向奏告白示爱，两姐妹终于认清对方是自己的最爱。\n　　Candy☆Boy的续集“Candy boy”由2008年5月2日开始在NICONICO动画频道以网络影像型式播放，每话约长15分钟，全7话。 ","date":"2008-05-02","objectID":"/anime/candy_boy/","tags":null,"title":"糖果男孩","uri":"/anime/candy_boy/"},{"categories":null,"content":"简介 关于孪生姐妹之间超过亲情以上的暧昧关系，以及两姐妹在一个学妹的出现所产生的隔阂。剧中樱井雪乃和樱井奏是双胞胎。在同学的渲染下，奏误会雪乃对学妹神山咲夜产生情愫，进而疏远和雪乃的关系。雪乃察觉奏对自己的冷漠，大胆向奏告白示爱，两姐妹终于认清对方是自己的最爱。 Candy☆Boy的续集“Candy boy”由2008年5月2日开始在NICONICO动画频道以网络影像型式播放，每话约长15分钟，全7话。 制作人员： 导演：星川孝文 脚本：铃木雅词 人物设定：波部崇、梅津行则 美术监督：宫本实生 ","date":"2008-05-02","objectID":"/anime/candy_boy/:1:0","tags":null,"title":"糖果男孩","uri":"/anime/candy_boy/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 樱井雪乃 さくらい ゆきの、Sakurai Yukino 女 柚木涼香 2 樱井奏 さくらい かなで、Sakurai Kanade 女 生天目仁美 3 神山咲夜 かみやま さくや、Kamiyama Sakuya 女 加藤英美里 4 樱井雫 さくらい しずく、Sakurai Shizuku 女 小林ゆう 5 广播 アナウンサー、Announcer、播音员、Announce 太田哲治 ","date":"2008-05-02","objectID":"/anime/candy_boy/:2:0","tags":null,"title":"糖果男孩","uri":"/anime/candy_boy/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 糖果男孩 2008-05-02 9 樱花 ","date":"2008-05-02","objectID":"/anime/candy_boy/:3:0","tags":null,"title":"糖果男孩","uri":"/anime/candy_boy/"},{"categories":null,"content":"由于记忆可以被储存，肉体的死亡不再具有意义。由于记忆可以在不同身体中转移，发生许多社会现象，像是记忆的买卖、违法的记忆改造、偷取他人的记忆。社会混乱，进步停滞。丧失自己记忆的主角凯巴在这样的社会里寻找自己原来的记忆。","date":"2008-04-10","objectID":"/anime/kaiba/","tags":null,"title":"海马","uri":"/anime/kaiba/"},{"categories":null,"content":"简介 由于记忆可以被储存，肉体的死亡不再具有意义。由于记忆可以在不同身体中转移，发生许多社会现象，像是记忆的买卖、违法的记忆改造、偷取他人的记忆。社会混乱，进步停滞。丧失自己记忆的主角凯巴在这样的社会里寻找自己原来的记忆。 制作人员： 原作：MADHOUSE、汤浅政明 脚本：三原三千夫、高桥知也、崔恩映、横山彰利 ","date":"2008-04-10","objectID":"/anime/kaiba/:1:0","tags":null,"title":"海马","uri":"/anime/kaiba/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 凯巴 海马、Kaiba 男 桑島法子 2 波波 Popo 男 朴璐美 3 内伊罗 Neiro 女 能登麻美子 4 クロニコ クロニコ、Chroniko 女 斎藤千和 5 バニラ バニラ、Vanilla 男 江川央生 6 キチ キチ、Kichi 男 岩永哲哉 7 カバ カバ、Kaba 男 ","date":"2008-04-10","objectID":"/anime/kaiba/:2:0","tags":null,"title":"海马","uri":"/anime/kaiba/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海马 2008-04-10 12 bilibili ","date":"2008-04-10","objectID":"/anime/kaiba/:3:0","tags":null,"title":"海马","uri":"/anime/kaiba/"},{"categories":null,"content":"在遥远的未来，一颗普通的行星上——\n由于人类的抵抗，机器人的贵族政治正走向灭亡。\n在与世隔绝的住宅中，两位机器人——Flügel公爵的女儿Drossel，及其管家Gedächtnis，展开了琐碎的“日常”对话。 ","date":"2008-04-07","objectID":"/anime/fireball/","tags":null,"title":"火球","uri":"/anime/fireball/"},{"categories":null,"content":"简介 在遥远的未来，一颗普通的行星上—— 由于人类的抵抗，机器人的贵族政治正走向灭亡。 在与世隔绝的住宅中，两位机器人——Flügel公爵的女儿Drossel，及其管家Gedächtnis，展开了琐碎的“日常”对话。 制作人员： 导演：荒川航 製作：迪士尼电影公司 CG 导演：渡边诚之 ","date":"2008-04-07","objectID":"/anime/fireball/:1:0","tags":null,"title":"火球","uri":"/anime/fireball/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 ゲデヒトニス Gedächtnis、ゲデヒトニス、Gedachtnis 男 2 多罗丝赛露 Drossel von Flügel、大小姐 女 川庄美雪 ","date":"2008-04-07","objectID":"/anime/fireball/:2:0","tags":null,"title":"火球","uri":"/anime/fireball/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 火球 2008-04-07 13 bilibili 2 火球 魅力之章 2011-04-04 13 bilibili 3 火球 幽默之章 2017-10-06 3 bilibili 4 火球最终章 2020-11-08 10 bilibili ","date":"2008-04-07","objectID":"/anime/fireball/:3:0","tags":null,"title":"火球","uri":"/anime/fireball/"},{"categories":null,"content":"在新宿开设事务所的少女麻生祗燐，不断地经历着不寻常的事件。在寻找猫的过程中，她无意发现一位记忆模糊的青年——前埜光辉。在帮助他寻找记忆的工程中，渐渐发现青山制药同此事件有着密切的联系。\n麻生祗燐混入青山制药的聚会试图寻找线索，不过神秘的暗杀者罗拉、美少年埃伯斯，以及青山制药的所长山之边沙耶罗，挡在了她的面前。","date":"2008-02-03","objectID":"/anime/daughters_of_mnemosyne/","tags":null,"title":"记忆女神的女儿们","uri":"/anime/daughters_of_mnemosyne/"},{"categories":null,"content":"简介 在新宿开设事务所的少女麻生祗燐，不断地经历着不寻常的事件。在寻找猫的过程中，她无意发现一位记忆模糊的青年——前埜光辉。在帮助他寻找记忆的工程中，渐渐发现青山制药同此事件有着密切的联系。 麻生祗燐混入青山制药的聚会试图寻找线索，不过神秘的暗杀者罗拉、美少年埃伯斯，以及青山制药的所长山之边沙耶罗，挡在了她的面前。 制作人员： 原作：Genco、XEBEC 导演：上田茂 脚本：大野木宽 分镜：榎本明广、网野哲郎 音乐：根岸贵幸 人物原案：中央东口 人物设定：石原满 ","date":"2008-02-03","objectID":"/anime/daughters_of_mnemosyne/:1:0","tags":null,"title":"记忆女神的女儿们","uri":"/anime/daughters_of_mnemosyne/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 麻生祇燐 斉藤珠樹、齐藤珠树、あそうぎ りん、Asougi Rin 女 能登麻美子 2 咪咪 美美、Mimi 女 釘宮理恵 3 罗拉 女 大原さやか 4 埃伯斯 Apos 石田彰 5 山之边沙耶罗 女 田中理恵 6 前埜光辉 前埜 光輝 男 檜山修之 7 柳原保 男 松本保典 8 前埜辉纪 男 平川大輔 ","date":"2008-02-03","objectID":"/anime/daughters_of_mnemosyne/:2:0","tags":null,"title":"记忆女神的女儿们","uri":"/anime/daughters_of_mnemosyne/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 记忆女神的女儿们 2008-02-03 6 樱花 ","date":"2008-02-03","objectID":"/anime/daughters_of_mnemosyne/:3:0","tags":null,"title":"记忆女神的女儿们","uri":"/anime/daughters_of_mnemosyne/"},{"categories":null,"content":"到处旅行靠贩卖一些小商品为生的商人罗兰斯，从因为收获祭而沸腾的帕斯洛耶村回来后却发现自己的运货马车中貌似有什么东西在里面，罗兰斯把麦束拨开一看，里面却睡着一只长有狼耳和狼尾巴的少女。这位少女自称是“掌控丰收的贤狼——赫萝”，靠麦子为生的她如果脖子上挂的帕斯洛耶麦子遗失了就会死。赫萝死赖着劳伦斯希望他能够带她回到遥远的北方故乡，于是，狼女与商人“完全没有剑与魔法的”旅行由此展开……","date":"2008-01-08","objectID":"/anime/spice_and_wolf/","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"简介 到处旅行靠贩卖一些小商品为生的商人罗兰斯，从因为收获祭而沸腾的帕斯洛耶村回来后却发现自己的运货马车中貌似有什么东西在里面，罗兰斯把麦束拨开一看，里面却睡着一只长有狼耳和狼尾巴的少女。这位少女自称是“掌控丰收的贤狼——赫萝”，靠麦子为生的她如果脖子上挂的帕斯洛耶麦子遗失了就会死。赫萝死赖着劳伦斯希望他能够带她回到遥远的北方故乡，于是，狼女与商人“完全没有剑与魔法的”旅行由此展开…… 制作人员： 原作：支仓冻砂 导演：高桥丈夫 脚本：荒川稔久 分镜：矢吹勉、岛津裕行、高本宣弘、中山正惠 演出：古谷田顺久 ","date":"2008-01-08","objectID":"/anime/spice_and_wolf/:1:0","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 赫萝 Холо、赫罗、Holo、ホロ、Holo、贤狼 女 小清水亜美 2 克拉福·罗伦斯 克拉福·劳伦斯、クラフト・ロレンス、Kraft Lawrence、罗兰斯、Крафт Лоурэнс 男 福山潤 3 库洛艾 クロエ、Chloe 女 名塚佳織 4 诺儿菈·艾伦 Norah Arendt、Nora Arendt、ノーラ・アレント 女 中原麻衣 5 列支敦·马贺特 Richten Marlheit、リヒテン・マールハイト 男 大塚芳忠 6 杰廉 ゼーレン 男 浪川大輔 ","date":"2008-01-08","objectID":"/anime/spice_and_wolf/:2:0","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 狼与香辛料 2008-01-08 13 樱花 2 狼与香辛料 第二季 2009-07-08 13 bilibili ","date":"2008-01-08","objectID":"/anime/spice_and_wolf/:3:0","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"MAD ","date":"2008-01-08","objectID":"/anime/spice_and_wolf/:4:0","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"从2008年1月5日开始进行首播的TV动画《死后文》，为观众展开了一幅前所未有的“死”之卷轴。主角是为现实世界中生存的人类邮送已经亡故的人们的书信（死后文）的文佳，还有她的伙伴——一枝会说话的手仗卡娜卡。这是一个紧紧围绕着死亡这个话题累积起来的一个个小故事，告诉观众自己存在的理由以及生存的意义，是一个抒情优美的故事。","date":"2008-01-05","objectID":"/anime/shigofumi/","tags":null,"title":"死后文","uri":"/anime/shigofumi/"},{"categories":null,"content":"简介 从2008年1月5日开始进行首播的TV动画《死后文》，为观众展开了一幅前所未有的“死”之卷轴。主角是为现实世界中生存的人类邮送已经亡故的人们的书信（死后文）的文佳，还有她的伙伴——一枝会说话的手仗卡娜卡。这是一个紧紧围绕着死亡这个话题累积起来的一个个小故事，告诉观众自己存在的理由以及生存的意义，是一个抒情优美的故事。 制作人员： 原作：汤泽友楼 导演：佐藤龙雄 脚本：大河内一楼 分镜：佐藤卓哉、小林常夫、下田正美、柳泽哲也、二瓶勇一 ","date":"2008-01-05","objectID":"/anime/shigofumi/:1:0","tags":null,"title":"死后文","uri":"/anime/shigofumi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 文伽 フミカ、Fumika 女 植田佳奈 2 美川文歌 みかわ ふみか 仙台エリ 3 卡娜卡 カナカ、カナカ、kanaka 女 松岡由貴 4 野岛要 野島 要、のじま かなめ 男 寺島拓篤 5 野岛辰巳 ノジ先生、野島 辰巳、のじま たつみ 男 野島昭生 6 清澄千章 Chiaki、清澄 千章、きよすみ ちあき、Kiyosumi Chiaki 女 浅野真澄 7 マトマ Matoma 男 加藤将之 8 葛西春乃 Kasai Haruno、かさい はるの 女 折笠富美子 ","date":"2008-01-05","objectID":"/anime/shigofumi/:2:0","tags":null,"title":"死后文","uri":"/anime/shigofumi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 死后文 2008-01-05 13 下方 ","date":"2008-01-05","objectID":"/anime/shigofumi/:3:0","tags":null,"title":"死后文","uri":"/anime/shigofumi/"},{"categories":null,"content":"少女“乃绘”因幼年的精神创伤而变得不会流泪，即使上了高中后这点还是依然如故……\n某天，乃绘在高校饲养的小动物不知道被谁残忍的杀害了。也就在那时，她结识了志愿成为绘本作家的仲上真一郎。在与真一郎的交往中，乃绘的心扉逐渐敞开，她的精神创伤能逐渐愈合吗……","date":"2008-01-05","objectID":"/anime/true_tears/","tags":null,"title":"真实之泪","uri":"/anime/true_tears/"},{"categories":null,"content":"简介 少女“乃绘”因幼年的精神创伤而变得不会流泪，即使上了高中后这点还是依然如故…… 某天，乃绘在高校饲养的小动物不知道被谁残忍的杀害了。也就在那时，她结识了志愿成为绘本作家的仲上真一郎。在与真一郎的交往中，乃绘的心扉逐渐敞开，她的精神创伤能逐渐愈合吗…… 制作人员： 原作：La’cryma 导演：西村纯二 脚本：森田真由美、冈田麿里 分镜：安藤真裕、山本秀世、川面真也 ","date":"2008-01-05","objectID":"/anime/true_tears/:1:0","tags":null,"title":"真实之泪","uri":"/anime/true_tears/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 仲上真一郎 なかがみ しんいちろう、Nakagami Shinichirou 男 石井真 2 石动乃绘 いするぎ のえ、Isurugi Noe 女 高垣彩陽 3 汤浅比吕美 ゆあさひろみ、Yuasa Hiromi 女 名塚佳織 4 安藤爱子 あんどう あいこ、Andou Aiko 女 井口裕香 5 野伏三代吉 のぶせ みよきち、Nobuse Miyokichi 男 吉野裕行 6 石动纯 いするぎ じゅん、Isurugi Jun 男 増田裕生 7 黑部朋与 くろべ ともよ 女 渡辺智美 8 仲上宗弘 なかがみ むねひろ 男 藤原啓治 ","date":"2008-01-05","objectID":"/anime/true_tears/:2:0","tags":null,"title":"真实之泪","uri":"/anime/true_tears/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 真实之泪 2008-01-05 13 bilibili ","date":"2008-01-05","objectID":"/anime/true_tears/:3:0","tags":null,"title":"真实之泪","uri":"/anime/true_tears/"},{"categories":null,"content":"MAD ","date":"2008-01-05","objectID":"/anime/true_tears/:4:0","tags":null,"title":"真实之泪","uri":"/anime/true_tears/"},{"categories":null,"content":"东京，冬季。\n青年佑太是一位胆小的青年，少女千鹤则是一位不走运的少女。二人都经历了多次不愉快的恋爱经历，而现在，他们在交往。\n这一天的约会，佑太打算向千鹤告白，而千鹤却打算提出分手以免被甩。正在双方欲言又止之时，佑太离席接听一通电话，而从佑太给千鹤的礼物中，居然突然蹦出一头小毛驴！\n淘气的小毛驴将千鹤的提包衔走，2人的约会计划彻底被打乱。这样的发展让两人措手不及，更给了两人重新审视这份爱情的机会。\n一只在东京大街上奔跑的小毛驴，牵动了恋爱中两人的心思。东京塔下的这段爱情，是否能有情人终成眷属呢？","date":"2007-12-19","objectID":"/anime/tokyo_marble_chocolate/","tags":null,"title":"东京糖衣巧克力","uri":"/anime/tokyo_marble_chocolate/"},{"categories":null,"content":"简介 东京，冬季。 青年佑太是一位胆小的青年，少女千鹤则是一位不走运的少女。二人都经历了多次不愉快的恋爱经历，而现在，他们在交往。 这一天的约会，佑太打算向千鹤告白，而千鹤却打算提出分手以免被甩。正在双方欲言又止之时，佑太离席接听一通电话，而从佑太给千鹤的礼物中，居然突然蹦出一头小毛驴！ 淘气的小毛驴将千鹤的提包衔走，2人的约会计划彻底被打乱。这样的发展让两人措手不及，更给了两人重新审视这份爱情的机会。 一只在东京大街上奔跑的小毛驴，牵动了恋爱中两人的心思。东京塔下的这段爱情，是否能有情人终成眷属呢？ 制作人员： 原作：Production I.G 导演：盐谷直义 脚本：尾崎将也 音乐：柳川刚","date":"2007-12-19","objectID":"/anime/tokyo_marble_chocolate/:1:0","tags":null,"title":"东京糖衣巧克力","uri":"/anime/tokyo_marble_chocolate/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 チヅル チヅル、Chizuru 女 水樹奈々 2 ミニロバ ミニロバ、Mini Roba 男 岩田光央 3 山田 Yamada、山田 男 中村悠一 4 タクヤ タクヤ、Takuya 男 岩田光央 5 广播 アナウンサー、Announcer、播音员、Announce 太田哲治 ","date":"2007-12-19","objectID":"/anime/tokyo_marble_chocolate/:2:0","tags":null,"title":"东京糖衣巧克力","uri":"/anime/tokyo_marble_chocolate/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 东京糖衣巧克力 2007-12-19 2 bilibili ","date":"2007-12-19","objectID":"/anime/tokyo_marble_chocolate/:3:0","tags":null,"title":"东京糖衣巧克力","uri":"/anime/tokyo_marble_chocolate/"},{"categories":null,"content":"剧场版《空之境界》改编自TYPE-MOON旗下作家奈须蘑菇的同名长篇小说。《空之境界》是著名作家、脚本家奈须蘑菇在\n1998年到1999年写作连载的轻小说， 插画由好友武内崇负责。那时的奈须与武内崇组成同人团体“竹帚”，后来随着TYPE-MOON的成立，\n著名作品《月姬》以及《Fate/stay night》引起巨大反响。 以这些为契机，《空之境界》推出了剧场版系列。\n作品以拥有直死之眼的两仪式与普通青年黑桐干也为中心，描绘了从两人高中邂逅开始的种种故事，\n在月世界的灰暗基调下，这残忍却又温馨的故事震撼了许多观众的心灵。","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"简介 剧场版《空之境界》改编自TYPE-MOON旗下作家奈须蘑菇的同名长篇小说。《空之境界》是著名作家、脚本家奈须蘑菇在 1998年到1999年写作连载的轻小说， 插画由好友武内崇负责。那时的奈须与武内崇组成同人团体“竹帚”，后来随着TYPE-MOON的成立， 著名作品《月姬》以及《Fate/stay night》引起巨大反响。 以这些为契机，《空之境界》推出了剧场版系列。 作品以拥有直死之眼的两仪式与普通青年黑桐干也为中心，描绘了从两人高中邂逅开始的种种故事， 在月世界的灰暗基调下，这残忍却又温馨的故事震撼了许多观众的心灵。 制作人员： 原作：奈须蘑菇 导演：青木英 脚本：平松正树 音乐：梶","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/:1:0","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 两仪式 兩儀 式、りょうぎ しき、Ryougi Shiki、214 女 坂本真綾 2 黑桐干也 Mikiya Kokutō、こくとう みきや、Kokutō Mikiya 男 鈴村健一 3 巫条雾绘 巫条霧絵、Fujou Kirie 女 田中理恵 4 苍崎橙子 あおざき とうこ、Aozaki Touko 女 本田貴子 5 荒耶宗莲 荒耶宗蓮、あらや そうれん、Araya Souren、大和尚 男 中田譲治 6 黑桐鲜花 こくとう あざか、Kokutou Azaka 女 藤村歩 ","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/:2:0","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 剧场版 空之境界 第一章 俯瞰风景 2007-12-01 1 bilibili 2 剧场版 空之境界 第二章 杀人考察（前） 2007-12-29 1 bilibili 3 剧场版 空之境界 第三章 痛觉残留 2008-02-09 1 bilibili 4 剧场版 空之境界 第四章 伽蓝之洞 2008-05-24 1 bilibili 5 剧场版 空之境界 第五章 矛盾螺旋 2008-08-16 1 bilibili 6 剧场版 空之境界 第六章 忘却录音 2008-12-20 1 bilibili 7 剧场版 空之境界 第七章 杀人考察（后）","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/:3:0","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"MAD ","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/:4:0","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"《Dead Fantasy》是由已故美籍亚裔动画制作师Monty Oum制作的系列同人3D动画， 片中角色主要来自角色扮演游戏《最终幻想》和格斗游戏《死或生》，\n本作品的名称也正来源于《Dead Or Alive》第一个单词和《Final Fantasy》的最后一个单词。 \n《Dead Fantasy》第一集发布于2007年10月15日，之后以“极其缓慢”的速度推出续集。\n\n2011年6月，网上已经出现了国外粉丝拍摄的《Dead Fantasy6》预览版，画质、人物效果都超越了前5集，相信不久6就与大众见面。\n在Monty的设想中，接下来的DF系列会有DF6、7、8、G、S。当然DF-G和DF-S被设想为一个分开的故事而非DF的主线。\nMonty之后在A-Kon 22上发表评论表示在DF10之前不会再提及莉诺雅的故事。然而随着Monty的过世，DF系列成为了真正的绝唱。","date":"2007-10-15","objectID":"/anime/dead_fantasy/","tags":null,"title":"死或生VS最终幻想","uri":"/anime/dead_fantasy/"},{"categories":null,"content":"简介 《Dead Fantasy》是由已故美籍亚裔动画制作师Monty Oum制作的系列同人3D动画， 片中角色主要来自角色扮演游戏《最终幻想》和格斗游戏《死或生》， 本作品的名称也正来源于《Dead Or Alive》第一个单词和《Final Fantasy》的最后一个单词。 《Dead Fantasy》第一集发布于2007年10月15日，之后以“极其缓慢”的速度推出续集。 2011年6月，网上已经出现了国外粉丝拍摄的《Dead Fantasy6》预览版，画质、人物效果都超越了前5集，相信不久6就与大众见面。 在Monty的设想中，接下来的DF系列会有DF6、7、8、G、S。当然DF-G和D","date":"2007-10-15","objectID":"/anime/dead_fantasy/:1:0","tags":null,"title":"死或生VS最终幻想","uri":"/anime/dead_fantasy/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 死或生VS最终幻想 2007-10-15 6 下方 ","date":"2007-10-15","objectID":"/anime/dead_fantasy/:2:0","tags":null,"title":"死或生VS最终幻想","uri":"/anime/dead_fantasy/"},{"categories":null,"content":"拥有用肉眼看见“菌”能力的少年泽木直保和青梅竹马结城萤进入农业大学所发生一连串的趣事，透过直保和其他人物的互动可以了解许多跟菌相关的知识，也因为直保的特殊能力而招惹许多事情……","date":"2007-10-11","objectID":"/anime/tales_of_agriculture/","tags":null,"title":"萌菌物语","uri":"/anime/tales_of_agriculture/"},{"categories":null,"content":"简介 拥有用肉眼看见“菌”能力的少年泽木直保和青梅竹马结城萤进入农业大学所发生一连串的趣事，透过直保和其他人物的互动可以了解许多跟菌相关的知识，也因为直保的特殊能力而招惹许多事情…… 制作人员： 原作：石川雅之 导演：矢野雄一郎 脚本：猪爪慎一、武上纯希、高桥奈津子 分镜：田头忍、镝木宏、渡边了 ","date":"2007-10-11","objectID":"/anime/tales_of_agriculture/:1:0","tags":null,"title":"萌菌物语","uri":"/anime/tales_of_agriculture/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 泽木惣右卫门直保 沢木惣右衛門直保、さわき そうえもん ただやす、Sawaki Souemon Tadayasu、泽木 男 阪口大助 2 结城萤 ゆうき けい 男 斎賀みつき 3 长谷川遥 はせがわ はるか、长谷川 大原さやか 4 树庆藏 樹慶蔵、Itsuki Keizou 男 西村知道 5 及川叶月 及川 葉月、おいかわ はづき、Oikawa Hazuki 女 神田朱未 6 川滨拓马 川浜拓馬、かわはま たくま、Kawahama Takuma 男 杉山紀彰 7 美里薰 みさと かおる 男 小西克幸 8 武藤葵 むとう あおい、武藤 女 能登麻美子 ","date":"2007-10-11","objectID":"/anime/tales_of_agriculture/:2:0","tags":null,"title":"萌菌物语","uri":"/anime/tales_of_agriculture/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 萌菌物语 2007-10-11 11 bilibili 2 萌菌物语 Returns 2012-07-05 11 bilibili ","date":"2007-10-11","objectID":"/anime/tales_of_agriculture/:3:0","tags":null,"title":"萌菌物语","uri":"/anime/tales_of_agriculture/"},{"categories":null,"content":"南春香是一个外表出色个性优秀的完美学生。在学校里，性格开朗温和的她是许多人爱慕的对象，保坂就是其中的一员。学校里流传着许多和春香有关的传说，她更是以“第一代首领”的名号著称。在妹妹南夏奈和南千秋的眼中，春香是一个母亲般的存在。夏奈是个四肢发达的运动型少女，个性活泼又有些迷糊的她是大家的开心果。可是在千秋眼中，夏奈是个十足的笨蛋，但这也恰恰是千秋表达爱意的特殊方式——毒舌。虽然外表冷漠行事老成，但千秋也有着意外细腻和幼稚的一面。南家的三个姐妹，各有各的特色，但三个人都是那么的善良和可爱，在小小的城市中，她们正展开着轻松又快乐的日常生活。","date":"2007-10-07","objectID":"/anime/minami-ke/","tags":null,"title":"南家三姐妹","uri":"/anime/minami-ke/"},{"categories":null,"content":"简介 南春香是一个外表出色个性优秀的完美学生。在学校里，性格开朗温和的她是许多人爱慕的对象，保坂就是其中的一员。学校里流传着许多和春香有关的传说，她更是以“第一代首领”的名号著称。在妹妹南夏奈和南千秋的眼中，春香是一个母亲般的存在。夏奈是个四肢发达的运动型少女，个性活泼又有些迷糊的她是大家的开心果。可是在千秋眼中，夏奈是个十足的笨蛋，但这也恰恰是千秋表达爱意的特殊方式——毒舌。虽然外表冷漠行事老成，但千秋也有着意外细腻和幼稚的一面。南家的三个姐妹，各有各的特色，但三个人都是那么的善良和可爱，在小小的城市中，她们正展开着轻松又快乐的日常生活。 制作人员： 原作：樱场小春 导演：太田雅彦 脚本：鸿","date":"2007-10-07","objectID":"/anime/minami-ke/:1:0","tags":null,"title":"南家三姐妹","uri":"/anime/minami-ke/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 南春香 みなみ はるか、Minami Haruka、ハルカ 女 佐藤利奈 2 南夏奈 南二、みなみ かな、Minami Kana、カナ 女 井上麻里奈 3 南千秋 南千秋、みなみ ちあき、Chiaki Minami 女 茅原実里 4 南冬马 Minami Touma 女 水樹奈々 5 藤冈 藤岡、Fujioka 男 柿原徹也 6 圭子 景子、ケイコ、Keiko 女 後藤沙緒里 7 利子 理子、Riko 女 高梁碧 8 真 真子、Makoto、マコちゃん 男 森永理科 ","date":"2007-10-07","objectID":"/anime/minami-ke/:2:0","tags":null,"title":"南家三姐妹","uri":"/anime/minami-ke/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 南家三姐妹 2007-10-07 13 bilibili 2 南家三姐妹 再来一碗 2008-01-06 13 bilibili 3 南家三姐妹 欢迎回来 2009-01-04 13 bilibili 4 南家三姐妹 我回来了 2013-01-05 13 bilibili ","date":"2007-10-07","objectID":"/anime/minami-ke/:3:0","tags":null,"title":"南家三姐妹","uri":"/anime/minami-ke/"},{"categories":null,"content":"MAD ","date":"2007-10-07","objectID":"/anime/minami-ke/:4:0","tags":null,"title":"南家三姐妹","uri":"/anime/minami-ke/"},{"categories":null,"content":"这是曾经因遭受地震和大火侵袭，而一度坍塌的街道——音羽。\n而这条街现在，犹如从欧洲的童话中飞出来一般，作为非常美丽的街景复苏了。\n就像是，将那不吉祥的灾难的记忆掩盖起来一般……。\n在这片重生的土地上，一个童话般的恋爱物语开始了…","date":"2007-10-06","objectID":"/anime/ef/","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"简介 这是曾经因遭受地震和大火侵袭，而一度坍塌的街道——音羽。 而这条街现在，犹如从欧洲的童话中飞出来一般，作为非常美丽的街景复苏了。 就像是，将那不吉祥的灾难的记忆掩盖起来一般……。 在这片重生的土地上，一个童话般的恋爱物语开始了… 制作人员： 原作：镜游、minori、御影 导演：大沼心 脚本：高山克彦 分镜：宫崎修治、石仓贤一、岛津裕行 ","date":"2007-10-06","objectID":"/anime/ef/:1:0","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫村宫子 宮村みやこ、みやむら みやこ、Miyamura Miyako 女 田口宏子 2 新藤景 Shindou Kei、新藤景、しんどう けい 女 岡田純子 3 新藤千寻 新藤 千尋、しんどう ちひろ、Shindou Chihiro 女 やなせなつみ 4 广野纮 Hirono Hiro、広野紘、ひろの ひろ 男 下野紘 5 堤京介 堤 京介、つつみ きょうすけ、Tsutsumi Kyousuke 男 泰勇気 6 麻生莲治 Asou Renji、麻生蓮治、あそう れんじ 男 高城元気 7 羽山瑞希 Hayama Mizuki、はやま みずき、未来 女 後藤麻","date":"2007-10-06","objectID":"/anime/ef/:2:0","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 悠久之翼 2007-10-06 12 bilibili 2 悠久之翼2 2008-10-06 12 bilibili ","date":"2007-10-06","objectID":"/anime/ef/:3:0","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"MAD ","date":"2007-10-06","objectID":"/anime/ef/:4:0","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"故事发生在一个小镇上，冈崎朋也是光坂高中在校生，因为家庭原因他一直过着浑浑噩噩的生活。他不参加任何社团活动，唯一的朋友是春原阳平。\n某天的上学途中，在樱花飞舞的坡道上，他邂逅了一名少女——古河渚，从此他的生活发生改变。渚因病休学一年，重返校园的她对周围环境感到相当不适应。她想加入戏剧部，然而戏剧部早已休部。朋也决定帮助她一起开展戏剧部的活动，二人关系变得越发亲密。随后不久朋也在图书馆中结识了一名天才少女一之濑琴美。","date":"2007-10-04","objectID":"/anime/clannad/","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"简介 故事发生在一个小镇上，冈崎朋也是光坂高中在校生，因为家庭原因他一直过着浑浑噩噩的生活。他不参加任何社团活动，唯一的朋友是春原阳平。 某天的上学途中，在樱花飞舞的坡道上，他邂逅了一名少女——古河渚，从此他的生活发生改变。渚因病休学一年，重返校园的她对周围环境感到相当不适应。她想加入戏剧部，然而戏剧部早已休部。朋也决定帮助她一起开展戏剧部的活动，二人关系变得越发亲密。随后不久朋也在图书馆中结识了一名天才少女一之濑琴美。 制作人员： 原作：Key、Visual Art’s 导演：石原立也 脚本：志茂文彦 分镜：武本康弘、高雄统子、米田光良、石立太一 ","date":"2007-10-04","objectID":"/anime/clannad/:1:0","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 冈崎朋也 岡崎朋也、Okazaki Tomoya 男 緒乃冬華 2 古河渚 冈崎渚、ふるかわ なぎさ、Furukawa Nagisa、小渚 女 中原麻衣 3 伊吹风子 いぶきふうこ、Ibuki Fuuko 女 野中藍 4 一之濑琴美 一ノ瀬 ことみ、いちのせ ことみ、Ichinose Kotomi 女 能登麻美子 5 藤林杏 ふじばやし きょう、Fujibayashi Kyou 女 広橋涼 6 坂上智代 さかがみともよ、Sakagami Tomoyo 女 桑島法子 7 藤林椋 ふじばやしりょう、Fujibayashi Ryou 女 神田朱未 8 春原阳平 春","date":"2007-10-04","objectID":"/anime/clannad/:2:0","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 CLANNAD 2007-10-04 23 bilibili 2 CLANNAD 另一个世界 智代篇 2008-07-16 1 bilibili 3 CLANNAD ～AFTER STORY～ 2008-10-02 24 bilibili 4 CLANNAD ～AFTER STORY～另一个世界 杏篇 2009-05-24 1 bilibili ","date":"2007-10-04","objectID":"/anime/clannad/:3:0","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"MAD ","date":"2007-10-04","objectID":"/anime/clannad/:4:0","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"　　故事从一艘黑夜中的赌船开始……\n　　男主角伊藤开司，浑浑噩噩，一事无成，因为好心替人做了担保而背负上了数百万债务。为偿还欠款，开司接受怂恿上了一艘名为“希望之船”的渡轮，为的是参加一次神秘赌局——一旦获胜，就能将欠款一笔勾销。登上渡船后开司才发现，参与者多是如自己一般的失败青年。然后主办方便开出了赌局的规则：参与者须以标着“石头，剪刀，布”的扑克为道具，夺取对手身上的星星标志，赌局结束时，扑克牌未用完或星星少于三颗者将失去资格，而参赛初所能向主办方借贷的巨款，也成为让他们盈利或逃生的重要因素……\n　　绝境下，开司极限究竟何在？！\n\n　　动画版相当于原作第一部的内容。主要声优和STAFF中许多人曾参与了原作者的另一部作品《闘牌伝説アカギ》的动画版制作。\n　　虽然作品中的过激言行被放送局自主规制而压抑了作品的演出，但福本作品中非常有特点的表现手法如「ざわ…」等都由BGM和背景图以及效果音予以了出色的演出。动画最后设有「カイジ箴言」一栏目，出演者为阪本麻美。","date":"2007-10-02","objectID":"/anime/kaiji/","tags":null,"title":"赌博默示录","uri":"/anime/kaiji/"},{"categories":null,"content":"简介 故事从一艘黑夜中的赌船开始…… 男主角伊藤开司，浑浑噩噩，一事无成，因为好心替人做了担保而背负上了数百万债务。为偿还欠款，开司接受怂恿上了一艘名为“希望之船”的渡轮，为的是参加一次神秘赌局——一旦获胜，就能将欠款一笔勾销。登上渡船后开司才发现，参与者多是如自己一般的失败青年。然后主办方便开出了赌局的规则：参与者须以标着“石头，剪刀，布”的扑克为道具，夺取对手身上的星星标志，赌局结束时，扑克牌未用完或星星少于三颗者将失去资格，而参赛初所能向主办方借贷的巨款，也成为让他们盈利或逃生的重要因素…… 绝境下，开司极限究竟何在？！ 动画版相当于原作第一部的内容。主要声优和STAFF中许多人曾参与了","date":"2007-10-02","objectID":"/anime/kaiji/:1:0","tags":null,"title":"赌博默示录","uri":"/anime/kaiji/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊藤开司 伊藤開司、Itou Kaiji 男 萩原聖人 2 旁白 ナレーター、解説、Narration/Narrator、Nareeshon、天之声、páng bái 立木文彦 3 兵藤和尊 会長、会长、ひょうどう かずたか 男 津嘉山正種 4 石田光司 いしだ こうじ 男 家中宏 5 古畑武志 ふるはた たけし 男 松本保典 6 安藤守 あんどう まもる 男 桜井敏治 7 船井让次 ふない じょうじ 男 石川英郎 8 北见 男 矢尾一樹 ","date":"2007-10-02","objectID":"/anime/kaiji/:2:0","tags":null,"title":"赌博默示录","uri":"/anime/kaiji/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 赌博默示录 2007-10-02 26 bilibili 2 赌博默示录 破戒录篇 2011-04-05 26 bilibili 3 中间管理录利根川 2018-07-03 24 bilibili ","date":"2007-10-02","objectID":"/anime/kaiji/:3:0","tags":null,"title":"赌博默示录","uri":"/anime/kaiji/"},{"categories":null,"content":"MAD ","date":"2007-10-02","objectID":"/anime/kaiji/:4:0","tags":null,"title":"赌博默示录","uri":"/anime/kaiji/"},{"categories":null,"content":"主人公日高佐菜是一位正在念公立高中的的16岁少年。\n他在小学五年级以前一直生活的小镇因为父母的工作关系而搬家到东京。\n然后，在上高中二年时…再次回到这个小镇…故事就在那里开始——\n\n曾经是初恋对象的少女，过去那闪亮的瞳孔…\n记忆跟现实的之间…或许就是一个鸿沟…\n各种各样的东西…不断地在他面前出现…然后消失…\n各种各样的变化，如同尖刺一样刺向他的心\n出现在少年的眼中的人，物，事件，回忆…\n在已经过去的时间里，在新的学园生活中，他失去了什么，得到了什么。\n\n我本身，你本身\n原来的我，原来的你\n我还是我，你还是你\n生活在这个世界，当发觉谁跟自己很相符…\n他的人生踏进了新的一步…","date":"2007-10-02","objectID":"/anime/myself_yourself/","tags":null,"title":"我自己；你自己","uri":"/anime/myself_yourself/"},{"categories":null,"content":"简介 主人公日高佐菜是一位正在念公立高中的的16岁少年。 他在小学五年级以前一直生活的小镇因为父母的工作关系而搬家到东京。 然后，在上高中二年时…再次回到这个小镇…故事就在那里开始—— 曾经是初恋对象的少女，过去那闪亮的瞳孔… 记忆跟现实的之间…或许就是一个鸿沟… 各种各样的东西…不断地在他面前出现…然后消失… 各种各样的变化，如同尖刺一样刺向他的心 出现在少年的眼中的人，物，事件，回忆… 在已经过去的时间里，在新的学园生活中，他失去了什么，得到了什么。 我本身，你本身 原来的我，原来的你 我还是我，你还是你 生活在这个世界，当发觉谁跟自己很相符… 他的人生踏进了新的一步… 制作人员： 原作：","date":"2007-10-02","objectID":"/anime/myself_yourself/:1:0","tags":null,"title":"我自己；你自己","uri":"/anime/myself_yourself/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 日高佐菜 ひだか さな、Hidaka Sana 男 立花慎之介 2 八代菜菜香 やつしろ ななか、Yatsushiro Nanaka 女 小清水亜美 3 若月朱里 わかつき しゅり、Wakatsuki Shuuri 女 田村ゆかり 4 若月修辅 わかつき しゅうすけ、Wakatsuki Shūsuke 男 子安武人 5 藤村柚希 ふじむら ゆずき、Fujimura Yuzuki 女 豊口めぐみ 6 织部麻绪衣 おりべ あおい、Oribe Aoi 女 金田朋子 7 星野爱沙美 ほしの あさみ、Hoshino Asami 女 中原麻衣 8 持田雏子 もちだ ひな","date":"2007-10-02","objectID":"/anime/myself_yourself/:2:0","tags":null,"title":"我自己；你自己","uri":"/anime/myself_yourself/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我自己；你自己 2007-10-02 13 bilibili ","date":"2007-10-02","objectID":"/anime/myself_yourself/:3:0","tags":null,"title":"我自己；你自己","uri":"/anime/myself_yourself/"},{"categories":null,"content":"室江高中剑道社的指导老师石田虎侍是个为了明天伙食费而伤透脑筋，既没干劲又没钱的老师。有一天，因为答应和石桥前辈所带领的女子剑道社进行团体练习赛，而开始与剑道社社长千叶纪梨乃，以及新加入的男学员（中田勇次、荣花段十朗）一起力劝女生入社。\n经历了种种事件之后，出身剑道道场的独生女—实力不凡的川添珠姬、荣花的女友—初学者宫崎都加入剑道社，幽灵社员—桑原鞘子也回归社团，社员们开始了积极的赛前练习。即便如此，随着比赛日期一天天临近，剑道社仍然缺少一人，达不到五名参赛队员的要求。\n面对迫在眉睫的比赛，小次郎有什么妙计吗？而练习比赛的真正目的又是什么呢？\n这是一部以搞笑的笔调描绘女孩们通过社团活动而得以成长的青春系学园剑道故事。","date":"2007-10-01","objectID":"/anime/bamboo_blade/","tags":null,"title":"竹刀少女","uri":"/anime/bamboo_blade/"},{"categories":null,"content":"简介 室江高中剑道社的指导老师石田虎侍是个为了明天伙食费而伤透脑筋，既没干劲又没钱的老师。有一天，因为答应和石桥前辈所带领的女子剑道社进行团体练习赛，而开始与剑道社社长千叶纪梨乃，以及新加入的男学员（中田勇次、荣花段十朗）一起力劝女生入社。 经历了种种事件之后，出身剑道道场的独生女—实力不凡的川添珠姬、荣花的女友—初学者宫崎都加入剑道社，幽灵社员—桑原鞘子也回归社团，社员们开始了积极的赛前练习。即便如此，随着比赛日期一天天临近，剑道社仍然缺少一人，达不到五名参赛队员的要求。 面对迫在眉睫的比赛，小次郎有什么妙计吗？而练习比赛的真正目的又是什么呢？ 这是一部以搞笑的笔调描绘女孩们通过社团活动而得","date":"2007-10-01","objectID":"/anime/bamboo_blade/:1:0","tags":null,"title":"竹刀少女","uri":"/anime/bamboo_blade/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 川添珠姬 川添 珠姫、Kawazoe Tamaki 女 広橋涼 2 千叶纪梨乃 千葉 紀梨乃、ちば きりの、Chiba Kirino 女 豊口めぐみ 3 桑原鞘子 桑原 鞘子、Kuwahara Sayako 女 小島幸子 4 宫崎都 宮崎 都、みやざき みやこ、Miyazaki Miyako、MIYAMIYA 女 桑島法子 5 东聪莉 東 聡莉、Azuma Satori 女 佐藤利奈 6 石田虎侍 石田 虎侍、Ishida Toraji、コジロー 男 小西克幸 7 中田勇次 なかた ゆうじ、ユージ 男 阪口大助 8 荣花段十朗 栄花 段十朗、えいが だんじゅ","date":"2007-10-01","objectID":"/anime/bamboo_blade/:2:0","tags":null,"title":"竹刀少女","uri":"/anime/bamboo_blade/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 竹刀少女 2007-10-01 26 9anime ","date":"2007-10-01","objectID":"/anime/bamboo_blade/:3:0","tags":null,"title":"竹刀少女","uri":"/anime/bamboo_blade/"},{"categories":null,"content":"　　在天下失序、列强割据的战乱时代，僧人祥庵将一名孤儿从中国带到了日本。孤儿名叫仔太郎，他背负着一个惊人的秘密。与祥庵失散后，孤苦无依的仔太郎带着爱犬飞丸前往赤池之国的万觉寺，在途中遇见了神秘剑士“无名”。仔太郎遭到追杀，危急时刻无名救了他一命。从此两人结伴同行。性格乖僻的浪人和紧闭心扉的少年虽然磕磕碰碰不断，但渐渐成了好朋友。\n　　白鸾率领的追杀组织还是抓住了仔太郎，他们开始着手筹备某种仪式。金发碧眼的剑士“罗狼”也是追杀组织中的一员，他虽然听命行事但并不真正在意组织的目的，对他来说，寻找可以与自己匹敌的对手才是生命的意义。罗狼与无名之间的生死对决拉开了帷幕……","date":"2007-09-29","objectID":"/anime/sword_of_the_stranger/","tags":null,"title":"异邦人 无皇刃谭","uri":"/anime/sword_of_the_stranger/"},{"categories":null,"content":"简介 在天下失序、列强割据的战乱时代，僧人祥庵将一名孤儿从中国带到了日本。孤儿名叫仔太郎，他背负着一个惊人的秘密。与祥庵失散后，孤苦无依的仔太郎带着爱犬飞丸前往赤池之国的万觉寺，在途中遇见了神秘剑士“无名”。仔太郎遭到追杀，危急时刻无名救了他一命。从此两人结伴同行。性格乖僻的浪人和紧闭心扉的少年虽然磕磕碰碰不断，但渐渐成了好朋友。 白鸾率领的追杀组织还是抓住了仔太郎，他们开始着手筹备某种仪式。金发碧眼的剑士“罗狼”也是追杀组织中的一员，他虽然听命行事但并不真正在意组织的目的，对他来说，寻找可以与自己匹敌的对手才是生命的意义。罗狼与无名之间的生死对决拉开了帷幕…… 制作人员： 原作：骨头社 导演","date":"2007-09-29","objectID":"/anime/sword_of_the_stranger/:1:0","tags":null,"title":"异邦人 无皇刃谭","uri":"/anime/sword_of_the_stranger/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 无名 无名氏、ななし 男 長瀬智也 2 仔太郎 仔太郎、Kotarou 男 知念侑李 3 罗狼 男 山寺宏一 ","date":"2007-09-29","objectID":"/anime/sword_of_the_stranger/:2:0","tags":null,"title":"异邦人 无皇刃谭","uri":"/anime/sword_of_the_stranger/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 异邦人 无皇刃谭 2007-09-29 102m bilibili ","date":"2007-09-29","objectID":"/anime/sword_of_the_stranger/:3:0","tags":null,"title":"异邦人 无皇刃谭","uri":"/anime/sword_of_the_stranger/"},{"categories":null,"content":"　　就快放暑假了，小学生上原康一在放学回家的路上捡到一块大石头。他把石头带回了家，没想到用水一洗，里面竟跳出一只小河童来。小河童对他“咕”的叫了一声，于是康一就给它取名为“小咕”。\n　　小咕会说人类的语言，几百年来他一直被埋在在地下。康一很快就和小咕成了好朋友，他们一起洗澡，一起吃饭，一起睡觉。而其它家庭成员也接受了小咕，小河童成了上原一家的秘密。\n　　一天，小咕提出想回家和伙伴们在一起。康一为了让小咕了解外面的世界，悄悄把它带了出去。小咕发现环境已经面目全非，大吃了一惊，这个不适合就河童生存的地方根本就找不到伙伴。看到小咕难过，康一也不好受。他和小咕一起外出旅行，来到了还保存着河童传说的远野县。两人在美丽的大自然中找到了适合河童生活的地方，小咕愉快地在清澈的河里游了起来，康一也为它高兴。可是，在这里也怎么都找不到其它河童。康一听到村民们说“抓住一只河童能得一千万呢！”，赶忙带着小咕离开了那里。\n　　回到家，康一讶异地撞见了一个小报记者。原来那人听说上原家养着一只河童，一定要拍照。小咕的秘密终于被大家知道了。康一的爸爸被公司勒令一定要让河童上电视。为了上原一家，小咕答应参加电视节目。然而在到场嘉宾里，它看到了一个长得很像杀父凶手的人。就在小咕被恐惧包围的时候，电视节目现场发生了意外。它拼命逃到了外面，然而无论跑到哪里都会看到黑压压的人群。\n　　为了摆脱让它害怕的人类，小咕爬上了东京塔。夏季的烈日照得它精疲力竭。小咕俯瞰着城市，独自低语道：“哪里都找不到一个安静的地方，这里是人类的窝。我已经不行了。我要去爸爸那里……”","date":"2007-07-28","objectID":"/anime/summer_days_with_coo/","tags":null,"title":"河童之夏","uri":"/anime/summer_days_with_coo/"},{"categories":null,"content":"简介 就快放暑假了，小学生上原康一在放学回家的路上捡到一块大石头。他把石头带回了家，没想到用水一洗，里面竟跳出一只小河童来。小河童对他“咕”的叫了一声，于是康一就给它取名为“小咕”。 小咕会说人类的语言，几百年来他一直被埋在在地下。康一很快就和小咕成了好朋友，他们一起洗澡，一起吃饭，一起睡觉。而其它家庭成员也接受了小咕，小河童成了上原一家的秘密。 一天，小咕提出想回家和伙伴们在一起。康一为了让小咕了解外面的世界，悄悄把它带了出去。小咕发现环境已经面目全非，大吃了一惊，这个不适合就河童生存的地方根本就找不到伙伴。看到小咕难过，康一也不好受。他和小咕一起外出旅行，来到了还保存着河童传说的远野县。两","date":"2007-07-28","objectID":"/anime/summer_days_with_coo/:1:0","tags":null,"title":"河童之夏","uri":"/anime/summer_days_with_coo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 河童之夏 2007-07-28 1 bilibili ","date":"2007-07-28","objectID":"/anime/summer_days_with_coo/:2:0","tags":null,"title":"河童之夏","uri":"/anime/summer_days_with_coo/"},{"categories":null,"content":"　　1711年在大西洋上，背井离乡的炼金术师们从恶魔手中得到了一样东西——那便是永生之酒。为了独占永生之酒的配方，在秘密之船上的众人开始互相残杀。1930年代的纽约的黑道中，年少有为的菲洛、傻瓜盗贼夫妇、200年老不死的炼金术士和他的助手，以及菲洛从小的玩伴、豪门千金、恐怖组织成员、年轻的列车长……这一群原本毫不相干的人却因永生之酒的复苏让他们的命运开始复杂交错起来。\n　　以纽约作为目的地，从芝加哥出发穿越美洲大陆的列车上，命运之轮将所有人聚集到了一起。而在这辆列车上的不仅仅是“人类”而已。传说中的幽灵再次出现，车上的旅客从最后一节车厢开始一个一个接连消失……","date":"2007-07-26","objectID":"/anime/baccano/","tags":null,"title":"永生之酒","uri":"/anime/baccano/"},{"categories":null,"content":"简介 1711年在大西洋上，背井离乡的炼金术师们从恶魔手中得到了一样东西——那便是永生之酒。为了独占永生之酒的配方，在秘密之船上的众人开始互相残杀。1930年代的纽约的黑道中，年少有为的菲洛、傻瓜盗贼夫妇、200年老不死的炼金术士和他的助手，以及菲洛从小的玩伴、豪门千金、恐怖组织成员、年轻的列车长……这一群原本毫不相干的人却因永生之酒的复苏让他们的命运开始复杂交错起来。 以纽约作为目的地，从芝加哥出发穿越美洲大陆的列车上，命运之轮将所有人聚集到了一起。而在这辆列车上的不仅仅是“人类”而已。传说中的幽灵再次出现，车上的旅客从最后一节车厢开始一个一个接连消失…… 制作人员： 原作：成田良悟 导演：","date":"2007-07-26","objectID":"/anime/baccano/:1:0","tags":null,"title":"永生之酒","uri":"/anime/baccano/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 克雷亚·斯坦菲尔德 フェリックス・ウォーケン、Claire Standfield 男 森田成一 2 艾萨克·迪安 Issac Dian、アイザック・ディアン、アイザック・ディアン 男 小野坂昌也 3 蜜莉亚·哈文德 Miria Harvent 女 あおきさやか 4 菲洛·普罗辛琪奥 费洛・普罗宣查、Firo Prochainezo、フィーロ・プロシェンツォ、フィーロ・プロシェンツォ、fiiro puroshyentsu、Firo 男 吉野裕行 5 修伊·拉弗雷特 Huey Laforet 男 千葉進歩 6 拉克.甘多鲁 Luck Gandor 男 子安武人 ","date":"2007-07-26","objectID":"/anime/baccano/:2:0","tags":null,"title":"永生之酒","uri":"/anime/baccano/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 永生之酒 2007-07-26 16 bilibili ","date":"2007-07-26","objectID":"/anime/baccano/:3:0","tags":null,"title":"永生之酒","uri":"/anime/baccano/"},{"categories":null,"content":"　　故事主要讲述日本天才钢琴家阿宇野因为意外而导致手部受伤，至不能在钢琴上攀上世界的高峰，在心灰意冷之下， 阿宇野抛弃了他的钢琴。殊不知被弃在森林里的钢琴郤为一小孩发现，而小孩慢慢与钢琴发展出深厚感情， 在缘份的牵引下，阿字野发现这小孩便是自己的学生海，最令他惊讶的是，海竟透过森林中的钢琴孕育出天才的音乐感，那是能在世界发光发热的音乐感，阿宇野决定把海带到世界去…","date":"2007-07-21","objectID":"/anime/the_piano_forest/","tags":null,"title":"钢琴之森","uri":"/anime/the_piano_forest/"},{"categories":null,"content":"简介 故事主要讲述日本天才钢琴家阿宇野因为意外而导致手部受伤，至不能在钢琴上攀上世界的高峰，在心灰意冷之下， 阿宇野抛弃了他的钢琴。殊不知被弃在森林里的钢琴郤为一小孩发现，而小孩慢慢与钢琴发展出深厚感情， 在缘份的牵引下，阿字野发现这小孩便是自己的学生海，最令他惊讶的是，海竟透过森林中的钢琴孕育出天才的音乐感，那是能在世界发光发热的音乐感，阿宇野决定把海带到世界去… 制作人员： 原作：一色真人 导演：小岛正幸 脚本：蓬莱龙太 分镜：矢野雄一郎、佐藤雄三、增田敏彦、富泽信雄 演出：吉野智美 ","date":"2007-07-21","objectID":"/anime/the_piano_forest/:1:0","tags":null,"title":"钢琴之森","uri":"/anime/the_piano_forest/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 一之濑海 一ノ瀬海、Ichinose Kai 男 上戸彩 2 雨宫修平 男 神木隆之介 3 阿字野壮介 Ajino Sousuke、アジノ 男 宮迫博之 4 丸山誉子 まるやま たかこ、Maruyama Takako 女 福田麻由子 5 雨宫奈美恵 あまみや なみえ、Amamiya Namie 女 田中敦子 6 金平大学 かねひら だいがく、Kanehira Daigaku、キンピラ 男 松本梨香 7 一之濑怜子 いちのせ れいこ、Ichinose Reiko 女 池脇千鶴 ","date":"2007-07-21","objectID":"/anime/the_piano_forest/:2:0","tags":null,"title":"钢琴之森","uri":"/anime/the_piano_forest/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 钢琴之森 2007-07-21 1 樱花 ","date":"2007-07-21","objectID":"/anime/the_piano_forest/:3:0","tags":null,"title":"钢琴之森","uri":"/anime/the_piano_forest/"},{"categories":null,"content":"江户初期，天下太平。\n应大纳言德川忠长的命令，一直都是以木剑来进行的殿前比武改为使用真剑。参加这一场比武的是岩本虎眼道场的同门——独臂的藤木源之助和盲眼的伊良子清玄。\n究竟谁才可以站在武士道的顶点？残酷的命运开始了……","date":"2007-07-19","objectID":"/anime/shigurui/","tags":null,"title":"剑豪生死斗","uri":"/anime/shigurui/"},{"categories":null,"content":"简介 江户初期，天下太平。 应大纳言德川忠长的命令，一直都是以木剑来进行的殿前比武改为使用真剑。参加这一场比武的是岩本虎眼道场的同门——独臂的藤木源之助和盲眼的伊良子清玄。 究竟谁才可以站在武士道的顶点？残酷的命运开始了…… 制作人员： 原作：南条范夫、山口贵由 导演：滨崎博嗣 脚本：水上清资 分镜：福田道生、平尾隆之、驹井一也、香月邦夫 ","date":"2007-07-19","objectID":"/anime/shigurui/:1:0","tags":null,"title":"剑豪生死斗","uri":"/anime/shigurui/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤木源之助 ふじき げんのすけ、Fujiki Gennosuke 男 浪川大輔 2 伊良子清玄 いらこ せいげん、Irako Seigen 男 佐々木望 3 郁 Iku 女 篠原恵美 4 岩本三重 いわもと みえ、Iwamoto Mie 女 桑島法子 5 岩本虎眼 いわもと こがん、Iwamoto Kogan 男 矢尾一樹 ","date":"2007-07-19","objectID":"/anime/shigurui/:2:0","tags":null,"title":"剑豪生死斗","uri":"/anime/shigurui/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 剑豪生死斗 2007-07-19 12 樱花 ","date":"2007-07-19","objectID":"/anime/shigurui/:3:0","tags":null,"title":"剑豪生死斗","uri":"/anime/shigurui/"},{"categories":null,"content":"有一位在各地旅行并且携带斩魔剑斩除「妖怪」的卖药郎。\n\n只要在他以及剑的呼唤下，在卖药男的面前就会出现一个又一个妖怪。\n\n在那些因为恐惧而要求除去妖怪的人们的请求下，他会拿出这把剑并且告知人们，他需要清楚找出关于妖怪的三种要素：分别是因为人的因果，所形成的缘份（えにし）即是「形（かたち）」、事情的真相「真（まこと）」、心中的隐情「理（ことわり）」才能加以消灭。\n\n就在这个除妖之旅上，他前往的地方，也就是各式各样所谓的「人世」。并且在完成使命后，又忽然消失于大家眼前……。","date":"2007-07-12","objectID":"/anime/mononoke/","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"简介 有一位在各地旅行并且携带斩魔剑斩除「妖怪」的卖药郎。 只要在他以及剑的呼唤下，在卖药男的面前就会出现一个又一个妖怪。 在那些因为恐惧而要求除去妖怪的人们的请求下，他会拿出这把剑并且告知人们，他需要清楚找出关于妖怪的三种要素：分别是因为人的因果，所形成的缘份（えにし）即是「形（かたち）」、事情的真相「真（まこと）」、心中的隐情「理（ことわり）」才能加以消灭。 就在这个除妖之旅上，他前往的地方，也就是各式各样所谓的「人世」。并且在完成使命后，又忽然消失于大家眼前……。 制作人员： 导演：中村健治 脚本：小中千昭、横手美智子、石川学、高桥郁子 分镜：山崎浩司、石黑育、梅泽淳稔、植田秀仁 ","date":"2007-07-12","objectID":"/anime/mononoke/:1:0","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 卖药郎 Medicine Seller、Kusuriuri、薬売り 男 櫻井孝宏 2 加世 かよ 女 ゆかな ","date":"2007-07-12","objectID":"/anime/mononoke/:2:0","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 怪化猫 2007-07-12 12+3 bilibili ","date":"2007-07-12","objectID":"/anime/mononoke/:3:0","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"MAD ","date":"2007-07-12","objectID":"/anime/mononoke/:4:0","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"著名动画制作公司STUDIO4℃的新作电影《GENIUS PARTY》，日前决定公映日为7月7日，放映剧场被安排在Cine Libre池袋、涩谷Cine Amuse等，日本全国依次预定展开。 《GENIUS PARTY》是由7个短篇组成的电影作品，福岛敦子、河森正治、木村真二、福山庸治、二村秀树、汤浅政明、渡边信一郎等人分别担任监督。 同时，音乐制片人由渡边信一郎先生担任。负责音乐的还有中川俊郎、山本精一、渡边琢磨、FENNESZ、竹村信和、菅野洋子等在娱乐领域一流的艺术家，这也让大家期待达到了前所未有的高度。 声优方面，在戛纳国际电影节获得最优秀奖的柳乐优也，凭借《巴别塔》被奥斯卡金像奖提名的菊池凛子，《蒙面超人响鬼》的栩原乐人、小仓久宽、三上博史等都将参加演出。 《GENIUS PARTY》的第2弹预定在2008年公开，同样仍将是由7位著名监督的短篇作品组成的形式。","date":"2007-07-07","objectID":"/anime/genius_party/","tags":null,"title":"天才嘉年华","uri":"/anime/genius_party/"},{"categories":null,"content":"简介 著名动画制作公司STUDIO4℃的新作电影《GENIUS PARTY》，日前决定公映日为7月7日，放映剧场被安排在Cine Libre池袋、涩谷Cine Amuse等，日本全国依次预定展开。 《GENIUS PARTY》是由7个短篇组成的电影作品，福岛敦子、河森正治、木村真二、福山庸治、二村秀树、汤浅政明、渡边信一郎等人分别担任监督。 同时，音乐制片人由渡边信一郎先生担任。负责音乐的还有中川俊郎、山本精一、渡边琢磨、FENNESZ、竹村信和、菅野洋子等在娱乐领域一流的艺术家，这也让大家期待达到了前所未有的高度。 声优方面，在戛纳国际电影节获得最优秀奖的柳乐优也，凭借《巴别塔》被奥斯卡金像","date":"2007-07-07","objectID":"/anime/genius_party/:1:0","tags":null,"title":"天才嘉年华","uri":"/anime/genius_party/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天才嘉年华 2007-07-07 7 bilibili 2 天才嘉年华BEYOND 2008-10-11 5 bilibili ","date":"2007-07-07","objectID":"/anime/genius_party/:2:0","tags":null,"title":"天才嘉年华","uri":"/anime/genius_party/"},{"categories":null,"content":"MAD ","date":"2007-07-07","objectID":"/anime/genius_party/:3:0","tags":null,"title":"天才嘉年华","uri":"/anime/genius_party/"},{"categories":null,"content":"主人公『伊藤诚』已经有了心上人，并偷偷地把那个女孩子的照片作为手机的待机图片一直带在身边。她就是隔壁班级的『桂言叶』。她一直与诚经过同样的铁路沿线，乘坐同一时刻的电车，因而诚渐渐地喜欢上了她。所以每天的上学、放学时间成了诚的唯一乐趣。\n\n但是某天，诚的手机待机图片被同桌『西园寺世界』看见了。此时学校正流行着一种说法，那就是把心上人的照片作为手机的待机图片3个星期并且不被别人看见，就可以实现梦想（成为恋人）等等诸如此类的说法。诚正是偶然听到了这些话才偷偷地许下了这个愿望。\n\n围绕校园展开的三角恋即将开始。","date":"2007-07-03","objectID":"/anime/school_days/","tags":null,"title":"日在校园","uri":"/anime/school_days/"},{"categories":null,"content":"简介 主人公『伊藤诚』已经有了心上人，并偷偷地把那个女孩子的照片作为手机的待机图片一直带在身边。她就是隔壁班级的『桂言叶』。她一直与诚经过同样的铁路沿线，乘坐同一时刻的电车，因而诚渐渐地喜欢上了她。所以每天的上学、放学时间成了诚的唯一乐趣。 但是某天，诚的手机待机图片被同桌『西园寺世界』看见了。此时学校正流行着一种说法，那就是把心上人的照片作为手机的待机图片3个星期并且不被别人看见，就可以实现梦想（成为恋人）等等诸如此类的说法。诚正是偶然听到了这些话才偷偷地许下了这个愿望。 围绕校园展开的三角恋即将开始。 制作人员： 原作：Overflow 导演：元永庆太郎 脚本：日暮茶坊、上江洲诚、秋月ひろ","date":"2007-07-03","objectID":"/anime/school_days/:1:0","tags":null,"title":"日在校园","uri":"/anime/school_days/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊藤诚 诚哥、人渣诚、伊藤 誠、いとう まこと、Itou Makoto 男 平川大輔 2 西园寺世界 さいおんじせかい、Saionji Sekai 女 河原木志穂 3 桂言叶 かつら ことのは、Katsura Kotonoha 女 岡嶋妙 4 清浦刹那 きようらせつな、Kiyoura Setsuna 女 井本ケイ 5 甘露寺七海 甘露寺 七海、かんろじななみ、Kanroji Nanami 女 たかはし智秋 6 黑田光 黒田 光、くろだ ひかり、Kuroda Hikari 女 田中涼子 7 加藤乙女 加藤 乙女、かとう おとめ、Katou Otome 女 永見","date":"2007-07-03","objectID":"/anime/school_days/:2:0","tags":null,"title":"日在校园","uri":"/anime/school_days/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 日在校园 2007-07-03 12 樱花 ","date":"2007-07-03","objectID":"/anime/school_days/:3:0","tags":null,"title":"日在校园","uri":"/anime/school_days/"},{"categories":null,"content":"近未来的纽约，在荒凉的曼哈顿岛上出现了一个男人。他的名字叫科林麦克劳德。身为不死者的他，只要不被斩首就不会死。他在两千多年间经历无数次的生死轮回，一直追赶着杀害他爱妻的宿敌马库斯。另一方面，在纽约地下抵抗组织工作的女子达丽雅，为拯救被流行病毒所威胁的同胞，决定前往军阀居住的巨塔夺取疫苗。在偶然的情况下，科林与达丽雅相遇了。在得知城市的统治者是马库斯之后，他和达丽雅怀着共同的目标一起闯进了城市的巨塔，开始了生死难料的行动。","date":"2007-06-05","objectID":"/anime/highlander/","tags":null,"title":"高地人 复仇之旅","uri":"/anime/highlander/"},{"categories":null,"content":"简介 近未来的纽约，在荒凉的曼哈顿岛上出现了一个男人。他的名字叫科林麦克劳德。身为不死者的他，只要不被斩首就不会死。他在两千多年间经历无数次的生死轮回，一直追赶着杀害他爱妻的宿敌马库斯。另一方面，在纽约地下抵抗组织工作的女子达丽雅，为拯救被流行病毒所威胁的同胞，决定前往军阀居住的巨塔夺取疫苗。在偶然的情况下，科林与达丽雅相遇了。在得知城市的统治者是马库斯之后，他和达丽雅怀着共同的目标一起闯进了城市的巨塔，开始了生死难料的行动。 制作人员： 导演：川尻善昭 分镜：滨崎博嗣 人物设定：阿部恒 色彩设计：三笠修 作画监督：田崎聪、村谷贵志 ","date":"2007-06-05","objectID":"/anime/highlander/:1:0","tags":null,"title":"高地人 复仇之旅","uri":"/anime/highlander/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 科林·麦克劳德 コリン・マクラウド 男 小栗旬 2 达丽雅 ダリア 女 朴璐美 3 马库斯·奥克塔维厄斯 マルカス・オクタビウス 男 山寺宏一 4 Kyala 伽羅 女 林原めぐみ ","date":"2007-06-05","objectID":"/anime/highlander/:2:0","tags":null,"title":"高地人 复仇之旅","uri":"/anime/highlander/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 高地人 复仇之旅 2007-06-05 1 9anime ","date":"2007-06-05","objectID":"/anime/highlander/:3:0","tags":null,"title":"高地人 复仇之旅","uri":"/anime/highlander/"},{"categories":null,"content":"Ani Kuri 15 是由创作《攻壳机动队剧场版 无罪》的押井守，《红辣椒》的今敏，《恶童》的Michael L.Arias等，日本在世界上引以为傲的动画创作者们与NHK共同制作的1分钟原创动画的企画。 \n\n自手冢治虫的名作《铁臂阿童木》以来，动画创作者们不断地继续着新的挑战。最终日本“动画”带着与众不同的多样性和创造性,开拓了新“映象文化”的境地。并且如今“Anime”已经成为了世界的共通语。 \n\nNHK在这之前也挑战过1分钟电视剧《EL POPO TOWN》等各种各样新的企画，但这次组织了由资深到新锐的15组动画创作者,挑战名为1分钟动画的电视界新流派。","date":"2007-05-07","objectID":"/anime/ani_kuri_15/","tags":null,"title":"NHK15个动画短片","uri":"/anime/ani_kuri_15/"},{"categories":null,"content":"简介 Ani Kuri 15 是由创作《攻壳机动队剧场版 无罪》的押井守，《红辣椒》的今敏，《恶童》的Michael L.Arias等，日本在世界上引以为傲的动画创作者们与NHK共同制作的1分钟原创动画的企画。 自手冢治虫的名作《铁臂阿童木》以来，动画创作者们不断地继续着新的挑战。最终日本“动画”带着与众不同的多样性和创造性,开拓了新“映象文化”的境地。并且如今“Anime”已经成为了世界的共通语。 NHK在这之前也挑战过1分钟电视剧《EL POPO TOWN》等各种各样新的企画，但这次组织了由资深到新锐的15组动画创作者,挑战名为1分钟动画的电视界新流派。 制作人员： 原作：西见祥示郎 导演","date":"2007-05-07","objectID":"/anime/ani_kuri_15/:1:0","tags":null,"title":"NHK15个动画短片","uri":"/anime/ani_kuri_15/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 NHK15个动画短片 2007-05-07 15 bilibili ","date":"2007-05-07","objectID":"/anime/ani_kuri_15/:2:0","tags":null,"title":"NHK15个动画短片","uri":"/anime/ani_kuri_15/"},{"categories":null,"content":"       暑假，来到自然学校的15名少年少女。在那里，他们遇到了一个自称为“KOKOPERI”（可可贝利）的神秘大叔，邀请和他们开始一场“游戏”。所谓的“游戏”就是操纵巨大机器人来对抗袭击地球的机器人，以为这是一般电脑游戏的15名孩子们定下了契约，但孩子们不知道这个游戏的真正意义，更不知道操纵机器人背后的沉重代价。在一次又一次的战斗中， 孩子们从不知到真相而对这个游戏的激动兴奋，到知道真相后看着同伴慢慢离开的痛苦，看着每次选择驾驶者也许就是自己却无法解除契约时各自的不同表现，展现了人性中最真实的一面——恐慌、愤怒和悲伤，并通过每个孩子独一无二的人生经历暴露出世界的黑暗一面。","date":"2007-04-08","objectID":"/anime/bokurano/","tags":null,"title":"地球防卫少年","uri":"/anime/bokurano/"},{"categories":null,"content":"简介 暑假，来到自然学校的15名少年少女。在那里，他们遇到了一个自称为“KOKOPERI”（可可贝利）的神秘大叔，邀请和他们开始一场“游戏”。所谓的“游戏”就是操纵巨大机器人来对抗袭击地球的机器人，以为这是一般电脑游戏的15名孩子们定下了契约，但孩子们不知道这个游戏的真正意义，更不知道操纵机器人背后的沉重代价。在一次又一次的战斗中， 孩子们从不知到真相而对这个游戏的激动兴奋，到知道真相后看着同伴慢慢离开的痛苦，看着每次选择驾驶者也许就是自己却无法解除契约时各自的不同表现，展现了人性中最真实的一面——恐慌、愤怒和悲伤，并通过每个孩子独一无二的人生经历暴露出世界的黑暗一面。 制作人员： 原作：鬼头","date":"2007-04-08","objectID":"/anime/bokurano/:1:0","tags":null,"title":"地球防卫少年","uri":"/anime/bokurano/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宇白顺 うしろ じゅん、Ushiro Jun、ウシロ 男 皆川純子 2 宇白可奈 宇白 可奈、Ushiro Kana 女 阿澄佳奈 3 吉川宽治 吉川寛治、よしかわ かんじ、Yoshikawa Kanji、カンジ 男 野島健児 4 町洋子 Machi Youko、町洋子 女 三瓶由布子 5 往住爱子 往住愛子、とこすみ あいこ、Tokosumi Aiko、アンコ 女 牧野由依 6 古茂田考美 古茂田孝美、こもだ たかみ、Komoda Takami、コモ 女 能登麻美子 7 切江洋介 切江洋介、きりえ ようすけ、Kirie Yousuke、キリエ 男 浅沼晋太","date":"2007-04-08","objectID":"/anime/bokurano/:2:0","tags":null,"title":"地球防卫少年","uri":"/anime/bokurano/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 地球防卫少年 2007-04-08 24 bilibili ","date":"2007-04-08","objectID":"/anime/bokurano/:3:0","tags":null,"title":"地球防卫少年","uri":"/anime/bokurano/"},{"categories":null,"content":"       讲述的就是一群喜爱动画、漫画的高中女生们的日常生活。其中主角泉こなた更是为了喜欢的东西会不惜一切的女孩子，整天出入OTAKU们的的圣地秋叶原、到女仆沏茶店打工、天天都有COSPLAY。这样一名标准的AKIBA系OTAKU的她，和相对平常些的柊姐妹、みゆき等好朋友一起演绎着一幕幕喧嚣的，令人意外却很日常化的故事。总之，原作就是那种平常到很无聊，但是闲暇时看着却很有趣的泡沫4格。\n\n       故事所描述的是典型的电玩游戏发烧友泉こなた与孪生姐妹柊つかさ、柊かがみ所发生的琐事，虽然不是会乱入宇宙怪物之类的惊奇设定，却能带给人奇妙的作品魅力。","date":"2007-04-08","objectID":"/anime/lucky_star/","tags":null,"title":"幸运星","uri":"/anime/lucky_star/"},{"categories":null,"content":"简介 讲述的就是一群喜爱动画、漫画的高中女生们的日常生活。其中主角泉こなた更是为了喜欢的东西会不惜一切的女孩子，整天出入OTAKU们的的圣地秋叶原、到女仆沏茶店打工、天天都有COSPLAY。这样一名标准的AKIBA系OTAKU的她，和相对平常些的柊姐妹、みゆき等好朋友一起演绎着一幕幕喧嚣的，令人意外却很日常化的故事。总之，原作就是那种平常到很无聊，但是闲暇时看着却很有趣的泡沫4格。 故事所描述的是典型的电玩游戏发烧友泉こなた与孪生姐妹柊つかさ、柊かがみ所发生的琐事，虽然不是会乱入宇宙怪物之类的惊奇设定，却能带给人奇妙的作品魅力。 制作人员： 原作：美水镜 导演：武本康弘、山本宽 脚本：冈部优子","date":"2007-04-08","objectID":"/anime/lucky_star/:1:0","tags":null,"title":"幸运星","uri":"/anime/lucky_star/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 泉此方 传说中的少女A、泉 こなた、いずみ こなた、Izumi Konata、こなちゃん 女 平野綾 2 柊镜 ひいらぎかがみ、Hiiragi Kagami、小镜，正常帝 女 加藤英美里 3 柊司 ひいらぎ つかさ、Hiiragi Tsukasa 女 福原香織 4 高良美幸 高良 みゆき、たから みゆき、Takara Miyuki 女 遠藤綾 5 小神晶 こがみあきら、Kogami Akira 女 今野宏美 6 白石稔 しらいし みのる、Shiraishi Minoru 男 白石稔 7 峰岸绫乃 Minegishi Ayano 女 相沢舞 8 黑井奈那子 黒","date":"2007-04-08","objectID":"/anime/lucky_star/:2:0","tags":null,"title":"幸运星","uri":"/anime/lucky_star/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 幸运星 2007-04-08 25 bilibili ","date":"2007-04-08","objectID":"/anime/lucky_star/:3:0","tags":null,"title":"幸运星","uri":"/anime/lucky_star/"},{"categories":null,"content":"MAD ","date":"2007-04-08","objectID":"/anime/lucky_star/:4:0","tags":null,"title":"幸运星","uri":"/anime/lucky_star/"},{"categories":null,"content":"身高172cm的高个女生小泉理沙，和身高156.2cm的可爱男生大谷敦士，从进入每户学园之后，就互相吐槽、彼此抬杠，是大家眼中的斗嘴好搭档。可是在高一那年的圣诞节，两人的关系却产生了微妙的变化。理沙发现自己渐渐爱上了大谷，会随着他的一言一行又喜又悲又生气。可是“像我这样的电线杆女生，为什么偏偏喜欢上娇小可爱的男生？”不知该如何是好的理沙，只好用搞笑来掩饰真心。","date":"2007-04-07","objectID":"/anime/lovely_complex/","tags":null,"title":"恋爱情结","uri":"/anime/lovely_complex/"},{"categories":null,"content":"简介 身高172cm的高个女生小泉理沙，和身高156.2cm的可爱男生大谷敦士，从进入每户学园之后，就互相吐槽、彼此抬杠，是大家眼中的斗嘴好搭档。可是在高一那年的圣诞节，两人的关系却产生了微妙的变化。理沙发现自己渐渐爱上了大谷，会随着他的一言一行又喜又悲又生气。可是“像我这样的电线杆女生，为什么偏偏喜欢上娇小可爱的男生？”不知该如何是好的理沙，只好用搞笑来掩饰真心。 制作人员： 原作：中原亚矢 导演：宇田钢之介 脚本：井上美绪、影山由美、山田隆司、高桥洋一、村山功 分镜：石平信司、深泽敏则 ","date":"2007-04-07","objectID":"/anime/lovely_complex/:1:0","tags":null,"title":"恋爱情结","uri":"/anime/lovely_complex/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小泉理沙 小泉 リサ、こいずみ りさ、Koizumi Risa 女 岡村明美 2 大谷敦士 大谷 敦士、おおたに あつし、Ootani Atsushi 男 永田彬 3 石原信子 石原 信子、いしはら のぶこ、Ishihara Nobuko 女 東さおり 4 中尾平吉 中尾平吉、なかお へいきち、Nakao Heikichi 男 徳山靖彦 5 田中千春 たなか ちはる、Tanaka Chiharu、千春ちゃん 女 こじまかずこ 6 铃木凉二 鈴木涼二、すずき りょうじ、Suzuki Ryouji 男 津田健次郎 7 寿圣子郎 ことぶき せいしろう、Kotobu","date":"2007-04-07","objectID":"/anime/lovely_complex/:2:0","tags":null,"title":"恋爱情结","uri":"/anime/lovely_complex/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 恋爱情结 2007-04-07 24 bilibili ","date":"2007-04-07","objectID":"/anime/lovely_complex/:3:0","tags":null,"title":"恋爱情结","uri":"/anime/lovely_complex/"},{"categories":null,"content":"　　依人是个喜爱着天空的普通高中一年级学生。\n　　石月真名是个活泼开朗的少女，同时也是依人的同学。\n　　真名的妹妹こより是小学二年级的学生，但因为身体状况不是很好，所以一直在一家可以看到大海的医院中住院。\n　　在这家医院中，こより遇到了一个名叫森宫苍乃的女孩。森宫苍乃和依人的关系很好，类似于姐弟的存在。\n　　这一天，是苍乃的生日，依人和真名一起去医院探望苍乃和こより，四个人愉快的嬉戏着。\n　　正在此时，神秘男子佛堂刚史与身着歌特萝莉服装的少女神河茧子展开了共同旅行。\n　　少女四方茉莉在街道的教会中独自的生活。然后，某日的凌晨四点，在美丽的海滨自然公园中，茉莉与正准备拍摄天空照片的依人却偶然相遇了。少年与少女的相遇，拉开了不思议事件的序幕……。","date":"2007-04-06","objectID":"/anime/sola/","tags":null,"title":"sola","uri":"/anime/sola/"},{"categories":null,"content":"简介 依人是个喜爱着天空的普通高中一年级学生。 石月真名是个活泼开朗的少女，同时也是依人的同学。 真名的妹妹こより是小学二年级的学生，但因为身体状况不是很好，所以一直在一家可以看到大海的医院中住院。 在这家医院中，こより遇到了一个名叫森宫苍乃的女孩。森宫苍乃和依人的关系很好，类似于姐弟的存在。 这一天，是苍乃的生日，依人和真名一起去医院探望苍乃和こより，四个人愉快的嬉戏着。 正在此时，神秘男子佛堂刚史与身着歌特萝莉服装的少女神河茧子展开了共同旅行。 少女四方茉莉在街道的教会中独自的生活。然后，某日的凌晨四点，在美丽的海滨自然公园中，茉莉与正准备拍摄天空照片的依人却偶然相遇了。少年与少女的相遇，","date":"2007-04-06","objectID":"/anime/sola/:1:0","tags":null,"title":"sola","uri":"/anime/sola/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 森宫依人 森宮 依人、もりみや よりと、Morimiya Yorito 男 岡本信彦 2 四方茉莉 しほう まつり、Shihou Matsuri 女 能登麻美子 3 森宫苍乃 森宮 蒼乃、もりみや あおの、Morimiya Aono 女 中原麻衣 4 石月真名 石月 真名、いしづき まな、Ishizuki Mana 女 本多陽子 5 石月小依 石月 こより、いしづき こより、Ishizuki Koyori 女 清水愛 6 辻堂刚史 辻堂 剛史、つじどう たけし、Tsujidou Takeshi 男 藤原啓治 7 神河茧子 かみかわ まゆこ、Kamikawa ","date":"2007-04-06","objectID":"/anime/sola/:2:0","tags":null,"title":"sola","uri":"/anime/sola/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 sola 2007-04-06 13 bilibili MAD ","date":"2007-04-06","objectID":"/anime/sola/:3:0","tags":null,"title":"sola","uri":"/anime/sola/"},{"categories":null,"content":"       自古妖魔侵入人類的世界，化作人形並以啃食人類的內臟為生，對妖魔束手無策的人們唯有求助於有著半人半妖的身分，帶著巨劍且以斬殺妖魔為業的銀眼戰士，畏懼並害怕她們的人們將其稱為Claymore（大劍、銀眼魔女）。","date":"2007-04-03","objectID":"/anime/claymore/","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"简介 自古妖魔侵入人類的世界，化作人形並以啃食人類的內臟為生，對妖魔束手無策的人們唯有求助於有著半人半妖的身分，帶著巨劍且以斬殺妖魔為業的銀眼戰士，畏懼並害怕她們的人們將其稱為Claymore（大劍、銀眼魔女）。 制作人员： 原作：八木教广 导演：田中洋之 脚本：笔安一幸、小林靖子、西田大辅 分镜：芦野芳晴、山崎和男、滨崎博嗣、浅香守生 ","date":"2007-04-03","objectID":"/anime/claymore/:1:0","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 克蕾雅 Clare 女 桑島法子 2 拉基 ラキ、Raki 男 高城元気 3 オフィーリア 女 篠原恵美 4 ルヴル 男 平田広明 5 イレーネ 女 高山みなみ 6 ジーン 女 三石琴乃 7 泰莉莎 迪妮莎、特蕾莎、テレサ、Teresa、微笑のテレサ 女 朴璐美 8 普莉希拉 プリシラ、Priscilla 女 久川綾 ","date":"2007-04-03","objectID":"/anime/claymore/:2:0","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 大剑 2007-04-03 26 樱花 ","date":"2007-04-03","objectID":"/anime/claymore/:3:0","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"MAD ","date":"2007-04-03","objectID":"/anime/claymore/:4:0","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"       这是一个被命运背叛的男人，战斗、继续战斗、不断战斗的热血故事。\n日复一日，地下村庄基哈村的少年西蒙始终拿着钻头挖掘，并习以为常。但是，西蒙的好友，被称为“大哥”的卡米那终日叫嚣着所谓地上的世界。“穿破天际，到地上的世界去看一看吧”卡米那每日这样想着。但一直未能成功。直到一天，巨大的机械怪物——“颜面”打破村子的天井，进入村子破坏。确认了地上世界的存在，卡米那热情高涨，与地上来的少女优子、小弟西蒙三人一起对抗颜面，并驾驶西蒙意外挖出的机械——“螺岩”冲出了天井，达到了地上的世界！\n地球表面展现在少年少女面前，但其实地表上有更多的“颜面”，不断战斗的冒险故事就此展开。西蒙的未来，以任何人都无法想象的方向展开。","date":"2007-04-01","objectID":"/anime/tengen_toppa/","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"简介 这是一个被命运背叛的男人，战斗、继续战斗、不断战斗的热血故事。 日复一日，地下村庄基哈村的少年西蒙始终拿着钻头挖掘，并习以为常。但是，西蒙的好友，被称为“大哥”的卡米那终日叫嚣着所谓地上的世界。“穿破天际，到地上的世界去看一看吧”卡米那每日这样想着。但一直未能成功。直到一天，巨大的机械怪物——“颜面”打破村子的天井，进入村子破坏。确认了地上世界的存在，卡米那热情高涨，与地上来的少女优子、小弟西蒙三人一起对抗颜面，并驾驶西蒙意外挖出的机械——“螺岩”冲出了天井，达到了地上的世界！ 地球表面展现在少年少女面前，但其实地表上有更多的“颜面”，不断战斗的冒险故事就此展开。西蒙的未来，以任何人都无","date":"2007-04-01","objectID":"/anime/tengen_toppa/:1:0","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 西蒙 simon、シモン、Simon 男 菅生隆之 2 卡米那 カミナ、Kamina 男 小西克幸 3 优子 阳子、ヨーコ、Youko、夜子、よるこ 女 井上麻里奈 4 妮亚 ニア・テッペリン、Nia Teppelin 女 福井裕佳梨 5 卜塔 ブータ、Boota 男 伊藤静 6 利珑 リーロン・リットナー、Leeron 男 小野坂昌也 7 维拉鲁 ヴィラル、Viral 男 檜山修之 8 达雅卡 ダヤッカ・リットナー、Dayakka Littner 男 中村大樹 ","date":"2007-04-01","objectID":"/anime/tengen_toppa/:2:0","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天元突破 红莲螺岩 2007-04-01 27 bilibili ","date":"2007-04-01","objectID":"/anime/tengen_toppa/:3:0","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"MAD ","date":"2007-04-01","objectID":"/anime/tengen_toppa/:4:0","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"故事讲述了公立高中一年级生的绫崎飒，因其父母性格懒散，使得他不得不每天都打工养家。圣诞夜，回到家中的绫崎飒发现父母留给他一张白条，原来，父母欠下了一亿五千万日圆债务后逃之夭夭。为了还债甚至还企图贩卖绫崎飒的器官。被黑道追杀走投无路的绫崎飒，妄图绑架附近公园的少女换取赎金，阴差阳错再加层层误会之下，绫崎飒反倒成了少女的救命恩人。怎知这位少女正是三千院财阀大小姐，为了报答救命之恩她雇用了绫崎飒当管家，并且偿还了他的债务。但是好人绫崎飒却坚持要偿还这笔钱，于是，绫崎飒的管家生活就此开始……","date":"2007-04-01","objectID":"/anime/hayate_no_gotoku/","tags":null,"title":"旋风管家","uri":"/anime/hayate_no_gotoku/"},{"categories":null,"content":"简介 故事讲述了公立高中一年级生的绫崎飒，因其父母性格懒散，使得他不得不每天都打工养家。圣诞夜，回到家中的绫崎飒发现父母留给他一张白条，原来，父母欠下了一亿五千万日圆债务后逃之夭夭。为了还债甚至还企图贩卖绫崎飒的器官。被黑道追杀走投无路的绫崎飒，妄图绑架附近公园的少女换取赎金，阴差阳错再加层层误会之下，绫崎飒反倒成了少女的救命恩人。怎知这位少女正是三千院财阀大小姐，为了报答救命之恩她雇用了绫崎飒当管家，并且偿还了他的债务。但是好人绫崎飒却坚持要偿还这笔钱，于是，绫崎飒的管家生活就此开始…… 制作人员： 原作：畑健二郎 导演：川口敬一郎 脚本：福田裕子、猪爪慎一、植田浩二、武上纯希、浦泽义雄、高","date":"2007-04-01","objectID":"/anime/hayate_no_gotoku/:1:0","tags":null,"title":"旋风管家","uri":"/anime/hayate_no_gotoku/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 三千院凪 大小姐、三千院ナギ、さんぜんいん なぎ、Sanzenin Nagi、钉宫四萌 女 釘宮理恵 2 玛丽亚 マリア、Maria 女 田中理恵 3 桂雏菊 桂ヒナギク、Katsura Hinagiku、会长 女 伊藤静 4 绫崎飒 Ayasaki Hayate、綾崎ハヤテ 男 白石涼子 5 鹭之宮伊澄 鷺ノ宮伊澄、Saginomiya Isumi 女 松来未祐 6 爱泽咲夜 愛沢咲夜、あいざわ　さくや、Aizawa Sakuya 女 植田佳奈 7 貴嶋サキ 貴嶋サキ、Kijima Saki 女 中島沙樹 8 橘ワタル 橘ワタル、Tachibana Wat","date":"2007-04-01","objectID":"/anime/hayate_no_gotoku/:2:0","tags":null,"title":"旋风管家","uri":"/anime/hayate_no_gotoku/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 旋风管家 2007-04-01 52 樱花 2 旋风管家 第二季 2009-04-03 25 樱花 3 旋风管家 HEAVEN IS A PLACE ON EARTH 2011-08-27 1 bilibili 4 旋风管家 CAN’T TAKE MY EYES OFF YOU 2012-10-03 12 bilibili 5 旋风管家 Cuties 2013-04-08 12 bilibili 6 旋风管家 OAD 2014-06-18 3 bilibili ","date":"2007-04-01","objectID":"/anime/hayate_no_gotoku/:3:0","tags":null,"title":"旋风管家","uri":"/anime/hayate_no_gotoku/"},{"categories":null,"content":"MAD ","date":"2007-04-01","objectID":"/anime/hayate_no_gotoku/:4:0","tags":null,"title":"旋风管家","uri":"/anime/hayate_no_gotoku/"},{"categories":null,"content":"故事讲述了一位公主被政变者的追杀，逃命途中不慎掉入悬崖与一位流氓大姐灵魂互换两人发觉互换了身体，从此踏上不同人生轨迹的故事。心怀祖国的公主恳求不幸变成公主的“大姐头”帮忙，拯救这个国家……从此，“大姐大”王女踏上了王女救国之路，其强悍的行事作风更为她赢得了“杀戮公主”之名，流传至今……。\n","date":"2007-03-28","objectID":"/anime/murder_princess/","tags":null,"title":"杀戮公主","uri":"/anime/murder_princess/"},{"categories":null,"content":"简介 故事讲述了一位公主被政变者的追杀，逃命途中不慎掉入悬崖与一位流氓大姐灵魂互换两人发觉互换了身体，从此踏上不同人生轨迹的故事。心怀祖国的公主恳求不幸变成公主的“大姐头”帮忙，拯救这个国家……从此，“大姐大”王女踏上了王女救国之路，其强悍的行事作风更为她赢得了“杀戮公主”之名，流传至今……。 制作人员： 原作：犬威赤彦 导演：黑川智之 脚本：浦畑达彦 分镜：高村雄太、山本秀世、守冈博、川面真也 ","date":"2007-03-28","objectID":"/anime/murder_princess/:1:0","tags":null,"title":"杀戮公主","uri":"/anime/murder_princess/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 珐莉斯 女 朴璐美 2 艾莉塔 女 朴璐美 3 多米尼可夫 矢尾一樹 4 皮特·阿姆斯特朗 高瀬右光 5 乔多·安特拉希亚 石森達幸 6 赤猿 土田大 7 安娜\u0026尤娜 女 斎藤千和 8 赛希莉亚 豊口めぐみ ","date":"2007-03-28","objectID":"/anime/murder_princess/:2:0","tags":null,"title":"杀戮公主","uri":"/anime/murder_princess/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 杀戮公主 2007-03-28 6 bilibili ","date":"2007-03-28","objectID":"/anime/murder_princess/:3:0","tags":null,"title":"杀戮公主","uri":"/anime/murder_princess/"},{"categories":null,"content":"时间是1990年代的日本，远野贵树与筱原明里原本是同班同学的好朋友，自从小学毕业之后，两人都没有再见一次面。分隔两地的两个人，靠着书信往来保持联络，直到贵树知道即将跟随家人搬到鹿儿岛，距离明里更远的地方，于是两人约定了再见面的时间。计划好的行程，却遇上了暴风雪……。","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"简介 时间是1990年代的日本，远野贵树与筱原明里原本是同班同学的好朋友，自从小学毕业之后，两人都没有再见一次面。分隔两地的两个人，靠着书信往来保持联络，直到贵树知道即将跟随家人搬到鹿儿岛，距离明里更远的地方，于是两人约定了再见面的时间。计划好的行程，却遇上了暴风雪……。 制作人员： 原作：新海诚 音乐：天门 人物设定：西村贵世 ","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/:1:0","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 远野贵树 遠野 貴樹、Toono Takaki 男 水橋研二 2 澄田花苗 女 花村怜美 3 篠原明里 しのはら あかり、Shinohara Akari 女 近藤好美 4 水野理纱 みずの りさ、Mizuno Risa 女 水野理紗 5 卓比 Chobi 男 新海誠 ","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/:2:0","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 秒速5厘米 2007-03-03 01:02:44 bilibili ","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/:3:0","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"MAD ","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/:4:0","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"　　故事的舞台设定在了2035年，主角是一群活泼可爱的美少女萝莉，30年后的未来，由于学生数量的减少，面临倒闭危机的学校比比皆是，一个萝莉转校来到了“私立圣樱学园”，她就是元气少女·天宫学美（通称:まなび），她的出现将给这所已经失去活力的学校掀起怎样的旋风呢？","date":"2007-01-07","objectID":"/anime/gakuen_utopia_manabi_straight/","tags":null,"title":"校园乌托邦 学美向前冲！","uri":"/anime/gakuen_utopia_manabi_straight/"},{"categories":null,"content":"简介 故事的舞台设定在了2035年，主角是一群活泼可爱的美少女萝莉，30年后的未来，由于学生数量的减少，面临倒闭危机的学校比比皆是，一个萝莉转校来到了“私立圣樱学园”，她就是元气少女·天宫学美（通称:まなび），她的出现将给这所已经失去活力的学校掀起怎样的旋风呢？ 制作人员： 原作：ufotable 导演：平尾隆之、小笠原笃、高桥拓朗、金月龙之介 脚本：寺东克己 分镜：岛津裕行 ","date":"2007-01-07","objectID":"/anime/gakuen_utopia_manabi_straight/:1:0","tags":null,"title":"校园乌托邦 学美向前冲！","uri":"/anime/gakuen_utopia_manabi_straight/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天宫学美 天宮 学美、あまみや まなみ、Amamiya Manami 女 堀江由衣 2 稻森光香 稲森 光香、いなもり みか、Inamori Mika 女 野中藍 3 上原睦月 上原 むつき、うえはら むつき、Uehara Mutsuki 女 井上麻里奈 4 卫藤芽生 衛藤 芽生、えとう めい、Etou Mei 女 平野綾 5 小鸟桃叶 おどり ももは、Odori Momoha、もも 女 藤田咲 6 下岛老师 下嶋、しもじま、Shimojima、しもじー 男 うすいたかやす 7 角泽多佳子 角沢 多佳子、かくざわ たかこ、Kakuzawa Takako 女 ","date":"2007-01-07","objectID":"/anime/gakuen_utopia_manabi_straight/:2:0","tags":null,"title":"校园乌托邦 学美向前冲！","uri":"/anime/gakuen_utopia_manabi_straight/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 校园乌托邦 学美向前冲！ 2007-01-07 13 bilibili ","date":"2007-01-07","objectID":"/anime/gakuen_utopia_manabi_straight/:3:0","tags":null,"title":"校园乌托邦 学美向前冲！","uri":"/anime/gakuen_utopia_manabi_straight/"},{"categories":null,"content":"故事在“地狱之街”宝町，那里充满义气、人情和暴力。在宝町住了两个自由自在的少年，“黑”和“白”。不过，这个城市将会被重新开发，实行“孩子之城”计划，意图控制整个城市，“黑”和“白”两人的命运亦受到重大改变……","date":"2006-12-23","objectID":"/anime/tekkon_kinkur%C3%AEto/","tags":null,"title":"恶童","uri":"/anime/tekkon_kinkur%C3%AEto/"},{"categories":null,"content":"简介 故事在“地狱之街”宝町，那里充满义气、人情和暴力。在宝町住了两个自由自在的少年，“黑”和“白”。不过，这个城市将会被重新开发，实行“孩子之城”计划，意图控制整个城市，“黑”和“白”两人的命运亦受到重大改变…… 制作人员： 原作：松本大洋 导演：迈克尔・阿里亚斯 脚本：安东尼·温特劳布 分镜：久保正彦、西见祥示郎、森本晃司、安藤裕章 ","date":"2006-12-23","objectID":"/anime/tekkon_kinkur%C3%AEto/:1:0","tags":null,"title":"恶童","uri":"/anime/tekkon_kinkur%C3%AEto/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 白 男 蒼井優 2 黑 Black、クロ、Kuro 男 二宮和也 ","date":"2006-12-23","objectID":"/anime/tekkon_kinkur%C3%AEto/:2:0","tags":null,"title":"恶童","uri":"/anime/tekkon_kinkur%C3%AEto/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 恶童 2006-12-23 1 bilibili ","date":"2006-12-23","objectID":"/anime/tekkon_kinkur%C3%AEto/:3:0","tags":null,"title":"恶童","uri":"/anime/tekkon_kinkur%C3%AEto/"},{"categories":null,"content":"近未来，为了治疗现代人类越来越多、越来越严重的精神疾病，位于东京的精神医疗综合研究所开发出一种可以反映他人梦境的机器。通过微型DC的帮助，梦境在显示器上呈现出来，更方便找到一个人焦虑的症结。  \n\n某日，三台微型DC失窃，与之相关的研究人员的梦境接连被人侵入，随后受到严重伤害。美女医疗师千叶敦子另一个身份是梦境侦探“红辣椒”，她能够与患者同步体验梦境。为避免盗贼利用微型DC进一步作恶，她不得不潜入受害者的梦中寻找恐怖分子，一场充满奇幻和惊险的争斗旋即展开……\n\n本片入围2006年威尼斯电影节主竞赛单元，荣获2007年葡萄牙奇幻电影节影评人选择奖、2006年蒙特利尔电影节大众选择奖。","date":"2006-11-25","objectID":"/anime/paprika/","tags":null,"title":"红辣椒","uri":"/anime/paprika/"},{"categories":null,"content":"简介 近未来，为了治疗现代人类越来越多、越来越严重的精神疾病，位于东京的精神医疗综合研究所开发出一种可以反映他人梦境的机器。通过微型DC的帮助，梦境在显示器上呈现出来，更方便找到一个人焦虑的症结。 某日，三台微型DC失窃，与之相关的研究人员的梦境接连被人侵入，随后受到严重伤害。美女医疗师千叶敦子另一个身份是梦境侦探“红辣椒”，她能够与患者同步体验梦境。为避免盗贼利用微型DC进一步作恶，她不得不潜入受害者的梦中寻找恐怖分子，一场充满奇幻和惊险的争斗旋即展开…… 本片入围2006年威尼斯电影节主竞赛单元，荣获2007年葡萄牙奇幻电影节影评人选择奖、2006年蒙特利尔电影节大众选择奖。 制作人员： ","date":"2006-11-25","objectID":"/anime/paprika/:1:0","tags":null,"title":"红辣椒","uri":"/anime/paprika/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 千叶敦子 红、辣、椒 女 林原めぐみ ","date":"2006-11-25","objectID":"/anime/paprika/:2:0","tags":null,"title":"红辣椒","uri":"/anime/paprika/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 红辣椒 2006-11-25 01:30:32 bilibili ","date":"2006-11-25","objectID":"/anime/paprika/:3:0","tags":null,"title":"红辣椒","uri":"/anime/paprika/"},{"categories":null,"content":"以人类移居月球的23世纪为舞台。传言地球已经灭亡，在称为“科学技术研究的自由”与“往地球出国的自由”都被夺走的伊甸（EDEN）的月球共和国上，描写少年们追求真正自由的故事。\n\nFREEDOM-PROJECT（自由计划）是日清食品的合味道杯面与漫画家大友克洋合作的宣传计划，主要制作电视广告、OVA及轻小说等。\n\n本计划的世界舞台是以日清食品的合味道杯面与大友克洋的“FREEDOM：自由”为主题，拍摄全10支的广告系列，并制作全6集+1集后续篇的OVA动画。动画会先在Yahoo!动画上作网上播放，其后会以标题“FREEDOM”作DVD发售。","date":"2006-11-24","objectID":"/anime/freedom/","tags":null,"title":"FREEDOM","uri":"/anime/freedom/"},{"categories":null,"content":"简介 以人类移居月球的23世纪为舞台。传言地球已经灭亡，在称为“科学技术研究的自由”与“往地球出国的自由”都被夺走的伊甸（EDEN）的月球共和国上，描写少年们追求真正自由的故事。 FREEDOM-PROJECT（自由计划）是日清食品的合味道杯面与漫画家大友克洋合作的宣传计划，主要制作电视广告、OVA及轻小说等。 本计划的世界舞台是以日清食品的合味道杯面与大友克洋的“FREEDOM：自由”为主题，拍摄全10支的广告系列，并制作全6集+1集后续篇的OVA动画。动画会先在Yahoo!动画上作网上播放，其后会以标题“FREEDOM”作DVD发售。 制作人员： 导演：森田修平 脚本：野村祐一、佐藤大、千","date":"2006-11-24","objectID":"/anime/freedom/:1:0","tags":null,"title":"FREEDOM","uri":"/anime/freedom/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 タケル タケル、Takeru 男 浪川大輔 2 和马 男 森久保祥太郎 3 ビス ビス、Bis 男 山口勝平 4 アラン アラン、Aran 男 加藤精三 5 泰那 男 桐本拓哉 6 Junk屋的大叔 男 松本大 ","date":"2006-11-24","objectID":"/anime/freedom/:2:0","tags":null,"title":"FREEDOM","uri":"/anime/freedom/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 FREEDOM 2006-11-24 7 樱花 ","date":"2006-11-24","objectID":"/anime/freedom/:3:0","tags":null,"title":"FREEDOM","uri":"/anime/freedom/"},{"categories":null,"content":"玛宝是帝企鹅家族中的另类分子，经常受到排挤歧视——原因是在帝企鹅里面，不会唱歌是一件丢人的事情，而玛宝恰恰是这样的企鹅。但是，他格外擅长舞蹈，舞技超群的绝艺却没有带给他幸运，铁面领袖把他赶出了族门。  \n\n玛宝在外面的世界流浪，却碰上了另一个族群：阿德利企鹅。这群企鹅嗜好跳舞，自诩“2266歌舞团”，他们惊叹于玛宝的舞步，邀请他前去舞会狂欢。然而，在前往舞会的路上，玛宝遇到了一个踩着摇滚舞步的流浪者，他指引玛宝去解开心中的谜团：为什么企鹅食物会越来越少，为什么海平面有大型的铁皮船，为什么船上的人对企鹅残暴不仁。于是玛宝追踪一艘铁壳船，闯入了人类的世界。","date":"2006-11-17","objectID":"/anime/happy_feet/","tags":null,"title":"快乐的大脚","uri":"/anime/happy_feet/"},{"categories":null,"content":"简介 玛宝是帝企鹅家族中的另类分子，经常受到排挤歧视——原因是在帝企鹅里面，不会唱歌是一件丢人的事情，而玛宝恰恰是这样的企鹅。但是，他格外擅长舞蹈，舞技超群的绝艺却没有带给他幸运，铁面领袖把他赶出了族门。 玛宝在外面的世界流浪，却碰上了另一个族群：阿德利企鹅。这群企鹅嗜好跳舞，自诩“2266歌舞团”，他们惊叹于玛宝的舞步，邀请他前去舞会狂欢。然而，在前往舞会的路上，玛宝遇到了一个踩着摇滚舞步的流浪者，他指引玛宝去解开心中的谜团：为什么企鹅食物会越来越少，为什么海平面有大型的铁皮船，为什么船上的人对企鹅残暴不仁。于是玛宝追踪一艘铁壳船，闯入了人类的世界。 制作人员： 制作：华纳兄弟娱乐公司 ","date":"2006-11-17","objectID":"/anime/happy_feet/:1:0","tags":null,"title":"快乐的大脚","uri":"/anime/happy_feet/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 Mumble 雄 Michael Joseph Jackson 2 Vinnie 雄 Mark Klastorin 3 Memphis 雄 Hugh Jackman ","date":"2006-11-17","objectID":"/anime/happy_feet/:2:0","tags":null,"title":"快乐的大脚","uri":"/anime/happy_feet/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 快乐的大脚 2006-11-17 1 樱花 2 快乐的大脚2 0000-00-00 1 樱花 ","date":"2006-11-17","objectID":"/anime/happy_feet/:3:0","tags":null,"title":"快乐的大脚","uri":"/anime/happy_feet/"},{"categories":null,"content":"酒吧不仅仅是一个喝酒的地方，在调酒师高超的技艺下，调出的不仅仅是美味的鸡尾酒，还有着百味的人生。本作可以说为奔忙于世的各种颜色的“领”们量身定做：那么，今晚想要怎样的一杯呢？在你说出口之前，已为你奉上最佳的一杯，这才是调酒师的风采。","date":"2006-10-14","objectID":"/anime/bartender/","tags":null,"title":"调酒师","uri":"/anime/bartender/"},{"categories":null,"content":"简介 酒吧不仅仅是一个喝酒的地方，在调酒师高超的技艺下，调出的不仅仅是美味的鸡尾酒，还有着百味的人生。本作可以说为奔忙于世的各种颜色的“领”们量身定做：那么，今晚想要怎样的一杯呢？在你说出口之前，已为你奉上最佳的一杯，这才是调酒师的风采。 制作人员： 原作：城亚罗树 导演：渡边正树 脚本：今川泰宏 分镜：黑川文男、小林一三、三原武宪、康村谅 演出：冈崎幸男 ","date":"2006-10-14","objectID":"/anime/bartender/:1:0","tags":null,"title":"调酒师","uri":"/anime/bartender/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 调酒师 2006-10-14 11 bilibili ","date":"2006-10-14","objectID":"/anime/bartender/:2:0","tags":null,"title":"调酒师","uri":"/anime/bartender/"},{"categories":null,"content":"2010年，超级大国“布里塔尼亚帝国”（Britannia）为了夺取日本的地下资源而侵略日本，在布里塔尼亚帝国强大的兵器Knightmare进攻下，日本在不到一个月的时间内被征服。日本被剥夺了自由、权利甚至是国家的名字，布里塔尼亚帝国将“日本”改称为“11区”，“日本人”这名词则被11这数字所取代。表面上看来布里塔尼亚帝国的统治似乎牢不可破，但其中早已出现了裂痕。\n七年后的2017年，在生死边缘获得“Geass”的力量，立志要粉碎布里塔尼亚帝国的黑色皇子鲁路修，以及获得第七世代人型机甲兰斯洛特，立志从帝国内部进行改革的白色骑士枢木朱雀，影响了整个世界。","date":"2006-10-05","objectID":"/anime/code_geass/","tags":null,"title":"Code Geass 反叛的鲁路修","uri":"/anime/code_geass/"},{"categories":null,"content":"简介 2010年，超级大国“布里塔尼亚帝国”（Britannia）为了夺取日本的地下资源而侵略日本，在布里塔尼亚帝国强大的兵器Knightmare进攻下，日本在不到一个月的时间内被征服。日本被剥夺了自由、权利甚至是国家的名字，布里塔尼亚帝国将“日本”改称为“11区”，“日本人”这名词则被11这数字所取代。表面上看来布里塔尼亚帝国的统治似乎牢不可破，但其中早已出现了裂痕。 七年后的2017年，在生死边缘获得“Geass”的力量，立志要粉碎布里塔尼亚帝国的黑色皇子鲁路修，以及获得第七世代人型机甲兰斯洛特，立志从帝国内部进行改革的白色骑士枢木朱雀，影响了整个世界。 制作人员： 导演：谷口悟朗 脚本：","date":"2006-10-05","objectID":"/anime/code_geass/:1:0","tags":null,"title":"Code Geass 反叛的鲁路修","uri":"/anime/code_geass/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鲁路修·兰佩路基 L.L.、勒鲁什、鲁鲁修、ゼロ、Zero、Lelouch Lamperouge、鲁路修·冯·布里塔尼亚、Lelouch Vie Britannia、ルルーシュ・ヴィ・ブリタニア 男 福山潤 2 枢木朱雀 白色骑士、Knight of Seven、枢木 スザク、くるるぎ スザク、Kururugi Suzaku 男 櫻井孝宏 3 C.C. 夕赐（音译）、シー・ツー、C.C. 女 ゆかな 4 红月华莲 Kallen Stadtfeld、卡莲·休妲菲尔特、红月卡莲、Kallen Kouzuki、カレン・シュタットフェルト、こうづき カレン、Kouz","date":"2006-10-05","objectID":"/anime/code_geass/:2:0","tags":null,"title":"Code Geass 反叛的鲁路修","uri":"/anime/code_geass/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Code Geass 反叛的鲁路修 2006-10-05 25 樱花 2 Code Geass 反叛的鲁路修R2 2008-04-06 25 樱花 ","date":"2006-10-05","objectID":"/anime/code_geass/:3:0","tags":null,"title":"Code Geass 反叛的鲁路修","uri":"/anime/code_geass/"},{"categories":null,"content":"MAD ","date":"2006-10-05","objectID":"/anime/code_geass/:4:0","tags":null,"title":"Code Geass 反叛的鲁路修","uri":"/anime/code_geass/"},{"categories":null,"content":"　　梦。\n我做着一个悠远而长久的梦。\n从很久以前就一直在做着这个梦；\n在梦中我凝望四季的街道，\n期望与永远不会到来的人再度见面，\n找寻连自己也早已忘却的遗失的东西。\n多少时间、多少岁月从我身边流逝而过，\n在无尽的黑夜中，一直、一直都在孤单地等待着——\n等待着最后那必将到来的黎明。","date":"2006-10-05","objectID":"/anime/kanon/","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"简介 梦。 我做着一个悠远而长久的梦。 从很久以前就一直在做着这个梦； 在梦中我凝望四季的街道， 期望与永远不会到来的人再度见面， 找寻连自己也早已忘却的遗失的东西。 多少时间、多少岁月从我身边流逝而过， 在无尽的黑夜中，一直、一直都在孤单地等待着—— 等待着最后那必将到来的黎明。 制作人员： 原作：Visual Art’s、Key 导演：石原立也 脚本：志茂文彦 分镜：石立太一、武本康弘、木上益治、吉冈忍、山本宽 ","date":"2006-10-05","objectID":"/anime/kanon/:1:0","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 相泽祐一 相沢 祐一、あいざわ ゆういち、Aizawa Yuichi 男 杉田智和 2 月宫亚由 月宮 あゆ、つきみや あゆ、Tsukimiya Ayu 女 堀江由衣 3 水濑名雪 水瀬 名雪、みなせなゆき、Minase Nayuki 女 國府田マリ子 4 泽渡真琴 沢渡 真琴、さわたり まこと、Sawatari Makoto 女 飯塚雅弓 5 美坂栞 美坂刊、美坂 栞、みさか しおり、Misaka Shiori 女 佐藤朱 6 川澄舞 川澄 舞、かわすみ まい、Kawasumi Mai 女 田村ゆかり 7 仓田佐祐理 倉田 佐祐理、くらた さゆり、Kura","date":"2006-10-05","objectID":"/anime/kanon/:2:0","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Kanon 2006-10-05 24 bilibili 2 Kanon 东映版 2002-01-30 13 bilibili ","date":"2006-10-05","objectID":"/anime/kanon/:3:0","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"MAD ","date":"2006-10-05","objectID":"/anime/kanon/:4:0","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"高三生夜神月意外捡到一本名《DEATH NOTE》的笔记本，并且发现只要写下想要杀死的人的名字，就会变成现实。\n月开始利用死亡笔记制裁那些他认为该死的人。接着，笔记的原主人：死神也以旁观者的姿态出现在月面前。\n另一方面越来越多的罪犯离奇死亡事件引起了各国政府的关注，在国际刑事警察机构会议（ICPO）上他们委托神秘人士L来调查此事。社会上则称这个神秘的杀手为“基拉”，不同的人有不同的反应。\n到底谁才是正义的一方，谁又会取得最后的胜利呢？一场斗智斗勇的较量就此展开…… ","date":"2006-10-04","objectID":"/anime/death_note/","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"简介 高三生夜神月意外捡到一本名《DEATH NOTE》的笔记本，并且发现只要写下想要杀死的人的名字，就会变成现实。 月开始利用死亡笔记制裁那些他认为该死的人。接着，笔记的原主人：死神也以旁观者的姿态出现在月面前。 另一方面越来越多的罪犯离奇死亡事件引起了各国政府的关注，在国际刑事警察机构会议（ICPO）上他们委托神秘人士L来调查此事。社会上则称这个神秘的杀手为“基拉”，不同的人有不同的反应。 到底谁才是正义的一方，谁又会取得最后的胜利呢？一场斗智斗勇的较量就此展开…… 制作人员： 原作：小畑健、大场鸫 导演：荒木哲郎 脚本：小林靖子、伊藤智彦、井上敏树、米村正二 分镜：笹木信作、山本沙代 ","date":"2006-10-04","objectID":"/anime/death_note/:1:0","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 夜神月 やがみ ライト、Yagami Light、Kami 男 宮野真守 2 L 流河旱树、龙崎、艾尔·罗莱特、L Lawliet、エル・ローライト、erurouraito 男 山口勝平 3 琉克 流愚、流克、Ryuk 男 中村獅童 4 弥海砂 Misa Amane、あまね みさ 女 平野綾 5 尼亚 N、Nate River、ネイト・リバー、Near 男 日髙のり子 6 梅洛 M、Mihael Keehl、ミハエル・ケール、Mello 男 佐々木望 7 魅上照 みかみ てる、Mikami Teru 男 松風雅也 8 高田清美 女 坂本真綾 ","date":"2006-10-04","objectID":"/anime/death_note/:2:0","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 死亡笔记 2006-10-04 37 樱花 ","date":"2006-10-04","objectID":"/anime/death_note/:3:0","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"MAD ","date":"2006-10-04","objectID":"/anime/death_note/:4:0","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"影片改编自俄国文学家伊万·什梅廖夫（Ivan Shmelev）的短篇小说，故事背景是19世纪末的俄国，一座俄罗斯小镇上，主角是一个憧憬于屠格涅夫小说《初恋》的情窦初开的16岁少年学生Anton，他疯狂迷恋着住在隔壁的那个神秘、美丽的女人，而他家的女佣却在偷偷暗恋他。女佣的爱过于平凡，少年更痴迷于追求那个其实存在于他幻想中的“女神”，然而一天，当“女神”的面纱彻底揭开，失望至极的少年大病一场，初恋就这样随风而去。  \n\n亚历山大·彼德洛夫的动画都是用油彩在玻璃上直接绘制的，画出的油画有一股特别的韵味，尤其是表现与水相关的场景更是别具一格，堪称动画版的“青春残酷物语”。","date":"2006-08-27","objectID":"/anime/my_love/","tags":null,"title":"春之觉醒","uri":"/anime/my_love/"},{"categories":null,"content":"简介 影片改编自俄国文学家伊万·什梅廖夫（Ivan Shmelev）的短篇小说，故事背景是19世纪末的俄国，一座俄罗斯小镇上，主角是一个憧憬于屠格涅夫小说《初恋》的情窦初开的16岁少年学生Anton，他疯狂迷恋着住在隔壁的那个神秘、美丽的女人，而他家的女佣却在偷偷暗恋他。女佣的爱过于平凡，少年更痴迷于追求那个其实存在于他幻想中的“女神”，然而一天，当“女神”的面纱彻底揭开，失望至极的少年大病一场，初恋就这样随风而去。 亚历山大·彼德洛夫的动画都是用油彩在玻璃上直接绘制的，画出的油画有一股特别的韵味，尤其是表现与水相关的场景更是别具一格，堪称动画版的“青春残酷物语”。 制作人员： 导演：亚历山大","date":"2006-08-27","objectID":"/anime/my_love/:1:0","tags":null,"title":"春之觉醒","uri":"/anime/my_love/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 春之觉醒 2006-08-27 1 bilibili ","date":"2006-08-27","objectID":"/anime/my_love/:2:0","tags":null,"title":"春之觉醒","uri":"/anime/my_love/"},{"categories":null,"content":"那个男人爱着的女人，竟然是最恐怖的怪物。她所爱的男人， 则是最强的怪物猎人。一边属于敌对的对手，一边又被爱情纽带给相连。这两人之间的爱情将会是怎样的结果呢？","date":"2006-08-05","objectID":"/anime/kemonozume/","tags":null,"title":"兽爪","uri":"/anime/kemonozume/"},{"categories":null,"content":"简介 那个男人爱着的女人，竟然是最恐怖的怪物。她所爱的男人， 则是最强的怪物猎人。一边属于敌对的对手，一边又被爱情纽带给相连。这两人之间的爱情将会是怎样的结果呢？ 制作人员： 原作：汤浅政明、崔恩映 脚本：小野亮、小黑祐一郎、清水洋、水上清资、中村健治 ","date":"2006-08-05","objectID":"/anime/kemonozume/:1:0","tags":null,"title":"兽爪","uri":"/anime/kemonozume/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 サル サル、Saru 男 ","date":"2006-08-05","objectID":"/anime/kemonozume/:2:0","tags":null,"title":"兽爪","uri":"/anime/kemonozume/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 兽爪 2006-08-05 13 樱花 ","date":"2006-08-05","objectID":"/anime/kemonozume/:3:0","tags":null,"title":"兽爪","uri":"/anime/kemonozume/"},{"categories":null,"content":"　　17岁少女绀野真琴是一个活泼跳脱的少女。在一次普通值日工作中，真琴不小心摔倒了，自此她发现自己拥有了穿越时空的能力。她兴奋不已，掌握了穿越时空的方法后，她经常用这个方法去解决生活中许多令她困扰十分的事。\n　　喜欢棒球的真琴与同班的两名男生千昭与功介有着共同爱好。一天，与她本是好朋友的千昭突然向她表达爱意，手足无措了她再次穿越时空希望可以躲避这件事的发生。但没想到，千昭会跟同学友梨在一起了，而友梨也是一直喜欢千昭的。此时，暗恋功介的果穗误以为真琴是功介的女友。\n　　为了帮忙解决朋友的问题，真琴不断以同样的方法回到过去。她突然发现自己手臂上的数字原来是穿越时空的次数，次数变得越来越少，与此同时她也发现了千昭的秘密…… ","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"简介 17岁少女绀野真琴是一个活泼跳脱的少女。在一次普通值日工作中，真琴不小心摔倒了，自此她发现自己拥有了穿越时空的能力。她兴奋不已，掌握了穿越时空的方法后，她经常用这个方法去解决生活中许多令她困扰十分的事。 喜欢棒球的真琴与同班的两名男生千昭与功介有着共同爱好。一天，与她本是好朋友的千昭突然向她表达爱意，手足无措了她再次穿越时空希望可以躲避这件事的发生。但没想到，千昭会跟同学友梨在一起了，而友梨也是一直喜欢千昭的。此时，暗恋功介的果穗误以为真琴是功介的女友。 为了帮忙解决朋友的问题，真琴不断以同样的方法回到过去。她突然发现自己手臂上的数字原来是穿越时空的次数，次数变得越来越少，与此同时她也发","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/:1:0","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 绀野真琴 紺野 真琴、Konno Makoto 女 仲里依紗 2 间宫千昭 間宮 千昭、Mamiya Chiaki 男 石田卓也 3 津田功介 男 板倉光隆 4 芳山和子 女 原沙知絵 5 绀野美雪 紺野 美雪、Konno Miyuki 女 関戸優希 6 藤谷果穗 藤谷 果穂、Fujitani Kaho 女 谷村美月 ","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/:2:0","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 穿越时空的少女 2006-07-15 01:38:00 bilibili ","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/:3:0","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"MAD ","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/:4:0","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"大学退学第二年的春天，主角家里蹲废材佐藤达广在一事无成下，妄想认为自己的退学跟无职是NHK的全国性阴谋，就在这个时候在他面前出现了之前遇到过叫做中原岬的神秘美少女，并坚持达广一定要加入计划治好只会窝在家里的毛病……","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"简介 大学退学第二年的春天，主角家里蹲废材佐藤达广在一事无成下，妄想认为自己的退学跟无职是NHK的全国性阴谋，就在这个时候在他面前出现了之前遇到过叫做中原岬的神秘美少女，并坚持达广一定要加入计划治好只会窝在家里的毛病…… 制作人员： 原作：泷本龙彦、大岩贤次 导演：山本裕介 脚本：西园悟 分镜：镝木宏、大畑晃一、川畑荣郎、奥野浩行、熊泽佑嗣 ","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/:1:0","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐藤达广 男 小泉豊 2 中原岬 なかはら みさき、Nakahara Misaki 女 牧野由依 3 山崎薫 山崎薫、Yamazaki Kaoru 男 阪口大助 4 柏瞳 柏 瞳 女 小林沙苗 5 小林恵 小林恵、Kobayashi Megumi 女 早水リサ 6 绿川七菜子 緑川七菜子、Midorikawa Nanako 女 宍戸留美 7 城崎彰 じょうがさき あきら 男 飛田展男 8 废材星人 未知 ","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/:2:0","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 欢迎加入NHK！ 2006-07-09 24 樱花 ","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/:3:0","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"MAD ","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/:4:0","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"　　在异世界哈尔凯尼亚被当作“使魔”被召唤出来的高中生平贺才人卷入了一场满载这四种元素的幻想罗曼史大冒险中。将才人召唤至异世界的是长相可爱却没有丝毫魔法才能的主人样·露易丝。面对突然出现的迷之美少女，满心疑惑的才人在听她讲完契约内容之后，遭遇了突如其来的强吻……之后，他的手背上浮现出了不可思议的文字，才人就这样莫名其妙的成为了露易丝的使魔……\n　　以全寄宿制的托丽斯汀魔法学院为舞台，主人样美少女魔法使露易丝与使魔才人在争吵、责备、爱恋中开始了充满了勇气与屈辱的学园生活……在异世界波澜万丈的交流之中，露易丝和才人的命运会怎么样呢？","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"简介 在异世界哈尔凯尼亚被当作“使魔”被召唤出来的高中生平贺才人卷入了一场满载这四种元素的幻想罗曼史大冒险中。将才人召唤至异世界的是长相可爱却没有丝毫魔法才能的主人样·露易丝。面对突然出现的迷之美少女，满心疑惑的才人在听她讲完契约内容之后，遭遇了突如其来的强吻……之后，他的手背上浮现出了不可思议的文字，才人就这样莫名其妙的成为了露易丝的使魔…… 以全寄宿制的托丽斯汀魔法学院为舞台，主人样美少女魔法使露易丝与使魔才人在争吵、责备、爱恋中开始了充满了勇气与屈辱的学园生活……在异世界波澜万丈的交流之中，露易丝和才人的命运会怎么样呢？ 制作人员： 原作：山口升 导演：岩崎良明 脚本：吉冈孝夫 分镜：铃","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/:1:0","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 露易丝·法兰西斯·露·布朗·杜·拉·瓦利埃尔 Louise Françoise Le Blanc de La Vallière、Ruizu Fransowāzu ru Buran do ra Variēru、钉宫四萌 女 釘宮理恵 2 平贺才人 Хирага Сайто、才人·修瓦里埃·杜·平贺·杜·奥尔尼埃尔、平賀才人、ひらが さいと、Hiraga Saito 男 日野聡 3 谢斯塔 Сиеста、シエスタ、Siesta 女 堀江由衣 4 安丽埃塔·杜·托里斯汀 Генриетта де Тристейн、アンリエッタ・ド・トリステイン、Henrietta","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/:2:0","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 零之使魔 2006-07-02 13 bilibili 2 零之使魔 双月骑士 2007-07-08 12 bilibili 3 零之使魔 三美姬的轮舞 2008-07-06 12 bilibili 4 零之使魔F 2012-01-07 12 bilibili ","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/:3:0","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"MAD ","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/:4:0","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"20XX年，亚洲某小国发生内战，由于联合国军的介入而扩大，逐渐陷入僵持。但是由于摄影师白州冴子偶然拍摄到的一张，名为FLAG的照片，越来越趋向和平。FLAG成了和平的象征。\n但是，激进派武装势力却夺走了FLAG。\n联合国为了秘密夺回FLAG，决定投入特殊部队SDC（Special Development Command），并命令带上摄影师记录他们的全部活动，这个人，正是冴子。\n但是，装备了最新强化装甲HAVWC（High Agility Versatile Weapon Carrier），认为这是很容易的任务的特殊小队，遇到了意料之外的反击，陷入苦战……","date":"2006-06-16","objectID":"/anime/flag/","tags":null,"title":"FLAG","uri":"/anime/flag/"},{"categories":null,"content":"简介 20XX年，亚洲某小国发生内战，由于联合国军的介入而扩大，逐渐陷入僵持。但是由于摄影师白州冴子偶然拍摄到的一张，名为FLAG的照片，越来越趋向和平。FLAG成了和平的象征。 但是，激进派武装势力却夺走了FLAG。 联合国为了秘密夺回FLAG，决定投入特殊部队SDC（Special Development Command），并命令带上摄影师记录他们的全部活动，这个人，正是冴子。 但是，装备了最新强化装甲HAVWC（High Agility Versatile Weapon Carrier），认为这是很容易的任务的特殊小队，遇到了意料之外的反击，陷入苦战…… 制作人员： 原作：高桥良辅 导演","date":"2006-06-16","objectID":"/anime/flag/:1:0","tags":null,"title":"FLAG","uri":"/anime/flag/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 白州冴子 しらす さえこ、Shirasu Saeko 女 田中麗奈 2 赤城圭一 あかぎ けいいち、Akagi Keiichi 男 石塚運昇 3 一柳信 いちやなぎ しん、Ichiyanagi Shin 男 川田紳司 4 クリス・エバーソルト Chris Eversalt 女 日高奈留美 5 ナディ・オロウカンディ 男 長嶝高士 6 ハカン・アクバル 女 佐藤ゆうこ 7 ラウェル・スーミン 女 浅川悠 8 ヤン・ニッカネン 男 乃村健次 ","date":"2006-06-16","objectID":"/anime/flag/:2:0","tags":null,"title":"FLAG","uri":"/anime/flag/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 FLAG 2006-06-16 13 9anime 2 FLAG 一千万库夫拉的记录 2007-08-08 1 bilibili ","date":"2006-06-16","objectID":"/anime/flag/:3:0","tags":null,"title":"FLAG","uri":"/anime/flag/"},{"categories":null,"content":"天空的圣魔法王国的公主田中蒲妮惠为了要成为下任女王到人间来修业，虽然外表看起来只是可爱柔弱的魔法少女，但真面目是为了登上大位不惜排除一切障碍的马基亚维利主义者，除了魔法外，还擅长各式让对手肉体跟精神完全破坏的关节技，在人间的修业中到底有多少人会被人间推土机给铲平呢？","date":"2006-04-05","objectID":"/anime/dai_mahou_touge/","tags":null,"title":"大魔法峠","uri":"/anime/dai_mahou_touge/"},{"categories":null,"content":"简介 天空的圣魔法王国的公主田中蒲妮惠为了要成为下任女王到人间来修业，虽然外表看起来只是可爱柔弱的魔法少女，但真面目是为了登上大位不惜排除一切障碍的马基亚维利主义者，除了魔法外，还擅长各式让对手肉体跟精神完全破坏的关节技，在人间的修业中到底有多少人会被人间推土机给铲平呢？ 制作人员： 原作：大和田秀树 导演：水岛努 分镜：池端隆史、常磐一郎 音乐：高木隆次 ","date":"2006-04-05","objectID":"/anime/dai_mahou_touge/:1:0","tags":null,"title":"大魔法峠","uri":"/anime/dai_mahou_touge/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 田中蒲妮惠 普妮耶、田中ぷにえ、たなか ぷにえ、tanaka punie 女 佐藤利奈 2 帕亚哒 パヤたん、Paya-tan 男 中田譲治 3 国铁子 国鉄子、Koku Tetsuko 女 下屋則子 4 大姐头 姉御 女 川澄綾子 5 田中纯 女 齋藤彩夏 6 田中萤 女 花澤香菜 ","date":"2006-04-05","objectID":"/anime/dai_mahou_touge/:2:0","tags":null,"title":"大魔法峠","uri":"/anime/dai_mahou_touge/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 大魔法峠 2006-04-05 8 bilibili ","date":"2006-04-05","objectID":"/anime/dai_mahou_touge/:3:0","tags":null,"title":"大魔法峠","uri":"/anime/dai_mahou_touge/"},{"categories":null,"content":"昭和58年的夏天，白天蝉的喧闹与傍晚茅蜩的合唱仿佛在欢迎今年早夏来临的6月，回荡在雏见泽。\n雏见泽是远离都会的深山中的一个穷乡僻壤。\n人口不足2千人的村子里，最近来了个从都会搬迁过来的少年前原圭一。性格开朗善于交际的圭一在学校里很快融入了周围的同学中。关系最好的喜欢照顾人的丽娜、具有领导才能的委员长魅音、盘球高手的低年级学生沙都子、古手神社千金且带来不可思议的气氛的梨花…\n他与伙伴们过着微不足道的日常生活，并以为会永远持续下去。\n每年6月举行的祭奠---绵流，没错，那一天也应该是快乐的一天的。\n然而在知道了一个关于雏见泽的谜之后，一切都改变了…\n在祭奠当日，惨剧再次发生。每年据说都会有一个人死亡，一个人行踪不明。自数年之前开始的连续怪死事件，其真相是？犯人是？圭一由于好奇心的驱使，步入了村子的黑暗之中。从那天起，圭一的周围发生了微妙但确实显而易见的变化。没错，所有一切都…\n只有茅蜩的鸣叫声一点未变，在雏见泽预告着早夏的来临。","date":"2006-04-04","objectID":"/anime/when_they_cry/","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"简介 昭和58年的夏天，白天蝉的喧闹与傍晚茅蜩的合唱仿佛在欢迎今年早夏来临的6月，回荡在雏见泽。 雏见泽是远离都会的深山中的一个穷乡僻壤。 人口不足2千人的村子里，最近来了个从都会搬迁过来的少年前原圭一。性格开朗善于交际的圭一在学校里很快融入了周围的同学中。关系最好的喜欢照顾人的丽娜、具有领导才能的委员长魅音、盘球高手的低年级学生沙都子、古手神社千金且带来不可思议的气氛的梨花… 他与伙伴们过着微不足道的日常生活，并以为会永远持续下去。 每年6月举行的祭奠—绵流，没错，那一天也应该是快乐的一天的。 然而在知道了一个关于雏见泽的谜之后，一切都改变了… 在祭奠当日，惨剧再次发生。每年据说都会有一个人","date":"2006-04-04","objectID":"/anime/when_they_cry/:1:0","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 前原圭一 越后屋、K、前原 圭一、まえばら けいいち、Maebara Keiichi 男 保志総一朗 2 龙宫礼奈 龙宫蕾娜、龙宫怜奈、竜宮レナ/竜宮礼奈、りゅうぐう れな/りゅうぐう れいな、Ryuuguu Rena/Ryuuguu Reina 女 中原麻衣 3 园崎魅音 そのざき みおん、Sonozaki Mion 女 ゆきのさつき 4 北条沙都子 北条 沙都子、ほうじょう さとこ、Houjou Satoko 女 かないみか 5 古手梨花 咪啪、ふるでりか、Furude Rika、魔法少女 御社神梨花 女 田村ゆかり 6 园崎诗音 そのざき しおん、So","date":"2006-04-04","objectID":"/anime/when_they_cry/:2:0","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 寒蝉鸣泣之时 2006-04-04 26 樱花 2 寒蝉鸣泣之时 解 2007-07-05 24 樱花 ","date":"2006-04-04","objectID":"/anime/when_they_cry/:3:0","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"MAD ","date":"2006-04-04","objectID":"/anime/when_they_cry/:4:0","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"舞台是充满兽耳•兽尾•有翼族的古装•异族•战国时代，据说在服饰、固有名词等方面参考了现在生活在北海道中北部的阿伊努民族。\n\n剧情以受伤倒在路边的面罩男哈库奥罗接受素未谋面的兽耳少女艾露露的治疗为起点，经历了哈库奥罗领导人民起义反抗暴政、领导卫国斗争、解放他国受压迫民众的战争到保卫全世界大致四个阶段。大陆的历史以及哈库奥罗究竟是谁、这些异民族又是如何产生等问题在战争的扩大化中逐步得到解决。\n\n人设由甘露树包揽，萌度十足。剧情从结尾看是泣系，从内容看是架空历史，设定丰富，整体看起来已经够独特的民族风最后染上超未来要素让人眼前一亮。","date":"2006-04-03","objectID":"/anime/utawarerumono/","tags":null,"title":"传颂之物","uri":"/anime/utawarerumono/"},{"categories":null,"content":"简介 舞台是充满兽耳•兽尾•有翼族的古装•异族•战国时代，据说在服饰、固有名词等方面参考了现在生活在北海道中北部的阿伊努民族。 剧情以受伤倒在路边的面罩男哈库奥罗接受素未谋面的兽耳少女艾露露的治疗为起点，经历了哈库奥罗领导人民起义反抗暴政、领导卫国斗争、解放他国受压迫民众的战争到保卫全世界大致四个阶段。大陆的历史以及哈库奥罗究竟是谁、这些异民族又是如何产生等问题在战争的扩大化中逐步得到解决。 人设由甘露树包揽，萌度十足。剧情从结尾看是泣系，从内容看是架空历史，设定丰富，整体看起来已经够独特的民族风最后染上超未来要素让人眼前一亮。 制作人员： 原作：アクアプラス、Leaf 导演：小林智树 脚本：","date":"2006-04-03","objectID":"/anime/utawarerumono/:1:0","tags":null,"title":"传颂之物","uri":"/anime/utawarerumono/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾露露 エルルゥ、Eruruu 女 柚木涼香 2 阿露露 アルルゥ、Aruruu 女 沢城みゆき 3 哈克奥罗 Hakuoro、ハクオロ、白皇 男 小山力也 4 多利、古拉 ドリィ ＆ グラァ、dory ＆ gura 男 渡辺明乃 5 贝纳威 ベナウィ、Benawi 男 浪川大輔 6 克罗 クロウ、Kurou 男 小山剛志 7 藤香 东霞、トウカ、Touka 女 三宅華也 8 卡露拉 カルラゥアツゥレイ、Karura 女 田中敦子 ","date":"2006-04-03","objectID":"/anime/utawarerumono/:2:0","tags":null,"title":"传颂之物","uri":"/anime/utawarerumono/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 传颂之物 2006-04-03 26 bilibili 2 传颂之物 虚伪的假面 2015-10-03 25 樱花 3 传颂之物 二人的白皇 2022-07-02 28 bilibili ","date":"2006-04-03","objectID":"/anime/utawarerumono/:3:0","tags":null,"title":"传颂之物","uri":"/anime/utawarerumono/"},{"categories":null,"content":"　　舞台设定在了地球以外的其他星球。人们把自己所在的星球称为“大空陆”。在那里，人类一出生就必须以“女性”的身份生活。等到17岁的时候到“泉”那里，选择性别而成为大人的时刻。\n为了夺取主人公等所在的宫国所持有的珍贵引擎，邻国开始了日益激烈的侵略。为了迎击敌国，宫国被迫将仪式用复座式飞行艇“Simoun”改造成了战斗用战舰。还需要未性别化的“巫女”被派遣担任驾驶员，于是，她们成为了被称为“coru”的战斗小队成员。\n操纵“Simoun”的少数少女被称为了“Simoun·シヴュラ（西贝拉）”因为拥有着特殊能力，她们可以选择自己成为大人的时间。但是因为战争的爆发，她们的优秀才能不得不运用在“Simoun”的操作上，换句话说，她们被强迫保持在了“少女阶段”……","date":"2006-04-03","objectID":"/anime/simoun/","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"简介 舞台设定在了地球以外的其他星球。人们把自己所在的星球称为“大空陆”。在那里，人类一出生就必须以“女性”的身份生活。等到17岁的时候到“泉”那里，选择性别而成为大人的时刻。 为了夺取主人公等所在的宫国所持有的珍贵引擎，邻国开始了日益激烈的侵略。为了迎击敌国，宫国被迫将仪式用复座式飞行艇“Simoun”改造成了战斗用战舰。还需要未性别化的“巫女”被派遣担任驾驶员，于是，她们成为了被称为“coru”的战斗小队成员。 操纵“Simoun”的少数少女被称为了“Simoun·シヴュラ（西贝拉）”因为拥有着特殊能力，她们可以选择自己成为大人的时间。但是因为战争的爆发，她们的优秀才能不得不运用在“Sim","date":"2006-04-03","objectID":"/anime/simoun/:1:0","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿艾尔 アーエル、Aaeru 女 新野美知 2 奈比利尔 Neviril、ネヴィリル、Neviriru 女 高橋理恵子 3 芭拉耶特 パライエッタ、Paraietta 女 小清水亜美 4 凯姆 カイム、Kaimu 女 細越みちこ 5 阿尔提 アルティ 女 豊口めぐみ 6 芙罗耶 Furoe、フロエ、Furoe 女 相澤みちる 7 罗德雷亚蒙 ロードレアモン 女 高橋美佳子 8 里莫奈 リモネ、Rimone 女 能登麻美子 ","date":"2006-04-03","objectID":"/anime/simoun/:2:0","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 西蒙 2006-04-03 26 下方 ","date":"2006-04-03","objectID":"/anime/simoun/:3:0","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"配乐 ","date":"2006-04-03","objectID":"/anime/simoun/:4:0","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"　　“我毕业于东中，叫做凉宫春日。我对普通的人类没有兴趣。你们之中要是有外星人、未来人、异世界人或者超能力者的话，就尽管来找我吧。”这是凉宫春日的宣言，也是她对于平庸生活的挑战。\n　　我们可能在很小时就不再相信圣诞老人的存在，也慢慢不会再对外星人，特异功能等等产生幻想。在生活的教化下习惯于平淡无奇的生活。可是不安于现状的凉宫同学却勇敢的建立起SOS团，用强烈的意志去试图改造这个了无新意的世界。她的忧郁，究竟从何而来，又将从何而去。","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"简介 “我毕业于东中，叫做凉宫春日。我对普通的人类没有兴趣。你们之中要是有外星人、未来人、异世界人或者超能力者的话，就尽管来找我吧。”这是凉宫春日的宣言，也是她对于平庸生活的挑战。 我们可能在很小时就不再相信圣诞老人的存在，也慢慢不会再对外星人，特异功能等等产生幻想。在生活的教化下习惯于平淡无奇的生活。可是不安于现状的凉宫同学却勇敢的建立起SOS团，用强烈的意志去试图改造这个了无新意的世界。她的忧郁，究竟从何而来，又将从何而去。 制作人员： 原作：谷川流 导演：石原立也 脚本：贺东招二、志茂文彦、山本宽、村元克彦、伊藤敦 ","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/:1:0","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿虚 约翰・史密斯（ジョン・スミス）、キョン、Kyon 男 杉田智和 2 凉宫春日 すずみや はるひ、Suzumiya Haruhi、团长 女 平野綾 3 长门有希 长门大明神、長門 有希、ながと ゆき、Nagato Yuki 女 茅原実里 4 朝比奈实玖瑠 あさひな みくる、Asahina Mikuru 女 後藤邑子 5 古泉一树 こいずみ いつき、Koizumi Itsuki 男 小野大輔 6 让世界变得更热闹的凉宫春日的团 Spreading Excitement all Over the World with Haruhi Suzumiya Brig","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/:2:0","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 凉宫春日的忧郁 2006-04-02 14 bilibili 2 凉宫春日的忧郁 2009 2009-04-02 28 bilibili 3 凉宫春日的消失 2010-02-06 1 bilibili ","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/:3:0","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"MAD ","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/:4:0","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"备长炭没有父母，头上顶着炭，独自住在深山之中（为木炭成为萌系元素双手鼓掌=V=）。她常常下山到小镇上给人们帮忙做工，居民们为了表示感谢而赠与她食物，备长炭就这样努力地生活着。而给居民们带来了温馨与快乐的备长炭，也交到了一个个好朋友。平时足不出户地有钱人家大小姐·狸炭，和药师爷爷生活在一起的喜爱发明的活泼女孩·竹炭，成天跟在竹炭后面的小妹·竹林，还有拥有神奇力量的练炭……围绕着这群可爱的小LOLI，一个个温馨的故事即将展开。因为走的是“治愈系”动画的路线，因此在剧情方面可以说是平淡，而邀请了岩崎琢创作配乐则让很多人感到意外，喜欢萌系和治愈类的朋友不妨一看。","date":"2006-02-02","objectID":"/anime/binchou-tan/","tags":null,"title":"备长炭","uri":"/anime/binchou-tan/"},{"categories":null,"content":"简介 备长炭没有父母，头上顶着炭，独自住在深山之中（为木炭成为萌系元素双手鼓掌=V=）。她常常下山到小镇上给人们帮忙做工，居民们为了表示感谢而赠与她食物，备长炭就这样努力地生活着。而给居民们带来了温馨与快乐的备长炭，也交到了一个个好朋友。平时足不出户地有钱人家大小姐·狸炭，和药师爷爷生活在一起的喜爱发明的活泼女孩·竹炭，成天跟在竹炭后面的小妹·竹林，还有拥有神奇力量的练炭……围绕着这群可爱的小LOLI，一个个温馨的故事即将展开。因为走的是“治愈系”动画的路线，因此在剧情方面可以说是平淡，而邀请了岩崎琢创作配乐则让很多人感到意外，喜欢萌系和治愈类的朋友不妨一看。 制作人员： 原作：江草天仁 导演","date":"2006-02-02","objectID":"/anime/binchou-tan/:1:0","tags":null,"title":"备长炭","uri":"/anime/binchou-tan/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 备长炭 Binchou-tan、びんちょうタン、びんちょうタン、Binchoutan 女 野中藍 2 竹炭 Chiku-tan 女 門脇舞以 3 柞炭 Kunugi-tan 女 野川さくら 4 练炭 れんタン、Ren-tan 女 佐藤利奈 5 芦荟 Aloe-tan 女 斎藤桃子 6 竹林 ちくリン、Chiku-rin 女 福圓美里 ","date":"2006-02-02","objectID":"/anime/binchou-tan/:2:0","tags":null,"title":"备长炭","uri":"/anime/binchou-tan/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 备长炭 2006-02-02 12 bilibili ","date":"2006-02-02","objectID":"/anime/binchou-tan/:3:0","tags":null,"title":"备长炭","uri":"/anime/binchou-tan/"},{"categories":null,"content":"传说中，圣杯是能够实现拥有者愿望的宝物。 为了让这圣杯出现必须要进行一项仪式 被圣杯所选的七位魔术师MASTER 将被赐与圣杯所选出的七位使魔SERVANT 剑士“SABER” 枪兵“LANCER” 弓兵“ARCHER” 骑兵“RIDER” 魔术师“CASTER” 暗杀者“ASSASSIN” 狂战士“BERSERKER” 魔术师必须与这七种类的使魔其中一位订下契约并证明自己是最适合圣杯的人 换言之，魔术师必须消去其它的魔术师来证明自己是最强的 这样一整个求取圣杯的仪式被称为 “圣杯战争……","date":"2006-01-06","objectID":"/anime/fate_stay_night/","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"简介 传说中，圣杯是能够实现拥有者愿望的宝物。 为了让这圣杯出现必须要进行一项仪式 被圣杯所选的七位魔术师MASTER 将被赐与圣杯所选出的七位使魔SERVANT 剑士“SABER” 枪兵“LANCER” 弓兵“ARCHER” 骑兵“RIDER” 魔术师“CASTER” 暗杀者“ASSASSIN” 狂战士“BERSERKER” 魔术师必须与这七种类的使魔其中一位订下契约并证明自己是最适合圣杯的人 换言之，魔术师必须消去其它的魔术师来证明自己是最强的 这样一整个求取圣杯的仪式被称为 “圣杯战争…… 制作人员： 原作：奈须蘑菇、型月 导演：山口祐司 脚本：志茂文彦、佐藤卓哉、花田十辉、冈田麿里 分","date":"2006-01-06","objectID":"/anime/fate_stay_night/:1:0","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿尔托莉雅·潘德拉贡 Saber、呆毛王、吾王、青王、骑士王、棉被王、亚瑟王、蓝Saber、元祖Saber、Altria Pendragon、セイバー 女 川澄綾子 2 卫宫士郎 衛宮 士郎、えみや しろう、Emiya Shirou 男 野田順子 3 吉尔伽美什 Gilgamesh、金皮卡、金闪闪、金A、英雄王、AUO 男 関智一 4 卫宫 红茶，红A，阿茶，背影侠、英灵卫宫、Emiya、英霊エミヤ、Archer、Faker 男 諏訪部順一 5 美狄亚 Μήδεια、Medea、C妈 女 田中敦子 6 伊莉雅斯菲尔·冯·爱因兹贝伦 伊莉雅丝菲尔·冯·爱因兹贝","date":"2006-01-06","objectID":"/anime/fate_stay_night/:2:0","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Fate/stay night 2006-01-06 24 bilibili 2 Fate/stay night UNLIMITED BLADE WORKS 2010-01-23 1 bilibili 3 Fate/stay night [Unlimited Blade Works] 2014-10-04 13 bilibili 4 Fate/stay night [Unlimited Blade Works] 第二季 2015-04-04 13 bilibili 5 剧场版 Fate/stay night [Heaven’s Feel] I.","date":"2006-01-06","objectID":"/anime/fate_stay_night/:3:0","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"MAD ","date":"2006-01-06","objectID":"/anime/fate_stay_night/:4:0","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"2005年12月14日开始出版《I''ss Pure》的系列动画，共6集。动画采取从一贵圣诞节时和伊织约会为开始，以追忆的方式描述了他在中学期间对伊织的追求故事。与漫画不同的是，漫画中的心理描写和比较暴露的情色情节都被忽略或者简化，并采用《一贵的妄想日记》的方式与主情节分开来描述主人公的性幻想部分。","date":"2005-11-01","objectID":"/anime/i_s_pure/","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"简介 2005年12月14日开始出版《I\"s Pure》的系列动画，共6集。动画采取从一贵圣诞节时和伊织约会为开始，以追忆的方式描述了他在中学期间对伊织的追求故事。与漫画不同的是，漫画中的心理描写和比较暴露的情色情节都被忽略或者简化，并采用《一贵的妄想日记》的方式与主情节分开来描述主人公的性幻想部分。 制作人员： 原作：桂正和 导演：神户守 脚本：大石哲也 分镜：小高义规、岩永彰 音乐：小西香叶 ","date":"2005-11-01","objectID":"/anime/i_s_pure/:1:0","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 濑户一贵 瀬戸 一貴、せと いちたか、Seto Ichitaka 男 野村勝人 2 苇月伊织 葦月 伊織、よしづき いおり、Yoshizuki Iori 女 伊藤静 3 矶崎泉 磯崎 泉、いそざき　いずみ、Isozaki Izumi 女 門脇舞以 4 秋叶季子 秋葉 いつき、あきば いつき、Akiba Itsuki 女 中世明日香 5 寺谷靖雅 寺谷 靖雅、てらたに やすまさ、Teratani Yasumasa 男 こぶしのぶゆき 6 森崎祐加 森崎 祐加、もりさき ゆうか 女 後藤邑子 7 奈美 女 鈴木菜穂子 ","date":"2005-11-01","objectID":"/anime/i_s_pure/:2:0","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 I\"s Pure 2005-11-01 6 樱花 ","date":"2005-11-01","objectID":"/anime/i_s_pure/:3:0","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"MAD ","date":"2005-11-01","objectID":"/anime/i_s_pure/:4:0","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"这里的虫既不是动植物，也与微生物和菌类不同，是更接近生命原生态的东西。这些东西总称为“虫”。它们的形态和存在都很暧昧，当人与虫的世界重叠之时，发生了超越人类智慧的怪异现象，此时人类才开始知道它们的存在。\n所谓生命，并非为威胁异己而存在。只是，各自以各自的形态存在着——作为连接这样的”虫“与人类的”虫师“--主人公银古，在旅途中不断与各种各样的人及与其关联的虫相遇。绘就了每话登场人物各不相同，读不尽的画卷。","date":"2005-10-22","objectID":"/anime/mushishi/","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"简介 这里的虫既不是动植物，也与微生物和菌类不同，是更接近生命原生态的东西。这些东西总称为“虫”。它们的形态和存在都很暧昧，当人与虫的世界重叠之时，发生了超越人类智慧的怪异现象，此时人类才开始知道它们的存在。 所谓生命，并非为威胁异己而存在。只是，各自以各自的形态存在着——作为连接这样的”虫“与人类的”虫师“–主人公银古，在旅途中不断与各种各样的人及与其关联的虫相遇。绘就了每话登场人物各不相同，读不尽的画卷。 制作人员： 原作：漆原友纪 导演：长滨博史 脚本：桑畑绢子、山田由香、伊丹秋 分镜：成田岁法、宫下新平、岛村秀一、长峰达也 ","date":"2005-10-22","objectID":"/anime/mushishi/:1:0","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 银古 ヨキ、Ginko 男 沢城みゆき 2 奴伊 ぬい、Nui 女 土井美加 3 化野 Adashino、化野 男 うえだゆうじ 4 廉子 れんず、Renzu 女 伊瀬茉莉也 5 五百藏森罗 五百蔵しんら、Ioroi Shinra 男 三瓶由布子 6 翠 スイ、Sui 女 岡明子 7 齐 ビキ、Biki 男 國分優香里 8 真火 真火、Maho 男 本城雄太郎 ","date":"2005-10-22","objectID":"/anime/mushishi/:2:0","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 虫师 2005-10-22 26 bilibili 2 虫师 特別篇 蚀日之翳 2014-01-04 1 樱花 3 虫师 续章 2014-04-04 11 樱花 4 虫师 续章 第2期 2014-10-18 10 樱花 5 虫师 特别篇 铃之雫 2015-05-16 1 bilibili ","date":"2005-10-22","objectID":"/anime/mushishi/:3:0","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"MAD ","date":"2005-10-22","objectID":"/anime/mushishi/:4:0","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"本故事的时代背景在24世纪。彼时人类在火星上进行行星地球化改造工程，由于两极冰帽融解的水量超乎预期，全星球有90%被海洋覆盖，因而被人称呼为「水星」（AQUA）。在此星球上有个以过去被称为水都的威尼斯为范本所建造的城市新威尼斯（Neo-Venezia），因其仿古的建筑与承袭传统的生活方式而广受观光客喜爱，而其中有一种驾驶小舟穿梭于运河之间，带领观光客游览整座城市的职业，被称为领航员（Undine）。\n出身于地球的水无灯里，以成为能独当一面的领航员为目标而来到新威尼斯，目前在艾莉西亚和亚利亚社长的Aria Company中见习。身为半熟手的她，每天都持续练习操控贡多拉及观光导览。《水星领航员》便是在描写灯里以及她身旁的朋友在一年四季中的日常生活点滴。","date":"2005-10-05","objectID":"/anime/aria/","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"简介 本故事的时代背景在24世纪。彼时人类在火星上进行行星地球化改造工程，由于两极冰帽融解的水量超乎预期，全星球有90%被海洋覆盖，因而被人称呼为「水星」（AQUA）。在此星球上有个以过去被称为水都的威尼斯为范本所建造的城市新威尼斯（Neo-Venezia），因其仿古的建筑与承袭传统的生活方式而广受观光客喜爱，而其中有一种驾驶小舟穿梭于运河之间，带领观光客游览整座城市的职业，被称为领航员（Undine）。 出身于地球的水无灯里，以成为能独当一面的领航员为目标而来到新威尼斯，目前在艾莉西亚和亚利亚社长的Aria Company中见习。身为半熟手的她，每天都持续练习操控贡多拉及观光导览。《水星领航","date":"2005-10-05","objectID":"/anime/aria/:1:0","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 水无灯里 遥阔湛蓝（Aquamarine）、遙かなる蒼（アクアマリン）、Akari Mizunashi、みずなし あかり、Mizunashi Akari 女 葉月絵理乃 2 蓝华·S·葛兰基斯塔 蔷薇女王（Rozen Queen）、薔薇の女王（ローゼン・クイーン）、Aika S. Granzchesta、藍華・S・グランチェスタ、あいか えす グランチェスタ、Aika Esu Guranchesuta、划二代 女 斎藤千和 3 爱丽丝·凯洛尔 黄昏的公主（Orange Princess）、黄昏の姫君（オレンジ・プリンセス）、爱莉丝·卡罗尔、爱理须·凯洛尔、A","date":"2005-10-05","objectID":"/anime/aria/:2:0","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 水星领航员 2005-10-05 13 樱花 2 水星领航员 第二季 2006-04-02 26 樱花 3 水星领航员 OVA ～ARIETTA～ 2007-09-21 1 樱花 4 水星领航员 第三季 2008-01-07 14 樱花 5 水星领航员 The AVVENIRE 2015-09-26 3 樱花 6 水星领航员 The CREPUSCOLO 2021-03-05 1 樱花 7 水星领航员 The BENEDIZIONE 2021-12-03 1 樱花 ","date":"2005-10-05","objectID":"/anime/aria/:3:0","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"MAD ","date":"2005-10-05","objectID":"/anime/aria/:4:0","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"　某一天在平凡的高中生坂井悠二的身旁，出现了一位名叫“炎发灼眼的追踪者”夏娜的少女，她告诉悠二，说他的生命马上就要结束了——原来在这个世界之外，还有另一个被称作“红世”的世界，那里的人们为了实现他们的野心，将人类身上的世界本源之力“存在之力”陆续夺走。悠二就受害者之一。红世之徒将“存在”夺走之后，为了缓和现实中产生的扭曲，还会留下“Torch（烛火）”作为代替。然后随着时间的推移，“Torch（烛火）”也终将从人们的记忆中淡去。修二的命运究竟会怎样呢？\n","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"简介 某一天在平凡的高中生坂井悠二的身旁，出现了一位名叫“炎发灼眼的追踪者”夏娜的少女，她告诉悠二，说他的生命马上就要结束了——原来在这个世界之外，还有另一个被称作“红世”的世界，那里的人们为了实现他们的野心，将人类身上的世界本源之力“存在之力”陆续夺走。悠二就受害者之一。红世之徒将“存在”夺走之后，为了缓和现实中产生的扭曲，还会留下“Torch（烛火）”作为代替。然后随着时间的推移，“Torch（烛火）”也终将从人们的记忆中淡去。修二的命运究竟会怎样呢？ 制作人员： 原作：高桥弥七郎 导演：渡部高志 脚本：白根秀树、小林靖子、佐藤胜一 分镜：橘秀树、池端隆史、中村宪由、福田道生 ","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/:1:0","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 夏娜 炎发灼眼的杀手、Shana、シャナ、syana、钉宫四萌 女 釘宮理恵 2 坂井悠二 坂井 悠二、Sakai Yuuji 男 日野聡 3 吉田一美 吉田 一美、Yoshida Kazumi 女 川澄綾子 4 玛琼琳·朵 Margery Daw 女 生天目仁美 5 威尔艾米娜·卡梅尔 ヴィルヘルミナ・カルメル、Wilhelmina Carmel 女 伊藤静 6 亚拉斯特尔 Flame-Haired Burning-Eyed Hunter、えんぱつしゃくがんのうちて、Enpatsu Shakugan no Uchite ？ 江原正士 7 池速人 池 人、I","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/:2:0","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 灼眼的夏娜 2005-10-05 24 bilibili 2 灼眼的夏娜 恋爱和温泉校外学习 2006-12-08 1 bilibili 3 灼眼的夏娜 剧场版 2007-04-21 1 bilibili 4 灼眼的夏娜 第二季 2007-10-04 24 bilibili 5 灼眼的夏娜S 2009-10-23 4 bilibili 6 灼眼的夏娜 Final 2011-10-07 24 bilibili 7 灼眼的夏娜炭 2006-01-25 15 bilibili ","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/:3:0","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"MAD ","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/:4:0","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"       下着雨的偏僻的麻将馆中，出现了一个由于无事可做而沉溺于麻将的少年。无论是谁，看到他那雪白的头发，都会情不自禁的想象他至今走过的人生。少年的名字叫akagi……\n　　作者以麻雀贯穿整部作品加之阴暗的背景和大量的心里描写竟然能够想像出那么多不符合常理的事情来！可想而知作者对这部作品付出了多少心血！一部关于麻雀的作品,作者竟然能计算出了那么多东西！实在难能可贵！\n　　人物的造型设计个性，这种新的动画风格,使整部动画更加的”写实”化了． ","date":"2005-10-04","objectID":"/anime/akagi/","tags":null,"title":"斗牌传说","uri":"/anime/akagi/"},{"categories":null,"content":"简介 下着雨的偏僻的麻将馆中，出现了一个由于无事可做而沉溺于麻将的少年。无论是谁，看到他那雪白的头发，都会情不自禁的想象他至今走过的人生。少年的名字叫akagi…… 作者以麻雀贯穿整部作品加之阴暗的背景和大量的心里描写竟然能够想像出那么多不符合常理的事情来！可想而知作者对这部作品付出了多少心血！一部关于麻雀的作品,作者竟然能计算出了那么多东西！实在难能可贵！ 人物的造型设计个性，这种新的动画风格,使整部动画更加的”写实”化了． 制作人员： 原作：福本伸行 导演：佐藤雄三 脚本：广田光毅、浦畑达彦、高屋敷英夫、笔安一幸 分镜：增原光幸、若林汉二 ","date":"2005-10-04","objectID":"/anime/akagi/:1:0","tags":null,"title":"斗牌传说","uri":"/anime/akagi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 赤木茂 赤木しげる、あかぎ しげる 男 萩原聖人 2 安冈 やすおか 男 玄田哲章 3 鹫巢严 鷲巣巌、Washizu Iwao 男 津嘉山正種 4 南乡 なんごう 男 小山力也 5 矢木圭次 やぎ けいじ 男 高木渉 6 市川 男 田中秀幸 7 治 おさむ 男 佐藤雄大 8 伪赤木 假赤木、平山幸雄、ひらやま ゆきお 男 佐藤銀平 ","date":"2005-10-04","objectID":"/anime/akagi/:2:0","tags":null,"title":"斗牌传说","uri":"/anime/akagi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 斗牌传说 2005-10-04 26 bilibili ","date":"2005-10-04","objectID":"/anime/akagi/:3:0","tags":null,"title":"斗牌传说","uri":"/anime/akagi/"},{"categories":null,"content":"男主角，一个正常的20岁男子，在考到驾驶执照那天,身体突然不适  \n经过一段时间的反覆住院和治疗後，被安排到了医院7楼,戴上了白色手环....  \n医生的说法是：在这里是为了静养和等待医学的进步  \n但他在7f认识的一个少女告诉他：这不过是骗人的  \n7F是全医院最少进行治疗的地方  \n也就是说,这里是个让人等死的地方......  \n故事就这样开始","date":"2005-08-01","objectID":"/game/narcissu/","tags":null,"title":"水仙","uri":"/game/narcissu/"},{"categories":null,"content":"简介 男主角，一个正常的20岁男子，在考到驾驶执照那天,身体突然不适 经过一段时间的反覆住院和治疗後，被安排到了医院7楼,戴上了白色手环…. 医生的说法是：在这里是为了静养和等待医学的进步 但他在7f认识的一个少女告诉他：这不过是骗人的 7F是全医院最少进行治疗的地方 也就是说,这里是个让人等死的地方…… 故事就这样开始 制作人员： 开发：ステージなな 剧本：片冈智 音乐：矢野雅士、Dreaming Rabbit、Elements Garden、Barbarian On The Groove、猫野こめっと、Ebi、上松范康 ","date":"2005-08-01","objectID":"/game/narcissu/:1:0","tags":null,"title":"水仙","uri":"/game/narcissu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 筱原姬子 篠原 姫子、しのはら ひめこ、shinohara himeko、姬子、ひめこ 女 やなせなつみ 2 佐仓濑津美 佐倉 瀬津美、さくら せつみ、Sakura Setsumi、セツミ 女 綾川りの 3 筱原千寻 篠原 千尋、千尋、ちひろ 女 後藤邑子 4 昭岛优花 昭島 優花、優花、ゆか 女 岩居由希子 5 小女孩 女 能登麻美子 ","date":"2005-08-01","objectID":"/game/narcissu/:2:0","tags":null,"title":"水仙","uri":"/game/narcissu/"},{"categories":null,"content":"系列 系列名 发行时间 1 水仙 2005-08-01 2 水仙2 2007-05-16 ","date":"2005-08-01","objectID":"/game/narcissu/:3:0","tags":null,"title":"水仙","uri":"/game/narcissu/"},{"categories":null,"content":"配乐 ","date":"2005-08-01","objectID":"/game/narcissu/:4:0","tags":null,"title":"水仙","uri":"/game/narcissu/"},{"categories":null,"content":"电视动画片“草莓棉花糖”，故事是通过相当可爱、性格迥异的四个小学生和一个20岁的短大女生展开的，一看就是描写普通日常生活的搞笑作品。\n时尚、稍显老成的动作，加上不断的愚蠢行为使整个动漫充满了忍俊不禁的场面。是一部男孩、女孩都会期待的呼之欲出的可爱爆笑动画片。\n描写小学女生们的惬意的日常生活的故事。伸惠与千佳是一对虽然年龄相差很大但感情却很好的姐妹。由于青梅竹马的朋友--美羽的关系，姐妹俩每天都被卷入奇奇怪怪的事件中。即使面对如此胡闹的美羽，姐妹俩与樱木茉莉还是默默忍受着。某日，千佳他们的学校来了个金发碧眼的美少女阿娜……","date":"2005-07-14","objectID":"/anime/ichigo_mashimaro/","tags":null,"title":"草莓棉花糖","uri":"/anime/ichigo_mashimaro/"},{"categories":null,"content":"简介 电视动画片“草莓棉花糖”，故事是通过相当可爱、性格迥异的四个小学生和一个20岁的短大女生展开的，一看就是描写普通日常生活的搞笑作品。 时尚、稍显老成的动作，加上不断的愚蠢行为使整个动漫充满了忍俊不禁的场面。是一部男孩、女孩都会期待的呼之欲出的可爱爆笑动画片。 描写小学女生们的惬意的日常生活的故事。伸惠与千佳是一对虽然年龄相差很大但感情却很好的姐妹。由于青梅竹马的朋友–美羽的关系，姐妹俩每天都被卷入奇奇怪怪的事件中。即使面对如此胡闹的美羽，姐妹俩与樱木茉莉还是默默忍受着。某日，千佳他们的学校来了个金发碧眼的美少女阿娜…… 制作人员： 原作：ばらスィー 导演：佐藤卓哉 脚本：平见瞠、花田十辉","date":"2005-07-14","objectID":"/anime/ichigo_mashimaro/:1:0","tags":null,"title":"草莓棉花糖","uri":"/anime/ichigo_mashimaro/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊藤伸惠 伊藤 伸恵、Itou Nobue 女 生天目仁美 2 伊藤千佳 いとう ちか、Itou Chika 女 千葉紗子 3 松冈美羽 松岡 美羽、まつおか みう、Matsuoka Miu、小美 女 折笠富美子 4 樱木茉莉 桜木 茉莉、さくらぎ まつり、Sakuragi Matsuri 女 川澄綾子 5 安娜·柯普拉 安娜·刻薄啦、Ana Coppola、安娜 女 能登麻美子 6 笹冢 屉冢、ささづか、Sasazuka 男 皆川純子 7 绀野爱子 紺野 愛子、こんの あいこ、Konno Aiko 女 福圓美里 8 5-2担任 男 近藤孝行 ","date":"2005-07-14","objectID":"/anime/ichigo_mashimaro/:2:0","tags":null,"title":"草莓棉花糖","uri":"/anime/ichigo_mashimaro/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 草莓棉花糖 2005-07-14 12 bilibili ","date":"2005-07-14","objectID":"/anime/ichigo_mashimaro/:3:0","tags":null,"title":"草莓棉花糖","uri":"/anime/ichigo_mashimaro/"},{"categories":null,"content":"　　神族、魔族、人类，三个不同的种族和世界，有一天通过一扇“门”联结了起来，从此三个种族生活在了一起，当然，在学校也不例外。\n　　土见凛，一个普通的男生，自幼双亲在一场事故中丧生，于是只能寄住在青梅竹马的芙蓉枫的家中。枫对凛一直有很深的感情，两人保持着平常的生活，直到有一天，神族的神王和魔族的魔王双双来到人间，并带来了他们两个可爱的女儿——西亚和奈莉奈。而凛居然要从她们两个中选择一个作为未婚妻！\n　　于是，一段复杂的恋爱故事就此开始……\n　　（二）故事发生在一所名为国立巴贝那学园的高校，普通高中生土见禀与自幼青梅竹马的女孩枫一起过着快乐安详的生活。因为10年前的一场巨变，神·人·魔三界的通道被打开，神界和魔界的居民开始在人界自由同行，三界的种族开始共同生活在一个社会里，随着时间的推移，人们也慢慢习以为常了。 \n　　某日，来自神界和魔界的两位美少女转校到巴贝那学园，她们为了寻找儿时的邂逅决定留在人界。从此禀的生活开始发生某种仿佛注定了的变化……\n","date":"2005-07-07","objectID":"/anime/shuffle/","tags":null,"title":"SHUFFLE!","uri":"/anime/shuffle/"},{"categories":null,"content":"简介 神族、魔族、人类，三个不同的种族和世界，有一天通过一扇“门”联结了起来，从此三个种族生活在了一起，当然，在学校也不例外。 土见凛，一个普通的男生，自幼双亲在一场事故中丧生，于是只能寄住在青梅竹马的芙蓉枫的家中。枫对凛一直有很深的感情，两人保持着平常的生活，直到有一天，神族的神王和魔族的魔王双双来到人间，并带来了他们两个可爱的女儿——西亚和奈莉奈。而凛居然要从她们两个中选择一个作为未婚妻！ 于是，一段复杂的恋爱故事就此开始…… （二）故事发生在一所名为国立巴贝那学园的高校，普通高中生土见禀与自幼青梅竹马的女孩枫一起过着快乐安详的生活。因为10年前的一场巨变，神·人·魔三界的通道被打开，神界","date":"2005-07-07","objectID":"/anime/shuffle/:1:0","tags":null,"title":"SHUFFLE!","uri":"/anime/shuffle/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 土见禀 つちみ りん 男 杉田智和 2 利希安瑟丝 Sia、Lisianthus、シア 女 あおきさやか 3 奈莉奈 ネリネ、Nerine 女 永見はるか 4 芙蓉枫 ふよう かえで、Fuyou Kaede 女 後藤邑子 5 时雨亚沙 しぐれ あさ 女 伊藤美紀 6 普莉姆拉 プリムラ、Primula 女 ひと美 7 枯叶 カレハ、Kareha 女 日向裕羅 8 麻弓百里香 麻弓タイム、Mayumi Thyme、まゆみ タイム、Mayumi Taimu 女 井上美紀 ","date":"2005-07-07","objectID":"/anime/shuffle/:2:0","tags":null,"title":"SHUFFLE!","uri":"/anime/shuffle/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 SHUFFLE! 2005-07-07 24 bilibili ","date":"2005-07-07","objectID":"/anime/shuffle/:3:0","tags":null,"title":"SHUFFLE!","uri":"/anime/shuffle/"},{"categories":null,"content":"　　在机缘巧合之下，普通的中学生一桥友里惠居然成为了法力高强的神！友里惠在第一时间将这一好消息告诉了好友四条光惠和三枝祀，没想到自己的兴高采烈换来的却是朋友的冷漠相对，气愤的友里惠和朋友们打赌，要用神迹来证实她的身份。台风的来袭证明了友里惠的话，也给城市带来了不小的麻烦，这让友里惠明白了，越是高强的能力，就越要小心的使用。 \n　　神也要恋爱呀，在友里惠的眼里，二宫健儿就是那个集万千有点为一身的他。对待感情有些笨拙的友里惠能否如有神助地对二宫健儿坦白自己的心思呢？","date":"2005-06-29","objectID":"/anime/kamichu/","tags":null,"title":"神是中学生","uri":"/anime/kamichu/"},{"categories":null,"content":"简介 在机缘巧合之下，普通的中学生一桥友里惠居然成为了法力高强的神！友里惠在第一时间将这一好消息告诉了好友四条光惠和三枝祀，没想到自己的兴高采烈换来的却是朋友的冷漠相对，气愤的友里惠和朋友们打赌，要用神迹来证实她的身份。台风的来袭证明了友里惠的话，也给城市带来了不小的麻烦，这让友里惠明白了，越是高强的能力，就越要小心的使用。 神也要恋爱呀，在友里惠的眼里，二宫健儿就是那个集万千有点为一身的他。对待感情有些笨拙的友里惠能否如有神助地对二宫健儿坦白自己的心思呢？ 制作人员： 原作：Besame Mucho 导演：舛成孝二 脚本：仓田英之 分镜：福田道生、岛崎奈奈子、儿玉兼嗣、山本泰一郎、小坂春女 ","date":"2005-06-29","objectID":"/anime/kamichu/:1:0","tags":null,"title":"神是中学生","uri":"/anime/kamichu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 一桥由利绘 一橋 ゆりえ、ひとつばし ゆりえ 女 MAKO 2 三枝祀 三枝祀、Saegusa Matsuri 女 森永理科 3 四条光惠 四条 光恵 女 峯香織 4 三枝御子 三枝みこ、Saegusa Miko 女 野中藍 5 八岛神 八島様、Yashima-sama 男 岡野浩介 6 一桥贤吉 一橋賢吉、Hitotsubashi Kenkichi 男 星野充昭 7 猪 イノ、Ino 男 前田ゆきえ 8 鹿 Shika 男 服部加奈子 ","date":"2005-06-29","objectID":"/anime/kamichu/:2:0","tags":null,"title":"神是中学生","uri":"/anime/kamichu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 神是中学生 2005-06-29 16 bilibili ","date":"2005-06-29","objectID":"/anime/kamichu/:3:0","tags":null,"title":"神是中学生","uri":"/anime/kamichu/"},{"categories":null,"content":"兰顿·萨斯顿（Renton Thurston）是一名看似普通的十四岁少年，他的父亲（阿德洛克·萨斯顿）是一名军队的研究人员，在第一次“爱之夏”之中牺牲自己拯救了地球而被世人称为英雄。然而兰顿对自己和作为机械工程师的祖父相依为命的生活现状却十分不满，流行的运动“滑空”（Lifting）成了他打发时间的唯一爱好。他最大的梦想是有一天能够加入传奇滑空天才霍兰德（Holland）的组织“月光洲”（Gekkostate），成为和他一样出色的滑空选手。可是他的祖父（阿克赛尔．萨斯顿）却希望他成为一名出色的机械工程师，继承家业。\n\n兰顿无聊的生活终于在某一天发生了改变，一架故障的神秘LFO 尼尔瓦修 零式（Nirvash TypeZERO）突然冲进了他祖父的仓库，LFO的驾驶员是一名叫做优莱卡（Eureka）的少女，她请求兰顿的祖父对她的LFO进行修理。兰顿对优莱卡一见钟情，而在与赶来追击的军部武装战斗的过程中，他惊人的表现击退了敌人，更让他得到了加入月光洲的机会。然而在进入月光号之后，他才发现舰船上的真实生活与他在 Ray=Out 杂志上所看到的光辉灿烂的一面完全不同，自己不但很难适应这种艰苦而危险的生活和战斗，更难以得到船上其他成员的认同。但是他想要保护和了解自己所爱慕的优莱卡的心却没有因此而动摇。\n\n交响诗篇的故事就围绕兰顿和优莱卡关系的发展而展开了，随着时间的推移，兰顿的心理和能力都得到了极大的成长，对船上各个成员的不为人知的往事都开始有了逐渐的了解，为了保护自己心爱的人和这个星球，他和敌人展开了一次又一次的战斗；而这颗星球的秘密，也在他眼前逐渐地展开……\n\n","date":"2005-04-17","objectID":"/anime/eureka_seven/","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"简介 兰顿·萨斯顿（Renton Thurston）是一名看似普通的十四岁少年，他的父亲（阿德洛克·萨斯顿）是一名军队的研究人员，在第一次“爱之夏”之中牺牲自己拯救了地球而被世人称为英雄。然而兰顿对自己和作为机械工程师的祖父相依为命的生活现状却十分不满，流行的运动“滑空”（Lifting）成了他打发时间的唯一爱好。他最大的梦想是有一天能够加入传奇滑空天才霍兰德（Holland）的组织“月光洲”（Gekkostate），成为和他一样出色的滑空选手。可是他的祖父（阿克赛尔．萨斯顿）却希望他成为一名出色的机械工程师，继承家业。 兰顿无聊的生活终于在某一天发生了改变，一架故障的神秘LFO 尼尔瓦修 零","date":"2005-04-17","objectID":"/anime/eureka_seven/:1:0","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 兰顿·萨斯顿 顿爷、レントン・サーストン、Renton Thurston 男 三瓶由布子 2 优莱卡 エウレカ・サーストン、艾蕾卡、Eureka 女 名塚佳織 3 安妮莫奈 石井・風花・アネモネ、石井·风花·安妮莫奈、アネモネ、Anemone 女 小清水亜美 4 塔荷 タルホ・ノヴァク、タルホ・ユーキ、Talho Yuuki 女 根谷美智子 5 霍兰德·诺瓦克 ホランド・ノヴァク、Holland Novak 男 藤原啓治 6 杜伊·诺瓦克 デューイ・ノヴァク、Dewey Novak 男 辻谷耕史 7 多米尼克·索莱尔 Dominic Sorel 男 山崎樹範","date":"2005-04-17","objectID":"/anime/eureka_seven/:2:0","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 交响诗篇 2005-04-17 50 bilibili ","date":"2005-04-17","objectID":"/anime/eureka_seven/:3:0","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"MAD ","date":"2005-04-17","objectID":"/anime/eureka_seven/:4:0","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"庆长19年，73岁高龄的德川家康为了第三代将军继承人人选的问题而烦恼。是愚笨的哥哥竹千代，还是天资聪慧的弟弟国千代。在这乱世里第三代将军的继承问题落到了两大忍术宗家——甲贺流和伊贺流的身上。家康决定由两家各派出10名最优秀的忍者，进行一场生死大对决，两派之中幸存下来的一方将得到千年的荣禄，并由其支持的一方继承人继承将军的名号。 \n甲贺首领甲贺弹正和伊贺首领阿幻，在家康的默许下亲手撕毁了两派在前代服部半藏调停下签订的“不战条约”。两派瞬间走向一场死斗。同时弹正的孙子弦之介，和阿幻的孙女胧，不得不放下婚约，为杀死自己的爱人而战……","date":"2005-04-12","objectID":"/anime/basilisk/","tags":null,"title":"甲贺忍法帖","uri":"/anime/basilisk/"},{"categories":null,"content":"简介 庆长19年，73岁高龄的德川家康为了第三代将军继承人人选的问题而烦恼。是愚笨的哥哥竹千代，还是天资聪慧的弟弟国千代。在这乱世里第三代将军的继承问题落到了两大忍术宗家——甲贺流和伊贺流的身上。家康决定由两家各派出10名最优秀的忍者，进行一场生死大对决，两派之中幸存下来的一方将得到千年的荣禄，并由其支持的一方继承人继承将军的名号。 甲贺首领甲贺弹正和伊贺首领阿幻，在家康的默许下亲手撕毁了两派在前代服部半藏调停下签订的“不战条约”。两派瞬间走向一场死斗。同时弹正的孙子弦之介，和阿幻的孙女胧，不得不放下婚约，为杀死自己的爱人而战…… 制作人员： 原作：山田风太郎 导演：木崎文智 脚本：冈田麿里、","date":"2005-04-12","objectID":"/anime/basilisk/:1:0","tags":null,"title":"甲贺忍法帖","uri":"/anime/basilisk/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 甲賀弦之介 甲賀弦之介、Kouga Gennosuke 男 鳥海浩輔 2 朧 朧、Oboro 女 水樹奈々 3 陽炎 陽炎、Kagerou 女 早水リサ 4 室賀豹馬 室賀豹馬、Muroga Hyouma 男 宮林康 5 霞刑部 霞刑部、Kasumi Gyoubu 男 北川勝博 6 地虫十兵衛 地虫十兵衛、Jimushi Juubee 男 伊丸岡篤 7 甲賀弾正 甲賀弾正、Kouga Danjou 男 小林清志 8 筑摩小四郎 筑摩小四郎、Chikuma Koshirou 男 羽多野渉 ","date":"2005-04-12","objectID":"/anime/basilisk/:2:0","tags":null,"title":"甲贺忍法帖","uri":"/anime/basilisk/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 甲贺忍法帖 2005-04-12 24 樱花 ","date":"2005-04-12","objectID":"/anime/basilisk/:3:0","tags":null,"title":"甲贺忍法帖","uri":"/anime/basilisk/"},{"categories":null,"content":"“二子魂川”小镇的居民大多是双胞胎。在二子魂川经营侦探事务所的双叶恋太郎，与两个性格截然不同的双胞胎助手，白钟沙罗和白钟双树，展开令人羡慕的三人恋爱生活。\n\n作品的中文名字容易让人理解为《双恋》的第二季作品，但实际上是另一部重新设定的作品。故事以白钟姊妹作女主角，而在前作中出场的其他双胞胎全部作为配角。作品获得第9回日本文化厅媒体艺术祭审查委员会推荐作品。作品中除第一话外，未有出现片头中女角手持武器的场面。而本作的DVD版与电视播放时的顺序有少许不同。","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"简介 “二子魂川”小镇的居民大多是双胞胎。在二子魂川经营侦探事务所的双叶恋太郎，与两个性格截然不同的双胞胎助手，白钟沙罗和白钟双树，展开令人羡慕的三人恋爱生活。 作品的中文名字容易让人理解为《双恋》的第二季作品，但实际上是另一部重新设定的作品。故事以白钟姊妹作女主角，而在前作中出场的其他双胞胎全部作为配角。作品获得第9回日本文化厅媒体艺术祭审查委员会推荐作品。作品中除第一话外，未有出现片头中女角手持武器的场面。而本作的DVD版与电视播放时的顺序有少许不同。 制作人员： 原作：双叶雏、佐佐木睦美 脚本：近藤光、寺东克己、金月龙之介、佐藤和治 分镜：野中卓也 ","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/:1:0","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 白钟沙罗 しろがね さら、Shirogane Sara 女 水橋かおり 2 白钟双树 しろがね そうじゅ、Shirogane Souju 女 門脇舞以 3 双叶恋太郎 ふたば れんたろう、Futaba Rentarou 男 関智一 4 一条薰子 いちじょう かおるこ、Ichijou Kaoruko 女 堀江由衣 5 一条堇子 いちじょう すみれこ、Ichijo Sumireko 女 小清水亜美 6 樱月绮罗 桜月キラ、さくらづき キラ、Sakurazuki Kira 女 伊月ゆい 7 樱月由罗 さくらづき ユラ、Sakurazuki Yura 女 綱掛裕美 ","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/:2:0","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 双恋 Alternative 2005-04-06 13 bilibili ","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/:3:0","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"MAD ","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/:4:0","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"国中三年级的学生真中淳平，有一天在学校的屋顶上，偶然目击了一名美少女的“草莓内裤”。于是真中便不断的寻找当初见到的那位美少女是谁。那个美少女的名字是东城绫，然而真中却误以为那位美少女是学生偶像西野司，从此便开始了他们不可思议的关系。\n\n真中在和西野交往的同时，也逐渐的被东城给吸引住了。发现了这种情形的西野，决定隐藏自己心中的情感，和真中进入不同的高中就读。\n\n真中升上高中之后，和新同学外村弘志、北大路五月，和国中时期的好朋友东城、小宫山一起成立电影研究社。他们发现了学校过去所留下的电影比赛应募作品，决定制作出比那更好的作品出来，于是由东城写剧本，真中担任导演，以在文化祭的发表和电影比赛的应募作为目标开始制作电影。\n\n这个故事，就是在这样的背景下，东城、西野、北大路，以及一个年纪小的青梅竹马南户，为了争夺真中所产生的一场恋爱大混战。","date":"2005-04-05","objectID":"/anime/strawberry_100/","tags":null,"title":"草莓100%","uri":"/anime/strawberry_100/"},{"categories":null,"content":"简介 国中三年级的学生真中淳平，有一天在学校的屋顶上，偶然目击了一名美少女的“草莓内裤”。于是真中便不断的寻找当初见到的那位美少女是谁。那个美少女的名字是东城绫，然而真中却误以为那位美少女是学生偶像西野司，从此便开始了他们不可思议的关系。 真中在和西野交往的同时，也逐渐的被东城给吸引住了。发现了这种情形的西野，决定隐藏自己心中的情感，和真中进入不同的高中就读。 真中升上高中之后，和新同学外村弘志、北大路五月，和国中时期的好朋友东城、小宫山一起成立电影研究社。他们发现了学校过去所留下的电影比赛应募作品，决定制作出比那更好的作品出来，于是由东城写剧本，真中担任导演，以在文化祭的发表和电影比赛的应募","date":"2005-04-05","objectID":"/anime/strawberry_100/:1:0","tags":null,"title":"草莓100%","uri":"/anime/strawberry_100/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 真中淳平 まなか じゅんぺい、Manaka Junpei 男 斎賀みつき 2 东城绫 東城綾、とうじょう あや、Toujou Aya 女 能登麻美子 3 西野司 Nishino Tsukasa、西野つかさ、にしの つかさ 女 豊口めぐみ 4 北大路五月 北大路さつき、きたおじ　さつき、Kitaooji Satsuki 女 小林沙苗 5 南户唯 みなみと ゆい 女 水樹奈々 6 Ichigo Pantsu Iseijin Ichigo Pantsu Iseijin ","date":"2005-04-05","objectID":"/anime/strawberry_100/:2:0","tags":null,"title":"草莓100%","uri":"/anime/strawberry_100/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 草莓100% 2005-04-05 24 樱花 ","date":"2005-04-05","objectID":"/anime/strawberry_100/:3:0","tags":null,"title":"草莓100%","uri":"/anime/strawberry_100/"},{"categories":null,"content":"《女仆咖啡帕露菲》是一款由戏画发行的恋爱冒险类AVG游戏，于2005年3月25日发售。这款游戏是题材相同的游戏ショコラ的续作。\n\n在05年的批评空间评分总得分中，超过1000人为它打分，初版和Re-order版均超过90分，当年评分超过90的也只有三个，可谓风光无限。这款游戏是题材相同的游戏ショコラ的续作。Re-order版增加了三个小剧本，其中两个故事源自于ショコラ\u0026パルフェ 的联合VFB，其他的人物剧本也略有增加。PS2版增加了两位可攻略女主角，并且修正了部分场景，去掉的H部分，并添加了一套新的语音阵容。","date":"2005-03-25","objectID":"/game/parfait/","tags":null,"title":"女仆咖啡帕露菲","uri":"/game/parfait/"},{"categories":null,"content":"简介 《女仆咖啡帕露菲》是一款由戏画发行的恋爱冒险类AVG游戏，于2005年3月25日发售。这款游戏是题材相同的游戏ショコラ的续作。 在05年的批评空间评分总得分中，超过1000人为它打分，初版和Re-order版均超过90分，当年评分超过90的也只有三个，可谓风光无限。这款游戏是题材相同的游戏ショコラ的续作。Re-order版增加了三个小剧本，其中两个故事源自于ショコラ\u0026パルフェ 的联合VFB，其他的人物剧本也略有增加。PS2版增加了两位可攻略女主角，并且修正了部分场景，去掉的H部分，并添加了一套新的语音阵容。 制作人员： 开发：戏画 剧本：丸户史明 美工：KOMEWORKS 主题歌演出：石","date":"2005-03-25","objectID":"/game/parfait/:1:0","tags":null,"title":"女仆咖啡帕露菲","uri":"/game/parfait/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 风美由飞 花鸟由飞、花鳥由飛 女 雪野梨沙 2 花鸟玲爱 女 永見はるか 3 雪乃明日香 女 天神有海 4 凉波絣 女 亜城めぐ 5 杉泽惠麻 女 茉雪千鶴 6 夏海里伽子 女 友川まり 7 高村仁 たかむら ひとし、仁 仁君 小仁 店长 男 8 川端瑞奈 Kawabata Mizuna、かわばた みずな 女 庄子裕衣 ","date":"2005-03-25","objectID":"/game/parfait/:2:0","tags":null,"title":"女仆咖啡帕露菲","uri":"/game/parfait/"},{"categories":null,"content":"系列 系列名 发行时间 1 女仆咖啡帕露菲 2005-03-25 ","date":"2005-03-25","objectID":"/game/parfait/:3:0","tags":null,"title":"女仆咖啡帕露菲","uri":"/game/parfait/"},{"categories":null,"content":"樱碧草只是一个普通的国中生，没想到，未来的他居然成为了喜爱小女孩的萝莉控！不仅如此，他还发明了一种能让女孩子一直保持12岁模样的怪药，因为这种药，未来的世界发生了重大混乱。无奈之下，未来的世界派出了扑杀天使朵库罗，她的任务是要回到过去扑杀樱碧草以改变未来。可怜的樱碧草就这样不明就里的被狼牙棒打成了碎块，然而，随着一阵呢喃，樱碧草又复活了。明白了事情的原委后，樱碧草提出了一个不用将他杀死也可以改变未来的设想，朵库罗接受了这个设想，于是两人便开始了奇怪的同居生活。 \n越来越多的扑杀天使从未来来到了现在，有看起来可怜兮兮的莎巴多，外表成熟的莎库罗等。而朵库罗现在的任务，就是保护樱碧草的人身安全。虽然樱碧草偶尔的会被打成肉酱，但是和天使在一起的幸福生活还是轰轰烈烈的开始了。","date":"2005-03-25","objectID":"/anime/bokusatsu_tenshi_dokuro-chan/","tags":null,"title":"扑杀天使朵库萝","uri":"/anime/bokusatsu_tenshi_dokuro-chan/"},{"categories":null,"content":"简介 樱碧草只是一个普通的国中生，没想到，未来的他居然成为了喜爱小女孩的萝莉控！不仅如此，他还发明了一种能让女孩子一直保持12岁模样的怪药，因为这种药，未来的世界发生了重大混乱。无奈之下，未来的世界派出了扑杀天使朵库罗，她的任务是要回到过去扑杀樱碧草以改变未来。可怜的樱碧草就这样不明就里的被狼牙棒打成了碎块，然而，随着一阵呢喃，樱碧草又复活了。明白了事情的原委后，樱碧草提出了一个不用将他杀死也可以改变未来的设想，朵库罗接受了这个设想，于是两人便开始了奇怪的同居生活。 越来越多的扑杀天使从未来来到了现在，有看起来可怜兮兮的莎巴多，外表成熟的莎库罗等。而朵库罗现在的任务，就是保护樱碧草的人身安全。","date":"2005-03-25","objectID":"/anime/bokusatsu_tenshi_dokuro-chan/:1:0","tags":null,"title":"扑杀天使朵库萝","uri":"/anime/bokusatsu_tenshi_dokuro-chan/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 三塚井朵库萝 三塚井ドクロ、Mitsukai Dokuro 女 千葉紗子 2 草壁樱 草壁桜、Kusakabe Sakura 男 高木礼子 3 莎芭多 サバトちゃん、Sabato-chan 女 釘宮理恵 4 水上静希 Minakami Shizuki、水上静希 女 川澄綾子 ","date":"2005-03-25","objectID":"/anime/bokusatsu_tenshi_dokuro-chan/:2:0","tags":null,"title":"扑杀天使朵库萝","uri":"/anime/bokusatsu_tenshi_dokuro-chan/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 扑杀天使朵库萝 2005-03-25 8 樱花 2 扑杀天使朵库萝2 2007-08-24 4 其它 ","date":"2005-03-25","objectID":"/anime/bokusatsu_tenshi_dokuro-chan/:3:0","tags":null,"title":"扑杀天使朵库萝","uri":"/anime/bokusatsu_tenshi_dokuro-chan/"},{"categories":null,"content":"　　《搞笑漫画日和》是在《月刊少年JUMP》上连载的人气作品，由于该作的恶搞程度已经达到了某种无人能及的境界，因此受到日本众多动漫迷的追捧。\n　　此作的恶搞对象通常都是些社会知名人物，比如圣德太子、松尾芭蕉等等，看到这些不仅我们想起当年那款恶搞世界人的动画《南方公园》。\n　　《搞笑漫画日和》在众多搞笑漫画中十分出名。对于喜爱恶搞类作品的观众是决不能错过的作品。","date":"2005-02-07","objectID":"/anime/gyagu_manga_biyori/","tags":null,"title":"搞笑漫画日和","uri":"/anime/gyagu_manga_biyori/"},{"categories":null,"content":"简介 《搞笑漫画日和》是在《月刊少年JUMP》上连载的人气作品，由于该作的恶搞程度已经达到了某种无人能及的境界，因此受到日本众多动漫迷的追捧。 此作的恶搞对象通常都是些社会知名人物，比如圣德太子、松尾芭蕉等等，看到这些不仅我们想起当年那款恶搞世界人的动画《南方公园》。 《搞笑漫画日和》在众多搞笑漫画中十分出名。对于喜爱恶搞类作品的观众是决不能错过的作品。 制作人员： 原作：增田耿介 导演：大地丙太郎 演出：音地正行、白井伸明、和田高明、田中将贺、五月女浩一朗、小关雅 ","date":"2005-02-07","objectID":"/anime/gyagu_manga_biyori/:1:0","tags":null,"title":"搞笑漫画日和","uri":"/anime/gyagu_manga_biyori/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 熊吉 クマ吉、熊吉君 男 前田剛 2 兔美 うさみ 女 名塚佳織 3 河合曾良 河合曽良、曾良君 男 前田剛 4 松尾芭蕉 松尾芭蕉、芭蕉桑 男 内藤玲 5 熊孩子 大石的儿子、小朋友 男 ","date":"2005-02-07","objectID":"/anime/gyagu_manga_biyori/:2:0","tags":null,"title":"搞笑漫画日和","uri":"/anime/gyagu_manga_biyori/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 搞笑漫画日和 2005-02-07 12 bilibili 2 搞笑漫画日和2 2006-08-05 12 bilibili 3 搞笑漫画日和3 2008-03-17 12 bilibili 4 搞笑漫画日和＋ 2010-01-04 26 bilibili ","date":"2005-02-07","objectID":"/anime/gyagu_manga_biyori/:3:0","tags":null,"title":"搞笑漫画日和","uri":"/anime/gyagu_manga_biyori/"},{"categories":null,"content":"我的孩子，仔细听好\n接下来我说的，是一件非常重要的事\n已经忘了从何时开始\n由上代讲给下代，代代传下来的故事\n一个关于长久的旅程的故事……\n\n夏天，在靠近海边小小的街道上\n一位青年从公共汽车站下车了\n青年一直在旅行中\n这样的小镇他无心久留\n在赚足了路费后，他会去那些更繁华的地方\n他的旅伴，是母亲留给他的小小的人偶\n他不用手接触，人偶就能动起来\n从母亲那里继承了这种魔法\n靠着表演人偶维生，他的旅途才一直能继续着\n青年给孩子们表演着人偶戏\n然而，简陋的人偶无法吸引孩子们\n没有得到报酬的他\n无力地站在夏天的烈日下\n迷迷糊糊地睡着了……\n就在这条海边的街上，青年和命运中的少女相遇了…… ","date":"2005-01-06","objectID":"/anime/air/","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"简介 我的孩子，仔细听好 接下来我说的，是一件非常重要的事 已经忘了从何时开始 由上代讲给下代，代代传下来的故事 一个关于长久的旅程的故事…… 夏天，在靠近海边小小的街道上 一位青年从公共汽车站下车了 青年一直在旅行中 这样的小镇他无心久留 在赚足了路费后，他会去那些更繁华的地方 他的旅伴，是母亲留给他的小小的人偶 他不用手接触，人偶就能动起来 从母亲那里继承了这种魔法 靠着表演人偶维生，他的旅途才一直能继续着 青年给孩子们表演着人偶戏 然而，简陋的人偶无法吸引孩子们 没有得到报酬的他 无力地站在夏天的烈日下 迷迷糊糊地睡着了…… 就在这条海边的街上，青年和命运中的少女相遇了…… 制作人员： ","date":"2005-01-06","objectID":"/anime/air/:1:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 国崎往人 くにさき ゆきと、Kunisaki Yukito 男 小野大輔 2 神尾观铃 かみお みすず、Kamio Misuzu 女 川上とも子 3 雾岛佳乃 きりしま かの、Kirishima Kano 女 岡本麻見 4 远野美凪 とおの みなぎ、Tohno Minagi 女 柚木涼香 5 神奈备命 かんなびのみこと、Kannabi no Mikoto 女 西村ちなみ 6 神尾晴子 かみお はるこ、Kamio Haruko 女 久川綾 7 雾岛圣 霧島 聖、きりしま ひじり、Kirishima Hijiri 女 冬馬由美 8 小满 みちる、Michiru ","date":"2005-01-06","objectID":"/anime/air/:2:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 AIR 2005-01-06 13 下方 01-13 2 AIR 夏季篇 2005-08-28 2 下方 14-15 3 AIR 剧场版 2005-02-05 1 bilibili ","date":"2005-01-06","objectID":"/anime/air/:3:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"配乐 ","date":"2005-01-06","objectID":"/anime/air/:4:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"MAD ","date":"2005-01-06","objectID":"/anime/air/:5:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"　　继母因无力负担生活，将苏菲和她的两个姐姐都送到了制帽店去当学徒。两个姐姐很快先后就离开了制帽店去追寻各自的梦想，只有苏菲坚持了下来。一天，小镇旁边来了一座移动堡垒，传说堡垒的主人哈尔专吸取年青姑娘的灵魂，所以小镇的姑娘都不敢靠近。\n　　一个恶毒的巫婆嫉妒苏菲的制帽技术，用巫术把她变成了一个80岁的老太婆，而且苏菲还不能对别人说出自己身中的巫术。无奈，苏菲决定独自一人逃离小镇。天黑了，虚弱的苏菲没走多远，来到了移动城堡。心想自己已经是老太婆了，苏菲壮着胆子走进了城堡。不想，遇到了和她遭遇相同的火焰魔。两人约定彼此帮助对方打破各自的咒语……","date":"2004-11-20","objectID":"/anime/howls_moving_castle/","tags":null,"title":"哈尔的移动城堡","uri":"/anime/howls_moving_castle/"},{"categories":null,"content":"简介 继母因无力负担生活，将苏菲和她的两个姐姐都送到了制帽店去当学徒。两个姐姐很快先后就离开了制帽店去追寻各自的梦想，只有苏菲坚持了下来。一天，小镇旁边来了一座移动堡垒，传说堡垒的主人哈尔专吸取年青姑娘的灵魂，所以小镇的姑娘都不敢靠近。 一个恶毒的巫婆嫉妒苏菲的制帽技术，用巫术把她变成了一个80岁的老太婆，而且苏菲还不能对别人说出自己身中的巫术。无奈，苏菲决定独自一人逃离小镇。天黑了，虚弱的苏菲没走多远，来到了移动城堡。心想自己已经是老太婆了，苏菲壮着胆子走进了城堡。不想，遇到了和她遭遇相同的火焰魔。两人约定彼此帮助对方打破各自的咒语…… 制作人员： 原作：黛安娜·温尼·琼斯 导演：宫崎骏 音","date":"2004-11-20","objectID":"/anime/howls_moving_castle/:1:0","tags":null,"title":"哈尔的移动城堡","uri":"/anime/howls_moving_castle/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哈尔 Howl、ハウル 男 木村拓哉 2 ソフィーハッター ソフィーハッター、Sophie Hatter 女 倍賞千恵子 ","date":"2004-11-20","objectID":"/anime/howls_moving_castle/:2:0","tags":null,"title":"哈尔的移动城堡","uri":"/anime/howls_moving_castle/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哈尔的移动城堡 2004-11-20 1 樱花 ","date":"2004-11-20","objectID":"/anime/howls_moving_castle/:3:0","tags":null,"title":"哈尔的移动城堡","uri":"/anime/howls_moving_castle/"},{"categories":null,"content":"故事背景设定在以现实世界为基础所衍生的架空世界，叙述日本在津轻海峡另一侧的北海道遭到占领，形成南北两侧对立的舞台。\n\n1945年，苏联背弃日苏中立条约，于十月攻占北海道。日本恢复主权后，北海道也被改名为“虾夷”，归入苏联的体制之下。1965年赫鲁雪夫在第二十届共产党大会上宣布统合苏联、东欧与西亚所有共产主义国家的统一政体“联邦国”诞生。 1960年代后半，虾夷内部民族主义运动高涨，为了因应这个情势，联邦国于1975年与日本断交，使日本南北分裂情势延续至今。\n\n联邦国在虾夷上建造有着高度直达云端、被称为“联邦国巨塔”的神秘建筑物，该神秘巨塔因此造成美国与联邦国的军事冲突点。","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"简介 故事背景设定在以现实世界为基础所衍生的架空世界，叙述日本在津轻海峡另一侧的北海道遭到占领，形成南北两侧对立的舞台。 1945年，苏联背弃日苏中立条约，于十月攻占北海道。日本恢复主权后，北海道也被改名为“虾夷”，归入苏联的体制之下。1965年赫鲁雪夫在第二十届共产党大会上宣布统合苏联、东欧与西亚所有共产主义国家的统一政体“联邦国”诞生。 1960年代后半，虾夷内部民族主义运动高涨，为了因应这个情势，联邦国于1975年与日本断交，使日本南北分裂情势延续至今。 联邦国在虾夷上建造有着高度直达云端、被称为“联邦国巨塔”的神秘建筑物，该神秘巨塔因此造成美国与联邦国的军事冲突点。 制作人员： 原作：","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/:1:0","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤泽浩纪 藤沢浩紀、ふじさわ　ひろき、Fujisawa Hiroki 男 吉岡秀隆 2 泽渡佐由理 沢渡佐由理、さわたり　さゆり、Sayuri Sawatari 女 南里侑香 3 白川拓也 しらかわ　たくや、Takuya Shirakawa 男 萩原聖人 4 水野理佳 みずの りか 女 中川里江 5 笠原真希 かさはら まき 女 水野理紗 6 冈部 おかべ 男 石塚運昇 7 富泽常夫 とみさわ つねお 男 井上和彦 ","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/:2:0","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 云之彼端，约定的地方 2004-11-20 01:30:21 bilibili ","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/:3:0","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"MAD ","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/:4:0","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"信则灵。小男孩始终坚信圣诞老人的存在，但周围的大人和玩伴都认为这只是他天真的一厢情愿。圣诞前夕，小男孩终于因为他的坚持而得到了回报，睡梦中的他忽然感到屋子颤抖起来了，一列长长的火车停在了他的家门口。当他战战兢兢打开房门时，和蔼的列车长邀请他参加北极的圣诞派对。惴惴不安的克 劳斯踏上了火车，发现很多和他一样的小伙伴们。于是，兴奋不已的小男孩开始了他的北极狂欢之旅。","date":"2004-11-10","objectID":"/anime/the_polar_express/","tags":null,"title":"极地特快","uri":"/anime/the_polar_express/"},{"categories":null,"content":"简介 信则灵。小男孩始终坚信圣诞老人的存在，但周围的大人和玩伴都认为这只是他天真的一厢情愿。圣诞前夕，小男孩终于因为他的坚持而得到了回报，睡梦中的他忽然感到屋子颤抖起来了，一列长长的火车停在了他的家门口。当他战战兢兢打开房门时，和蔼的列车长邀请他参加北极的圣诞派对。惴惴不安的克 劳斯踏上了火车，发现很多和他一样的小伙伴们。于是，兴奋不已的小男孩开始了他的北极狂欢之旅。 制作人员： 友情協力：华纳兄弟娱乐公司 ","date":"2004-11-10","objectID":"/anime/the_polar_express/:1:0","tags":null,"title":"极地特快","uri":"/anime/the_polar_express/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 极地特快 2004-11-10 1 樱花 ","date":"2004-11-10","objectID":"/anime/the_polar_express/:2:0","tags":null,"title":"极地特快","uri":"/anime/the_polar_express/"},{"categories":null,"content":"第1部共制作了12集动画，并于发售的DVD中附赠了3集不平衡抽签的动画，自2004年10月10日播放至2004年12月26日。\n\n“现代视觉文化研究会”，简称“现视研”，是一个以研究动漫等综合性现代视觉文化为成立宗旨，但行吃喝玩乐之实的社团。主角笹原完士在成为大学新鲜人后，跟同为一年级新生的重度御宅族高坂真琴一起加入了现视研。但在都是“御宅族”的社团活动中，高坂的青梅竹马春日部咲对其展开攻势；即使与其交往之后发现了高坂的“御宅族”真面目，仍不放弃将他拉回正道，因而成为社团的常客。漫画《现视研》，即是活生生的描写大学内动漫社团里的日常生活与人际关系的作品。\n坊间对于“御宅族”在外表、行为模式、与异性间的互动情形等面向上往往具有刻板印象；然而本作对此族群的描写呈现多样化，被部分动漫爱好者认为较为接近真实状况。","date":"2004-10-10","objectID":"/anime/genshiken/","tags":null,"title":"现视研","uri":"/anime/genshiken/"},{"categories":null,"content":"简介 第1部共制作了12集动画，并于发售的DVD中附赠了3集不平衡抽签的动画，自2004年10月10日播放至2004年12月26日。 “现代视觉文化研究会”，简称“现视研”，是一个以研究动漫等综合性现代视觉文化为成立宗旨，但行吃喝玩乐之实的社团。主角笹原完士在成为大学新鲜人后，跟同为一年级新生的重度御宅族高坂真琴一起加入了现视研。但在都是“御宅族”的社团活动中，高坂的青梅竹马春日部咲对其展开攻势；即使与其交往之后发现了高坂的“御宅族”真面目，仍不放弃将他拉回正道，因而成为社团的常客。漫画《现视研》，即是活生生的描写大学内动漫社团里的日常生活与人际关系的作品。 坊间对于“御宅族”在外表、行为模式","date":"2004-10-10","objectID":"/anime/genshiken/:1:0","tags":null,"title":"现视研","uri":"/anime/genshiken/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 春日部咲 女 ゆきのさつき 2 斑目晴信 Madarame Harunobu、斑目晴信 男 檜山修之 3 笹原完士 Sasahara Kanji、笹原完士 男 大山鎬則 4 大野加奈子 Kanako Ohno、Oono Kanako、大野加奈子 女 川澄綾子 5 笹原惠子 今日子、笹原 恵子、ささはら けいこ、Sasahara Keiko、笹原妹、笹妹（ささいも） 女 清水香里 6 田中总市郎 田中総市郎、Tanaka Souichirou 男 関智一 7 高坂真琴 Kousaka Makoto、高坂真琴 男 斎賀みつき 8 久我山光紀 久我山光紀、くがやま","date":"2004-10-10","objectID":"/anime/genshiken/:2:0","tags":null,"title":"现视研","uri":"/anime/genshiken/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 现视研 2004-10-10 12 bilibili 2 现视研2 2007-10-09 12 樱花 ","date":"2004-10-10","objectID":"/anime/genshiken/:3:0","tags":null,"title":"现视研","uri":"/anime/genshiken/"},{"categories":null,"content":"樱田纯，一名不愿上学而长期足不出户的中学二年生，热衷于上网购物，喜欢在购买物品后的退货限期内退回物品，买了许多奇奇怪怪的诅咒物品。有一天收到一张传单，上面只写一个“上发条 还是不上发条”的选项，在好奇心驱使下选择了“上发条”，之后房间就出现了一个神秘的皮箱，里面装着一个非常美丽而且质感近似真人的人偶，使用皮箱内的发条转动背部的开关后，人偶像有生命般的活动起来，向纯说：“我的名字是真红，蔷薇少女的第五人偶。”","date":"2004-10-07","objectID":"/anime/rozen_maiden/","tags":null,"title":"蔷薇少女","uri":"/anime/rozen_maiden/"},{"categories":null,"content":"简介 樱田纯，一名不愿上学而长期足不出户的中学二年生，热衷于上网购物，喜欢在购买物品后的退货限期内退回物品，买了许多奇奇怪怪的诅咒物品。有一天收到一张传单，上面只写一个“上发条 还是不上发条”的选项，在好奇心驱使下选择了“上发条”，之后房间就出现了一个神秘的皮箱，里面装着一个非常美丽而且质感近似真人的人偶，使用皮箱内的发条转动背部的开关后，人偶像有生命般的活动起来，向纯说：“我的名字是真红，蔷薇少女的第五人偶。” 制作人员： 原作：PEACH-PIT 导演：松尾衡 脚本：冈田麿里、花田十辉、玉井豪 分镜：樱美胜志、岛津裕行、紫绀、大桥誉志光 ","date":"2004-10-07","objectID":"/anime/rozen_maiden/:1:0","tags":null,"title":"蔷薇少女","uri":"/anime/rozen_maiden/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 樱田纯 桜田ジュン、Sakurada Jun 男 真田アサミ 2 真红 真紅、しんく、Shinku 沢城みゆき 3 雏莓 雛苺、ひないちご、Hinaichigo 野川さくら 4 水银灯 水銀燈、すいぎんとう、Suigintou 田中理恵 5 翠星石 翠星石、すいせいせき、Suiseiseki 桑谷夏子 6 苍星石 蒼星石、そうせいせき、Souseiseki 女 森永理科 7 樱田纪 桜田のり、Sakurada Nori 女 力丸乃りこ 8 柏叶巴 柏葉 巴、Kashiwaba Tomoe 女 倉田雅世 ","date":"2004-10-07","objectID":"/anime/rozen_maiden/:2:0","tags":null,"title":"蔷薇少女","uri":"/anime/rozen_maiden/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 蔷薇少女 2004-10-07 12 bilibili 2 蔷薇少女 梦之终结 2005-10-20 12 bilibili 3 新蔷薇少女 2013-07-04 13 bilibili ","date":"2004-10-07","objectID":"/anime/rozen_maiden/:3:0","tags":null,"title":"蔷薇少女","uri":"/anime/rozen_maiden/"},{"categories":null,"content":"MAD ","date":"2004-10-07","objectID":"/anime/rozen_maiden/:4:0","tags":null,"title":"蔷薇少女","uri":"/anime/rozen_maiden/"},{"categories":null,"content":"主角高町奈叶是个平凡的小学三年级女生，与好友在如同日常作息的前往补习途中，发现了从异世界米德其路达（又译米德芝尔达）来的雪貂尤诺·斯克莱亚。他利用心灵感应告诉奈叶，他来到这个世界的理由是为了回收他所挖掘到的太古遗产（平行次元中的高度文明的遗产）“宝石种子”。奈叶为了保护可能因为宝石种子暴走被破坏的城镇，决定代替尤诺出面回收。不料，这却只是一连串事件的开端。他们遇见，与他们一样目的，因为回收宝石种子而出现的谜样金发少女魔导师到底是……\n\n","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"简介 主角高町奈叶是个平凡的小学三年级女生，与好友在如同日常作息的前往补习途中，发现了从异世界米德其路达（又译米德芝尔达）来的雪貂尤诺·斯克莱亚。他利用心灵感应告诉奈叶，他来到这个世界的理由是为了回收他所挖掘到的太古遗产（平行次元中的高度文明的遗产）“宝石种子”。奈叶为了保护可能因为宝石种子暴走被破坏的城镇，决定代替尤诺出面回收。不料，这却只是一连串事件的开端。他们遇见，与他们一样目的，因为回收宝石种子而出现的谜样金发少女魔导师到底是…… 制作人员： 原作：ivory、都筑真纪 导演：新房昭之 分镜：田所修、阿部雅司、小寺胜之 演出：齐藤良成、秋田谷典昭 ","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/:1:0","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 高町奈叶 管理局の白い悪魔、白色恶魔、高町奈葉、Nanoha Takamachi、高町なのは、たかまち なのは、Takamachi Nanoha、暴君 女 田村ゆかり 2 菲特·泰斯特罗莎 菲特·泰斯特罗莎·哈拉温、菲特·泰斯塔罗莎·哈拉温、フェイト・テスタロッサ・ハラオウン、Fate T. Harlaown、菲特·T·哈拉温、Fate Testarossa Harlaown、フェイト・T・テスタロッサ、Feito Tesutarossa Haraoun、菲特、宠妃 女 水樹奈々 3 尤诺·斯克莱亚 ユーノ・スクライア、Yuuno Scrya 男 水橋かおり","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/:2:0","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔法少女奈叶 2004-10-01 13 bilibili 2 魔法少女奈叶A’s 2005-10-01 13 bilibili 3 魔法少女奈叶StrikerS 2007-04-01 26 bilibili 4 魔法少女奈叶ViVid 2015-04-03 12 bilibili 5 ViVid Strike! 2016-10-01 12 bilibili 6 魔法少女奈叶 The MOVIE 1st 2010-01-23 1 bilibili 7 魔法少女奈叶 The MOVIE 2nd A’s 2012-07-14 1 bilibili ","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/:3:0","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"MAD ","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/:4:0","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"　　一天，二十多岁的新人漫画家西在电车上遇到了青梅竹马的弥，她正在被黑社会追杀。西送弥回家，途中得知了弥已经有了婚约。\n　　在她们家的烤肉店，弥的未婚夫来到店里，虽然嫉妒，但西自认比不过他。这时，黑社会也来到店里，打晕了弥的男友并要强奸弥，而西此时蜷缩一旁不敢动弹。黑社会发现了一旁的西，用枪爆了他的屁眼。\n　　死去的西来到天堂，遇到了一个非常kuso的上帝，他燃起了生的希望，并且最终成功地死而复生了……","date":"2004-08-07","objectID":"/anime/mind_game/","tags":null,"title":"心灵游戏","uri":"/anime/mind_game/"},{"categories":null,"content":"简介 一天，二十多岁的新人漫画家西在电车上遇到了青梅竹马的弥，她正在被黑社会追杀。西送弥回家，途中得知了弥已经有了婚约。 在她们家的烤肉店，弥的未婚夫来到店里，虽然嫉妒，但西自认比不过他。这时，黑社会也来到店里，打晕了弥的男友并要强奸弥，而西此时蜷缩一旁不敢动弹。黑社会发现了一旁的西，用枪爆了他的屁眼。 死去的西来到天堂，遇到了一个非常kuso的上帝，他燃起了生的希望，并且最终成功地死而复生了…… 制作人员： 导演：汤浅政明 音乐：山本精一 人物设定：末吉裕一郎 原画：大平晋也、浦谷千惠、金井次郎、柿田英树 ","date":"2004-08-07","objectID":"/anime/mind_game/:1:0","tags":null,"title":"心灵游戏","uri":"/anime/mind_game/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 心灵游戏 2004-08-07 1 樱花 ","date":"2004-08-07","objectID":"/anime/mind_game/:2:0","tags":null,"title":"心灵游戏","uri":"/anime/mind_game/"},{"categories":null,"content":"露西生来就与常人有异，她头上长着两个犄角，生有四只隐形的手，体内蕴藏着巨大的力量，人们管她这样的孩子叫作异种人。从小就被人抛弃排挤的露西一直非常孤独，直到她遇到浩太才渡过了非常愉快的几天。然而随着体内载体的呼唤，她渐渐还是显露出杀人魔的本性，并被研究所拘捕监禁。\n八年后，露西从研究所里逃出来，却由于脑部重创失忆，成为“白痴少女”。此时的浩太也由于儿时的重大打击选择性失忆，两人再次相遇，浩太把露西当作陌生人收留下来。穿插着两人断断续续的回忆，故事渐渐走向了两个极端。","date":"2004-07-25","objectID":"/anime/elfen_lied/","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"简介 露西生来就与常人有异，她头上长着两个犄角，生有四只隐形的手，体内蕴藏着巨大的力量，人们管她这样的孩子叫作异种人。从小就被人抛弃排挤的露西一直非常孤独，直到她遇到浩太才渡过了非常愉快的几天。然而随着体内载体的呼唤，她渐渐还是显露出杀人魔的本性，并被研究所拘捕监禁。 八年后，露西从研究所里逃出来，却由于脑部重创失忆，成为“白痴少女”。此时的浩太也由于儿时的重大打击选择性失忆，两人再次相遇，浩太把露西当作陌生人收留下来。穿插着两人断断续续的回忆，故事渐渐走向了两个极端。 制作人员： 原作：冈本伦 导演：神户守 脚本：吉冈孝夫 分镜：渡边纯央、阿部达也、岩永彰、佐土原武之 ","date":"2004-07-25","objectID":"/anime/elfen_lied/:1:0","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 耕太 耕太、Kouta 男 鈴木千尋 2 露西 にゅう、妮悠、Lucy 女 小林沙苗 3 由香 Yuka 女 能登麻美子 4 真由 マユ、mayu 女 萩原えみこ 5 娜娜 ナナ、Nana 女 松岡由貴 6 白河 白川、しらかわ、Shirakawa 女 生天目仁美 7 真理子 マリコ、Mariko 女 川上とも子 8 香苗 カナエ、Kanae 女 山本麻里安 ","date":"2004-07-25","objectID":"/anime/elfen_lied/:2:0","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 妖精的旋律 2004-07-25 14 樱花 ","date":"2004-07-25","objectID":"/anime/elfen_lied/:3:0","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"MAD ","date":"2004-07-25","objectID":"/anime/elfen_lied/:4:0","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"游戏故事发生在利贝尔王国，玩家扮演隶属于民间机构——游击士协会的新人游击士艾丝蒂尔·布莱特和约修亚·布莱特。\n两位游击士新人为了磨练自我而踏上旅程，却在不经意间卷入震撼全王国乃至全大陆的重大事件之中。","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"简介 游戏故事发生在利贝尔王国，玩家扮演隶属于民间机构——游击士协会的新人游击士艾丝蒂尔·布莱特和约修亚·布莱特。 两位游击士新人为了磨练自我而踏上旅程，却在不经意间卷入震撼全王国乃至全大陆的重大事件之中。 制作人员： 开发：日本Falcom 发行：北京娱乐通科技发展有限公司 剧本：竹入久喜、近藤季洋 音乐：石桥渡、神藤由東大、Falcom Sound Team jdk、村山貴英 ","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/:1:0","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾丝蒂尔·布莱特 Estelle Bright 女 神田朱未 2 约修亚·布莱特 漆黑之牙、约修亚·阿斯特雷、Joshua Bright、ヨシュア・アストレイ、小约 男 斎賀みつき 3 亚妮拉丝·艾尔菲德 Anelace Elfead、萌主 女 大河内雅子 4 雪拉扎德·哈维 雪拉扎德·莱泽·亚诺尔、Scherazard Harvey 女 塩山由佳 5 奥利维特·莱泽·亚诺尔 奥利维尔·朗海姆、Olivier Lenheim、オリビエ・レンハイム、Olivert Reise Arnor 男 子安武人 6 提妲·拉赛尔 Tita Russell 女 今野宏美 ","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/:2:0","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"系列 系列名 发行时间 1 英雄传说6：空之轨迹FC 2004-06-24 2 英雄传说6：空之轨迹SC 2006-03-09 3 英雄传说6：空之轨迹 the 3rd 2007-06-28 4 英雄传说：零之轨迹 2010-09-30 5 英雄传说：碧之轨迹 2011-09-29 6 英雄传说 闪之轨迹 2013-09-26 7 英雄传说 闪之轨迹2 2014-09-25 8 英雄传说 闪之轨迹3 2017-09-28 9 英雄传说 闪之轨迹4 -THE END OF SAGA- 2018-09-27 10 英雄传说 创之轨迹 2020-08-27 11 英雄传说 黎之轨迹 2021-09-","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/:3:0","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"动画 系列名 首播时间 话数/时长 观看地址 1 英雄传说 空之轨迹 2011-11-25 2 bilibili ","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/:4:0","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"MAD ","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/:5:0","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"　　天箕博士与他的研究队在一次进行着原子碰撞的实验时，突然从实验装置射出两道光，并被攻击中了来参观天箕博士的女儿Kurau(12岁)，女孩的身体被分解，但很快地在光芒中重新回复人形。\n　　但是，眼前的女孩回过头来对天箕博士说的第一句话却是：“我是……rynax。”\n　　——10年后，kurau作为“代理人”过着独居的生活。\n　　而22岁的那天，随着rynax的光从kurau体内溢出，被kurau称为“对”的女孩出现了。\n　　rynax给女孩起名为クリスマス（Christmas），两人相互陪伴下开始了看似平静的生活。\n　　但有组织对RYNAX的奇异能力发生兴趣，虎视眈眈想得到她。\n　　所谓的“RYNAX”，拥有“分解”与“重组”的能力，会将遇到的物质转化为原子，一旦溢出，对整个世界将造成不可估量的影响，政府决定将这种物质抹杀的时候，kurau和クリスマス将成为首要目标。\n　　然而，故事才刚刚开始。","date":"2004-06-24","objectID":"/anime/kurau_phantom_memory/","tags":null,"title":"库拉乌 幻之记忆","uri":"/anime/kurau_phantom_memory/"},{"categories":null,"content":"简介 天箕博士与他的研究队在一次进行着原子碰撞的实验时，突然从实验装置射出两道光，并被攻击中了来参观天箕博士的女儿Kurau(12岁)，女孩的身体被分解，但很快地在光芒中重新回复人形。 但是，眼前的女孩回过头来对天箕博士说的第一句话却是：“我是……rynax。” ——10年后，kurau作为“代理人”过着独居的生活。 而22岁的那天，随着rynax的光从kurau体内溢出，被kurau称为“对”的女孩出现了。 rynax给女孩起名为クリスマス（Christmas），两人相互陪伴下开始了看似平静的生活。 但有组织对RYNAX的奇异能力发生兴趣，虎视眈眈想得到她。 所谓的“RYNAX”，拥有“分解","date":"2004-06-24","objectID":"/anime/kurau_phantom_memory/:1:0","tags":null,"title":"库拉乌 幻之记忆","uri":"/anime/kurau_phantom_memory/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 聖誕 クリスマス、Christmas 女 小林美佐 2 天箕库拉乌 天箕クラウ、あまみ クラウ、Amami Kurau 女 川澄綾子 3 天箕創 天箕創 男 小形満 4 達古 ダグ 男 志村知幸 5 綾香 アヤカ 女 甲斐田裕子 ","date":"2004-06-24","objectID":"/anime/kurau_phantom_memory/:2:0","tags":null,"title":"库拉乌 幻之记忆","uri":"/anime/kurau_phantom_memory/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 库拉乌 幻之记忆 2004-06-24 24 bilibili ","date":"2004-06-24","objectID":"/anime/kurau_phantom_memory/:3:0","tags":null,"title":"库拉乌 幻之记忆","uri":"/anime/kurau_phantom_memory/"},{"categories":null,"content":"在湘南最棒的便利屋“海豚屋”中发生的充满活力，搞笑，感动和泪水的大地丙太郎的“自主制作作品”《海豚便利屋》是由日本动画界首屈一指的监督——大地丙太郎的漫画为原作，在大地监督的主导下找来了相关的工作人员，完全不倚赖制作公司的支持，只靠着工作人员的个别努力而完成之大地丙太郎的“自主制作作品”。同时，这也是日本史上第一部的手语动画，并向一般人所认为很难以动画完整呈现出来的手语描绘进行挑战。片子开头就有“小碧”（听障人士）用大段的手语给一个企业老板计算经营成本的场面，这个手语并不是摆个花架子而已，是真正标准的手语。当初也就是因为这个地方制作难度很大，所以没有厂商愿意出资投拍。后来大地丙太郎经朋友提醒，凭借人脉拉来了各个制作单位的人员后亲自上阵投入制作，这也是“大地丙太郎自主作品”名称的由来。2004年，这部作品从294部参赛作品中脱颖而出，荣获日本“第8届文化厅媒体艺术祭”动画部门优秀奖。","date":"2004-06-10","objectID":"/anime/grrl_power/","tags":null,"title":"海豚便利店","uri":"/anime/grrl_power/"},{"categories":null,"content":"简介 在湘南最棒的便利屋“海豚屋”中发生的充满活力，搞笑，感动和泪水的大地丙太郎的“自主制作作品”《海豚便利屋》是由日本动画界首屈一指的监督——大地丙太郎的漫画为原作，在大地监督的主导下找来了相关的工作人员，完全不倚赖制作公司的支持，只靠着工作人员的个别努力而完成之大地丙太郎的“自主制作作品”。同时，这也是日本史上第一部的手语动画，并向一般人所认为很难以动画完整呈现出来的手语描绘进行挑战。片子开头就有“小碧”（听障人士）用大段的手语给一个企业老板计算经营成本的场面，这个手语并不是摆个花架子而已，是真正标准的手语。当初也就是因为这个地方制作难度很大，所以没有厂商愿意出资投拍。后来大地丙太郎经朋友","date":"2004-06-10","objectID":"/anime/grrl_power/:1:0","tags":null,"title":"海豚便利店","uri":"/anime/grrl_power/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 空 Sora、空、そら、sora 女 齋藤彩夏 2 碧 Ao、碧、あお、ao 女 名塚佳織 3 海 Wumi、海、うみ、wumi 女 東野佑美 ","date":"2004-06-10","objectID":"/anime/grrl_power/:2:0","tags":null,"title":"海豚便利店","uri":"/anime/grrl_power/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海豚便利店 2004-06-10 1 bilibili ","date":"2004-06-10","objectID":"/anime/grrl_power/:3:0","tags":null,"title":"海豚便利店","uri":"/anime/grrl_power/"},{"categories":null,"content":"著名的設計師鷺月子在一天夜裏突然遭到神秘少年襲擊。在此之後接連出現新的受害者，城中一度陷入恐慌。事件的真相究竟是……","date":"2004-02-02","objectID":"/anime/paranoia_agent/","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"简介 著名的設計師鷺月子在一天夜裏突然遭到神秘少年襲擊。在此之後接連出現新的受害者，城中一度陷入恐慌。事件的真相究竟是…… 制作人员： 原作：今敏 脚本：水上清资、吉野智美 分镜：岛崎奈奈子、三原三千夫、林重行、滨崎博嗣 ","date":"2004-02-02","objectID":"/anime/paranoia_agent/:1:0","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鹭月子 鷺 月子、さぎ つきこ 女 能登麻美子 2 麻洛美 桃井はるこ 3 猪狩庆一 いかり けいいち 男 飯塚昭三 4 马庭光弘 馬庭 光弘、まにわ みつひろ 男 関俊彦 5 川津明雄 Kawazu Akio 男 内海賢二 6 鯛良优一 Taira Yuuichi 男 山口眞弓 7 蛭川雅美 ひるかわ まさみ、Hirukawa Masami 男 中嶋聡彦 8 牛山尚吾 Ushiyama Shougo 男 津村まこと ","date":"2004-02-02","objectID":"/anime/paranoia_agent/:2:0","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 妄想代理人 2004-02-02 13 樱花 ","date":"2004-02-02","objectID":"/anime/paranoia_agent/:3:0","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"MAD ","date":"2004-02-02","objectID":"/anime/paranoia_agent/:4:0","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"《Fate/stay night》是TYPE-MOON开发并最早于2004年1月30日在PC平台上发售的文字冒险游戏，也是TYPE-MOON公司商业化后初次亮相的作品，是Fate的系列作品之一。","date":"2004-01-30","objectID":"/game/fate_stay_night/","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"简介 《Fate/stay night》是TYPE-MOON开发并最早于2004年1月30日在PC平台上发售的文字冒险游戏，也是TYPE-MOON公司商业化后初次亮相的作品，是Fate的系列作品之一。 制作人员： 开发：型月 发行：Notes. 剧本：奈须蘑菇 音乐：芳贺敬太、永田大祐、石川敏 主题歌作曲：NUMBER 201 主题歌演出：M.H. 原画：武内崇 ","date":"2004-01-30","objectID":"/game/fate_stay_night/:1:0","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 卫宫士郎 衛宮 士郎、えみや しろう、Emiya Shirou 男 野田順子 2 阿尔托莉雅·潘德拉贡 Saber、呆毛王、吾王、青王、骑士王、棉被王、亚瑟王、蓝Saber、元祖Saber、Altria Pendragon、セイバー 女 川澄綾子 3 远坂凛 Rin Tohsaka、遠坂 凛、とおさか りん、Tohsaka Rin 女 植田佳奈 4 间桐樱 まとうさくら、Matou Sakura 女 下屋則子 5 伊莉雅斯菲尔·冯·爱因兹贝伦 伊莉雅丝菲尔·冯·爱因兹贝伦、伊莉亚丝菲尔·冯·艾因兹贝伦、依莉雅苏菲尔·冯·爱因兹贝伦、伊莉雅、Illyasvie","date":"2004-01-30","objectID":"/game/fate_stay_night/:2:0","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"系列 系列名 发行时间 1 Fate/stay night 2004-01-30 ","date":"2004-01-30","objectID":"/game/fate_stay_night/:3:0","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"配乐 ","date":"2004-01-30","objectID":"/game/fate_stay_night/:4:0","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"在未来的某一天，一对男女Retro（山口胜平 配音）和Pandy（本田贵子 配音）在一片荒野中醒来，却发现自己不但赤身裸体而且丧失了记忆。二人来到了东京闹市中肆意抢劫衣服和食物，经过一番大战后，两人被捕，并被投放到月球上的监狱“Dead Leaves”。  \n\n经过一段短暂的禁闭生活后，他们发现这座监狱是一所克隆工厂。两个看守员随意杀害克隆人，于是Retro和Pandy萌生了越狱的念头。Retro和Pandy轻而易举地解开了身上的锁，更不可思议的是，他们居然对这座监狱了如指掌。他们的真实身份究竟是什么？","date":"2004-01-16","objectID":"/anime/dead_leaves/","tags":null,"title":"落叶","uri":"/anime/dead_leaves/"},{"categories":null,"content":"简介 在未来的某一天，一对男女Retro（山口胜平 配音）和Pandy（本田贵子 配音）在一片荒野中醒来，却发现自己不但赤身裸体而且丧失了记忆。二人来到了东京闹市中肆意抢劫衣服和食物，经过一番大战后，两人被捕，并被投放到月球上的监狱“Dead Leaves”。 经过一段短暂的禁闭生活后，他们发现这座监狱是一所克隆工厂。两个看守员随意杀害克隆人，于是Retro和Pandy萌生了越狱的念头。Retro和Pandy轻而易举地解开了身上的锁，更不可思议的是，他们居然对这座监狱了如指掌。他们的真实身份究竟是什么？ 制作人员： 原作：今井トゥーンズ、Production I.G 导演：今石洋之 音乐：池赖","date":"2004-01-16","objectID":"/anime/dead_leaves/:1:0","tags":null,"title":"落叶","uri":"/anime/dead_leaves/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 落叶 2004-01-16 1 bilibili ","date":"2004-01-16","objectID":"/anime/dead_leaves/:2:0","tags":null,"title":"落叶","uri":"/anime/dead_leaves/"},{"categories":null,"content":"《DotA》（Defense of the Ancients），可以译作守护古树、守护遗迹、远古遗迹守卫， 是由暴雪公司出品即时战略游戏《魔兽争霸3》的一款多人即时对战、自定义地图，可支持10个人同时连线游戏，是暴雪公司官方认可的魔兽争霸的RPG地图。\n\n最早的DOTA地图则在混乱之治时代就出现了，一位叫做Eul（Euls）的玩家制作了第一张DOTA地图《RoC DOTA》，其中两队都只有总共5个英雄，非常简单   。Eul（Euls）退出之后有位玩家Steve Guinsoo整合了很多个英雄制作了DotA Allstars。在2005年，6.01版发布不久，IceFrog同Neichus对地图进行了多次修正和更新。之后Neichus退出，IceFrog成为主要的地图程序员，负责包括游戏的执行和平衡的测试在内的任何工作。随着6系列版本不断被发布，bug的修正，新的英雄和新增加的法术不断被引入《DotA》。\n\n最终游戏分为两个阵营，玩家需要操作英雄，通过摧毁对方遗迹建筑来获取最终胜利。这种多人在线竞技模式后来被称为“Dota类游戏“，对之后的许多游戏产生了深远的影响。","date":"2004-01-01","objectID":"/game/dota/","tags":null,"title":"DotA","uri":"/game/dota/"},{"categories":null,"content":"简介 《DotA》（Defense of the Ancients），可以译作守护古树、守护遗迹、远古遗迹守卫， 是由暴雪公司出品即时战略游戏《魔兽争霸3》的一款多人即时对战、自定义地图，可支持10个人同时连线游戏，是暴雪公司官方认可的魔兽争霸的RPG地图。 最早的DOTA地图则在混乱之治时代就出现了，一位叫做Eul（Euls）的玩家制作了第一张DOTA地图《RoC DOTA》，其中两队都只有总共5个英雄，非常简单 。Eul（Euls）退出之后有位玩家Steve Guinsoo整合了很多个英雄制作了DotA Allstars。在2005年，6.01版发布不久，IceFrog同Neichus对地","date":"2004-01-01","objectID":"/game/dota/:1:0","tags":null,"title":"DotA","uri":"/game/dota/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 石鳞剑士 穿山甲、滚滚 Phil LaMarr 2 小小 山岭巨人、山岭 3 撼地者 撼地神牛、小牛、老牛、神牛、ES 4 斯温 流浪剑客、流浪、真男人、SV 5 昆卡 船长、海军上将 6 兽王 卡洛克、BM 7 龙骑士 Davion、达维安、DK 8 发条技师 发条、天宇技师、瑞托崔普、RattleTrap ","date":"2004-01-01","objectID":"/game/dota/:2:0","tags":null,"title":"DotA","uri":"/game/dota/"},{"categories":null,"content":"系列 系列名 发行时间 1 DotA 2004-01-01 2 刀塔2 2013-07-09 ","date":"2004-01-01","objectID":"/game/dota/:3:0","tags":null,"title":"DotA","uri":"/game/dota/"},{"categories":null,"content":"MAD ","date":"2004-01-01","objectID":"/game/dota/:4:0","tags":null,"title":"DotA","uri":"/game/dota/"},{"categories":null,"content":"她叫罗塞特修女，玛克达拉修道院的除魔师。\n公元1928年，美国纽约。依旧是夜晚被黑暗妆点的时候。第一次世界大战结束后不久，美国经济开始了前所未有的发展。但是过于急速的发展吸引了一些不速之客。人眼看不到的怪异，在黑暗中蠢蠢欲动。专司除魔的玛克达拉修道院的修女罗塞特，和她的助手少年克罗诺正是被称为“除魔师”的专家。\n本领高强的两人阻止依附在各种物品上侵入合众国的恶魔，展开了无数冒险。只不过偶尔在解决恶魔的同时也令周围遭受更大的损失。罗塞特一直在寻找小时候因恶魔引发的时间而失散的弟弟尤休亚。\n为此进入修道院，接受除魔师的训练。不过她合克罗诺之间尤一个重大的秘密：克罗诺的真实身份是和罗塞特定下“怀表契约”的恶魔。情况紧急时，罗赛特解开封印，让克罗诺发挥他强大的力量。但是，代价就是罗赛特必须消耗自己的“灵魂”，也就意味着罗赛特的寿命会缩短。人类和恶魔之间建立了绝对的信赖关系。不过，罗赛特的生命能够维持到和弟弟尤休亚相见么？","date":"2003-11-24","objectID":"/anime/chrono_crusade/","tags":null,"title":"圣枪修女","uri":"/anime/chrono_crusade/"},{"categories":null,"content":"简介 她叫罗塞特修女，玛克达拉修道院的除魔师。 公元1928年，美国纽约。依旧是夜晚被黑暗妆点的时候。第一次世界大战结束后不久，美国经济开始了前所未有的发展。但是过于急速的发展吸引了一些不速之客。人眼看不到的怪异，在黑暗中蠢蠢欲动。专司除魔的玛克达拉修道院的修女罗塞特，和她的助手少年克罗诺正是被称为“除魔师”的专家。 本领高强的两人阻止依附在各种物品上侵入合众国的恶魔，展开了无数冒险。只不过偶尔在解决恶魔的同时也令周围遭受更大的损失。罗塞特一直在寻找小时候因恶魔引发的时间而失散的弟弟尤休亚。 为此进入修道院，接受除魔师的训练。不过她合克罗诺之间尤一个重大的秘密：克罗诺的真实身份是和罗塞特定下“","date":"2003-11-24","objectID":"/anime/chrono_crusade/:1:0","tags":null,"title":"圣枪修女","uri":"/anime/chrono_crusade/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 罗塞特·克里斯特福 罗赛朵·克里斯多福、Rosette Christopher、ロゼット・クリストファ、罗塞特 女 川上とも子 2 克罗诺 克罗诺、克劳诺、库挪、库罗诺、Chrno 男 石田彰 3 艾斯马利亚·汉得林格 Azmaria Hendric 女 千葉紗子 4 莎德拉·哈贝海特 サテラ・ハーベンハイト、Satella Harvenheit 女 根谷美智子 5 尤安·雷明顿 Ewan Remington 男 速水奨 6 约书亚·克里斯特法 Joshua Christopher 男 皆川純子 7 ケイト・ヴァレンタイン Kate Valentine 女 ","date":"2003-11-24","objectID":"/anime/chrono_crusade/:2:0","tags":null,"title":"圣枪修女","uri":"/anime/chrono_crusade/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 圣枪修女 2003-11-24 24 樱花 ","date":"2003-11-24","objectID":"/anime/chrono_crusade/:3:0","tags":null,"title":"圣枪修女","uri":"/anime/chrono_crusade/"},{"categories":null,"content":"MAD ","date":"2003-11-24","objectID":"/anime/chrono_crusade/:4:0","tags":null,"title":"圣枪修女","uri":"/anime/chrono_crusade/"},{"categories":null,"content":"中年流浪汉金、虽身为男人但内心温柔又充满母性的阿花和离家出走少女美雪，他们三人过着无家可归的生活，一起居住在东京原宿的一个角落。\n圣诞夜，三人在垃圾堆中发现一个哭泣的弃婴，在孩子的襁褓里，发现了一个酒吧的名片和照片，还有奶粉。阿花非常想要小孩子，便收留了她并给孩子起了个名字，叫清子。于是，三人展开了清子的寻亲之旅。途中，他们与各式各样的过去相遇。他们能找到清子的父母吗……？","date":"2003-11-08","objectID":"/anime/tokyo_godfathers/","tags":null,"title":"东京教父","uri":"/anime/tokyo_godfathers/"},{"categories":null,"content":"简介 中年流浪汉金、虽身为男人但内心温柔又充满母性的阿花和离家出走少女美雪，他们三人过着无家可归的生活，一起居住在东京原宿的一个角落。 圣诞夜，三人在垃圾堆中发现一个哭泣的弃婴，在孩子的襁褓里，发现了一个酒吧的名片和照片，还有奶粉。阿花非常想要小孩子，便收留了她并给孩子起了个名字，叫清子。于是，三人展开了清子的寻亲之旅。途中，他们与各式各样的过去相遇。他们能找到清子的父母吗……？ 制作人员： 原作：今敏 脚本：信本敬子 演出：古屋胜悟 音乐：ムーンライダーズ、铃木庆一 人物设定：小西贤一 ","date":"2003-11-08","objectID":"/anime/tokyo_godfathers/:1:0","tags":null,"title":"东京教父","uri":"/anime/tokyo_godfathers/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 金 男 江守徹 2 哈娜 阿花 男 梅垣義明 3 美由纪 女 岡本綾 4 清子 女 こおろぎさとみ 5 出租车司机 男 山寺宏一 ","date":"2003-11-08","objectID":"/anime/tokyo_godfathers/:2:0","tags":null,"title":"东京教父","uri":"/anime/tokyo_godfathers/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 东京教父 2003-11-08 1 bilibili ","date":"2003-11-08","objectID":"/anime/tokyo_godfathers/:3:0","tags":null,"title":"东京教父","uri":"/anime/tokyo_godfathers/"},{"categories":null,"content":"　　爱德华德和他的弟弟阿尔芬斯十分思念在他们还小的时候亡故的母亲，实行了炼金术中最大的禁忌——可以将死者复活的人体炼成。 可是炼成失败，爱德华德失去了左腿，阿尔芬斯则失去了全身。爱德华德好不容易才以牺牲自己的右臂为代价将弟弟的灵魂炼成，并定着在一副铠甲上，可是其代价未免太大了。爱德华德和阿尔芬斯一起，为了找回所失去的一切，开始踏上了寻找拥有极大力量的“贤者之石”的旅程。 \n　　 \n　　右臂和左腿用钢制义肢“机械铠”来替代的他，被人们称为“钢之炼金术师”…","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"简介 爱德华德和他的弟弟阿尔芬斯十分思念在他们还小的时候亡故的母亲，实行了炼金术中最大的禁忌——可以将死者复活的人体炼成。 可是炼成失败，爱德华德失去了左腿，阿尔芬斯则失去了全身。爱德华德好不容易才以牺牲自己的右臂为代价将弟弟的灵魂炼成，并定着在一副铠甲上，可是其代价未免太大了。爱德华德和阿尔芬斯一起，为了找回所失去的一切，开始踏上了寻找拥有极大力量的“贤者之石”的旅程。 右臂和左腿用钢制义肢“机械铠”来替代的他，被人们称为“钢之炼金术师”… 制作人员： 原作：荒川弘 导演：水岛精二 脚本：高桥奈津子、吉永亚矢、会川升、大和屋晓、石川学、高山克彦、井上敏树 ","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/:1:0","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 爱德华·艾尔利克 Edward Elric、爱德 男 朴璐美 2 阿尔芬斯·艾尔利克 Alphonse Elric 男 釘宮理恵 3 温莉·洛克贝尔 Winry Rockbell 女 豊口めぐみ 4 キャスリン・エル・アームストロング Catherine Elle Armstrong 女 釘宮理恵 5 冯·霍恩海姆 ホーエンハイム・エルリック、班·賀恩漢、Van Hohenheim 男 江原正士 6 特蕾莎·艾尔利克 朵莉夏·爱力克、トリシャ・エルリック、Trisha Elric 女 鷹森淑乃 7 皮纳可·洛克贝尔 比拿可·洛克贝尔、ピナコ・ロックベル、Pi","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/:2:0","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 钢之炼金术师 2003-10-04 51 樱花 2 钢之炼金术师 香巴拉的征服者 2005-07-23 1 樱花 3 钢之炼金术师 FULLMETAL ALCHEMIST 2009-04-05 64 樱花 4 钢之炼金术师 叹息之丘的圣星 2011-07-02 1 樱花 ","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/:3:0","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"MAD ","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/:4:0","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"鸣海孝之（谷山纪章 配音）、平慎二（青木城 配音）和速濑水月（石桥朋子 配音）是学生时代的好友，毕业在即，三人亦即将奔向不同的未来。某日，鸣海孝之结识了名叫凉宫遥（栗林美奈实 配音）的少女，在速濑水月的牵线搭桥下，鸣海孝之和凉宫遥走到了一起。  \n\n其实，水月一直暗暗的喜欢着孝之，在生日当天，她找到了正准备和凉宫遥约会的孝之，希望他能够送自己一枚戒指作为礼物。然而，当孝之告别水月来到约会地点时，等待着他的却是凉宫遥因车祸而陷入昏迷的噩耗。三年之后，凉宫遥从昏迷中苏醒了，可是她的记忆依旧停留在三年前出事的那一天，殊不知此时的孝之和水月早已经走到了一起。","date":"2003-10-04","objectID":"/anime/rumbling_hearts/","tags":null,"title":"你所期望的永远","uri":"/anime/rumbling_hearts/"},{"categories":null,"content":"简介 鸣海孝之（谷山纪章 配音）、平慎二（青木城 配音）和速濑水月（石桥朋子 配音）是学生时代的好友，毕业在即，三人亦即将奔向不同的未来。某日，鸣海孝之结识了名叫凉宫遥（栗林美奈实 配音）的少女，在速濑水月的牵线搭桥下，鸣海孝之和凉宫遥走到了一起。 其实，水月一直暗暗的喜欢着孝之，在生日当天，她找到了正准备和凉宫遥约会的孝之，希望他能够送自己一枚戒指作为礼物。然而，当孝之告别水月来到约会地点时，等待着他的却是凉宫遥因车祸而陷入昏迷的噩耗。三年之后，凉宫遥从昏迷中苏醒了，可是她的记忆依旧停留在三年前出事的那一天，殊不知此时的孝之和水月早已经走到了一起。 制作人员： 原作：âge 导演：渡边哲哉 ","date":"2003-10-04","objectID":"/anime/rumbling_hearts/:1:0","tags":null,"title":"你所期望的永远","uri":"/anime/rumbling_hearts/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 凉宫遥 すずみや はるか、Suzumiya Haruka 女 栗林みな実 2 鸣海孝之 鳴海孝之、なるみ たかゆき、Narumi Takayuki 男 谷山紀章 3 速濑水月 はやせ みつき、Hayase Mitsuki 女 たかはし智秋 4 凉宫茜 Suzumiya Akane 女 水橋かおり 5 大空寺亚由 大空寺あゆ、Daikuuji Ayu 女 浅井清己 6 凉宫宗一郎 涼宮 宗一郎、Suzumiya Souichirou 男 川津泰彦 7 石田亚月沙 石田 あづさ、Ishida Azusa 女 伊藤美紀 8 美纪 美紀、Miki 女 宇和川恵美 ","date":"2003-10-04","objectID":"/anime/rumbling_hearts/:2:0","tags":null,"title":"你所期望的永远","uri":"/anime/rumbling_hearts/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 你所期望的永远 2003-10-04 14 樱花 ","date":"2003-10-04","objectID":"/anime/rumbling_hearts/:3:0","tags":null,"title":"你所期望的永远","uri":"/anime/rumbling_hearts/"},{"categories":null,"content":"安达卢西亚位于西班牙南部的地中海西岸，面临太平洋。现在，这里正在举行世界最大自行车比赛之一的环西班牙·贝尔塔大奖赛。选手帕帕·贝奈海利所属的PaoPao啤酒队是一只弱小的队伍。但是，在是山路的安达卢西亚赛段，强队的选手们都会保存体力，所以这就成了为PaoPao啤酒队争取荣誉的好机会。帕帕今天从教练那接到的指令是冲出集团、消耗敌人体力……同时，今天也是帕帕的哥哥与他们的青梅竹马结婚的日子……为了协助队友得到冠军，帕帕冲出了集团，但是没有人去追赶他，没人认为他能保持速度骑到终点…… \n突然出现的黑猫导致了队友的受伤，PaoPao啤酒队只有将希望寄托在帕帕身上了…… \n“VENGA PePe　要到远方去。”  ","date":"2003-07-26","objectID":"/anime/nasu/","tags":null,"title":"茄子·安达卢西亚之夏","uri":"/anime/nasu/"},{"categories":null,"content":"简介 安达卢西亚位于西班牙南部的地中海西岸，面临太平洋。现在，这里正在举行世界最大自行车比赛之一的环西班牙·贝尔塔大奖赛。选手帕帕·贝奈海利所属的PaoPao啤酒队是一只弱小的队伍。但是，在是山路的安达卢西亚赛段，强队的选手们都会保存体力，所以这就成了为PaoPao啤酒队争取荣誉的好机会。帕帕今天从教练那接到的指令是冲出集团、消耗敌人体力……同时，今天也是帕帕的哥哥与他们的青梅竹马结婚的日子……为了协助队友得到冠军，帕帕冲出了集团，但是没有人去追赶他，没人认为他能保持速度骑到终点…… 突然出现的黑猫导致了队友的受伤，PaoPao啤酒队只有将希望寄托在帕帕身上了…… “VENGA PePe　要到","date":"2003-07-26","objectID":"/anime/nasu/:1:0","tags":null,"title":"茄子·安达卢西亚之夏","uri":"/anime/nasu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 茄子·安达卢西亚之夏 2003-07-26 1 bilibili 2 茄子 带着旅行箱的候鸟 2007-10-24 1 bilibili ","date":"2003-07-26","objectID":"/anime/nasu/:2:0","tags":null,"title":"茄子·安达卢西亚之夏","uri":"/anime/nasu/"},{"categories":null,"content":"故事的主角是一个叫帕希菲卡的女孩。她是莱因布安(莱邦)王国被遗弃的公主。第5111个圣格林德预言说她是“毁灭世界的猛毒”，时间是当她满16周岁时。因为这样，当帕希菲卡还是婴儿时就被人从山崖上丢弃。直到她15岁时，无人知道她依然还活着。帕希菲卡被一位巫师所救并且被卡斯尔家族收养。卡斯尔(卡苏鲁)家族的长男和长女夏浓及拉克维尔更成为了她的保护者。夏浓是一位剑客，拉克维尔(拉寇儿)是位魔法师。他们的能力都很强。在整个故事中，他们一直跟着帕希菲卡，保护她免于遭到那些害怕预言结果的人杀害。另一方面，帕希菲卡却没有什么能力可以保护自己。随着故事的发展，预言的真相渐渐地浮上了水面。","date":"2003-04-08","objectID":"/anime/scrapped_princess/","tags":null,"title":"废弃公主","uri":"/anime/scrapped_princess/"},{"categories":null,"content":"简介 故事的主角是一个叫帕希菲卡的女孩。她是莱因布安(莱邦)王国被遗弃的公主。第5111个圣格林德预言说她是“毁灭世界的猛毒”，时间是当她满16周岁时。因为这样，当帕希菲卡还是婴儿时就被人从山崖上丢弃。直到她15岁时，无人知道她依然还活着。帕希菲卡被一位巫师所救并且被卡斯尔家族收养。卡斯尔(卡苏鲁)家族的长男和长女夏浓及拉克维尔更成为了她的保护者。夏浓是一位剑客，拉克维尔(拉寇儿)是位魔法师。他们的能力都很强。在整个故事中，他们一直跟着帕希菲卡，保护她免于遭到那些害怕预言结果的人杀害。另一方面，帕希菲卡却没有什么能力可以保护自己。随着故事的发展，预言的真相渐渐地浮上了水面。 制作人员： 原作：","date":"2003-04-08","objectID":"/anime/scrapped_princess/:1:0","tags":null,"title":"废弃公主","uri":"/anime/scrapped_princess/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 帕希菲卡·卡苏尔 帕稀菲卡·卡苏尔、Pacifica Casull 女 折笠富美子 2 夏浓·卡苏尔 シャノン・カスール、Shannon Casull 男 三木眞一郎 3 拉克维尔·卡苏尔 Raquel Casull 女 大原さやか 4 ディアーナ 女 佐藤しのぶ 5 クリストファ・アーマライト Christopher Armalite、クリス 男 水島大宙 6 レオポルド・スコルプス Leopold Scorpse、Leopold Scorpus、レオ 男 近藤隆 7 ゼフィリス Zeffiris、Zefiris 女 水橋かおり 8 グロリア Gloria","date":"2003-04-08","objectID":"/anime/scrapped_princess/:2:0","tags":null,"title":"废弃公主","uri":"/anime/scrapped_princess/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 废弃公主 2003-04-08 24 bilibili ","date":"2003-04-08","objectID":"/anime/scrapped_princess/:3:0","tags":null,"title":"废弃公主","uri":"/anime/scrapped_princess/"},{"categories":null,"content":"旅行者奇诺（Kino）骑着她那会说话的摩托车汉密斯（Hermes）到各个国家旅行，在每个国家奇诺都只停留三天，在她体会了该国家人民的文化、风俗之后，她便离开并前往另一个国家……\n\n　　--世界は美しくなんかない　そして それ故に 美しい--\n　　--The World Is Not Beautiful,Therefore It Is--\n　　--这个世界并不美丽，然而，又因此而美丽--","date":"2003-04-08","objectID":"/anime/kino_no_tabi/","tags":null,"title":"奇诺之旅","uri":"/anime/kino_no_tabi/"},{"categories":null,"content":"简介 旅行者奇诺（Kino）骑着她那会说话的摩托车汉密斯（Hermes）到各个国家旅行，在每个国家奇诺都只停留三天，在她体会了该国家人民的文化、风俗之后，她便离开并前往另一个国家…… –世界は美しくなんかない　そして それ故に 美しい– –The World Is Not Beautiful,Therefore It Is– –这个世界并不美丽，然而，又因此而美丽– 制作人员： 原作：时雨泽惠一 导演：中村隆太郎 脚本：村井贞之 分镜：佐藤卓哉、和田平作、小林孝嗣 演出：江岛泰男、楠本巨树 ","date":"2003-04-08","objectID":"/anime/kino_no_tabi/:1:0","tags":null,"title":"奇诺之旅","uri":"/anime/kino_no_tabi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 奇诺 Kino 女 前田愛 2 汉密斯 艾鲁梅斯、Hermes、Erumesu 相ヶ瀬龍史 3 西兹 Shizu 男 入江崇史 4 陆 Riku 大塚芳忠 5 师父 Shishou 女 渡辺明乃 6 旅人奇诺 Tabibito Kino 男 井上和彦 7 樱 小樱、Sakura 女 悠木碧 8 伙伴 弟子、Aibō (Aibou) 男 千葉進歩 ","date":"2003-04-08","objectID":"/anime/kino_no_tabi/:2:0","tags":null,"title":"奇诺之旅","uri":"/anime/kino_no_tabi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 奇诺之旅 2003-04-08 13 bilibili ","date":"2003-04-08","objectID":"/anime/kino_no_tabi/:3:0","tags":null,"title":"奇诺之旅","uri":"/anime/kino_no_tabi/"},{"categories":null,"content":"从很小的时候起，苗木野空就对卡莱多剧团的表演充满了憧憬之情。如今，已经长大的她终于有能力开始追逐自己的梦想了，信心满满的空踏上了前往美国的旅途，她发誓要成为剧团的一份子，给更多的孩子带去欢乐。可惜事与愿违，刚刚踏上美国的土地，空就迷失了方向，在经历了一系列波折之后，迷糊的她居然错过了剧团的选拔考试。\n就算无法成为剧团的一份子，也要亲眼看一看他们的表演。怀着这样的信念，空来到了剧团的后台，却在无意之中弄伤了马上就要上场表演的巨星蕾拉。无奈之下，经理只得让空代替蕾拉上台演出，没想到，初来乍到的空居然赢得了广大观众的喜爱。就这样，空被破格录取了，她在卡莱多剧团的表演生涯正式拉开了帷幕。面对强劲的竞争对手，空能够脱颖而出吗？","date":"2003-04-03","objectID":"/anime/kaleido_star/","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"简介 从很小的时候起，苗木野空就对卡莱多剧团的表演充满了憧憬之情。如今，已经长大的她终于有能力开始追逐自己的梦想了，信心满满的空踏上了前往美国的旅途，她发誓要成为剧团的一份子，给更多的孩子带去欢乐。可惜事与愿违，刚刚踏上美国的土地，空就迷失了方向，在经历了一系列波折之后，迷糊的她居然错过了剧团的选拔考试。 就算无法成为剧团的一份子，也要亲眼看一看他们的表演。怀着这样的信念，空来到了剧团的后台，却在无意之中弄伤了马上就要上场表演的巨星蕾拉。无奈之下，经理只得让空代替蕾拉上台演出，没想到，初来乍到的空居然赢得了广大观众的喜爱。就这样，空被破格录取了，她在卡莱多剧团的表演生涯正式拉开了帷幕。面对强劲","date":"2003-04-03","objectID":"/anime/kaleido_star/:1:0","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 苗木野空 苗木野そら、Naegino Sora、Наэгино Сора 女 広橋涼 2 蕾拉·汉密尔顿 レイラ・ハミルトン、Layla Hamilton 女 大原さやか 3 罗赛塔·帕赛尔 Rosetta Passel、ロゼッタ・パッセル 女 水橋かおり 4 王梅 メイ・ウォン 女 中原麻衣 5 莱昂·渥兹伍尔 Leon Oswald、レオン・オズワルド 男 櫻井孝宏 6 米娅·盖伦 Mia Guillem 女 西村ちなみ 7 安娜·哈特 アンナ・ハート 女 渡辺明乃 8 玛莉恩 マリオン 女 折笠富美子 ","date":"2003-04-03","objectID":"/anime/kaleido_star/:2:0","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 百变之星 2003-04-03 51 bilibili 2 百变之星 崭新之翼 EXTRA STAGE 不笑的公主 2004-10-22 1 bilibili 3 百变之星 不死鸟传说 ～蕾拉・汉密尔顿物语～ 2006-01-27 1 bilibili 4 百变之星 妙啊！妙！ 2006-09-27 1 bilibili ","date":"2003-04-03","objectID":"/anime/kaleido_star/:3:0","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"MAD ","date":"2003-04-03","objectID":"/anime/kaleido_star/:4:0","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"       從高空墜落的少女。不久後她從溢滿水的繭中醒過來。在古老建築物的一個房間裡迎接她的是背上擁有無法飛的灰色翅膀，被稱為「灰羽」的少女們。由繭裡時做的天空落下的夢，將少女命名為落下(ラッカ)。 故事敘述灰羽（Haibane）與人類這兩種生物共同生活在栗城中，主角落下（Rakka）新來乍到，學習如何以灰羽的身分生活，直到幫助另一灰羽礫（Reki）離開，從中引出名字、記憶、夢、罪、遺忘與傷害的探討。","date":"2002-10-09","objectID":"/anime/haibane_renmei/","tags":null,"title":"灰羽联盟","uri":"/anime/haibane_renmei/"},{"categories":null,"content":"简介 從高空墜落的少女。不久後她從溢滿水的繭中醒過來。在古老建築物的一個房間裡迎接她的是背上擁有無法飛的灰色翅膀，被稱為「灰羽」的少女們。由繭裡時做的天空落下的夢，將少女命名為落下(ラッカ)。 故事敘述灰羽（Haibane）與人類這兩種生物共同生活在栗城中，主角落下（Rakka）新來乍到，學習如何以灰羽的身分生活，直到幫助另一灰羽礫（Reki）離開，從中引出名字、記憶、夢、罪、遺忘與傷害的探討。 制作人员： 原作：安倍吉俊 导演：所智一 分镜：山本裕介、大森贵弘、伊魔崎斋、岛津裕行、吉川浩司、高田淳 ","date":"2002-10-09","objectID":"/anime/haibane_renmei/:1:0","tags":null,"title":"灰羽联盟","uri":"/anime/haibane_renmei/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 落下 落下、Rakka 女 広橋涼 2 砾 野田順子 3 河鱼 女 宮島依里 4 空 クウ 女 矢島晶子 5 光 ヒカリ 女 折笠富美子 6 眠 ネム 女 村井かずさ ","date":"2002-10-09","objectID":"/anime/haibane_renmei/:2:0","tags":null,"title":"灰羽联盟","uri":"/anime/haibane_renmei/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 灰羽联盟 2002-10-09 13 bilibili ","date":"2002-10-09","objectID":"/anime/haibane_renmei/:3:0","tags":null,"title":"灰羽联盟","uri":"/anime/haibane_renmei/"},{"categories":null,"content":"    在火影忍者正式故事展开的12年前，一只被称为九尾 妖狐的妖怪袭击木叶忍者村，传说它一挥动尾巴就会山崩海啸。当时的第四代火影“木叶黄色闪光”波风皆人牺牲自己的性命，把九尾封印在刚出生的孩子 漩涡鸣人身上。\n“第四代火影”被村里的人认为是英雄，但他更希望村里的人同样地将鸣人当作英雄看待。但村民认为鸣人就是妖狐的化身，而不是作为封印妖狐的幕后功臣，因此为鸣人自小就被人歧视。\n重新复出的“第三代火影”已经禁止村民和后代提到这次的九尾突袭事件，但是仍不能阻止人们排挤鸣人。就连他们不知情的后代，在父母的感染下，亦疏远鸣人。因此，鸣人从小倍受孤立。为了引起其他人注意经常恶作剧。但这种状况在他成功的通过“忍者学校”的毕业考试后逐渐改变，并以成为“火影”为目标努力。\n火影忍者故事既包含严肃和娱乐的情节，整个故事以鸣人及其朋友的成长为核心，并描绘他们在人生经历当中的相互感情。鸣人与两位好友 宇智波佐助和春野樱，和他们的导师“复制忍者”旗木卡卡西组成第七组执行各种任务。 ","date":"2002-10-03","objectID":"/anime/naruto/","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"简介 在火影忍者正式故事展开的12年前，一只被称为九尾 妖狐的妖怪袭击木叶忍者村，传说它一挥动尾巴就会山崩海啸。当时的第四代火影“木叶黄色闪光”波风皆人牺牲自己的性命，把九尾封印在刚出生的孩子 漩涡鸣人身上。 “第四代火影”被村里的人认为是英雄，但他更希望村里的人同样地将鸣人当作英雄看待。但村民认为鸣人就是妖狐的化身，而不是作为封印妖狐的幕后功臣，因此为鸣人自小就被人歧视。 重新复出的“第三代火影”已经禁止村民和后代提到这次的九尾突袭事件，但是仍不能阻止人们排挤鸣人。就连他们不知情的后代，在父母的感染下，亦疏远鸣人。因此，鸣人从小倍受孤立。为了引起其他人注意经常恶作剧。但这种状况在他成功的通过","date":"2002-10-03","objectID":"/anime/naruto/:1:0","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 漩涡鸣人 鳴門、渦卷鳴門、漩涡鸣门、Naruto Uzumaki、うずまきナルト、Uzumaki Naruto、鳴門 男 竹内順子 2 宇智波佐助 內輪佐助、内轮佐助、うちはサスケ、Uchiha Sasuke、佐助 男 杉山紀彰 3 春野樱 春野サクラ、Haruno Sakura、樱爷 女 中村千絵 4 旗木卡卡西 畑鹿驚、畑鹿惊、はたけカカシ、Hatake Kakashi 男 井上和彦 5 手鞠 女 朴璐美 6 自来也 Jiraiya 男 大塚芳忠 7 日向雏田 日向ヒナタ、Hyuuga Hinata 女 水樹奈々 8 我爱罗 我愛羅、Gaara 男 石田","date":"2002-10-03","objectID":"/anime/naruto/:2:0","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 火影忍者 2002-10-03 220 优酷 2 火影忍者疾风传 2007-02-15 500 樱花 3 火影忍者 剧场版 博人传 2015-08-07 1 樱花 ","date":"2002-10-03","objectID":"/anime/naruto/:3:0","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"MAD ","date":"2002-10-03","objectID":"/anime/naruto/:4:0","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"主人翁花田一路於某年發生一次車禍意外，在昏迷中夢見一位名叫小雪的美少女，後來一路被這個鬼魂嚇醒，也開始有看得見鬼魂的超能力，許多鬼魂接近一路，希望他能幫他們完成在人世時尚未完成的願望。\n","date":"2002-10-01","objectID":"/anime/hanada_shounen-shi/","tags":null,"title":"花田少年史","uri":"/anime/hanada_shounen-shi/"},{"categories":null,"content":"简介 主人翁花田一路於某年發生一次車禍意外，在昏迷中夢見一位名叫小雪的美少女，後來一路被這個鬼魂嚇醒，也開始有看得見鬼魂的超能力，許多鬼魂接近一路，希望他能幫他們完成在人世時尚未完成的願望。 制作人员： 原作：一色真人 导演：小岛正幸 脚本：高屋敷英夫、金春智子、米村正二、望月武、藤田伸三 分镜：兼森义则、望月智充 ","date":"2002-10-01","objectID":"/anime/hanada_shounen-shi/:1:0","tags":null,"title":"花田少年史","uri":"/anime/hanada_shounen-shi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 花田少年史 2002-10-01 25 bilibili ","date":"2002-10-01","objectID":"/anime/hanada_shounen-shi/:2:0","tags":null,"title":"花田少年史","uri":"/anime/hanada_shounen-shi/"},{"categories":null,"content":"infinity系列第二部。本游戏分为两个主人公视点——仓成武和失忆少年，与小町月海，茜崎空，优，松永沙罗，八神可可几位少女编制一团迷离的故事，各女主角的剧情安排也因主人公的视点而有所变动未来海洋主题乐园内 演绎生离死别的悲喜剧","date":"2002-08-29","objectID":"/game/ever17/","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"简介 infinity系列第二部。本游戏分为两个主人公视点——仓成武和失忆少年，与小町月海，茜崎空，优， 松永沙罗， 八神可可几位少女编制一团迷离的故事，各女主角的剧情安排也因主人公的视点而有所变动未来海洋主题乐园 内演绎生离死别的悲喜剧。 制作人员： 开发：KID 发行：光谱资讯、赛科、サイバーフロント、北京娱乐通科技发展有限公司 剧本：打越钢太郎、中泽工、梅田伸明 ","date":"2002-08-29","objectID":"/game/ever17/:1:0","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 仓成武 くらなり たけし、Kuranari Takeshi、武 仓成先生 男 保志総一朗 2 少年 Shonen 男 ？？？ 3 小町月海 小町鸠（误译）、小町鸫、小町 つぐみ、こまち つぐみ、Komachi Tsugumi 女 浅川悠 4 茜崎空 あかねがさき そら、Akanegasaki Sora、空 女 笠原弘子 5 田中优美清春香菜 优春、たなか ゆうびせいはるかな、Tanaka Yubiseiharukana 女 下屋則子 6 松永沙罗 まつなが さら、Matsunaga Sara、沙罗 女 植田佳奈 7 八神可可 八神可可、やがみ ここ、Yaga","date":"2002-08-29","objectID":"/game/ever17/:2:0","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"系列 系列名 发行时间 1 时空轮回 2002-08-29 ","date":"2002-08-29","objectID":"/game/ever17/:3:0","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"配乐 ","date":"2002-08-29","objectID":"/game/ever17/:4:0","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"在未来，南极的上空出现了被称为“通路”的蘑菇云般的时空通路，外星生物“迦姆”利用它发动了对地球的攻击。经过33年惨烈的战斗，人类终于将“迦姆”封印于道路的彼端——菲雅利星球。然后，随着迦姆的消失，人们开始渐渐淡忘了这件事，但战斗仍然在菲雅利星球继续着……","date":"2002-08-25","objectID":"/anime/yukikaze/","tags":null,"title":"战斗妖精雪风","uri":"/anime/yukikaze/"},{"categories":null,"content":"简介 在未来，南极的上空出现了被称为“通路”的蘑菇云般的时空通路，外星生物“迦姆”利用它发动了对地球的攻击。经过33年惨烈的战斗，人类终于将“迦姆”封印于道路的彼端——菲雅利星球。然后，随着迦姆的消失，人们开始渐渐淡忘了这件事，但战斗仍然在菲雅利星球继续着…… 制作人员： 原作：神林长平 导演：大仓雅彦 脚本：山下育人、きお誠児、多田由美、山口宏、十川诚志 分镜：城正克 ","date":"2002-08-25","objectID":"/anime/yukikaze/:1:0","tags":null,"title":"战斗妖精雪风","uri":"/anime/yukikaze/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 深井零 深井零、Fukai Rei 男 堺雅人 2 ジェイムズ・ブッカー James Bukhar 男 中田譲治 3 リン・ジャクスン Lynn Jackson 女 池田昌子 4 リディア・クーリィ Lydia Cooley 女 麻上洋子 5 エディス・フォス Edith Foss 女 山田美穂 6 アンセル・ロンバート Ansel Rombert 男 土師孝也 7 トム・ジョン Tom John、トマホーク 男 矢尾一樹 8 FFR-31MR/D スーパーシルフ Super Sylph、雪風 ","date":"2002-08-25","objectID":"/anime/yukikaze/:2:0","tags":null,"title":"战斗妖精雪风","uri":"/anime/yukikaze/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 战斗妖精雪风 2002-08-25 5 bilibili ","date":"2002-08-25","objectID":"/anime/yukikaze/:3:0","tags":null,"title":"战斗妖精雪风","uri":"/anime/yukikaze/"},{"categories":null,"content":"内容描述一位平凡善良的高中女生小春，在一次上学途中救了一只猫，意外开启了一趟奇幻冒险经历。小春救的是猫王国的王子，“猫之国度”的猫国王为了报答她，不断送她礼物，并邀请小春到猫王国作客，希望她嫁给猫王子。困惑的小春向“猫事务所”的猫男爵巴隆（Baron）求助，遇到大肥猫胖胖（MUTA）、大乌鸦多多（TOTO）。突然，小春被一大群猫强行带往猫国，猫男爵和胖胖、多多紧追进入猫国。待在舒服的猫国中，小春渐渐地长出胡须和猫耳朵，小春快变成真正的猫了。在猫王的阻挠之下，小春、猫男爵和胖胖拼命的奔往迷宫出口，想在时间之内重回人类世界。","date":"2002-07-20","objectID":"/anime/the_cat_returns/","tags":null,"title":"猫的报恩","uri":"/anime/the_cat_returns/"},{"categories":null,"content":"简介 内容描述一位平凡善良的高中女生小春，在一次上学途中救了一只猫，意外开启了一趟奇幻冒险经历。小春救的是猫王国的王子，“猫之国度”的猫国王为了报答她，不断送她礼物，并邀请小春到猫王国作客，希望她嫁给猫王子。困惑的小春向“猫事务所”的猫男爵巴隆（Baron）求助，遇到大肥猫胖胖（MUTA）、大乌鸦多多（TOTO）。突然，小春被一大群猫强行带往猫国，猫男爵和胖胖、多多紧追进入猫国。待在舒服的猫国中，小春渐渐地长出胡须和猫耳朵，小春快变成真正的猫了。在猫王的阻挠之下，小春、猫男爵和胖胖拼命的奔往迷宫出口，想在时间之内重回人类世界。 制作人员： 原作：柊葵 导演：森田宏幸 脚本：吉田玲子 音乐：野见","date":"2002-07-20","objectID":"/anime/the_cat_returns/:1:0","tags":null,"title":"猫的报恩","uri":"/anime/the_cat_returns/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 巴隆 フンベルト・フォン・ジッキンゲン、Baron Humbert von Gikkingen 男 袴田吉彦 2 月牙 RUUN 公 山田孝之 3 ムタ 胖胖、ルナルド・ムーン ","date":"2002-07-20","objectID":"/anime/the_cat_returns/:2:0","tags":null,"title":"猫的报恩","uri":"/anime/the_cat_returns/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 猫的报恩 2002-07-20 1 樱花 ","date":"2002-07-20","objectID":"/anime/the_cat_returns/:3:0","tags":null,"title":"猫的报恩","uri":"/anime/the_cat_returns/"},{"categories":null,"content":"2039年时，人类火星调查队在火星的塔尔西斯高地上发现了异文明的遗迹，但却被突然出现的异生命体攻击而全军覆没。于是为了对抗被命名为塔尔西斯（Tarsian）人的异生命体的威胁，联合国组成了联合国宇宙军。\n\n2046年时，当时就读于中学三年级的长峰美加子参加了联合国宇宙军的机器人驾驶选拔被录取了。翌年为了追查塔尔西斯人而被编入里希提亚舰队，跟着舰队旗舰里希提亚号从地球出发，留下她所喜欢的人，寺尾升。当调查舰队追寻塔尔西斯人的痕迹，离地球越来越远时，两人的距离变成以光年来计算，两人的移动电话电子邮件要抵达所花费的时间也越来越长。\n\n终于，美加子抵达了距离地球8.7光年的半人马座α星系中的一颗行星。在那里，美加子传送了费时8.7年才能到达地球的手机短信给寺尾升。在随后进行的与塔而西斯人的战斗中，联合国军几乎全军覆没，但美加子幸存。","date":"2002-02-02","objectID":"/anime/hoshi_no_koe/","tags":null,"title":"星之声","uri":"/anime/hoshi_no_koe/"},{"categories":null,"content":"简介 2039年时，人类火星调查队在火星的塔尔西斯高地上发现了异文明的遗迹，但却被突然出现的异生命体攻击而全军覆没。于是为了对抗被命名为塔尔西斯（Tarsian）人的异生命体的威胁，联合国组成了联合国宇宙军。 2046年时，当时就读于中学三年级的长峰美加子参加了联合国宇宙军的机器人驾驶选拔被录取了。翌年为了追查塔尔西斯人而被编入里希提亚舰队，跟着舰队旗舰里希提亚号从地球出发，留下她所喜欢的人，寺尾升。当调查舰队追寻塔尔西斯人的痕迹，离地球越来越远时，两人的距离变成以光年来计算，两人的移动电话电子邮件要抵达所花费的时间也越来越长。 终于，美加子抵达了距离地球8.7光年的半人马座α星系中的一颗行星","date":"2002-02-02","objectID":"/anime/hoshi_no_koe/:1:0","tags":null,"title":"星之声","uri":"/anime/hoshi_no_koe/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 寺尾升 Terao Noboru、寺尾 昇、てらお のぼる、Terao Noboru 男 新海誠 2 长峰美加子 長峰美加子、Nagamine Mikako 女 篠原美香 ","date":"2002-02-02","objectID":"/anime/hoshi_no_koe/:2:0","tags":null,"title":"星之声","uri":"/anime/hoshi_no_koe/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 星之声 2002-02-02 00:24:30 bilibili ","date":"2002-02-02","objectID":"/anime/hoshi_no_koe/:3:0","tags":null,"title":"星之声","uri":"/anime/hoshi_no_koe/"},{"categories":null,"content":"在20世纪，世界格局比较稳定的时候，各大国都想增强自己的军事力量，从而称霸世界。而Whisper[耳语者]这种特殊的人类，自从出生开始就拥有特殊的能力，不用学习也能知道超越当时科技几十年的被称为黑科技的高科技手段。为了保护世界格局的稳定，神秘组织Mithril[米斯利尔]派出了相良中士等三人去保护一名已知的Whisper[耳语者]，即千鸟香奈。其中相良中士装成转校生随时跟踪保护，由于长期处于军队的生活，完全没有普通高中生的生活常识的相良中士在学校里闹了不少笑话。在学校期间也发生了不少恐怖的事情，如苏联为绑架香奈制造的劫机事件等。宗介和千鸟之间也因为发生的各种事件产生了特殊的感情。","date":"2002-01-15","objectID":"/anime/full_metal_panic/","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"简介 在20世纪，世界格局比较稳定的时候，各大国都想增强自己的军事力量，从而称霸世界。而Whisper[耳语者]这种特殊的人类，自从出生开始就拥有特殊的能力，不用学习也能知道超越当时科技几十年的被称为黑科技的高科技手段。为了保护世界格局的稳定，神秘组织Mithril[米斯利尔]派出了相良中士等三人去保护一名已知的Whisper[耳语者]，即千鸟香奈。其中相良中士装成转校生随时跟踪保护，由于长期处于军队的生活，完全没有普通高中生的生活常识的相良中士在学校里闹了不少笑话。在学校期间也发生了不少恐怖的事情，如苏联为绑架香奈制造的劫机事件等。宗介和千鸟之间也因为发生的各种事件产生了特殊的感情。 制作人","date":"2002-01-15","objectID":"/anime/full_metal_panic/:1:0","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 相良宗介 Sagara Sosuke、相良 宗介、さがら そうすけ、Sagara Sousuke、カシム / 卡西姆 男 関智一 2 千鸟要 Kaname Chidori、千鳥かなめ、Chidori Kaname 女 ゆきのさつき 3 泰蕾莎·泰斯塔罗莎 テレサ・テスタロッサ、Teletha Testarossa、泰莎 女 ゆかな 4 梅利莎·毛 Melissa Mao、メリッサ・マオ、Uruz 2 女 根谷美智子 5 克鲁兹·威巴 Kurz Weber、クルツ・ウェーバー、Uruz 6 男 三木眞一郎 6 理查德·马度卡斯 Richard Henry Ma","date":"2002-01-15","objectID":"/anime/full_metal_panic/:2:0","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 全金属狂潮 2002-01-15 24 bilibili 2 全金属狂潮 校园篇 2003-08-26 12 bilibili 3 全金属狂潮 The Second Raid 2005-07-13 13 bilibili 4 全金属狂潮 The Second Raid OVA 战队长悠闲的一天 2006-05-26 1 bilibili 5 全金属狂潮 Invisible Victory 2018-04-13 12 bilibili ","date":"2002-01-15","objectID":"/anime/full_metal_panic/:3:0","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"MAD ","date":"2002-01-15","objectID":"/anime/full_metal_panic/:4:0","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"自从汉堂在1999年夏天推出《天地劫：神魔至尊传》之后，制作小组在《神魔至尊传》之后，\n便立刻开始着手制作《天地劫》的系列作品《天地劫：幽城幻剑录》。《幽城幻剑录》的故事将以《神魔至尊传》中出身来历最神秘的\n金发邪道法师──夏侯仪为主角，以他少年时代不为人所知的冒险传奇，来交代他在《神魔至尊传》中的诸般出人意料的偏激言行，并连贯两个故事之间的前因后果。","date":"2001-11-18","objectID":"/game/you_cheng/","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"简介 自从汉堂在1999年夏天推出《天地劫：神魔至尊传》之后，制作小组在《神魔至尊传》之后， 便立刻开始着手制作《天地劫》的系列作品《天地劫：幽城幻剑录》。 《幽城幻剑录》的故事将以《神魔至尊传》中出身来历最神秘的 金发邪道法师──夏侯仪为主角，以他少年时代不为人所知的冒险传奇，来交代他在《神魔至尊传》中的 诸般出人意料的偏激言行，并连贯两个故事之间的前因后果。 制作人员： 开发：智乐堂 剧本：叶明璋 ","date":"2001-11-18","objectID":"/game/you_cheng/:1:0","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 夏侯仪 男 2 冰璃 女 3 封铃笙 女 4 慕容璇玑 女 5 古伦德 男 6 霍雍 男 7 皇甫申 男 8 葛云衣 女 ","date":"2001-11-18","objectID":"/game/you_cheng/:2:0","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"系列 系列名 发行时间 1 天地劫序传：幽城幻剑录 2001-11-18 ","date":"2001-11-18","objectID":"/game/you_cheng/:3:0","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"配乐 ","date":"2001-11-18","objectID":"/game/you_cheng/:4:0","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"       小学生进藤光在爷爷家的仓库玩耍时，邂逅了千年前的棋士藤原佐为的魂魄并被强行附体，对围棋原本毫无兴趣的他要如何与佐为相处？\n在佐为的帮助下进藤光意外打败了棋坛明日之星塔矢亮，受到众人关注的他要如何面对自己的人生之路？\n一段联结千年时光的围棋物语就此徐徐展开......","date":"2001-10-10","objectID":"/anime/hikaru_no_go/","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"简介 小学生进藤光在爷爷家的仓库玩耍时，邂逅了千年前的棋士藤原佐为的魂魄并被强行附体，对围棋原本毫无兴趣的他要如何与佐为相处？ 在佐为的帮助下进藤光意外打败了棋坛明日之星塔矢亮，受到众人关注的他要如何面对自己的人生之路？ 一段联结千年时光的围棋物语就此徐徐展开…… 制作人员： 原作：小畑健、堀田由美 导演：远藤彻哉、西泽晋、神谷纯 脚本：大桥志吉、富冈淳广、横手美智子 ","date":"2001-10-10","objectID":"/anime/hikaru_no_go/:1:0","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 进藤光 進藤 ヒカル、しんどう ひかる、Shindou Hikaru 男 川上とも子 2 藤原佐为 藤原佐為、ふじわら の さい、Fujiwara no Sai 男 千葉進歩 3 塔矢亮 塔矢 アキラ、とうや アキラ 男 小林沙苗 4 筒井公宏 筒井公宏、つつい きみひろ、Tsutsui Kimihiro 男 津村まこと 5 绪方精次 緒方精次、Ogata Seiji 男 藤原啓治 6 和谷义高 和谷義高、Waya Yoshitaka 男 高木礼子 7 岸本薰 岸本薫、Kishimoto Kaoru 男 櫻井孝宏 8 尹教练 尹先生、Yun-sensei 男","date":"2001-10-10","objectID":"/anime/hikaru_no_go/:2:0","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 棋魂 2001-10-10 75 樱花 2 棋魂特别篇 迈向北斗杯之路 2004-01-03 1 bilibili ","date":"2001-10-10","objectID":"/anime/hikaru_no_go/:3:0","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"MAD ","date":"2001-10-10","objectID":"/anime/hikaru_no_go/:4:0","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"为了和外星侵略者进行抗争，组织“太白星”制造了最强战斗用人型机器人麻幌。在她的生命即将终结之际她离开了战场，将自己剩余的时间投入到少年美里优的女仆工作之中。等待她的会是平静的生活吗……","date":"2001-10-05","objectID":"/anime/mahoromatic/","tags":null,"title":"魔力女管家","uri":"/anime/mahoromatic/"},{"categories":null,"content":"简介 为了和外星侵略者进行抗争，组织“太白星”制造了最强战斗用人型机器人麻幌。在她的生命即将终结之际她离开了战场，将自己剩余的时间投入到少年美里优的女仆工作之中。等待她的会是平静的生活吗…… 制作人员： 原作：Ditama某、中山文十郎 导演：山贺博之 脚本：佐伯昭志 分镜：山口赖房、高桥拓朗、铃木利正 ","date":"2001-10-05","objectID":"/anime/mahoromatic/:1:0","tags":null,"title":"魔力女管家","uri":"/anime/mahoromatic/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安藤麻幌 Андо Махоро、安藤まほろ、Andou Mahoro 女 川澄綾子 2 美里优 Мисато Сугуру、美里優、Misato Suguru 男 瀧本富士子 3 史莱修 Слэш、スラッシュ、Slash 男 野田圭一 4 式条沙织 式条沙織、Shikijou Saori 女 高田由美 5 佐仓深雪 佐倉深雪、Sakura Miyuki 女 菊地由美 6 大江千鹤子 大江 千鶴子、おおえ ちづこ、Ooe Chiduko 女 真田アサミ 7 滨口俊也 浜口俊也、Hamaguchi Toshiya 男 荻原秀樹 8 流河涛 流河濤、Ryuuga","date":"2001-10-05","objectID":"/anime/mahoromatic/:2:0","tags":null,"title":"魔力女管家","uri":"/anime/mahoromatic/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔力女管家 2001-10-05 12 樱花 2 魔力女管家～更美丽的事物～ 2002-09-26 14 樱花 3 魔力女管家夏日TV特别篇 “我认为H是不对的！ 2003-08-14 1 9anime 4 魔力女管家特别篇 我回来了◆欢迎回来 2009-10-17 2 樱花 ","date":"2001-10-05","objectID":"/anime/mahoromatic/:3:0","tags":null,"title":"魔力女管家","uri":"/anime/mahoromatic/"},{"categories":null,"content":"MAD ","date":"2001-10-05","objectID":"/anime/mahoromatic/:4:0","tags":null,"title":"魔力女管家","uri":"/anime/mahoromatic/"},{"categories":null,"content":"风靡日本的女明星藤原千代子，三十年前当红之际，突然从银幕消声匿迹。\n三十年后，千代子的影迷费尽千辛万苦，终于在人烟稀少的寂静山庄中，找到了隐居数十年的她，并献上了一把千代子当年不慎遗失的神秘钥匙。\n神秘钥匙宛若开启了记忆之门，引领千代子划入回忆的大海，挖掘出一段她从不为人知的爱情故事。那故事像是从千代子辉煌年代的河流溢出，一路流向她无数的电影与映像汇集而成的海洋；也像从遥远的战国时代奔驰而来，再闯进无边无际的时空未来。\n而倾听入神的影迷，则随着千代子在记忆的逆流波谷间摆荡，体验她那令人怜惜的悲欢爱情；更在波涛汹涌的时空浪潮中，猛然惊觉到那股横亘千年的浓绵相思，神秘钥匙开启被千代子封锁隐藏了的记忆，解开了她的重要秘密。那正是在无情的时间洪流里，当记忆与爱情最灿烂交会时，所浮现出最真实且永恒的一代巨星千代子。","date":"2001-07-28","objectID":"/anime/millennium_actress/","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"简介 风靡日本的女明星藤原千代子，三十年前当红之际，突然从银幕消声匿迹。 三十年后，千代子的影迷费尽千辛万苦，终于在人烟稀少的寂静山庄中，找到了隐居数十年的她，并献上了一把千代子当年不慎遗失的神秘钥匙。 神秘钥匙宛若开启了记忆之门，引领千代子划入回忆的大海，挖掘出一段她从不为人知的爱情故事。那故事像是从千代子辉煌年代的河流溢出，一路流向她无数的电影与映像汇集而成的海洋；也像从遥远的战国时代奔驰而来，再闯进无边无际的时空未来。 而倾听入神的影迷，则随着千代子在记忆的逆流波谷间摆荡，体验她那令人怜惜的悲欢爱情；更在波涛汹涌的时空浪潮中，猛然惊觉到那股横亘千年的浓绵相思，神秘钥匙开启被千代子封锁隐藏","date":"2001-07-28","objectID":"/anime/millennium_actress/:1:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤原千代子 Fujiwara Chiyoko 女 折笠富美子 2 钥匙先生 男 山寺宏一 3 立花源也 男 佐藤政道 4 井田恭二 男 小野坂昌也 ","date":"2001-07-28","objectID":"/anime/millennium_actress/:2:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 千年女优 2001-07-28 01:26:26 bilibili ","date":"2001-07-28","objectID":"/anime/millennium_actress/:3:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"配乐 ","date":"2001-07-28","objectID":"/anime/millennium_actress/:4:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"MAD ","date":"2001-07-28","objectID":"/anime/millennium_actress/:5:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"年仅10岁的荻野千尋是一个看起来非常普通的四年级小学生，她随父母搬家来到一个陌生的城镇准备开始一个全新的生活。然而，因为途中迷路，她和父母误闯入了一个人类不应该进入的灵异小镇。小镇的主管是当地一家叫“油屋”的澡堂的巫婆：湯婆婆；而“油屋”则是为服侍日本八百万天神洗澡的地方。镇上有一条规定，在镇上凡是没有工作的人，都要被变成猪被吃掉。\n\n千尋的父母由于贪吃，未經過店員容許就隨便觸碰食物，而遭到惩罚变成了猪。千尋为了拯救父母，在汤婆婆的助手「珀」（ハク，台灣上映時譯為「白龍」）的帮助下，进入澡堂，并成功的获得了一份工作。作为代价，她的名字被汤婆婆拿掉了筆劃太多的名字，成了“千”（台灣片中稱為「小千」）。在澡堂工作的过程中，小千从一个娇生惯养，什么活都不会做的小女孩，逐渐成长，变得越来越坚强能干；同时，她善良的品格也开始得到了澡堂中其他的尊重，而她和白龙之间也萌生出一段纯真的感情。\n\n而为了拯救父母和对自己重要的人，面对各种困难和危险，千尋也一次次做出了自己的选择。而影片也随着她的心理变化历程而展开。\n\n简介来源于：http://zh.wikipedia.org/wiki/%E5%8D%83%E4%B8%8E%E5%8D%83%E5%AF%BB","date":"2001-07-20","objectID":"/anime/spirited_away/","tags":null,"title":"千与千寻","uri":"/anime/spirited_away/"},{"categories":null,"content":"简介 年仅10岁的荻野千尋是一个看起来非常普通的四年级小学生，她随父母搬家来到一个陌生的城镇准备开始一个全新的生活。然而，因为途中迷路，她和父母误闯入了一个人类不应该进入的灵异小镇。小镇的主管是当地一家叫“油屋”的澡堂的巫婆：湯婆婆；而“油屋”则是为服侍日本八百万天神洗澡的地方。镇上有一条规定，在镇上凡是没有工作的人，都要被变成猪被吃掉。 千尋的父母由于贪吃，未經過店員容許就隨便觸碰食物，而遭到惩罚变成了猪。千尋为了拯救父母，在汤婆婆的助手「珀」（ハク，台灣上映時譯為「白龍」）的帮助下，进入澡堂，并成功的获得了一份工作。作为代价，她的名字被汤婆婆拿掉了筆劃太多的名字，成了“千”（台灣片中稱為「","date":"2001-07-20","objectID":"/anime/spirited_away/:1:0","tags":null,"title":"千与千寻","uri":"/anime/spirited_away/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 白 白龙／赈早见琥珀主、Kohaku River、饒速水小白主、ニギハヤミコハクヌシ、Nigihayami Kohaku Nushi 男 入野自由 2 荻野千寻 Ogino Chihiro 女 柊瑠美 3 锅炉爷爷 釜爺、Kamajii 男 菅原文太 4 リン Lin、リン、Rin 女 玉井夕海 5 荻野悠子 おぎの ゆうこ 女 沢口靖子 6 坊 ぼう 男 神木隆之介 7 无脸男 カオナシ 中村彰男 8 汤婆婆 ゆばば 女 夏木マリ ","date":"2001-07-20","objectID":"/anime/spirited_away/:2:0","tags":null,"title":"千与千寻","uri":"/anime/spirited_away/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 千与千寻 2001-07-20 124m 樱花 ","date":"2001-07-20","objectID":"/anime/spirited_away/:3:0","tags":null,"title":"千与千寻","uri":"/anime/spirited_away/"},{"categories":null,"content":"事情起源于六年前。大地隆起，日本的神奈川县在分离之后就被孤立。以后在神奈川出生的少数人就懂得运用阿尔达超能力。阿尔达超能力是一种能够将物质分解再构成的力量…… \n　　数马和刘鳯是对立的，因为所属的地方不同。数马是一个为了钱而生活的人，以自己的超能力来为自己获得金钱，从而满足自己的生活。刘鳯是一个为了找寻阿尔达结晶体，为自己的妈妈报仇而加入圣堂/神圣部队（HOLY）的人。圣堂是由阿尔达超能力者组成的警察部队，为了保护没有超能力者、制止超能力犯罪而设立，所以圣堂的人会捕捉周围土生的超能力者。该日数马和刘鳯的相见就是因为圣堂的一次行动而促成…….......","date":"2001-07-04","objectID":"/anime/scryed/","tags":null,"title":"分身战士","uri":"/anime/scryed/"},{"categories":null,"content":"简介 事情起源于六年前。大地隆起，日本的神奈川县在分离之后就被孤立。以后在神奈川出生的少数人就懂得运用阿尔达超能力。阿尔达超能力是一种能够将物质分解再构成的力量…… 数马和刘鳯是对立的，因为所属的地方不同。数马是一个为了钱而生活的人，以自己的超能力来为自己获得金钱，从而满足自己的生活。刘鳯是一个为了找寻阿尔达结晶体，为自己的妈妈报仇而加入圣堂/神圣部队（HOLY）的人。圣堂是由阿尔达超能力者组成的警察部队，为了保护没有超能力者、制止超能力犯罪而设立，所以圣堂的人会捕捉周围土生的超能力者。该日数马和刘鳯的相见就是因为圣堂的一次行动而促成…………. 制作人员： 原作：矢立肇 导演：谷口悟朗 脚本：","date":"2001-07-04","objectID":"/anime/scryed/:1:0","tags":null,"title":"分身战士","uri":"/anime/scryed/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 刘凤 劉鳳、りゅう ほう、Ryuu Hou 男 緑川光 2 一马 数马、カズマ 男 保志総一朗 3 由詑かなみ Yuta Kanami、由詑かなみ 女 田村ゆかり 4 橘あすか 橘あすか、Tachibana Asuka 男 岩永哲哉 5 桐生水守 Kiryuu Mimori、桐生水守 女 永島由子 6 シェリス・アジャーニ Sherrice Adjani、シェリス・アジャーニ 女 倉田雅世 7 无常矜侍 Mujou Kyouji 男 白鳥哲 8 史特雷特·库卡 Straight Cougar 男 津久井教生 ","date":"2001-07-04","objectID":"/anime/scryed/:2:0","tags":null,"title":"分身战士","uri":"/anime/scryed/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 分身战士 2001-07-04 26 bilibili ","date":"2001-07-04","objectID":"/anime/scryed/:3:0","tags":null,"title":"分身战士","uri":"/anime/scryed/"},{"categories":null,"content":"描述距离现今不远的近未来世界，世界到处都可以看到异形，人们一点也不觉得稀奇，在小学里面只要升到了六年级就有可能成为“异形应变小组”的成员。\n\n而这届被选为“异形应变小组”的是大谷由莉、川村久美以及远峰霞这三个女生。而“异形应变小组”成员，各自以共生型异形－宝咕为搭档，将入侵学校的各种异形加以击退与捕捉。本来以为就只是这样而已...\n\n其背后其实隐藏了非常巨大的阴谋。","date":"2001-06-25","objectID":"/anime/alien_9/","tags":null,"title":"校园外星人","uri":"/anime/alien_9/"},{"categories":null,"content":"简介 描述距离现今不远的近未来世界，世界到处都可以看到异形，人们一点也不觉得稀奇，在小学里面只要升到了六年级就有可能成为“异形应变小组”的成员。 而这届被选为“异形应变小组”的是大谷由莉、川村久美以及远峰霞这三个女生。而“异形应变小组”成员，各自以共生型异形－宝咕为搭档，将入侵学校的各种异形加以击退与捕捉。本来以为就只是这样而已… 其背后其实隐藏了非常巨大的阴谋。 制作人员： 原作：富泽人志 导演：藤本次朗、入江泰浩 脚本：村井贞之、水上清资 分镜：锦织博、樱美胜志 ","date":"2001-06-25","objectID":"/anime/alien_9/:1:0","tags":null,"title":"校园外星人","uri":"/anime/alien_9/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 大谷由莉 大谷百合、Ootani Yuri 女 井端珠里 2 远峰霞 Toomine Kasumi 女 下屋則子 3 川村久美 Kawamura Kumi 女 清水香里 4 宝咕 Bougu 外星人 中尾隆聖 5 久川惠 Hisakawa Megumi 女 久川綾 6 珠木美佑 Tamaki Miyu 女 中山さら 7 イエローナイフ Yellow Knife 外星人 石田彰 ","date":"2001-06-25","objectID":"/anime/alien_9/:2:0","tags":null,"title":"校园外星人","uri":"/anime/alien_9/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 校园外星人 2001-06-25 4 9anime ","date":"2001-06-25","objectID":"/anime/alien_9/:3:0","tags":null,"title":"校园外星人","uri":"/anime/alien_9/"},{"categories":null,"content":"“银河天使队”是特兰斯巴尔皇国近卫军所属的特殊部队。任务是收集古代文明遗留下的“遗失科技”。但是实际上，从猫的搜索、VIP和犯罪者的护送、垃圾处理到钉在行星上的钉子的拔除，可谓是无所不做的万事屋。","date":"2001-04-07","objectID":"/anime/galaxy_angel/","tags":null,"title":"银河天使","uri":"/anime/galaxy_angel/"},{"categories":null,"content":"简介 “银河天使队”是特兰斯巴尔皇国近卫军所属的特殊部队。任务是收集古代文明遗留下的“遗失科技”。但是实际上，从猫的搜索、VIP和犯罪者的护送、垃圾处理到钉在行星上的钉子的拔除，可谓是无所不做的万事屋。 制作人员： 原作：Broccoli 导演：浅香守生、大桥誉志光 脚本：佐藤胜一、泷晃一、菅良幸、杉原研二、金卷兼一、远藤明范 ","date":"2001-04-07","objectID":"/anime/galaxy_angel/:1:0","tags":null,"title":"银河天使","uri":"/anime/galaxy_angel/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 梅尔优·樱叶 梅尔菲·樱叶、美露菲悠·樱叶、Milfeulle Sakuraba、ミルフィーユ・桜葉、梅尔优˙樱叶、蜜尔妃.樱叶 女 新谷良子 2 兰花·法兰波瓦兹 兰花·弗兰波瓦兹、蘭花・フランボワーズ、Ranpha Franboise 女 田村ゆかり 3 薄荷·布拉曼修 薄荷·布兰蒙榭、Mint Blancmanche、ミント・ブラマンシュ、ミント・ブラマンシュ、敏特/明特 女 沢城みゆき 4 佛特·修特伦 佛特·修特雷、フォルテ・シュトーレン、Forte Stollen 女 山口眞弓 5 香草·亚修 范妮拉·H、Vanilla˙H、ヴァニラ・H 女 か","date":"2001-04-07","objectID":"/anime/galaxy_angel/:2:0","tags":null,"title":"银河天使","uri":"/anime/galaxy_angel/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 银河天使 2001-04-07 26 bilibili 2 银河天使Z 2002-02-03 19 bilibili 3 银河天使A 2002-10-06 55 acfun、acfun 4 银河天使X 2004-07-07 26 acfun ","date":"2001-04-07","objectID":"/anime/galaxy_angel/:3:0","tags":null,"title":"银河天使","uri":"/anime/galaxy_angel/"},{"categories":null,"content":"猫姐姐病重卧床，灵魂正被死神带走。猫猫弟弟拼命与死神争回姐姐的灵魂，千辛万苦却只争回一半，姐姐虽然死而复生，可是睁开眼睛的姐姐却变得痴痴傻傻。猫猫姐弟原本受妈妈所托到街市买豆腐，但他们却辗转踏上为姐姐寻找另一半灵魂的旅程。\n诡异的旅途中，不乏血腥与暴力，但也少不了温馨和生趣。他们遇上马戏团神奇的魔术师，穿过大海，走过沙漠，遇上大屋的奇怪主人，还遇上把猫猫残肢缝合的妇人，还有孩子脾气的上帝，随意拨弄着时间。最后他们终于找到了拯救姐姐的四叶花。","date":"2001-02-21","objectID":"/anime/cat_soup/","tags":null,"title":"猫汤","uri":"/anime/cat_soup/"},{"categories":null,"content":"简介 猫姐姐病重卧床，灵魂正被死神带走。猫猫弟弟拼命与死神争回姐姐的灵魂，千辛万苦却只争回一半，姐姐虽然死而复生，可是睁开眼睛的姐姐却变得痴痴傻傻。猫猫姐弟原本受妈妈所托到街市买豆腐，但他们却辗转踏上为姐姐寻找另一半灵魂的旅程。 诡异的旅途中，不乏血腥与暴力，但也少不了温馨和生趣。他们遇上马戏团神奇的魔术师，穿过大海，走过沙漠，遇上大屋的奇怪主人，还遇上把猫猫残肢缝合的妇人，还有孩子脾气的上帝，随意拨弄着时间。最后他们终于找到了拯救姐姐的四叶花。 制作人员： 原作：桥口千代美 导演：佐藤龙雄 脚本：汤浅政明 音乐：小笠原宽 美术监督：中村豪希 ","date":"2001-02-21","objectID":"/anime/cat_soup/:1:0","tags":null,"title":"猫汤","uri":"/anime/cat_soup/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 喵子 Nyako 女 2 喵太 Nyatta 男 3 喵五郎 男 4 喵江 にゃす江 女 ","date":"2001-02-21","objectID":"/anime/cat_soup/:2:0","tags":null,"title":"猫汤","uri":"/anime/cat_soup/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 猫汤 2001-02-21 1 樱花 ","date":"2001-02-21","objectID":"/anime/cat_soup/:3:0","tags":null,"title":"猫汤","uri":"/anime/cat_soup/"},{"categories":null,"content":"陀螺战士》(爆転シュート ベイブレード)，又译战斗陀螺、爆旋陀螺。是日本的动画和漫画作品，其漫画版前期于快乐龙别册《HERO》连载，后期于快乐龙双周刊连载，于2004年16期结束。动画版则由 d-rights 制作，并于东京电视台播出。内容是关于一群小孩利用含有“圣兽”的陀螺进行决斗的故事。一般被认为是玩具公司 TAKARA 为促销玩具(陀螺)而诞生的动漫画作品。漫画分为大会篇、白虎族篇、尤里篇、世界大赛篇、伯克篇(演变为无印剧情)、圣封士篇、赛欧篇(演变为第二部剧情)、新世界大赛预选篇、新世界大赛(第三部剧情)。","date":"2001-01-08","objectID":"/anime/beyblade/","tags":null,"title":"爆旋陀螺","uri":"/anime/beyblade/"},{"categories":null,"content":"简介 陀螺战士》(爆転シュート ベイブレード)，又译战斗陀螺、爆旋陀螺。是日本的动画和漫画作品，其漫画版前期于快乐龙别册《HERO》连载，后期于快乐龙双周刊连载，于2004年16期结束。动画版则由 d-rights 制作，并于东京电视台播出。内容是关于一群小孩利用含有“圣兽”的陀螺进行决斗的故事。一般被认为是玩具公司 TAKARA 为促销玩具(陀螺)而诞生的动漫画作品。漫画分为大会篇、白虎族篇、尤里篇、世界大赛篇、伯克篇(演变为无印剧情)、圣封士篇、赛欧篇(演变为第二部剧情)、新世界大赛预选篇、新世界大赛(第三部剧情)。 制作人员： 原作：青木孝夫 导演：川濑敏文 脚本：杉原研二、荒西大介、大","date":"2001-01-08","objectID":"/anime/beyblade/:1:0","tags":null,"title":"爆旋陀螺","uri":"/anime/beyblade/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 木之宫孝男 kinomiya takao 男 くまいもとこ 2 火渡凯 火盗海、Hiwatari kai 男 高乃麗 3 金李 Kon Rei 男 久川綾 4 水原麦斯 Mizuhara Max 男 折笠愛 5 キョウジュ 男 桑島法子 ","date":"2001-01-08","objectID":"/anime/beyblade/:2:0","tags":null,"title":"爆旋陀螺","uri":"/anime/beyblade/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 爆旋陀螺 2001-01-08 51 bilibili 2 爆旋陀螺2 2002-01-07 51 bilibili 3 爆旋陀螺G世代 2003-01-06 52 bilibili ","date":"2001-01-08","objectID":"/anime/beyblade/:3:0","tags":null,"title":"爆旋陀螺","uri":"/anime/beyblade/"},{"categories":null,"content":"青年学生维利•维金斯（Wiley Wiggins 饰）童年时曾从小伙伴那里得到这样一个预言：“梦即命运”。长大后，他在恍恍惚惚间来到了一座陌生的城市。维利走街串巷，经历各种各样的神奇体验，仿佛穿梭于不同的梦中。在此期间，他还遇到了各色人等：从开着船形汽车的司机到大学教授，从性感的金发美女到癫狂的眼睛男，从引火自焚的金发男子再到留着雷鬼头的四人团体……每个人都喋喋不休，谈论着人生、理想和哲学。而维利不发一言，俨然一个极具耐心的聆听者。\n　　本片由导演兼编剧理查德•林克莱特（Richard Linklater）采用DV真人拍摄，并用软件将其“动画化”。导演史蒂文•索德伯格（Steven Soderbergh）亦在片中出现。","date":"2001-01-01","objectID":"/anime/waking_life/","tags":null,"title":"半梦半醒的人生","uri":"/anime/waking_life/"},{"categories":null,"content":"简介 青年学生维利•维金斯（Wiley Wiggins 饰）童年时曾从小伙伴那里得到这样一个预言：“梦即命运”。长大后，他在恍恍惚惚间来到了一座陌生的城市。维利走街串巷，经历各种各样的神奇体验，仿佛穿梭于不同的梦中。在此期间，他还遇到了各色人等：从开着船形汽车的司机到大学教授，从性感的金发美女到癫狂的眼睛男，从引火自焚的金发男子再到留着雷鬼头的四人团体……每个人都喋喋不休，谈论着人生、理想和哲学。而维利不发一言，俨然一个极具耐心的聆听者。 本片由导演兼编剧理查德•林克莱特（Richard Linklater）采用DV真人拍摄，并用软件将其“动画化”。导演史蒂文•索德伯格（Steven Sode","date":"2001-01-01","objectID":"/anime/waking_life/:1:0","tags":null,"title":"半梦半醒的人生","uri":"/anime/waking_life/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 半梦半醒的人生 2001-01-01 1 bilibili ","date":"2001-01-01","objectID":"/anime/waking_life/:2:0","tags":null,"title":"半梦半醒的人生","uri":"/anime/waking_life/"},{"categories":null,"content":"日暮戈薇是就读于国中三年级的15岁普通小女生，某日，她偶然通过家中神社的枯井来到了500年前的战国时代。时狼烟四起，妖怪横行，世间大地生灵涂炭。戈薇在御神木那里邂逅了被封印的半妖犬夜叉。50年前，意欲变成真正妖怪的犬夜叉，为了得到四魂之玉结识拥有强大灵力的巫女桔梗。经过一段时间相处，两人之间产生了感情。犬夜叉因此希望变成人类，而桔梗也打算在净化完四魂之玉后过回普通人的生活。然而，对桔梗心存邪念的盗贼鬼蜘蛛将灵魂和肉体献给妖怪，继而转生变成邪恶的半妖奈落。在他的一番挑拨下，犬夜叉被桔梗封印在神木之上，重伤的桔梗也在悲伤绝望中死去。\n桔梗转生的戈薇解救了犬夜叉，却不慎将四魂之玉射成碎片。为了找回碎片，她和犬夜叉以及随后遇到的伙伴：七宝、弥勒、珊瑚踏上了充满艰难险阻的旅途…… ","date":"2000-10-16","objectID":"/anime/inuyasha/","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"简介 日暮戈薇是就读于国中三年级的15岁普通小女生，某日，她偶然通过家中神社的枯井来到了500年前的战国时代。时狼烟四起，妖怪横行，世间大地生灵涂炭。戈薇在御神木那里邂逅了被封印的半妖犬夜叉。50年前，意欲变成真正妖怪的犬夜叉，为了得到四魂之玉结识拥有强大灵力的巫女桔梗。经过一段时间相处，两人之间产生了感情。犬夜叉因此希望变成人类，而桔梗也打算在净化完四魂之玉后过回普通人的生活。然而，对桔梗心存邪念的盗贼鬼蜘蛛将灵魂和肉体献给妖怪，继而转生变成邪恶的半妖奈落。在他的一番挑拨下，犬夜叉被桔梗封印在神木之上，重伤的桔梗也在悲伤绝望中死去。 桔梗转生的戈薇解救了犬夜叉，却不慎将四魂之玉射成碎片。为了","date":"2000-10-16","objectID":"/anime/inuyasha/:1:0","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 犬夜叉 いぬやしゃ、Inuyasha 男 山口勝平 2 日暮戈薇 日暮笼目、日暮篱、日暮かごめ、ひぐらし かごめ、Higurashi Kagome 女 ゆきのさつき 3 桔梗 ききょう、Kikyou 女 日髙のり子 4 七宝 しっぽう、Shippou 男 渡辺久美子 5 弥勒 みろく、Miroku 男 辻谷耕史 6 珊瑚 さんご、Sango 女 桑島法子 7 杀生丸 せっしょうまる、Sesshoumaru 男 成田剣 8 奈落 ならく、Naraku 男 森川智之 ","date":"2000-10-16","objectID":"/anime/inuyasha/:2:0","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 犬夜叉 2000-10-16 167 bilibili 2 犬夜叉 完结篇 2009-10-03 26 bilibili 3 犬夜叉 穿越时空的思念 2001-12-15 1 bilibili 4 犬夜叉 镜中的梦幻城 2002-12-21 1 bilibili 5 犬夜叉 天下霸道之剑 2003-12-20 1 bilibili 6 犬夜叉 红莲之蓬莱岛 2004-12-23 1 樱花 7 犬夜叉 黑色铁碎牙 2008-07-30 1 优酷 ","date":"2000-10-16","objectID":"/anime/inuyasha/:3:0","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"MAD ","date":"2000-10-16","objectID":"/anime/inuyasha/:4:0","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"《Air》是日本Key会社继《Kanon》后，所出品的第二款恋爱AVG（电子小说类游戏）游戏。\n\nAIR的标志是一个牵着男孩的手的女孩。故事主要以夏天为主基调，讲述了一个跨越千年的翼人传说。亦被视为Key社季节组曲中的“夏”。","date":"2000-09-08","objectID":"/game/air/","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"简介 《Air》是日本Key会社继《Kanon》后，所出品的第二款恋爱AVG（电子小说类游戏）游戏。 AIR的标志是一个牵着男孩的手的女孩。故事主要以夏天为主基调，讲述了一个跨越千年的翼人传说。 亦被视为Key社季节组曲中的“夏”。 制作人员： 开发：Key 剧本：云龙寺魁、丘野塔也、麻枝准、凉元悠一 音乐：折户伸治、戸越まごめ ","date":"2000-09-08","objectID":"/game/air/:1:0","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 神尾观铃 かみお みすず、Kamio Misuzu 女 川上とも子 2 雾岛佳乃 きりしま かの、Kirishima Kano 女 岡本麻見 3 远野美凪 とおの みなぎ、Tohno Minagi 女 柚木涼香 4 神奈备命 かんなびのみこと、Kannabi no Mikoto 女 西村ちなみ 5 国崎往人 くにさき ゆきと、Kunisaki Yukito 男 緑川光 6 柳也 りゅうや、Ryuuya 男 神奈延年 7 里叶 裏葉、うらは、Uraha 女 井上喜久子 8 神尾晴子 かみお はるこ、Kamio Haruko 女 久川綾 ","date":"2000-09-08","objectID":"/game/air/:2:0","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"系列 系列名 发行时间 1 AIR 2000-09-08 ","date":"2000-09-08","objectID":"/game/air/:3:0","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"配乐 ","date":"2000-09-08","objectID":"/game/air/:4:0","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"　　根据小说版第三作《D-妖杀行》改编。2000年8月25日以《Vampire Hunter D: Bloodlust》片名在美国上映。与前作OVA版相较，本片则受到原作者菊地秀行的高度评价。日本在2001年4月21日，先以英语配音版配日文字幕方式于院线上映，之后在发行英语版DVD一段期间后，比英语版先行制作的日语配音版本才另行推出DVD上市。台湾由普威尔发行的授权DVD，则为英日双语同时收录。","date":"2000-08-25","objectID":"/anime/vampire_hunter_d/","tags":null,"title":"吸血鬼猎人D：妖杀行","uri":"/anime/vampire_hunter_d/"},{"categories":null,"content":"简介 根据小说版第三作《D-妖杀行》改编。2000年8月25日以《Vampire Hunter D: Bloodlust》片名在美国上映。与前作OVA版相较，本片则受到原作者菊地秀行的高度评价。日本在2001年4月21日，先以英语配音版配日文字幕方式于院线上映，之后在发行英语版DVD一段期间后，比英语版先行制作的日语配音版本才另行推出DVD上市。台湾由普威尔发行的授权DVD，则为英日双语同时收录。 制作人员： 原作：菊地秀行 导演：川尻善昭 音乐：Marco d’ Ambrosio 人物原案：天野喜孝 人物设定：箕轮丰 分镜构图：渡部隆、小曾根正美 ","date":"2000-08-25","objectID":"/anime/vampire_hunter_d/:1:0","tags":null,"title":"吸血鬼猎人D：妖杀行","uri":"/anime/vampire_hunter_d/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 D Vampire Hunter D、吸血鬼ハンター\"D\" 男 田中秀幸 2 莱拉·马库斯 Leila Marcus 女 矢島晶子 3 左手 Countenanced Carbuncle、Left Hand 男 永井一郎 4 迈耶·林克男爵 Meier Link 男 山寺宏一 5 夏洛特·埃尔伯恩 Charlotte Elbourne 女 篠原恵美 6 卡米拉伯爵夫人 Bloody Countess、血だらけ血だらけ、Countess Carmilla Elizabeth Bathory 女 前田美波里 7 ベンゲ Bengé 男 藤原啓治 8 レイラの孫娘","date":"2000-08-25","objectID":"/anime/vampire_hunter_d/:2:0","tags":null,"title":"吸血鬼猎人D：妖杀行","uri":"/anime/vampire_hunter_d/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 吸血鬼猎人D：妖杀行 2000-08-25 102m 樱花 ","date":"2000-08-25","objectID":"/anime/vampire_hunter_d/:3:0","tags":null,"title":"吸血鬼猎人D：妖杀行","uri":"/anime/vampire_hunter_d/"},{"categories":null,"content":"近未来的日本，一个叫做“疏濑”的城市中，市民过着平凡的生活，只不过，在城市的一角，山冈上面耸立着医疗机器制造厂建造的外形酷似熨斗的工厂，每天固定时刻，那个工厂都像刚烫完东西一样散发出大量蒸汽。\n小学六年级学生直太，与高中女生真见美，直太那个留学的哥哥的女友，一起在河边打发时间。本该是继续平凡的日子，随着传说中的蜜蜂女——睛子驾驶的电车撞上直太而结束了。直太头上长出了奇怪的角！而睛子居然成为直太家的佣人进入了直太家。睛子的秘密与她口中常念起的“FLCL”的含义，令直太的生活有了翻天覆地的改变。","date":"2000-04-26","objectID":"/anime/flcl/","tags":null,"title":"FLCL","uri":"/anime/flcl/"},{"categories":null,"content":"简介 近未来的日本，一个叫做“疏濑”的城市中，市民过着平凡的生活，只不过，在城市的一角，山冈上面耸立着医疗机器制造厂建造的外形酷似熨斗的工厂，每天固定时刻，那个工厂都像刚烫完东西一样散发出大量蒸汽。 小学六年级学生直太，与高中女生真见美，直太那个留学的哥哥的女友，一起在河边打发时间。本该是继续平凡的日子，随着传说中的蜜蜂女——睛子驾驶的电车撞上直太而结束了。直太头上长出了奇怪的角！而睛子居然成为直太家的佣人进入了直太家。睛子的秘密与她口中常念起的“FLCL”的含义，令直太的生活有了翻天覆地的改变。 制作人员： 原作：GAINAX 导演：鹤卷和哉 脚本：榎户洋司 分镜：佐伯昭志、今石洋之、吉成曜","date":"2000-04-26","objectID":"/anime/flcl/:1:0","tags":null,"title":"FLCL","uri":"/anime/flcl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 南束直太 ナンダバ・ナオ太、Nandaba Naota 男 水樹洵 2 春原晴子 Haruko Haruhara、ハルハ・ラハル、ベスパ女 女 新谷真弓 3 鲛岛真见美 サメジマ・マミ美、Samejima Mamimi 女 笠木泉 4 蜷守惠理 Ninamori Eri 女 伊藤実華 5 阿学 男 宮島章 6 政志 マサムネ・マサシ、Masashi 男 鈴木和人 7 宫路纯子 Miyaji Junko、ミヤジュン 女 福井裕佳梨 8 南束卡门 ナンダバ・カモン、Nandaba Kamon 男 松尾スズキ ","date":"2000-04-26","objectID":"/anime/flcl/:2:0","tags":null,"title":"FLCL","uri":"/anime/flcl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 FLCL 2000-04-26 6 bilibili ","date":"2000-04-26","objectID":"/anime/flcl/:3:0","tags":null,"title":"FLCL","uri":"/anime/flcl/"},{"categories":null,"content":"MAD ","date":"2000-04-26","objectID":"/anime/flcl/:4:0","tags":null,"title":"FLCL","uri":"/anime/flcl/"},{"categories":null,"content":"也不知是过去还是未来的年代，“外星移民”早成了平凡的存在。贫穷考生真由子寄居在“荏之花”澡堂的阁楼，一天到晚三餐不继却还得养活个吃白食的外星懒虫。于是万丈波涛滚滚而来。外星小孩尼亚最大的爱好就是收集垃圾，从中回收剩余物资再造飞船。头上没有像其他外星人样生着天线，被蔑称为“低等外星人”却从未在意，在自己的曲调早活得悠哉游哉。真由子的认真清苦，真由子的胆小谨慎，在那外星小孩的心无城府面前，忽然变得意义不明。严肃刻板与大而化之的碰撞，带着轻捷的喜剧色彩，余音早又有些淡色水彩般的惆怅。 \n\n挂在空中像朵云的母船，是尼亚头脑中遥远模糊的，关于“故乡”的呼唤。它化成流黄飞去的那一天，一种最温柔的意象笼罩了“荏之花”的风物与居民。世界如此广阔，而这刻，我们为彼此驻足，这一分钟是准也改变不了，因为那已是过去，将成为回忆，在未来的时光里与我们作着推手，走出个饱满的弧形。所谓生命，所谓怀念，就是这样平平淡淡，生生不息。","date":"2000-04-26","objectID":"/anime/niea_7/","tags":null,"title":"我家也有外星人","uri":"/anime/niea_7/"},{"categories":null,"content":"简介 也不知是过去还是未来的年代，“外星移民”早成了平凡的存在。贫穷考生真由子寄居在“荏之花”澡堂的阁楼，一天到晚三餐不继却还得养活个吃白食的外星懒虫。于是万丈波涛滚滚而来。外星小孩尼亚最大的爱好就是收集垃圾，从中回收剩余物资再造飞船。头上没有像其他外星人样生着天线，被蔑称为“低等外星人”却从未在意，在自己的曲调早活得悠哉游哉。真由子的认真清苦，真由子的胆小谨慎，在那外星小孩的心无城府面前，忽然变得意义不明。严肃刻板与大而化之的碰撞，带着轻捷的喜剧色彩，余音早又有些淡色水彩般的惆怅。 挂在空中像朵云的母船，是尼亚头脑中遥远模糊的，关于“故乡”的呼唤。它化成流黄飞去的那一天，一种最温柔的意象笼罩","date":"2000-04-26","objectID":"/anime/niea_7/:1:0","tags":null,"title":"我家也有外星人","uri":"/anime/niea_7/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 ニア ニア、NieA 女 宮村優子 2 茅崎真由子 女 川澄綾子 3 广播 アナウンサー、Announcer、播音员、Announce 福島潤 ","date":"2000-04-26","objectID":"/anime/niea_7/:2:0","tags":null,"title":"我家也有外星人","uri":"/anime/niea_7/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我家也有外星人 2000-04-26 13 bilibili ","date":"2000-04-26","objectID":"/anime/niea_7/:3:0","tags":null,"title":"我家也有外星人","uri":"/anime/niea_7/"},{"categories":null,"content":"本片讲述了一位武艺高强但又嗜酒如命的女武士（月影兰）与一位使用猫铁拳格斗术的小女孩（美安奈）相遇并一起游历于各处的故事。两人一路上行侠仗义，但又不时地闹出点笑话……","date":"2000-01-26","objectID":"/anime/carried_by_the_wind/","tags":null,"title":"随风舞月影兰","uri":"/anime/carried_by_the_wind/"},{"categories":null,"content":"简介 本片讲述了一位武艺高强但又嗜酒如命的女武士（月影兰）与一位使用猫铁拳格斗术的小女孩（美安奈）相遇并一起游历于各处的故事。两人一路上行侠仗义，但又不时地闹出点笑话…… 制作人员： 原作：大地丙太郎 脚本：高桥良辅、佐藤龙雄、秦义人、横手美智子、池田真美子 分镜：政木伸一 ","date":"2000-01-26","objectID":"/anime/carried_by_the_wind/:1:0","tags":null,"title":"随风舞月影兰","uri":"/anime/carried_by_the_wind/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 月影兰 月影蘭、Tsukikage Ran 女 安原麗子 2 猫鉄拳のミャオ 岡村明美 ","date":"2000-01-26","objectID":"/anime/carried_by_the_wind/:2:0","tags":null,"title":"随风舞月影兰","uri":"/anime/carried_by_the_wind/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 随风舞月影兰 2000-01-26 13 bilibili ","date":"2000-01-26","objectID":"/anime/carried_by_the_wind/:3:0","tags":null,"title":"随风舞月影兰","uri":"/anime/carried_by_the_wind/"},{"categories":null,"content":"MAD ","date":"2000-01-26","objectID":"/anime/carried_by_the_wind/:4:0","tags":null,"title":"随风舞月影兰","uri":"/anime/carried_by_the_wind/"},{"categories":null,"content":"　　传说中海贼王哥尔·D·罗杰在死前说出他留下了具有财富、名声、力量的宝藏「ONE PIECE」，许多人为了争夺ONE PIECE，争相出海，许多海贼开始树立霸权，而形成了大海贼时代。十年后，草帽小子 蒙其·D·路飞为了要实现与因救他而断臂的海贼红发香克斯的约定而出海，在遥远的路途上找寻着志同道合的伙伴，一起进入「伟大的航道」，目标当上海贼王。","date":"1999-10-20","objectID":"/anime/one_piece/","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"简介 传说中海贼王哥尔·D·罗杰在死前说出他留下了具有财富、名声、力量的宝藏「ONE PIECE」，许多人为了争夺ONE PIECE，争相出海，许多海贼开始树立霸权，而形成了大海贼时代。十年后，草帽小子 蒙其·D·路飞为了要实现与因救他而断臂的海贼红发香克斯的约定而出海，在遥远的路途上找寻着志同道合的伙伴，一起进入「伟大的航道」，目标当上海贼王。 制作人员： 原作：尾田荣一郎 导演：小牧文、暮田公平、深泽敏则、宇田钢之介、志水淳儿、长峰达也、境宗久、宮元宏彰 ","date":"1999-10-20","objectID":"/anime/one_piece/:1:0","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 蒙奇·D·路飞 蒙其·D·魯夫、Monkey D. Luffy 男 田中真弓 2 罗罗诺亚·索隆 罗罗亚·佐罗、ロロノア・ゾロ、Roronoa Zoro 男 中井和哉 3 娜美 奈美、ナミ、Nami、小贼猫娜美 女 岡村明美 4 乌索普 撒谎布、骗人布、ウソップ、Usopp、狙击王（そげキング，Sogeking） 男 山口勝平 5 文斯莫克·山智 Vinsmoke Sanji、黒足のサンジ （黑足山治）、文斯莫克·山治（港）、賓什莫克·香吉士（台湾东立） 男 大谷育江 6 托尼托尼·乔巴 东尼东尼·乔巴、トニートニー・チョッパー、Tony Tony Chop","date":"1999-10-20","objectID":"/anime/one_piece/:2:0","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海贼王 1999-10-20 1040 樱花 ","date":"1999-10-20","objectID":"/anime/one_piece/:3:0","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"MAD ","date":"1999-10-20","objectID":"/anime/one_piece/:4:0","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"热血而耿直的少年修在放学路上遇见沉默的少女。在突如其来的变故中，为了保护向他呼救的少女，修被卷入了陌生的时空。在荒芜的世界里，生命将何去何从……\n","date":"1999-10-14","objectID":"/anime/now_and_then/","tags":null,"title":"此时此刻的我","uri":"/anime/now_and_then/"},{"categories":null,"content":"简介 热血而耿直的少年修在放学路上遇见沉默的少女。在突如其来的变故中，为了保护向他呼救的少女，修被卷入了陌生的时空。在荒芜的世界里，生命将何去何从…… 制作人员： 导演：大地丙太郎 脚本：仓田英之 分镜：山崎健志、佐山圣子、井硲清高、大桥誉志光、长滨博史、铃木行 ","date":"1999-10-14","objectID":"/anime/now_and_then/:1:0","tags":null,"title":"此时此刻的我","uri":"/anime/now_and_then/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 拉拉·露 Lala Ru 女 名塚佳織 2 松谷修造 シュウ、Matsutani Shuuzou 男 岡村明美 3 ハムド Hamdo 男 石井康嗣 4 阿贝利亚 ABELIA 安原麗子 5 莎拉 SALA 仲尾あづさ 6 纳布卡 NABUCA 今井由香 7 小布 BOO 小西寛子 8 西斯 SIS 松本梨香 ","date":"1999-10-14","objectID":"/anime/now_and_then/:2:0","tags":null,"title":"此时此刻的我","uri":"/anime/now_and_then/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 此时此刻的我 1999-10-14 13 bilibili ","date":"1999-10-14","objectID":"/anime/now_and_then/:3:0","tags":null,"title":"此时此刻的我","uri":"/anime/now_and_then/"},{"categories":null,"content":"讲述的是不同环境下成长的女孩们，蜕变与成熟的故事。天资聪颖的女高中生，却患有极度的男性恐惧症、从来不敢穿女装的运动健将，竟面临画家央求她当模特儿的难题——","date":"1999-10-06","objectID":"/anime/seraphim_call/","tags":null,"title":"六翼天使之声","uri":"/anime/seraphim_call/"},{"categories":null,"content":"简介 讲述的是不同环境下成长的女孩们，蜕变与成熟的故事。天资聪颖的女高中生，却患有极度的男性恐惧症、从来不敢穿女装的运动健将，竟面临画家央求她当模特儿的难题—— 该作不论是产生的背景或表现的型式，在日本动画界均是少见的案例，它本来只是日本‘电击G’s Magazine’的一个读者特别企划连载单元，刊登后赢得热烈的回响， 于是趁势推出系列周边商品，后来由日本SUNRISE公司制成动画。每一话的主角均不同，剧情也毫不相干（第5、6话例外），最后一话再让所有女主角来个大会串。 制作人员： 导演：望月智充 脚本：村井贞之、荒川稔久、荒木宪一 分镜：大森贵弘、原博、吉永尚之 ","date":"1999-10-06","objectID":"/anime/seraphim_call/:1:0","tags":null,"title":"六翼天使之声","uri":"/anime/seraphim_call/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 栗本雪菜 栗本雪菜、くりもと ゆきな、Kurimoto Yukina 女 笠原弘子 2 寺本蒲公英 寺本たんぽぽ、てらもと　たんぽぽ、Teramoto Tanpopo 女 川田妙子 3 樱濑千奈美 桜瀬ちなみ、おうせ ちなみ 女 矢島晶子 4 楠初摘 楠初摘、くすのき はつみ 女 伊東絵実 5 村雨紫苑 村雨紫苑、Murasame Shion 女 長沢美樹 6 村雨樱 村雨桜、むらさめ さくら 女 西村ちなみ 7 柊彩乃 柊彩乃、Hiiragi Saeno 女 石村知子 8 凛堂绚香 凛堂あやか、りんどう あやか 女 佐久間レイ ","date":"1999-10-06","objectID":"/anime/seraphim_call/:2:0","tags":null,"title":"六翼天使之声","uri":"/anime/seraphim_call/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 六翼天使之声 1999-10-06 12 bilibili ","date":"1999-10-06","objectID":"/anime/seraphim_call/:3:0","tags":null,"title":"六翼天使之声","uri":"/anime/seraphim_call/"},{"categories":null,"content":"西历2225年，宇宙空间站“利柏·迪尔塔（即翻译中三角洲之意）”是这个故事所发生的一切的开端。数百名的学员，为了成为专业宇航员而到达“利柏·迪尔塔”接受教官们的培训。但却因为被一股不知名的势力袭击而导致“利柏·迪尔塔”开始向盖多路托之海沉没。而教官们在保护学员的同时，不幸全部牺牲。就这样幸存的487名青年学生在慌乱之中搭乘上了潜藏在“利柏·迪尔塔”内部的，迷一般的维亚级潜艇“RYVAIUS（利维雅斯）”，开始了他们那充满艰辛以及留下了永远的无法抹去的回忆的万里长征之路。","date":"1999-10-06","objectID":"/anime/infinite_ryvius/","tags":null,"title":"无限的未知","uri":"/anime/infinite_ryvius/"},{"categories":null,"content":"简介 西历2225年，宇宙空间站“利柏·迪尔塔（即翻译中三角洲之意）”是这个故事所发生的一切的开端。数百名的学员，为了成为专业宇航员而到达“利柏·迪尔塔”接受教官们的培训。但却因为被一股不知名的势力袭击而导致“利柏·迪尔塔”开始向盖多路托之海沉没。而教官们在保护学员的同时，不幸全部牺牲。就这样幸存的487名青年学生在慌乱之中搭乘上了潜藏在“利柏·迪尔塔”内部的，迷一般的维亚级潜艇“RYVAIUS（利维雅斯）”，开始了他们那充满艰辛以及留下了永远的无法抹去的回忆的万里长征之路。 制作人员： 导演：谷口悟朗 脚本：竹田裕一郎、黑田洋介 分镜：山崎和男、池田成、北村真咲、吉本毅、杉岛邦久 ","date":"1999-10-06","objectID":"/anime/infinite_ryvius/:1:0","tags":null,"title":"无限的未知","uri":"/anime/infinite_ryvius/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 相叶昴治 相葉 昴治 男 白鳥哲 2 相叶祐希 相葉 祐希、Aiba Yuki 男 保志総一朗 3 尾濑育巳 尾瀬 イクミ、Oze Ikumi 男 関智一 4 蓬仙葵 蓬仙 あおい、ほうせん あおい、Housen Aoi 女 桑島法子 5 和泉梢 和泉こずえ 女 丹下桜 6 ファイナ・S・篠崎 ファイナ・S・篠崎 愛河里花子 7 ユイリィ・バハナ ユイリィ・バハナ 氷上恭子 8 エアーズ・ブルー エアーズ・ブルー、Airs Blue 男 檜山修之 ","date":"1999-10-06","objectID":"/anime/infinite_ryvius/:2:0","tags":null,"title":"无限的未知","uri":"/anime/infinite_ryvius/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 无限的未知 1999-10-06 26 bilibili ","date":"1999-10-06","objectID":"/anime/infinite_ryvius/:3:0","tags":null,"title":"无限的未知","uri":"/anime/infinite_ryvius/"},{"categories":null,"content":"表面上，素（坂本真绫 配音）是一名白发的柔弱少女，但是，她还有着另一重身份——“白花苜蓿计划”的试验品。“白花苜蓿计划”专门挑选出那些能够使用魔法的孩子，囚禁并且研究他们的能力，最终作为兵器使用，工作人员称他们为“三叶草”，在三叶草中，魔法能力出众的孩子被称为“四片叶的三叶草”，而素是其中最优秀的一个，她拥有能够毁灭世界的能力。  \n\n长久以来的形单影只让素倍感寂寞，周围的人无不对她心存恐惧。终于有一天，她的能力失控了，在一片血泊之中，那个名叫琉.F.和彦（谷山纪章 配音）的男子出现了，素请求他护送她，前往传说中的妖精游乐园，在那里，素一直渴望着的幸福在等着她","date":"1999-08-21","objectID":"/anime/clover/","tags":null,"title":"三叶草","uri":"/anime/clover/"},{"categories":null,"content":"简介 表面上，素（坂本真绫 配音）是一名白发的柔弱少女，但是，她还有着另一重身份——“白花苜蓿计划”的试验品。“白花苜蓿计划”专门挑选出那些能够使用魔法的孩子，囚禁并且研究他们的能力，最终作为兵器使用，工作人员称他们为“三叶草”，在三叶草中，魔法能力出众的孩子被称为“四片叶的三叶草”，而素是其中最优秀的一个，她拥有能够毁灭世界的能力。 长久以来的形单影只让素倍感寂寞，周围的人无不对她心存恐惧。终于有一天，她的能力失控了，在一片血泊之中，那个名叫琉.F.和彦（谷山纪章 配音）的男子出现了，素请求他护送她，前往传说中的妖精游乐园，在那里，素一直渴望着的幸福在等着她 制作人员： 原作：CLAMP 导","date":"1999-08-21","objectID":"/anime/clover/:1:0","tags":null,"title":"三叶草","uri":"/anime/clover/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 素 Suu 女 坂本真綾 2 蓝 Ran、らん 男 谷山紀章 ","date":"1999-08-21","objectID":"/anime/clover/:2:0","tags":null,"title":"三叶草","uri":"/anime/clover/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 三叶草 1999-08-21 06:35 bilibili ","date":"1999-08-21","objectID":"/anime/clover/:3:0","tags":null,"title":"三叶草","uri":"/anime/clover/"},{"categories":null,"content":"MAD ","date":"1999-08-21","objectID":"/anime/clover/:4:0","tags":null,"title":"三叶草","uri":"/anime/clover/"},{"categories":null,"content":"《宝莲灯》是上海美术电影制片厂继《大闹天宫》、《哪咤闹海》、《天书奇谭》、《金猴降妖》之后于1999年摄制并公映的一部改编自中国神话《宝莲灯》的长篇动画电影。该片总投资1200万元人民币，其剧本、人物造型、背景设计等项目都经过了反复的推敲与修改而创造出来的动画作品。曾经海外各国等地区外购了该片，现有日语、粤语、英语等国语言上映与发行。\n\n天宫中的仙女—三圣母爱上了人间的书生—刘彦昌。三圣母为了爱情，不顾二郎神的反对，带着宝莲灯下凡在圣母宫与刘彦昌相会。七年很快过去了，三圣母与刘彦昌的孩子沉香渐渐长大了，他与母亲一起过着幸福快乐的生活。一天，二郎神在宝莲灯的闪光中找到了他们，为了维护天规的威严趁三圣母不注意时捉走了沉香，三圣母发现后便上天寻子，二郎神并要挟三圣母交出宝莲灯才会放了沉香，三圣母无奈只好吹灭宝莲灯之光并交给了二郎神，结果二郎神将其镇压在华山底下。\n在天宫中的沉香从土地爷口中得知了自己的身世后便立志打败二郎神，夺回宝莲灯并救出母亲。为夺回宝莲灯他机智地与两个护灯秦俑神周旋，最终夺回了母亲的宝莲灯。在天宫中同为二郎神人质的部落族长之女嘎妹的帮助下逃离了天宫，踏上了寻找母亲的道路。\n在寻母的征途中，沉香经历了重重磨难，最终成为了一个英勇的少年，并拜孙悟空为师。之后在嘎妹与她的部落族人的帮助下利用二郎神的神像练就一把神斧，最后结合宝莲灯的神力击败了二郎神，最终用神斧将华山劈开把母亲从华山底下解救出来的感人故事。","date":"1999-07-30","objectID":"/anime/bao_lian_deng/","tags":null,"title":"宝莲灯","uri":"/anime/bao_lian_deng/"},{"categories":null,"content":"简介 《宝莲灯》是上海美术电影制片厂继《大闹天宫》、《哪咤闹海》、《天书奇谭》、《金猴降妖》之后于1999年摄制并公映的一部改编自中国神话《宝莲灯》的长篇动画电影。该片总投资1200万元人民币，其剧本、人物造型、背景设计等项目都经过了反复的推敲与修改而创造出来的动画作品。曾经海外各国等地区外购了该片，现有日语、粤语、英语等国语言上映与发行。 天宫中的仙女—三圣母爱上了人间的书生—刘彦昌。三圣母为了爱情，不顾二郎神的反对，带着宝莲灯下凡在圣母宫与刘彦昌相会。七年很快过去了，三圣母与刘彦昌的孩子沉香渐渐长大了，他与母亲一起过着幸福快乐的生活。一天，二郎神在宝莲灯的闪光中找到了他们，为了维护天规的威","date":"1999-07-30","objectID":"/anime/bao_lian_deng/:1:0","tags":null,"title":"宝莲灯","uri":"/anime/bao_lian_deng/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 沉香 男 杨硕 2 三圣母 女 徐帆 3 二郎神 杨戬、显圣二郎真君、清源妙道真君 男 姜文 4 孙悟空 斗战胜佛、齐天大圣、花果山美猴王、孙行者、Monkey King、孫悟空、そん ごくう、Son Gokuu、猴哥，弼马温，大师兄，心猿，太乙散仙 雄（男） 陈佩斯 5 嘎妹 女 宁静 6 土地爷 男 崔杰 7 假道士 男 梁天 ","date":"1999-07-30","objectID":"/anime/bao_lian_deng/:2:0","tags":null,"title":"宝莲灯","uri":"/anime/bao_lian_deng/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 宝莲灯 1999-07-30 01:24:34 bilibili ","date":"1999-07-30","objectID":"/anime/bao_lian_deng/:3:0","tags":null,"title":"宝莲灯","uri":"/anime/bao_lian_deng/"},{"categories":null,"content":"　　八神太一、石田大和、武之内素娜、城户丈、泉光子郎、太刀川美美、高石武、八神嘉儿这八位小朋友，在夏令营中受到召唤而到进入数码世界进行冒险。\n1999年，由于数码世界资料异常增生，导致数码世界和现实世界的连接发生紊乱。地球上相应地出现奇怪的自然现象：东南亚没有下雨，池塘全部干涸；中东却因为连场大雨发生洪水,美国则遇到有史以来最寒冷的夏天，日本则突降大雪。\n11岁的少年八神太一和他的六个朋友一起参加了夏令营，却奇怪的被神秘地送到了一个多彩的数码世界。在那里，他们得到了叫做“数码宝贝”的搭档。这些孩子被认为是数字世界的未来，他们与数码宝贝们一起要解开控制这个可怕的数码世界之谜。当他们踏上这个伟大的征程时，因特网成了他们的战场……","date":"1999-03-07","objectID":"/anime/digimon_adventure/","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"简介 八神太一、石田大和、武之内素娜、城户丈、泉光子郎、太刀川美美、高石武、八神嘉儿这八位小朋友，在夏令营中受到召唤而到进入数码世界进行冒险。 1999年，由于数码世界资料异常增生，导致数码世界和现实世界的连接发生紊乱。地球上相应地出现奇怪的自然现象：东南亚没有下雨，池塘全部干涸；中东却因为连场大雨发生洪水,美国则遇到有史以来最寒冷的夏天，日本则突降大雪。 11岁的少年八神太一和他的六个朋友一起参加了夏令营，却奇怪的被神秘地送到了一个多彩的数码世界。在那里，他们得到了叫做“数码宝贝”的搭档。这些孩子被认为是数字世界的未来，他们与数码宝贝们一起要解开控制这个可怕的数码世界之谜。当他们踏上这个伟大","date":"1999-03-07","objectID":"/anime/digimon_adventure/:1:0","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 八神太一 やがみ たいち、Yagami Taichi 男 藤田淑子 2 亚古兽 Agumon、아구몬 坂本千夏 3 石田大和 いしだ やまと、Ishida Yamato 男 風間勇刀 4 加布兽 Gabumon、파피몬 山口眞弓 5 武之内空 武之内素娜、たけのうち そら、Takenouchi Sora 女 水谷優子 6 比丘兽 Piyomon、피요몬 重松花鳥 7 泉光子郎 いずみ こうしろう、Izumi Koushiro 男 天神有海 8 甲虫兽 Tentomon、텐토몬 櫻井孝宏 ","date":"1999-03-07","objectID":"/anime/digimon_adventure/:2:0","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 数码宝贝大冒险 1999-03-07 54 樱花 2 数码宝贝大冒险02 2000-04-02 50 樱花 3 数码宝贝驯兽师之王 2001-04-01 51 樱花 4 数码宝贝无限地带 2002-04-07 50 樱花 5 数码宝贝大冒险 滚球兽的诞生 1999-03-06 1 bilibili 6 数码宝贝大冒险 我们的战争游戏! 2000-03-04 1 acfun 7 数码宝贝X进化 2005-01-03 1 bilibili ","date":"1999-03-07","objectID":"/anime/digimon_adventure/:3:0","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"MAD ","date":"1999-03-07","objectID":"/anime/digimon_adventure/:4:0","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"身为劳合社保险公司旗下之保险调查员的平贺[父方之姓]．奇顿[母方之姓]．太一；自牛津大学毕业成为考古学者的同时，也成为了英国陆军特种空勤团之野外求生术的教官．在福克兰群岛战争中和伊拉克国境内美国大使成为人质的世界中以SAS队员的身分表现活跃． 奇顿的父亲是日本人｛且为动物学学者｝，但母亲却是个英国人．他在牛津大学时代和日本籍女友结婚并生下一女． 但因为总总原因两人异离，离婚之后的前妻在大学教授数学；奇顿本人想往考古学的道路继续前进，但本行仍非如此． 为了筹措考古学的探索费用继续当着保险调查员，从过去形形色色的委托，使得他数次遭逢绝境；但也培养出他面对事情的思考力及判断力．\n\n这部作品的背景以｛冷战｝前后的社会情势、考古学发展为根基，交织在和奇顿邂逅的人群的优秀TV化动画作品．","date":"1998-10-05","objectID":"/anime/master_keaton/","tags":null,"title":"危险调查员","uri":"/anime/master_keaton/"},{"categories":null,"content":"简介 身为劳合社保险公司旗下之保险调查员的平贺[父方之姓]．奇顿[母方之姓]．太一；自牛津大学毕业成为考古学者的同时，也成为了英国陆军特种空勤团之野外求生术的教官．在福克兰群岛战争中和伊拉克国境内美国大使成为人质的世界中以SAS队员的身分表现活跃． 奇顿的父亲是日本人｛且为动物学学者｝，但母亲却是个英国人．他在牛津大学时代和日本籍女友结婚并生下一女． 但因为总总原因两人异离，离婚之后的前妻在大学教授数学；奇顿本人想往考古学的道路继续前进，但本行仍非如此． 为了筹措考古学的探索费用继续当着保险调查员，从过去形形色色的委托，使得他数次遭逢绝境；但也培养出他面对事情的思考力及判断力． 这部作品的背景","date":"1998-10-05","objectID":"/anime/master_keaton/:1:0","tags":null,"title":"危险调查员","uri":"/anime/master_keaton/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 平贺·奇顿·太一 平賀＝キートン・太一、ひらが＝キートン・たいち、Taichi Hiraga-Keaton 男 宮田幸季 2 平贺太平 ひらが　たへい 男 永井一郎 3 平贺百合子 ひらが　ゆりこ 女 桑島法子 4 查理·查普曼 男 菅原正志 ","date":"1998-10-05","objectID":"/anime/master_keaton/:2:0","tags":null,"title":"危险调查员","uri":"/anime/master_keaton/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 危险调查员 1998-10-05 39 bilibili ","date":"1998-10-05","objectID":"/anime/master_keaton/:3:0","tags":null,"title":"危险调查员","uri":"/anime/master_keaton/"},{"categories":null,"content":"宫泽雪野是公认的模范优等生，无论是成绩、性格、还是外貌都无可挑剔。因此，同学们将她作为偶像一样崇拜。但是，真正的雪野是一个虚荣心极强的人，为了获得别人的赞赏，几乎什么事情都做得出来。好脾气是装出来的，好成绩是通宵学出来的，可爱的样子是对着镜子苦练的结果。只有在自己家中，雪野才会卸下那个假面具，变成一个不修边幅、任性的普通女孩。\n升入高中后，雪野命中的克星出现了，她的生活完全被破坏了。有马总一郎，出生于医生世家，学业、体育等各方面都非常出色，比雪野更十全十美，也是女生们心中百分百的白马王子。同学们的注意力渐渐集中在有马身上，雪野第一次尝到了被忽视的滋味。于是，雪野将有马作为头号敌人，开始制定打倒他的作战计划，决心重新成为学校的焦点。","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"简介 宫泽雪野是公认的模范优等生，无论是成绩、性格、还是外貌都无可挑剔。因此，同学们将她作为偶像一样崇拜。但是，真正的雪野是一个虚荣心极强的人，为了获得别人的赞赏，几乎什么事情都做得出来。好脾气是装出来的，好成绩是通宵学出来的，可爱的样子是对着镜子苦练的结果。只有在自己家中，雪野才会卸下那个假面具，变成一个不修边幅、任性的普通女孩。 升入高中后，雪野命中的克星出现了，她的生活完全被破坏了。有马总一郎，出生于医生世家，学业、体育等各方面都非常出色，比雪野更十全十美，也是女生们心中百分百的白马王子。同学们的注意力渐渐集中在有马身上，雪野第一次尝到了被忽视的滋味。于是，雪野将有马作为头号敌人，开始制","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/:1:0","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫泽雪野 宮沢雪野、みやざわ ゆきの、Miyazawa Yukino、ゆきのん 女 榎本温子 2 有马总一郎 有馬総一郎、ありま そういちろう、Arima Souichirou、ありま 男 小山裕香 3 浅叶秀明 浅葉秀明、あさば ひであき、Asaba Hideaki、あさば しゅうめい 男 私市淳 4 宫泽洋之 宮沢洋之、みやざわ ひろゆき、Miyazawa Hiroyuki 男 野田順子 5 宫泽月野 宮沢月野、みやざわ つきの、Miyazawa Tsukino 女 渡邉由紀 6 芝姫つばさ 芝姫つばさ 新谷真弓 7 井泽真秀 Izawa Maho 女 ","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/:2:0","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 他和她的故事 1998-10-02 26 bilibili ","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/:3:0","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"配乐 ","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/:4:0","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"岩仓玲音的同学四方田千砂自杀了。没有任何前兆的自杀事件让同学们不知所措，一周后，玲音收到了千砂的短信。明明已死的千砂居然以手机短信和玲音开始了交流。回到家，玲音用爸爸给她的电脑开始与千砂联系。当谈及为何自杀时，千砂回答说“因为我已经不需要身体了，没有身体，我可以在wired网络之间继续活着。”不解的玲音继续调查千砂的事件，发现wired网络之中隐藏的巨大秘密，玲音自己的身世也出现了谜团。玲音面对网络世界中的真相，耳边不断响起千砂的话“我生存在wired中，因为神在那里。”","date":"1998-07-06","objectID":"/anime/lain/","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"简介 岩仓玲音的同学四方田千砂自杀了。没有任何前兆的自杀事件让同学们不知所措，一周后，玲音收到了千砂的短信。明明已死的千砂居然以手机短信和玲音开始了交流。回到家，玲音用爸爸给她的电脑开始与千砂联系。当谈及为何自杀时，千砂回答说“因为我已经不需要身体了，没有身体，我可以在wired网络之间继续活着。”不解的玲音继续调查千砂的事件，发现wired网络之中隐藏的巨大秘密，玲音自己的身世也出现了谜团。玲音面对网络世界中的真相，耳边不断响起千砂的话“我生存在wired中，因为神在那里。” 制作人员： 导演：中村隆太郎 脚本：小中千昭 分镜：仁贺绿朗、佐藤卓哉、村田雅彦 演出：松浦锭平 ","date":"1998-07-06","objectID":"/anime/lain/:1:0","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 岩仓玲音 Lain Iwakura、岩倉 玲音、Iwakura Lain 女 清水香里 2 岩仓康男 岩倉 康男、Iwakura Yasuo 男 大林隆介 3 岩仓美香 岩倉 美香、Iwakura Mika 女 川澄綾子 4 岩仓美穗 岩倉 美穂、Iwakura Miho 女 五十嵐麗 5 英利政美 Eiri Masami 男 速水奨 6 瑞城爱丽丝 Mizuki Alice、みずき ありす、Mizuki Arisu 女 浅田葉子 ","date":"1998-07-06","objectID":"/anime/lain/:2:0","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 玲音 1998-07-06 13 bilibili ","date":"1998-07-06","objectID":"/anime/lain/:3:0","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"MAD ","date":"1998-07-06","objectID":"/anime/lain/:4:0","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"故事的主人公藤原拓海是个普通的高中男生，拥有无与伦比的飞车天赋。从中一开始，每天早上驾驶那辆AE86在秋名山上飞驰，练成了华丽(注意：是华丽)的驾驶技术。必须注意，他的车技之所以高明，是有赖于每天凌晨必须将父亲做的豆腐送到秋名山山顶的饭店。无论刮风、下雨、下雪，五年间车技竟然突飞猛进。黑白颜色的AE86是一辆只有130匹马力的日本“国宝级”旧款跑车，但凭着藤原拓海超凡的技术和天分，先后击败同样是天才少年Red Sun车队的高桥启介；驾驶令人望而生畏的黑色R32的中里毅；采用死亡胶布赛(用胶布粘绑住右手，使方向盘无法扭到空手时的最大限度)战胜了NightKids的第二把交椅；更在秋名山的山道中击败Red Sun第一把交椅，驾驶着代表高贵的FC3S的高桥凉介。当然，拓海的成长不止这些，“他的技术就像艺术一样”，我们最熟悉的就是AE86那华丽的甩尾(汽车用语。指车疾速行驶时疾速拐弯，车轮横向滑动的状态。)以及排水道跑法。秋名山下坡最快的AE86神话正式开始。","date":"1998-04-19","objectID":"/anime/initial_d/","tags":null,"title":"头文字D","uri":"/anime/initial_d/"},{"categories":null,"content":"简介 故事的主人公藤原拓海是个普通的高中男生，拥有无与伦比的飞车天赋。从中一开始，每天早上驾驶那辆AE86在秋名山上飞驰，练成了华丽(注意：是华丽)的驾驶技术。必须注意，他的车技之所以高明，是有赖于每天凌晨必须将父亲做的豆腐送到秋名山山顶的饭店。无论刮风、下雨、下雪，五年间车技竟然突飞猛进。黑白颜色的AE86是一辆只有130匹马力的日本“国宝级”旧款跑车，但凭着藤原拓海超凡的技术和天分，先后击败同样是天才少年Red Sun车队的高桥启介；驾驶令人望而生畏的黑色R32的中里毅；采用死亡胶布赛(用胶布粘绑住右手，使方向盘无法扭到空手时的最大限度)战胜了NightKids的第二把交椅；更在秋名山的山","date":"1998-04-19","objectID":"/anime/initial_d/:1:0","tags":null,"title":"头文字D","uri":"/anime/initial_d/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤原拓海 ふじわら たくみ 男 三木眞一郎 2 四代丰田Sprinter Trueno/卡罗拉雷凌 丰田AE86、ハチロク 3 藤原文太 ふじわら ぶんた、Fujiwara Bunta 男 石塚運昇 4 沙织 さおり 女 福島おりね 5 武内树 武内 樹、たけうち いつき、Takeuchi Itsuki 男 岩田光央 6 池谷浩一郎 池谷 浩一郎、Kouichiro Iketani 男 矢尾一樹 7 五代日产Silvia Nissan Silvia、S13 8 健二 けんじ、Kenji 男 高木渉 ","date":"1998-04-19","objectID":"/anime/initial_d/:2:0","tags":null,"title":"头文字D","uri":"/anime/initial_d/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 头文字D 1998-04-19 26 bilibili 2 头文字D Second Stage 1999-10-15 13 bilibili 3 头文字D Third Stage 2001-01-13 1 bilibili 4 头文字D Fourth Stage 2004-04-17 24 bilibili 5 头文字D Fifth Stage 2012-11-09 14 bilibili 6 头文字D Final Stage 2014-05-16 4 bilibili ","date":"1998-04-19","objectID":"/anime/initial_d/:3:0","tags":null,"title":"头文字D","uri":"/anime/initial_d/"},{"categories":null,"content":"MAD ","date":"1998-04-19","objectID":"/anime/initial_d/:4:0","tags":null,"title":"头文字D","uri":"/anime/initial_d/"},{"categories":null,"content":"故事讲述10岁的木之本樱打开了她父亲所藏的魔法书，意外把有魔法力量的“库洛牌”释放。由于她把卡弄失，要负责寻回，于是看守库洛牌守护兽可鲁贝洛斯，便给予小樱封印之杖，任命她为“库洛魔法使”，陪同并帮助小樱寻找回魔法卡。随后的故事，围绕着小樱寻找和收服库洛牌的经历而发展。在库洛牌收服完后，通过了身为审判者的月之考验，成为库洛牌的新主人。一天一位神秘的转校生柊泽出现，他引发不可思议的事件，让小樱将库洛牌转换为小樱卡，也避免了库洛牌魔力流失的危机。\n\n动画分上下两篇：\n库洛牌篇1998年4月7日－1999年6月22日，全46话（35话+11话）\n樱之卡篇1999年9月7日－2000年3月21日，全24话","date":"1998-04-07","objectID":"/anime/cardcaptor_sakura/","tags":null,"title":"魔卡少女樱","uri":"/anime/cardcaptor_sakura/"},{"categories":null,"content":"简介 故事讲述10岁的木之本樱打开了她父亲所藏的魔法书，意外把有魔法力量的“库洛牌”释放。由于她把卡弄失，要负责寻回，于是看守库洛牌守护兽可鲁贝洛斯，便给予小樱封印之杖，任命她为“库洛魔法使”，陪同并帮助小樱寻找回魔法卡。随后的故事，围绕着小樱寻找和收服库洛牌的经历而发展。在库洛牌收服完后，通过了身为审判者的月之考验，成为库洛牌的新主人。一天一位神秘的转校生柊泽出现，他引发不可思议的事件，让小樱将库洛牌转换为小樱卡，也避免了库洛牌魔力流失的危机。 动画分上下两篇： 库洛牌篇1998年4月7日－1999年6月22日，全46话（35话+11话） 樱之卡篇1999年9月7日－2000年3月21日，全","date":"1998-04-07","objectID":"/anime/cardcaptor_sakura/:1:0","tags":null,"title":"魔卡少女樱","uri":"/anime/cardcaptor_sakura/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 木之本樱 初代萌王、木之本 桜、きのもと さくら、Kinomoto Sakura、小樱 女 丹下桜 2 李小狼 王小明、李小狼、Li Syaoran 男 くまいもとこ 3 大道寺知世 だいどうじ ともよ、Daidouji Tomoyo 女 岩男潤子 4 可鲁贝洛斯 小可、Cerberus、ケルベロス、KERO、ケロ 男 久川綾 5 月 月、Yue 緒方恵美 6 佐佐木利佳 ささき りか、SASAKI RIKA 女 川上とも子 7 木之本抚子 天宫抚子、雨宫抚子、雨宮撫子、きのもと なでしこ、KINOMOTO NADESHIKO 女 皆口裕子 8 李莓铃 リ・","date":"1998-04-07","objectID":"/anime/cardcaptor_sakura/:2:0","tags":null,"title":"魔卡少女樱","uri":"/anime/cardcaptor_sakura/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔卡少女樱 1998-04-07 70 bilibili 2 魔卡少女樱 透明牌篇 2018-01-07 22 bilibili ","date":"1998-04-07","objectID":"/anime/cardcaptor_sakura/:3:0","tags":null,"title":"魔卡少女樱","uri":"/anime/cardcaptor_sakura/"},{"categories":null,"content":"MAD ","date":"1998-04-07","objectID":"/anime/cardcaptor_sakura/:4:0","tags":null,"title":"魔卡少女樱","uri":"/anime/cardcaptor_sakura/"},{"categories":null,"content":"武藤游戏是童实野高中的一名普通学生，除了喜欢玩各种游戏外没有任何优点，运动神经也不好，除了青梅竹马的真崎杏子外没有任何朋友。经常自己一个人玩的游戏其实心里很想要有朋友。\n\n游戏认为只要拼好爷爷武藤双六给自己的古埃及宝物千年积木并对它许愿，愿望就会成真，在这八年中游戏总是无法拼好了这个神秘的宝物。\n\n以某件事为契机，游戏和班里的城之内克也结下了深厚的友谊，也在这件事中游戏成功地完成了千年积木。在千年积木的力量下，游戏得到了另一个黑暗的人格，继承了三千年来所有游戏知识，成为使用“黑暗游戏”来制裁各种行恶之人的正义使者。","date":"1998-04-04","objectID":"/anime/yu_gi_oh/","tags":null,"title":"游戏王","uri":"/anime/yu_gi_oh/"},{"categories":null,"content":"简介 武藤游戏是童实野高中的一名普通学生，除了喜欢玩各种游戏外没有任何优点，运动神经也不好，除了青梅竹马的真崎杏子外没有任何朋友。经常自己一个人玩的游戏其实心里很想要有朋友。 游戏认为只要拼好爷爷武藤双六给自己的古埃及宝物千年积木并对它许愿，愿望就会成真，在这八年中游戏总是无法拼好了这个神秘的宝物。 以某件事为契机，游戏和班里的城之内克也结下了深厚的友谊，也在这件事中游戏成功地完成了千年积木。在千年积木的力量下，游戏得到了另一个黑暗的人格，继承了三千年来所有游戏知识，成为使用“黑暗游戏”来制裁各种行恶之人的正义使者。 制作人员： 原作：高桥和希 导演：角铜博之 脚本：千叶克彦、小林靖子、金卷兼","date":"1998-04-04","objectID":"/anime/yu_gi_oh/:1:0","tags":null,"title":"游戏王","uri":"/anime/yu_gi_oh/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 暗游戏 / 亚图姆 Yami Yugi / Atem、やみゆうぎ / アテム、Yami Yugi / Atemu、王样 男 緒方恵美 2 本田广 本田ヒロト、ほんだ ヒロト、Honda Hiroto 男 置鮎龍太郎 3 城之内克也 Joey Wheeler、城之内 克也、じょうのうち かつや、Jōnouchi Katsuya、凡骨 男 森川智之 4 真崎杏子 真崎杏子、まざき あんず、Mazaki Anzu 女 かかずゆみ 5 武藤游戏 表游戏、海星、むとうゆうぎ、Mutou Yuugi、Aibo 男 緒方恵美 6 海马濑人 AB社长、海馬瀨人、かいば せと","date":"1998-04-04","objectID":"/anime/yu_gi_oh/:2:0","tags":null,"title":"游戏王","uri":"/anime/yu_gi_oh/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 游戏王 1998-04-04 27 bilibili 2 游戏王－怪兽之决斗 2000-04-18 224 bilibili 3 游戏王－怪兽之决斗GX 2004-10-06 180 bilibili 4 游戏王5D’s 2008-04-02 154 bilibili ","date":"1998-04-04","objectID":"/anime/yu_gi_oh/:3:0","tags":null,"title":"游戏王","uri":"/anime/yu_gi_oh/"},{"categories":null,"content":"MAD ","date":"1998-04-04","objectID":"/anime/yu_gi_oh/:4:0","tags":null,"title":"游戏王","uri":"/anime/yu_gi_oh/"},{"categories":null,"content":"雾越未麻是流行音乐偶像团体“CHAM!”中的成员之一，但是在公司的决策下，她开始转型为演员。但她却感觉内心有个声音在拒绝自己的选择，而未麻的一些歌迷也反对这个决定。随着越来越多电视剧的演出，未麻却觉得自己的头脑越来越奇怪，仿佛有“另一个自己”正在形成。这时，她身边的工作人员竟一个个接连被杀。在面对社会压力和疑云之际，未麻感到越来越混乱…","date":"1998-02-28","objectID":"/anime/perfect_blue/","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"简介 雾越未麻是流行音乐偶像团体“CHAM!”中的成员之一，但是在公司的决策下，她开始转型为演员。但她却感觉内心有个声音在拒绝自己的选择，而未麻的一些歌迷也反对这个决定。随着越来越多电视剧的演出，未麻却觉得自己的头脑越来越奇怪，仿佛有“另一个自己”正在形成。这时，她身边的工作人员竟一个个接连被杀。在面对社会压力和疑云之际，未麻感到越来越混乱… 制作人员： 原作：竹内义和 导演：今敏 脚本：村井贞之 演出：松尾衡 音乐：几见雅博 人物原案：江口寿史 人物设定：滨洲英喜 ","date":"1998-02-28","objectID":"/anime/perfect_blue/:1:0","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雾越未麻 霧越未麻、Kirigoe Mima 女 岩男潤子 2 内田 Uchida、うちだ 男 大倉正章 3 留美 Rumi、るみ 女 松本梨香 ","date":"1998-02-28","objectID":"/anime/perfect_blue/:2:0","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 蓝色恐惧 1998-02-28 01:21:44 樱花 ","date":"1998-02-28","objectID":"/anime/perfect_blue/:3:0","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"MAD ","date":"1998-02-28","objectID":"/anime/perfect_blue/:4:0","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"大和王权时期蝦夷族末代王子阿席达卡，在保卫他的村庄时被一恶魔诅咒受不治创伤。村里的巫婆劝他前往西方，寻找恶魔的来源和解除诅咒的方法。在他的旅途中，他來到山獸神森林，认识了被称为“魔法公主”的、由犬神抚养大的小桑。\n\n在這個過程中，阿席達卡发现恶魔本来是一个山猪神，但体内中了一颗铁弹后，对人类憎恨无比，变成了恶魔。铁弹是工業之城達達拉的統治者幻姬领导的穷人在铁城里制造的，为了保护自己不被贪心的封建贵族吞并，幻姬使用火器和铁弹作为武器，而为了制造火器和铁弹，她又必须从大自然中开发木头和铁矿石，由此与原始森林中的兽神交恶。\n\n阿席达卡试图在双方调停，但却越来越深地被牵入了这场冲突。","date":"1997-07-12","objectID":"/anime/princess_mononoke/","tags":null,"title":"幽灵公主","uri":"/anime/princess_mononoke/"},{"categories":null,"content":"简介 大和王权时期蝦夷族末代王子阿席达卡，在保卫他的村庄时被一恶魔诅咒受不治创伤。村里的巫婆劝他前往西方，寻找恶魔的来源和解除诅咒的方法。在他的旅途中，他來到山獸神森林，认识了被称为“魔法公主”的、由犬神抚养大的小桑。 在這個過程中，阿席達卡发现恶魔本来是一个山猪神，但体内中了一颗铁弹后，对人类憎恨无比，变成了恶魔。铁弹是工業之城達達拉的統治者幻姬领导的穷人在铁城里制造的，为了保护自己不被贪心的封建贵族吞并，幻姬使用火器和铁弹作为武器，而为了制造火器和铁弹，她又必须从大自然中开发木头和铁矿石，由此与原始森林中的兽神交恶。 阿席达卡试图在双方调停，但却越来越深地被牵入了这场冲突。 制作人员： 原","date":"1997-07-12","objectID":"/anime/princess_mononoke/:1:0","tags":null,"title":"幽灵公主","uri":"/anime/princess_mononoke/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿席达卡 アシタカヒコ、Ashitaka、アシタカ、Ashitaka 男 松田洋治 2 珊 サン、San、幽灵公主 女 石田ゆり子 3 エボシ エボシ、Eboshi 女 田中裕子 4 乙事主 おっことぬし、Okkotonushi、乙事主 森繁久彌 5 甲六 Kouroku、甲六 男 西村雅彦 6 トキ トキ、Toki 女 島本須美 7 山兽神 シシ神、Shishigami ","date":"1997-07-12","objectID":"/anime/princess_mononoke/:2:0","tags":null,"title":"幽灵公主","uri":"/anime/princess_mononoke/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 幽灵公主 1997-07-12 1 樱花 ","date":"1997-07-12","objectID":"/anime/princess_mononoke/:3:0","tags":null,"title":"幽灵公主","uri":"/anime/princess_mononoke/"},{"categories":null,"content":"　　其內容主要描寫中國四川省的年輕廚師劉昴星（マオ，外號阿昴，台灣譯為小當家）學習廚藝，到廣州陽泉酒家修行，獲得特級廚師（漫畫中虛構的中國料理界的最高地位）資格，因為主角堅持一個信念－－料理是為人們帶來幸福的。結交許多對於廚藝有志一同的朋友，及最後與「黑暗料理界」（裏料理界）對抗過程的冒險歷程。\n\n漫畫（第1集～第17集完）、動畫有第1話～第52話，動畫的故事至此尚未完結，因為「傳說中的廚具」尚未取得，且尚沒有和黑暗料理界進行最後決戰，後續的劇情因動畫追上漫畫連載而就此打住。","date":"1997-04-27","objectID":"/anime/chuka_ichiban/","tags":null,"title":"中华小当家","uri":"/anime/chuka_ichiban/"},{"categories":null,"content":"简介 其內容主要描寫中國四川省的年輕廚師劉昴星（マオ，外號阿昴，台灣譯為小當家）學習廚藝，到廣州陽泉酒家修行，獲得特級廚師（漫畫中虛構的中國料理界的最高地位）資格，因為主角堅持一個信念－－料理是為人們帶來幸福的。結交許多對於廚藝有志一同的朋友，及最後與「黑暗料理界」（裏料理界）對抗過程的冒險歷程。 漫畫（第1集～第17集完）、動畫有第1話～第52話，動畫的故事至此尚未完結，因為「傳說中的廚具」尚未取得，且尚沒有和黑暗料理界進行最後決戰，後續的劇情因動畫追上漫畫連載而就此打住。 制作人员： 原作：小川悦司 导演：案纳正美 脚本：岸间信明、菅良幸、户田博史 分镜：西田健一、高村彰、渊上真、高木淳 ","date":"1997-04-27","objectID":"/anime/chuka_ichiban/:1:0","tags":null,"title":"中华小当家","uri":"/anime/chuka_ichiban/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 刘昴星 小当家、Liu Maoxing、リュウ・マオシン、マオ 男 田中真弓 2 周梅丽 梅丽、赵梅丽、赵美莉、嘟嘟、チョウ・メイリィ 女 ゆきのさつき 3 兰飞鸿 阿飞、Lan Fei Hong、ラン・フェイフォン、フェイ 男 置鮎龍太郎 4 四郎 シロウ、Shiro 男 坂本千夏 5 解鲁 鋼棍のシェル 男 家中宏 6 雷恩 七星刀のレオン 男 野田順子 7 周瑜 チョウユ 男 大塚明夫 8 罗鋈 ルオウ 男 石森達幸 ","date":"1997-04-27","objectID":"/anime/chuka_ichiban/:2:0","tags":null,"title":"中华小当家","uri":"/anime/chuka_ichiban/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 中华小当家 1997-04-27 52 樱花 ","date":"1997-04-27","objectID":"/anime/chuka_ichiban/:3:0","tags":null,"title":"中华小当家","uri":"/anime/chuka_ichiban/"},{"categories":null,"content":"天上欧蒂娜是一位穿着男生制服的性格少女。年幼时为一位王子所救，由于心怀憧憬而期望自己能成为王子。\n入读凤学园之后，欧蒂娜因为特立独行的作风而受到校方责难，但同时也成为了众人目光的焦点。这样的欧蒂娜遇到了被称为“蔷薇的新娘”的柔弱少女姬宫安希，同情安希的遭遇而决定保护她的欧蒂娜，被卷入了学生会争夺“改革世界的力量”的一系列决斗中，向“世界的尽头”发起挑战。\n\n少女革命的原作是以幾原邦彦为首的原创团队ビーパパス（Bepapas），团队成员包括榎户洋司、さいとうちほ(斋藤千穗)、長谷川眞也、小黒祐一郎等人。有些人以为由斋藤千穗执笔的漫画是《少女革命》的原作，这其实是误解，实际上少女漫画家出身的斋藤与幾原就《少女革命》的主题意见相左，这一点在漫画版《少女革命》中亦有所体现。而《少女革命》的TV动画由于其隐晦深刻的内涵和独特的世界观而与EVA、机动战舰并称为OTAKU三大经典。","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"简介 天上欧蒂娜是一位穿着男生制服的性格少女。年幼时为一位王子所救，由于心怀憧憬而期望自己能成为王子。 入读凤学园之后，欧蒂娜因为特立独行的作风而受到校方责难，但同时也成为了众人目光的焦点。这样的欧蒂娜遇到了被称为“蔷薇的新娘”的柔弱少女姬宫安希，同情安希的遭遇而决定保护她的欧蒂娜，被卷入了学生会争夺“改革世界的力量”的一系列决斗中，向“世界的尽头”发起挑战。 少女革命的原作是以幾原邦彦为首的原创团队ビーパパス（Bepapas），团队成员包括榎户洋司、さいとうちほ(斋藤千穗)、長谷川眞也、小黒祐一郎等人。有些人以为由斋藤千穗执笔的漫画是《少女革命》的原作，这其实是误解，实际上少女漫画家出身的斋","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/:1:0","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天上欧蒂娜 天上萼、Tenjou Utena 女 川上とも子 2 姬宫安希 姬宫安诗、Himemiya Anthy、ひめみや アンシー、Himemiya Anshii 女 渕崎ゆり子 3 桐生冬芽 桐生冬芽、きりゅう　とうが、Kiryuu Touga 男 子安武人 4 有栖川树璃 有栖川樹璃、ありすがわ　じゅり、Arisugawa Juri 女 三石琴乃 5 薰干 かおる みき、Kaoru Miki、ミッキー 男 久川綾 6 西园寺荚一 さいおんじ きょういち、Saionji Kyoichi 男 草尾毅 7 桐生七实 きりゅう ななみ、Kiryuu Nana","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/:2:0","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 少女革命 1997-04-02 39 bilibili 2 少女革命剧场版 思春期默示录 1999-08-14 1 bilibili ","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/:3:0","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"MAD ","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/:4:0","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"从宇宙的彼方Bratcher星而来的拥有黑暗能源的三人组快速魔头号、黑暗使者号、马虎恶魔号到达地球，将能源附身于蒸汽机车之上获得了拥有自我意识且可以变身的机体，为了实现“把世界变成漆黑一片”（OVA是以征服地球为目标的恶作剧）的目的，决定首先要把日本作为中心展开他们的“黑暗大作战”。为了阻止这一野心，正义的铁胆火车侠从Hikarian行星追赶而来，把作为各自能源起源的电力与容易被采用的新干线铁道车辆相融合，也有靠引擎和蒸汽机关电力发电的登场人物（电车·铁路机车）存在。\n穿过路线之外时候的变形，各自在地球上的生活，铁胆火车侠与他们最大的敌人银色魔头号不断的进行战斗。地球人为了支援铁胆火车侠而开设了日本ヒカリアン鉄道（JHR）与铁道公司，平时处理着一些不是铁胆火车侠的新干线电车的旅客输送任务。","date":"1997-04-02","objectID":"/anime/hikarian/","tags":null,"title":"铁胆火车侠","uri":"/anime/hikarian/"},{"categories":null,"content":"简介 从宇宙的彼方Bratcher星而来的拥有黑暗能源的三人组快速魔头号、黑暗使者号、马虎恶魔号到达地球，将能源附身于蒸汽机车之上获得了拥有自我意识且可以变身的机体，为了实现“把世界变成漆黑一片”（OVA是以征服地球为目标的恶作剧）的目的，决定首先要把日本作为中心展开他们的“黑暗大作战”。为了阻止这一野心，正义的铁胆火车侠从Hikarian行星追赶而来，把作为各自能源起源的电力与容易被采用的新干线铁道车辆相融合，也有靠引擎和蒸汽机关电力发电的登场人物（电车·铁路机车）存在。 穿过路线之外时候的变形，各自在地球上的生活，铁胆火车侠与他们最大的敌人银色魔头号不断的进行战斗。地球人为了支援铁胆火车侠","date":"1997-04-02","objectID":"/anime/hikarian/:1:0","tags":null,"title":"铁胆火车侠","uri":"/anime/hikarian/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 铁胆火车侠 1997-04-02 156 bilibili ","date":"1997-04-02","objectID":"/anime/hikarian/:2:0","tags":null,"title":"铁胆火车侠","uri":"/anime/hikarian/"},{"categories":null,"content":"居住在《关都地区》《真新镇》的主人公小智十分热爱宝可梦。\n在十岁生日那天，小智被允许可以以宝可梦训练家的身份踏上旅程，但非常期待旅程到来的他却在出发当天早上睡过了头！\n虽然在出发的早上可以挑选同伴宝可梦，但留给小智的只剩下“皮卡丘”！而那皮卡丘也完全和小智熟络不起来，它不愿意进精灵球。虽然小智和皮卡丘之间的相处进行得不顺利，但以某件事为契机，他们终于相互承认对方是自己的同伴。\n他们从《关都地区》旅行到《橘子群岛》。然后小智与皮卡丘冒险之旅的舞台又转到《城都地区》。在经过与许多不同的人及宝可梦的不断邂逅与分离后，小智他们在激烈的宝可梦对战中不断成长。","date":"1997-04-01","objectID":"/anime/pokemon/","tags":null,"title":"精灵宝可梦","uri":"/anime/pokemon/"},{"categories":null,"content":"简介 居住在《关都地区》《真新镇》的主人公小智十分热爱宝可梦。 在十岁生日那天，小智被允许可以以宝可梦训练家的身份踏上旅程，但非常期待旅程到来的他却在出发当天早上睡过了头！ 虽然在出发的早上可以挑选同伴宝可梦，但留给小智的只剩下“皮卡丘”！而那皮卡丘也完全和小智熟络不起来，它不愿意进精灵球。虽然小智和皮卡丘之间的相处进行得不顺利，但以某件事为契机，他们终于相互承认对方是自己的同伴。 他们从《关都地区》旅行到《橘子群岛》。然后小智与皮卡丘冒险之旅的舞台又转到《城都地区》。在经过与许多不同的人及宝可梦的不断邂逅与分离后，小智他们在激烈的宝可梦对战中不断成长。 制作人员： 原作：Game Freak","date":"1997-04-01","objectID":"/anime/pokemon/:1:0","tags":null,"title":"精灵宝可梦","uri":"/anime/pokemon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小智的皮卡丘 小智的比卡超、Ash’s Pikachu、皮神 雄性 大谷育江 2 小智 Ash Ketchum、Satoshi、Sacha Ketchum、Ash Ketchum、Ash Ketchum、Ash Ketchum、한지우、Ali / Satoshi、ซาโตชิ 男 松本梨香 3 小霞 Misty、Kasumi 飯塚雅弓 4 小茂 오바람 O Baram、Régis Chen、大木茂、Gary Oak、Ōkido Shigeru、绿 男 5 小刚 Brock、Takeshi 男 うえだゆうじ 6 小建 Tracey Sketchit、Kenji","date":"1997-04-01","objectID":"/anime/pokemon/:2:0","tags":null,"title":"精灵宝可梦","uri":"/anime/pokemon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 精灵宝可梦 1997-04-01 276 bilibili 2 精灵宝可梦 超世代 2002-11-21 192 bilibili 3 精灵宝可梦 钻石\u0026珍珠 2006-09-28 191 bilibili 4 精灵宝可梦 超级愿望 2010-09-23 144 bilibili 5 精灵宝可梦XY 2013-10-17 141 bilibili 6 精灵宝可梦 太阳\u0026月亮 2016-11-17 146 bilibili ","date":"1997-04-01","objectID":"/anime/pokemon/:3:0","tags":null,"title":"精灵宝可梦","uri":"/anime/pokemon/"},{"categories":null,"content":"MAD ","date":"1997-04-01","objectID":"/anime/pokemon/:4:0","tags":null,"title":"精灵宝可梦","uri":"/anime/pokemon/"},{"categories":null,"content":"一个在学校教书的普通老师，常常生出些古古怪怪的想法，教些莫名其妙的东西。\n身体之所以会感受到温暖，是因为原子感受到了春的味道，从窗户里跳出去，感受春天吧。\n你们看这些石头，像不像一个个人，我们甚至能与之对谈，不信么，用锤子敲一下试试，叮叮咚咚，真的，每一块都不一样。\n尤其是那喵的一声，让人误会这是个温暖的小品。","date":"1996-12-14","objectID":"/anime/spring_and_chaos/","tags":null,"title":"贤治之春","uri":"/anime/spring_and_chaos/"},{"categories":null,"content":"简介 一个在学校教书的普通老师，常常生出些古古怪怪的想法，教些莫名其妙的东西。 身体之所以会感受到温暖，是因为原子感受到了春的味道，从窗户里跳出去，感受春天吧。 你们看这些石头，像不像一个个人，我们甚至能与之对谈，不信么，用锤子敲一下试试，叮叮咚咚，真的，每一块都不一样。 尤其是那喵的一声，让人误会这是个温暖的小品。 制作人员： 导演：河森正治 演出：佐藤英一 音乐：上上台风 人物设定：岸田隆宏 美术监督：大野广司 色彩设计：一濑美代子 摄影监督：野口肇 ","date":"1996-12-14","objectID":"/anime/spring_and_chaos/:1:0","tags":null,"title":"贤治之春","uri":"/anime/spring_and_chaos/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 贤治之春 1996-12-14 00:56:07 bilibili ","date":"1996-12-14","objectID":"/anime/spring_and_chaos/:2:0","tags":null,"title":"贤治之春","uri":"/anime/spring_and_chaos/"},{"categories":null,"content":"配乐 ","date":"1996-12-14","objectID":"/anime/spring_and_chaos/:3:0","tags":null,"title":"贤治之春","uri":"/anime/spring_and_chaos/"},{"categories":null,"content":"一共52集动画。由美国方面制作推出，采取革命性的3D动画模式，日本版本为美版的配音输出版本。美版动画将其划分为第一季26集（SEASON 1），第二季13集（SEASON 2），第三季13集（SEASON 3）。日版动画则把第二季和第三季一共26集称为“BEASWT WARS METALS”。国内引进时全部一起播出，翻译为“超能勇士”。\n　　汽车人后代巨无霸（港译：密斯姆）与霸天虎后代原始兽（港译：巴达乾）继续战斗着。巨无霸领袖黑猩猩（港译：奥迪武）率领分队追击原始兽的霸王龙（港译：麦卡顿），双方穿梭时空来到史前地球并坠毁在地球上。为了抵御地球的能量乾扰，他们都使自己变形为野兽，开始了一场野兽战争BEAST WARS。双方在地球上陆续发现外星人的机关，在与外星人较量中，部分变形金刚转化为恒定的金属变体（TRANS METALS），战斗异常激烈。霸王龙发现古老的战舰方舟号，并试图摧毁未苏醒的擎天柱而改变历史。黑猩猩在对战中吸收了擎天柱的力量而进化为TRANS METAL 2，霸王龙也通过吸收威震天的力量而进化成红色火龙。外星人介入，但被消灭。霸王龙最后找到了霸天虎的古老战舰报应号，并试图驾驶它摧毁方舟。最后报应号被击落，霸王龙被抓获，巨无霸返回塞伯坦　　 ","date":"1996-09-16","objectID":"/anime/beast_wars/","tags":null,"title":"超能勇士","uri":"/anime/beast_wars/"},{"categories":null,"content":"简介 一共52集动画。由美国方面制作推出，采取革命性的3D动画模式，日本版本为美版的配音输出版本。美版动画将其划分为第一季26集（SEASON 1），第二季13集（SEASON 2），第三季13集（SEASON 3）。日版动画则把第二季和第三季一共26集称为“BEASWT WARS METALS”。国内引进时全部一起播出，翻译为“超能勇士”。 汽车人后代巨无霸（港译：密斯姆）与霸天虎后代原始兽（港译：巴达乾）继续战斗着。巨无霸领袖黑猩猩（港译：奥迪武）率领分队追击原始兽的霸王龙（港译：麦卡顿），双方穿梭时空来到史前地球并坠毁在地球上。为了抵御地球的能量乾扰，他们都使自己变形为野兽，开始了一场野","date":"1996-09-16","objectID":"/anime/beast_wars/:1:0","tags":null,"title":"超能勇士","uri":"/anime/beast_wars/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 Airazor 女 2 擎天柱 柯柏文、柯博文 男 ","date":"1996-09-16","objectID":"/anime/beast_wars/:2:0","tags":null,"title":"超能勇士","uri":"/anime/beast_wars/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 超能勇士 1996-09-16 52 bilibili 2 猛兽侠 1999-09-18 26 bilibili ","date":"1996-09-16","objectID":"/anime/beast_wars/:3:0","tags":null,"title":"超能勇士","uri":"/anime/beast_wars/"},{"categories":null,"content":"主角工藤新一原本是一位颇具名声的高中生侦探，在目击黑暗组织的地下交易后，正准备追踪时却被突袭击昏，并被灌下代号为“APTX4869”（アポトキシン4869）的不明药物。后来虽然幸免于死，但身体就此缩小为小学时期的模样。之后他化名为江户川柯南，在邻居阿笠博士的建议下，寄住在女友毛利兰的父亲—侦探毛利小五郎家中，继续秘密从事追查黑暗组织的工作，并私下探寻获得解药的管道，希望能够恢复原来新一的样貌。与此同时，柯南凭着自己的推理天份，配合阿笠博士为他发明的道具，帮助毛利小五郎成为出名的大侦探。故事内容当中穿插许多爱情、友情、犯罪、背叛、复仇等情节。","date":"1996-01-08","objectID":"/anime/conan/","tags":null,"title":"名侦探柯南","uri":"/anime/conan/"},{"categories":null,"content":"简介 主角工藤新一原本是一位颇具名声的高中生侦探，在目击黑暗组织的地下交易后，正准备追踪时却被突袭击昏，并被灌下代号为“APTX4869”（アポトキシン4869）的不明药物。后来虽然幸免于死，但身体就此缩小为小学时期的模样。之后他化名为江户川柯南，在邻居阿笠博士的建议下，寄住在女友毛利兰的父亲—侦探毛利小五郎家中，继续秘密从事追查黑暗组织的工作，并私下探寻获得解药的管道，希望能够恢复原来新一的样貌。与此同时，柯南凭着自己的推理天份，配合阿笠博士为他发明的道具，帮助毛利小五郎成为出名的大侦探。故事内容当中穿插许多爱情、友情、犯罪、背叛、复仇等情节。 制作人员： 原作：青山刚昌 导演：佐藤真人、镰","date":"1996-01-08","objectID":"/anime/conan/:1:0","tags":null,"title":"名侦探柯南","uri":"/anime/conan/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 江户川柯南 バーロー、江戸川コナン、えどがわこなん、Edogawa Conan、柯南 男 高山みなみ 2 工藤新一 Jimmy Kudo、くどう しんいち、Kudou Shinichi、滚筒洗衣机 男 山口勝平 3 毛利兰 Rachel Moore、毛利蘭、もうり らん、Mouri Ran 女 山崎和佳奈 4 毛利小五郎 Richard Moore、毛利小五郎、Mouri Kogoro 男 小山力也 5 阿笠博士 ハーシェル・アガサ、Hershel Agasa、あがさ ひろし、Agasa Hiroshi、阿笠博士 男 緒方賢一 6 灰原哀 灰原哀、はいばら ","date":"1996-01-08","objectID":"/anime/conan/:2:0","tags":null,"title":"名侦探柯南","uri":"/anime/conan/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 名侦探柯南 1996-01-08 bilibili ","date":"1996-01-08","objectID":"/anime/conan/:3:0","tags":null,"title":"名侦探柯南","uri":"/anime/conan/"},{"categories":null,"content":"MAD ","date":"1996-01-08","objectID":"/anime/conan/:4:0","tags":null,"title":"名侦探柯南","uri":"/anime/conan/"},{"categories":null,"content":"小烈和小豪是模型四驱车的爱好者，小小年纪的他们已经懂得了很多模型四驱车的知识，加上有模型四驱车专家土屋博士的帮助，他们的四驱车已经在各种比赛中屡屡获奖。然而，最近突然出现了一些极具毁灭性的赛车，它们不仅拥有绝对的速度优势，而且能将对手的四驱车压得粉碎！原来，这是邪恶的大神博士研发的新一代的四驱车。为了捍卫荣誉，打败大神博士的车队，小烈和小豪开始对他们的四驱车开始进行彻底改造！","date":"1996-01-08","objectID":"/anime/bakusou_kyoudai/","tags":null,"title":"四驱兄弟","uri":"/anime/bakusou_kyoudai/"},{"categories":null,"content":"简介 小烈和小豪是模型四驱车的爱好者，小小年纪的他们已经懂得了很多模型四驱车的知识，加上有模型四驱车专家土屋博士的帮助，他们的四驱车已经在各种比赛中屡屡获奖。然而，最近突然出现了一些极具毁灭性的赛车，它们不仅拥有绝对的速度优势，而且能将对手的四驱车压得粉碎！原来，这是邪恶的大神博士研发的新一代的四驱车。为了捍卫荣誉，打败大神博士的车队，小烈和小豪开始对他们的四驱车开始进行彻底改造！ 制作人员： 原作：越田哲弘 导演：网野哲郎 脚本：星山博之、隅泽克之、千叶克彦 分镜：铃木吉男、白旗伸朗、星合贵彦、井上修 ","date":"1996-01-08","objectID":"/anime/bakusou_kyoudai/:1:0","tags":null,"title":"四驱兄弟","uri":"/anime/bakusou_kyoudai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 星马豪 せいば ゴー、Seiba Go 男 池澤春菜 2 星马烈 せいば レツ、seiba retsu 男 渕崎ゆり子 3 鹰羽龙 たかば リョウ、Takaba Ryo 男 高乃麗 4 土方令 hijikata rei 男 木藤聡子 5 阿吉 J、ジェイ 男 渡辺久美子 6 三国藤吉 みくに とうきち、Mikuni Toukichi 男 神代知衣 7 鹰羽二郎丸 たかば じろうまる、takaba jiroumaru 男 大谷育江 8 土屋博士 つちやはかせ、TSUCHIYAHAKASE、乔布斯·土屋 男 江原正士 ","date":"1996-01-08","objectID":"/anime/bakusou_kyoudai/:2:0","tags":null,"title":"四驱兄弟","uri":"/anime/bakusou_kyoudai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 四驱兄弟 1996-01-08 51 bilibili 2 四驱兄弟WGP 1997-01-06 51 bilibili ","date":"1996-01-08","objectID":"/anime/bakusou_kyoudai/:3:0","tags":null,"title":"四驱兄弟","uri":"/anime/bakusou_kyoudai/"},{"categories":null,"content":"本片由三段互无关联的故事组成。《她的回忆》：2092年，由伊瓦诺夫领导的太空垃圾回收飞船在返航途中接收到来自“宇宙坟场”的求救信号，特殊的是，信号中掺杂着歌剧《蝴蝶夫人》的唱段。队员汉兹与米格尔前往施救，却进入了一位歌剧演员艾娃的回忆，这些栩栩如生的回忆场景对船员们产生了威胁；《最臭兵器》：供职于制药公司的小职员田中信男拖着病体赶回公司，无意中服用了公司与军方合作的实验药品。自此信男成为了制造致命臭气的肉身工厂，对此毫不自知的信男却按照上司命令将药品样本送往东京总部，一路上引起大面积恐慌，军方不得不派出大批军队半路截杀信男；《大炮之街》：在一座由蒸汽驱动的城市中，一家三口展开了一天的生活。母亲去制造炮弹的工厂上班，父亲在炮台担任装填手，小儿子在学校里学习与大炮相关的知识。炮台不停开炮，但敌人的身影却始终没有出现……","date":"1995-12-23","objectID":"/anime/memories/","tags":null,"title":"回忆三部曲","uri":"/anime/memories/"},{"categories":null,"content":"简介 本片由三段互无关联的故事组成。《她的回忆》：2092年，由伊瓦诺夫领导的太空垃圾回收飞船在返航途中接收到来自“宇宙坟场”的求救信号，特殊的是，信号中掺杂着歌剧《蝴蝶夫人》的唱段。队员汉兹与米格尔前往施救，却进入了一位歌剧演员艾娃的回忆，这些栩栩如生的回忆场景对船员们产生了威胁；《最臭兵器》：供职于制药公司的小职员田中信男拖着病体赶回公司，无意中服用了公司与军方合作的实验药品。自此信男成为了制造致命臭气的肉身工厂，对此毫不自知的信男却按照上司命令将药品样本送往东京总部，一路上引起大面积恐慌，军方不得不派出大批军队半路截杀信男；《大炮之街》：在一座由蒸汽驱动的城市中，一家三口展开了一天的生活","date":"1995-12-23","objectID":"/anime/memories/:1:0","tags":null,"title":"回忆三部曲","uri":"/anime/memories/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 回忆三部曲 1995-12-23 01:53:25 bilibili ","date":"1995-12-23","objectID":"/anime/memories/:2:0","tags":null,"title":"回忆三部曲","uri":"/anime/memories/"},{"categories":null,"content":"       2029年，公安九课在市容很像香港的日本城市“新港市”中执行各种秘密任务。九课因为不顾正当程序的自作主张、强硬行事，往往与政府其他部门起冲突，例如负责外交的公安六课就与九课不合。另一方面，九课之中的重要人物，全身是义体的机械生化人草薙素子，对于自己的现状一直隐隐感到不满。有一天，公安九课因为一件外国政要的刺杀未遂案而开始追查神秘的黑客“傀儡师”。傀儡师能透过网络入侵人脑，植入虚拟记忆，再利用记忆被窜改的对象来达成目的。虽然九课的追查没有成功，藏有傀儡师的“灵魂”的机械生化人却自行来到九课。公安六课随后赶来将傀儡师绑走。草薙素子因为在事前就推测出六课的绑架行动而成功拦截傀儡师。这时发现原来傀儡师并不是人类，而是公安六课设计来非法操纵人类的电脑程式“2501计划”。2501计划在意外中产生自觉意识，决定逃出六课以求生存，并且要求和草薙素子的灵魂“融合”以求进一步发展。草薙素子最后在同事巴特的协助与掩护下完成融合并且脱离政府掌握，下落不明，其意识与整个网络融合。","date":"1995-11-18","objectID":"/anime/ghost_in_the_shell/","tags":null,"title":"攻壳机动队","uri":"/anime/ghost_in_the_shell/"},{"categories":null,"content":"简介 2029年，公安九课在市容很像香港的日本城市“新港市”中执行各种秘密任务。九课因为不顾正当程序的自作主张、强硬行事，往往与政府其他部门起冲突，例如负责外交的公安六课就与九课不合。另一方面，九课之中的重要人物，全身是义体的机械生化人草薙素子，对于自己的现状一直隐隐感到不满。有一天，公安九课因为一件外国政要的刺杀未遂案而开始追查神秘的黑客“傀儡师”。傀儡师能透过网络入侵人脑，植入虚拟记忆，再利用记忆被窜改的对象来达成目的。虽然九课的追查没有成功，藏有傀儡师的“灵魂”的机械生化人却自行来到九课。公安六课随后赶来将傀儡师绑走。草薙素子因为在事前就推测出六课的绑架行动而成功拦截傀儡师。这时发现原来","date":"1995-11-18","objectID":"/anime/ghost_in_the_shell/:1:0","tags":null,"title":"攻壳机动队","uri":"/anime/ghost_in_the_shell/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 草薙素子 草薙素子、Kusanagi Motoko、くさなぎ もとこ 女 田中敦子 2 巴特 バトー、Batou 男 大塚明夫 3 公安9课 攻壳机动队、9课、Public Security Section 9、公安9課、Koan Kyuka 4 荒卷大辅 荒巻大輔、Aramaki Daisuke、猴子课长 男 大木民夫 5 陀古萨 户草、トグサ、Togusa 男 山寺宏一 6 石川 イシカワ、Ishikawa 男 仲野裕 7 傀儡师 不明 家弓家正 ","date":"1995-11-18","objectID":"/anime/ghost_in_the_shell/:2:0","tags":null,"title":"攻壳机动队","uri":"/anime/ghost_in_the_shell/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 攻壳机动队 1995-11-18 1 bilibili 2 攻壳机动队2 无罪 2004-03-06 1 bilibili ","date":"1995-11-18","objectID":"/anime/ghost_in_the_shell/:3:0","tags":null,"title":"攻壳机动队","uri":"/anime/ghost_in_the_shell/"},{"categories":null,"content":"MAD ","date":"1995-11-18","objectID":"/anime/ghost_in_the_shell/:4:0","tags":null,"title":"攻壳机动队","uri":"/anime/ghost_in_the_shell/"},{"categories":null,"content":"大江锦太郎，25岁，东京大学法学部中辍生，提前修完所有学分后主动退学。退学之后他便从事各种职业，动画6集换了6个职业，进行人生的学习。他骑着自己的爱车，在旅行兼职中与每个美少女的邂逅，其中发生的搞笑故事，今天也不断的向前迈进，而他或许是拯救日本，不…是拯救世界的人。每一集都为一个短篇故事，每篇也似乎极尽所能表现锦太郎的破坏力，但到最后他都会神奇地弥补了过错。","date":"1995-10-27","objectID":"/anime/golden_boy/","tags":null,"title":"黄金宝贝","uri":"/anime/golden_boy/"},{"categories":null,"content":"简介 大江锦太郎，25岁，东京大学法学部中辍生，提前修完所有学分后主动退学。退学之后他便从事各种职业，动画6集换了6个职业，进行人生的学习。他骑着自己的爱车，在旅行兼职中与每个美少女的邂逅，其中发生的搞笑故事，今天也不断的向前迈进，而他或许是拯救日本，不…是拯救世界的人。每一集都为一个短篇故事，每篇也似乎极尽所能表现锦太郎的破坏力，但到最后他都会神奇地弥补了过错。 制作人员： 原作：江川达也 导演：北久保弘之 分镜：森田宏幸、本猪木浩明、菊地康仁 演出：西山明树彦 ","date":"1995-10-27","objectID":"/anime/golden_boy/:1:0","tags":null,"title":"黄金宝贝","uri":"/anime/golden_boy/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 大江锦太郎 男 岩田光央 2 女社长 女 鶴ひろみ 3 胜田奈绪子 女 皆口裕子 4 纪子 白鳥由里 5 速水鲇子 女 井上喜久子 6 寺山丽子 女 玉川砂記子 7 知绘 女 かないみか 8 神崎裕香 女 小山裕香 ","date":"1995-10-27","objectID":"/anime/golden_boy/:2:0","tags":null,"title":"黄金宝贝","uri":"/anime/golden_boy/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 黄金宝贝 1995-10-27 6 樱花 ","date":"1995-10-27","objectID":"/anime/golden_boy/:3:0","tags":null,"title":"黄金宝贝","uri":"/anime/golden_boy/"},{"categories":null,"content":"　　2000年，一个科学探险队在南极洲针对被称作“第一使徒”亚当的“光之巨人”进行探险。在对其进行接触实验时，“光之巨人”自毁，从而发生了“第二次冲击”，进而导致世界大战。最后，人类人口减半，地轴偏转、气候改变。根据对“第二次冲击”的调查，联合国在日本箱根成立人工进化研究所（即 GEHIRN）从事EVA（指机器人）的发展研究，后GEHIRN利用在人工进化研究所下方发现的巨大空洞建造了总部。\n另一方面，联合国下属秘密组织SEELE为了使人类进化，开始实行人类补完计划，就是将所有人的灵魂汇集在一起，通过中和每个人的AT力场，使每个人回归LCL之海。\n2004年，EVA初号机进行启动试验时发生事故，碇真嗣的母亲碇唯消失，碇源渡开始执行“碇源渡版本的人类补完计划”。2010年，GEHIRN被改建成NERV。\n2015年开始，根据SEELE人类补完计划剧本的安排，一种巨型人形生物“使徒”开始在日本登陆，并向NERV总部进攻，NERV组织EVA消灭使徒。在NERV与使徒作战的同时，碇源渡秘密地执行它自己的计划。随着时间推移，碇源渡的计划逐渐被SEELE发现，NERV与SEELE产生了矛盾并不断恶化。\nDirector's Cut版本的第21～24集由剧场版《Death》篇剪辑而成，收录在20周年纪念版的蓝光中。","date":"1995-10-04","objectID":"/anime/evangelion/","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"简介 2000年，一个科学探险队在南极洲针对被称作“第一使徒”亚当的“光之巨人”进行探险。在对其进行接触实验时，“光之巨人”自毁，从而发生了“第二次冲击”，进而导致世界大战。最后，人类人口减半，地轴偏转、气候改变。根据对“第二次冲击”的调查，联合国在日本箱根成立人工进化研究所（即 GEHIRN）从事EVA（指机器人）的发展研究，后GEHIRN利用在人工进化研究所下方发现的巨大空洞建造了总部。 另一方面，联合国下属秘密组织SEELE为了使人类进化，开始实行人类补完计划，就是将所有人的灵魂汇集在一起，通过中和每个人的AT力场，使每个人回归LCL之海。 2004年，EVA初号机进行启动试验时发生事故","date":"1995-10-04","objectID":"/anime/evangelion/:1:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 碇真嗣 碇真治、いかり　しんじ、Ikari Shinji、笨蛋真嗣（バガシンジ），小鬼真嗣（ガキシンジ，剧场版Q） 男 緒方恵美 2 绫波丽 绫波零、あやなみ レイ、Ayanami Rei 女 林原めぐみ 3 惣流·明日香·兰格雷 Soryu Asuka Langley、そうりゅう・アスカ・ラングレー、Sōryū Asuka Rangurē、香香、式波・アスカ・ラングレー、式波·明日香·兰格雷、Shikinami Asuka Langley、しきなみ・アスカ・ラングレー、Shikinami Asuka Rangurē 女 宮村優子 4 葛城美里 葛城ミサト、","date":"1995-10-04","objectID":"/anime/evangelion/:2:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 新世纪福音战士 1995-10-04 26 bilibili 2 新世纪福音战士剧场版 死与新生 1997-03-15 2 bilibili 3 新世纪福音战士剧场版 Air/真心为你 1997-07-19 2 bilibili 4 福音战士新剧场版：序 2007-09-01 1 bilibili 5 福音战士新剧场版：破 2009-06-27 1 bilibili 6 福音战士新剧场版：Q 2012-11-17 1 bilibili 7 新・福音战士剧场版：终 2021-03-08 1 小兵看看 ","date":"1995-10-04","objectID":"/anime/evangelion/:3:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"配乐 ","date":"1995-10-04","objectID":"/anime/evangelion/:4:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"MAD ","date":"1995-10-04","objectID":"/anime/evangelion/:5:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"*同人 ","date":"1995-10-04","objectID":"/anime/evangelion/:6:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"在制作第一代游戏时之所以取名为《仙剑奇侠传》，姚壮宪解释是因为“仙”字代表像赵灵儿这样的人间仙女；\n“剑”代表江湖，代表武侠，也是代表李逍遥。但是觉得只有两个字不够，便继续取“奇”字，代表奇幻的元素，也是代表阿奴。\n“侠”便是侠义精神，最后加上后缀“传”字，于是就组成了《仙剑奇侠传》这一名称。\n初代暂以PAL作为“仙剑奇侠传”的英文缩写，源自于林坤信为姚壮宪作曲时所使用的目录名称“PAL”，意即“Paladin”\n（中文意为“骑士”、“游侠”等），并一直沿用至今。","date":"1995-07-07","objectID":"/game/xian_jian/","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"简介 在制作第一代游戏时之所以取名为《仙剑奇侠传》，姚壮宪解释是因为“仙”字代表像赵灵儿这样的人间仙女； “剑”代表江湖，代表武侠，也是代表李逍遥。但是觉得只有两个字不够，便继续取“奇”字，代表奇幻的元素，也是代表阿奴。 “侠”便是侠义精神，最后加上后缀“传”字，于是就组成了《仙剑奇侠传》这一名称。 初代暂以PAL作为“仙剑奇侠传”的英文缩写，源自于林坤信为姚壮宪作曲时所使用的目录名称“PAL”，意即“Paladin” （中文意为“骑士”、“游侠”等），并一直沿用至今。 制作人员： 开发：大宇资讯股份有限公司 遊戲設計師：姚壮宪 剧本：谢崇辉 音乐：林坤信 ","date":"1995-07-07","objectID":"/game/xian_jian/:1:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 李逍遥 一贫 男 2 赵灵儿 女 3 林月如 女 4 阿奴 海棠 女 5 酒剑仙 司徒钟 男 6 彩依 女 7 丁香兰 女 8 丁秀兰 女 ","date":"1995-07-07","objectID":"/game/xian_jian/:2:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"系列 系列名 发行时间 1 仙剑奇侠传 1995-07-07 2 新仙剑奇侠传 2001-07-21 3 仙剑奇侠传二 2003-01-23 4 仙剑奇侠传三 2003-07-31 5 仙剑奇侠传三外传·问情篇 2004-08-06 6 仙剑奇侠传四 2007-08-01 7 仙剑奇侠传五 2011-07-07 8 仙剑奇侠传五前传 2013-01-15 9 仙剑奇侠传六 2015-07-08 10 仙剑奇侠传七 2021-10-15 ","date":"1995-07-07","objectID":"/game/xian_jian/:3:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"配乐 ","date":"1995-07-07","objectID":"/game/xian_jian/:4:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"MAD ","date":"1995-07-07","objectID":"/game/xian_jian/:5:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"*同人 ","date":"1995-07-07","objectID":"/game/xian_jian/:6:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"很久很久以前……在原始的混沌之海中，从无边的黑暗中诞生了唯一一个纯真的意志……这个意志所产生的力量，让原本一片虛无的混沌之海发生变化。如造物主般分出了无数世界，这些世界是由无数石柱一般长杖支撑在混沌之海上。她，是这世间万物的母亲。因此，有了神、有了魔……也有了人类。神与魔不断地纷争，神为了保卫世界而战；魔为了争取长杖毀灭世界而战。造物主沉眠了……她被魔族奉为大王--金色魔王，也是帶來恶梦的魔王。在这个世界，赤眼魔王卢比埃和龙神史菲德为了各自的目的而战……龙神史菲德费劲心力将卢比埃击败，并将它分为七部份……但史菲德也累了，为了防范魔族的行动，他化为四个分身固守着四方。一千年前，魔王的一部份觉醒了。它率领着魔族们向史菲德的一個分身--水龙王挑战。魔王五个手下中的四个设下了结界，由它和魔龙王一起直接跟水龙王决斗。魔王的计划，宣告失败。卢比埃被打倒，魔龙王被封印。魔族的行动渐趋寂静……一千年后，一名天才美少女诞生了。她名叫莉娜·因巴斯（LinaInverse），和伙伴高里·布列夫（GourryGabriev）一起踏上旅程。但，魔族们仍不停止动作。它们期待着真正的王能回來，也就是--金色魔王，带来恶梦的魔王……","date":"1995-04-07","objectID":"/anime/slayers/","tags":null,"title":"秀逗魔导士","uri":"/anime/slayers/"},{"categories":null,"content":"简介 很久很久以前……在原始的混沌之海中，从无边的黑暗中诞生了唯一一个纯真的意志……这个意志所产生的力量，让原本一片虛无的混沌之海发生变化。如造物主般分出了无数世界，这些世界是由无数石柱一般长杖支撑在混沌之海上。她，是这世间万物的母亲。因此，有了神、有了魔……也有了人类。神与魔不断地纷争，神为了保卫世界而战；魔为了争取长杖毀灭世界而战。造物主沉眠了……她被魔族奉为大王–金色魔王，也是帶來恶梦的魔王。在这个世界，赤眼魔王卢比埃和龙神史菲德为了各自的目的而战……龙神史菲德费劲心力将卢比埃击败，并将它分为七部份……但史菲德也累了，为了防范魔族的行动，他化为四个分身固守着四方。一千年前，魔王的一部份觉","date":"1995-04-07","objectID":"/anime/slayers/:1:0","tags":null,"title":"秀逗魔导士","uri":"/anime/slayers/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 莉娜·因巴斯 Лина Инверс、Lina Inverse 女 林原めぐみ 2 高里·杰布列夫 Gourry Gabriev 男 松本保典 3 杰路刚帝士·克雷依威斯 Зелгадис Грейвардс、Zelgadiss Graywords 男 緑川光 4 加梅莉亚·威尔·迪斯拉·赛伦 Амелия Вил Тесла Сэйрун、Ameria Wil Tesla Saillune、Amelia Wil Tesla Seyruun 女 鈴木真仁 5 フィリオネル＝エル＝ディ＝セイルーン フィリオネル＝エル＝ディ＝セイルーン、Philionel El","date":"1995-04-07","objectID":"/anime/slayers/:2:0","tags":null,"title":"秀逗魔导士","uri":"/anime/slayers/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 秀逗魔导士 1995-04-07 26 bilibili 2 秀逗魔导士NEXT 1996-04-05 26 bilibili 3 秀逗魔导士TRY 1997-04-04 26 bilibili ","date":"1995-04-07","objectID":"/anime/slayers/:3:0","tags":null,"title":"秀逗魔导士","uri":"/anime/slayers/"},{"categories":null,"content":"63年后的未来世界由于人口过多，甚至订定了生2个小孩为死刑的法律。在这样的时代里被称为“超级花花公子（メガプレイボーイ”的男人拥有100人以上的小孩，而且其DNA被继承了下来。\n政府派出了“DNA操作者”葵华林（葵加玲）来到过去的时代，企图改变这个男人的DNA。然而这个男人桃生纯太却是个不受女性青睐、不可靠，离超级花花公子10万8千里的人。华林本来应该是依照预定达查成了任务，但却弄错了改写DNA的子弹（DCM弹），使得纯太开始出现觉醒为超级花花公子的征兆。","date":"1994-10-07","objectID":"/anime/dna2/","tags":null,"title":"再造基因","uri":"/anime/dna2/"},{"categories":null,"content":"简介 63年后的未来世界由于人口过多，甚至订定了生2个小孩为死刑的法律。在这样的时代里被称为“超级花花公子（メガプレイボーイ”的男人拥有100人以上的小孩，而且其DNA被继承了下来。 政府派出了“DNA操作者”葵华林（葵加玲）来到过去的时代，企图改变这个男人的DNA。然而这个男人桃生纯太却是个不受女性青睐、不可靠，离超级花花公子10万8千里的人。华林本来应该是依照预定达查成了任务，但却弄错了改写DNA的子弹（DCM弹），使得纯太开始出现觉醒为超级花花公子的征兆。 制作人员： 原作：桂正和 导演：坂田纯一 脚本：浦畑达彦 分镜：加濑充子、小寺胜之、阿部司、福富博、山内重保、菊池一仁 ","date":"1994-10-07","objectID":"/anime/dna2/:1:0","tags":null,"title":"再造基因","uri":"/anime/dna2/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 再造基因 1994-10-07 12 bilibili ","date":"1994-10-07","objectID":"/anime/dna2/:2:0","tags":null,"title":"再造基因","uri":"/anime/dna2/"},{"categories":null,"content":"辛巴是狮子王国的小王子，他的父亲穆法沙是一个威严的国王。然而叔叔刀疤却对穆法沙的王位觊觎已久。\n\n要想坐上王位宝座，刀疤必须除去小王子。于是，刀疤利用种种借口让辛巴外出，然后伺机大开杀戒，无奈被穆法沙即时来救。在反复的算计下，穆法沙惨死在刀疤手下，刀疤别有用心的劝辛巴离开，一方面派人将他赶尽杀绝。\n\n辛巴逃亡中遇到了机智的丁满和善良的彭彭，他们抚养辛巴长成雄壮的大狮子，鼓励他回去森林复国。在接下来一场复国救民的斗争中，辛巴真正长成一个坚强的男子汉，领会了责任的真谛。\n\n简介来自豆瓣（https://movie.douban.com/subject/1301753/）。","date":"1994-06-15","objectID":"/anime/the_lion_king/","tags":null,"title":"狮子王","uri":"/anime/the_lion_king/"},{"categories":null,"content":"简介 辛巴是狮子王国的小王子，他的父亲穆法沙是一个威严的国王。然而叔叔刀疤却对穆法沙的王位觊觎已久。 要想坐上王位宝座，刀疤必须除去小王子。于是，刀疤利用种种借口让辛巴外出，然后伺机大开杀戒，无奈被穆法沙即时来救。在反复的算计下，穆法沙惨死在刀疤手下，刀疤别有用心的劝辛巴离开，一方面派人将他赶尽杀绝。 辛巴逃亡中遇到了机智的丁满和善良的彭彭，他们抚养辛巴长成雄壮的大狮子，鼓励他回去森林复国。在接下来一场复国救民的斗争中，辛巴真正长成一个坚强的男子汉，领会了责任的真谛。 简介来自豆瓣（https://movie.douban.com/subject/1301753/）。 制作人员： 导演：罗杰·","date":"1994-06-15","objectID":"/anime/the_lion_king/:1:0","tags":null,"title":"狮子王","uri":"/anime/the_lion_king/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 沙祖 雄 Rowan Atkinson ","date":"1994-06-15","objectID":"/anime/the_lion_king/:2:0","tags":null,"title":"狮子王","uri":"/anime/the_lion_king/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 狮子王 1994-06-15 1 bilibili 2 狮子王 2019-07-12 1 樱花 ","date":"1994-06-15","objectID":"/anime/the_lion_king/:3:0","tags":null,"title":"狮子王","uri":"/anime/the_lion_king/"},{"categories":null,"content":"《十二生肖》是由上海美术电影制片厂出品的国产动画片。描写了古代时世界被十二个凶残的妖魔轮流统治，为了解救人类，一位勇敢的青年勇士和他的朋友鼠、牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪十二个动物与妖魔们展开生死博斗，最终把人类从灾难中解放出来的故事。每消灭一个妖怪就有一个动物献出生命，为了纪念牺牲的动物，人们将它们定为十二生肖。本片制作精良，画质优美，情节感人，中国传统文化气息颇为浓厚，是一部将神话、历史、文化、民俗完美结合的一部不可多得的动画精品。","date":"1993-01-01","objectID":"/anime/shi_er_sheng_xiao/","tags":null,"title":"十二生肖","uri":"/anime/shi_er_sheng_xiao/"},{"categories":null,"content":"简介 《十二生肖》是由上海美术电影制片厂出品的国产动画片。描写了古代时世界被十二个凶残的妖魔轮流统治，为了解救人类，一位勇敢的青年勇士和他的朋友鼠、牛、虎、兔、龙、蛇、马、羊、猴、鸡、狗、猪十二个动物与妖魔们展开生死博斗，最终把人类从灾难中解放出来的故事。每消灭一个妖怪就有一个动物献出生命，为了纪念牺牲的动物，人们将它们定为十二生肖。本片制作精良，画质优美，情节感人，中国传统文化气息颇为浓厚，是一部将神话、历史、文化、民俗完美结合的一部不可多得的动画精品。 制作人员： 脚本：凌纾 音乐：上海电影乐团、吴应钜 人物设定：刘泽岱 剪辑：莫普忠 制作：上海美术电影制片厂 ","date":"1993-01-01","objectID":"/anime/shi_er_sheng_xiao/:1:0","tags":null,"title":"十二生肖","uri":"/anime/shi_er_sheng_xiao/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 十二生肖 1993-01-01 13 bilibili ","date":"1993-01-01","objectID":"/anime/shi_er_sheng_xiao/:2:0","tags":null,"title":"十二生肖","uri":"/anime/shi_er_sheng_xiao/"},{"categories":null,"content":"　　罗森是一战中意大利空军的王牌飞行员，但却被施了魔法变了一头猪。虽然变了猪，但罗森还是继续他的老本行，成了一位赏金猎人，专门打击在亚地里亚海空域作恶的空中劫匪。红猪侠一时威名远扬，令劫匪们闻风丧胆。匪徒们为了对付罗森，请来了超级飞行员卡基斯。卡基斯在于罗森对决中趁他发动机故障将其击落。罗森把飞机送到老朋友比克罗处修理时，遇上了比克罗的孙女菲欧。菲欧帮罗森修好了飞机，两人一起再度翱翔蓝天对付空中劫匪。\n　　这时，卡斯基出现了，他对菲欧一见钟情。为了争夺菲欧的爱，卡斯罗向罗森提出决斗。于是两人再次浴血蓝空。 ","date":"1992-07-18","objectID":"/anime/porco_rosso/","tags":null,"title":"红猪","uri":"/anime/porco_rosso/"},{"categories":null,"content":"简介 罗森是一战中意大利空军的王牌飞行员，但却被施了魔法变了一头猪。虽然变了猪，但罗森还是继续他的老本行，成了一位赏金猎人，专门打击在亚地里亚海空域作恶的空中劫匪。红猪侠一时威名远扬，令劫匪们闻风丧胆。匪徒们为了对付罗森，请来了超级飞行员卡基斯。卡基斯在于罗森对决中趁他发动机故障将其击落。罗森把飞机送到老朋友比克罗处修理时，遇上了比克罗的孙女菲欧。菲欧帮罗森修好了飞机，两人一起再度翱翔蓝天对付空中劫匪。 这时，卡斯基出现了，他对菲欧一见钟情。为了争夺菲欧的爱，卡斯罗向罗森提出决斗。于是两人再次浴血蓝空。 制作人员： 原作：宫崎骏 音乐：久石让 美术监督：久村佳津 作画监督：贺川爱、河口俊夫 摄","date":"1992-07-18","objectID":"/anime/porco_rosso/:1:0","tags":null,"title":"红猪","uri":"/anime/porco_rosso/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 マルコ・パゴット Marco Pagot 男 2 フィオ・ピッコロ フィオ・ピッコロ、Fio Piccolo 女 岡村明美 3 吉娜 Madame Gina、Gina 女 加藤登紀子 4 贝蒂 贝蒂娃娃、Betty Boop、ベティ・ブープ、贝蒂大眼妹 女 ","date":"1992-07-18","objectID":"/anime/porco_rosso/:2:0","tags":null,"title":"红猪","uri":"/anime/porco_rosso/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 红猪 1992-07-18 01:33:19 樱花 ","date":"1992-07-18","objectID":"/anime/porco_rosso/:3:0","tags":null,"title":"红猪","uri":"/anime/porco_rosso/"},{"categories":null,"content":"东京私立贵大高等学校高一年级的学生弄内洋太追求同学早川然美，正当他准备告白时，却发现然美喜欢的是他的好友——同班同学新舞贵志，于是他陷入了无奈与失落。一个人走在回到家的路上，洋太的情绪十分低落，自己也不知道怎么就走到了一家名叫GOKURAU的出租录影带的商店前。洋太走过一排排录影带架后，在一盒录影带前停了下来：《安慰——天野爱》。借回家的录影带在播放过程中，天野爱居然从画面中走出！爱鼓励洋太要努力追求真爱，并以洋太妹妹的身份住在洋太家中。谁也没有想到，一段感人的恋爱故事就这样开始。","date":"1992-03-27","objectID":"/anime/video_girl/","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"简介 东京私立贵大高等学校高一年级的学生弄内洋太追求同学早川然美，正当他准备告白时，却发现然美喜欢的是他的好友——同班同学新舞贵志，于是他陷入了无奈与失落。一个人走在回到家的路上，洋太的情绪十分低落，自己也不知道怎么就走到了一家名叫GOKURAU的出租录影带的商店前。洋太走过一排排录影带架后，在一盒录影带前停了下来：《安慰——天野爱》。借回家的录影带在播放过程中，天野爱居然从画面中走出！爱鼓励洋太要努力追求真爱，并以洋太妹妹的身份住在洋太家中。谁也没有想到，一段感人的恋爱故事就这样开始。 制作人员： 原作：桂正和 导演：西久保瑞穗 脚本：关岛真赖、山下久仁明、赤堀悟 分镜：坂田纯一、望月智充 ","date":"1992-03-27","objectID":"/anime/video_girl/:1:0","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天野爱 あまの　あい、amano ai 女 林原めぐみ 2 广播 アナウンサー、Announcer、播音员、Announce 池本小百合 ","date":"1992-03-27","objectID":"/anime/video_girl/:2:0","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 电影少女 1992-03-27 6 9anime ","date":"1992-03-27","objectID":"/anime/video_girl/:3:0","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"MAD ","date":"1992-03-27","objectID":"/anime/video_girl/:4:0","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"唐武皇时期，秀才唐敖科举失意，心怀抑郁。在妻兄林之洋的邀请下，他随船队出海经商，四海巡游。造访了君子国、女儿国、大人国、两面国、无肠国、穿胸国等民俗各异的国家，一路发生许多刺激和有趣的事情。\n\n改编自清小说家李汝珍的同名作品。影片第4集《两面国》获1991年度广播电影电视部优秀影片奖和1993年第二届中国影视动画展播荣誉奖。","date":"1991-12-01","objectID":"/anime/jing_hua_yuan/","tags":null,"title":"镜花缘","uri":"/anime/jing_hua_yuan/"},{"categories":null,"content":"简介 唐武皇时期，秀才唐敖科举失意，心怀抑郁。在妻兄林之洋的邀请下，他随船队出海经商，四海巡游。造访了君子国、女儿国、大人国、两面国、无肠国、穿胸国等民俗各异的国家，一路发生许多刺激和有趣的事情。 改编自清小说家李汝珍的同名作品。影片第4集《两面国》获1991年度广播电影电视部优秀影片奖和1993年第二届中国影视动画展播荣誉奖。 制作人员： 导演：胡兆洪、邹勤 背景美术：袁炽昌 剪辑：莫普忠 制作：上海美术电影制片厂 ","date":"1991-12-01","objectID":"/anime/jing_hua_yuan/:1:0","tags":null,"title":"镜花缘","uri":"/anime/jing_hua_yuan/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 镜花缘 1991-12 4 bilibili ","date":"1991-12-01","objectID":"/anime/jing_hua_yuan/:2:0","tags":null,"title":"镜花缘","uri":"/anime/jing_hua_yuan/"},{"categories":null,"content":"著名的中文角色扮演游戏，以独特的内涵和厚重的历史感在中文RPG游戏中自成一格，人气极高的《轩辕剑叁：云和山的彼端》\n与其外传《天之痕》是角色扮演游戏中的经典，随后的《苍之涛》更是感动了无数玩家。\n【主篇故事顺序】轩辕剑壹——轩辕剑贰——穹之扉（商代）——轩辕剑陆（商末周初）——苍之涛（春秋）——枫之舞（战国）——轩辕剑肆（秦代）——\n轩辕剑柒（西汉）——云之遥（三国·曹魏）——汉之云（三国·蜀汉）——轩辕剑伍——天之痕（隋代）——轩辕剑叁（安史之乱前后的欧洲、阿拉伯地区、唐帝国）","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"简介 著名的中文角色扮演游戏，以独特的内涵和厚重的历史感在中文RPG游戏中自成一格，人气极高的《轩辕剑叁：云和山的彼端》 与其外传《天之痕》是角色扮演游戏中的经典，随后的《苍之涛》更是感动了无数玩家。 【主篇故事顺序】轩辕剑壹——轩辕剑贰——穹之扉（商代）——轩辕剑陆（商末周初）——苍之涛（春秋）——枫之舞（战国）——轩辕剑肆（秦代）—— 轩辕剑柒（西汉）——云之遥（三国·曹魏）——汉之云（三国·蜀汉）——轩辕剑伍——天之痕（隋代）——轩辕剑叁（安史之乱前后的欧洲、阿拉伯地区、唐帝国） 制作人员： 开发：DOMO小组 发行：大宇资讯股份有限公司 遊戲設計師：蔡明宏 美工：郭炳宏 音乐：苏竑嶂 ","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/:1:0","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 何然 然翁、燕赤霞 男 2 杨坤硕 寧采臣、宁采臣 男 3 江如红 小倩 女 ","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/:2:0","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"系列 系列名 发行时间 1 轩辕剑 1990-10-13 2 轩辕剑二 1994-02-08 3 轩辕剑外传 枫之舞 1995-01-06 4 轩辕剑三 云和山的彼端 1999-12-15 5 轩辕剑三外传：天之痕 2000-12-02 6 轩辕剑四：黑龙舞兮云飞扬 2002-08-04 7 轩辕剑外传：苍之涛 2004-02-06 8 轩辕剑五：一剑凌云山海情 2006-10-16 9 轩辕剑外传：汉之云 2009-01-10 10 轩辕剑外传：云之遥 2010-01-12 11 轩辕剑外传：云之遥 兰茵篇 2010-04-27 ","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/:3:0","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"配乐 ","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/:4:0","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"童年的印象里，我们多看过两部日本以四驱车为题材的动画。一部是星马豪、星马烈兄弟的《四驱兄弟》；而另一部，有着“天王巨星”、“舞蹈天使”等耳熟能详的赛车名字的，就是本作——《四驱小子》。\n\n还记得用曲棍玩赛车的日子吗？暴走!狂飙!激烈的赛车场面，让你在速度中感受极限!屏住呼吸，出发! 四驱郎凭着至爱的四驱车及自己坚强的意志，无论遇到什么困难，在四驱车赛场上无往而不胜。\n\n　　在片中，不仅有这些紧张逼真的赛车场面，更有许多专业性的四驱车知识讲解。也一直为广大四驱车迷所津津乐道至今。\n　　当年因为四驱小子的热播，还带动了整个中国四驱车市场。四驱车由此大卖。动画里的仿车更是四驱车迷的追逐于心爱之物。","date":"1989-10-03","objectID":"/anime/dash_yonkurou/","tags":null,"title":"四驱小子","uri":"/anime/dash_yonkurou/"},{"categories":null,"content":"简介 童年的印象里，我们多看过两部日本以四驱车为题材的动画。一部是星马豪、星马烈兄弟的《四驱兄弟》；而另一部，有着“天王巨星”、“舞蹈天使”等耳熟能详的赛车名字的，就是本作——《四驱小子》。 还记得用曲棍玩赛车的日子吗？暴走!狂飙!激烈的赛车场面，让你在速度中感受极限!屏住呼吸，出发! 四驱郎凭着至爱的四驱车及自己坚强的意志，无论遇到什么困难，在四驱车赛场上无往而不胜。 在片中，不仅有这些紧张逼真的赛车场面，更有许多专业性的四驱车知识讲解。也一直为广大四驱车迷所津津乐道至今。 当年因为四驱小子的热播，还带动了整个中国四驱车市场。四驱车由此大卖。动画里的仿车更是四驱车迷的追逐于心爱之物。 制作人","date":"1989-10-03","objectID":"/anime/dash_yonkurou/:1:0","tags":null,"title":"四驱小子","uri":"/anime/dash_yonkurou/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 四驱小子 1989-10-03 25 bilibili ","date":"1989-10-03","objectID":"/anime/dash_yonkurou/:2:0","tags":null,"title":"四驱小子","uri":"/anime/dash_yonkurou/"},{"categories":null,"content":"琪琪是一个13岁的实习魔女。依家族惯例，琪琪是时候离开她的家，到一个新的城市去展开独立的新生活，修行成为正式的魔女。\n\n动画宣传用文宣：\n虽然有时会不如意，但我很好。（おちこんだりもしたけれど、私はげんきです。）──由糸井重里提供。\n虽然有失落的时候，但我喜欢这座城市。（おちこむこともあるけれど、私はこの町がすきです。）──第二份公开的官方海报采用文宣。","date":"1989-07-29","objectID":"/anime/majo_no_takkyuubin/","tags":null,"title":"魔女宅急便","uri":"/anime/majo_no_takkyuubin/"},{"categories":null,"content":"简介 琪琪是一个13岁的实习魔女。依家族惯例，琪琪是时候离开她的家，到一个新的城市去展开独立的新生活，修行成为正式的魔女。 动画宣传用文宣： 虽然有时会不如意，但我很好。（おちこんだりもしたけれど、私はげんきです。）──由糸井重里提供。 虽然有失落的时候，但我喜欢这座城市。（おちこむこともあるけれど、私はこの町がすきです。）──第二份公开的官方海报采用文宣。 制作人员： 原作：角野荣子 导演：宫崎骏 分镜：近藤喜文 音乐：久石让 人物设定：近藤胜也 美术监督：大野广司 色彩设计：保田道世 ","date":"1989-07-29","objectID":"/anime/majo_no_takkyuubin/:1:0","tags":null,"title":"魔女宅急便","uri":"/anime/majo_no_takkyuubin/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 琪琪 KIKI 女 高山みなみ 2 ジジ Jiji 男 佐久間レイ 3 トンボ / コポリ 男 山口勝平 4 先輩魔女 女 小林優子 5 おソノ 女 戸田恵子 6 おソノの夫（フクオ） 男 山寺宏一 7 ウルスラ 女 高山みなみ 8 マキ 女 井上喜久子 ","date":"1989-07-29","objectID":"/anime/majo_no_takkyuubin/:2:0","tags":null,"title":"魔女宅急便","uri":"/anime/majo_no_takkyuubin/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔女宅急便 1989-07-29 01:43:02 樱花 ","date":"1989-07-29","objectID":"/anime/majo_no_takkyuubin/:3:0","tags":null,"title":"魔女宅急便","uri":"/anime/majo_no_takkyuubin/"},{"categories":null,"content":" 故事发生在遥远的月球之上，彼时，那里已经变成了适宜人类居住的星球。某日，来月球旅行的遥大地（松冈洋子 配音）邂逅了名为“兔人”的月球种族，他们告诉遥大地，他们位于月球内层的星球遭到了邪动族的侵略都和霸占，为此，他们踏上了寻找能够对抗邪动族的勇士的旅程。  \n\n让兔人们没有想到的是，遥大地竟然就是他们要找的光明魔动战士，通过魔法阵，遥大地召唤出了地之魔动王。之后，召唤出风之魔动王的山本加斯（松田辰也 配音），召唤出水之魔动王的玛利乌斯（安达忍 配音）等人纷纷登场，一行人来到了圣地路那，准备在那里展开一段惊心动魄的奇幻旅程。","date":"1989-04-07","objectID":"/anime/mado_king_granzort/","tags":null,"title":"魔动王","uri":"/anime/mado_king_granzort/"},{"categories":null,"content":"简介 故事发生在遥远的月球之上，彼时，那里已经变成了适宜人类居住的星球。某日，来月球旅行的遥大地（松冈洋子 配音）邂逅了名为“兔人”的月球种族，他们告诉遥大地，他们位于月球内层的星球遭到了邪动族的侵略都和霸占，为此，他们踏上了寻找能够对抗邪动族的勇士的旅程。 让兔人们没有想到的是，遥大地竟然就是他们要找的光明魔动战士，通过魔法阵，遥大地召唤出了地之魔动王。之后，召唤出风之魔动王的山本加斯（松田辰也 配音），召唤出水之魔动王的玛利乌斯（安达忍 配音）等人纷纷登场，一行人来到了圣地路那，准备在那里展开一段惊心动魄的奇幻旅程。 制作人员： 原作：矢立肇、广井王子 脚本：比贺静梦、三井秀树、井内秀治、","date":"1989-04-07","objectID":"/anime/mado_king_granzort/:1:0","tags":null,"title":"魔动王","uri":"/anime/mado_king_granzort/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 遥大地 はるか　だいち、Haruka Daichi 男 松岡洋子 2 拉比 马流士·冯·拉玛斯、マリウス・フォン・ラーマス 安達忍 3 地动王 地隐侠、火动王、光能使者、Granzort、地神号 大滝進矢 4 超级地动王 超级地隐侠、超级火动王、超级光能使者、Super Granzort、超级地神号 大滝進矢 5 加斯 瓦斯、ガス 男 松田辰也 6 梅 女 鈴木れい子 7 咕哩咕哩 林原めぐみ 8 爱奴玛 女 林原めぐみ ","date":"1989-04-07","objectID":"/anime/mado_king_granzort/:2:0","tags":null,"title":"魔动王","uri":"/anime/mado_king_granzort/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔动王 1989-04-07 41 bilibili ","date":"1989-04-07","objectID":"/anime/mado_king_granzort/:3:0","tags":null,"title":"魔动王","uri":"/anime/mado_king_granzort/"},{"categories":null,"content":"　　21世纪人类开始开发宇宙。但是宇宙生物群(通称宇宙怪兽, STMC)，一种以恒星作载体繁殖的生物来袭，使人类文明受到重大威胁。\n　　为了对抗宇宙怪兽，机械人兵器和宇宙战舰持续开发中，由地球上的机械人训练学校找出优胜的驾驶员控制。\n　　2015年，在人类史上第一次和宇宙怪兽接触后，故事的女主角高屋法子进入了机械人训练学校接受训练，驾驶人类对抗宇宙怪兽最强武器Gunbuster，开始了她守护地球使命的故事。 ","date":"1988-10-07","objectID":"/anime/gunbuster/","tags":null,"title":"飞跃巅峰！","uri":"/anime/gunbuster/"},{"categories":null,"content":"简介 21世纪人类开始开发宇宙。但是宇宙生物群(通称宇宙怪兽, STMC)，一种以恒星作载体繁殖的生物来袭，使人类文明受到重大威胁。 为了对抗宇宙怪兽，机械人兵器和宇宙战舰持续开发中，由地球上的机械人训练学校找出优胜的驾驶员控制。 2015年，在人类史上第一次和宇宙怪兽接触后，故事的女主角高屋法子进入了机械人训练学校接受训练，驾驶人类对抗宇宙怪兽最强武器Gunbuster，开始了她守护地球使命的故事。 制作人员： 原作：冈田斗司夫 导演：庵野秀明 脚本：山贺博之 分镜：樋口真嗣 演出：增尾昭一 音乐：田中公平 人物原案：美树本晴彦 ","date":"1988-10-07","objectID":"/anime/gunbuster/:1:0","tags":null,"title":"飞跃巅峰！","uri":"/anime/gunbuster/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 高屋法子 タカヤ・ノリコ、Takaya Noriko 女 日髙のり子 2 天野和美 アマノ・カズミ、Amano Kazumi 女 佐久間レイ 3 荣格·佛洛依德 Jung Freud、Yungu Furoito 女 川村万梨阿 4 太田宏一朗 太田浩一郎、Oota Kouichirou、コーチ 男 若本規夫 5 诺诺 ノノリリ、ノノリリ 女 福井裕佳梨 6 拉璐可·梅鲁克·玛尔 Lal`C Mellk Mal、ラルク・メルク・マール、raruku meruku maaru 女 坂本真綾 7 琪可·赛琰斯 Tycho Science 女 沢城みゆき 8 葛鲁嘉","date":"1988-10-07","objectID":"/anime/gunbuster/:2:0","tags":null,"title":"飞跃巅峰！","uri":"/anime/gunbuster/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 飞跃巅峰！ 1988-10-07 6 bilibili 2 飞跃巅峰2！ 2004-11-26 6 bilibili ","date":"1988-10-07","objectID":"/anime/gunbuster/:3:0","tags":null,"title":"飞跃巅峰！","uri":"/anime/gunbuster/"},{"categories":null,"content":"MAD ","date":"1988-10-07","objectID":"/anime/gunbuster/:4:0","tags":null,"title":"飞跃巅峰！","uri":"/anime/gunbuster/"},{"categories":null,"content":"本片是對日本鄉村生活的迷人及節奏緩慢的描繪。故事背景設定於1958年（昭和33年），一位大學教授和他的兩個女兒搬進一個森林附近的一所舊房子，因為他的妻子染上了結核病，在附近的一所醫院康復中。他的女兒們發現了「煤炭屎」，她們又名「煤炭屎鬼」。\n\n次子追趕一隻小龍貓，牠引領了她去找到森林守護者「龍貓」。次子被牠們迷住了，並且下定決心去尋找大龍貓。一個下雨的晚上，當女孩們在等爸爸時，她們遇到了一個，用樹葉擋雨的大龍貓。當次子想把一個成熟的玉米帶給住在醫院的媽媽時，但迷了路，草子到處尋找她，最後去找大龍貓幫忙。並且在牠的幫助下，梅被迅速找到了。龍貓召喚而來的貓公車，接送草子和次子穿過鄉間，到醫院探望她們的媽媽。","date":"1988-04-16","objectID":"/anime/my_neighbor_totoro/","tags":null,"title":"龙猫","uri":"/anime/my_neighbor_totoro/"},{"categories":null,"content":"简介 本片是對日本鄉村生活的迷人及節奏緩慢的描繪。故事背景設定於1958年（昭和33年），一位大學教授和他的兩個女兒搬進一個森林附近的一所舊房子，因為他的妻子染上了結核病，在附近的一所醫院康復中。他的女兒們發現了「煤炭屎」，她們又名「煤炭屎鬼」。 次子追趕一隻小龍貓，牠引領了她去找到森林守護者「龍貓」。次子被牠們迷住了，並且下定決心去尋找大龍貓。一個下雨的晚上，當女孩們在等爸爸時，她們遇到了一個，用樹葉擋雨的大龍貓。當次子想把一個成熟的玉米帶給住在醫院的媽媽時，但迷了路，草子到處尋找她，最後去找大龍貓幫忙。並且在牠的幫助下，梅被迅速找到了。龍貓召喚而來的貓公車，接送草子和次子穿過鄉間，到醫院探","date":"1988-04-16","objectID":"/anime/my_neighbor_totoro/:1:0","tags":null,"title":"龙猫","uri":"/anime/my_neighbor_totoro/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 草壁メイ 草壁メイ、Kusakabe Mei 女 坂本千夏 2 草壁五月 日髙のり子 3 龙猫 Totoro、トトロ 高木均 4 草壁タツオ 草壁タツオ、Kusakabe Tatsuo 男 糸井重里 5 猫巴士 ネコバス、Nekobus 龍田直樹 6 ススワタリ ススワタリ、Susuwatari ","date":"1988-04-16","objectID":"/anime/my_neighbor_totoro/:2:0","tags":null,"title":"龙猫","uri":"/anime/my_neighbor_totoro/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙猫 1988-04-16 88m 樱花 ","date":"1988-04-16","objectID":"/anime/my_neighbor_totoro/:3:0","tags":null,"title":"龙猫","uri":"/anime/my_neighbor_totoro/"},{"categories":null,"content":"《银河英雄传说》的时间设定约在距今一千六百年后，范围约扩及全银河系的五分之一。当时宇宙中存在着两大势力，分别是专制的“银河帝国”，\n和由逃出帝国的共和主义者建立的“自由行星同盟”。 帝国视同盟为“边境叛徒的根据地”，同盟则将帝国当作“邪恶的黑暗专制势力”，\n彼此水火不容，持续了长达二百多年的战争。在两国领域之间，充满了不利宇宙航行的异常重力场，使得两国间的通道，只有著名的“费沙回廊”和“伊谢尔伦回廊”。\n伊谢尔伦回廊有着难攻不落的强大军事要塞，而在费沙回廊中，是介于两大势力间的半独立国——“费沙自治领”。\n因此整个宇宙就在专制的高登巴姆王朝银河帝国和崇尚自由、自主、自尊、自律的自由行星同盟及以经济、情报生存的费沙三方平衡之下运转着。\n终于，双方各出现了一位年轻的英雄：帝国的莱因哈特·冯·罗严克拉姆，和同盟的杨威利。历史的车轮开始转动了。","date":"1988-01-08","objectID":"/anime/legend_of_galactic_heroes/","tags":null,"title":"银河英雄传说","uri":"/anime/legend_of_galactic_heroes/"},{"categories":null,"content":"简介 《银河英雄传说》的时间设定约在距今一千六百年后，范围约扩及全银河系的五分之一。当时宇宙中存在着两大势力，分别是专制的“银河帝国”， 和由逃出帝国的共和主义者建立的“自由行星同盟”。 帝国视同盟为“边境叛徒的根据地”，同盟则将帝国当作“邪恶的黑暗专制势力”， 彼此水火不容，持续了长达二百多年的战争。在两国领域之间，充满了不利宇宙航行的异常重力场，使得两国间的通道，只有著名的“费沙回廊”和“伊谢尔伦回廊”。 伊谢尔伦回廊有着难攻不落的强大军事要塞，而在费沙回廊中，是介于两大势力间的半独立国——“费沙自治领”。 因此整个宇宙就在专制的高登巴姆王朝银河帝国和崇尚自由、自主、自尊、自律的自由行星同","date":"1988-01-08","objectID":"/anime/legend_of_galactic_heroes/:1:0","tags":null,"title":"银河英雄传说","uri":"/anime/legend_of_galactic_heroes/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 莱因哈特·冯·罗严克拉姆 ラインハルト・フォン・ローエングラム、Reinhard von Lohengramm 男 堀川りょう 2 渥佛根·米达麦亚 大米、沃尔夫冈·米特迈尔、ウォルフガング・ミッターマイヤー、Wolfgang Mittermeyer、疾风之狼 男 森功至 3 奥斯卡·冯·罗严塔尔 Oskar von Reuentahl、オスカー・フォン・ロイエンタール、Oskar von Reuenthal、金银妖瞳 男 若本規夫 4 巴尔·冯·奥贝斯坦 保罗·冯·奥贝斯泰因、パウル・フォン・オーベルシュタイン、Paul von Oberstein、干冰、","date":"1988-01-08","objectID":"/anime/legend_of_galactic_heroes/:2:0","tags":null,"title":"银河英雄传说","uri":"/anime/legend_of_galactic_heroes/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 银河英雄传说 1988-01-08 110 樱花 2 银河英雄传说 我的征途是星辰大海 1988-02-06 1 bilibili 3 银河英雄传说 黄金之翼 1992-02-12 1 bilibili 4 银河英雄传说 新战争的序曲 1993-12-18 1 bilibili 5 银河英雄传说 Die Neue These 邂逅 2018-04-03 12 bilibili 6 银河英雄传说 Die Neue These 星乱 第1章 2019-09-27 12 bilibili 7 银河英雄传说 Die Neue These 激突 第1章 ","date":"1988-01-08","objectID":"/anime/legend_of_galactic_heroes/:3:0","tags":null,"title":"银河英雄传说","uri":"/anime/legend_of_galactic_heroes/"},{"categories":null,"content":"最终幻想（日语：ファイナルファンタジー，简称FF，台湾/香港：太空战士，中国大陆：最终幻想），\n1987年由日本当时的游戏软件公司史克威尔（SQUARE SOFT）（与ENIX艾尼克斯合并为：SQUARE-ENIX）开发的角色扮演游戏（RPG）游戏系列。\n\n在那个时候，正是FC红极一时的年代。充斥市场的是以《勇者斗恶龙》为代表的所谓“勇者派”RPG。那时的史克威尔公司还不过是一个小小的开发游戏的厂商。\n在做了几个游戏都没有轰动后，制作人坂口博信决定做完最后一个游戏改行。而那个游戏就被命名为《最终幻想》（多少有点悲壮的意味）。 \n不曾想，游戏一经推出就备受玩家的注目。由此开始，FF一代一代的伴着无数玩家走了过来……","date":"1987-12-18","objectID":"/game/final_fantasy/","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"简介 最终幻想（日语：ファイナルファンタジー，简称FF，台湾/香港：太空战士，中国大陆：最终幻想）， 1987年由日本当时的游戏软件公司史克威尔（SQUARE SOFT）（与ENIX艾尼克斯合并为：SQUARE-ENIX）开发的角色扮演游戏（RPG）游戏系列。 在那个时候，正是FC红极一时的年代。充斥市场的是以《勇者斗恶龙》为代表的所谓\"勇者派\"RPG。那时的史克威尔公司还不过是一个小小的开发游戏的厂商。 在做了几个游戏都没有轰动后，制作人坂口博信决定做完最后一个游戏改行。而那个游戏就被命名为《最终幻想》（多少有点悲壮的意味）。 不曾想，游戏一经推出就备受玩家的注目。由此开始，FF一代一代的伴","date":"1987-12-18","objectID":"/game/final_fantasy/:1:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 克劳德·斯特莱夫 クラウド・ストライフ、Cloud Strife 男 2 蒂法·洛克哈特 Tifa Lockhart、Tifa 女 3 艾瑞丝·盖恩斯巴勒 エアリス・ゲインズブール、Aerith Gainsborough 女 4 巴瑞特·华莱士 Barret Wallace 男 5 雷诺 レノ、Reno 男 6 扎克斯 菲尔 Zack Fair、ザックス・フェア 男 7 尤菲･如月 ユフィ・キサラギ、Yuffie Kisaragi 女 8 赤红13 Nanaki、レッドXIII、Red XIII 雄 ","date":"1987-12-18","objectID":"/game/final_fantasy/:2:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"系列 系列名 发行时间 1 最终幻想 1987-12-18 2 最终幻想5 1992-12-06 3 最终幻想6 1994-04-02 4 最终幻想7 1997-01-31 5 最终幻想8 1999-02-11 6 最终幻想9 2000-07-07 7 最终幻想10 2001-07-19 8 最终幻想12 2006-03-16 9 最终幻想7 重制版 2020-04-10 ","date":"1987-12-18","objectID":"/game/final_fantasy/:3:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"动画 系列名 首播时间 话数/时长 观看地址 1 最终幻想：灵魂深处 2001-07-11 01:46:00 bilibili 2 最终幻想VII：降临之子 2005-09-14 02:06:26 bilibili 3 最终幻想15 王者之剑 2016-07-09 01:55:33 bilibili ","date":"1987-12-18","objectID":"/game/final_fantasy/:4:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"MAD ","date":"1987-12-18","objectID":"/game/final_fantasy/:5:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"　　在过去的历史之中，传说着曾有人类以高科技创造了可飞行于天空的城市——拉普达。虽多数认为这是虚构幻想出来的事物，但仍有相信飞行城市存在而试图寻找出的人们。\n　　某一日晚上，搭载众多旅客的飞行客船突遭到空中海盗团的袭击和入侵，空中海盗的目标是搭乘飞行船的一位名叫希达的少女身上所携带与飞行城市传说相关的物品“飞行石”。\n　　巴斯与希达为了抢回飞行石并阻止罗穆斯卡的企图，于是搭上了朵拉一族的飞行船一同前往拉普达——传说的天空之城。","date":"1986-08-02","objectID":"/anime/castle_in_the_sky/","tags":null,"title":"天空之城","uri":"/anime/castle_in_the_sky/"},{"categories":null,"content":"简介 在过去的历史之中，传说着曾有人类以高科技创造了可飞行于天空的城市——拉普达。虽多数认为这是虚构幻想出来的事物，但仍有相信飞行城市存在而试图寻找出的人们。 某一日晚上，搭载众多旅客的飞行客船突遭到空中海盗团的袭击和入侵，空中海盗的目标是搭乘飞行船的一位名叫希达的少女身上所携带与飞行城市传说相关的物品“飞行石”。 巴斯与希达为了抢回飞行石并阻止罗穆斯卡的企图，于是搭上了朵拉一族的飞行船一同前往拉普达——传说的天空之城。 制作人员： 原作：宫崎骏 音乐：久石让 美术监督：山本二三 作画监督：丹内司 摄影监督：高桥宏固 原画：名仓靖博、江村丰秋 ","date":"1986-08-02","objectID":"/anime/castle_in_the_sky/:1:0","tags":null,"title":"天空之城","uri":"/anime/castle_in_the_sky/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 希达 シータ、Sheeta 女 よこざわけい子 2 巴斯 Pazu 男 田中真弓 3 朵拉 Dola 女 初井言榮 4 穆斯卡 Muska 男 Mark Hamill 5 穆罗将军 General、Shogun Mouro 男 永井一郎 6 达菲 男 糸博 7 路易 Louie 男 安原義人 8 亨利 Henri 男 亀山助清 ","date":"1986-08-02","objectID":"/anime/castle_in_the_sky/:2:0","tags":null,"title":"天空之城","uri":"/anime/castle_in_the_sky/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天空之城 1986-08-02 124m 樱花 ","date":"1986-08-02","objectID":"/anime/castle_in_the_sky/:3:0","tags":null,"title":"天空之城","uri":"/anime/castle_in_the_sky/"},{"categories":null,"content":"鸟山明最早在《少年JUMP》周刊连载《龙珠》时，该漫画早期（1-194篇）比较偏重于搞笑，而且打斗一般并不在这儿占主流，因此这个时期，鸟山明的画风对人物性格刻画得很精准，可以让人爆笑起来，因此东映动画公司决定把这个时期的漫画改成一部153集的动画，这也是中国内地在三部《龙珠》系列动画中唯一引进的一部，故也称龙珠TV。而且第一部有很多风格和人物剧情都根源于《西游记》，而且鸟山明的前作《阿拉蕾》中的人物也有客串。","date":"1986-02-26","objectID":"/anime/dragonball/","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"简介 鸟山明最早在《少年JUMP》周刊连载《龙珠》时，该漫画早期（1-194篇）比较偏重于搞笑，而且打斗一般并不在这儿占主流，因此这个时期，鸟山明的画风对人物性格刻画得很精准，可以让人爆笑起来，因此东映动画公司决定把这个时期的漫画改成一部153集的动画，这也是中国内地在三部《龙珠》系列动画中唯一引进的一部，故也称龙珠TV。而且第一部有很多风格和人物剧情都根源于《西游记》，而且鸟山明的前作《阿拉蕾》中的人物也有客串。 制作人员： 原作：鸟山明 脚本：出手敬、雪室俊一、丸尾未步、菅良幸、小黑祐一郎、宫崎博子、荒川稔久、由木义文 ","date":"1986-02-26","objectID":"/anime/dragonball/:1:0","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 孙悟空 Sangoku、孙悟空（成年）、Goku、孫悟空、Son Gokuu、卡卡罗特 男 野沢雅子 2 布尔玛 ブルマ、Bulma、布尔玛，布玛，庄子 女 鶴ひろみ 3 龟仙人 Tortue Géniale、Master Roshi、亀仙人、かめ せんにん、Kame Sennin、武天老師 男 宮内幸平 4 スノ Snow、スノ 女 渡辺菜生子 5 皮拉夫 ピラフ、Pilaf 男 千葉繁 6 海龟 カメ、Kame 男 郷里大輔 7 乌龙 ウーロン、Oolong 男 龍田直樹 8 阿修 シュウ、Shuu 男 玄田哲章 ","date":"1986-02-26","objectID":"/anime/dragonball/:2:0","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙珠 1986-02-26 153 樱花 2 龙珠Z 1989-04-26 291 樱花 3 龙珠GT 1996-02-07 64 樱花 4 龙珠改 2009-04-05 98 樱花 5 龙珠改 魔人布欧篇 2014-04-06 61 樱花 6 龙珠超 2015-07-05 131 樱花 7 龙珠Z 一夫当关的最后决战~挑战弗利萨的Z战士 孙悟空的父亲~ 1990-10-17 1 优酷 8 龙珠Z・绝望的反抗!!残留的超战士・悟饭和特兰克斯 1993-02-24 1 樱花 9 龙珠旧剧场版 1986-12-20 17 樱花 10 龙珠超 布罗利","date":"1986-02-26","objectID":"/anime/dragonball/:3:0","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"MAD ","date":"1986-02-26","objectID":"/anime/dragonball/:4:0","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"“天使之卵”架构在一个充满阴影和灰暗色彩的超现实主义世界中，剧情的主角是两个没有提及名字的少年与少女。\n\n少女随身带着一颗神秘的蛋，她花许多的时间在某个歌德式的死城里搜集各式瓶子与手工艺品。身上背着一把十字型武器的少年在某天也随着一种神秘的机械来到这个城镇。\n\n同时，巨大腔棘鱼的身影在城镇上方出现，城市里的人也成群的活过来开始用长枪猎捕这些鱼群。\n\n在少女如巨穴般的瓶子中，就像个庇护所一般，里面收藏着蒐藏品。少年等少女入睡后将那颗神秘的蛋打破。\n\n少女表现得很生气并紧跟着已经离开的少年。最后少女沉入了溪谷中死去，她口中吐出来的气泡最后都化作了一颗颗的蛋。","date":"1985-12-22","objectID":"/anime/tenshi_no_tamago/","tags":null,"title":"天使之卵","uri":"/anime/tenshi_no_tamago/"},{"categories":null,"content":"简介 “天使之卵”架构在一个充满阴影和灰暗色彩的超现实主义世界中，剧情的主角是两个没有提及名字的少年与少女。 少女随身带着一颗神秘的蛋，她花许多的时间在某个歌德式的死城里搜集各式瓶子与手工艺品。身上背着一把十字型武器的少年在某天也随着一种神秘的机械来到这个城镇。 同时，巨大腔棘鱼的身影在城镇上方出现，城市里的人也成群的活过来开始用长枪猎捕这些鱼群。 在少女如巨穴般的瓶子中，就像个庇护所一般，里面收藏着蒐藏品。少年等少女入睡后将那颗神秘的蛋打破。 少女表现得很生气并紧跟着已经离开的少年。最后少女沉入了溪谷中死去，她口中吐出来的气泡最后都化作了一颗颗的蛋。 制作人员： 原作：天野喜孝、押井守 音乐","date":"1985-12-22","objectID":"/anime/tenshi_no_tamago/:1:0","tags":null,"title":"天使之卵","uri":"/anime/tenshi_no_tamago/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 少女 少女、Shoujo 女 兵藤まこ 2 少年 男 根津甚八 ","date":"1985-12-22","objectID":"/anime/tenshi_no_tamago/:2:0","tags":null,"title":"天使之卵","uri":"/anime/tenshi_no_tamago/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天使之卵 1985-12-22 1 bilibili ","date":"1985-12-22","objectID":"/anime/tenshi_no_tamago/:3:0","tags":null,"title":"天使之卵","uri":"/anime/tenshi_no_tamago/"},{"categories":null,"content":"　　主人公乔万尼是一个贫困家庭的孩子，他要靠努力打工来养活被疾病困扰的妈妈。他的好朋友康佩内拉家境富裕，家中有很多书籍，他常常无私地邀请穷苦的乔万尼去他家一起阅读。有一天上自然科学课，老师拿出了银河的图片让同学们回答，当乔万尼被点到的时候，他明知答案，因为曾经在康佩内拉家一起在书上读过，但他却自卑担心答错而不敢回答，最终被一些同学耻笑。而为了保全乔万尼的面子，康佩内拉也故意对老师提出的问题沉默不答，而被老师和同学误以为连他这样的好学生也不懂。\n　　在银河节的那天，乔万尼在路上遭到了同班同学贾奈利的嘲弄。贾奈利随后吆喝同学们前往河边，参加晚上的银河节水灯大会，可是乔万尼却无法参加，因为他还要回家照顾妈妈。\n　　终于，他累倒了。于是他躺在山坡顶上休息。过了不知多久时间，他突然他听到一种奇怪的声音，于是睁开眼，意识到自己正在跟康佩内拉乘坐一辆在星际中的银河轨道上行驶的列车中。路途中，他们看见了许多难以置信美丽而又奇异的景象，还看见了许多人在白色的沙子和水晶中发掘化石，还有人捕捉白鹭，并用它们来制造糖果。一切的种种，都仿佛梦境一般的不可思议……\n　　他们又遇见了两个孩子与一位青年教师。从他们的交谈中，乔万尼得知刚才他们搭上了一艘撞上冰山而沉没的轮船，所以现在他们才进到这列车里来，隐隐暗示这辆列车的乘客身份其实并不寻常。当列车到达南十字座站的时候，其他乘客都下车了，车厢里只剩下了乔万尼和康佩内拉。两位好朋友相约永不分离。但当列车驶到煤袋星云站的时候，乔万尼才发觉康佩内拉已经离他而去，消失不见了。\n　　这时候，乔万尼醒过来了。他到城里头，发现众人聚集在桥头上，才发现原来之前贾奈利不小心从船上掉到河里去，而康佩内拉跳进河里救他。结果贾奈利被安全地救了上来，而康佩内拉却不幸再也没有浮出水面。原来所谓的“银河铁道”，是带领死者灵魂回归天国的哀伤列车……　　 ","date":"1985-07-13","objectID":"/anime/railroad/","tags":null,"title":"银河铁道之夜","uri":"/anime/railroad/"},{"categories":null,"content":"简介 主人公乔万尼是一个贫困家庭的孩子，他要靠努力打工来养活被疾病困扰的妈妈。他的好朋友康佩内拉家境富裕，家中有很多书籍，他常常无私地邀请穷苦的乔万尼去他家一起阅读。有一天上自然科学课，老师拿出了银河的图片让同学们回答，当乔万尼被点到的时候，他明知答案，因为曾经在康佩内拉家一起在书上读过，但他却自卑担心答错而不敢回答，最终被一些同学耻笑。而为了保全乔万尼的面子，康佩内拉也故意对老师提出的问题沉默不答，而被老师和同学误以为连他这样的好学生也不懂。 在银河节的那天，乔万尼在路上遭到了同班同学贾奈利的嘲弄。贾奈利随后吆喝同学们前往河边，参加晚上的银河节水灯大会，可是乔万尼却无法参加，因为他还要回家照","date":"1985-07-13","objectID":"/anime/railroad/:1:0","tags":null,"title":"银河铁道之夜","uri":"/anime/railroad/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 银河铁道之夜 1985-07-13 01:47:58 bilibili 2 银河铁道之夜 2006-06-17 48:21 bilibili ","date":"1985-07-13","objectID":"/anime/railroad/:2:0","tags":null,"title":"银河铁道之夜","uri":"/anime/railroad/"},{"categories":null,"content":"工业文明的高度发展，却最终带来灾难，一场为期7天的虫族毁灭战争摧毁了人类文明。一千年后，工业文明遗留下来的症结仍在困扰这个星球。带有强烈毒性的植物组成了令人望而却步的“腐海”森林，随着时间的推移，腐海有条不紊地向四周蔓延，蚕食周边世界。在一片腐海森林的旁边，居住着一群御风而行的人类。女主角娜乌茜卡和族人依靠海风的力量抵御着有毒孢子的侵蚀，过着平静祥和的生活。 \n\n直到某一天，战火烧到了这里。西方强国特洛梅意欲重新建立人类霸权，他们计划统一周边诸国，然后向虫族发起总攻。另一方面，一千年前曾主导摧毁人类的上古怪兽“猛怪”重现人间。毁灭战争一触即发，人类的命运将会如何……  \n\n本片根据宫崎骏同名漫画改编，并分获1985年罗马奇幻电影节和1985年电影旬报最佳影片奖、1985年每日电影大藤信郎奖。","date":"1984-03-11","objectID":"/anime/nausicaa_of_the_valley_of_the_wind/","tags":null,"title":"风之谷","uri":"/anime/nausicaa_of_the_valley_of_the_wind/"},{"categories":null,"content":"简介 工业文明的高度发展，却最终带来灾难，一场为期7天的虫族毁灭战争摧毁了人类文明。一千年后，工业文明遗留下来的症结仍在困扰这个星球。带有强烈毒性的植物组成了令人望而却步的“腐海”森林，随着时间的推移，腐海有条不紊地向四周蔓延，蚕食周边世界。在一片腐海森林的旁边，居住着一群御风而行的人类。女主角娜乌茜卡和族人依靠海风的力量抵御着有毒孢子的侵蚀，过着平静祥和的生活。 直到某一天，战火烧到了这里。西方强国特洛梅意欲重新建立人类霸权，他们计划统一周边诸国，然后向虫族发起总攻。另一方面，一千年前曾主导摧毁人类的上古怪兽“猛怪”重现人间。毁灭战争一触即发，人类的命运将会如何…… 本片根据宫崎骏同名漫画改","date":"1984-03-11","objectID":"/anime/nausicaa_of_the_valley_of_the_wind/:1:0","tags":null,"title":"风之谷","uri":"/anime/nausicaa_of_the_valley_of_the_wind/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 娜乌西卡 娜伍斯佳、Nausicaä、ナウシカ、なうしか、Naushika 女 島本須美 2 库夏娜 港译：无敌、Kushana、クシャナ 女 榊原良子 3 犹巴·米拉尔达 ユパ ミラルダ、Yupa 男 納谷悟朗 4 阿斯贝鲁 アスベル、Asbel 男 松田洋治 5 ラステル Lastelle、Rastel、Rasteru 女 冨永みーな 6 クロトワ Kurotowa 男 家弓家正 7 巨神兵 きょしんへい ","date":"1984-03-11","objectID":"/anime/nausicaa_of_the_valley_of_the_wind/:2:0","tags":null,"title":"风之谷","uri":"/anime/nausicaa_of_the_valley_of_the_wind/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 风之谷 1984-03-11 116m 樱花 ","date":"1984-03-11","objectID":"/anime/nausicaa_of_the_valley_of_the_wind/:3:0","tags":null,"title":"风之谷","uri":"/anime/nausicaa_of_the_valley_of_the_wind/"},{"categories":null,"content":"小学篇\n小学篇介绍了主角大空翼和其他主要角色，包括石崎梁、若林源三、本乡罗勃特、岬太郎、日向小次郎、三杉淳、松山光等人的背景和在全国大赛中的比赛。故事早段讲述主角大空翼迁居至南葛市，凭出色的足球技术及入球能力入选了南葛代表队，出战全国大赛。他的天赋才能震惊了整个足球界，而该年日本小学足球界亦人才辈出，当年司职中锋的大空翼带领的南葛在分组赛首场败给了日向小次郎率领的明和小学，但及后先后打败立花兄弟、三杉淳等人杀入决赛，在若林源三复出下终于打败斗志顽强的日向小次郎夺冠。\n\n中学篇\n中学篇仍然是描述在日本内举行的全国中学生足球比赛，不过加插了不少新人物，包括前锋新田瞬、来自大阪的盯人后卫早田诚、一刚一柔的二人组合次藤洋及佐野满等等。而若林源三、本乡和岬太郎在此时期都已经分别离开日本。由主角大空翼带领的南葛在连番苦战下杀入决赛，决赛对手正是整项赛事被冷冻的日向小次郎所带领的东邦学园，两队爆发激烈对决后不分胜负，最终两队同得冠军，而大空翼于日本学界的足球生涯亦暂告一段落。","date":"1983-10-13","objectID":"/anime/captain_tsubasa/","tags":null,"title":"足球小将","uri":"/anime/captain_tsubasa/"},{"categories":null,"content":"简介 小学篇 小学篇介绍了主角大空翼和其他主要角色，包括石崎梁、若林源三、本乡罗勃特、岬太郎、日向小次郎、三杉淳、松山光等人的背景和在全国大赛中的比赛。故事早段讲述主角大空翼迁居至南葛市，凭出色的足球技术及入球能力入选了南葛代表队，出战全国大赛。他的天赋才能震惊了整个足球界，而该年日本小学足球界亦人才辈出，当年司职中锋的大空翼带领的南葛在分组赛首场败给了日向小次郎率领的明和小学，但及后先后打败立花兄弟、三杉淳等人杀入决赛，在若林源三复出下终于打败斗志顽强的日向小次郎夺冠。 中学篇 中学篇仍然是描述在日本内举行的全国中学生足球比赛，不过加插了不少新人物，包括前锋新田瞬、来自大阪的盯人后卫早田诚、","date":"1983-10-13","objectID":"/anime/captain_tsubasa/:1:0","tags":null,"title":"足球小将","uri":"/anime/captain_tsubasa/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 大空翼 大空翼、おおぞら つばさ、Oozora Tsubasa 男 日比野朱里 2 若林源三 若林源三、わかばやし げんぞう、Wakabayashi Genzou 男 橋本晃一 3 日向小次郎 日向 小次郎、ひゅうが こじろう、Hyuuga Kojirou、コジロウ、猛虎 男 鈴置洋孝 4 岬太郎 岬 太郎、みさき たろう、Misaki Tarou 男 山田栄子 5 石崎了 石崎 了、いしざき りょう、Ishizaki Ryo 男 丸山裕子 6 泷一 たき はじめ、Taki Hajime 男 堀内賢雄 7 若岛津健 空手道守门员、わかしまづ けん、Wakas","date":"1983-10-13","objectID":"/anime/captain_tsubasa/:2:0","tags":null,"title":"足球小将","uri":"/anime/captain_tsubasa/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 足球小将 1983-10-13 128 bilibili ","date":"1983-10-13","objectID":"/anime/captain_tsubasa/:3:0","tags":null,"title":"足球小将","uri":"/anime/captain_tsubasa/"},{"categories":null,"content":"一天，看守天书《如意宝册》的袁公踏云巡山，突然天空飞过的鸟儿投下一颗不同寻常的石蛋。袁公将石蛋投入到炼丹炉中修炼。由于玉帝与各路大仙都去赴宴蟠桃会了，袁公趁机偷偷翻看了天书，并将天书的内容刻在了仙洞的石壁上，因此泄露了天机而遭到了天界的逮捕，袁公认为天道无私，既有天书何不理当传授于人。后在太白金星的劝说下，袁公被判免除死罪，革除天职，并罚他终身看守着石壁天书。一次趁袁公不在时，三只已窥视许久的狐狸精趁机溜进了洞府，并偷吃了仙丹从而幻化为人形，不仅发现了石壁上的天书，还偷走了丹炉里的那个石蛋。袁公回洞后，发现石蛋不见了，从镜子中看到原来是三只妖狐搞的鬼。石蛋从三只妖狐手中溜走，并被寺庙里的和尚打井时给捞了上来。后来三只妖狐赶来夺走了石蛋，并将石蛋埋在了荒郊野外，几天后石蛋破土而出变成了个小男孩。后来袁公找到了蛋生，为了将天书流传于人间，他吩咐蛋生等到白云洞口香炉升起彩烟时，将带上白纸，抄下洞中石壁上的天书。袁公便开始指点蛋生天书中的奥秘，让他运用天书中的知识造福于百姓。蛋生勤于研究天书，为民除害，由于三只妖狐憎恨蛋生阻止他们作恶，便施计企图去窃取天书，并且还勾结官府，继续祸害于黎民百姓。蛋生为了保护天书几经与妖狐斗法，当天书即将被狐狸精夺走时，袁公及时赶到，并收回了天书，还将三只狐狸精镇压在云梦山下。\n\n袁公自知难逃天庭法网，并将天书托付于蛋生，便叮嘱他急忙把天书文字永记在心里。然后袁公用一把神火将天书完全焚烧了。霎时间空中电闪雷鸣，玉帝下达圣旨，将袁公再次缉拿于天庭问罪。\n\n该片是中国史上第三部长片动画电影，是迄今为止上海美术电影制片厂的六部经典动画长片中唯一一部具有原创情节的动画。","date":"1983-01-01","objectID":"/anime/tian_shu/","tags":null,"title":"天书奇谭","uri":"/anime/tian_shu/"},{"categories":null,"content":"简介 一天，看守天书《如意宝册》的袁公踏云巡山，突然天空飞过的鸟儿投下一颗不同寻常的石蛋。袁公将石蛋投入到炼丹炉中修炼。由于玉帝与各路大仙都去赴宴蟠桃会了，袁公趁机偷偷翻看了天书，并将天书的内容刻在了仙洞的石壁上，因此泄露了天机而遭到了天界的逮捕，袁公认为天道无私，既有天书何不理当传授于人。后在太白金星的劝说下，袁公被判免除死罪，革除天职，并罚他终身看守着石壁天书。一次趁袁公不在时，三只已窥视许久的狐狸精趁机溜进了洞府，并偷吃了仙丹从而幻化为人形，不仅发现了石壁上的天书，还偷走了丹炉里的那个石蛋。袁公回洞后，发现石蛋不见了，从镜子中看到原来是三只妖狐搞的鬼。石蛋从三只妖狐手中溜走，并被寺庙里的","date":"1983-01-01","objectID":"/anime/tian_shu/:1:0","tags":null,"title":"天书奇谭","uri":"/anime/tian_shu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 袁公 男 毕克 2 美女狐精 女 程晓桦 3 独脚狐精 男 施融 ","date":"1983-01-01","objectID":"/anime/tian_shu/:2:0","tags":null,"title":"天书奇谭","uri":"/anime/tian_shu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天书奇谭 1983-01-01 01:40:37 bilibili ","date":"1983-01-01","objectID":"/anime/tian_shu/:3:0","tags":null,"title":"天书奇谭","uri":"/anime/tian_shu/"},{"categories":null,"content":"《铁臂阿童木》是日本漫画界一代宗師手塚治虫的首部長篇连载作品。故事講述少年仿生人阿童木在未來21世紀裏為了人類的福祉而活躍。日本電視網在1980年重新繪製了同劇彩色版，共52集。1980年代中臺灣、香港均有播放了此版本《小戰士》。同年12月中國中央電視台引進黑白版播放，成為最早引進中國大陸的日本動畫作品之一，播出後廣受歡迎。","date":"1980-10-01","objectID":"/anime/astro_boy/","tags":null,"title":"铁臂阿童木","uri":"/anime/astro_boy/"},{"categories":null,"content":"简介 《铁臂阿童木》是日本漫画界一代宗師手塚治虫的首部長篇连载作品。故事講述少年仿生人阿童木在未來21世紀裏為了人類的福祉而活躍。日本電視網在1980年重新繪製了同劇彩色版，共52集。1980年代中臺灣、香港均有播放了此版本《小戰士》。同年12月中國中央電視台引進黑白版播放，成為最早引進中國大陸的日本動畫作品之一，播出後廣受歡迎。 制作人员： 原作：手冢治虫 导演：石黑升 脚本：村野守美、高桥良辅 分镜：西村緋禄司、神田武幸 演出：矢泽则夫 ","date":"1980-10-01","objectID":"/anime/astro_boy/:1:0","tags":null,"title":"铁臂阿童木","uri":"/anime/astro_boy/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿童木 小金剛、Atom 男 清水マリ 2 洛克 ロック、トーマス・ウォータマン、ガノモス、星野マモル、バッサニオ、間久部緑郎（キャラクター）、间久部绿郎 男 水島裕 ","date":"1980-10-01","objectID":"/anime/astro_boy/:2:0","tags":null,"title":"铁臂阿童木","uri":"/anime/astro_boy/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 铁臂阿童木 1980-10-01 52 bilibili 2 铁臂阿童木 2003-04-06 50 bilibili 3 阿童木起源 2017-04-15 12 bilibili ","date":"1980-10-01","objectID":"/anime/astro_boy/:3:0","tags":null,"title":"铁臂阿童木","uri":"/anime/astro_boy/"},{"categories":null,"content":"　　商末时期，陈塘关总兵李靖的夫人怀胎3年6个月，最终生下一个肉球，肉球中跳出一个伶俐可爱的男孩。李靖原当他是妖孽欲杀之而后快，幸太乙真人前来收之为徒，赐名哪吒，并赐以乾坤圈和混天绫两件宝贝。某年，天下大旱，甘露未降。哪吒和家将到东海洗澡玩耍。他用混天绫搅动海水，撼动龙宫，惹出巡海夜叉李艮和龙王三太子敖丙。几番言语不和，哪吒杀此二人，由此闯下通天大祸。四海龙王齐聚陈塘关索命，为救一方百姓，哪吒决定交出生命……\n　　本片根据《封神演义》故事改编，并荣获1980年电影百花奖最佳美术片奖；文化部1979年优秀影片奖、青年优秀创作奖；1983年菲律宾马尼拉国际电影节特别奖；1988年法国布尔波拉斯文化俱乐部青年国际动画电影节评委奖和宽银幕长动画片奖。  ","date":"1979-05-19","objectID":"/anime/nezha_nao_hai/","tags":null,"title":"哪吒闹海","uri":"/anime/nezha_nao_hai/"},{"categories":null,"content":"简介 商末时期，陈塘关总兵李靖的夫人怀胎3年6个月，最终生下一个肉球，肉球中跳出一个伶俐可爱的男孩。李靖原当他是妖孽欲杀之而后快，幸太乙真人前来收之为徒，赐名哪吒，并赐以乾坤圈和混天绫两件宝贝。某年，天下大旱，甘露未降。哪吒和家将到东海洗澡玩耍。他用混天绫搅动海水，撼动龙宫，惹出巡海夜叉李艮和龙王三太子敖丙。几番言语不和，哪吒杀此二人，由此闯下通天大祸。四海龙王齐聚陈塘关索命，为救一方百姓，哪吒决定交出生命…… 本片根据《封神演义》故事改编，并荣获1980年电影百花奖最佳美术片奖；文化部1979年优秀影片奖、青年优秀创作奖；1983年菲律宾马尼拉国际电影节特别奖；1988年法国布尔波拉斯文化俱","date":"1979-05-19","objectID":"/anime/nezha_nao_hai/:1:0","tags":null,"title":"哪吒闹海","uri":"/anime/nezha_nao_hai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哪吒 哪咤 男 梁正晖 2 敖广 男 邱岳峰 3 太乙真人 男 富润生 4 李靖 男 毕克 ","date":"1979-05-19","objectID":"/anime/nezha_nao_hai/:2:0","tags":null,"title":"哪吒闹海","uri":"/anime/nezha_nao_hai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哪吒闹海 1979-05-19 58:29 bilibili ","date":"1979-05-19","objectID":"/anime/nezha_nao_hai/:3:0","tags":null,"title":"哪吒闹海","uri":"/anime/nezha_nao_hai/"},{"categories":null,"content":"U.C.（宇宙世纪）0079年，人类向宇宙发展并建立了多个巨大的卫星，让人类能够居住在宇宙中。卫星的居民们不堪忍受地球联邦政府对其剥削和压迫，遂宣布独立，更组建军队与地球联邦政府决一雌雄。在战争中双方先后开发了机动战士并投入战场。NEWTYPE少年阿姆罗·雷无意中驾驶上联邦军新开发的机动战士高达，卷入后来被称为“一年战争”中，并与其宿敌夏亚·阿兹纳布尔相遇。","date":"1979-04-07","objectID":"/anime/gundam/","tags":null,"title":"机动战士高达","uri":"/anime/gundam/"},{"categories":null,"content":"简介 U.C.（宇宙世纪）0079年，人类向宇宙发展并建立了多个巨大的卫星，让人类能够居住在宇宙中。卫星的居民们不堪忍受地球联邦政府对其剥削和压迫，遂宣布独立，更组建军队与地球联邦政府决一雌雄。在战争中双方先后开发了机动战士并投入战场。NEWTYPE少年阿姆罗·雷无意中驾驶上联邦军新开发的机动战士高达，卷入后来被称为“一年战争”中，并与其宿敌夏亚·阿兹纳布尔相遇。 制作人员： 原作：富野由悠季、矢立肇 脚本：星山博之、荒木芳久、松崎健一、山本优 分镜：贞光绅也、藤原良二 ","date":"1979-04-07","objectID":"/anime/gundam/:1:0","tags":null,"title":"机动战士高达","uri":"/anime/gundam/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 高达 Gundam、ガンダム、白色恶魔 2 阿姆罗·雷 李亚宝、李阿宝、アムロ・レイ、Amuro Ray 男 古谷徹 3 夏亚·阿兹纳布尔 红有三、鸭子、马沙 男 池田秀一 4 布莱德·诺亚 林有德、Bright Noah、ブライト・ノア、Buraito Noa 男 鈴置洋孝 5 塞拉·玛斯 アルテイシア・ソム・ダイクン、鸭子妹、阿尔黛西亚·雷姆·戴肯、セイラ・マス、Sayla Mass、鸭妹 女 井上瑤 6 拉拉·辛 娜娜·絲、Lalah Sune、宇宙第一女鬼、ソロモンの亡霊 女 潘恵子 7 马克贝 尿壶、夜壶大佐、马·克贝、马克杯 男 塩沢兼人 8 依","date":"1979-04-07","objectID":"/anime/gundam/:2:0","tags":null,"title":"机动战士高达","uri":"/anime/gundam/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 机动战士高达 1979-04-07 43 bilibili 2 机动战士Z高达 1985-03-02 50 bilibili 3 机动战士高达ZZ 1986-03-01 47 樱花 4 机动战士高达0080 口袋里的战争 1989-03-25 6 bilibili 5 机动战士高达0083 星尘的回忆 1991-05-22 13 bilibili 6 机动战士V高达 1993-04-02 51 其它 7 机动武斗传G高达 1994-04-01 49 bilibili 8 新机动战记高达W 1995-04-07 49 bilibili 9 机动战","date":"1979-04-07","objectID":"/anime/gundam/:3:0","tags":null,"title":"机动战士高达","uri":"/anime/gundam/"},{"categories":null,"content":"MAD ","date":"1979-04-07","objectID":"/anime/gundam/:4:0","tags":null,"title":"机动战士高达","uri":"/anime/gundam/"},{"categories":null,"content":"《哆啦A梦》（日语：ドラえもん；英语：Doraemon；旧译叮当 / 小叮当）是日本漫画家藤本弘（笔名藤子·F·不二雄）创作的漫画。\n漫画叙述了一只来自22世纪的猫型机器人——哆啦A梦，受主人野比世修的托付，回到20世纪，借助从四维口袋里拿出来的各种未来道具，\n来帮助世修的高祖父——小学生野比大雄化解身边的种种困难问题，以及生活中和妈妈野比玉子、身边的小伙伴静香、胖虎、小夫发生的轻松幽默搞笑感人的故事。","date":"1979-04-02","objectID":"/anime/doraemon/","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"简介 《哆啦A梦》（日语：ドラえもん；英语：Doraemon；旧译叮当 / 小叮当）是日本漫画家藤本弘（笔名藤子·F·不二雄）创作的漫画。 漫画叙述了一只来自22世纪的猫型机器人——哆啦A梦，受主人野比世修的托付，回到20世纪，借助从四维口袋里拿出来的各种未来道具， 来帮助世修的高祖父——小学生野比大雄化解身边的种种困难问题，以及生活中和妈妈野比玉子、身边的小伙伴静香、胖虎、小夫发生的轻松幽默搞笑感人的故事。 制作人员： 原作：藤子·F·不二雄 导演：芝山努、原平随了 脚本：神户一彦、加藤公平、川崎良、楠部工、岸间信明 ","date":"1979-04-02","objectID":"/anime/doraemon/:1:0","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哆啦A梦 机器猫、多拉A梦、小叮当、叮当、阿蒙、Doraemon、ドラえもん、どらえもん、Doraemon 男 水田わさび 2 野比大雄 叶大雄、野比太、康夫、大宝、Nobita Nobi、野比 のび太、のび のびた、Nobi Nobita 男 大原めぐみ 3 源静香 陈静香、静怡、静儿、静子、宜静、静静、小静、Shizuka Minamoto、源 静香、みなもと しずか、Minamoto Shizuka 女 かかずゆみ 4 刚田武 刚田武志、刚田胖虎、Takeshi Goda、剛田 武、ごうだ たけし、Gouda Takeshi、ジャイアン／Giant／技","date":"1979-04-02","objectID":"/anime/doraemon/:2:0","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哆啦A梦 大山版 1979-04-02 1787 bilibili 2 哆啦A梦 2005-04-15 * bilibili 3 哆啦A梦新剧场版 2006-03-04 10 bilibili 4 哆啦A梦：伴我同行 2014-08-08 1 bilibili ","date":"1979-04-02","objectID":"/anime/doraemon/:3:0","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"MAD ","date":"1979-04-02","objectID":"/anime/doraemon/:4:0","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"　　女孩尚未出生，就在妈妈的肚子里和爸爸交上了朋友，爸爸时常逗得她哈哈大笑。而在出生后，她更是从爸爸那儿得到了许多快乐，度过愉快无忧的童年。 \n　　女孩渐渐长大，和妈妈之间的矛盾多了起来，慢慢老去的爸爸也不再是她快乐的源泉，爸爸和她同时被孤独笼罩。遇到心中的白马王子后，女孩找到人生的另一番乐趣，远离了爸爸妈妈。结婚生子时，女孩意识到爸爸妈妈是生命中的不可或缺。","date":"1978-01-01","objectID":"/anime/oh_my_darling/","tags":null,"title":"哦，亲爱的","uri":"/anime/oh_my_darling/"},{"categories":null,"content":"简介 女孩尚未出生，就在妈妈的肚子里和爸爸交上了朋友，爸爸时常逗得她哈哈大笑。而在出生后，她更是从爸爸那儿得到了许多快乐，度过愉快无忧的童年。 女孩渐渐长大，和妈妈之间的矛盾多了起来，慢慢老去的爸爸也不再是她快乐的源泉，爸爸和她同时被孤独笼罩。遇到心中的白马王子后，女孩找到人生的另一番乐趣，远离了爸爸妈妈。结婚生子时，女孩意识到爸爸妈妈是生命中的不可或缺。 ","date":"1978-01-01","objectID":"/anime/oh_my_darling/:1:0","tags":null,"title":"哦，亲爱的","uri":"/anime/oh_my_darling/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哦，亲爱的 1978-01-01 07:25 bilibili ","date":"1978-01-01","objectID":"/anime/oh_my_darling/:2:0","tags":null,"title":"哦，亲爱的","uri":"/anime/oh_my_darling/"},{"categories":null,"content":"       茫茫宇宙中一颗无名星球上，生活着体形悬殊的两种生物。占主导地位的是戴格斯人，他们身形巨大，拥有极高的文明和智慧，可以使精神摆脱肉体自在游弋；与之相对的是奥姆斯人，他们具有地球人的外表和身形，社会形态原始落后，在戴格斯人面前有如蝼蚁，于是当仁不让成为这些巨人的奴隶和玩物。奥姆斯人具有顽强的生命力和繁殖能力，他们的数量与日俱增，造成了统治者的困扰。于是，一场针对奥姆斯人的剿灭战随即展开。这本是一场微不足道的如同剿灭害虫的行动，但一个不起眼的奥姆斯人改变了双方的格局。泰尔是被一个戴格斯女孩豢养的奥姆斯男性宠物，他通过主人的教学机器学到了戴格斯人先进的科学文化知识。偶然机会，泰尔逃离戴格斯家庭，成为了领导奥姆斯人对抗统治者的领袖…… \n　　本片荣获1973年戛纳电影节特别奖。","date":"1973-05-01","objectID":"/anime/fantastic_planet/","tags":null,"title":"原始星球","uri":"/anime/fantastic_planet/"},{"categories":null,"content":"简介 茫茫宇宙中一颗无名星球上，生活着体形悬殊的两种生物。占主导地位的是戴格斯人，他们身形巨大，拥有极高的文明和智慧，可以使精神摆脱肉体自在游弋；与之相对的是奥姆斯人，他们具有地球人的外表和身形，社会形态原始落后，在戴格斯人面前有如蝼蚁，于是当仁不让成为这些巨人的奴隶和玩物。奥姆斯人具有顽强的生命力和繁殖能力，他们的数量与日俱增，造成了统治者的困扰。于是，一场针对奥姆斯人的剿灭战随即展开。这本是一场微不足道的如同剿灭害虫的行动，但一个不起眼的奥姆斯人改变了双方的格局。泰尔是被一个戴格斯女孩豢养的奥姆斯男性宠物，他通过主人的教学机器学到了戴格斯人先进的科学文化知识。偶然机会，泰尔逃离戴格斯家庭，","date":"1973-05-01","objectID":"/anime/fantastic_planet/:1:0","tags":null,"title":"原始星球","uri":"/anime/fantastic_planet/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 原始星球 1973-05-01 1 樱花 ","date":"1973-05-01","objectID":"/anime/fantastic_planet/:2:0","tags":null,"title":"原始星球","uri":"/anime/fantastic_planet/"},{"categories":null,"content":"影片以《西游记》中孙悟空从诞生到大闹天宫这一段的经历为主要内容。\n\n1961年《大闹天宫》上集正式上映，在国内引起轰动。1964年，下集拍摄完成后由于文艺政策的变化，影片的全本没能够上映。1978年全本的《大闹天宫》终于得以上映。\n\n2004年，在《大闹天宫》问世40周年之际，上海美术电影制片厂特意推出了影片的珍藏版DVD，全长85分钟，是1964年放映的一个影院版。2009年网络上出现了基于40周年版的影迷修复版，其图像更加稳定和干净，并且重新插入了40周年纪念版里缺失的20多分钟内容，对影片中的声音也进行了修正。","date":"1961-12-01","objectID":"/anime/the_monkey_king/","tags":null,"title":"大闹天宫","uri":"/anime/the_monkey_king/"},{"categories":null,"content":"简介 影片以《西游记》中孙悟空从诞生到大闹天宫这一段的经历为主要内容。 1961年《大闹天宫》上集正式上映，在国内引起轰动。1964年，下集拍摄完成后由于文艺政策的变化，影片的全本没能够上映。1978年全本的《大闹天宫》终于得以上映。 2004年，在《大闹天宫》问世40周年之际，上海美术电影制片厂特意推出了影片的珍藏版DVD，全长85分钟，是1964年放映的一个影院版。2009年网络上出现了基于40周年版的影迷修复版，其图像更加稳定和干净，并且重新插入了40周年纪念版里缺失的20多分钟内容，对影片中的声音也进行了修正。 制作人员： 导演：万嘉综 脚本：李克弱 音乐：上海电影乐团、吴应钜、张鑫海","date":"1961-12-01","objectID":"/anime/the_monkey_king/:1:0","tags":null,"title":"大闹天宫","uri":"/anime/the_monkey_king/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 孙悟空 斗战胜佛、齐天大圣、花果山美猴王、孙行者、Monkey King、孫悟空、そん ごくう、Son Gokuu、猴哥，弼马温，大师兄，心猿，太乙散仙 雄（男） 邱岳峰 2 二郎神 杨戬、显圣二郎真君、清源妙道真君 男 于鼎 3 敖广 男 毕克 4 托塔李天王 托塔天王、李靖 男 于鼎 ","date":"1961-12-01","objectID":"/anime/the_monkey_king/:2:0","tags":null,"title":"大闹天宫","uri":"/anime/the_monkey_king/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 大闹天宫 1961-12-01 01:52:34 bilibili ","date":"1961-12-01","objectID":"/anime/the_monkey_king/:3:0","tags":null,"title":"大闹天宫","uri":"/anime/the_monkey_king/"},{"categories":null,"content":"本合集收录上美代表性的动画短片，从 1950《谢谢小花猫》到 1998《雪狐》。\n\n最具代表性的有：1955 神笔、1955 乌鸦为什么是黑的、1956 骄傲的将军、1958 猪八戒吃西瓜，1960 小蝌蚪找妈妈、1960 聪明的鸭子、1962 没头脑和不高兴、1963 牧笛、1964 半夜鸡叫、1980 雪孩子、1980 三个和尚、1981 九色鹿、1981 猴子捞月、1982 蛐蛐、1983 鹬蚌相争、1988 不射之射、1993 鹿女。","date":"1950-01-01","objectID":"/anime/shang_mei/","tags":null,"title":"上美动画短片","uri":"/anime/shang_mei/"},{"categories":null,"content":"简介 本合集收录上美代表性的动画短片，从 1950《谢谢小花猫》到 1998《雪狐》。 最具代表性的有：1955 神笔、1955 乌鸦为什么是黑的、1956 骄傲的将军、1958 猪八戒吃西瓜，1960 小蝌蚪找妈妈、1960 聪明的鸭子、1962 没头脑和不高兴、1963 牧笛、1964 半夜鸡叫、1980 雪孩子、1980 三个和尚、1981 九色鹿、1981 猴子捞月、1982 蛐蛐、1983 鹬蚌相争、1988 不射之射、1993 鹿女。 ","date":"1950-01-01","objectID":"/anime/shang_mei/:1:0","tags":null,"title":"上美动画短片","uri":"/anime/shang_mei/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 上美动画短片 1950-01-01 211 下方 ","date":"1950-01-01","objectID":"/anime/shang_mei/:2:0","tags":null,"title":"上美动画短片","uri":"/anime/shang_mei/"},{"categories":null,"content":"本合集收录苏联早期代表性的动画短片，从 1948《七色花》到 1985《了不起的沃瓦》。","date":"1948-01-01","objectID":"/anime/su_lian/","tags":null,"title":"苏联早期动画短片","uri":"/anime/su_lian/"},{"categories":null,"content":"简介 本合集收录苏联早期代表性的动画短片，从 1948《七色花》到 1985《了不起的沃瓦》。 ","date":"1948-01-01","objectID":"/anime/su_lian/:1:0","tags":null,"title":"苏联早期动画短片","uri":"/anime/su_lian/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 苏联早期动画短片 1948-01-01 7 下方 ","date":"1948-01-01","objectID":"/anime/su_lian/:2:0","tags":null,"title":"苏联早期动画短片","uri":"/anime/su_lian/"},{"categories":null,"content":"《猫和老鼠》（Tom and Jerry）是米高梅电影公司于1939年制作的一部动画，该片由威廉·汉纳、约瑟夫·巴伯拉编写，\n弗雷德·昆比制作，首部剧集《甜蜜的家》于1940年2月10日在美国首播。\n\n\n《猫和老鼠》以闹剧为特色，描绘了一对水火不容的冤家：汤姆和杰瑞猫鼠之间的战争，片中的汤姆经常使用狡诈的诡计来对付杰瑞，\n而杰瑞则时常利用汤姆诡计中的漏洞逃脱他的迫害并给予报复。","date":"1940-02-10","objectID":"/anime/tom_and_jerry/","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"简介 《猫和老鼠》（Tom and Jerry）是米高梅电影公司于1939年制作的一部动画，该片由威廉·汉纳、约瑟夫·巴伯拉编写，弗雷德·昆比制作，首部剧集《甜蜜的家》于1940年2月10日在美国首播。 《猫和老鼠》以闹剧为特色，描绘了一对水火不容的冤家：汤姆和杰瑞猫鼠之间的战争，片中的汤姆经常使用狡诈的诡计来对付杰瑞，而杰瑞则时常利用汤姆诡计中的漏洞逃脱他的迫害并给予报复。 制作人员： 导演：威廉·汉纳、约瑟夫·巴伯拉 音乐：斯科特·布拉德利 製作：华纳兄弟动画 ","date":"1940-02-10","objectID":"/anime/tom_and_jerry/:1:0","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 汤姆 Jasper、Thomas、Tom、汤姆猫 男猫 William Hanna 2 杰瑞 Jerry、Jinx、杰瑞鼠 男鼠 3 斯派克 雄 4 泰克 雄 5 泰菲 塔菲、尼布斯、Nibbles Mouse 雄 ","date":"1940-02-10","objectID":"/anime/tom_and_jerry/:2:0","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 猫和老鼠 1940-02-10 164 下方 ","date":"1940-02-10","objectID":"/anime/tom_and_jerry/:3:0","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"MAD ","date":"1940-02-10","objectID":"/anime/tom_and_jerry/:4:0","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"本合集收录了迪斯尼米老鼠的早期彩色动画短片，从 1935《乐团音乐会》到 1953《简单的事》。","date":"1935-02-23","objectID":"/anime/mickey_color/","tags":null,"title":"米老鼠的彩色动画片生涯","uri":"/anime/mickey_color/"},{"categories":null,"content":"简介 本合集收录了迪斯尼米老鼠的早期彩色动画短片，从 1935《乐团音乐会》到 1953《简单的事》。 ","date":"1935-02-23","objectID":"/anime/mickey_color/:1:0","tags":null,"title":"米老鼠的彩色动画片生涯","uri":"/anime/mickey_color/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 乐团音乐会 1935-02-23 47 下方 ","date":"1935-02-23","objectID":"/anime/mickey_color/:2:0","tags":null,"title":"米老鼠的彩色动画片生涯","uri":"/anime/mickey_color/"},{"categories":null,"content":"本合集收录哥伦比亚影业早期代表性的动画短片，从 1934《Holiday Land》到 1957《Trees and Jamaica Daddy》。","date":"1934-11-11","objectID":"/anime/columbia/","tags":null,"title":"哥伦比亚早期动画短片","uri":"/anime/columbia/"},{"categories":null,"content":"简介 本合集收录哥伦比亚影业早期代表性的动画短片，从 1934《Holiday Land》到 1957《Trees and Jamaica Daddy》。 ","date":"1934-11-11","objectID":"/anime/columbia/:1:0","tags":null,"title":"哥伦比亚早期动画短片","uri":"/anime/columbia/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哥伦比亚早期动画短片 1934-11-11 14 下方 ","date":"1934-11-11","objectID":"/anime/columbia/:2:0","tags":null,"title":"哥伦比亚早期动画短片","uri":"/anime/columbia/"},{"categories":null,"content":"本合集收录了迪斯尼唐老鸭的早期动画短片，从 1934《聪明的小母鸡》到 1950《海滩上的蜜蜂》。","date":"1934-06-09","objectID":"/anime/donald_duck/","tags":null,"title":"唐老鸭编年史","uri":"/anime/donald_duck/"},{"categories":null,"content":"简介 本合集收录了迪斯尼唐老鸭的早期动画短片，从 1934《聪明的小母鸡》到 1950《海滩上的蜜蜂》。 ","date":"1934-06-09","objectID":"/anime/donald_duck/:1:0","tags":null,"title":"唐老鸭编年史","uri":"/anime/donald_duck/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 唐老鸭 唐纳德·方特罗伊·达克、Donald Fauntleroy Duck、ドナルドダック 公 ","date":"1934-06-09","objectID":"/anime/donald_duck/:2:0","tags":null,"title":"唐老鸭编年史","uri":"/anime/donald_duck/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 唐老鸭编年史 1934-06-09 100 下方 ","date":"1934-06-09","objectID":"/anime/donald_duck/:3:0","tags":null,"title":"唐老鸭编年史","uri":"/anime/donald_duck/"},{"categories":null,"content":"弗莱舍出品，1933~1957年共 231 集。","date":"1933-07-14","objectID":"/anime/popeye_the_sailor/","tags":null,"title":"大力水手","uri":"/anime/popeye_the_sailor/"},{"categories":null,"content":"简介 弗莱舍出品，1933~1957年共 231 集。 ","date":"1933-07-14","objectID":"/anime/popeye_the_sailor/:1:0","tags":null,"title":"大力水手","uri":"/anime/popeye_the_sailor/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 大力水手 Popeye、普派、波派、波佩、波比、波派、ポパイ 男 ","date":"1933-07-14","objectID":"/anime/popeye_the_sailor/:2:0","tags":null,"title":"大力水手","uri":"/anime/popeye_the_sailor/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 大力水手 1933-07-14 231 bilibili ","date":"1933-07-14","objectID":"/anime/popeye_the_sailor/:3:0","tags":null,"title":"大力水手","uri":"/anime/popeye_the_sailor/"},{"categories":null,"content":"本合集收录米高梅早期代表性的动画短片，从 1930《Fiddlesticks》到 1967《The Bear That Wasn't》。包括两部奥斯卡最佳短片：1940 The Milky Way、1965 The Dot and the Line。","date":"1930-08-16","objectID":"/anime/mgm/","tags":null,"title":"米高梅早期动画短片","uri":"/anime/mgm/"},{"categories":null,"content":"简介 本合集收录米高梅早期代表性的动画短片，从 1930《Fiddlesticks》到 1967《The Bear That Wasn’t》。包括两部奥斯卡最佳短片：1940 The Milky Way、1965 The Dot and the Line。 ","date":"1930-08-16","objectID":"/anime/mgm/:1:0","tags":null,"title":"米高梅早期动画短片","uri":"/anime/mgm/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 米高梅早期动画短片 1930-08-16 134 下方 ","date":"1930-08-16","objectID":"/anime/mgm/:2:0","tags":null,"title":"米高梅早期动画短片","uri":"/anime/mgm/"},{"categories":null,"content":"在30年代，美国动画有两大对立的阵营，西海岸（好莱坞）风格的迪士尼，东海岸（纽约）风格的弗莱舍（后来并入派拉蒙公司）。\n\n本合集收录弗莱舍早期代表性的动画短片，从 1930《Dizzy Dishes》 到 1934《poor cinderella》。","date":"1930-08-09","objectID":"/anime/fleischer/","tags":null,"title":"弗莱舍早期动画短片","uri":"/anime/fleischer/"},{"categories":null,"content":"简介 在30年代，美国动画有两大对立的阵营，西海岸（好莱坞）风格的迪士尼，东海岸（纽约）风格的弗莱舍（后来并入派拉蒙公司）。 本合集收录弗莱舍早期代表性的动画短片，从 1930《Dizzy Dishes》 到 1934《poor cinderella》。 ","date":"1930-08-09","objectID":"/anime/fleischer/:1:0","tags":null,"title":"弗莱舍早期动画短片","uri":"/anime/fleischer/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 弗莱舍早期动画短片 1930-08-09 7 下方 ","date":"1930-08-09","objectID":"/anime/fleischer/:2:0","tags":null,"title":"弗莱舍早期动画短片","uri":"/anime/fleischer/"},{"categories":null,"content":"本合集收录环球影业早期代表性的动画短片，从 1930《Spooks》 到 1954 《I'm Cold》。","date":"1930-07-14","objectID":"/anime/universal/","tags":null,"title":"环球早期动画短片","uri":"/anime/universal/"},{"categories":null,"content":"简介 本合集收录环球影业早期代表性的动画短片，从 1930《Spooks》 到 1954 《I’m Cold》。 ","date":"1930-07-14","objectID":"/anime/universal/:1:0","tags":null,"title":"环球早期动画短片","uri":"/anime/universal/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 环球早期动画短片 1930-07-14 3 下方 ","date":"1930-07-14","objectID":"/anime/universal/:2:0","tags":null,"title":"环球早期动画短片","uri":"/anime/universal/"},{"categories":null,"content":"本合集收录华纳早期代表性的动画短片，包括乐一通（Looney Tunes）系列和欢乐旋律（Merrie Melodies）系列。\n\n从 1930 乐一通首作《Sinkin' in the Bathtub》到 1955《One Froggy Evening》。","date":"1930-04-19","objectID":"/anime/warner_bros/","tags":null,"title":"华纳早期动画短片","uri":"/anime/warner_bros/"},{"categories":null,"content":"简介 本合集收录华纳早期代表性的动画短片，包括乐一通（Looney Tunes）系列和欢乐旋律（Merrie Melodies）系列。 从 1930 乐一通首作《Sinkin’ in the Bathtub》到 1955《One Froggy Evening》。 ","date":"1930-04-19","objectID":"/anime/warner_bros/:1:0","tags":null,"title":"华纳早期动画短片","uri":"/anime/warner_bros/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 华纳早期动画短片 1930-04-1 165 下方 ","date":"1930-04-19","objectID":"/anime/warner_bros/:2:0","tags":null,"title":"华纳早期动画短片","uri":"/anime/warner_bros/"},{"categories":null,"content":"本合集是迪斯尼在 1929-1939 十年期间推出的一系列动画短片，包括几部奥斯卡最佳短片：1932花与树、1933 三只小猪、1934 龟兔赛跑、1935 三只孤儿猫、1936 乡巴佬、1937 老磨坊、1939 丑小鸭。","date":"1929-08-29","objectID":"/anime/silly_symphony/","tags":null,"title":"迪士尼糊涂交响曲","uri":"/anime/silly_symphony/"},{"categories":null,"content":"简介 本合集是迪斯尼在 1929-1939 十年期间推出的一系列动画短片，包括几部奥斯卡最佳短片：1932花与树、1933 三只小猪、1934 龟兔赛跑、1935 三只孤儿猫、1936 乡巴佬、1937 老磨坊、1939 丑小鸭。 ","date":"1929-08-29","objectID":"/anime/silly_symphony/:1:0","tags":null,"title":"迪士尼糊涂交响曲","uri":"/anime/silly_symphony/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 迪士尼糊涂交响曲 1929-08-29 75 下方 ","date":"1929-08-29","objectID":"/anime/silly_symphony/:2:0","tags":null,"title":"迪士尼糊涂交响曲","uri":"/anime/silly_symphony/"},{"categories":null,"content":"本合集收录了从1928年~1935年米老鼠所有早期黑白动画作品。1928年【汽船威利】（Steamboat Willie）被製作成有声卡通，本片成为影史上第一部有声卡通影片，【汽船威利】的成功使得华特迪士尼声名大噪，后来华特迪士尼还因为创造出米奇老鼠而获得奥斯卡金像奖的特别荣誉奖呢。在1935年的【米奇音乐会】（The Band Concert）中米奇首度以彩色面貌与大家见面！","date":"1928-11-18","objectID":"/anime/mickey/","tags":null,"title":"米老鼠的黑白动画片生涯","uri":"/anime/mickey/"},{"categories":null,"content":"简介 本合集收录了从1928年~1935年米老鼠所有早期黑白动画作品。1928年【汽船威利】（Steamboat Willie）被製作成有声卡通，本片成为影史上第一部有声卡通影片，【汽船威利】的成功使得华特迪士尼声名大噪，后来华特迪士尼还因为创造出米奇老鼠而获得奥斯卡金像奖的特别荣誉奖呢。在1935年的【米奇音乐会】（The Band Concert）中米奇首度以彩色面貌与大家见面！ 制作人员： 製作：迪士尼电影公司 动画制作：华特·迪士尼动画工作室 ","date":"1928-11-18","objectID":"/anime/mickey/:1:0","tags":null,"title":"米老鼠的黑白动画片生涯","uri":"/anime/mickey/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 米老鼠的黑白动画片生涯 1928-11-18 20 bilibili ","date":"1928-11-18","objectID":"/anime/mickey/:2:0","tags":null,"title":"米老鼠的黑白动画片生涯","uri":"/anime/mickey/"},{"categories":null,"content":"2006年法国昂西评选的100部短篇动画作品","date":"1908-08-17","objectID":"/anime/1908/","tags":null,"title":"动画的世纪·100 部作品","uri":"/anime/1908/"},{"categories":null,"content":"简介 2006年法国昂西评选的100部短篇动画作品。 ","date":"1908-08-17","objectID":"/anime/1908/:1:0","tags":null,"title":"动画的世纪·100 部作品","uri":"/anime/1908/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 动画的世纪·100 部作品 1908-08-17 100 下方 ","date":"1908-08-17","objectID":"/anime/1908/:2:0","tags":null,"title":"动画的世纪·100 部作品","uri":"/anime/1908/"},{"categories":null,"content":"早期的标志性动画作品，从 1892 第一部动画《可怜的比埃洛》到 1928 第一部有声动画《汽船威利号》。","date":"1892-10-28","objectID":"/anime/1892/","tags":null,"title":"动画的起源","uri":"/anime/1892/"},{"categories":null,"content":"简介 早期的标志性动画作品，从 1892 第一部动画《可怜的比埃洛》到 1928 第一部有声动画《汽船威利号》。 ","date":"1892-10-28","objectID":"/anime/1892/:1:0","tags":null,"title":"动画的起源","uri":"/anime/1892/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 动画的起源 1892-10-28 12 下方 ","date":"1892-10-28","objectID":"/anime/1892/:2:0","tags":null,"title":"动画的起源","uri":"/anime/1892/"}]