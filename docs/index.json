[{"categories":null,"content":"每个人都有着不让任何人所看见的一面——\n这是一个世界各国在暗地里展开激烈情报战的时代。东国和西国已经处于冷战状态长达十余年之久。\n隶属于西国情报局对东科（WISE）的精英间谍“黄昏”，为了调查东国国家统一党总裁多诺万·德斯蒙这一威胁东西和平的危险人物的战争计划，黄昏被指派了一个绝密的任务。\n这个任务称之为“枭”作战。\n任务的内容是在一周内组建成一个家庭，潜入德斯蒙的儿子就读的名校，并解决掉德斯蒙。\n但是，黄昏所遇到的“女儿”是能读懂内心的超能力者，“妻子”则是暗杀者。三人为了彼此的利益而成为了一家人，并决定在隐藏真实身份的情况下共同生活。\n世界的和平被托付给了这个意外频出的临时家庭。","date":"2022-04-09","objectID":"/anime/spyfamily/","tags":null,"title":"间谍过家家","uri":"/anime/spyfamily/"},{"categories":null,"content":"简介 每个人都有着不让任何人所看见的一面—— 这是一个世界各国在暗地里展开激烈情报战的时代。东国和西国已经处于冷战状态长达十余年之久。 隶属于西国情报局对东科（WISE）的精英间谍“黄昏”，为了调查东国国家统一党总裁多诺万·德斯蒙这一威胁东西和平的危险人物的战争计划，黄昏被指派了一个绝密的任务。 这个任务称之为“枭”作战。 任务的内容是在一周内组建成一个家庭，潜入德斯蒙的儿子就读的名校，并解决掉德斯蒙。 但是，黄昏所遇到的“女儿”是能读懂内心的超能力者，“妻子”则是暗杀者。三人为了彼此的利益而成为了一家人，并决定在隐藏真实身份的情况下共同生活。 世界的和平被托付给了这个意外频出的临时家庭。 制","date":"2022-04-09","objectID":"/anime/spyfamily/:1:0","tags":null,"title":"间谍过家家","uri":"/anime/spyfamily/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 黄昏 / 罗伊德·弗杰 Loid Forger、Twilight 男 江口拓也 2 尤尔·布莱尔 Yor Briar、いばら姫 女 早見沙織 3 阿妮亚 阿尼亚、安妮亞、Anya 女 種﨑敦美 4 达米安·戴斯蒙德 Damian Desmond 男 藤原夏海 5 贝琪·布莱克贝尔 Becky Blackbell 女 加藤英美里 6 亨利·亨德森 Henry Henderson 男 山路和弘 7 尤里·布莱尔 Yuri Briar 男 小野賢章 8 弗兰基·弗兰克林 Franky Franklin 男 吉野裕行 ","date":"2022-04-09","objectID":"/anime/spyfamily/:2:0","tags":null,"title":"间谍过家家","uri":"/anime/spyfamily/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 间谍过家家 2022-04-09 12 bilibili 2 间谍过家家 第二部分 2022-10-01 13 bilibili ","date":"2022-04-09","objectID":"/anime/spyfamily/:3:0","tags":null,"title":"间谍过家家","uri":"/anime/spyfamily/"},{"categories":null,"content":" 第 场周赛第 4 题 ","date":"2022-03-12","objectID":"/leetcode/2203/:0:0","tags":null,"title":"2203：得到要求路径的最小带权子图（★★★）","uri":"/leetcode/2203/"},{"categories":null,"content":"题目 给你一个整数 n ，它表示一个 带权有向 图的节点数，节点编号为 0 到 n - 1 。 同时给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi, weighti] ，表示从 fromi 到 toi 有一条边权为 weighti 的 有向 边。 最后，给你三个 互不相同 的整数 src1 ，src2 和 dest ，表示图中三个不同的点。 请你从图中选出一个 边权和最小 的子图，使得从 src1 和 src2 出发，在这个子图中，都 可以 到达 dest 。 如果这样的子图不存在，请返回 -1 。 子图 中的点和边都应该属于原图的一部分。子图的边权和定","date":"2022-03-12","objectID":"/leetcode/2203/:1:0","tags":null,"title":"2203：得到要求路径的最小带权子图（★★★）","uri":"/leetcode/2203/"},{"categories":null,"content":"分析 最终的子图一定是三岔路的形式（可以反证），而且由三条最短路组成。 因此遍历每个节点 x，使三条最短路之和最小即可。 注意是求所有节点 x 到 dest 的最短路，而不是求 dest 到所有节点的最短路。 一个巧妙的方法是将边全部反向，将问题转为求 dest 到所有节点的最短路。 ","date":"2022-03-12","objectID":"/leetcode/2203/:2:0","tags":null,"title":"2203：得到要求路径的最小带权子图（★★★）","uri":"/leetcode/2203/"},{"categories":null,"content":"解答 def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -\u003e int: def dij(root, nxt): d, pq = defaultdict(lambda: float('inf')), [(0, root)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, w2 in nxt[u]: if v not in d: heappush(pq, (w+w2, v)) return ","date":"2022-03-12","objectID":"/leetcode/2203/:3:0","tags":null,"title":"2203：得到要求路径的最小带权子图（★★★）","uri":"/leetcode/2203/"},{"categories":null,"content":" 第 场周赛第 4 题 ","date":"2022-03-06","objectID":"/leetcode/2197/:0:0","tags":null,"title":"2197：替换数组中的非互质数（★★）","uri":"/leetcode/2197/"},{"categories":null,"content":"题目 给你一个整数数组 nums 。请你对数组执行下述操作： 从 nums 中找出 任意 两个 相邻 的 非互质 数。 如果不存在这样的数，终止 这一过程。 否则，删除这两个数，并 替换 为它们的 最小公倍数（Least Common Multiple，LCM）。 只要还能找出两个相邻的非互质数就继续 重复 这一过程。 返回修改后得到的 最终 数组。可以证明的是，以 任意 顺序替换相邻的非互质数都可以得到相同的结果。 生成的测试用例可以保证最终数组中的值 小于或者等于 10^8 。 两个数字 x 和 y 满足 非互质数 的条件是：GCD(x, y) \u003e 1 ，其中 GCD(x, y) 是 x ","date":"2022-03-06","objectID":"/leetcode/2197/:1:0","tags":null,"title":"2197：替换数组中的非互质数（★★）","uri":"/leetcode/2197/"},{"categories":null,"content":"分析 因为顺序不影响，所以可以贪心操作。 遍历 nums，每轮将所有能替换的替换到。注意到这种策略下，替换只会发生在末尾，因此可以用栈。 ","date":"2022-03-06","objectID":"/leetcode/2197/:2:0","tags":null,"title":"2197：替换数组中的非互质数（★★）","uri":"/leetcode/2197/"},{"categories":null,"content":"解答 def replaceNonCoprimes(self, nums: List[int]) -\u003e List[int]: stack = [] for num in nums: stack.append(num) while len(stack)\u003e1 and gcd(stack[-2], stack[-1])\u003e1: stack.append(lcm(stack.pop(), stack.pop())) return stack 396 ms ","date":"2022-03-06","objectID":"/leetcode/2197/:3:0","tags":null,"title":"2197：替换数组中的非互质数（★★）","uri":"/leetcode/2197/"},{"categories":null,"content":" 第 场周赛第 4 题 ","date":"2022-03-01","objectID":"/leetcode/2192/:0:0","tags":null,"title":"2192：有向无环图中一个节点的所有祖先（★★）","uri":"/leetcode/2192/"},{"categories":null,"content":"题目 给你一个正整数 n ，它表示一个 有向无环图 中节点的数目，节点编号为 0 到 n - 1 （包括两者）。 给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi] 表示图中一条从 fromi 到 toi 的单向边。 请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。 如果 u 通过一系列边，能够到达 v ，那么我们称节点 u 是节点 v 的 祖先 节点。 示例 1： 输入：n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6]","date":"2022-03-01","objectID":"/leetcode/2192/:1:0","tags":null,"title":"2192：有向无环图中一个节点的所有祖先（★★）","uri":"/leetcode/2192/"},{"categories":null,"content":"分析 有向无环图可以直接递归。 ","date":"2022-03-01","objectID":"/leetcode/2192/:2:0","tags":null,"title":"2192：有向无环图中一个节点的所有祖先（★★）","uri":"/leetcode/2192/"},{"categories":null,"content":"解答 def getAncestors(self, n: int, edges: List[List[int]]) -\u003e List[List[int]]: @lru_cache(None) def dfs(u): return sorted({vv for v in nxt[u] for vv in dfs(v)+[v]}) nxt = defaultdict(list) for v, u in edges: nxt[u].append(v) return [dfs(i) for i in range(n)] 164 ms ","date":"2022-03-01","objectID":"/leetcode/2192/:3:0","tags":null,"title":"2192：有向无环图中一个节点的所有祖先（★★）","uri":"/leetcode/2192/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2022-02-24","objectID":"/leetcode/2183/:0:0","tags":null,"title":"2183：统计可以被 K 整除的下标对数目（★★★）","uri":"/leetcode/2183/"},{"categories":null,"content":"题目 给你一个下标从 0 开始、长度为 n 的整数数组 nums 和一个整数 k ，返回满足下述条件的下标对 (i, j) 的数目： 0 \u003c= i \u003c j \u003c= n - 1 且 nums[i] * nums[j] 能被 k 整除。 示例 1： 输入：nums = [1,2,3,4,5], k = 2 输出：7 解释： 共有 7 对下标的对应积可以被 2 整除： (0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4) 它们的积分别是 2、4、6、8、10、12 和 20 。 其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15","date":"2022-02-24","objectID":"/leetcode/2183/:1:0","tags":null,"title":"2183：统计可以被 K 整除的下标对数目（★★★）","uri":"/leetcode/2183/"},{"categories":null,"content":"分析 遍历所有下标对时间复杂度高。注意到 nums[i] 重要的是和 k 的公共因子，假如将 nums[i] 替换为 nums[i] 和 k 的最大公约数， 那么结果不会改变。 因此可以将 nums 替换后得到一个计数器 ct，注意到 k 的因子最多 $O(\\sqrt k)$ 个，那么二重循环即可。 注意当 x 满足 x*x%k==0 时，对应的下标对是 ct[x] * (ct[x]-1)//2 个 ","date":"2022-02-24","objectID":"/leetcode/2183/:2:0","tags":null,"title":"2183：统计可以被 K 整除的下标对数目（★★★）","uri":"/leetcode/2183/"},{"categories":null,"content":"解答 def countPairs(self, nums: List[int], k: int) -\u003e int: ct = Counter(gcd(num, k) for num in nums) return sum(ct[x]*(ct[y]-(x==y)) for x in ct for y in ct if x*y%k==0)//2 116 ms ","date":"2022-02-24","objectID":"/leetcode/2183/:3:0","tags":null,"title":"2183：统计可以被 K 整除的下标对数目（★★★）","uri":"/leetcode/2183/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2022-02-20","objectID":"/leetcode/2179/:0:0","tags":null,"title":"2179：统计数组中好三元组数目（★★★）","uri":"/leetcode/2179/"},{"categories":null,"content":"题目 给你两个下标从 0 开始且长度为 n 的整数数组 nums1 和 nums2 ，两者都是 [0, 1, …, n - 1] 的 排列 。 好三元组 指的是 3 个 互不相同 的值，且它们在数组 nums1 和 nums2 中出现顺序保持一致。 换句话说，如果我们将 pos1v 记为值 v 在 nums1 中出现的位置，pos2v 为值 v 在 nums2 中的位置， 那么一个好三元组定义为 0 \u003c= x, y, z \u003c= n - 1 ，且 pos1x \u003c pos1y \u003c pos1z 和 pos2x \u003c pos2y \u003c pos2z 都成立的 (x, y, z) 。 请你返回好三元组的 总数","date":"2022-02-20","objectID":"/leetcode/2179/:1:0","tags":null,"title":"2179：统计数组中好三元组数目（★★★）","uri":"/leetcode/2179/"},{"categories":null,"content":"分析 将 nums1 的数映射为在 nums2 中的坐标，得到数组 A，问题转为求 A 中的递增三元组。 遍历每个中间数 y，找前面比 y 小的个数和后面比 y 大的个数即可求得 y 对应的三元组个数。 容易想到维护有序集合，二分查找即可。 ","date":"2022-02-20","objectID":"/leetcode/2179/:2:0","tags":null,"title":"2179：统计数组中好三元组数目（★★★）","uri":"/leetcode/2179/"},{"categories":null,"content":"解答 def goodTriplets(self, nums1: List[int], nums2: List[int]) -\u003e int: from sortedcontainers import SortedList d = {num: i for i, num in enumerate(nums2)} A = [d[num] for num in nums1] res, sl1, sl2 = 0, SortedList(), SortedList(A) for y in A: res += sl1.bisect_left(y)*(len(sl2)-sl2.bisect_right(y)) ","date":"2022-02-20","objectID":"/leetcode/2179/:3:0","tags":null,"title":"2179：统计数组中好三元组数目（★★★）","uri":"/leetcode/2179/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2022-01-27","objectID":"/leetcode/2156/:0:0","tags":null,"title":"2156：查找给定哈希值的子串（★★）","uri":"/leetcode/2156/"},{"categories":null,"content":"题目 给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算： hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + … + val(s[k-1]) * pk-1) mod m. 其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val(‘a’) = 1 到 val(‘z’) = 26 。 给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 k 的 子串 sub ， 满足 hash(sub, power, modulo) ==","date":"2022-01-27","objectID":"/leetcode/2156/:1:0","tags":null,"title":"2156：查找给定哈希值的子串（★★）","uri":"/leetcode/2156/"},{"categories":null,"content":"分析 典型的滚动哈希。 注意这里定义的哈希值在前面的是低位，和一般的滚动哈希相反。 因此考虑将 s 反向，找最后一个满足要求的子串，然后再反向返回即可。 ","date":"2022-01-27","objectID":"/leetcode/2156/:2:0","tags":null,"title":"2156：查找给定哈希值的子串（★★）","uri":"/leetcode/2156/"},{"categories":null,"content":"解答 def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -\u003e str: end, s = None, s[::-1] w, bL = 0, pow(power, k, modulo) for j, char in enumerate(s): w = w*power+ord(char)-ord('a')+1 if j\u003e=k: w -= (ord(s[j-k])-ord('a')+1)*bL w %= modulo if j\u003e=k-1 and w == hashValue: end = j r","date":"2022-01-27","objectID":"/leetcode/2156/:3:0","tags":null,"title":"2156：查找给定哈希值的子串（★★）","uri":"/leetcode/2156/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2021-12-30","objectID":"/leetcode/2115/:0:0","tags":null,"title":"2115：从给定原材料中找到所有可以做出的菜（★★）","uri":"/leetcode/2115/"},{"categories":null,"content":"题目 你有 n 道不同菜的信息。给你一个字符串数组 recipes 和一个二维字符串数组 ingredients 。第 i 道菜的名字为 recipes[i] ， 如果你有它 所有 的原材料 ingredients[i] ，那么你可以 做出 这道菜。一道菜的原材料可能是 另一道 菜， 也就是说 ingredients[i] 可能包含 recipes 中另一个字符串。 同时给你一个字符串数组 supplies ，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。 请你返回你可以做出的所有菜。你可以以 任意顺序 返回它们。 注意两道菜在它们的原材料中可能互相包含。 示例 1： 输入：rec","date":"2021-12-30","objectID":"/leetcode/2115/:1:0","tags":null,"title":"2115：从给定原材料中找到所有可以做出的菜（★★）","uri":"/leetcode/2115/"},{"categories":null,"content":"分析 将材料和菜看作顶点，菜对材料的依赖关系看作边，那么就是典型的拓扑排序问题。 ","date":"2021-12-30","objectID":"/leetcode/2115/:2:0","tags":null,"title":"2115：从给定原材料中找到所有可以做出的菜（★★）","uri":"/leetcode/2115/"},{"categories":null,"content":"解答 def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -\u003e List[str]: nxt, indeg = defaultdict(list), defaultdict(int) for r, ings in zip(recipes, ingredients): for ing in ings: nxt[ing].append(r) indeg[r] += 1 queue = deque(u for u in supplies if indeg[u]=","date":"2021-12-30","objectID":"/leetcode/2115/:3:0","tags":null,"title":"2115：从给定原材料中找到所有可以做出的菜（★★）","uri":"/leetcode/2115/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2021-12-12","objectID":"/leetcode/2097/:0:0","tags":null,"title":"2097：合法重新排列数对（★★★）","uri":"/leetcode/2097/"},{"categories":null,"content":"题目 给你一个下标从 0 开始的二维整数数组 pairs ，其中 pairs[i] = [starti, endi] 。 如果 pairs 的一个重新排列，满足对每一个下标 i （ 1 \u003c= i \u003c pairs.length ）都有 endi-1 == starti ， 那么我们就认为这个重新排列是 pairs 的一个 合法重新排列 。 请你返回 任意一个 pairs 的合法重新排列。 注意：数据保证至少存在一个 pairs 的合法重新排列。 示例 1： 输入：pairs = [[5,1],[4,5],[11,9],[9,4]] 输出：[[11,9],[9,4],[4,5],[5,1]] 解释","date":"2021-12-12","objectID":"/leetcode/2097/:1:0","tags":null,"title":"2097：合法重新排列数对（★★★）","uri":"/leetcode/2097/"},{"categories":null,"content":"分析 将 start，end 看作点，pair 看作边，那么就是典型的欧拉通路问题。 数据保证存在欧拉通路，那么先找到起始节点 若存在点的出度比入度多 1，该点即是起始节点 否则任一点都可作为起始节点 然后用 Hierholzer 算法即可。 ","date":"2021-12-12","objectID":"/leetcode/2097/:2:0","tags":null,"title":"2097：合法重新排列数对（★★★）","uri":"/leetcode/2097/"},{"categories":null,"content":"解答 def validArrangement(self, pairs: List[List[int]]) -\u003e List[List[int]]: def dfs(u): while nxt[u]: dfs(nxt[u].pop()) stack.append(u) nxt, ct = defaultdict(list), Counter() for u, v in pairs: nxt[u].append(v) ct[u] += 1 ct[v] -= 1 A = [u for u, _ in pairs if ct[u]==1] stack, start = [], A.pop() if A","date":"2021-12-12","objectID":"/leetcode/2097/:3:0","tags":null,"title":"2097：合法重新排列数对（★★★）","uri":"/leetcode/2097/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2021-10-29","objectID":"/leetcode/2050/:0:0","tags":null,"title":"2050：并行课程 III（★★）","uri":"/leetcode/2050/"},{"categories":null,"content":"题目 给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ， 其中 relations[j] = [prevCoursej, nextCoursej] ，表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ， 其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。 请你根据以下规则算出完成所有课程所需要的 最少 月份数： 如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。 你可以 同时 上 任意门课程 。","date":"2021-10-29","objectID":"/leetcode/2050/:1:0","tags":null,"title":"2050：并行课程 III（★★）","uri":"/leetcode/2050/"},{"categories":null,"content":"分析 有向无环图，可以直接递归求课程 u 的最早结束时间。 ","date":"2021-10-29","objectID":"/leetcode/2050/:2:0","tags":null,"title":"2050：并行课程 III（★★）","uri":"/leetcode/2050/"},{"categories":null,"content":"解答 def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -\u003e int: @lru_cache(None) def dfs(u): return max([dfs(v) for v in nxt[u]], default=0)+time[u] nxt = defaultdict(list) for v, u in relations: nxt[u-1].append(v-1) return max(dfs(u) for u in range(n)) 416 ms ","date":"2021-10-29","objectID":"/leetcode/2050/:3:0","tags":null,"title":"2050：并行课程 III（★★）","uri":"/leetcode/2050/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2021-10-24","objectID":"/leetcode/2045/:0:0","tags":null,"title":"2045：到达目的地的第二短时间（★★★）","uri":"/leetcode/2045/"},{"categories":null,"content":"题目 城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示， 其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。 每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 time 分钟。 每个节点都有一个交通信号灯，每 change 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。 所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。 如果信号灯是 绿色 ，你 不能 在节","date":"2021-10-24","objectID":"/leetcode/2045/:1:0","tags":null,"title":"2045：到达目的地的第二短时间（★★★）","uri":"/leetcode/2045/"},{"categories":null,"content":"分析 容易写出求最短路径的 dijkastra 算法，本题要求次短路径，那么同时记录到每个顶点的最短路径和次短路径， 然后修改一下入堆的判定条件即可。 （因为边的权重相等，也可以直接 bfs，将堆改为队列即可，时间更少点。） ","date":"2021-10-24","objectID":"/leetcode/2045/:2:0","tags":null,"title":"2045：到达目的地的第二短时间（★★★）","uri":"/leetcode/2045/"},{"categories":null,"content":"解答 def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -\u003e int: nxt = defaultdict(list) for u, v in edges: nxt[u-1].append(v-1) nxt[v-1].append(u-1) d, pq = defaultdict(list), [(0, 0)] while pq: w, u = heappop(pq) if len(d[u]) == 2 or (len(d[u])==1 and d[u][0]==w): continu","date":"2021-10-24","objectID":"/leetcode/2045/:3:0","tags":null,"title":"2045：到达目的地的第二短时间（★★★）","uri":"/leetcode/2045/"},{"categories":null,"content":" 第 258 场周赛第 4 题 ","date":"2021-09-12","objectID":"/leetcode/2003/:0:0","tags":null,"title":"2003：每棵子树内缺失的最小基因值（★★★）","uri":"/leetcode/2003/"},{"categories":null,"content":"题目 有一棵根节点为 0 的 家族树 ，总共包含 n 个节点，节点编号为 0 到 n - 1 。给你一个下标从 0 开始的整数数组 parents ， 其中 parents[i] 是节点 i 的父节点。由于节点 0 是 根 ，所以 parents[0] == -1 。 总共有 10^5 个基因值，每个基因值都用 闭区间 [1, 10^5] 中的一个整数表示。给你一个下标从 0 开始的整数数组 nums ， 其中 nums[i] 是节点 i 的基因值，且基因值 互不相同 。 请你返回一个数组 ans ，长度为 n ，其中 ans[i] 是以节点 i 为根的子树内 缺失 的 最小 基因值。 节点 ","date":"2021-09-12","objectID":"/leetcode/2003/:1:0","tags":null,"title":"2003：每棵子树内缺失的最小基因值（★★★）","uri":"/leetcode/2003/"},{"categories":null,"content":"分析 显然若基因值 1 不在树中，所有 ans 都为 1。 若基因值 1 在树中，对应的节点为 x，那么除了 x 和 x 的所有祖先，其它的 ans 都为 1。 然后可以递推 x 和 x 的祖先的 ans。 设 y 是 x 的父节点，那么从 ans[x] 遍历找到第一个不存在于 y 的子树的基因集合内的正整数即为 ans[y]。 在求 y 的子树的基因集合时，x 的子树无需再遍历。因此求基因集合的操作总共是 O(N) 时间。 递推 x 和 x 的祖先的 ans 时，ans 是递增的，因此遍历求 ans 的操作总共是 O(S) 时间（本题数据范围 S 等于节点个数范围 N) ","date":"2021-09-12","objectID":"/leetcode/2003/:2:0","tags":null,"title":"2003：每棵子树内缺失的最小基因值（★★★）","uri":"/leetcode/2003/"},{"categories":null,"content":"解答 def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -\u003e List[int]: n = len(nums) if 1 not in nums: return [1] * n nxt = defaultdict(list) for v, u in enumerate(parents): nxt[u].append(v) i = nums.index(1) ans, vis, cur = [1]*n, set(), 1 while i != -1: queue = [i] while queue","date":"2021-09-12","objectID":"/leetcode/2003/:3:0","tags":null,"title":"2003：每棵子树内缺失的最小基因值（★★★）","uri":"/leetcode/2003/"},{"categories":null,"content":" 第 258 场周赛第 3 题 ","date":"2021-09-12","objectID":"/leetcode/2002/:0:0","tags":null,"title":"2002：两个回文子序列长度的最大乘积（★★）","uri":"/leetcode/2002/"},{"categories":null,"content":"题目 给你一个字符串 s ，请你找到 s 中两个 不相交回文子序列 ，使得它们长度的 乘积最大 。 两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 不相交 的。 请你返回两个回文子序列长度可以达到的 最大乘积 。 子序列 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。 如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 回文字符串 。 提示： 2 \u003c= s.length \u003c= 12 s 只含有小写英文字母。 示例 1： 输入：s = \"leetcodecom\"\r输出：9\r解释：最优方案是选择 \"ete\" 作为第一个子序列，\"","date":"2021-09-12","objectID":"/leetcode/2002/:1:0","tags":null,"title":"2002：两个回文子序列长度的最大乘积（★★）","uri":"/leetcode/2002/"},{"categories":null,"content":"分析 数据规模很小，考虑暴力。 遍历所有子序列，如果是回文序列，那么将剩下的位置拼接为 s2，在 s2 中找最长的回文子序列即可。 求最长的回文子序列即是问题 0516 为了方便将 s 拆为两个子序列，可以用状态压缩。 ","date":"2021-09-12","objectID":"/leetcode/2002/:2:0","tags":null,"title":"2002：两个回文子序列长度的最大乘积（★★）","uri":"/leetcode/2002/"},{"categories":null,"content":"解答 def maxProduct(self, s: str) -\u003e int: def cal(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): dp[i][j] = 2 + dp[i + 1][j - 1] if s[i] == s[j] else max(dp[i + 1][j], dp[i][j - 1]) return dp[0][-1] res, n = 0, len(s) for state in ","date":"2021-09-12","objectID":"/leetcode/2002/:3:0","tags":null,"title":"2002：两个回文子序列长度的最大乘积（★★）","uri":"/leetcode/2002/"},{"categories":null,"content":" 第 258 场周赛第 2 题 ","date":"2021-09-12","objectID":"/leetcode/2001/:0:0","tags":null,"title":"2001：可互换矩形的组数（★）","uri":"/leetcode/2001/"},{"categories":null,"content":"题目 用一个下标从 0 开始的二维整数数组 rectangles 来表示 n 个矩形，其中 rectangles[i] = [widthi, heighti] 表示第 i 个矩形的宽度和高度。 如果两个矩形 i 和 j（i \u003c j）的宽高比相同，则认为这两个矩形 可互换 。 更规范的说法是，两个矩形满足 widthi/heighti == widthj/heightj（使用实数除法而非整数除法） ，则认为这两个矩形 可互换 。 计算并返回 rectangles 中有多少对 可互换 矩形。 提示： n == rectangles.length 1 \u003c= n \u003c= 10^5 rectangles[","date":"2021-09-12","objectID":"/leetcode/2001/:1:0","tags":null,"title":"2001：可互换矩形的组数（★）","uri":"/leetcode/2001/"},{"categories":null,"content":"分析 统计每个宽高比对应的矩形个数 x，其中任意两个矩形可互换，即有 x*(x-1)//2 对。 为了避免精度问题，可以用最简分数的形式来代表宽高比。可以用除以最大公约数的方法， 也可以直接调用 fractions.Fraction ","date":"2021-09-12","objectID":"/leetcode/2001/:2:0","tags":null,"title":"2001：可互换矩形的组数（★）","uri":"/leetcode/2001/"},{"categories":null,"content":"解答 def interchangeableRectangles(self, rectangles: List[List[int]]) -\u003e int: ct = Counter() for w, h in rectangles: g = gcd(w, h) ct[(w//g, h//g)]+=1 return sum(v*(v-1)//2 for v in ct.values()) 460 ms ","date":"2021-09-12","objectID":"/leetcode/2001/:3:0","tags":null,"title":"2001：可互换矩形的组数（★）","uri":"/leetcode/2001/"},{"categories":null,"content":" 第 258 场周赛第 1 题 ","date":"2021-09-12","objectID":"/leetcode/2000/:0:0","tags":null,"title":"2000：反转单词前缀（★）","uri":"/leetcode/2000/"},{"categories":null,"content":"题目 给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ， 反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。 如果 word 中不存在字符 ch ，则无需进行任何操作。 例如，如果 word = “abcdefd” 且 ch = “d” ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。 结果字符串将会是 “dcbaefd” 。 返回 结果字符串 。 提示： 1 \u003c= word.length \u003c= 250 word 由小写英文字母组成 ch 是一个小写英文字母 示例 1： 输入：word ","date":"2021-09-12","objectID":"/leetcode/2000/:1:0","tags":null,"title":"2000：反转单词前缀（★）","uri":"/leetcode/2000/"},{"categories":null,"content":"分析 找到 i 后，分割反转再合并即可。 当 ch 不存在时，word.find(ch)=-1，同样适用按位置 i 分割的操作。 ","date":"2021-09-12","objectID":"/leetcode/2000/:2:0","tags":null,"title":"2000：反转单词前缀（★）","uri":"/leetcode/2000/"},{"categories":null,"content":"解答 def reversePrefix(self, word: str, ch: str) -\u003e str: i = word.find(ch) return word[:i+1][::-1] + word[i+1:] 36 ms ","date":"2021-09-12","objectID":"/leetcode/2000/:3:0","tags":null,"title":"2000：反转单词前缀（★）","uri":"/leetcode/2000/"},{"categories":null,"content":" 第 257 场周赛第 4 题 ","date":"2021-09-05","objectID":"/leetcode/1998/:0:0","tags":null,"title":"1998：数组的最大公因数排序（★★★）","uri":"/leetcode/1998/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，你可以在 nums 上执行下述操作 任意次 ： 如果 gcd(nums[i], nums[j]) \u003e 1 ，交换 nums[i] 和 nums[j] 的位置。 其中 gcd(nums[i], nums[j]) 是 nums[i] 和 nums[j] 的最大公因数。 如果能使用上述交换方式将 nums 按 非递减顺序 排列，返回 true ；否则，返回 false 。 提示： 1 \u003c= nums.length \u003c= 3 * 10^4 2 \u003c= nums[i] \u003c= 10^5 示例 1： 输入：nums = [7,21,3]\r输出：true\r解释：可以执行下述操","date":"2021-09-05","objectID":"/leetcode/1998/:1:0","tags":null,"title":"1998：数组的最大公因数排序（★★★）","uri":"/leetcode/1998/"},{"categories":null,"content":"分析 观察发现，只要 a、b 不互质，b、c 不互质，那么 a、b、c 可交换为任意顺序。 将 a、b 不互质看作是顶点 a、b 之间连了一条边。那么只要 a、b 连通，a、b 就可交换。 因此遍历数据范围内的质数 p，将 nums 中 p 的倍数都连通。 最终判断 nums 和 sorted(nums) 相同位置上不同的数是否连通即可。 ","date":"2021-09-05","objectID":"/leetcode/1998/:2:0","tags":null,"title":"1998：数组的最大公因数排序（★★★）","uri":"/leetcode/1998/"},{"categories":null,"content":"解答 def gcdSort(self, nums: List[int]) -\u003e bool: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) M, vis = max(nums)+1, set(nums) f, flags = list(range(M)), [1] * M for p in range(2, M): if flags[p]: for x in range(p * 2, M, p): flags[x] = 0 if x in vis: u","date":"2021-09-05","objectID":"/leetcode/1998/:3:0","tags":null,"title":"1998：数组的最大公因数排序（★★★）","uri":"/leetcode/1998/"},{"categories":null,"content":" 第 257 场周赛第 3 题 ","date":"2021-09-05","objectID":"/leetcode/1997/:0:0","tags":null,"title":"1997：访问完所有房间的第一天（★★）","uri":"/leetcode/1997/"},{"categories":null,"content":"题目 你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。 你每天都会访问一个房间。 最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。 在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定： 假设某一天，你访问 i 号房间。 如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间， 其中 0 \u003c= nextVisit[i] \u003c= i 。 如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天","date":"2021-09-05","objectID":"/leetcode/1997/:1:0","tags":null,"title":"1997：访问完所有房间的第一天（★★）","uri":"/leetcode/1997/"},{"categories":null,"content":"分析 观察发现，第一次访问房间 i 后，跳到房间 j=nextVisit[i]。 然后从 j 到 i 会重复之前第一次从 j 到 i 的过程。之后再移到房间 i+1。 因此考虑递推，令 dp[i] 代表第一次访问房间 i 的日期。那么 第一次从 j 到 i 的过程用了 dp[i]-dp[j] 天\rdp[i+1] = dp[i] + 1 + dp[i] - dp[j] + 1\r= 2*dp[i]-dp[j]+2\r最终 dp[-1] 即为所求。 ","date":"2021-09-05","objectID":"/leetcode/1997/:2:0","tags":null,"title":"1997：访问完所有房间的第一天（★★）","uri":"/leetcode/1997/"},{"categories":null,"content":"解答 def firstDayBeenInAllRooms(self, nextVisit: List[int]) -\u003e int: n, mod = len(nextVisit), 10**9+7 dp = [0] * n for i in range(1, n): dp[i] = 2*dp[i-1]-dp[nextVisit[i-1]]+2 dp[i] %= mod return dp[-1] 228 ms ","date":"2021-09-05","objectID":"/leetcode/1997/:3:0","tags":null,"title":"1997：访问完所有房间的第一天（★★）","uri":"/leetcode/1997/"},{"categories":null,"content":" 第 257 场周赛第 2 题 ","date":"2021-09-05","objectID":"/leetcode/1996/:0:0","tags":null,"title":"1996：游戏中弱角色的数量（★★）","uri":"/leetcode/1996/"},{"categories":null,"content":"题目 你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ， 其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。 更正式地，如果认为角色 i 弱于 存在的另一个角色 j ， 那么 attackj \u003e attacki 且 defensej \u003e defensei 。 返回 弱角色 的数量。 提示： 2 \u003c= properties.length \u003c= 10^5 propertie","date":"2021-09-05","objectID":"/leetcode/1996/:1:0","tags":null,"title":"1996：游戏中弱角色的数量（★★）","uri":"/leetcode/1996/"},{"categories":null,"content":"分析 将角色按攻击排序，若攻击相同则防御较高的排前面。 令 A 代表排序后的防御数组，那么 A[i] 是弱角色等价于后面后面有角色的防御更高，即 A[i]\u003cmax(A[i+1:])。 那么倒序遍历 i 并维护 max(A[i+1:])，即可在 O(N) 时间得到弱角色数量。 ","date":"2021-09-05","objectID":"/leetcode/1996/:2:0","tags":null,"title":"1996：游戏中弱角色的数量（★★）","uri":"/leetcode/1996/"},{"categories":null,"content":"解答 def numberOfWeakCharacters(self, properties: List[List[int]]) -\u003e int: A = sorted(properties, key=lambda x: (x[0],-x[1])) res, M = 0, float('-inf') for _, x in A[::-1]: res += int(x \u003c M) M = max(M, x) return res 时间复杂度 O(N*logN)，600 ms ","date":"2021-09-05","objectID":"/leetcode/1996/:3:0","tags":null,"title":"1996：游戏中弱角色的数量（★★）","uri":"/leetcode/1996/"},{"categories":null,"content":" 第 257 场周赛第 1 题 ","date":"2021-09-05","objectID":"/leetcode/1995/:0:0","tags":null,"title":"1995：统计特殊四元组（★）","uri":"/leetcode/1995/"},{"categories":null,"content":"题目 给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ： nums[a] + nums[b] + nums[c] == nums[d] ，且 a \u003c b \u003c c \u003c d 提示： 4 \u003c= nums.length \u003c= 50 1 \u003c= nums[i] \u003c= 100 示例 1： 输入：nums = [1,2,3,6]\r输出：1\r解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\r示例 2： 输入：nums = [3,3,6,4,5]\r输出：0\r解释：[3,3,6,4,5] 中不","date":"2021-09-05","objectID":"/leetcode/1995/:1:0","tags":null,"title":"1995：统计特殊四元组（★）","uri":"/leetcode/1995/"},{"categories":null,"content":"分析 ","date":"2021-09-05","objectID":"/leetcode/1995/:2:0","tags":null,"title":"1995：统计特殊四元组（★）","uri":"/leetcode/1995/"},{"categories":null,"content":"#1 最简单的就是固定 c 和 d，在 [0, c) 中求和等于 nums[d]-nums[c] 的二元组个数，可以用哈希表。 def countQuadruplets(self, nums: List[int]) -\u003e int: res, n = 0, len(nums) for d in range(n): for c in range(d): ct = Counter() for b in range(c): res += ct[nums[d]-nums[c]-nums[b]] ct[nums[b]] += 1 return res 时间复杂度 O(N^3)，628 ms ","date":"2021-09-05","objectID":"/leetcode/1995/:2:1","tags":null,"title":"1995：统计特殊四元组（★）","uri":"/leetcode/1995/"},{"categories":null,"content":"#2 注意到数据范围很小，所以考虑直接统计 nums[:d] 中的 {三元组的和: 三元组的个数} 哈希表。 nums[:i+1] 的三元组计数显然可以由 nums[i] 和 nums[:i] 中 {二元组的和: 二元组的个数} 哈希表得到。 同理，nums[:i+1] 的二元组计数可以由 nums[i] 和 Counter(nums[:i]) 得到。 令 dp3[i]、dp2[i]、dp1[i] 分别代表 nums[:i+1] 的三元组计数、二元组计数、哈希表计数。那么： dp1[i], dp2[i], dp3[i] = dp1[i-1].copy(), dp2[i-1].copy(), d","date":"2021-09-05","objectID":"/leetcode/1995/:2:2","tags":null,"title":"1995：统计特殊四元组（★）","uri":"/leetcode/1995/"},{"categories":null,"content":"解答 def countQuadruplets(self, nums: List[int]) -\u003e int: res, ct1, ct2, ct3 = 0, Counter(), Counter(), Counter() for num in nums: res += ct3[num] for x in ct2: ct3[x+num] += ct2[x] for x in ct1: ct2[x+num] += ct1[x] ct1[num] += 1 return res 时间复杂度 O(N*S)，116 ms ","date":"2021-09-05","objectID":"/leetcode/1995/:3:0","tags":null,"title":"1995：统计特殊四元组（★）","uri":"/leetcode/1995/"},{"categories":null,"content":" 第 60 场双周赛第 4 题 ","date":"2021-09-04","objectID":"/leetcode/1994/:0:0","tags":null,"title":"1994：好子集的数目（★★★）","uri":"/leetcode/1994/"},{"categories":null,"content":"题目 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以用若干个 互不相同的质数 相乘得到， 那么我们称它为 好子集 。 比方说，如果 nums = [1, 2, 3, 4] ： [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2 * 3 ，6 = 2 * 3 和 3 = 3 。 [1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2 * 2 和 4 = 2 * 2 。 请你返回 nums 中不同的 好 子集的数目对 10^9 + 7 取余 的结果。 nums 中的 子集 是通过删除 nums 中一些（可能一个都","date":"2021-09-04","objectID":"/leetcode/1994/:1:0","tags":null,"title":"1994：好子集的数目（★★★）","uri":"/leetcode/1994/"},{"categories":null,"content":"分析 注意到取值范围非常小，可以列举出能作为好子集元素的数的集合： A = [1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30]。 令 dp[i] 代表 nums 中 A[:i] 范围内的数能组成的 {好子集的乘积: 对应的个数} 哈希表。 为了方便，先将 1 组成的集合和空集也看作好子集。发现可以递推： dp[i+1] = dp[i].copy()\rfor x in dp[i]:\rif gcd(x, A[i]) == 1:\rdp[i+1][x*A[i]] += Counter(nums)[A[i]] * ","date":"2021-09-04","objectID":"/leetcode/1994/:2:0","tags":null,"title":"1994：好子集的数目（★★★）","uri":"/leetcode/1994/"},{"categories":null,"content":"解答 def numberOfGoodSubsets(self, nums: List[int]) -\u003e int: ct, mod = Counter(nums), 10**9+7 d = defaultdict(int) d[1] = (1 \u003c\u003c ct[1]) % mod for num in [2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30]: for x in list(d): if math.gcd(num, x) == 1: d[num*x] += ct[num]*d[x] d[num*x] %= m","date":"2021-09-04","objectID":"/leetcode/1994/:3:0","tags":null,"title":"1994：好子集的数目（★★★）","uri":"/leetcode/1994/"},{"categories":null,"content":" 第 60 场双周赛第 3 题 ","date":"2021-09-04","objectID":"/leetcode/1993/:0:0","tags":null,"title":"1993：树上的操作（★★）","uri":"/leetcode/1993/"},{"categories":null,"content":"题目 给你一棵 n 个节点的树，编号从 0 到 n - 1 ，以父节点数组 parent 的形式给出， 其中 parent[i] 是第 i 个节点的父节点。树的根节点为 0 号节点，所以 parent[0] = -1 ， 因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。 数据结构需要支持如下函数： Lock：指定用户给指定节点 上锁 ，上锁后其他用户将无法给同一节点上锁。 只有当节点处于未上锁的状态下，才能进行上锁操作。 Unlock：指定用户给指定节点 解锁 ，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。 Upgrade：指定用户给指定节点 上锁","date":"2021-09-04","objectID":"/leetcode/1993/:1:0","tags":null,"title":"1993：树上的操作（★★）","uri":"/leetcode/1993/"},{"categories":null,"content":"分析 用 state 数组保存每个节点的 \u003c是否上锁,上锁的用户 id\u003e，然后模拟即可。 upgrade 时向上 dfs 确定没有上锁的祖先节点，然后向下 dfs 找所有上锁的子孙节点， 如果非空即代表符合条件，将它们解锁。 ","date":"2021-09-04","objectID":"/leetcode/1993/:2:0","tags":null,"title":"1993：树上的操作（★★）","uri":"/leetcode/1993/"},{"categories":null,"content":"解答 class LockingTree: def __init__(self, parent: List[int]): self.parent = parent self.nxt = defaultdict(list) for v, u in enumerate(parent): self.nxt[u].append(v) self.state = [(0, 0)] * len(parent) def lock(self, num: int, user: int) -\u003e bool: if self.state[num][0]: return False self.state[num] = (","date":"2021-09-04","objectID":"/leetcode/1993/:3:0","tags":null,"title":"1993：树上的操作（★★）","uri":"/leetcode/1993/"},{"categories":null,"content":" 第 60 场双周赛第 2 题 ","date":"2021-09-04","objectID":"/leetcode/1992/:0:0","tags":null,"title":"1992：找到所有的农场组（★）","uri":"/leetcode/1992/"},{"categories":null,"content":"题目 给你一个下标从 0 开始，大小为 m x n 的二进制矩阵 land ，其中 0 表示一单位的森林土地， 1 表示一单位的农场土地。 为了让农场保持有序，农场土地之间以矩形的 农场组 的形式存在。每一个农场组都 仅 包含农场土地。 且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 不会 与 另一个农场组的任何一块土地在四个方向上相邻。 land 可以用坐标系统表示，其中 land 左上角坐标为 (0, 0) ，右下角坐标为 (m-1, n-1) 。 请你找到所有 农场组 最左上角和最右下角的坐标。一个左上角坐标为 (r1, c1) 且右下角坐标为 (r2, c2) 的","date":"2021-09-04","objectID":"/leetcode/1992/:1:0","tags":null,"title":"1992：找到所有的农场组（★）","uri":"/leetcode/1992/"},{"categories":null,"content":"分析 先遍历找到所有农场的左上角（上和左都是 0 的土地位置），然后每个农场遍历找到右下角即可。 ","date":"2021-09-04","objectID":"/leetcode/1992/:2:0","tags":null,"title":"1992：找到所有的农场组（★）","uri":"/leetcode/1992/"},{"categories":null,"content":"解答 def findFarmland(self, land: List[List[int]]) -\u003e List[List[int]]: tmp, m, n = [], len(land), len(land[0]) for i, j in product(range(m), range(n)): if land[i][j] == 1 and (not i or land[i-1][j]==0) and (not j or land[i][j-1]==0): tmp.append([i, j]) res = [] for r1, c1 in tmp: r2, c2 = r1, c1 while","date":"2021-09-04","objectID":"/leetcode/1992/:3:0","tags":null,"title":"1992：找到所有的农场组（★）","uri":"/leetcode/1992/"},{"categories":null,"content":" 第 60 场双周赛第 1 题 ","date":"2021-09-04","objectID":"/leetcode/1991/:0:0","tags":null,"title":"1991：找到数组的中间位置","uri":"/leetcode/1991/"},{"categories":null,"content":"题目 给你一个下标从 0 开始的整数数组 nums ，请你找到 最左边 的中间位置 middleIndex （也就是所有可能中间位置下标最小的一个）。 中间位置 middleIndex 是满足 nums[0] + nums[1] + … + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + … + nums[nums.length-1] 的数组下标。 如果 middleIndex == 0 ，左边部分的和定义为 0 。类似的，如果 middleIndex == nums.length - 1 ， 右边部分的和定","date":"2021-09-04","objectID":"/leetcode/1991/:1:0","tags":null,"title":"1991：找到数组的中间位置","uri":"/leetcode/1991/"},{"categories":null,"content":"分析 遍历找到第一个满足 sum(nums[:i])*2+nums[i] == sum(nums) 的 i 即可。 ","date":"2021-09-04","objectID":"/leetcode/1991/:2:0","tags":null,"title":"1991：找到数组的中间位置","uri":"/leetcode/1991/"},{"categories":null,"content":"解答 def findMiddleIndex(self, nums: List[int]) -\u003e int: s, cur = sum(nums), 0 for i, num in enumerate(nums): if cur == s-num-cur: return i cur += num return -1 40 ms ","date":"2021-09-04","objectID":"/leetcode/1991/:3:0","tags":null,"title":"1991：找到数组的中间位置","uri":"/leetcode/1991/"},{"categories":null,"content":" 第 场双周赛第 题 ","date":"2021-08-22","objectID":"/leetcode/1979/:0:0","tags":null,"title":"1979：找出数组的最大公约数","uri":"/leetcode/1979/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，返回数组中最大数和最小数的 最大公约数 。 两个数的 最大公约数 是能够被两个数整除的最大正整数。 示例 1： 输入：nums = [2,5,6,9,10]\r输出：2\r解释：\rnums 中最小的数是 2\rnums 中最大的数是 10\r2 和 10 的最大公约数是 2\r示例 2： 输入：nums = [7,5,6,8,3]\r输出：1\r解释：\rnums 中最小的数是 3\rnums 中最大的数是 8\r3 和 8 的最大公约数是 1\r示例 3： 输入：nums = [3,3]\r输出：3\r解释：\rnums 中最小的数是 3\rnums 中最大的数是 3\r3 和 3 的最","date":"2021-08-22","objectID":"/leetcode/1979/:1:0","tags":null,"title":"1979：找出数组的最大公约数","uri":"/leetcode/1979/"},{"categories":null,"content":"分析 模拟即可 ","date":"2021-08-22","objectID":"/leetcode/1979/:2:0","tags":null,"title":"1979：找出数组的最大公约数","uri":"/leetcode/1979/"},{"categories":null,"content":"解答 def findGCD(self, nums: List[int]) -\u003e int: return gcd(max(nums), min(nums)) 40 ms ","date":"2021-08-22","objectID":"/leetcode/1979/:3:0","tags":null,"title":"1979：找出数组的最大公约数","uri":"/leetcode/1979/"},{"categories":null,"content":" 第 场双周赛第 题 ","date":"2021-08-19","objectID":"/leetcode/1976/:0:0","tags":null,"title":"1976：到达目的地的方案数（★★）","uri":"/leetcode/1976/"},{"categories":null,"content":"题目 你在一个城市里，城市由 n 个路口组成，路口编号为 0 到 n - 1 ，某些路口之间有 双向 道路。 输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。 给你一个整数 n 和二维整数数组 roads ，其中 roads[i] = [ui, vi, timei] 表示在路口 ui 和 vi 之间 有一条需要花费 timei 时间才能通过的道路。你想知道花费 最少时间 从路口 0 出发到达路口 n - 1 的方案数。 请返回花费 最少时间 到达目的地的 路径数目 。由于答案可能很大，将结果对 10^9 + 7 取余 后返回。 示例 1： 输入：n = 7, ro","date":"2021-08-19","objectID":"/leetcode/1976/:1:0","tags":null,"title":"1976：到达目的地的方案数（★★）","uri":"/leetcode/1976/"},{"categories":null,"content":"分析 可以先用 dijkstra 求出所有节点到 n-1 的最短时间 dis。 然后假如节点 u 和 v 相邻，权重 w，且 dis[u]-w=dis[v]，连一条有向边 \u003cu, v\u003e， 问题转为求新的有向无环图中 0 到 n-1 的路径。显然可以动态规划递推。 注意到 dijkstra 出堆节点的顺序和动态规划中递推的顺序其实是一致的，因此可以同时进行。 ","date":"2021-08-19","objectID":"/leetcode/1976/:2:0","tags":null,"title":"1976：到达目的地的方案数（★★）","uri":"/leetcode/1976/"},{"categories":null,"content":"解答 def countPaths(self, n: int, roads: List[List[int]]) -\u003e int: nxt = defaultdict(list) for u, v, w in roads: nxt[u].append((v, w)) nxt[v].append((u, w)) dp, mod = Counter({n-1: 1}), 10**9+7 d, pq = {}, [(0, n-1)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, w2 in nxt[u]: if v no","date":"2021-08-19","objectID":"/leetcode/1976/:3:0","tags":null,"title":"1976：到达目的地的方案数（★★）","uri":"/leetcode/1976/"},{"categories":null,"content":"线段树（Segment Tree）是一种二叉树形数据结构。多用于区间查询。 相比于 前缀和 和 树状数组， 线段树更复杂，也更通用。 线段树可以区间修改、区间查询。而且线段树不仅能维护区间的和，还可以维护区间的 最小值、最大值、总和、最大公约数、最小公倍数等。 详解 ","date":"2021-07-21","objectID":"/algorithm-segment_tree/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（六）：线段树","uri":"/algorithm-segment_tree/"},{"categories":null,"content":"1 基础 0307 区域和检索 - 数组可修改 ","date":"2021-07-21","objectID":"/algorithm-segment_tree/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（六）：线段树","uri":"/algorithm-segment_tree/"},{"categories":null,"content":"2 进阶 ","date":"2021-07-21","objectID":"/algorithm-segment_tree/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（六）：线段树","uri":"/algorithm-segment_tree/"},{"categories":null,"content":"3 挑战 ","date":"2021-07-21","objectID":"/algorithm-segment_tree/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（六）：线段树","uri":"/algorithm-segment_tree/"},{"categories":null,"content":"第 250 场周赛第 4 题 ","date":"2021-07-18","objectID":"/leetcode/1938/:0:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"题目 给你一棵 n 个节点的有根树，节点编号从 0 到 n - 1 。 每个节点的编号表示这个节点的 独一无二的基因值 （也就是说节点 x 的基因值为 x）。 两个基因值的 基因差 是两者的 异或和 。给你整数数组 parents ，其中 parents[i] 是节点 i 的父节点。 如果节点 x 是树的 根 ，那么 parents[x] == -1 。 给你查询数组 queries ，其中 queries[i] = [nodei, vali] 。 对于查询 i ，请你找到 vali 和 pi 的 最大基因差 ，其中 pi 是节点 nodei 到根之间的任意节点（包含 nodei 和根节点）。","date":"2021-07-18","objectID":"/leetcode/1938/:1:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"分析 类似 1707，只不过限制条件从数组上界变为了树的路径。 考虑遍历树的节点 node 时动态维护哈希表或字典树，即可回答 node 对应的查询。 注意动态维护过程中不仅有添加，还有删除，因此需要维护前缀的计数。 这里用更简单的哈希表方法。 ","date":"2021-07-18","objectID":"/leetcode/1938/:2:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"解答 def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -\u003e List[int]: def find(x): ans = 0 for j in range(17, -1, -1): ans \u003c\u003c= 1 ans += 1 if A[j][(ans+1)^(x\u003e\u003ej)] else 0 return ans def dfs(u): for v in nxt[u]: for j in range(18): A[j][v \u003e\u003e j] += 1 for i, val in qr[v]: res[i] =","date":"2021-07-18","objectID":"/leetcode/1938/:3:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"*附加 字典树写法。 def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -\u003e List[int]: def find(x): ans, p = '', trie for bit in bin(x)[2:].zfill(18): bit_rev = str(int(bit)^1) ans += '1' if p[bit_rev].get('cnt') else '0' p = p[bit_rev] if p[bit_rev].get('cnt') else p[bit] return int(","date":"2021-07-18","objectID":"/leetcode/1938/:4:0","tags":null,"title":"1938：查询最大基因差（★★★）","uri":"/leetcode/1938/"},{"categories":null,"content":"树状数组或二叉索引树（Binary Indexed Tree），又以其发明者命名为 Fenwick 树。 是一种解决动态数组区间查询问题的算法。 最简单的树状数组支持两种操作，都能在 O(logN) 时间完成： 单点修改：更改数组中一个元素的值 区间查询：查询一个区间内所有元素的和 详解 如果是区间修改，则考虑更通用的 线段树 方法。 ","date":"2021-07-11","objectID":"/algorithm-binary_indexed_tree/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（五）：树状数组","uri":"/algorithm-binary_indexed_tree/"},{"categories":null,"content":"1 基础 0307 区域和检索 - 数组可修改 ","date":"2021-07-11","objectID":"/algorithm-binary_indexed_tree/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（五）：树状数组","uri":"/algorithm-binary_indexed_tree/"},{"categories":null,"content":"2 进阶 0308 二维区域和检索 - 可变 ","date":"2021-07-11","objectID":"/algorithm-binary_indexed_tree/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（五）：树状数组","uri":"/algorithm-binary_indexed_tree/"},{"categories":null,"content":"3 挑战 ","date":"2021-07-11","objectID":"/algorithm-binary_indexed_tree/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（五）：树状数组","uri":"/algorithm-binary_indexed_tree/"},{"categories":null,"content":"题目 一个国家由 n 个编号为 0 到 n - 1 的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。 总共有 m 个编号为 0 到 m - 1 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。 每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。 同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。 给你一个整数 n 和二维数组 paths ，其中 paths[i] 是一个整数数组，表示第 i 个朋友走过的路径， 请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。 一个 子路","date":"2021-07-03","objectID":"/leetcode/1923/:1:0","tags":null,"title":"1923：最长公共子路径（★★★）","uri":"/leetcode/1923/"},{"categories":null,"content":"分析 类似 0718，只不过从两个数组变成了多个数组。 元素种类最多 10^5，用到的窗口种类最多 10^6 级别，因此考虑 base 取 10^5+3，mod 取 10^12+39 ","date":"2021-07-03","objectID":"/leetcode/1923/:2:0","tags":null,"title":"1923：最长公共子路径（★★★）","uri":"/leetcode/1923/"},{"categories":null,"content":"解答 def longestCommonSubpath(self, n: int, paths: List[List[int]]) -\u003e int: def gen(A, L): ans, w, bL = set(), 0, pow(base, L, mod) for j, a in enumerate(A): w = w*base+a if j\u003e=L: w -= A[j-L]*bL w %= mod if j\u003e=L-1: ans.add(w) return ans base, mod = 10**5+3, 10**12+39 self.__class__.__getitem__ = lambd","date":"2021-07-03","objectID":"/leetcode/1923/:3:0","tags":null,"title":"1923：最长公共子路径（★★★）","uri":"/leetcode/1923/"},{"categories":null,"content":"*附加 也可以类似 0718，使用 后缀数组 判断是否存在长为 L 的公共路径 def longestCommonSubpath(self, n: int, paths: List[List[int]]) -\u003e int: def SA_IS(A): def equal(pos1, pos2): end1, end2 = LMS.find('*', pos1+1), LMS.find('*', pos2+1) return A[pos1:end1+1] == A[pos2:end2+1] def IS(stars): sa = [n] + [-1] * n tails = list(accumu","date":"2021-07-03","objectID":"/leetcode/1923/:4:0","tags":null,"title":"1923：最长公共子路径（★★★）","uri":"/leetcode/1923/"},{"categories":null,"content":"字典树，又叫前缀树，是一种 N 叉树，用于高效地存储、查找字符串前缀。 python 中可以用 defaultdict 来实现。 ","date":"2021-07-01","objectID":"/algorithm-trie/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（四）：字典树","uri":"/algorithm-trie/"},{"categories":null,"content":"1 基础 0208 实现 Trie (前缀树) 0648 单词替换 ","date":"2021-07-01","objectID":"/algorithm-trie/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（四）：字典树","uri":"/algorithm-trie/"},{"categories":null,"content":"2 进阶 0211 添加与搜索单词 - 数据结构设计 0677 键值映射 ","date":"2021-07-01","objectID":"/algorithm-trie/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（四）：字典树","uri":"/algorithm-trie/"},{"categories":null,"content":"3 挑战 0212 单词搜索 II 0421 数组中两个数的最大异或值 1707 与数组中元素的最大异或值 1938 查询最大基因差 ","date":"2021-07-01","objectID":"/algorithm-trie/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（四）：字典树","uri":"/algorithm-trie/"},{"categories":null,"content":"题目 你是一只蚂蚁，负责为蚁群构筑 n 间编号从 0 到 n-1 的新房间。给你一个 下标从 0 开始 且长度为 n 的整数数组 prevRoom 作为扩建计划。其中，prevRoom[i] 表示在构筑房间 i 之前，你必须先构筑房间 prevRoom[i] ， 并且这两个房间必须 直接 相连。房间 0 已经构筑完成，所以 prevRoom[0] = -1 。 扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 0 可以访问到每个房间。 你一次只能构筑 一个 房间。你可以在 已经构筑好的 房间之间自由穿行，只要这些房间是 相连的 。 如果房间 prevRoom[i] 已经构筑完成，那","date":"2021-06-25","objectID":"/leetcode/1916/:1:0","tags":null,"title":"1916：统计为蚁群构筑房间的不同顺序（★★★）","uri":"/leetcode/1916/"},{"categories":null,"content":"分析 将 \u003cprevRoom[i],i\u003e 看作一条边，显然构成一棵根节点 0 的树。那么可以考虑递归。 令 dfs(u) 代表以 u 为根的树的方案数，那么除了子树自身的方案数的乘积以外，还要考虑子树之间的先后顺序。 假设子树 v1、v2、… 的节点数分别为 s1、s2、…，子树之间的先后顺序相当于求 s1 个 1、s2 个 2、… 的排列数， 根据排列组合的知识即可求解。 注意本题数很大，必须边乘除边求模，因此要用到乘法逆元 ","date":"2021-06-25","objectID":"/leetcode/1916/:2:0","tags":null,"title":"1916：统计为蚁群构筑房间的不同顺序（★★★）","uri":"/leetcode/1916/"},{"categories":null,"content":"解答 def waysToBuildRooms(self, prevRoom: List[int]) -\u003e int: def dfs(u): res, s = 1, 0 for v in nxt[u]: a, b = dfs(v) s += b res = res*a*inv[b]%mod return res*fac[s]%mod, s+1 n = len(prevRoom) nxt = defaultdict(list) for v, u in enumerate(prevRoom): nxt[u].append(v) fac, inv, mod = [1]*n, [1]*n, 10**9","date":"2021-06-25","objectID":"/leetcode/1916/:3:0","tags":null,"title":"1916：统计为蚁群构筑房间的不同顺序（★★★）","uri":"/leetcode/1916/"},{"categories":null,"content":"并查集（Union Find）也叫「不相交集合（Disjoint Set）」，是一种树型的数据结构， 专门用于 动态处理 不相交集合的「查询」与「合并」问题。 查询（Find），查询图中的两个顶点是不是在同一个集合中。 注意：并查集只回答两个顶点之间是否有一条路径连接，而不回答怎么连接。 合并（Union），将两个不相交集合进行合并。 并查集常常和图相关，比如「最小生成树」算法。 能用并查集的问题一般都可以用 bfs/dfs，但是并查集更简洁直观，而且一般更节省时间。 ","date":"2021-06-21","objectID":"/algorithm-union_find/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（三）：并查集","uri":"/algorithm-union_find/"},{"categories":null,"content":"1 基础 0200 岛屿数量 0547 省份数量 0684 冗余连接 0839 相似字符串组 0990 等式方程的可满足性 ","date":"2021-06-21","objectID":"/algorithm-union_find/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（三）：并查集","uri":"/algorithm-union_find/"},{"categories":null,"content":"2 进阶 0130 被围绕的区域 0695 岛屿的最大面积 0721 账户合并 0959 由斜杠划分区域 ","date":"2021-06-21","objectID":"/algorithm-union_find/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（三）：并查集","uri":"/algorithm-union_find/"},{"categories":null,"content":"3 挑战 0399 除法求值 0407 接雨水 II 0685 冗余连接 II 0803 打砖块 ","date":"2021-06-21","objectID":"/algorithm-union_find/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（三）：并查集","uri":"/algorithm-union_find/"},{"categories":null,"content":"很多问题需要维护一个有序的集合，根据操作不同，可以选择更优的数据结构。 访问 搜索 插入 删除 访问最值 插入最值 删除最值 数组 list O(1) O(logN) O(N) O(N) O(1) O(1) O(1) 队列 deque O(N) O(N) O(N) O(N) O(1) O(1) O(1) 堆 heapq O(N) O(N) O(logN) O(N) O(1) O(logN) O(logN) AVL/红黑树 O(logN) O(logN) O(logN) O(logN) O(logN) O(logN) O(logN) 若只需搜索操作，用 数组 即可。 若只需最值相关的操作，用 栈","date":"2021-06-11","objectID":"/algorithm-ordered_set/:0:0","tags":["算法"],"title":"力扣总结 数据结构进阶（二）：有序集合","uri":"/algorithm-ordered_set/"},{"categories":null,"content":"1 基础 0239 滑动窗口最大值 0295 数据流的中位数 ","date":"2021-06-11","objectID":"/algorithm-ordered_set/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（二）：有序集合","uri":"/algorithm-ordered_set/"},{"categories":null,"content":"2 进阶 0218 天际线问题 0220 存在重复元素 III ","date":"2021-06-11","objectID":"/algorithm-ordered_set/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（二）：有序集合","uri":"/algorithm-ordered_set/"},{"categories":null,"content":"3 挑战 ","date":"2021-06-11","objectID":"/algorithm-ordered_set/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（二）：有序集合","uri":"/algorithm-ordered_set/"},{"categories":null,"content":"1 基础 0496 下一个更大元素 I 0739 每日温度 0901 股票价格跨度 ","date":"2021-06-01","objectID":"/algorithm-monotonic_stack/:1:0","tags":["算法"],"title":"力扣总结 数据结构进阶（一）：单调栈和单调队列","uri":"/algorithm-monotonic_stack/"},{"categories":null,"content":"2 进阶 0084 柱状图中最大的矩形 0085 最大矩形 0907 子数组的最小值之和 ","date":"2021-06-01","objectID":"/algorithm-monotonic_stack/:2:0","tags":["算法"],"title":"力扣总结 数据结构进阶（一）：单调栈和单调队列","uri":"/algorithm-monotonic_stack/"},{"categories":null,"content":"3 挑战 0456 132 模式 0962 最大宽度坡 0975 奇偶跳 1124 表现良好的最长时间段 1130 叶值的最小代价生成树 ","date":"2021-06-01","objectID":"/algorithm-monotonic_stack/:3:0","tags":["算法"],"title":"力扣总结 数据结构进阶（一）：单调栈和单调队列","uri":"/algorithm-monotonic_stack/"},{"categories":null,"content":"*4 单调队列 0239 滑动窗口最大值 0862 和至少为 K 的最短子数组 0918 环形子数组的最大和 1425 带限制的子序列和 1438 绝对差不超过限制的最长连续子数组 1499 满足不等式的最大值 1696 跳跃游戏 VI ","date":"2021-06-01","objectID":"/algorithm-monotonic_stack/:4:0","tags":["算法"],"title":"力扣总结 数据结构进阶（一）：单调栈和单调队列","uri":"/algorithm-monotonic_stack/"},{"categories":null,"content":"题目 给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。 给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。 同时给你一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边 。 图中一条有效 路径 是一个点序列 x1 -\u003e x2 -\u003e x3 -\u003e … -\u003e xk ，对于所有 1 \u003c= i \u003c k ， 从 xi 到 xi+1 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。 请你返回给定图中","date":"2021-05-16","objectID":"/leetcode/1857/:1:0","tags":null,"title":"1857：有向图中最大颜色值（★★★）","uri":"/leetcode/1857/"},{"categories":null,"content":"分析 要判断环，容易想到用拓扑排序。 若没有环，那么对于有向无环图，可以考虑用递归： 问题中要求路径中的最大颜色值，不好直接递归。容易递归的是每种颜色的最大值。 假设路径中的最大颜色值是 cnt，对应的颜色为 x，那么显然颜色 x 的最大值就是 cnt，其它颜色的最大值 \u003c= cnt。 因此 max(每种颜色的最大值) 即为所求。 注意到拓扑排序出队的顺序和递推的顺序其实是一致的，因此可以同时进行。 ","date":"2021-05-16","objectID":"/leetcode/1857/:2:0","tags":null,"title":"1857：有向图中最大颜色值（★★★）","uri":"/leetcode/1857/"},{"categories":null,"content":"解答 def largestPathValue(self, colors: str, edges: List[List[int]]) -\u003e int: n = len(colors) nxt, indeg = defaultdict(list), [0]*n for u, v in edges: nxt[u].append(v) indeg[v] += 1 res, dp = 0, [defaultdict(int) for _ in range(n)] queue = deque(u for u in range(n) if indeg[u]==0) while queue: u = queu","date":"2021-05-16","objectID":"/leetcode/1857/:3:0","tags":null,"title":"1857：有向图中最大颜色值（★★★）","uri":"/leetcode/1857/"},{"categories":null,"content":"题目 给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间 开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目， 更正式地表达是 righti - lefti + 1 。 再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti \u003c= queries[j] \u003c= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。 以数组形式返回对应查询的所有答案。 示例 1： 输入：intervals = [[1,4]","date":"2021-05-10","objectID":"/leetcode/1851/:1:0","tags":null,"title":"1851：包含每个查询的最小区间（★★★）","uri":"/leetcode/1851/"},{"categories":null,"content":"分析 有点类似 0218，不过查询的不一定是边界，可能在区间中间。 考虑将查询也添加到边缘坐标中，然后遍历所有边缘坐标，维护区间长度集合 H，min(H) 即为查询答案。 注意到查询是满足闭区间即可，因此遍历到边缘坐标 x 时，要先将以 x 开始的区间添加到 H 中， 然后完成查询操作，最后将以 x 结束的区间移出 H。可以通过标记排序来实现。 ","date":"2021-05-10","objectID":"/leetcode/1851/:2:0","tags":null,"title":"1851：包含每个查询的最小区间（★★★）","uri":"/leetcode/1851/"},{"categories":null,"content":"解答 def minInterval(self, intervals: List[List[int]], queries: List[int]) -\u003e List[int]: from sortedcontainers import SortedList d = defaultdict(list) for a, b in intervals: h = b-a+1 d[a].append((0, h)) d[b].append((2, h)) for idx, q in enumerate(queries): d[q].append((1, idx)) res, H = [-1] * len(qu","date":"2021-05-10","objectID":"/leetcode/1851/:3:0","tags":null,"title":"1851：包含每个查询的最小区间（★★★）","uri":"/leetcode/1851/"},{"categories":null,"content":"一些问题涉及到数学的几何知识，包括斜率、面积、凸包等。 相关的算法有 扫描线算法 等。 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:0:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":"1 基础 0223 矩形面积 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:1:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":"2 进阶 0149 直线上最多的点数 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:2:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":"3 挑战 0335 路径交叉 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:3:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":"*4 扫描线 0218 天际线问题 0391 完美矩形 0850 矩形面积 II 1851 包含每个查询的最小区间 ","date":"2021-04-11","objectID":"/algorithm-math_geometry/:4:0","tags":["算法"],"title":"力扣总结 算法进阶（四）：几何","uri":"/algorithm-math_geometry/"},{"categories":null,"content":"题目 小明的电动车电量充满时可行驶距离为 cnt，每行驶 1 单位距离消耗 1 单位电量，且花费 1 单位时间。 小明想选择电动车作为代步工具。地图上共有 N 个景点，景点编号为 0 ~ N-1。 他将地图信息以 [城市 A 编号,城市 B 编号,两城市间距离] 格式整理在在二维数组 paths，表示城市 A、B 间存在双向通路。 初始状态，电动车电量为 0。每个城市都设有充电桩，charge[i] 表示第 i 个城市每充 1 单位电量需要花费的单位时间。 请返回小明最少需要花费多少单位时间从起点城市 start 抵达终点城市 end。 示例 1： 输入：paths = [[1,3,3],[3","date":"2021-04-09","objectID":"/leetcode/lcp35/:1:0","tags":null,"title":"LCP35：电动车游城市(★★★)","uri":"/leetcode/lcp35/"},{"categories":null,"content":"分析 将状态 (节点 u,电量 c) 看作顶点，那么对于通路 \u003cu,v,w\u003e，如果 c\u003e=w，则 (u, c) 到 (v, c-w) 连有向边，权重为 w。 额外的，(u, c) 到 (u, c+1) 连一条有向边，权重为 charge[u]。 那么问题就转为在新图中求 (start, 0) 到 (end, 0) 的最短路，可以用 dijkstra 算法。 ","date":"2021-04-09","objectID":"/leetcode/lcp35/:2:0","tags":null,"title":"LCP35：电动车游城市(★★★)","uri":"/leetcode/lcp35/"},{"categories":null,"content":"解答 def electricCarPlan(self, paths: List[List[int]], cnt: int, start: int, end: int, charge: List[int]) -\u003e int: nxt = defaultdict(list) for u, v, w in paths: nxt[u].append((v, w)) nxt[v].append((u, w)) d, pq = {}, [(0, start, 0)] while pq: w, u, c = heappop(pq) if (u, c) in d: continue if (u, c) == ","date":"2021-04-09","objectID":"/leetcode/lcp35/:3:0","tags":null,"title":"LCP35：电动车游城市(★★★)","uri":"/leetcode/lcp35/"},{"categories":null,"content":"题目 给你一个由正整数组成的数组 nums 。 数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。 例如，序列 [4,6,16] 的最大公约数是 2 。 数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。 例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。 示例 1： 输入：nums = [6,10,3]\r输出：5\r解释：上图显示了所有的非空子序列与各自的最大公约数。\r不同的最大公约数为 6 、10 、3 、2 和 1 。\r示例 2： 输","date":"2021-04-08","objectID":"/leetcode/1819/:1:0","tags":null,"title":"1819：序列中不同最大公约数的数目(★★★)","uri":"/leetcode/1819/"},{"categories":null,"content":"分析 要递推所有子序列的最大公约数时间复杂度高。注意到最大公约数不会超过 2*10^5， 因此可以反过来，判断每个数是否是某个子序列的最大公约数。 这样总时间不超过 N * 调和级数，时间复杂度 O(N*logN)。 ","date":"2021-04-08","objectID":"/leetcode/1819/:2:0","tags":null,"title":"1819：序列中不同最大公约数的数目(★★★)","uri":"/leetcode/1819/"},{"categories":null,"content":"解答 def countDifferentSubsequenceGCDs(self, nums: List[int]) -\u003e int: res, nums, Max = 0, set(nums), max(nums) for x in range(1, Max+1): g = None for y in range(x, Max+1, x): if y in nums: g = gcd(g, y) if g else y if g == x: res += 1 break return res 2656 ms ","date":"2021-04-08","objectID":"/leetcode/1819/:3:0","tags":null,"title":"1819：序列中不同最大公约数的数目(★★★)","uri":"/leetcode/1819/"},{"categories":null,"content":"明明是熟悉的街道，这座城市却似乎有哪里变得不太一样了。\n出租车司机小户川每天平凡度日。他没有亲人，鲜少与人交流，是个有点孤僻木讷的怪人。兴趣是在睡前听落语和工作时听广播。姑且能称得上是他朋友的人，只有他的主治医生刚力，以及高中同学柿花而已。\n他载到的尽是些有点古怪的客人：一心想在网路上被疯传的大学生，桦泽；似乎有所隐情的护理师，白川；不太红的搞笑二人组，智人拍档；街头无赖，阴沟；正要开始走红的偶像女团，神秘之吻等。\n人与人之间百无聊赖的对话，最后竟与一位失踪少女扯上了关系。","date":"2021-04-05","objectID":"/anime/odd_taxi/","tags":null,"title":"奇巧计程车","uri":"/anime/odd_taxi/"},{"categories":null,"content":"简介 明明是熟悉的街道，这座城市却似乎有哪里变得不太一样了。 出租车司机小户川每天平凡度日。他没有亲人，鲜少与人交流，是个有点孤僻木讷的怪人。兴趣是在睡前听落语和工作时听广播。姑且能称得上是他朋友的人，只有他的主治医生刚力，以及高中同学柿花而已。 他载到的尽是些有点古怪的客人：一心想在网路上被疯传的大学生，桦泽；似乎有所隐情的护理师，白川；不太红的搞笑二人组，智人拍档；街头无赖，阴沟；正要开始走红的偶像女团，神秘之吻等。 人与人之间百无聊赖的对话，最后竟与一位失踪少女扯上了关系。 制作人员： 原作：P.I.C.S. 导演：木下麦 脚本：此元和津也 演出：粟井重纪、兴满录助、山井纱也香、沼山茉由","date":"2021-04-05","objectID":"/anime/odd_taxi/:1:0","tags":null,"title":"奇巧计程车","uri":"/anime/odd_taxi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小户川宏 小戸川 宏、おどかわ ひろし、Hiroshi Odokawa 男 花江夏樹 2 白川美保 しらかわ みほ、Miho Shirakawa 女 飯田里穂 3 刚力步 ごうりき、Gouriki 男 木村良平 4 柿花英二 かきはな えいじ、Eiji Kakihana 男 山口勝平 5 二阶堂瑠衣 二階堂 ルイ、にかいどう ルイ、Rui Nikaidou 女 三森すずこ 6 市村志帆 市村 しほ、いちむら しほ、Shiho Ichimura 女 小泉萌香 7 三矢雪 和田垣樱、和田垣さくら、わだがき さくら、Sakura Wadagaki 女 村上まなつ ","date":"2021-04-05","objectID":"/anime/odd_taxi/:2:0","tags":null,"title":"奇巧计程车","uri":"/anime/odd_taxi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 奇巧计程车 2021-04-05 13 bilibili ","date":"2021-04-05","objectID":"/anime/odd_taxi/:3:0","tags":null,"title":"奇巧计程车","uri":"/anime/odd_taxi/"},{"categories":null,"content":"一些问题涉及到数学的代数知识： 基础的四则运算、平方开根、进制转换等 排列组合、概率统计 数论知识，包括质数、同余、因式分解、乘法逆元等 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:0:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"1 运算 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:1:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"1.1 基础 0007 整数反转 0050 Pow(x, n) 0069 x 的平方根 0102 整数转罗马数字 0171 Excel 表列序号 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:1:1","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"1.2 进阶 0029 两数相除 0043 字符串相乘 0168 Excel 表列名称 0202 快乐数 0367 有效的完全平方数 0400 第 N 位数字 0829 连续整数求和 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:1:2","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"1.3 挑战 0166 分数到小数 0169 多数元素 0229 求众数 II 0273 整数转换英文表示 0343 整数拆分 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:1:3","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"2 排列组合 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:2:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"2.1 基础 0062 不同路径 0119 杨辉三角 II 0357 计算各个位数不同的数字个数 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:2:1","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"2.2 进阶 0060 排列序列 0096 不同的二叉搜索树 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:2:2","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"2.3 挑战 0902 最大为 N 的数字组合 1012 至少有 1 位重复的数字 1916 统计为蚁群构筑房间的不同顺序 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:2:3","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"3 概率统计 0382 链表随机节点 0384 打乱数组 0398 随机数索引 0470 用 Rand7() 实现 Rand10() 0478 在圆内随机生成点 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:3:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"4 数论 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:4:0","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"4.1 基础 0172 阶乘后的零 0231 2 的幂 0258 各位相加 0263 丑数 0914 卡牌分组 1250 检查「好数组」 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:4:1","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"4.2 进阶 0204 计数质数 0279 完全平方数 0319 灯泡开关 0365 水壶问题 0650 只有两个键的键盘 0866 回文素数 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:4:2","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"4.3 挑战 1819 序列中不同最大公约数的数目 2183 统计可以被 K 整除的下标对数目 ","date":"2021-04-01","objectID":"/algorithm-math_algebra/:4:3","tags":["算法"],"title":"力扣总结 算法进阶（三）：代数","uri":"/algorithm-math_algebra/"},{"categories":null,"content":"滚动哈希是一种针对固定长度的滑动窗口的哈希方法。 朴素的哈希需要对所有窗口单独求哈希值，时间复杂度和空间复杂度都和窗口长度相关。 用滚动哈希则可以递推求得相邻窗口的哈希值，优化为线性复杂度。 一般采用 Rabin-Karp 算法来实现滚动哈希。核心思想就是将窗口 W 看作是一个 base 进制的数： $$hash(W)=\\sum_{i=0}^{|W|-1}base^{|W|-(i+1)}*W[i]$$ base 取一个大于元素范围的数，该 base 进制的数就唯一对应一个窗口。 特别注意，当哈希值很大必须要取模时，为了尽量避免哈希冲突，base 取一个大于 元素种数 的 质数， 而mod 应该","date":"2021-03-11","objectID":"/algorithm-rolling_hash/:0:0","tags":["算法"],"title":"力扣总结 算法进阶（二）：滚动哈希","uri":"/algorithm-rolling_hash/"},{"categories":null,"content":"1 基础 0187 重复的DNA序列 ","date":"2021-03-11","objectID":"/algorithm-rolling_hash/:1:0","tags":["算法"],"title":"力扣总结 算法进阶（二）：滚动哈希","uri":"/algorithm-rolling_hash/"},{"categories":null,"content":"2 进阶 0718 最长重复子数组 1392 最长快乐前缀 ","date":"2021-03-11","objectID":"/algorithm-rolling_hash/:2:0","tags":["算法"],"title":"力扣总结 算法进阶（二）：滚动哈希","uri":"/algorithm-rolling_hash/"},{"categories":null,"content":"3 挑战 1044 最长重复子串 1316 不同的循环子字符串 1923 最长公共子路径 ","date":"2021-03-11","objectID":"/algorithm-rolling_hash/:3:0","tags":["算法"],"title":"力扣总结 算法进阶（二）：滚动哈希","uri":"/algorithm-rolling_hash/"},{"categories":null,"content":"题目 现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ， 其中每个 edges[i] = [ui, vi, weighti] 表示存在一条位于节点 ui 和 vi 之间的边，这条边的权重为 weighti 。 从节点 start 出发到节点 end 的路径是一个形如 [z0, z1, z2, …, zk] 的节点序列，满足 z0 = start 、zk = end 且在所有符合 0 \u003c= i \u003c= k-1 的节点 zi 和 zi+1 之间存在一条边。 路径的距离定义为这条路径上所有边的权重总和。用 distanc","date":"2021-03-09","objectID":"/leetcode/1786/:1:0","tags":null,"title":"1786：从第一个节点出发到最后一个节点的受限路径数（★★★）","uri":"/leetcode/1786/"},{"categories":null,"content":"分析 显然可以用 dijkstra 先得到所有节点到 n 的最短距离 dis。 然后假如节点 u 和 v 相邻且 dis[u]\u003edis[v]，连一条有向边 \u003cu, v\u003e，问题转为求新的有向无环图中 1 到 n 的路径。 显然可以动态规划递推。 注意到 dijkstra 出堆节点的顺序和动态规划中递推的顺序其实是一致的，因此可以同时进行。 ","date":"2021-03-09","objectID":"/leetcode/1786/:2:0","tags":null,"title":"1786：从第一个节点出发到最后一个节点的受限路径数（★★★）","uri":"/leetcode/1786/"},{"categories":null,"content":"解答 def countRestrictedPaths(self, n: int, edges: List[List[int]]) -\u003e int: nxt = defaultdict(list) for u, v, w in edges: nxt[u].append((v, w)) nxt[v].append((u, w)) dp, mod = Counter({n: 1}), 10**9+7 d, pq = {}, [(0, n)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, w2 in nxt[u]: i","date":"2021-03-09","objectID":"/leetcode/1786/:3:0","tags":null,"title":"1786：从第一个节点出发到最后一个节点的受限路径数（★★★）","uri":"/leetcode/1786/"},{"categories":null,"content":"题目 给你一个长度为 n 的二维整数数组 groups ，同时给你一个整数数组 nums 。 你是否可以从 nums 中选出 n 个 不相交 的子数组，使得第 i 个子数组与 groups[i] （下标从 0 开始）完全相同， 且如果 i \u003e 0 ，那么第 (i-1) 个子数组在 nums 中出现的位置在第 i 个子数组前面。 （也就是说，这些子数组在 nums 中出现的顺序需要与 groups 顺序相同） 如果你可以找出这样的 n 个子数组，请你返回 true ，否则返回 false 。 如果不存在下标为 k 的元素 nums[k] 属于不止一个子数组，就称这些子数组是 不相交 的。 子数组","date":"2021-03-03","objectID":"/leetcode/1764/:1:0","tags":null,"title":"1764：通过连接另一个数组的子数组得到一个数组（★★）","uri":"/leetcode/1764/"},{"categories":null,"content":"分析 类似于判断子序列，在 nums 中依次找 groups[i] 即可。 ","date":"2021-03-03","objectID":"/leetcode/1764/:2:0","tags":null,"title":"1764：通过连接另一个数组的子数组得到一个数组（★★）","uri":"/leetcode/1764/"},{"categories":null,"content":"解答 def canChoose(self, groups: List[List[int]], nums: List[int]) -\u003e bool: i, n = 0, len(nums) for g in groups: while i\u003cn and nums[i:i+len(g)] != g: i += 1 if i==n: return False i += len(g) return True 44 ms ","date":"2021-03-03","objectID":"/leetcode/1764/:3:0","tags":null,"title":"1764：通过连接另一个数组的子数组得到一个数组（★★）","uri":"/leetcode/1764/"},{"categories":null,"content":"前缀和是一种常用的解决区间查询问题的算法。 当数组固定时，根据前缀和即可在 O(1) 时间查询任意区间的和。 当数组动态变化时，则考虑用 树状数组、 线段树 等方法 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:0:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":"1 基础 0303 区域和检索 - 数组不可变 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:1:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":"2 进阶 0134 加油站 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:2:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":"3 挑战 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:3:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":"*4 二维前缀和 0304 二维区域和检索 - 矩阵不可变 ","date":"2021-03-01","objectID":"/algorithm-prefix_sum/:4:0","tags":["算法"],"title":"力扣总结 算法进阶（一）：前缀和","uri":"/algorithm-prefix_sum/"},{"categories":null,"content":"贪心算法是一种高效的搜索方法。在每一步，都选择当前最好的分支，最终即能得到最优解。 能用贪心算法解决的问题，对于贪心正确性的证明往往更加复杂。 因此很多时候需要依赖一定的直觉才能想到贪心策略，即先构造后证明。 而有些不能用贪心解决的问题，如果对用例的考虑不够周全，容易错误地采用贪心策略。 因此使用贪心一定要慎重。 ","date":"2021-02-11","objectID":"/algorithm-greedy/:0:0","tags":["算法"],"title":"力扣总结 常见算法（八）：贪心","uri":"/algorithm-greedy/"},{"categories":null,"content":"1 基础 0502 IPO 0871 最低加油次数 1642 可以到达的最远建筑 1792 最大平均通过率 ","date":"2021-02-11","objectID":"/algorithm-greedy/:1:0","tags":["算法"],"title":"力扣总结 常见算法（八）：贪心","uri":"/algorithm-greedy/"},{"categories":null,"content":"2 进阶 0402 移掉K位数字 0406 根据身高重建队列 1705 吃苹果的最大数目 ","date":"2021-02-11","objectID":"/algorithm-greedy/:2:0","tags":["算法"],"title":"力扣总结 常见算法（八）：贪心","uri":"/algorithm-greedy/"},{"categories":null,"content":"3 挑战 0316 去除重复字母 0321 拼接最大数 ","date":"2021-02-11","objectID":"/algorithm-greedy/:3:0","tags":["算法"],"title":"力扣总结 常见算法（八）：贪心","uri":"/algorithm-greedy/"},{"categories":null,"content":"居庙堂之高而忧苍生，处江湖之远而忧天下。 幼年丧父的何方知练就一身绝技，踏上了寻仇之路。从位于西北边陲十三年前全家被灭门的羊汤店，到山东临清州，又至浙江翠峰山，何方知跨越南北、抽丝剥茧，试图查到杀害父亲的幕后主使。复仇路上，何方知感觉到对手仿佛都是有情有义之辈，他们似乎在拼尽全力保护真正的主谋……","date":"2021-02-05","objectID":"/anime/zhen_dao_ge/","tags":null,"title":"枕刀歌：千里不留行","uri":"/anime/zhen_dao_ge/"},{"categories":null,"content":"简介 居庙堂之高而忧苍生，处江湖之远而忧天下。 幼年丧父的何方知练就一身绝技，踏上了寻仇之路。从位于西北边陲十三年前全家被灭门的羊汤店，到山东临清州，又至浙江翠峰山，何方知跨越南北、抽丝剥茧，试图查到杀害父亲的幕后主使。复仇路上，何方知感觉到对手仿佛都是有情有义之辈，他们似乎在拼尽全力保护真正的主谋…… 制作人员： 动画制作：广州更号三文化传播有限公司 ","date":"2021-02-05","objectID":"/anime/zhen_dao_ge/:1:0","tags":null,"title":"枕刀歌：千里不留行","uri":"/anime/zhen_dao_ge/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 枕刀歌：千里不留行 2021-02-05 12 片库网 2 枕刀歌 特别篇 2021-09-30 2 片库网 ","date":"2021-02-05","objectID":"/anime/zhen_dao_ge/:2:0","tags":null,"title":"枕刀歌：千里不留行","uri":"/anime/zhen_dao_ge/"},{"categories":null,"content":"动态规划是一种特殊的递归，适用于有重叠子问题的场景。 存在大量重叠的子问题时，普通的递归写法会重复计算这些子问题，浪费大量时间。 动态规划会保存所有子问题的结果，避免重复计算。 动态规划也有递归和非递归两种形式。递归形式的动态规划也叫记忆化递归， 非递归形式即是保存中间结果的递推。 python 在递归函数上加一个 @lru_cache(None) 的装饰器即可实现记忆化递归。 非递归形式一般初始化一个 k（动态参数个数）维的数组保存子问题的结果。 递归层数太多时容易爆栈，用非递归形式更好。 但有时所求问题只会用到稀疏的子问题，此时用递归形式更节省时间。 ","date":"2021-02-01","objectID":"/algorithm-dp/:0:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"1 单推 dp 有的问题结果完全依赖于几个初始值和递推式： 有时能用简洁的函数表达式直接表达，比如组合数 有的递推式可以用矩阵快速幂优化时间 ","date":"2021-02-01","objectID":"/algorithm-dp/:1:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"1.1 基础 0062 不同路径 0070 爬楼梯 0096 不同的二叉搜索树 0279 完全平方数 0397 整数替换 0509 斐波那契数 ","date":"2021-02-01","objectID":"/algorithm-dp/:1:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"1.2 进阶 0338 比特位计数 0343 整数拆分 0790 多米诺和托米诺平铺 ","date":"2021-02-01","objectID":"/algorithm-dp/:1:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"1.3 挑战 0552 学生出勤记录 II ","date":"2021-02-01","objectID":"/algorithm-dp/:1:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"2 线性 dp ","date":"2021-02-01","objectID":"/algorithm-dp/:2:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"2.1 基础 0091 解码方法 0322 零钱兑换 0377 组合总和 Ⅳ ","date":"2021-02-01","objectID":"/algorithm-dp/:2:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"2.2 进阶 0032 最长有效括号 0042 接雨水 0131 分割回文串 0403 青蛙过河 0639 解码方法 II 0801 使序列递增的最小交换次数 0823 带因子的二叉树 ","date":"2021-02-01","objectID":"/algorithm-dp/:2:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"2.3 挑战 0005 最长回文子串 0135 分发糖果 0264 丑数 II ","date":"2021-02-01","objectID":"/algorithm-dp/:2:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3 线性 dp 典型问题 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.1 子数组/子串 0053 最大子序和 0152 乘积最大子数组 0413 等差数列划分 0467 环绕字符串中唯一的子字符串 0689 三个无重叠子数组的最大和 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.2 子序列 0300 最长递增子序列 0354 俄罗斯套娃信封问题 0368 最大整除子集 0376 摆动序列 0673 最长递增子序列的个数 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.3 多串 dp 0044 通配符匹配 0097 交错字符串 0115 不同的子序列 0583 两个字符串的删除操作 0712 两个字符串的最小ASCII删除和 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.4 打家劫舍系列 0198 打家劫舍 0213 打家劫舍 II 0740 删除与获得点数 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:4","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.5 股票系列 0121 买卖股票的最佳时机 0122 买卖股票的最佳时机 II 0123 买卖股票的最佳时机 III 0188 买卖股票的最佳时机 IV 0309 最佳买卖股票时机含冷冻期 0714 买卖股票的最佳时机含手续费 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:5","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"3.6 背包 dp 0474 一和零 0518 零钱兑换 II 0638 大礼包 0691 贴纸拼词 ","date":"2021-02-01","objectID":"/algorithm-dp/:3:6","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"4 矩阵 dp ","date":"2021-02-01","objectID":"/algorithm-dp/:4:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"4.1 基础 0063 不同路径 II 0064 最小路径和 0120 三角形最小路径和 ","date":"2021-02-01","objectID":"/algorithm-dp/:4:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"4.2 进阶 0329 矩阵中的最长递增路径 0576 出界的路径数 0688 骑士在棋盘上的概率 0764 最大加号标志 ","date":"2021-02-01","objectID":"/algorithm-dp/:4:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"4.3 挑战 0174 地下城游戏 0221 最大正方形 0741 摘樱桃 ","date":"2021-02-01","objectID":"/algorithm-dp/:4:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"5 区间 DP ","date":"2021-02-01","objectID":"/algorithm-dp/:5:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"5.1 基础 0005 最长回文子串 0516 最长回文子序列 ","date":"2021-02-01","objectID":"/algorithm-dp/:5:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"5.2 进阶 0087 扰乱字符串 0664 奇怪的打印机 ","date":"2021-02-01","objectID":"/algorithm-dp/:5:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"5.3 挑战 0312 戳气球 0375 猜数字大小 II 0546 移除盒子 0730 统计不同回文子序列 ","date":"2021-02-01","objectID":"/algorithm-dp/:5:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"6 哈希 dp 有时需要递推的不是单纯的值，而是集合/计数器 ","date":"2021-02-01","objectID":"/algorithm-dp/:6:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"6.1 基础 0416 分割等和子集 0494 目标和 ","date":"2021-02-01","objectID":"/algorithm-dp/:6:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"6.2 进阶 0241 为运算表达式设计优先级 ","date":"2021-02-01","objectID":"/algorithm-dp/:6:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"6.3 挑战 0446 等差数列划分 II - 子序列 ","date":"2021-02-01","objectID":"/algorithm-dp/:6:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"7 状压 dp 0416 分割等和子集 0473 火柴拼正方形 0526 优美的排列 0698 划分为k个相等的子集 0805 数组的均值分割 ","date":"2021-02-01","objectID":"/algorithm-dp/:7:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"8 数位 dp 0233 数字 1 的个数 0600 不含连续1的非负整数 0788 旋转数字 ","date":"2021-02-01","objectID":"/algorithm-dp/:8:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"9 图上 dp 0126 单词接龙 II ","date":"2021-02-01","objectID":"/algorithm-dp/:9:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"10 博弈 dp 0464 我能赢吗 0486 预测赢家 ","date":"2021-02-01","objectID":"/algorithm-dp/:10:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11 dp 优化 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:0","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.1 dp+上下界 0808 分汤 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:1","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.2 dp+前缀和 0629 K个逆序对数组 0813 最大平均值和的分组 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:2","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.3 dp+二分 0514 自由之路 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:3","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.4 dp+构造 0264 丑数 II 0300 最长递增子序列 0313 超级丑数 0673 最长递增子序列的个数 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:4","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"11.4 dp+折半搜索 0805 数组的均值分割 ","date":"2021-02-01","objectID":"/algorithm-dp/:11:5","tags":["算法"],"title":"力扣总结 常见算法（七）：动态规划","uri":"/algorithm-dp/"},{"categories":null,"content":"dfs（深度优先搜索算法）和 bfs（广度优先搜索算法）都是图形搜索方法， 不同的在于 dfs 先尽可能深的搜索一个分支，再尝试别的路径，而 bfs 按离起点的距离一层层搜索。 dfs 常借助递归实现，而 bfs 常借助队列实现。 dfs 的思想就是回溯，是一种暴力通用解法。有时可以提前判断分支不满足要求，提前返回，被称为剪枝。 树 和 图 常常要用到 dfs 或 bfs 来搜索，这里不涉及。 ","date":"2021-01-21","objectID":"/algorithm-dfs_bfs/:0:0","tags":["算法"],"title":"力扣总结 常见算法（六）：dfs 和 bfs","uri":"/algorithm-dfs_bfs/"},{"categories":null,"content":"1 基础 0022 括号生成 0045 跳跃游戏 II 0078 子集 0386 字典序排数 ","date":"2021-01-21","objectID":"/algorithm-dfs_bfs/:1:0","tags":["算法"],"title":"力扣总结 常见算法（六）：dfs 和 bfs","uri":"/algorithm-dfs_bfs/"},{"categories":null,"content":"2 进阶 0051 N 皇后 0079 单词搜索 0093 复原IP地址 0401 二进制手表 0994 腐烂的橘子 ","date":"2021-01-21","objectID":"/algorithm-dfs_bfs/:2:0","tags":["算法"],"title":"力扣总结 常见算法（六）：dfs 和 bfs","uri":"/algorithm-dfs_bfs/"},{"categories":null,"content":"3 挑战 0037 解数独 0127 单词接龙 0529 扫雷游戏 ","date":"2021-01-21","objectID":"/algorithm-dfs_bfs/:3:0","tags":["算法"],"title":"力扣总结 常见算法（六）：dfs 和 bfs","uri":"/algorithm-dfs_bfs/"},{"categories":null,"content":"题目 给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。 第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。 换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] \u003c= mi 。 如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。 返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。 提示：","date":"2021-01-12","objectID":"/leetcode/1707/:1:0","tags":null,"title":"1707：与数组中元素的最大异或值（★★★）","uri":"/leetcode/1707/"},{"categories":null,"content":"分析 基于 0421 可知，先构建二进制前缀的哈希表或字典树， 即可在 31 步内求得 x 与 nums 中元素的最大异或值。 但本题限制了每轮 nums 的范围，只能取不超过 mi 的元素，所以固定的哈希表或字典树不可行。 有个巧妙的想法是将 nums 排序，在动态地构建哈希表或字典树的过程中， 便得到了任意 mi 所对应的哈希表或字典树。 注意到这种方法得到的 queries 的答案并不是按 queries 的顺序依次得到的。这被称为离线查询。 这里用哈希表方法，更简单。 ","date":"2021-01-12","objectID":"/leetcode/1707/:2:0","tags":null,"title":"1707：与数组中元素的最大异或值（★★★）","uri":"/leetcode/1707/"},{"categories":null,"content":"解答 def maximizeXor(self, nums: List[int], queries: List[List[int]]) -\u003e List[int]: def find(x): ans = 0 for j in range(30, -1, -1): ans \u003c\u003c= 1 ans += int((ans+1)^(x\u003e\u003ej) in A[j]) return ans nums = sorted(set(nums)) queries = sorted((m, idx, x) for idx, (x, m) in enumerate(queries)) A = [set() for _ in ","date":"2021-01-12","objectID":"/leetcode/1707/:3:0","tags":null,"title":"1707：与数组中元素的最大异或值（★★★）","uri":"/leetcode/1707/"},{"categories":null,"content":"*附加 字典树写法。 def maximizeXor(self, nums: List[int], queries: List[List[int]]) -\u003e List[int]: def find(x): ans, p = '', trie for bit in bin(x)[2:].zfill(31): bit_rev = str(int(bit)^1) ans += '1' if bit_rev in p else '0' p = p[bit_rev] if bit_rev in p else p[bit] return int(ans, 2) nums = sorted(set(nums","date":"2021-01-12","objectID":"/leetcode/1707/:4:0","tags":null,"title":"1707：与数组中元素的最大异或值（★★★）","uri":"/leetcode/1707/"},{"categories":null,"content":"二分查找是一种针对有序集合的高效查找算法，时间复杂度为 O(logN)。 二分查找每一轮通过检查中间元素，将查找范围缩小一半，本质上是一种分治。 很多情况下，python 中可以直接调用 bisect 来实现二分查找。 有时中间元素的判定较为复杂，不是直接比较，则可以结合 bisect 和 python 的魔法方法来实现。 ","date":"2021-01-11","objectID":"/algorithm-binary_search/:0:0","tags":["算法"],"title":"力扣总结 常见算法（五）：二分查找","uri":"/algorithm-binary_search/"},{"categories":null,"content":"1 基础 0034 在排序数组中查找元素的第一个和最后一个位置 0069 x 的平方根 0074 搜索二维矩阵 0278 第一个错误的版本 0374 猜数字大小 ","date":"2021-01-11","objectID":"/algorithm-binary_search/:1:0","tags":["算法"],"title":"力扣总结 常见算法（五）：二分查找","uri":"/algorithm-binary_search/"},{"categories":null,"content":"2 进阶 0033 搜索旋转排序数组 0081 搜索旋转排序数组 II 0153 寻找旋转排序数组中的最小值 0154 寻找旋转排序数组中的最小值 II 0162 寻找峰值 0222 完全二叉树的节点个数 ","date":"2021-01-11","objectID":"/algorithm-binary_search/:2:0","tags":["算法"],"title":"力扣总结 常见算法（五）：二分查找","uri":"/algorithm-binary_search/"},{"categories":null,"content":"3 挑战 0004 寻找两个正序数组的中位数 0209 长度最小的子数组 ","date":"2021-01-11","objectID":"/algorithm-binary_search/:3:0","tags":["算法"],"title":"力扣总结 常见算法（五）：二分查找","uri":"/algorithm-binary_search/"},{"categories":null,"content":"“我要在这个异世界拿出真本事！”\n34岁童贞且无职的家里蹲男子，在父母的葬礼当天被赶出家门后，在路上被一辆卡车所撞死。意识清醒后，他发现自己居然作为一个刚出生的婴儿转生到了剑与魔法的异世界！像废物一样活过了前世的男子，发誓要作为少年·鲁迪乌斯在异世界以认真的态度好好活下去！\n等待着鲁迪乌斯的是，与娇小魔术师、有着精灵长耳又很男孩子气的美少女、凶暴的傲娇大小姐以及其他性格各异的人们之间的邂逅，当然也还有残酷的冒险与战斗。\n新的人生就要开始了！“人生重来型”幻想冒险谭，在此开幕！","date":"2021-01-10","objectID":"/anime/jobless_reincarnation/","tags":null,"title":"无职转生 ～在异世界认真地活下去～","uri":"/anime/jobless_reincarnation/"},{"categories":null,"content":"简介 “我要在这个异世界拿出真本事！” 34岁童贞且无职的家里蹲男子，在父母的葬礼当天被赶出家门后，在路上被一辆卡车所撞死。意识清醒后，他发现自己居然作为一个刚出生的婴儿转生到了剑与魔法的异世界！像废物一样活过了前世的男子，发誓要作为少年·鲁迪乌斯在异世界以认真的态度好好活下去！ 等待着鲁迪乌斯的是，与娇小魔术师、有着精灵长耳又很男孩子气的美少女、凶暴的傲娇大小姐以及其他性格各异的人们之间的邂逅，当然也还有残酷的冒险与战斗。 新的人生就要开始了！“人生重来型”幻想冒险谭，在此开幕！ 制作人员： 原作：不讲理的痒痒挠 导演：冈本学 脚本：平野宏树、中本宗应、齐藤浩央 分镜：小林敦、重原克也、三盐","date":"2021-01-10","objectID":"/anime/jobless_reincarnation/:1:0","tags":null,"title":"无职转生 ～在异世界认真地活下去～","uri":"/anime/jobless_reincarnation/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鲁迪乌斯·格雷拉特 卢迪乌斯·格雷拉特、Rudeus Greyrat、鲁迪、泥沼 男 内山夕実 2 洛琪希·米格路迪亚·格雷拉特 Roxy Migurdia Greyrat、教育之神 女 小原好美 3 艾莉丝·格雷拉特 エリス・ボレアス・グレイラット、艾莉丝·伯雷亚斯·格雷拉特、Eris Greyrat、狂犬、狂剑王 女 加隈亜衣 4 希露菲叶特·格雷拉特 希露菲爱特·格雷拉特、Sylphiette Greyrat、希露弗、希露菲、沉默的菲兹 女 茅野愛衣 5 保罗·格雷拉特 Paul Greyrat 男 森川智之 6 塞妮丝·格雷拉特 Zenith Gre","date":"2021-01-10","objectID":"/anime/jobless_reincarnation/:2:0","tags":null,"title":"无职转生 ～在异世界认真地活下去～","uri":"/anime/jobless_reincarnation/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 无职转生 ～在异世界认真地活下去～ 2021-01-10 11 樱花 2 无职转生 ～在异世界认真地活下去～ 第二部分 2021-10-03 12 樱花 3 无职转生 ～在异世界认真地活下去～ OVA 2022-03-16 1 樱花 ","date":"2021-01-10","objectID":"/anime/jobless_reincarnation/:3:0","tags":null,"title":"无职转生 ～在异世界认真地活下去～","uri":"/anime/jobless_reincarnation/"},{"categories":null,"content":"题目 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。 一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。 也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。 你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。 请你返回你能得到的 最大得分 。 示例 1： 输入：nums = [1,-1,-2,4,-7,3], k = 2\r输出：7\r解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。\r示例 2： 输入：nums = ","date":"2021-01-01","objectID":"/leetcode/1696/:1:0","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"分析 ","date":"2021-01-01","objectID":"/leetcode/1696/:2:0","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"#1 类似 1425，令 dp[j] 代表到达位置 j 的最大得分，那么可以递推： dp[j] = nums[j]+max(dp[j-k:j])\r然后边递推边滑动 dp 数组，转为滑动窗口最大值问题。 def maxResult(self, nums: List[int], k: int) -\u003e int: from sortedcontainers import SortedList sl, dp = SortedList(), nums[:] for j, num in enumerate(nums): if j: dp[j] = num + sl[-1] sl.add(dp[j]) if ","date":"2021-01-01","objectID":"/leetcode/1696/:2:1","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"#2 也可以用单调队列的方法。 ","date":"2021-01-01","objectID":"/leetcode/1696/:2:2","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"解答 def maxResult(self, nums: List[int], k: int) -\u003e int: queue, dp = deque(), nums[:] for j, num in enumerate(nums): if j: dp[j] = num + queue[0][0] while queue and queue[-1][0]\u003c=dp[j]: queue.pop() queue.append((dp[j], j)) if queue[0][1] == j-k: queue.popleft() return dp[-1] 340 ms ","date":"2021-01-01","objectID":"/leetcode/1696/:3:0","tags":null,"title":"1696：跳跃游戏 VI（★★）","uri":"/leetcode/1696/"},{"categories":null,"content":"双指针算法一般指两个指针在数组上相向移动来解决问题的算法。 双指针算法常应用在具有某种有序性质的问题上，本质上是一种减少了搜索范围的递归。 广义来说，用两个变量在线性结构上遍历来解决问题的方法都可以归为双指针算法。 比如链表上的快慢指针、部分滑动窗口问题。 用双指针来解决滑动窗口问题时，两个指针同向移动，常应用在某种限制条件下的窗口最值问题。 有些滑动窗口问题更加复杂，还需要用到 有序集合、 滚动哈希 等方法，这里暂不涉及。 ","date":"2021-01-01","objectID":"/algorithm-two_pointers/:0:0","tags":["算法"],"title":"力扣总结 常见算法（四）：双指针和滑动窗口","uri":"/algorithm-two_pointers/"},{"categories":null,"content":"1 基础 0003 无重复字符的最长子串 0167 两数之和 II - 输入有序数组 0209 长度最小的子数组 0345 反转字符串中的元音字母 0643 子数组最大平均数 I ","date":"2021-01-01","objectID":"/algorithm-two_pointers/:1:0","tags":["算法"],"title":"力扣总结 常见算法（四）：双指针和滑动窗口","uri":"/algorithm-two_pointers/"},{"categories":null,"content":"2 进阶 0011 盛最多水的容器 0016 最接近的三数之和 0424 替换后的最长重复字符 0438 找到字符串中所有字母异位词 0713 乘积小于K的子数组 ","date":"2021-01-01","objectID":"/algorithm-two_pointers/:2:0","tags":["算法"],"title":"力扣总结 常见算法（四）：双指针和滑动窗口","uri":"/algorithm-two_pointers/"},{"categories":null,"content":"3 挑战 0030 串联所有单词的子串 0042 接雨水 0076 最小覆盖子串 0992 K 个不同整数的子数组 ","date":"2021-01-01","objectID":"/algorithm-two_pointers/:3:0","tags":["算法"],"title":"力扣总结 常见算法（四）：双指针和滑动窗口","uri":"/algorithm-two_pointers/"},{"categories":null,"content":"递归是指函数自己调用自己的语法现象。 一般递归用于将问题不断转化为规模更小的子问题，直到变为可以直接求解的最简单子问题。 这也就是分治法的思想。 递归是许多算法和数据结构的基础。（这里暂不涉及） 排序 中的快速排序、归并排序，双指针， 二分查找，动态规划 等算法本质上都是分治的思想。 回溯法、dfs 一般借助递归来实现。 树 的定义即是递归的。 递归是自顶向下的，思考逻辑比较自然直接，但有时递归层数太多会爆栈。 所以还需要掌握非递归的写法，也就是自底向上的递推写法。 ","date":"2020-12-21","objectID":"/algorithm-recursion/:0:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":"1 基础 0050 Pow(x, n) 0078 子集 0779 第K个语法符号 ","date":"2020-12-21","objectID":"/algorithm-recursion/:1:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":"2 进阶 0060 排列序列 0301 删除无效的括号 0372 超级次方 0390 消除游戏 0395 至少有 K 个重复字符的最长子串 ","date":"2020-12-21","objectID":"/algorithm-recursion/:2:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":"3 挑战 0273 整数转换英文表示 1823 找出游戏的获胜者 ","date":"2020-12-21","objectID":"/algorithm-recursion/:3:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":"4 树上递归 ","date":"2020-12-21","objectID":"/algorithm-recursion/:4:0","tags":["算法"],"title":"力扣总结 常见算法（三）：递归和分治","uri":"/algorithm-recursion/"},{"categories":null,"content":"位运算是计算机最基础的运算，包括位模式或二进制数的一元和二元操作（\u0026、|、^、~、«、»）。 很多位运算的问题具有较强的技巧性，需要很熟悉各个位运算符的性质。 ","date":"2020-12-11","objectID":"/algorithm-bit/:0:0","tags":["算法"],"title":"力扣总结 常见算法（二）：位运算和状态压缩","uri":"/algorithm-bit/"},{"categories":null,"content":"1 基础 0136 只出现一次的数字 0191 位1的个数 ","date":"2020-12-11","objectID":"/algorithm-bit/:1:0","tags":["算法"],"title":"力扣总结 常见算法（二）：位运算和状态压缩","uri":"/algorithm-bit/"},{"categories":null,"content":"2 进阶 0201 数字范围按位与 0260 只出现一次的数字 III 0338 比特位计数 ","date":"2020-12-11","objectID":"/algorithm-bit/:2:0","tags":["算法"],"title":"力扣总结 常见算法（二）：位运算和状态压缩","uri":"/algorithm-bit/"},{"categories":null,"content":"3 挑战 0137 只出现一次的数字 II ","date":"2020-12-11","objectID":"/algorithm-bit/:3:0","tags":["算法"],"title":"力扣总结 常见算法（二）：位运算和状态压缩","uri":"/algorithm-bit/"},{"categories":null,"content":"题目 给你一个字符串 sequence ，如果字符串 word 连续重复 k 次形成的字符串是 sequence 的一个子字符串， 那么单词 word 的 重复值为 k 。单词 word 的 最大重复值 是单词 word 在 sequence 中最大的重复值。 如果 word 不是 sequence 的子串，那么重复值 k 为 0 。 给你一个字符串 sequence 和 word ，请你返回 最大重复值 k 。 示例 1： 输入：sequence = \"ababc\", word = \"ab\"\r输出：2\r解释：\"abab\" 是 \"ababc\" 的子字符串。\r示例 2： 输入：sequence ","date":"2020-12-04","objectID":"/leetcode/1668/:1:0","tags":null,"title":"1668：最大重复子字符串（★）","uri":"/leetcode/1668/"},{"categories":null,"content":"分析 ","date":"2020-12-04","objectID":"/leetcode/1668/:2:0","tags":null,"title":"1668：最大重复子字符串（★）","uri":"/leetcode/1668/"},{"categories":null,"content":"#1 设 sequence 长度 m，word 长度 n，显然 k 不超过 m//n，从大到小遍历判断即可。 def maxRepeating(self, sequence: str, word: str) -\u003e int: m, n = len(sequence), len(word) for x in range(m//n, 0, -1): if word*x in sequence: return x return 0 32 ms ","date":"2020-12-04","objectID":"/leetcode/1668/:2:1","tags":null,"title":"1668：最大重复子字符串（★）","uri":"/leetcode/1668/"},{"categories":null,"content":"#2 令 check(x) 代表 x*word 是否为 sequence 的子串。显然 check(x) 具有单调性，因此可以用二分查找优化时间。 ","date":"2020-12-04","objectID":"/leetcode/1668/:2:2","tags":null,"title":"1668：最大重复子字符串（★）","uri":"/leetcode/1668/"},{"categories":null,"content":"解答 def maxRepeating(self, sequence: str, word: str) -\u003e int: self.__class__.__getitem__ = lambda self, x: word*x not in sequence return bisect_left(self, True, 1, len(sequence)//len(word)+1)-1 32 ms ","date":"2020-12-04","objectID":"/leetcode/1668/:3:0","tags":null,"title":"1668：最大重复子字符串（★）","uri":"/leetcode/1668/"},{"categories":null,"content":"排序算法是非常经典的一类算法，常作为算法教程的第一章。 最常用的是快速排序、归并排序、堆排序，其思想也不仅应用在排序中。 特别的，当数据范围相对于数据规模较小时，计数排序可能更快。 而桶排序的应用较为灵活，能巧妙地解决一些问题。 python 中一般直接调用 sort 函数来排序，采用的是 TimSort算法， 一种结合了归并排序和插入排序的混合排序算法。 解决很多数组问题时，都可以先排序。比如取不重复元组的问题，通用方法是： 先排序，然后每轮取元素时，相同的数跳过，即可保证元组不重复 ","date":"2020-12-01","objectID":"/algorithm-sort/:0:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":"1 基础 0021 合并两个有序链表 0506 相对名次 0912 排序数组 1030 距离顺序排列矩阵单元格 ","date":"2020-12-01","objectID":"/algorithm-sort/:1:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":"2 进阶 0023 合并K个升序链表 0147 对链表进行插入排序 0148 排序链表 0274 H 指数 0853 车队 ","date":"2020-12-01","objectID":"/algorithm-sort/:2:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":"3 挑战 0179 最大数 0215 数组中的第K个最大元素 ","date":"2020-12-01","objectID":"/algorithm-sort/:3:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":"*4 桶排序 0164 最大间距 0220 存在重复元素 III ","date":"2020-12-01","objectID":"/algorithm-sort/:4:0","tags":["算法"],"title":"力扣总结 常见算法（一）：排序","uri":"/algorithm-sort/"},{"categories":null,"content":"题目 给你一个整数数组 instructions ，你需要根据 instructions 中的元素创建一个有序数组。 一开始你有一个空的数组 nums ，你需要 从左到右 遍历 instructions 中的元素，将它们依次插入 nums 数组中。 每一次插入操作的 代价 是以下两者的 较小值 ： nums 中 严格小于 instructions[i] 的数字数目。 nums 中 严格大于 instructions[i] 的数字数目。 比方说，如果要将 3 插入到 nums = [1,2,3,5] ，那么插入操作的 代价 为 min(2, 1) (元素 1 和 2 小于 3 ，元素 5 大于 ","date":"2020-11-15","objectID":"/leetcode/1649/:1:0","tags":null,"title":"1649：通过指令创建有序数组（★★）","uri":"/leetcode/1649/"},{"categories":null,"content":"分析 容易想到维护一个 nums 的有序集合，然后二分查找即可。 ","date":"2020-11-15","objectID":"/leetcode/1649/:2:0","tags":null,"title":"1649：通过指令创建有序数组（★★）","uri":"/leetcode/1649/"},{"categories":null,"content":"解答 def createSortedArray(self, instructions: List[int]) -\u003e int: from sortedcontainers import SortedList res, sl = 0, SortedList() for x in instructions: res += min(sl.bisect_left(x),len(sl)-sl.bisect_right(x)) sl.add(x) return res % (10**9+7) 3908 ms ","date":"2020-11-15","objectID":"/leetcode/1649/:3:0","tags":null,"title":"1649：通过指令创建有序数组（★★）","uri":"/leetcode/1649/"},{"categories":null,"content":"图是一种比树形结构更复杂的非线性数据结构。 树形结构中的结点是一对多的关系，且有明显的层次关系。 图中的顶点是多对多的关系，无明显的层次关系。 按顶点连线（边）是否有方向，可以将图分为有向图和无向图。 有些图的边还附带数据信息（权），被称为网或网络。 图的遍历和树的遍历相似，但图中可能出现回路，因此常用一个辅助数组或哈希表 vis 记录访问过的顶点。 图最常见的问题有： 最小生成树，常用算法 并查集 拓扑排序，常用算法 bfs 最短路径，常用算法 dijkstra、Bellman-Ford、floyd 割点和桥，常用算法 tarjan 欧拉图，常用算法 Hierholzer ","date":"2020-11-11","objectID":"/algorithm-graph/:0:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"1 基础 0133 克隆图 0797 所有可能的路径 0841 钥匙和房间 0997 找到小镇的法官 ","date":"2020-11-11","objectID":"/algorithm-graph/:1:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"2 拓扑排序 ","date":"2020-11-11","objectID":"/algorithm-graph/:2:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"2.1 基础 0207 课程表 0210 课程表 II 0684 冗余连接 ","date":"2020-11-11","objectID":"/algorithm-graph/:2:1","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"2.2 进阶 0310 最小高度树 0802 找到最终的安全状态 2115 从给定原材料中找到所有可以做出的菜 ","date":"2020-11-11","objectID":"/algorithm-graph/:2:2","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"2.3 挑战 1203 项目管理 1591 奇怪的打印机 II 1857 有向图中最大颜色值 ","date":"2020-11-11","objectID":"/algorithm-graph/:2:3","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"3 最短路径 ","date":"2020-11-11","objectID":"/algorithm-graph/:3:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"3.1 基础 0743 网络延迟时间 1334 阈值距离内邻居最少的城市 1514 概率最大的路径 ","date":"2020-11-11","objectID":"/algorithm-graph/:3:1","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"3.2 进阶 0787 K 站中转内最便宜的航班 0847 访问所有节点的最短路径 0882 细分图中的可到达结点 1368 使网格图至少有一条有效路径的最小代价 lcp35 电动车游城市 ","date":"2020-11-11","objectID":"/algorithm-graph/:3:2","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"3.3 挑战 1786 从第一个节点出发到最后一个节点的受限路径数 1976 到达目的地的方案数 2045 到达目的地的第二短时间 2203 得到要求路径的最小带权子图 ","date":"2020-11-11","objectID":"/algorithm-graph/:3:3","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"4 最小生成树 1584 连接所有点的最小费用 ","date":"2020-11-11","objectID":"/algorithm-graph/:4:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"*5 欧拉图 0332 重新安排行程 0753 破解保险箱 2097 合法重新排列数对 ","date":"2020-11-11","objectID":"/algorithm-graph/:5:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"*6 割点和桥 1192 查找集群内的「关键连接」 1489 找到最小生成树里的关键边和伪关键边 1568 使陆地分离的最少天数 ","date":"2020-11-11","objectID":"/algorithm-graph/:6:0","tags":["算法"],"title":"力扣总结 数据结构（八）：图","uri":"/algorithm-graph/"},{"categories":null,"content":"堆 是一种特别的完全二叉树，每一个节点的值都大于等于或小于等于其孩子节点的值。 堆可以在 O(logN) 时间内插入元素、删除根节点，在 O(1) 时间获得最大值或最小值。一般用于有序弹出元素的场景。 python 中一般直接用内置库 heapq 表示（list 实现的），默认是小顶堆，即堆顶元素是最小值。 额外地，图里面有个重要的 dijkstra 算法常借助堆实现，这里先不涉及。 ","date":"2020-11-01","objectID":"/algorithm-heap/:0:0","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"1 基础 ","date":"2020-11-01","objectID":"/algorithm-heap/:1:0","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"1.1 设计 0703 数据流中的第 K 大元素 1845 座位预约管理系统 ","date":"2020-11-01","objectID":"/algorithm-heap/:1:1","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"1.2 应用 0023 合并K个升序链表 0692 前K个高频单词 1046 最后一块石头的重量 ","date":"2020-11-01","objectID":"/algorithm-heap/:1:2","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"2 进阶 ","date":"2020-11-01","objectID":"/algorithm-heap/:2:0","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"2.1 设计 0295 数据流的中位数 0355 设计推特 ","date":"2020-11-01","objectID":"/algorithm-heap/:2:1","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"2.2 应用 0373 查找和最小的 K 对数字 0786 第 K 个最小的素数分数 1801 积压订单中的订单总数 1834 单线程 CPU ","date":"2020-11-01","objectID":"/algorithm-heap/:2:2","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"3 挑战 0407 接雨水 II 0857 雇佣 K 名工人的最低成本 1439 有序矩阵中的第 k 个最小数组和 ","date":"2020-11-01","objectID":"/algorithm-heap/:3:0","tags":["算法"],"title":"力扣总结 数据结构（七）：堆","uri":"/algorithm-heap/"},{"categories":null,"content":"题目 给你一个 m x n 的矩阵 matrix ，请你返回一个新的矩阵 answer ，其中 answer[row][col] 是 matrix[row][col] 的秩。 每个元素的 秩 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算： 秩是从 1 开始的一个整数。 如果两个元素 p 和 q 在 同一行 或者 同一列 ，那么： 如果 p \u003c q ，那么 rank(p) \u003c rank(q) 如果 p == q ，那么 rank(p) == rank(q) 如果 p \u003e q ，那么 rank(p) \u003e rank(q) 秩 需要越 小 越好。 题目保证按照上面规则 answ","date":"2020-10-29","objectID":"/leetcode/1632/:1:0","tags":null,"title":"1632：矩阵转换后的秩（★★★）","uri":"/leetcode/1632/"},{"categories":null,"content":"分析 先考虑简化情形：没有相同的元素。那么显然最小的元素的秩为 1，第二小的元素则要考虑是否和最小元素同行或同列。 于是得到贪心解法： 从小到大遍历元素，并维护每行/列的最大秩，该元素的秩即为同行/列的最大秩加 1\r存在相同元素时则较为复杂，假设两个相同元素同行/列，那么就要考虑到两个元素分别对应的 行/列 的最大秩。 同时还可能出现连动，比如元素 a 和 b 同行，b 和 c 同列，那么要同时考虑这三个元素。 这种连动容易想到并查集，于是用并查集将相同元素分为几个连通块，对于每个连通块， 里面所有元素对应的 行/列 最大秩 加 1，即为该连通块内所有元素的秩。 ","date":"2020-10-29","objectID":"/leetcode/1632/:2:0","tags":null,"title":"1632：矩阵转换后的秩（★★★）","uri":"/leetcode/1632/"},{"categories":null,"content":"解答 def matrixRankTransform(self, matrix: List[List[int]]) -\u003e List[List[int]]: def find(x): if f.setdefault(x, x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) m, n = len(matrix), len(matrix[0]) d = defaultdict(list) for i, j in product(range(m), range(n)): d[matrix[i][j]]","date":"2020-10-29","objectID":"/leetcode/1632/:3:0","tags":null,"title":"1632：矩阵转换后的秩（★★★）","uri":"/leetcode/1632/"},{"categories":null,"content":"树是一种非线性的数据结构，本质是节点的有限集。其定义是递归的： 有且仅有一个特定的称为根（root）的节点 当节点数量 \u003e 1 时，其余节点可分为若干个互不相交的有限集，其中每个集合也可以看作一颗树，称之为根的子树。 从图的观点来看，树也可视为一个拥有 N 个节点和 N-1 条边的一个有向无环图。 树的应用非常广泛，也常和其它数据结构和算法有联系，尤其是递归。 ","date":"2020-10-21","objectID":"/algorithm-tree/:0:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"1 基础 ","date":"2020-10-21","objectID":"/algorithm-tree/:1:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"1.1 遍历 0094 二叉树的中序遍历 0103 二叉树的锯齿形层序遍历 0144 二叉树的前序遍历 0145 二叉树的后序遍历 0872 叶子相似的树 ","date":"2020-10-21","objectID":"/algorithm-tree/:1:1","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"1.2 递归 0101 对称二叉树 0226 翻转二叉树 0508 出现次数最多的子树元素和 0606 根据二叉树创建字符串 0671 二叉树中第二小的节点 0814 二叉树剪枝 ","date":"2020-10-21","objectID":"/algorithm-tree/:1:2","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"2 进阶 ","date":"2020-10-21","objectID":"/algorithm-tree/:2:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"2.1 遍历 0112 路径总和 0113 路径总和 II 0116 填充每个节点的下一个右侧节点指针 0117 填充每个节点的下一个右侧节点指针 II 0655 输出二叉树 0662 二叉树最大宽度 ","date":"2020-10-21","objectID":"/algorithm-tree/:2:1","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"2.2 递归 0106 从中序与后序遍历序列构造二叉树 0110 平衡二叉树 0124 二叉树中的最大路径和 0236 二叉树的最近公共祖先 0337 打家劫舍 III ","date":"2020-10-21","objectID":"/algorithm-tree/:2:2","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"3 挑战 0834 树中距离之和 0889 根据前序和后序遍历构造二叉树 ","date":"2020-10-21","objectID":"/algorithm-tree/:3:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"*4 二叉搜索树 ","date":"2020-10-21","objectID":"/algorithm-tree/:4:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"4.1 基础 0098 验证二叉搜索树 0108 将有序数组转换为二叉搜索树 0173 二叉搜索树迭代器 0235 二叉搜索树的最近公共祖先 0669 修剪二叉搜索树 0701 二叉搜索树中的插入操作 ","date":"2020-10-21","objectID":"/algorithm-tree/:4:1","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"4.2 进阶 0096 不同的二叉搜索树 0095 不同的二叉搜索树 II 0450 删除二叉搜索树中的节点 0501 二叉搜索树中的众数 0530 二叉搜索树的最小绝对差 0538 把二叉搜索树转换为累加树 ","date":"2020-10-21","objectID":"/algorithm-tree/:4:2","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"4.3 挑战 0099 恢复二叉搜索树 ","date":"2020-10-21","objectID":"/algorithm-tree/:4:3","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"*5 树哈希 0297 二叉树的序列化与反序列化 0449 序列化和反序列化二叉搜索树 0572 另一个树的子树 0652 寻找重复的子树 ","date":"2020-10-21","objectID":"/algorithm-tree/:5:0","tags":["算法"],"title":"力扣总结 数据结构（六）：树","uri":"/algorithm-tree/"},{"categories":null,"content":"栈是一个后入先出的数据结构，插入和删除都在末尾进行。python 中一般直接用 list 表示。 队列是一个先入先出的数据结构，插入在末尾，删除在开头。python 中一般直接用内置库 deque 表示。 额外地，dfs 常借助栈实现，bfs 常借助队列实现，这里先不涉及。 ","date":"2020-10-11","objectID":"/algorithm-stack/:0:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"1 基础 ","date":"2020-10-11","objectID":"/algorithm-stack/:1:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"1.1 设计 0225 用队列实现栈 0232 用栈实现队列 0622 设计循环队列 0641 设计循环双端队列 ","date":"2020-10-11","objectID":"/algorithm-stack/:1:1","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"1.2 应用 0071 简化路径 0150 逆波兰表达式求值 0682 棒球比赛 0946 验证栈序列 1441 用栈操作构建数组 ","date":"2020-10-11","objectID":"/algorithm-stack/:1:2","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"2 进阶 ","date":"2020-10-11","objectID":"/algorithm-stack/:2:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"2.1 设计 0155 最小栈 0341 扁平化嵌套列表迭代器 0895 最大频率栈 1381 设计一个支持增量操作的栈 ","date":"2020-10-11","objectID":"/algorithm-stack/:2:1","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"2.2 应用 0385 迷你语法分析器 0394 字符串解码 0636 函数的独占时间 0735 行星碰撞 0880 索引处的解码字符串 ","date":"2020-10-11","objectID":"/algorithm-stack/:2:2","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"3 挑战 0224 基本计算器 0227 基本计算器 II 0726 原子的数量 0770 基本计算器 IV ","date":"2020-10-11","objectID":"/algorithm-stack/:3:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"*4 括号系列 ","date":"2020-10-11","objectID":"/algorithm-stack/:4:0","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"4.1 基础 0020 有效的括号 1021 删除最外层的括号 1249 移除无效的括号 0921 使括号有效的最少添加 1614 括号的最大嵌套深度 ","date":"2020-10-11","objectID":"/algorithm-stack/:4:1","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"4.2 进阶 0032 最长有效括号 0301 删除无效的括号 0856 括号的分数 1111 有效括号的嵌套深度 1190 反转每对括号间的子串 ","date":"2020-10-11","objectID":"/algorithm-stack/:4:2","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"4.3 挑战 0678 有效的括号字符串 1541 平衡括号字符串的最少插入次数 ","date":"2020-10-11","objectID":"/algorithm-stack/:4:3","tags":["算法"],"title":"力扣总结 数据结构（五）：栈和队列","uri":"/algorithm-stack/"},{"categories":null,"content":"在某个地方有一位旅人。她的名字叫伊蕾娜。\n她是年纪轻轻就成为了最上位的“魔女”的才女。\n憧憬着小时候读过的旅行的故事，\n顺其自然地持续着随心所欲的长途旅行。\n在广大的世界里自由地穿行 ，遇见莫名其妙、可笑的人，\n或是见证到某人的美丽的日常，\n她作为旅人，也没有什么目的，\n重复着和各种各样的国家和人的相遇。\n以及相同数量的——\n\n“请别管我。我就是个旅人，\n必须赶路了。”\n这样的魔女伊蕾娜所编织的离别的物语。","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"简介 在某个地方有一位旅人。她的名字叫伊蕾娜。 她是年纪轻轻就成为了最上位的“魔女”的才女。 憧憬着小时候读过的旅行的故事， 顺其自然地持续着随心所欲的长途旅行。 在广大的世界里自由地穿行 ，遇见莫名其妙、可笑的人， 或是见证到某人的美丽的日常， 她作为旅人，也没有什么目的， 重复着和各种各样的国家和人的相遇。 以及相同数量的—— “请别管我。我就是个旅人， 必须赶路了。” 这样的魔女伊蕾娜所编织的离别的物语。 制作人员： 原作：白石定规 导演：洼冈俊之 脚本：笔安一幸 分镜：平池芳正、板井宽树、高桥顺、西野武志、博多正寿 ","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/:1:0","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊蕾娜 灰之魔女、Elaina、灰の魔女 女 本渡楓 2 芙兰 星尘魔女、Fran、星屑の魔女 女 花澤香菜 3 沙耶 炭之魔女、炭の魔女、Saya 女 黒沢ともよ 4 アムネシア 女 小原好美 5 席拉 Sheila 女 日笠陽子 6 米菈罗赛 女 Lynn 7 艾赫米娅 女 佐藤利奈 8 维多利加 ニケ、妮可、维多莉佳、Vikutorika 女 伊藤静 ","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/:2:0","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔女之旅 2020-10-02 12 bilibili ","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/:3:0","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"MAD ","date":"2020-10-02","objectID":"/anime/majo_no_tabitabi/:4:0","tags":null,"title":"魔女之旅","uri":"/anime/majo_no_tabitabi/"},{"categories":null,"content":"哈希表是针对查询，空间换时间的一种数据结构，一般能够在 O(1) 时间内插入、查询、删除元素， 但不能通过下标访问元素。 哈希表分为哈希集合和哈希映射，哈希集合存储非重复值，哈希映射存储 key 唯一的 (key,value) 对。 python 中一般直接用内置库 set 和 dict 表示哈希集合和哈希映射。 另外还有一些特定用途的内置库，比如 Counter, defaultdict, OrderedDict。 ","date":"2020-10-01","objectID":"/algorithm-hash/:0:0","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1 基础 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:0","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.1 设计 0705 设计哈希集合 0706 设计哈希映射 0535 设计哈希映射 TinyURL 的加密与解密 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:1","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.2 哈希集合 0217 存在重复元素 0349 两个数组的交集 0500 键盘行 0575 分糖果 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:2","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.3 哈希映射 0001 两数之和 0205 同构字符串 0219 存在重复元素 II 0599 两个列表的最小索引总和 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:3","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.4 设计键 0036 有效的数独 0049 字母异位词分组 0318 最大单词长度乘积 0676 实现一个魔法字典 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:4","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"1.5 Counter 0350 两个数组的交集 II 0409 最长回文串 0532 数组中的 k-diff 数对 0594 最长和谐子序列 ","date":"2020-10-01","objectID":"/algorithm-hash/:1:5","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"2 进阶 ","date":"2020-10-01","objectID":"/algorithm-hash/:2:0","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"2.1 设计 0146 LRU 缓存机制 0380 常数时间插入、删除和获取随机元素 0381 O(1) 时间插入、删除和获取随机元素 - 允许重复 ","date":"2020-10-01","objectID":"/algorithm-hash/:2:1","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"2.2 应用 0015 三数之和 0299 猜数字游戏 0447 回旋镖的数量 0454 四数相加 II 0554 砖墙 ","date":"2020-10-01","objectID":"/algorithm-hash/:2:2","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"3 挑战 ","date":"2020-10-01","objectID":"/algorithm-hash/:3:0","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"3.1 设计 0432 全 O(1) 的数据结构 0460 LFU 缓存 0710 黑名单中的随机数 ","date":"2020-10-01","objectID":"/algorithm-hash/:3:1","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"3.2 应用 0149 直线上最多的点数 0166 分数到小数 0336 回文对 1178 猜字谜 ","date":"2020-10-01","objectID":"/algorithm-hash/:3:2","tags":["算法"],"title":"力扣总结 数据结构（四）：哈希表","uri":"/algorithm-hash/"},{"categories":null,"content":"字符串和数组很相似，具有索引，且元素在内存中是连续存储的。不同的是： 字符串更关心整体或子串，而非单个元素。 字符串可以整体比较，还可以按字典序等来排序。 python 中的字符串是不可变的，不能直接修改、添加、删除元素，而应该用切片。 经典的问题有： 字符串匹配，常用 KMP算法、正则表达式。 回文串，常用 Manacher 算法。 额外的，还常用 字典树 解决多字符串匹配问题，这里暂不涉及 ","date":"2020-09-21","objectID":"/algorithm-string/:0:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"1 基础 0009 回文数 0165 比较版本号 0392 判断子序列 0831 隐藏个人信息 1169 查询无效交易 ","date":"2020-09-21","objectID":"/algorithm-string/:1:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"2 进阶 0068 文本左右对齐 0393 UTF-8 编码验证 0459 重复的子字符串 0686 重复叠加字符串匹配 0833 字符串中的查找与替换 ","date":"2020-09-21","objectID":"/algorithm-string/:2:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"3 挑战 0564 寻找最近的回文数 0866 回文素数 ","date":"2020-09-21","objectID":"/algorithm-string/:3:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"4 正则表达式 0008 字符串转换整数 (atoi) 0044 通配符匹配 0065 有效数字 1023 驼峰式匹配 ","date":"2020-09-21","objectID":"/algorithm-string/:4:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"*5 字符串匹配 0005 最长回文子串 0028 实现 strStr() 0214 最短回文串 1392 最长快乐前缀 ","date":"2020-09-21","objectID":"/algorithm-string/:5:0","tags":["算法"],"title":"力扣总结 数据结构（三）：字符串","uri":"/algorithm-string/"},{"categories":null,"content":"链表和数组是最基本的数据结构，是其他数据结构的基础。 链表和数组都是线性结构，但在内存中，数组的元素是连续的，而链表不是。 所以链表是把一些分离独立的元素按引用链接到一起。 链表能在 O(1) 时间插入、删除元素，但需要 O(N) 时间访问到元素，与数组相反。 python 中的内置库 deque 即是用双向链表实现的。 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:0:0","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"1 基础 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:1:0","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"1.1 设计 0707 设计链表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:1:1","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"1.2 操作 0002 两数相加 0024 两两交换链表中的节点 0082 删除排序链表中的重复元素 II 0237 删除链表中的节点 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:1:2","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"2 进阶 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:2:0","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"2.1 操作 0061 旋转链表 0086 分隔链表 0328 奇偶链表 0725 分隔链表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:2:1","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"2.2 快慢指针 0019 删除链表的倒数第 N 个结点 0141 环形链表 0142 环形链表 II 0160 相交链表 0876 链表的中间结点 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:2:2","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"2.3 排序 0021 合并两个有序链表 0023 合并K个升序链表 0147 对链表进行插入排序 0148 排序链表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:2:3","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"3 挑战 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:3:0","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"3.1 设计 0138 复制带随机指针的链表 0430 扁平化多级双向链表 0432 全 O(1) 的数据结构 1206 设计跳表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:3:1","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"3.2 操作 0206 反转链表 0092 反转链表 II 0025 K 个一组翻转链表 0143 重排链表 0234 回文链表 ","date":"2020-09-11","objectID":"/algorithm-linked_list/:3:2","tags":["算法"],"title":"力扣总结 数据结构（二）：链表","uri":"/algorithm-linked_list/"},{"categories":null,"content":"链表和数组是最基本的数据结构，是其他数据结构的基础。 数组和链表的区别 数组和链表都是线性数据结构，区别在于数组具有索引，数组中的元素在内存中是连续存储的。 数组能在 O(1) 时间内访问到元素，但需要 O(N) 时间插入、删除元素，与链表相反。 数组相关的数据结构 基本的 栈、堆 可以用数组表示以外 一些进阶的数据结构比如 并查集、树状数组、 线段树 也可以用数组来表示 数组可以嵌套数组，得到多维数组 数组相关的算法（现在暂不涉及） 有序数组常和 排序、二分查找、 双指针 相关 二维数组常和 dfs、bfs 相关 子数组/子序列常和 滑动窗口、 动态规划 相关 区间计算常和 前缀和、树状数组","date":"2020-09-01","objectID":"/algorithm-array/:0:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":"1 基础 0080 删除排序数组中的重复项 II 0283 移动零 0448 找到所有数组中消失的数字 0485 最大连续 1 的个数 0724 寻找数组的中心下标 ","date":"2020-09-01","objectID":"/algorithm-array/:1:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":"2 进阶 0075 颜色分类 0128 最长连续序列 0189 旋转数组 0238 除自身以外数组的乘积 ","date":"2020-09-01","objectID":"/algorithm-array/:2:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":"3 挑战 0041 缺失的第一个正数 0284 顶端迭代器 0287 寻找重复数 ","date":"2020-09-01","objectID":"/algorithm-array/:3:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":"*4 二维数组 0048 旋转图像 0054 螺旋矩阵 0059 螺旋矩阵 II 0073 矩阵置零 0289 生命游戏 0463 岛屿的周长 0835 图像重叠 1992 找到所有的农场组 ","date":"2020-09-01","objectID":"/algorithm-array/:4:0","tags":["算法"],"title":"力扣总结 数据结构（一）：数组","uri":"/algorithm-array/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2020-08-30","objectID":"/leetcode/1591/:0:0","tags":null,"title":"1591：奇怪的打印机 II（★★★）","uri":"/leetcode/1591/"},{"categories":null,"content":"题目 给你一个奇怪的打印机，它有如下两个特殊的打印规则： 每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。 一旦矩形根据上面的规则使用了一种颜色，那么 相同的颜色不能再被使用 。 给你一个初始没有颜色的 m x n 的矩形 targetGrid ，其中 targetGrid[row][col] 是位置 (row, col) 的颜色。 如果你能按照上述规则打印出矩形 targetGrid ，请你返回 true ，否则返回 false 。 示例 1： 输入：targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1","date":"2020-08-30","objectID":"/leetcode/1591/:1:0","tags":null,"title":"1591：奇怪的打印机 II（★★★）","uri":"/leetcode/1591/"},{"categories":null,"content":"分析 一种颜色只能打印一次，因此每种颜色打印的矩形必然包括了该颜色的所有点。 因此，某种颜色所有点的边界即对应了打印的矩形（更大没有意义）。确定了每种颜色的打印矩形，问题只在于打印顺序。 假如某个颜色 c 的矩形包含了其它颜色 c2，那么 c 必须在 c2 之前打印。如果不包含其它颜色，那么 c 可以最后打印。 于是转为拓扑排序问题，判断是否存在拓扑顺序即可。 ","date":"2020-08-30","objectID":"/leetcode/1591/:2:0","tags":null,"title":"1591：奇怪的打印机 II（★★★）","uri":"/leetcode/1591/"},{"categories":null,"content":"解答 def isPrintable(self, targetGrid: List[List[int]]) -\u003e bool: m, n = len(targetGrid), len(targetGrid[0]) d = defaultdict(lambda: defaultdict(set)) for i, j in product(range(m), range(n)): c = targetGrid[i][j] d[c]['X'].add(i) d[c]['Y'].add(j) nxt, indeg = defaultdict(set), defaultdict(int) for c in","date":"2020-08-30","objectID":"/leetcode/1591/:3:0","tags":null,"title":"1591：奇怪的打印机 II（★★★）","uri":"/leetcode/1591/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2020-08-23","objectID":"/leetcode/1584/:0:0","tags":null,"title":"1584：连接所有点的最小费用（★★）","uri":"/leetcode/1584/"},{"categories":null,"content":"题目 给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。 请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。 示例 1： 输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\r输出：20\r解释：\r我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。\r注意到任意两个点之间只","date":"2020-08-23","objectID":"/leetcode/1584/:1:0","tags":null,"title":"1584：连接所有点的最小费用（★★）","uri":"/leetcode/1584/"},{"categories":null,"content":"分析 典型的最小生成树问题，按费用排序，依次判断是否添加边即可。 ","date":"2020-08-23","objectID":"/leetcode/1584/:2:0","tags":null,"title":"1584：连接所有点的最小费用（★★）","uri":"/leetcode/1584/"},{"categories":null,"content":"解答 def minCostConnectPoints(self, points: List[List[int]]) -\u003e int: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def cal(p1, p2): return abs(p1[0]-p2[0])+abs(p1[1]-p2[1]) n = len(points) A = [[cal(points[i], points[j]), i, j] for i in range(n) for j i","date":"2020-08-23","objectID":"/leetcode/1584/:3:0","tags":null,"title":"1584：连接所有点的最小费用（★★）","uri":"/leetcode/1584/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2020-08-07","objectID":"/leetcode/1568/:0:0","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"题目 给你一个由若干 0 和 1 组成的二维网格 grid ，其中 0 表示水，而 1 表示陆地。 岛屿由水平方向或竖直方向上相邻的 1 （陆地）连接形成。 如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。 一天内，可以将任何单个陆地单元（1）更改为水单元（0）。 返回使陆地分离的最少天数。 示例 1： 输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\r输出：2\r解释：至少需要 2 天才能得到分离的陆地。\r将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。\r示例 2： 输入：grid = [[1,","date":"2020-08-07","objectID":"/leetcode/1568/:1:0","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"分析 ","date":"2020-08-07","objectID":"/leetcode/1568/:2:0","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"#1 观察发现，只要岛屿有对角相连的网格，那么将该 2x2 的区域内的其它网格置 0，即可让岛屿分离。 因此最多需要两天。那么： 假如一开始就没有岛屿或者多个岛屿，返回 0\r遍历岛屿网格，若置为 0 后岛屿分离，返回 1\r其它情况，返回 2 计算岛屿数量，用并查集即可。 def minDays(self, grid: List[List[int]]) -\u003e int: def find(x): if f.setdefault(x,x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def cal","date":"2020-08-07","objectID":"/leetcode/1568/:2:1","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"#2 找某个岛屿网格，使得去掉后岛屿分离，这其实就是找无向图的割点，可以用 tarjan 算法。 注意特殊情况，岛屿只有一个网格时，没有割点，但只需要 1 天 ","date":"2020-08-07","objectID":"/leetcode/1568/:2:2","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"解答 def minDays(self, grid: List[List[int]]) -\u003e int: def find(x): if f.setdefault(x,x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def cal(A): f.clear() for i, j in A: for x, y in [(i-1, j), (i, j-1), (i+1, j), (i, j+1)]: if (x, y) in A: union((i, j), (x, y)) return len(","date":"2020-08-07","objectID":"/leetcode/1568/:3:0","tags":null,"title":"1568：使陆地分离的最少天数（★★★）","uri":"/leetcode/1568/"},{"categories":null,"content":"上古时期妖兽纵横，一位神秘道人分别授予了阴阳五行的特殊能力给金木水火土五个家族来抵抗妖兽。他们将妖兽驱赶到神隐雾山之中，设立结界。雾山之中另有强大灵力的麒麟兽常常吸引来那些想要提升妖力突破结界，因此自愿被封印于巨阙神盾之中。火行使者闻人翊悬为救其母私自打开了巨阙神盾，小麒麟趁机偷溜出来，妖兽界将掀起一股腥风血雨……","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":"简介 上古时期妖兽纵横，一位神秘道人分别授予了阴阳五行的特殊能力给金木水火土五个家族来抵抗妖兽。他们将妖兽驱赶到神隐雾山之中，设立结界。雾山之中另有强大灵力的麒麟兽常常吸引来那些想要提升妖力突破结界，因此自愿被封印于巨阙神盾之中。火行使者闻人翊悬为救其母私自打开了巨阙神盾，小麒麟趁机偷溜出来，妖兽界将掀起一股腥风血雨…… 制作人员： 导演：林魂 製作：bilibili ","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/:1:0","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 闻人翊悬 男 郭盛 2 嗔兽孔雀 男（人形状态） 郝祥海 3 苏小安 女 阎么么 4 白义 男 刘琮 5 申屠子夜 水行 男 郝祥海 6 山子 男 宝木中阳 7 渠黄 男 陈喆 8 水冠 林魂 ","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/:2:0","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 雾山五行 2020-07-26 3 bilibili ","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/:3:0","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":"MAD ","date":"2020-07-26","objectID":"/anime/wu_shan_wu_xing/:4:0","tags":null,"title":"雾山五行","uri":"/anime/wu_shan_wu_xing/"},{"categories":null,"content":"2018年10月，Google 发布 BERT 模型，然后 BERT 横扫了 NLP 的各个任务： 文本分类、序列标注、文本摘要、信息检索、问答系统、阅读理解等等。 到如今，BERT 及其变种几乎一统了 NLU（Natural Language Understanding，自然语言理解）领域， 只有 GPT 模型依托 NLG（Natural Language Generation，自然语言生成）领域能与之周旋。 而细究下来，GPT 与 BERT 的结构其实只有一处不同。 不夸张地说，这是属于 BERT 的时代。因此，本文对 BERT 及其之后的发展作一个粗略的小结，以供参考。 ","date":"2020-06-21","objectID":"/nlp-bert_family/:0:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"BERT：一切之始 BERT，全称 Bidirectional Encoder Representation from Transformers， 融合了前辈 GPT 和 ELMO 的优点，是 NLP 模型的一个里程碑。 BERT 模型结构 BERT的核心特点在于： 1）两阶段的预训练过程。第一阶段利用语言模型进行预训练；第二阶段是迁移学习， 将预训练网络结构中的高层特征用于下游任务，进行微调。与以前的 Word2Vec 的区别在于， 下游任务不仅利用了预训练网络的 Word Embedding 层，还利用了更高层的特征。这个结构来源于 GPT； 2）采用 双向的 Transformer 提取","date":"2020-06-21","objectID":"/nlp-bert_family/:1:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"后 BERT 时代：八仙过海 BERT 点燃了 NLP 的新一轮热潮，各大公司开始堆人堆钱各显神通，不断刷新热点。其中的进展可以粗略地分为三个方向。 ","date":"2020-06-21","objectID":"/nlp-bert_family/:2:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"一、大：有钱任性，大力出奇迹 其实从工程的视角来看，BERT 本身已可算为巨型模型。BERT-Large 的预训练语料共 16 G，模型参数 3.4 亿， 整个预训练过程用 64 块 TPU 芯片跑了 4 天。 然而，或许是 BERT 的成功带来了启发，各大巨头在烧钱的路上一去不返。 2019年2月，OpenAI 发布 GPT 升级版 GPT-2，预训练语料用了 800 万个网页，总共 40 G，而模型参数也增加到 15 亿 2019年6月，谷歌提出 XLNET，预训练语料增长为 113 G 2019年7月，facebook 发布 BERT 升级版 RoBERTa，预训练语料 160 G 20","date":"2020-06-21","objectID":"/nlp-bert_family/:2:1","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"二、小：落地为王，浓缩才是精华 虽然原始的 BERT 在各个怪物面前不算啥，但想要工程落地，依然过于笨重。因此在模型压缩的方向，也有不少的努力和尝试。 Compressing BERT：利用剪枝技术，去掉模型中影响较小的参数或层 Q-BERT：利用量化技术，用低精度取代高精度模型 ALBERT：利用参数共享技术，将所有 transformer 层的参数共享，减少训练时间 DistilBERT / TinyBERT：利用知识蒸馏技术，将大型模型的知识蒸馏到小型模型 FastBERT：利用自适应推理技术，减少简单样本的推理时间 ······ 目前，这些尝试或许不尽如人意，很难保证模型的效果，但这个","date":"2020-06-21","objectID":"/nlp-bert_family/:2:2","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"三、改：创新与微创新，哪里能改改哪里 BERT模型虽然效果很好，但其设计也有明显的缺陷，即预训练过程的任务是MLM而微调过程的下游任务大多是自回归语言模型。 两个过程的不一致导致了部分信息的损失，也使得BERT不适合NLG任务。因此，如何改进设计就举足轻重。 而在细节方面，自然也有不断的尝试。 ERNIE / BERT-WWM：针对中文模型，改进 mask 方式，ERNIE mask 掉实体和短语，BERT-WWM mask 掉词 StructBERT：新添了词序重建和句序判定两个预训练任务，即预测出句子中正确的词语顺序和文章中正确的句子对顺序 MASS / T5：将 BERT 的 Trans","date":"2020-06-21","objectID":"/nlp-bert_family/:2:3","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"展望：路漫漫其修远兮 未来 BERT 的发展之快其实已超出很多人的想象，然而往前看，NLP 的道路依然十分漫长。 从工程上讲，如何得到效果更好的轻量模型，如何解决实际项目中样本不足的困境，依然是巨大的挑战。 从学术上讲，BERT 哪怕利用到极限，似乎离 NLP 的真正目标——让机器理解自然语言，还是隔着天堑。 希望下一个里程碑，能够尽快到来。 ","date":"2020-06-21","objectID":"/nlp-bert_family/:3:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":"参考文献 1.Pre-trained Models for Natural Language Processing: A Survey, Xipeng Qiu, 2020. 2.Deep contextualized word representations, Matthew E. Peters, NAACL 2018. (ELMo) 3.Improving Language Understanding by Generative Pre-Training, Alec Radford, 2018 (GPT) 4.BERT: Pre-training of Deep Bidirectional ","date":"2020-06-21","objectID":"/nlp-bert_family/:4:0","tags":["nlp"],"title":"后 BERT 时代小结","uri":"/nlp-bert_family/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2020-06-16","objectID":"/leetcode/1499/:0:0","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"题目 给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也 就是说 points[i] = [xi, yi] ，并且在 1 \u003c= i \u003c j \u003c= points.length 的前提下， xi \u003c xj 总成立。 请你找出 yi + yj + |xi - xj| 的 最大值，其中 |xi - xj| \u003c= k 且 1 \u003c= i \u003c j \u003c= points.length。 题目测试数据保证至少存在一对能够满足 |xi - xj| \u003c= k 的点。 示例 1： 输入：points = [[1,3],[2,0],[5,10],","date":"2020-06-16","objectID":"/leetcode/1499/:1:0","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"分析 ","date":"2020-06-16","objectID":"/leetcode/1499/:2:0","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"#1 显然可以遍历 j，然后在满足 xj-k\u003c=xi\u003cxj 的 i 中，找最大的 yi-xi。 那么是典型的滑动窗口问题，而维护 yi-xi 的最大值则可以用有序集合。 def findMaxValueOfEquation(self, points: List[List[int]], k: int) -\u003e int: from sortedcontainers import SortedList sl = SortedList() res, i = float('-inf'), 0 for j, (x, y) in enumerate(points): while points[i][0]\u003cx-","date":"2020-06-16","objectID":"/leetcode/1499/:2:1","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"#2 还可以用单调队列维护窗口的最大值。 ","date":"2020-06-16","objectID":"/leetcode/1499/:2:2","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"解答 def findMaxValueOfEquation(self, points: List[List[int]], k: int) -\u003e int: res, queue = float('-inf'), deque() for x, y in points: while queue and queue[0][0]\u003cx-k: queue.popleft() if queue: res = max(res, queue[0][1]+x+y) while queue and queue[-1][1]\u003c=y-x: queue.pop() queue.append((x, y-x)) return","date":"2020-06-16","objectID":"/leetcode/1499/:3:0","tags":null,"title":"1499：满足不等式的最大值（★★★）","uri":"/leetcode/1499/"},{"categories":null,"content":"题目 给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成， 其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。 指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。 如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。 示例 1： 输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.","date":"2020-06-14","objectID":"/leetcode/1514/:1:0","tags":null,"title":"1514：概率最大的路径（★★）","uri":"/leetcode/1514/"},{"categories":null,"content":"分析 类似于最短路，只不过权重从相加改为了相乘，依然可以用 dijkstra 算法。 python 自带的是小顶堆，因此将初始权重设为 -1，最终结果再取反即可。 ","date":"2020-06-14","objectID":"/leetcode/1514/:2:0","tags":null,"title":"1514：概率最大的路径（★★）","uri":"/leetcode/1514/"},{"categories":null,"content":"解答 def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -\u003e float: nxt = defaultdict(list) for (u, v), w in zip(edges, succProb): nxt[u].append((v, w)) nxt[v].append((u, w)) d, pq = {}, [(-1, start)] while pq: w, u = heappop(pq) if u == end: return -w ","date":"2020-06-14","objectID":"/leetcode/1514/:3:0","tags":null,"title":"1514：概率最大的路径（★★）","uri":"/leetcode/1514/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2020-06-06","objectID":"/leetcode/1489/:0:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":"题目 给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组 edges ，其中 edges[i] = [fromi, toi, weighti] 表示在 fromi 和 toi 节点之间有一条带权无向边。 最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。 请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加， 那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。 请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的","date":"2020-06-06","objectID":"/leetcode/1489/:1:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":"分析 先求出 MST 的代价 s。如果去掉某条边，不存在 MST 或者 s 变大，即说明是关键边。 如果先连某条边，s 不变，说明该边出现在 MST 中，那么它要么是关键边，要么是伪关键边。 ","date":"2020-06-06","objectID":"/leetcode/1489/:2:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":"解答 def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -\u003e List[List[int]]: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def cal(A): f[:], s, cnt = list(range(n)), 0, 0 for w, u, v, idx in A: if find(u) != find(v): union(u, v)","date":"2020-06-06","objectID":"/leetcode/1489/:3:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":"*附加 本题还有更优的算法。 假设边的权重各不相同，那么显然生成 MST 的每一步都是确定的，MST 唯一。因此该唯一的 MST 中的都是关键边，不存在伪关键边。 存在相同权重的边时，情况复杂很多。假设生成 MST 的过程遍历到权重 w，权重等于 w 的边的集合是 A。 并设此时的并查集状态是 U0，将 A 的边都相连后的并查集状态是 U1。 那么 A 中的边有三种情况： 假如边的两个顶点在 U0 状态下已连通，该边多余\r假如去掉该边后，U1 状态变化，该边是关键边\r否则该边是伪关键边\r然后有个巧妙的想法，将 U0 状态下的连通块看作是点，将 A 的边都相连后得到一个图 G，那么 A 中的边的","date":"2020-06-06","objectID":"/leetcode/1489/:4:0","tags":null,"title":"1489：找到最小生成树里的关键边和伪关键边（★★★）","uri":"/leetcode/1489/"},{"categories":null,"content":"题目 你总共需要上 numCourses 门课，课程编号依次为 0 到 numCourses-1 。你会得到一个数组 prerequisite ， 其中 prerequisites[i] = [ai, bi] 表示如果你想选 bi 课程，你 必须 先选 ai 课程。 有的课会有直接的先修课程，比如如果想上课程 1 ，你必须先上课程 0 ，那么会以 [0,1] 数对的形式给出先修课程数对。 先决条件也可以是 间接 的。如果课程 a 是课程 b 的先决条件，课程 b 是课程 c 的先决条件，那么课程 a 就是课程 c 的先决条件。 你也得到一个数组 queries ，其中 queries[j] =","date":"2020-05-10","objectID":"/leetcode/1462/:1:0","tags":null,"title":"1462：课程表 IV（★★）","uri":"/leetcode/1462/"},{"categories":null,"content":"分析 有向无环图，可以直接递归求课程 u 的所有先决条件。 ","date":"2020-05-10","objectID":"/leetcode/1462/:2:0","tags":null,"title":"1462：课程表 IV（★★）","uri":"/leetcode/1462/"},{"categories":null,"content":"解答 def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -\u003e List[bool]: @lru_cache(None) def dfs(u): return reduce(or_, [dfs(v) for v in nxt[u]], set(nxt[u])) nxt = defaultdict(list) for v, u in prerequisites: nxt[u].append(v) return [u in dfs(v) fo","date":"2020-05-10","objectID":"/leetcode/1462/:3:0","tags":null,"title":"1462：课程表 IV（★★）","uri":"/leetcode/1462/"},{"categories":null,"content":"题目 给你一个二进制字符串 s 和一个整数 k 。如果所有长度为 k 的二进制字符串都是 s 的子串， 请返回 true ，否则请返回 false 。 示例 1： 输入：s = \"00110110\", k = 2\r输出：true\r解释：长度为 2 的二进制串包括 \"00\"，\"01\"，\"10\" 和 \"11\"。\r它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。\r示例 2： 输入：s = \"0110\", k = 1\r输出：true\r解释：长度为 1 的二进制串包括 \"0\" 和 \"1\"，显然它们都是 s 的子串。\r示例 3： 输入：s = \"0110\", k = 2\r输出：fals","date":"2020-05-09","objectID":"/leetcode/1461/:1:0","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★★）","uri":"/leetcode/1461/"},{"categories":null,"content":"分析 ","date":"2020-05-09","objectID":"/leetcode/1461/:2:0","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★★）","uri":"/leetcode/1461/"},{"categories":null,"content":"#1 最简单的就是看所有长度 k 的子串集合是否有 2^k 个即可。 def hasAllCodes(self, s: str, k: int) -\u003e bool: return len({s[i:i+k] for i in range(len(s)-k+1)})==(1\u003c\u003ck) 356 ms ","date":"2020-05-09","objectID":"/leetcode/1461/:2:1","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★★）","uri":"/leetcode/1461/"},{"categories":null,"content":"#2 注意到如果将子串用对应的十进制值代替，那么相邻的子串的值可以递推，从而节省时间。 这其实就是滚动哈希的思想。 ","date":"2020-05-09","objectID":"/leetcode/1461/:2:2","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★★）","uri":"/leetcode/1461/"},{"categories":null,"content":"解答 def hasAllCodes(self, s: str, k: int) -\u003e bool: res, w = set(), 0 for j, char in enumerate(s): w = w*2+(char=='1') if j\u003e=k: w -= (s[j-k]=='1')*(1\u003c\u003ck) if j\u003e=k-1: res.add(w) return len(res)==(1\u003c\u003ck) 600 ms ","date":"2020-05-09","objectID":"/leetcode/1461/:3:0","tags":null,"title":"1461：检查一个字符串是否包含所有长度为 K 的二进制子串（★★）","uri":"/leetcode/1461/"},{"categories":null,"content":"题目 给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。 请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。 如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。 如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。 如果 searchWord 不是任何单词的前缀，则返回 -1 。 字符串 s 的 前缀 是 s 的任何前导连续子字符串。 示例 1： 输入：sentence = \"i","date":"2020-05-03","objectID":"/leetcode/1455/:1:0","tags":null,"title":"1455：检查单词是否为句中其他单词的前缀（★）","uri":"/leetcode/1455/"},{"categories":null,"content":"分析 遍历判断即可。 ","date":"2020-05-03","objectID":"/leetcode/1455/:2:0","tags":null,"title":"1455：检查单词是否为句中其他单词的前缀（★）","uri":"/leetcode/1455/"},{"categories":null,"content":"解答 def isPrefixOfWord(self, sentence: str, searchWord: str) -\u003e int: for i, w in enumerate(sentence.split()): if w.startswith(searchWord): return i+1 return -1 40 ms ","date":"2020-05-03","objectID":"/leetcode/1455/:3:0","tags":null,"title":"1455：检查单词是否为句中其他单词的前缀（★）","uri":"/leetcode/1455/"},{"categories":null,"content":"Ian 的个人博客，专注于 MAD、动画、游戏、 力扣。 ","date":"2020-05-01","objectID":"/about/:0:0","tags":[],"title":"关于","uri":"/about/"},{"categories":null,"content":"今日歌单 ","date":"2020-05-01","objectID":"/about/:0:1","tags":[],"title":"关于","uri":"/about/"},{"categories":null,"content":"今日MAD ","date":"2020-05-01","objectID":"/about/:0:2","tags":[],"title":"关于","uri":"/about/"},{"categories":null,"content":"题目 给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 n 的 最简 分数。 分数可以以 任意 顺序返回。 示例 1： 输入：n = 2\r输出：[\"1/2\"]\r解释：\"1/2\" 是唯一一个分母小于等于 2 的最简分数。\r示例 2： 输入：n = 3\r输出：[\"1/2\",\"1/3\",\"2/3\"]\r示例 3： 输入：n = 4\r输出：[\"1/2\",\"1/3\",\"1/4\",\"2/3\",\"3/4\"]\r解释：\"2/4\" 不是最简分数，因为它可以化简为 \"1/2\" 。\r示例 4： 输入：n = 1\r输出：[]\r提示： 1 \u003c= n \u003c= 100 ","date":"2020-04-25","objectID":"/leetcode/1447/:1:0","tags":null,"title":"1447：最简分数（★）","uri":"/leetcode/1447/"},{"categories":null,"content":"分析 遍历所有 0\u003c分子\u003c分母\u003c=n 的分数，判断是否是最简分数即可。 ","date":"2020-04-25","objectID":"/leetcode/1447/:2:0","tags":null,"title":"1447：最简分数（★）","uri":"/leetcode/1447/"},{"categories":null,"content":"解答 def simplifiedFractions(self, n: int) -\u003e List[str]: return ['%d/%d'%(x,y) for y in range(2, n+1) for x in range(1, y) if gcd(x, y)==1] 72 ms ","date":"2020-04-25","objectID":"/leetcode/1447/:3:0","tags":null,"title":"1447：最简分数（★）","uri":"/leetcode/1447/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度， 该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。 如果不存在满足条件的子数组，则返回 0 。 示例 1： 输入：nums = [8,2,4,7], limit = 4\r输出：2 解释：所有子数组如下：\r[8] 最大绝对差 |8-8| = 0 \u003c= 4.\r[8,2] 最大绝对差 |8-2| = 6 \u003e 4. [8,2,4] 最大绝对差 |8-2| = 6 \u003e 4.\r[8,2,4,7] 最大绝对差 |8-2| = 6 \u003e 4.\r[2] 最大绝对差 |2-2| = 0 \u003c= 4.","date":"2020-04-16","objectID":"/leetcode/1438/:1:0","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★★）","uri":"/leetcode/1438/"},{"categories":null,"content":"分析 ","date":"2020-04-16","objectID":"/leetcode/1438/:2:0","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★★）","uri":"/leetcode/1438/"},{"categories":null,"content":"#1 显然可以遍历结尾下标 j，找最小的 i 使得 max(nums[i:j+1])-min(nums[i:j+1])\u003c=limit。 注意到随着 j 递增，i 必然不递减，因此是一个滑动窗口问题。 要维护 nums[i:j+1] 的最大值和最小值，考虑用有序集合。 def longestSubarray(self, nums: List[int], limit: int) -\u003e int: from sortedcontainers import SortedList sl = SortedList() res, i = 0, 0 for j, num in enumerate(nums): ","date":"2020-04-16","objectID":"/leetcode/1438/:2:1","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★★）","uri":"/leetcode/1438/"},{"categories":null,"content":"#2 也可以用两个单调队列分别维护窗口的最大/小值。 ","date":"2020-04-16","objectID":"/leetcode/1438/:2:2","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★★）","uri":"/leetcode/1438/"},{"categories":null,"content":"解答 def longestSubarray(self, nums: List[int], limit: int) -\u003e int: que1, que2 = deque(), deque() res, i = 0, 0 for j, num in enumerate(nums): while que1 and que1[-1][0]\u003c=num: que1.pop() while que2 and que2[-1][0]\u003e=num: que2.pop() que1.append((num, j)) que2.append((num, j)) while que1[0][0]-que2[0][0]","date":"2020-04-16","objectID":"/leetcode/1438/:3:0","tags":null,"title":"1438：绝对差不超过限制的最长连续子数组（★★）","uri":"/leetcode/1438/"},{"categories":null,"content":"       大学毕业后没有固定工作，在便利店打工的陆生。在没什么目标、对将来怀着焦躁感生活的陆生面前，某天出现了一位带着乌鸦的神秘少女——晴。就在陆生对她那前所未见的举止感到困惑的同时，他得知自己曾经憧憬的同级生榀子回到了东京。","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":"简介 大学毕业后没有固定工作，在便利店打工的陆生。在没什么目标、对将来怀着焦躁感生活的陆生面前，某天出现了一位带着乌鸦的神秘少女——晴。就在陆生对她那前所未见的举止感到困惑的同时，他得知自己曾经憧憬的同级生榀子回到了东京。 制作人员： 原作：冬目景 导演：藤原佳幸 脚本：田中仁 分镜：堀口和树、小泽一浩、原口浩、田中雄一、伊藤良太 ","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/:1:0","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鱼住陆生 うおずみ りくお、Uozumi Rikuo、リクオ 男 小林親弘 2 野中晴 のなか はる、ハル 女 宮本侑芽 3 森之目榀子 もりのめ しなこ 女 花澤香菜 4 早川浪 男 花江夏樹 5 凑航一 湊 航一、みなと こういち、Minato Koichi 男 小野友樹 6 柚原千佳 柚原知花、柚原 チカ、ゆずはら チカ、Yuzuhara Chika 女 喜多村英梨 7 狭山杏子 狭山 杏子、さやま きょうこ、Sayama Kyōko 女 坂本真綾 8 福田孝则 福田タカノリ、ふくだ たかのり 男 寺島拓篤 ","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/:2:0","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 昨日之歌 2020-04-04 12 bilibili ","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/:3:0","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":"MAD ","date":"2020-04-04","objectID":"/anime/sing_yesterday_for_me/:4:0","tags":null,"title":"昨日之歌","uri":"/anime/sing_yesterday_for_me/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值， 子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和 j 满足 i \u003c j 且 j - i \u003c= k 。 数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。 示例 1： 输入：nums = [10,2,-10,5,20], k = 2\r输出：37\r解释：子序列为 [10, 2, 5, 20] 。\r示例 2： 输入：nums = [-1,-2,-3], k = 1\r输出：-1\r解释：子序列必须是非","date":"2020-04-03","objectID":"/leetcode/1425/:1:0","tags":null,"title":"1425：带限制的子序列和（★★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"分析 ","date":"2020-04-03","objectID":"/leetcode/1425/:2:0","tags":null,"title":"1425：带限制的子序列和（★★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"#1 令 dp[j] 代表以 nums[j] 结尾的满足要求的最大子序列和，那么显然可以递推： dp[j] = nums[j]+max(dp[j-k:j]+[0])\r但是这样时间复杂度为 O(N*K)，会超时。 注意到递推式中本质是在求滑动窗口的最大值，因此类似 0239，可以用有序集合解决。 本题滑动窗口的区别在于，数组并不是一开始就给定的，而是边递推边滑动的。 def constrainedSubsetSum(self, nums: List[int], k: int) -\u003e int: from sortedcontainers import SortedList sl, dp = Sor","date":"2020-04-03","objectID":"/leetcode/1425/:2:1","tags":null,"title":"1425：带限制的子序列和（★★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"#2 也可以采用 0239 的单调队列方法。 ","date":"2020-04-03","objectID":"/leetcode/1425/:2:2","tags":null,"title":"1425：带限制的子序列和（★★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"解答 def constrainedSubsetSum(self, nums: List[int], k: int) -\u003e int: queue, dp = deque(), nums[:] for j, num in enumerate(nums): dp[j] = num + max(0, queue[0][0] if queue else 0) while queue and queue[-1][0]\u003c=dp[j]: queue.pop() queue.append((dp[j], j)) if queue[0][1] == j-k: queue.popleft() return max","date":"2020-04-03","objectID":"/leetcode/1425/:3:0","tags":null,"title":"1425：带限制的子序列和（★★★）","uri":"/leetcode/1425/"},{"categories":null,"content":"题目 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。 请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。 如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ， 那么字符串 words[i] 就是 words[j] 的一个子字符串。 示例 1： 输入：words = [\"mass\",\"as\",\"hero\",\"superhero\"]\r输出：[\"as\",\"hero\"]\r解释：\"as\" 是 \"mass\" 的子字符串，\"hero\" 是 \"superhero\" 的子字符串。\r[\"hero\",\"as\"] 也是有效的答案。\r示例","date":"2020-03-17","objectID":"/leetcode/1408/:1:0","tags":null,"title":"1406：数组中的字符串匹配（★）","uri":"/leetcode/1408/"},{"categories":null,"content":"分析 遍历判断 word 是否是另一个单词的子串即可。 ","date":"2020-03-17","objectID":"/leetcode/1408/:2:0","tags":null,"title":"1406：数组中的字符串匹配（★）","uri":"/leetcode/1408/"},{"categories":null,"content":"解答 def stringMatching(self, words: List[str]) -\u003e List[str]: return [w for w in words if any(w2!=w and w in w2 for w2 in words)] 40 ms ","date":"2020-03-17","objectID":"/leetcode/1408/:3:0","tags":null,"title":"1406：数组中的字符串匹配（★）","uri":"/leetcode/1408/"},{"categories":null,"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-15","objectID":"/hugo-shortcodes/","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-15","objectID":"/hugo-shortcodes/:0:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"1 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel","date":"2020-03-15","objectID":"/hugo-shortcodes/:1:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"2 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightgallery.js 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. t","date":"2020-03-15","objectID":"/hugo-shortcodes/:2:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"3 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是","date":"2020-03-15","objectID":"/hugo-shortcodes/:3:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:1","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:2","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3,","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:3","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:4","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:5","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:6","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"4.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:4:7","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"5 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": ","date":"2020-03-15","objectID":"/hugo-shortcodes/:5:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"6 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是","date":"2020-03-15","objectID":"/hugo-shortcodes/:6:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"https://hugoloveit.com/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"http://p1.music.126.net/ehaqke","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:1","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://y.qq.com/n/yqq/album/001Di11N41SEdY.html\" \u003e}} 或者 {{\u003c music \"https://y.qq.com/n/yqq/album/001Di11N41SEdY.html\" \u003e}} 呈","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:2","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"neteas","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:3","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"7.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #aaaaaa. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方","date":"2020-03-15","objectID":"/hugo-shortcodes/:7:4","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"8 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV15t411E7hf \u003e}} 或者 {{\u003c bilibili id=BV15t411E7hf \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.","date":"2020-03-15","objectID":"/hugo-shortcodes/:8:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"9 typeit typeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-15","objectID":"/hugo-shortcodes/:9:0","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"9.1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... ","date":"2020-03-15","objectID":"/hugo-shortcodes/:9:1","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"9.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:9:2","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"9.3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-15","objectID":"/hugo-shortcodes/:9:3","tags":["博客"],"title":"博客 - Shortcodes","uri":"/hugo-shortcodes/"},{"categories":null,"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-10","objectID":"/hugo-content/","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-10","objectID":"/hugo-content/:0:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录","date":"2020-03-10","objectID":"/hugo-content/:1:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: --- title: \"我的第一篇文章\" subtitle: \"\" date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true author: \"\" authorLink: \"\" description: \"\" license: \"\"","date":"2020-03-10","objectID":"/hugo-content/:2:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览 ","date":"2020-03-10","objectID":"/hugo-content/:3:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-10","objectID":"/hugo-content/:3:1","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-10","objectID":"/hugo-content/:3:2","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-10","objectID":"/hugo-content/:3:3","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2020-03-10","objectID":"/hugo-content/:3:4","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-10","objectID":"/hugo-content/:3:5","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"4 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-10","objectID":"/hugo-content/:4:0","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"数学公式 LoveIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈","date":"2020-03-10","objectID":"/hugo-content/:4:1","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-10","objectID":"/hugo-content/:4:2","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-10","objectID":"/hugo-content/:4:3","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-10","objectID":"/hugo-content/:4:4","tags":["博客"],"title":"博客 - 内容","uri":"/hugo-content/"},{"categories":null,"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/hugo-basics/:0:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06","objectID":"/hugo-basics/:1:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/hugo-basics/:2:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/hugo-basics/:2:1","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.g","date":"2020-03-06","objectID":"/hugo-basics/:2:2","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 vers","date":"2020-03-06","objectID":"/hugo-basics/:2:3","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06","objectID":"/hugo-basics/:2:4","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/hugo-basics/:2:5","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"/hugo-basics/:2:6","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"3 配置 ","date":"2020-03-06","objectID":"/hugo-basics/:3:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，","date":"2020-03-06","objectID":"/hugo-basics/:3:1","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfi","date":"2020-03-06","objectID":"/hugo-basics/:3:2","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"3.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026di","date":"2020-03-06","objectID":"/hugo-basics/:3:3","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换 ","date":"2020-03-06","objectID":"/hugo-basics/:4:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi ","date":"2020-03-06","objectID":"/hugo-basics/:4:1","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"4.2 基本配置 学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" ","date":"2020-03-06","objectID":"/hugo-basics/:4:2","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/hugo-basics/:4:3","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"/hugo-basics/:5:0","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/hugo-basics/:5:1","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"e","date":"2020-03-06","objectID":"/hugo-basics/:5:2","tags":["博客"],"title":"博客 - 基本概念","uri":"/hugo-basics/"},{"categories":null,"content":"题目 「快乐前缀」 是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。 给你一个字符串 s，请你返回它的 最长快乐前缀。如果不存在满足题意的前缀，则返回一个空字符串 \"\" 。 示例 1： 输入：s = \"level\"\r输出：\"l\"\r解释：不包括 s 自己，一共有 4 个前缀（\"l\", \"le\", \"lev\", \"leve\"）和 4 个后缀（\"l\", \"el\", \"vel\", \"evel\"）。\r最长的既是前缀也是后缀的字符串是 \"l\" 。\r示例 2： 输入：s = \"ababab\"\r输出：\"abab\"\r解释：\"abab\" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字","date":"2020-03-03","objectID":"/leetcode/1392/:1:0","tags":null,"title":"1392：最长快乐前缀（★★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"分析 ","date":"2020-03-03","objectID":"/leetcode/1392/:2:0","tags":null,"title":"1392：最长快乐前缀（★★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"#1 暴力法就是直接遍历 L 判断 s[:L] 和 s[-L:] 是否相等。 要优化判断子串相等的时间，容易想到用滚动哈希。 元素种类最多 26，窗口种类最多 10^5 级别，因此考虑 base 取 31，mod 取 10^11+3 def longestPrefix(self, s: str) -\u003e str: res, n = -1, len(s) base, mod = 31, 10**11+3 w1, w2, bL = 0, 0, 1 for i in range(n-1): w1 = (w1*base+ord(s[i])-ord('a')+1)%mod w2 = (w2+(ord(s[","date":"2020-03-03","objectID":"/leetcode/1392/:2:1","tags":null,"title":"1392：最长快乐前缀（★★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"#2 求最长的既是前缀又是后缀的子串，容易想到 KMP，KMP 中的 nxt[i] 即是 s[:i] 的快乐前缀长度。 ","date":"2020-03-03","objectID":"/leetcode/1392/:2:2","tags":null,"title":"1392：最长快乐前缀（★★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"解答 def longestPrefix(self, s: str) -\u003e str: nxt, j, n = [-1], -1, len(s) for i in range(n): while j \u003e= 0 and s[i] != s[j]: j = nxt[j] j += 1 nxt.append(j) return s[:nxt[-1]] 228 ms ","date":"2020-03-03","objectID":"/leetcode/1392/:3:0","tags":null,"title":"1392：最长快乐前缀（★★★）","uri":"/leetcode/1392/"},{"categories":null,"content":"题目 给你一个 m x n 的网格图 grid 。 grid 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况： 1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1] 2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1] 3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j] 4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j] 注意网格图中可能会有 无效数字 ，因为它们可能指向 gri","date":"2020-02-06","objectID":"/leetcode/1368/:1:0","tags":null,"title":"1368：使网格图至少有一条有效路径的最小代价（★★）","uri":"/leetcode/1368/"},{"categories":null,"content":"分析 将每个格子看作顶点，相邻格子的路径看作边，如果边的方向顺着数字，看作权重 0，否则权重 1。 那么就是典型的最短路问题，用 dijkstra 即可。 ","date":"2020-02-06","objectID":"/leetcode/1368/:2:0","tags":null,"title":"1368：使网格图至少有一条有效路径的最小代价（★★）","uri":"/leetcode/1368/"},{"categories":null,"content":"解答 def minCost(self, grid: List[List[int]]) -\u003e int: m, n = len(grid), len(grid[0]) d, pq = {}, [(0, 0, 0)] while pq: w, i, j = heappop(pq) if i==m-1 and j==n-1: return w if (i, j) in d: continue d[(i, j)] = w for x, y, k in [(i, j+1, 1), (i, j-1, 2), (i+1, j, 3), (i-1, j, 4)]: if 0\u003c=x\u003cm and 0\u003c=y\u003cn a","date":"2020-02-06","objectID":"/leetcode/1368/:3:0","tags":null,"title":"1368：使网格图至少有一条有效路径的最小代价（★★）","uri":"/leetcode/1368/"},{"categories":null,"content":"题目 有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。 返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。 如果有多个这样的城市，则返回编号最大的城市。 注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。 示例 1： 输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,","date":"2020-01-26","objectID":"/leetcode/1334/:1:0","tags":null,"title":"1334：阈值距离内邻居最少的城市（★★）","uri":"/leetcode/1334/"},{"categories":null,"content":"分析 典型的最短路问题，可以直接用 floyd 算法。 ","date":"2020-01-26","objectID":"/leetcode/1334/:2:0","tags":null,"title":"1334：阈值距离内邻居最少的城市（★★）","uri":"/leetcode/1334/"},{"categories":null,"content":"解答 def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -\u003e int: dis = [[float('inf')]*n for _ in range(n)] for i in range(n): dis[i][i] = 0 for u, v, w in edges: dis[u][v] = dis[v][u] = w for x, u, v in product(range(n), range(n), range(n)): dis[u][v] = min(dis[u][v], dis[u]","date":"2020-01-26","objectID":"/leetcode/1334/:3:0","tags":null,"title":"1334：阈值距离内邻居最少的城市（★★）","uri":"/leetcode/1334/"},{"categories":null,"content":"题目 给你一个字符串 text ，请你返回满足下述条件的 不同 非空子字符串的数目： 可以写成某个字符串与其自身相连接的形式（即，可以写为 a + a，其中 a 是某个字符串）。 例如，abcabc 就是 abc 和它自身连接形成的。 示例 1： 输入：text = \"abcabcabc\"\r输出：3\r解释：3 个子字符串分别为 \"abcabc\"，\"bcabca\" 和 \"cabcab\" 。\r示例 2： 输入：text = \"leetcodeleetcode\"\r输出：2\r解释：2 个子字符串为 \"ee\" 和 \"leetcodeleetcode\" 。\r提示： 1 \u003c= text.length \u003c= ","date":"2020-01-08","objectID":"/leetcode/1316/:1:0","tags":null,"title":"1316：不同的循环子字符串（★★★）","uri":"/leetcode/1316/"},{"categories":null,"content":"分析 暴力法就是直接遍历 i 和 L 判断 text[i:i+L] 和 text[i+L:i+2*L] 是否相等。 要优化判断子串相等的时间，容易想到用滚动哈希。 可以先求出 text 所有前缀的哈希值，然后类似前缀和，可以快速得到任一子串的哈希值。 元素种类最多 26，窗口种类最多 2*10^6 级别，因此考虑 base 取 31，mod 取 10^13+37 ","date":"2020-01-08","objectID":"/leetcode/1316/:2:0","tags":null,"title":"1316：不同的循环子字符串（★★★）","uri":"/leetcode/1316/"},{"categories":null,"content":"解答 def distinctEchoSubstrings(self, text: str) -\u003e int: base, mod = 31, 10**13+37 pre = [0] for char in text: w = pre[-1]*base+ord(char)-ord('a')+1 pre.append(w % mod) res, n = set(), len(text) for L in range(1, n//2+1): bL = pow(base, L, mod) for i in range(n-2*L+1): w1 = (pre[i+L]-pre[i]*bL)%mod w2","date":"2020-01-08","objectID":"/leetcode/1316/:3:0","tags":null,"title":"1316：不同的循环子字符串（★★★）","uri":"/leetcode/1316/"},{"categories":null,"content":"利用检测杀意的系统“罔象女”搜查犯罪事件的组织，通称“仓”。\n然后，神探·酒井户身为“罔象女”的驾驶员进入犯人的深层心理“杀意世界（井）”，对事件进行推理。\n他不断追寻着频繁发生、谜团重重的凶恶事件，以及在其中若隐若现的连续杀人鬼制造者“约翰·沃克”的影子。","date":"2020-01-05","objectID":"/anime/id_invaded/","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"简介 利用检测杀意的系统“罔象女”搜查犯罪事件的组织，通称“仓”。 然后，神探·酒井户身为“罔象女”的驾驶员进入犯人的深层心理“杀意世界（井）”，对事件进行推理。 他不断追寻着频繁发生、谜团重重的凶恶事件，以及在其中若隐若现的连续杀人鬼制造者“约翰·沃克”的影子。 制作人员： 导演：青木英 脚本：舞城王太郎 分镜：久保田雄大、碇谷敦、又贺大介、下平佑一、青柳隆平 ","date":"2020-01-05","objectID":"/anime/id_invaded/:1:0","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 名侦探酒井户 Brilliant detective Sakaido、鳴瓢秋人、鸣瓢秋人、なりひさご あきひと、Narihisago Akihito 男 津田健次郎 2 佳爱瑠 佳爱琉、Asukai Kiki、あすかい きき、飞鸟井木记、Kaeru、飛鳥井木記 女 宮本侑芽 3 冬川浩二 花火師（はなびし）、ふゆかわ こうじ、Fuyukawa Kouji 男 平川大輔 4 百贵船太郎 ももき ふねたろう、Momoki Funetarou 男 細谷佳正 5 本堂町小春 ほんどうまち こはる、Hondoumachi Koharu、Hijiriido Miyo、名","date":"2020-01-05","objectID":"/anime/id_invaded/:2:0","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 ID:INVADED 2020-01-05 13 bilibili ","date":"2020-01-05","objectID":"/anime/id_invaded/:3:0","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"MAD ","date":"2020-01-05","objectID":"/anime/id_invaded/:4:0","tags":null,"title":"ID:INVADED","uri":"/anime/id_invaded/"},{"categories":null,"content":"　　高中1年级学生浅草绿，是强调“设定即生命”的动画迷。在素描本上描绘积累各种各样的想法，却因不能一个人行动做事而无法迈出走向动画制作的一步。对于浅草这种才能，拥有制片人气质的金森沙耶香很快注意到了。同时，得知同学兼新星读者模特的水崎燕，其实希望将来成为动画人，3人为了展现脑内“最强的世界”而设立了映像研……","date":"2020-01-05","objectID":"/anime/keep_your_hands_off_eizouken/","tags":null,"title":"别对映像研出手！","uri":"/anime/keep_your_hands_off_eizouken/"},{"categories":null,"content":"简介 高中1年级学生浅草绿，是强调“设定即生命”的动画迷。在素描本上描绘积累各种各样的想法，却因不能一个人行动做事而无法迈出走向动画制作的一步。对于浅草这种才能，拥有制片人气质的金森沙耶香很快注意到了。同时，得知同学兼新星读者模特的水崎燕，其实希望将来成为动画人，3人为了展现脑内“最强的世界”而设立了映像研…… 制作人员： 原作：大童澄瞳 导演：汤浅政明 脚本：木户雄一郎 分镜：伊东伸高、山代风我、佐佐木勅嘉、五十岚祐贵、长屋诚志郎、木下绘李 ","date":"2020-01-05","objectID":"/anime/keep_your_hands_off_eizouken/:1:0","tags":null,"title":"别对映像研出手！","uri":"/anime/keep_your_hands_off_eizouken/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 浅草绿 Asakusa Midori 女 伊藤沙莉 2 水崎燕 Mizusaki Tsubame 女 松岡美里 3 金森沙耶香 Kanamori Sayaka 女 田村睦心 4 百目鬼 どうめき 女 花守ゆみり ","date":"2020-01-05","objectID":"/anime/keep_your_hands_off_eizouken/:2:0","tags":null,"title":"别对映像研出手！","uri":"/anime/keep_your_hands_off_eizouken/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 别对映像研出手！ 2020-01-05 12 acfun ","date":"2020-01-05","objectID":"/anime/keep_your_hands_off_eizouken/:3:0","tags":null,"title":"别对映像研出手！","uri":"/anime/keep_your_hands_off_eizouken/"},{"categories":null,"content":"2019 年投稿的 MAD 盘点","date":"2019-12-31","objectID":"/anime/2019_mad/","tags":null,"title":"2019 MAD","uri":"/anime/2019_mad/"},{"categories":null,"content":"2019 年投稿的 MAD 盘点 ","date":"2019-12-31","objectID":"/anime/2019_mad/:0:0","tags":null,"title":"2019 MAD","uri":"/anime/2019_mad/"},{"categories":null,"content":"单素材 ","date":"2019-12-31","objectID":"/anime/2019_mad/:1:0","tags":null,"title":"2019 MAD","uri":"/anime/2019_mad/"},{"categories":null,"content":"多素材 ","date":"2019-12-31","objectID":"/anime/2019_mad/:2:0","tags":null,"title":"2019 MAD","uri":"/anime/2019_mad/"},{"categories":null,"content":"同人 ","date":"2019-12-31","objectID":"/anime/2019_mad/:3:0","tags":null,"title":"2019 MAD","uri":"/anime/2019_mad/"},{"categories":null,"content":"* 总结 ","date":"2019-12-31","objectID":"/anime/2019_mad/:4:0","tags":null,"title":"2019 MAD","uri":"/anime/2019_mad/"},{"categories":null,"content":"题目 给你一个正整数数组 nums，你需要从中任选一些子集，然后将子集中每一个数乘以一个 任意整数，并求出他们的和。 假如该和结果为 1，那么原数组就是一个「好数组」，则返回 True；否则请返回 False。 示例 1： 输入：nums = [12,5,7,23]\r输出：true\r解释：挑选数字 5 和 7。\r5*3 + 7*(-2) = 1\r示例 2： 输入：nums = [29,6,10]\r输出：true\r解释：挑选数字 29, 6 和 10。\r29*1 + 6*(-3) + 10*(-1) = 1\r示例 3： 输入：nums = [3,6]\r输出：false\r提示： 1 \u003c= nums","date":"2019-11-03","objectID":"/leetcode/1250/:1:0","tags":null,"title":"1250：检查「好数组」（★★）","uri":"/leetcode/1250/"},{"categories":null,"content":"分析 根据裴蜀定理，只要存在子集的最大公约数为 1，即可满足条件。 而存在子集的最大公约数为 1 等价于 nums 的最大公约数为 1，判断即可。 ","date":"2019-11-03","objectID":"/leetcode/1250/:2:0","tags":null,"title":"1250：检查「好数组」（★★）","uri":"/leetcode/1250/"},{"categories":null,"content":"解答 def isGoodArray(self, nums: List[int]) -\u003e bool: return reduce(gcd, nums)==1 56 ms ","date":"2019-11-03","objectID":"/leetcode/1250/:3:0","tags":null,"title":"1250：检查「好数组」（★★）","uri":"/leetcode/1250/"},{"categories":null,"content":"题目 5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子） 所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面， 而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。 只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。 假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。 设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下， 每个哲学家都可以在吃","date":"2019-10-14","objectID":"/leetcode/1226/:1:0","tags":null,"title":"1226：哲学家进餐（★★★）","uri":"/leetcode/1226/"},{"categories":null,"content":"分析 典型的并发问题，可以用互斥锁+信号量解决。 为了防止死锁，最多允许 4 个哲学家同时拿叉子。考虑到效率，可以设置最多 3 个哲学家同时拿叉子。 ","date":"2019-10-14","objectID":"/leetcode/1226/:2:0","tags":null,"title":"1226：哲学家进餐（★★★）","uri":"/leetcode/1226/"},{"categories":null,"content":"解答 from threading import Lock, Semaphore class DiningPhilosophers: def __init__(self,): self.limit = Semaphore(3) self.forks = [Lock() for _ in range(5)] # call the functions directly to execute, for example, eat() def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightF","date":"2019-10-14","objectID":"/leetcode/1226/:3:0","tags":null,"title":"1226：哲学家进餐（★★★）","uri":"/leetcode/1226/"},{"categories":null,"content":"肉食兽与草食兽共存的世界。\n食肉被视为重罪，然而在全宿制的名门高校·切里顿学园却发生了学生惨遭吞噬的“食杀事件”。\n\n在蔓延不安的校内，演剧部的怪人·灰狼雷格西过着与“庞大的身躯”与“锐利的尖牙”不符的平静生活。然而与小巧的兔子女学生·春的相遇，使雷格西的内心产生动摇。\n\n“我追求她的心情，是恋爱？还是食欲？”\n\n他真正遇到的事物，那是他自身的本能——","date":"2019-10-09","objectID":"/anime/beastars/","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":"简介 肉食兽与草食兽共存的世界。 食肉被视为重罪，然而在全宿制的名门高校·切里顿学园却发生了学生惨遭吞噬的“食杀事件”。 在蔓延不安的校内，演剧部的怪人·灰狼雷格西过着与“庞大的身躯”与“锐利的尖牙”不符的平静生活。然而与小巧的兔子女学生·春的相遇，使雷格西的内心产生动摇。 “我追求她的心情，是恋爱？还是食欲？” 他真正遇到的事物，那是他自身的本能—— 制作人员： 原作：板垣巴留 导演：松见真一 脚本：樋口七海 分镜：寸田笃志、武藤健司、佐藤真二、下司泰弘、石井俊匡 ","date":"2019-10-09","objectID":"/anime/beastars/:1:0","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雷格西 ♂ 小林親弘 2 春 哈鲁 ♀ 千本木彩花 3 路易 ♂ 小野友樹 4 茱诺 ♀ 種﨑敦美 5 杰克 ♂ 榎木淳弥 6 米古诺 ♂ 内田雄馬 7 克洛 ♂ 大塚剛央 8 德拉姆 ♂ 小林直人 ","date":"2019-10-09","objectID":"/anime/beastars/:2:0","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 动物狂想曲 2019-10-09 12 bilibili 2 BEASTARS 2nd Season 2021-01-06 12 bilibili ","date":"2019-10-09","objectID":"/anime/beastars/:3:0","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":"MAD ","date":"2019-10-09","objectID":"/anime/beastars/:4:0","tags":null,"title":"动物狂想曲","uri":"/anime/beastars/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2019-09-24","objectID":"/leetcode/1206/:0:0","tags":null,"title":"1206：设计跳表（★★★）","uri":"/leetcode/1206/"},{"categories":null,"content":"题目 不使用任何库函数，设计一个跳表。 跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当， 并且跳表的代码长度相较下更短，其设计思想与链表相似。 例如，一个跳表包含 [30, 40, 50, 60, 70, 90]，然后增加 80、45 到跳表中，以下图的方式操作： 跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。 跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。 在本题中，你的设计应该要包含这些函数： bool search(int tar","date":"2019-09-24","objectID":"/leetcode/1206/:1:0","tags":null,"title":"1206：设计跳表（★★★）","uri":"/leetcode/1206/"},{"categories":null,"content":"分析 跳表教程 为了方便，可以将叠在一起的看成是一个节点。 ","date":"2019-09-24","objectID":"/leetcode/1206/:2:0","tags":null,"title":"1206：设计跳表（★★★）","uri":"/leetcode/1206/"},{"categories":null,"content":"解答 class Node: def __init__(self, val, nxt=[]): self.val = val self.nxt = nxt class Skiplist: def __init__(self): self.tail = Node(float('inf')) self.head = Node(-float('inf'), [self.tail]) self.H = 0 def search(self, target: int) -\u003e bool: cur = self.head for h in range(self.H, -1, -1): while cur.nx","date":"2019-09-24","objectID":"/leetcode/1206/:3:0","tags":null,"title":"1206：设计跳表（★★★）","uri":"/leetcode/1206/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2019-09-21","objectID":"/leetcode/1203/:0:0","tags":null,"title":"1203：项目管理（★★★）","uri":"/leetcode/1203/"},{"categories":null,"content":"题目 有 n 个项目，每个项目或者不属于任何小组，或者属于 m 个小组之一。group[i] 表示第 i 个项目所属的小组， 如果第 i 个项目不属于任何小组，则 group[i] 等于 -1。项目和小组都是从零开始编号的。 可能存在小组不负责任何项目，即没有任何项目属于这个小组。 请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表： 同一小组的项目，排序后在列表中彼此相邻。 项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行 第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。 如果存在多个解决方案，只需","date":"2019-09-21","objectID":"/leetcode/1203/:1:0","tags":null,"title":"1203：项目管理（★★★）","uri":"/leetcode/1203/"},{"categories":null,"content":"分析 将依赖关系看作有向边，显然是一个拓扑排序问题。 同一小组的必须相邻，那么可以将小组也看作顶点，小组间要满足拓扑顺序。 小组排好后，每个小组内部也要满足拓扑顺序。因此要用双层拓扑排序。 具体来说： 预处理： 将不属于任何小组的项目分给一个单独的虚拟小组，方便统一解决 建图： 对每个小组建立虚拟顶点，将项目顶点分给对应的小组 将边分为组间边和组内边，并且组内边分给对应的小组 双层拓扑： 根据小组虚拟顶点和组间边对小组进行拓扑排序 按拓扑顺序遍历小组，根据小组内的项目顶点和边进行拓扑排序 ","date":"2019-09-21","objectID":"/leetcode/1203/:2:0","tags":null,"title":"1203：项目管理（★★★）","uri":"/leetcode/1203/"},{"categories":null,"content":"解答 def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -\u003e List[int]: def topo(V, E): nxt, indeg = defaultdict(list), defaultdict(int) for u, v in E: nxt[u].append(v) indeg[v] += 1 res, queue = [], deque(u for u in V if indeg[u]==0) while queue: u = queue.popleft() res","date":"2019-09-21","objectID":"/leetcode/1203/:3:0","tags":null,"title":"1203：项目管理（★★★）","uri":"/leetcode/1203/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2019-09-19","objectID":"/leetcode/1201/:0:0","tags":null,"title":"1201：丑数 III（★★）","uri":"/leetcode/1201/"},{"categories":null,"content":"题目 给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。 丑数是可以被 a 或 b 或 c 整除的 正整数 。 示例 1： 输入：n = 3, a = 2, b = 3, c = 5\r输出：4\r解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。\r示例 2： 输入：n = 4, a = 2, b = 3, c = 4\r输出：6\r解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。\r示例 3： 输入：n = 5, a = 2, b = 11, c = 13\r输出：10\r解释：丑数序列为","date":"2019-09-19","objectID":"/leetcode/1201/:1:0","tags":null,"title":"1201：丑数 III（★★）","uri":"/leetcode/1201/"},{"categories":null,"content":"分析 观察数据范围容易想到用二分查找。 令 check(x) 代表小于等于 x 的丑数个数是否大于等于 n，那么二分查找第一个满足 check(x) 的 x 即可。 具体求小于等于 x 的丑数个数，则可以用到集合的知识。 ","date":"2019-09-19","objectID":"/leetcode/1201/:2:0","tags":null,"title":"1201：丑数 III（★★）","uri":"/leetcode/1201/"},{"categories":null,"content":"解答 def nthUglyNumber(self, n: int, a: int, b: int, c: int) -\u003e int: def check(x): return x//a+x//b+x//c-x//lcm(a,b)-x//lcm(a,c)-x//lcm(b,c)+x//reduce(lcm, [a,b,c])\u003e=n self.__class__.__getitem__ = lambda self, x: check(x) return bisect_left(self, True, 0, a*n) 40 ms ","date":"2019-09-19","objectID":"/leetcode/1201/:3:0","tags":null,"title":"1201：丑数 III（★★）","uri":"/leetcode/1201/"},{"categories":null,"content":"题目 编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是： 如果这个数字可以被 3 整除，输出 “fizz”。 如果这个数字可以被 5 整除，输出 “buzz”。 如果这个数字可以同时被 3 和 5 整除，输出 “fizzbuzz”。 例如，当 n = 15，输出： 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz。 假设有这么一个类： class FizzBuzz {\rpublic FizzBuzz(int n) { ... } // constructor\rpublic void f","date":"2019-09-13","objectID":"/leetcode/1195/:1:0","tags":null,"title":"1195. 交替打印字符串（★★）","uri":"/leetcode/1195/"},{"categories":null,"content":"分析 典型的并发问题，可以用互斥锁解决。 ","date":"2019-09-13","objectID":"/leetcode/1195/:2:0","tags":null,"title":"1195. 交替打印字符串（★★）","uri":"/leetcode/1195/"},{"categories":null,"content":"解答 from threading import Lock class FizzBuzz: def __init__(self, n: int): self.n = n self.lock_f = Lock() self.lock_b = Lock() self.lock_fb = Lock() self.lock_n = Lock() self.lock_f.acquire() self.lock_b.acquire() self.lock_fb.acquire() # printFizz() outputs \"fizz\" def fizz(self, printFizz: 'Callabl","date":"2019-09-13","objectID":"/leetcode/1195/:3:0","tags":null,"title":"1195. 交替打印字符串（★★）","uri":"/leetcode/1195/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2019-09-10","objectID":"/leetcode/1192/:0:0","tags":null,"title":"1192. 查找集群内的「关键连接」（★★★）","uri":"/leetcode/1192/"},{"categories":null,"content":"题目 力扣数据中心有 n 台服务器，分别按从 0 到 n-1 的方式进行了编号。它们之间以「服务器到服务器」 点对点的形式相互连接组成了一个内部集群，其中连接 connections 是无向的。 从形式上讲，connections[i] = [a, b] 表示服务器 a 和 b 之间形成连接。 任何服务器都可以直接或者间接地通过网络到达任何其他服务器。 「关键连接」 是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。 请你以任意顺序返回该集群内的所有 「关键连接」。 示例 1： 输入：n = 4, connections = [[0,1],[1,2],[","date":"2019-09-10","objectID":"/leetcode/1192/:1:0","tags":null,"title":"1192. 查找集群内的「关键连接」（★★★）","uri":"/leetcode/1192/"},{"categories":null,"content":"分析 tarjan 算法模版题，求无向图的桥。 ","date":"2019-09-10","objectID":"/leetcode/1192/:2:0","tags":null,"title":"1192. 查找集群内的「关键连接」（★★★）","uri":"/leetcode/1192/"},{"categories":null,"content":"解答 def criticalConnections(self, n: int, connections: List[List[int]]) -\u003e List[List[int]]: def tarjan(p, fa): dfn[p] = low[p] = self.t = self.t+1 for q in nxt[p]: if q not in dfn: tarjan(q, p) low[p] = min(low[p], low[q]) if low[q] \u003e dfn[p]: bridge.append([p, q]) elif q != fa: low[p] = min(low[p], d","date":"2019-09-10","objectID":"/leetcode/1192/:3:0","tags":null,"title":"1192. 查找集群内的「关键连接」（★★★）","uri":"/leetcode/1192/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2019-08-27","objectID":"/leetcode/1178/:0:0","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"题目 外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。 例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。 返回一个答案数组 answer，数组中的每个元素 ans","date":"2019-08-27","objectID":"/leetcode/1178/:1:0","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"分析 ","date":"2019-08-27","objectID":"/leetcode/1178/:2:0","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"#1 先试试暴力解法，对每个 puzzle，遍历每个 word 判断是否满足条件即可。 def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -\u003e List[int]: res, words = [], [set(word) for word in words] for puzzle in puzzles: puz = set(puzzle) cnt = sum(puzzle[0] in word and puz \u003e= word for word in words) res.append(cnt) return ","date":"2019-08-27","objectID":"/leetcode/1178/:2:1","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"#2 puzzles 和 words 可能的个数太多了，全部遍历很耗时，考虑限制搜索范围。 可以直接把 key=''.join(sorted(set(word))) 作为表示 word 的唯一 key，保存在哈希表。\r那么 word 可以作为 puzzle 的谜底，等价于 word 的 key 是 puzzle 的某个含有 puzzle[0] 的子序列的 key。\r因此对于某个 puzzle，遍历含有 puzzle[0] 的子序列 sub，累计 key 相同的 word 个数即可。\r生成字符串的所有子序列类似于 0078 ，可以递推得到。 ","date":"2019-08-27","objectID":"/leetcode/1178/:2:2","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":"解答 def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -\u003e List[int]: res, d = [], defaultdict(int) gen_key = lambda x: ''.join(sorted(x)) for word in words: d[gen_key(set(word))] += 1 for puzzle in puzzles: subs = [puzzle[0]] for char in puzzle[1:]: subs += [sub+char for sub in subs]","date":"2019-08-27","objectID":"/leetcode/1178/:3:0","tags":null,"title":"1178：猜字谜（★★★）","uri":"/leetcode/1178/"},{"categories":null,"content":" 第 151 场周赛第 4 题 ","date":"2019-08-26","objectID":"/leetcode/1172/:0:0","tags":null,"title":"1172：餐盘栈（★★★）","uri":"/leetcode/1172/"},{"categories":null,"content":"题目 我们把无限数量 ∞ 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量 capacity 都相同。 实现一个叫「餐盘」的类 DinnerPlates： DinnerPlates(int capacity) - 给出栈的最大容量 capacity。 void push(int val) - 将给出的正整数 val 推入 从左往右第一个 没有满的栈。 int pop() - 返回 从右往左第一个 非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回 -1。 int popAtStack(int index) - 返回编号 index 的栈顶部的值，并将其从栈中删除；","date":"2019-08-26","objectID":"/leetcode/1172/:1:0","tags":null,"title":"1172：餐盘栈（★★★）","uri":"/leetcode/1172/"},{"categories":null,"content":"分析 考虑用数组 A 动态维护所有栈的信息（保证末尾是非空栈），那么 pop 时： 若 len(A[-1]) \u003e 1，直接 pop A[-1] 即可\r若 len(A[-1]) == 1，pop A[-1] 并去掉末尾所有空栈\r每个非末尾的空栈至少对应了一个 push 和 popAtStack 操作\r因此平摊下来 pop 时间复杂度 O(1)\r然后为了方便 push，考虑用堆 pq 维护没有满的栈下标集合，那么： 若 pq 空或 pq[0]\u003e=len(A)\r说明 A 中的栈的都满了，末尾添加一个栈并 push\r否则\r得到没有满的最小下标 i=pq[0]，往 A[i] push\r注意在所有操作中都","date":"2019-08-26","objectID":"/leetcode/1172/:2:0","tags":null,"title":"1172：餐盘栈（★★★）","uri":"/leetcode/1172/"},{"categories":null,"content":"解答 class DinnerPlates: def __init__(self, capacity: int): self.size = capacity self.pq = [] self.A = [] def push(self, val: int) -\u003e None: if not self.pq or self.pq[0] \u003e= len(self.A): self.A.append([val]) self.pq = [len(self.A)-1] if self.size \u003e 1 else [] else: i = self.pq[0] self.A[i].append(val) if","date":"2019-08-26","objectID":"/leetcode/1172/:3:0","tags":null,"title":"1172：餐盘栈（★★★）","uri":"/leetcode/1172/"},{"categories":null,"content":" 第 151 场周赛第 3 题 ","date":"2019-08-26","objectID":"/leetcode/1171/:0:0","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★★）","uri":"/leetcode/1171/"},{"categories":null,"content":"题目 给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列， 直到不存在这样的序列为止。 删除完毕后，请你返回最终结果链表的头节点。 你可以返回任何满足题目要求的答案。 （注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。） 提示： 给你的链表中可能有 1 到 1000 个节点。 对于链表中的每个节点，节点的值：-1000 \u003c= node.val \u003c= 1000. 示例 1： 输入：head = [1,2,-3,3,1]\r输出：[3,1]\r提示：答案 [1,2,1] 也是正确的。\r示例 2： 输入：head = [1,2,3","date":"2019-08-26","objectID":"/leetcode/1171/:1:0","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★★）","uri":"/leetcode/1171/"},{"categories":null,"content":"分析 ","date":"2019-08-26","objectID":"/leetcode/1171/:2:0","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★★）","uri":"/leetcode/1171/"},{"categories":null,"content":"#1 区间和为 0，容易想到转为找相等的前缀和。 遍历时，用哈希表 d 维护 {前缀和: 对应的节点}，若节点 p 处的前缀和 s 出现过，就将节点 d[s] 到节点 p 的部分删去即可。 注意删去节点时，要同步将哈希表中对应的前缀和也删去。 def removeZeroSumSublists(self, head: ListNode) -\u003e ListNode: dummy = p = ListNode(next=head) d, s = {}, 0 while p: s += p.val if s in d: q, _s = d[s].next, s while q != p: _s += ","date":"2019-08-26","objectID":"/leetcode/1171/:2:1","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★★）","uri":"/leetcode/1171/"},{"categories":null,"content":"#2 有个巧妙的想法是先一趟得到哈希表 d，保存 {前缀和: 对应的最后一个节点}。 然后再遍历节点 p，得到对应前缀和 s ，将节点 p 到节点 d[s] 的部分删去即可。 ","date":"2019-08-26","objectID":"/leetcode/1171/:2:2","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★★）","uri":"/leetcode/1171/"},{"categories":null,"content":"解答 def removeZeroSumSublists(self, head: ListNode) -\u003e ListNode: dummy = p = ListNode(next=head) d, s = {}, 0 while p: s += p.val d[s] = p p = p.next p, s = dummy, 0 while p: s += p.val p.next = d[s].next p = p.next return dummy.next 40 ms ","date":"2019-08-26","objectID":"/leetcode/1171/:3:0","tags":null,"title":"1171：从链表中删去总和值为零的连续节点（★★）","uri":"/leetcode/1171/"},{"categories":null,"content":" 第 151 场周赛第 2 题 ","date":"2019-08-25","objectID":"/leetcode/1170/:0:0","tags":null,"title":"1170：比较字符串最小字母出现频次（★）","uri":"/leetcode/1170/"},{"categories":null,"content":"题目 定义一个函数 f(s)，统计 s 中（按字典序比较）最小字母的出现频次 ，其中 s 是一个非空字符串。 例如，若 s = “dcce”，那么 f(s) = 2，因为字典序最小字母是 “c”，它出现了 2 次。 现在，给你两个字符串数组待查表 queries 和词汇表 words 。对于每次查询 queries[i] ， 需统计 words 中满足 f(queries[i]) \u003c f(W) 的 词的数目 ，W 表示词汇表 words 中的每个词。 请你返回一个整数数组 answer 作为答案，其中每个 answer[i] 是第 i 次查询的结果。 提示： 1 \u003c= queries.leng","date":"2019-08-25","objectID":"/leetcode/1170/:1:0","tags":null,"title":"1170：比较字符串最小字母出现频次（★）","uri":"/leetcode/1170/"},{"categories":null,"content":"分析 用数组 A 记录词汇表中每个 f 值对应的词个数，那么每次查询即是求 sum(A[f(queries[i])+1:])。 容易想到用前缀和。不过本题 f 值最多为 10，直接求和即可。 ","date":"2019-08-25","objectID":"/leetcode/1170/:2:0","tags":null,"title":"1170：比较字符串最小字母出现频次（★）","uri":"/leetcode/1170/"},{"categories":null,"content":"解答 def numSmallerByFrequency(self, queries: List[str], words: List[str]) -\u003e List[int]: A = [0] * 11 for w in words: cnt = w.count(min(w)) A[cnt] += 1 res = [] for q in queries: cnt = q.count(min(q)) res.append(sum(A[cnt+1:])) return res 36 ms ","date":"2019-08-25","objectID":"/leetcode/1170/:3:0","tags":null,"title":"1170：比较字符串最小字母出现频次（★）","uri":"/leetcode/1170/"},{"categories":null,"content":" 第 151 场周赛第 1 题 ","date":"2019-08-25","objectID":"/leetcode/1169/:0:0","tags":null,"title":"1169：查询无效交易（★）","uri":"/leetcode/1169/"},{"categories":null,"content":"题目 如果出现下述两种情况，交易 可能无效： 交易金额超过 ¥1000 或者，它和另一个城市中同名的另一笔交易相隔不超过 60 分钟（包含 60 分钟整） 每个交易字符串 transactions[i] 由一些用逗号分隔的值组成，这些值分别表示交易的名称，时间（以分钟计），金额以及城市。 给你一份交易清单 transactions，返回可能无效的交易列表。你可以按任何顺序返回答案。 提示： transactions.length \u003c= 1000 每笔交易 transactions[i] 按 “{name},{time},{amount},{city}” 的格式进行记录 每个交易名称 {name","date":"2019-08-25","objectID":"/leetcode/1169/:1:0","tags":null,"title":"1169：查询无效交易（★）","uri":"/leetcode/1169/"},{"categories":null,"content":"分析 数据范围不大，可以直接两重遍历判断每个交易是否有效。 ","date":"2019-08-25","objectID":"/leetcode/1169/:2:0","tags":null,"title":"1169：查询无效交易（★）","uri":"/leetcode/1169/"},{"categories":null,"content":"解答 def invalidTransactions(self, transactions: List[str]) -\u003e List[str]: def check(tr): name, time, amount, city = tr.split(',') if int(amount) \u003e 1000: return True for tr2 in transactions: name2, time2, _, city2 = tr2.split(',') if name == name2 and city != city2 and abs(int(time) - int(time2)) \u003c= 60","date":"2019-08-25","objectID":"/leetcode/1169/:3:0","tags":null,"title":"1169：查询无效交易（★）","uri":"/leetcode/1169/"},{"categories":null,"content":"　　天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间。元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？ ","date":"2019-07-26","objectID":"/anime/ne_zha/","tags":null,"title":"哪吒之魔童降世","uri":"/anime/ne_zha/"},{"categories":null,"content":"简介 天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间。元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？ 制作人员： 导演：杨宇 音乐：朱芸编 製作：霍尔果斯彩条屋影业有限公司、北京深海十月传媒有限公司、北京光线影业有限公司 动画制作：成都可可豆动画影视","date":"2019-07-26","objectID":"/anime/ne_zha/:1:0","tags":null,"title":"哪吒之魔童降世","uri":"/anime/ne_zha/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哪吒之魔童降世 2019-07-26 01:49:59 片库网 ","date":"2019-07-26","objectID":"/anime/ne_zha/:2:0","tags":null,"title":"哪吒之魔童降世","uri":"/anime/ne_zha/"},{"categories":null,"content":"「想要试着去往那道光芒当中」\n\n高中一年级的夏天。从离岛离家出走，来到东京的帆高。\n他的生活立刻变得困窘，在度过孤独的每一天之后终于找到的工作，\n是为古怪的超自然杂志撰稿。\n\n如同预示着他接下来的命运一般，连日不断降下雨水。\n此时，在人潮熙熙攘攘的都市一角，帆高遇到了一位少女。\n\n由于某些缘故，和弟弟两个人一起坚强生活的少女·阳菜。\n她拥有不可思议的能力。\n\n「呐，现在开始就要放晴了哦」\n\n雨水逐渐停止，街道笼罩在美丽的光芒中。\n那是，仅仅在心中祈祷，就能让天空放晴的力量——","date":"2019-07-19","objectID":"/anime/tenki_no_ko/","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":"简介 「想要试着去往那道光芒当中」 高中一年级的夏天。从离岛离家出走，来到东京的帆高。 他的生活立刻变得困窘，在度过孤独的每一天之后终于找到的工作， 是为古怪的超自然杂志撰稿。 如同预示着他接下来的命运一般，连日不断降下雨水。 此时，在人潮熙熙攘攘的都市一角，帆高遇到了一位少女。 由于某些缘故，和弟弟两个人一起坚强生活的少女·阳菜。 她拥有不可思议的能力。 「呐，现在开始就要放晴了哦」 雨水逐渐停止，街道笼罩在美丽的光芒中。 那是，仅仅在心中祈祷，就能让天空放晴的力量—— 制作人员： 原作：新海诚 演出：居村健治、德野悠我 音乐：RADWIMPS 人物设定：田中将贺、田村笃 ","date":"2019-07-19","objectID":"/anime/tenki_no_ko/:1:0","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天野阳菜 あまの ひな、Amano Hina 女 森七菜 2 森岛帆高 もりしま ほだか、Morishima Hodaka 男 醍醐虎汰朗 3 須贺圭介 すが けいすけ、Suga Keisuke 男 小栗旬 4 须贺夏美 すが なつみ、Suga Natsumi 女 本田翼 5 立花富美 たちばな ふみ、Tachibana Fumi 女 倍賞千恵子 6 天野凪 あまの なぎ、Amano Nagi 男 吉柳咲良 7 安井 男 平泉成 8 高井高司 高井高司、たかい たかし、Takai Takashi、高井刑事 男 梶裕貴 ","date":"2019-07-19","objectID":"/anime/tenki_no_ko/:2:0","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天气之子 2019-07-19 112m bilibili ","date":"2019-07-19","objectID":"/anime/tenki_no_ko/:3:0","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":"MAD ","date":"2019-07-19","objectID":"/anime/tenki_no_ko/:4:0","tags":null,"title":"天气之子","uri":"/anime/tenki_no_ko/"},{"categories":null,"content":"被浪费的青春——\n偏差值差不多的田中（通称“笨蛋”）、沉迷于BL的菊池（通称：“御宅”）、面无表情的才女・鹭宫（通称“机”）。个性十足的女高中生们无所事事的日常校园生活——","date":"2019-07-05","objectID":"/anime/jyoshi_muda/","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":"简介 被浪费的青春—— 偏差值差不多的田中（通称“笨蛋”）、沉迷于BL的菊池（通称：“御宅”）、面无表情的才女・鹭宫（通称“机”）。个性十足的女高中生们无所事事的日常校园生活—— 制作人员： 原作：ビーノ 导演：三瓶圣 脚本：坂井史世、横谷昌宏、福田裕子 分镜：神谷智大、铃木吉男、石黑达也、橘纱央莉 ","date":"2019-07-05","objectID":"/anime/jyoshi_muda/:1:0","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 田中望 笨蛋、たなか のぞむ、Tanaka Nozomu、バカ 女 赤﨑千夏 2 菊池茜 阿宅、きくち あかね、Kikuchi Akane、ヲタ 女 戸松遥 3 鹭宫栞 机器人、さぎのみや しおり、Saginomiya Shiori、ロボ 女 豊崎愛生 4 百井咲久 萝莉、ももい さく、Momoi Saku、ロリ 女 長縄まりあ 5 山本美波 有病、やまもと みなみ、Yamamoto Minami、ヤマイ 女 富田美憂 6 一奏 死认真、にのまえ かなで、Ninomae Kanade、マジメ 女 高橋李依 7 染谷莉莉 百合、そめや リリィ、Someya L","date":"2019-07-05","objectID":"/anime/jyoshi_muda/:2:0","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 女高中生的无所事事 2019-07-05 12 bilibili ","date":"2019-07-05","objectID":"/anime/jyoshi_muda/:3:0","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":"MAD ","date":"2019-07-05","objectID":"/anime/jyoshi_muda/:4:0","tags":null,"title":"女高中生的无所事事","uri":"/anime/jyoshi_muda/"},{"categories":null,"content":"题目 现在有两种线程，氧 oxygen 和氢 hydrogen，你的目标是组织这两种线程来产生水分子。 存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。 氢和氧线程会被分别给予 releaseHydrogen 和 releaseOxygen 方法来允许它们突破屏障。 这些线程应该三三成组突破屏障并能立即组合产生一个水分子。 你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。 换句话说: 如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。 如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到","date":"2019-06-27","objectID":"/leetcode/1117/:1:0","tags":null,"title":"1117：H2O 生成（★★）","uri":"/leetcode/1117/"},{"categories":null,"content":"分析 典型的并发问题，可以用信号量控制数量。 ","date":"2019-06-27","objectID":"/leetcode/1117/:2:0","tags":null,"title":"1117：H2O 生成（★★）","uri":"/leetcode/1117/"},{"categories":null,"content":"解答 from threading import Semaphore class H2O: def __init__(self): self.h = Semaphore(2) self.o = Semaphore(1) def hydrogen(self, releaseHydrogen: 'Callable[[], None]') -\u003e None: self.h.acquire() # releaseHydrogen() outputs \"H\". Do not change or remove this line. releaseHydrogen() if self.h._value == ","date":"2019-06-27","objectID":"/leetcode/1117/:3:0","tags":null,"title":"1117：H2O 生成（★★）","uri":"/leetcode/1117/"},{"categories":null,"content":"题目 现有函数 printNumber 可以用一个整数参数调用，并输出该整数到控制台。 例如，调用 printNumber(7) 将会输出 7 到控制台。 给你类 ZeroEvenOdd 的一个实例，该类中有三个函数：zero、even 和 odd 。ZeroEvenOdd 的相同实例将会传递给三个不同线程： 线程 A：调用 zero() ，只输出 0 线程 B：调用 even() ，只输出偶数 线程 C：调用 odd() ，只输出奇数 修改给出的类，以输出序列 “010203040506…” ，其中序列的长度必须为 2n 。 实现 ZeroEvenOdd 类： ZeroEvenOdd(int","date":"2019-06-26","objectID":"/leetcode/1116/:1:0","tags":null,"title":"1116：打印零与奇偶数（★★）","uri":"/leetcode/1116/"},{"categories":null,"content":"分析 典型的并发问题，最常用的是互斥锁。 ","date":"2019-06-26","objectID":"/leetcode/1116/:2:0","tags":null,"title":"1116：打印零与奇偶数（★★）","uri":"/leetcode/1116/"},{"categories":null,"content":"解答 from threading import Lock class ZeroEvenOdd: def __init__(self, n): self.n = n self.lock0 = Lock() self.lock1 = Lock() self.lock2 = Lock() self.lock1.acquire() self.lock2.acquire() def zero(self, printNumber: 'Callable[[int], None]') -\u003e None: for i in range(self.n): self.lock0.acquire() printNum","date":"2019-06-26","objectID":"/leetcode/1116/:3:0","tags":null,"title":"1116：打印零与奇偶数（★★）","uri":"/leetcode/1116/"},{"categories":null,"content":"题目 给你一个类： class FooBar {\rpublic void foo() {\rfor (int i = 0; i \u003c n; i++) {\rprint(\"foo\");\r}\r}\rpublic void bar() {\rfor (int i = 0; i \u003c n; i++) {\rprint(\"bar\");\r}\r}\r}\r两个不同的线程将会共用一个 FooBar 实例： 线程 A 将会调用 foo() 方法，而 线程 B 将会调用 bar() 方法 请设计修改程序，以确保 “foobar” 被输出 n 次。 示例 1： 输入：n = 1\r输出：\"foobar\"\r解释：这里有两个线程被异步启动","date":"2019-06-25","objectID":"/leetcode/1115/:1:0","tags":null,"title":"1115：交替打印 FooBar（★★）","uri":"/leetcode/1115/"},{"categories":null,"content":"分析 典型的并发问题，最常用的是互斥锁。 ","date":"2019-06-25","objectID":"/leetcode/1115/:2:0","tags":null,"title":"1115：交替打印 FooBar（★★）","uri":"/leetcode/1115/"},{"categories":null,"content":"解答 from threading import Lock class FooBar: def __init__(self, n): self.n = n self.lock1 = Lock() self.lock2 = Lock() self.lock2.acquire() def foo(self, printFoo: 'Callable[[], None]') -\u003e None: for i in range(self.n): self.lock1.acquire() printFoo() self.lock2.release() def bar(self, printBar: 'Call","date":"2019-06-25","objectID":"/leetcode/1115/:3:0","tags":null,"title":"1115：交替打印 FooBar（★★）","uri":"/leetcode/1115/"},{"categories":null,"content":"题目 给你一个类： public class Foo {\rpublic void first() { print(\"first\"); }\rpublic void second() { print(\"second\"); }\rpublic void third() { print(\"third\"); }\r}\r三个不同的线程 A、B、C 将会共用一个 Foo 实例。 线程 A 将会调用 first() 方法 线程 B 将会调用 second() 方法 线程 C 将会调用 third() 方法 请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 s","date":"2019-06-24","objectID":"/leetcode/1114/:1:0","tags":null,"title":"1114：按序打印（★）","uri":"/leetcode/1114/"},{"categories":null,"content":"分析 典型的并发问题，最常用的是互斥锁。 ","date":"2019-06-24","objectID":"/leetcode/1114/:2:0","tags":null,"title":"1114：按序打印（★）","uri":"/leetcode/1114/"},{"categories":null,"content":"解答 from threading import Lock class Foo: def __init__(self): self.lock1 = Lock() self.lock2 = Lock() self.lock1.acquire() self.lock2.acquire() def first(self, printFirst: 'Callable[[], None]') -\u003e None: printFirst() self.lock1.release() def second(self, printSecond: 'Callable[[], None]') -\u003e None: wit","date":"2019-06-24","objectID":"/leetcode/1114/:3:0","tags":null,"title":"1114：按序打印（★）","uri":"/leetcode/1114/"},{"categories":null,"content":"向水日奈子因考上大学而搬来海边城镇居住，她非常喜欢冲浪，觉得自己只要站在海浪之上就无所畏惧。但其实，她是一个对自己未来没有什么自信的人。因为某场火灾，日奈子和消防员雏罂粟港相遇。通过一起冲浪等经历，日奈子开始被总是为了别人着想的港所吸引。而港的心中，也萌发了对日奈子的特殊情感。","date":"2019-06-21","objectID":"/anime/kimi_nami/","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":"简介 向水日奈子因考上大学而搬来海边城镇居住，她非常喜欢冲浪，觉得自己只要站在海浪之上就无所畏惧。但其实，她是一个对自己未来没有什么自信的人。因为某场火灾，日奈子和消防员雏罂粟港相遇。通过一起冲浪等经历，日奈子开始被总是为了别人着想的港所吸引。而港的心中，也萌发了对日奈子的特殊情感。 制作人员： 导演：汤浅政明 脚本：吉田玲子 音乐：大岛满 人物设定：小岛崇史 美术监督：赤井文尚 色彩设计：中村绚郁 摄影监督：福士享 原画：前场健次 ","date":"2019-06-21","objectID":"/anime/kimi_nami/:1:0","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雏罂粟港 雛罌粟 港、ひなげし みなと、Hinageshi Minato 男 山崎智史 2 向水日奈子 むかいみず ひなこ、Mukaizumi Hinako 女 木野日菜 3 雏罂粟洋子 ひなげし ようこ、Hinageshi Yoko 女 松本穂香 4 川村山葵 かわむら わさび、Kawamura Wasabi 男 伊藤健太郎 ","date":"2019-06-21","objectID":"/anime/kimi_nami/:2:0","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 若能与你共乘海浪之上 2019-06-21 95m bilibili ","date":"2019-06-21","objectID":"/anime/kimi_nami/:3:0","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":"MAD ","date":"2019-06-21","objectID":"/anime/kimi_nami/:4:0","tags":null,"title":"若能与你共乘海浪之上","uri":"/anime/kimi_nami/"},{"categories":null,"content":"海洋生物发出光芒的同时，从地球的各个角落群聚而来。庞大的座头鲸奏着“歌曲”的同时，缓缓消失于海底之中。迎接“重头戏”的到来，海洋的一切一切开始移动了――\n不擅于以言语表达自己所思所想的中学生琉花，在暑假初日的社团活动中与队友发生争执。炎炎夏日之中，与母亲保持距离的她在校内、在家里都失去了自己的立足之所。她走到父亲工作的水族馆，伫立于大水槽前回想着过往与父母的一点一滴之际，遇上了在眼前与鱼群一同游泳的神秘少年“海”和他的哥哥“空”。\n“他们呢，是儒艮养大的。”琉花的爸爸说――\n性格开朗又天真无邪的“海”、以及像是能够看穿一切的“空”。琉花就像被他们引导着，一步一步接触她从没看到过的不可思议的世界。适逢三人的相遇，地球上同时出现了各式各样的异变。夜空中闪烁的流星突然坠落大海，海洋的所有生物开始往日本移动；甚至连庞大的座头鲸都出现，奏着“歌曲”向所有海洋生物传递“祭典的重头戏就快来了”的信息。知晓“海”与“空”两兄弟与各种超自然现象有关系、并打算加以利用他们的人；即使如此还是努力守护两兄弟的海洋学者吉姆和安格拉。各种思绪交错的人们，究竟能解开生命的种种谜团吗？“海”与“空”究竟从哪里而来，“重头戏”又是什么？\n这是琉花所接触到，一段“生命”的故事。","date":"2019-06-07","objectID":"/anime/children_of_the_sea/","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":"简介 海洋生物发出光芒的同时，从地球的各个角落群聚而来。庞大的座头鲸奏着“歌曲”的同时，缓缓消失于海底之中。迎接“重头戏”的到来，海洋的一切一切开始移动了―― 不擅于以言语表达自己所思所想的中学生琉花，在暑假初日的社团活动中与队友发生争执。炎炎夏日之中，与母亲保持距离的她在校内、在家里都失去了自己的立足之所。她走到父亲工作的水族馆，伫立于大水槽前回想着过往与父母的一点一滴之际，遇上了在眼前与鱼群一同游泳的神秘少年“海”和他的哥哥“空”。 “他们呢，是儒艮养大的。”琉花的爸爸说―― 性格开朗又天真无邪的“海”、以及像是能够看穿一切的“空”。琉花就像被他们引导着，一步一步接触她从没看到过的不可思议","date":"2019-06-07","objectID":"/anime/children_of_the_sea/:1:0","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安海琉花 女 芦田愛菜 2 海 男 石橋陽彩 3 空 男 浦上晟周 4 アングラード 男 森崎ウィン 5 ジム・キューザック 男 田中泯 6 安海加奈子 女 蒼井優 7 安海正明 男 稲垣吾郎 8 蒂蒂 女 富司純子 ","date":"2019-06-07","objectID":"/anime/children_of_the_sea/:2:0","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海兽之子 2019-06-07 01:51:18 bilibili ","date":"2019-06-07","objectID":"/anime/children_of_the_sea/:3:0","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":"MAD ","date":"2019-06-07","objectID":"/anime/children_of_the_sea/:4:0","tags":null,"title":"海兽之子","uri":"/anime/children_of_the_sea/"},{"categories":null,"content":"题目 （这是一个 交互式问题 ） 给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。 如果不存在这样的下标 index，就请返回 -1。 何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件： 首先，A.length \u003e= 3 其次，在 0 \u003c i \u003c A.length - 1 条件下，存在 i 使得： A[0] \u003c A[1] \u003c … A[i-1] \u003c A[i] A[i] \u003e A[i+1] \u003e … \u003e A[A.length - 1] 你将 不能直接访问该山脉数组，必须通过 M","date":"2019-06-05","objectID":"/leetcode/1095/:1:0","tags":null,"title":"1095：山脉数组中查找目标值（★★）","uri":"/leetcode/1095/"},{"categories":null,"content":"分析 可以先二分查找到山顶坐标 mid（第一个满足 A[i]\u003eA[i+1] 的 i)，然后 [0, mid], [mid, n-1] 区间都是单调的， 可以分别二分查找 target。 ","date":"2019-06-05","objectID":"/leetcode/1095/:2:0","tags":null,"title":"1095：山脉数组中查找目标值（★★）","uri":"/leetcode/1095/"},{"categories":null,"content":"解答 def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -\u003e int: n = mountain_arr.length() self.__class__.__getitem__ = lambda self, i: mountain_arr.get(i)\u003emountain_arr.get(i+1) mid = bisect_left(self, True, 1, n-2) self.__class__.__getitem__ = lambda self, i: mountain_arr.get(i)","date":"2019-06-05","objectID":"/leetcode/1095/:3:0","tags":null,"title":"1095：山脉数组中查找目标值（★★）","uri":"/leetcode/1095/"},{"categories":null,"content":"世界大燃烧——全世界的一半化为了焦土。引发了这未曾有过的事态的是，突然变异而诞生的能够操纵火焰的人种“燃烧者”的出现。\n在那之后过去了30年——有着攻击性的一部分自称“疯狂燃烧者”的燃烧者，再度对世界发动了攻击。\n专门对应燃烧者之特殊火焰的高机动救命消防队——“烈焰救火队”。有着燃烧的消火魂的新人队员·加洛与“疯狂燃烧者”的首领·里欧。\n炽热灵魂的激烈冲撞，两人的战斗的结末是。","date":"2019-05-24","objectID":"/anime/promare/","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":"简介 世界大燃烧——全世界的一半化为了焦土。引发了这未曾有过的事态的是，突然变异而诞生的能够操纵火焰的人种“燃烧者”的出现。 在那之后过去了30年——有着攻击性的一部分自称“疯狂燃烧者”的燃烧者，再度对世界发动了攻击。 专门对应燃烧者之特殊火焰的高机动救命消防队——“烈焰救火队”。有着燃烧的消火魂的新人队员·加洛与“疯狂燃烧者”的首领·里欧。 炽热灵魂的激烈冲撞，两人的战斗的结末是。 制作人员： 原作：中岛一基、TRIGGER 导演：今石洋之 分镜：小仓陈利、石崎寿夫、小松田大全、吉成曜 ","date":"2019-05-24","objectID":"/anime/promare/:1:0","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 加洛·提莫斯 Galo Thymos 男 松山ケンイチ 2 里欧·弗提亚 Lio Fotia 男 早乙女太一 3 艾娜·阿尔德比特 Aina Ardebit 女 佐倉綾音 4 露琪亚·菲克斯 Lucia Fex 女 新谷真弓 5 瓦里斯·特拉斯 Varys Truss 男 稲田徹 6 雷米·普古纳 Remi Puguna 男 吉野裕行 7 伊格尼斯·艾克斯 Ignis Ex 男 小山力也 8 维尼 Vinny ケンドーコバヤシ ","date":"2019-05-24","objectID":"/anime/promare/:2:0","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Promare 2019-05-24 111m bilibili ","date":"2019-05-24","objectID":"/anime/promare/:3:0","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":"MAD ","date":"2019-05-24","objectID":"/anime/promare/:4:0","tags":null,"title":"Promare","uri":"/anime/promare/"},{"categories":null,"content":"题目 给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。 返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 \"\" 。 示例 1： 输入：s = \"banana\"\r输出：\"ana\"\r示例 2： 输入：s = \"abcd\"\r输出：\"\"\r提示： 2 \u003c= s.length \u003c= 3 * 10^4 s 由小写英文字母组成 ","date":"2019-04-15","objectID":"/leetcode/1044/:1:0","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"分析 类似 0718，可以用二分查找+滚动哈希解决。 元素种数最多 26，用到的窗口种数最多 5*10^5 级别，因此考虑 base 取 29，mod 取 10^11+3 ","date":"2019-04-15","objectID":"/leetcode/1044/:2:0","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"解答 def longestDupSubstring(self, s: str) -\u003e str: def check(L): vis, w, bL = set(), 0, pow(base, L, mod) for j, char in enumerate(s): w = w*base+ord(char)-ord('a') if j\u003e=L: w -= (ord(s[j-L])-ord('a'))*bL w %= mod if j\u003e=L-1: if w in vis: return False, s[j-L+1:j+1] vis.add(w) return True, '' base, mod ","date":"2019-04-15","objectID":"/leetcode/1044/:3:0","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"*附加 滚动哈希只要存在 mod，就有针对性的数据使其出错。而后缀数组算法则能保证一定正确。所以本题可以用来练习 后缀数组 算法。 ","date":"2019-04-15","objectID":"/leetcode/1044/:4:0","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"#1 后缀数组有几种实现方法，最好理解的是 倍增法。 直接用 sort，时间复杂度 $O(N * log^2N)$，用基数排序，时间复杂度 $O(N * logN)$。 求得后缀数组后，可以在 O(N) 时间得到 height 数组，即可求解。 def longestDupSubstring(self, s: str) -\u003e str: def SA(A): n, size = len(A), 1 rk, sa = [0] * n, sorted((A[i], i) for i in range(n)) while True: prev, cnt = None, 0 for x, i in sa","date":"2019-04-15","objectID":"/leetcode/1044/:4:1","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"#2 最快的实现则是 诱导排序 方法，但理解难度较大， 最好结合讲解，实际运行每一步，观察每一步的输入输出。 这里给出一种模板（尽量精简了。。。） def longestDupSubstring(self, s: str) -\u003e str: def SA_IS(A): def equal(pos1, pos2): end1, end2 = LMS.find('*', pos1+1), LMS.find('*', pos2+1) return A[pos1:end1+1] == A[pos2:end2+1] def IS(stars): sa = [n] + [-1] * n tails = li","date":"2019-04-15","objectID":"/leetcode/1044/:4:2","tags":null,"title":"1044：最长重复子串（★★★）","uri":"/leetcode/1044/"},{"categories":null,"content":"「《异世界四重奏》由STUDIO PUYUKAI负责制作，是将《OVERLORD》、《为美好的世界献上祝福！》、《Re：从零开始的异世界生活》、《幼女战记》四部异世界轻小说的角色Q版化的电视动画作品。\n\n此次的企划是由曾经手其中三部作品迷你动画的STUDIO PUYUKAI所推动，而监督当然也是负责这几部迷你动画的芦名实。虽然只是2头身的阳春画面，但监督和编剧的确相当了解迷你动画的重点，演出节奏相当紧凑，几乎每隔5秒就有一个笑点出现。\n\n而比起制作部分，此次配音的部分可以说是一场大乱斗。除了完整集合了四部作品动画总共20多位的主力配音演员外，甚至有高桥李依这种一人分饰两作主要角色的状况出现，阵容可说是相当豪华。\n\n总结而言，该作其实可以说是角川版异世界的《幻想嘉年华》。短短十多分钟内塞满了各式的高强度搞笑和槽点，再加上满满的原作捏他，作为粉丝向作品可说是再完美不过了。","date":"2019-04-09","objectID":"/anime/isekai_quartet/","tags":null,"title":"异世界四重奏","uri":"/anime/isekai_quartet/"},{"categories":null,"content":"简介 「《异世界四重奏》由STUDIO PUYUKAI负责制作，是将《OVERLORD》、《为美好的世界献上祝福！》、《Re：从零开始的异世界生活》、《幼女战记》四部异世界轻小说的角色Q版化的电视动画作品。 此次的企划是由曾经手其中三部作品迷你动画的STUDIO PUYUKAI所推动，而监督当然也是负责这几部迷你动画的芦名实。虽然只是2头身的阳春画面，但监督和编剧的确相当了解迷你动画的重点，演出节奏相当紧凑，几乎每隔5秒就有一个笑点出现。 而比起制作部分，此次配音的部分可以说是一场大乱斗。除了完整集合了四部作品动画总共20多位的主力配音演员外，甚至有高桥李依这种一人分饰两作主要角色的状况出现，","date":"2019-04-09","objectID":"/anime/isekai_quartet/:1:0","tags":null,"title":"异世界四重奏","uri":"/anime/isekai_quartet/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安兹·乌尔·恭 铃木悟、莫莫伽、飞鼠、ainz ooal gown、モモンガ、拥有骷髅外表的最强魔法吟唱者 男 日野聡 2 雅儿贝德 albedo、温柔体贴的纯白恶魔 女 原由実 3 佐藤和真 佐藤 和真、サトウ カズマ、Satou Kazuma 男 福島潤 4 阿克娅 阿库娅、Aqua、アクア、Akua、茶包 女 雨宮天 5 菜月昴 なつき・すばる、Natsuki Subaru 男 小林裕介 6 艾米莉娅 爱蜜莉雅、Emilia、EMT 女 高橋李依 7 谭雅·提古雷查夫 Tanya Degurechaff 女 悠木碧 8 维夏 维多利亚·伊娃诺娃·谢列布","date":"2019-04-09","objectID":"/anime/isekai_quartet/:2:0","tags":null,"title":"异世界四重奏","uri":"/anime/isekai_quartet/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 异世界四重奏 2019-04-09 12 樱花 2 异世界四重奏2 2020-01-14 12 樱花 3 剧场版 异世界四重奏 ～Another World～ 2022-06-10 1 bilibili ","date":"2019-04-09","objectID":"/anime/isekai_quartet/:3:0","tags":null,"title":"异世界四重奏","uri":"/anime/isekai_quartet/"},{"categories":null,"content":"大正时期、日本。\n卖炭的心地善良的少年·炭治郎，有一天被鬼杀死了家人。\n而唯一幸存下来的妹妹祢豆子变成了鬼。\n被绝望的现实打垮的炭治郎，为了让妹妹变回人类并讨伐杀害家人的鬼，决心沿着“鬼杀队”的道路前进。\n人与鬼交织的悲哀的兄妹的故事，现在开始！","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":"简介 大正时期、日本。 卖炭的心地善良的少年·炭治郎，有一天被鬼杀死了家人。 而唯一幸存下来的妹妹祢豆子变成了鬼。 被绝望的现实打垮的炭治郎，为了让妹妹变回人类并讨伐杀害家人的鬼，决心沿着“鬼杀队”的道路前进。 人与鬼交织的悲哀的兄妹的故事，现在开始！ 制作人员： 原作：吾峠呼世晴 导演：外崎春雄 脚本：ufotable 分镜：南野纯一、野中卓也、寺尾优一、栖原隆史、竹内将 ","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/:1:0","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 灶门炭治郎 竈門 炭治郎、かまど たんじろう、Kamado Tanjirou 男 佐藤聡美 2 灶门祢豆子 竈門 禰豆子、かまど ねずこ、Kamado Nezuko 女 鬼頭明里 3 我妻善逸 我妻 善逸、あがつま ぜんいつ、Agatsuma Zenitsu、懶覺丸 男 下野紘 4 嘴平伊之助 嘴平 伊之助、はしびら いのすけ、Hashibira Inosuke 男 松岡禎丞 5 富冈义勇 冨岡 義勇、とみおか ぎゆう、Tomioka Giyuu 男 櫻井孝宏 6 蝴蝶忍 胡蝶 しのぶ、こちょう しのぶ、Kochou Shinobu 女 早見沙織 7 炼狱杏","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/:2:0","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 鬼灭之刃 2019-04-06 26 bilibili 2 剧场版 鬼灭之刃 无限列车篇 2020-10-16 1 樱花 3 鬼灭之刃 无限列车篇 2021-10-10 7 bilibili 4 鬼灭之刃 游郭篇 2021-12-05 11 bilibili ","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/:3:0","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":"MAD ","date":"2019-04-06","objectID":"/anime/kimetsu_no_yaiba/:4:0","tags":null,"title":"鬼灭之刃","uri":"/anime/kimetsu_no_yaiba/"},{"categories":null,"content":"题目 如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。 （我们可以在任何位置插入每个字符，也可以插入 0 个字符。） 给定待查询列表 queries，和模式串 pattern，返回由布尔值组成的答案列表 answer。 只有在待查项 queries[i] 与模式串 pattern 匹配时， answer[i] 才为 true，否则为 false。 示例 1： 输入：queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"","date":"2019-03-22","objectID":"/leetcode/1023/:1:0","tags":null,"title":"1023：驼峰式匹配（★★）","uri":"/leetcode/1023/"},{"categories":null,"content":"分析 ","date":"2019-03-22","objectID":"/leetcode/1023/:2:0","tags":null,"title":"1023：驼峰式匹配（★★）","uri":"/leetcode/1023/"},{"categories":null,"content":"#1 当 pattern 是 query 的子序列且包含了 query 的所有大写字母时，即匹配。 可以直接用正则。 def camelMatch(self, queries: List[str], pattern: str) -\u003e List[bool]: reg = '[a-z]*?'.join(['']+list(pattern)+[''])+'$' return [bool(re.match(reg, q)) for q in queries] 44 ms ","date":"2019-03-22","objectID":"/leetcode/1023/:2:1","tags":null,"title":"1023：驼峰式匹配（★★）","uri":"/leetcode/1023/"},{"categories":null,"content":"#2 也可以遍历判断。 ","date":"2019-03-22","objectID":"/leetcode/1023/:2:2","tags":null,"title":"1023：驼峰式匹配（★★）","uri":"/leetcode/1023/"},{"categories":null,"content":"解答 def camelMatch(self, queries: List[str], pattern: str) -\u003e List[bool]: def check(q): i = 0 for char in q: if i\u003cn and char == pattern[i]: i += 1 elif char.isupper(): return False return i==n n = len(pattern) return [check(q) for q in queries] 36 ms ","date":"2019-03-22","objectID":"/leetcode/1023/:3:0","tags":null,"title":"1023：驼峰式匹配（★★）","uri":"/leetcode/1023/"},{"categories":null,"content":"题目 给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。 示例 1： 输入：n = 20\r输出：1\r解释：具有至少 1 位重复数字的正数（\u003c= 20）只有 11 。\r示例 2： 输入：n = 100\r输出：10\r解释：具有至少 1 位重复数字的正数（\u003c= 100）有 11，22，33，44，55，66，77，88，99 和 100 。\r示例 3： 输入：n = 1000\r输出：262\r提示： 1 \u003c= n \u003c= 10^9 ","date":"2019-03-11","objectID":"/leetcode/1012/:1:0","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"分析 ","date":"2019-03-11","objectID":"/leetcode/1012/:2:0","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"#1 可以先求 [0, n] 范围内数字不重复的个数，再用 n+1 减去即可。 求范围内数字满足某种性质的个数，容易想到用数位 dp，令 dfs(pos, state, bound) 代表某个状态下的结果： 遍历到 n 的第 pos 位 前面取的数的集合状态是 state bound 代表前面取的数是否贴着 n 的上界 即可递归。 特别注意前置 0 不应该加入到 state 中。 def numDupDigitsAtMostN(self, n: int) -\u003e int: @lru_cache(None) def dfs(pos, state, bound): if pos==len(s): r","date":"2019-03-11","objectID":"/leetcode/1012/:2:1","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"#2 也可以利用排列组合知识直接分段计算。例如对于 n=8382： [0, 1000) 的数字不重复的个数：9*(perm(9,0)+perm(9,1)+perm(9,2)) [1000, 8000) 的对应个数：7*perm(9,3) [8000, 8300) 的对应个数：3*perm(8,2) [8300, 8380) 的对应个数：7*perm(7,1) [8380, 8382) 的对应个数：0 具体实现时，假设 s=str(n) 的长度为 m： 先计算 0-10^(m-1) 的对应个数 然后遍历 i，在 s[:i] 不变的情况下，求 s[i] 能取的值，即在 [0, 原 s[i]) 区间","date":"2019-03-11","objectID":"/leetcode/1012/:2:2","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":"解答 def numDupDigitsAtMostN(self, n: int) -\u003e int: s = str(n) m = len(s) res = 9*sum(perm(9, k) for k in range(m-1)) vis = set() for i in range(m): cur = int(s[i]) cand = set(range(int(i==0), cur+int(i==m-1)))-vis res += len(cand)*perm(9-i, m-i-1) if cur in vis: break vis.add(cur) return n-res 36 ms ","date":"2019-03-11","objectID":"/leetcode/1012/:3:0","tags":null,"title":"1012：至少有 1 位重复的数字（★★★）","uri":"/leetcode/1012/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2019-02-03","objectID":"/leetcode/0997/:0:0","tags":null,"title":"0997：找到小镇的法官（★）","uri":"/leetcode/0997/"},{"categories":null,"content":"题目 在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。 如果小镇的法官真的存在，那么： 小镇的法官不相信任何人。 每个人（除了小镇法官外）都信任小镇的法官。 只有一个人同时满足属性 1 和属性 2 。 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。 如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。 提示： 1 \u003c= N \u003c= 1000 trust.length \u003c= 10000 trust[i] 是完全不同的 trust[i][0] != tr","date":"2019-02-03","objectID":"/leetcode/0997/:1:0","tags":null,"title":"0997：找到小镇的法官（★）","uri":"/leetcode/0997/"},{"categories":null,"content":"分析 显然法官被 N-1 个人信任且自己信任 0 人，所以记录每个人被多少人信任和自己信任多少人即可。 本题也可以看作是一个图问题。将人作为顶点，信任关系作为边，即是求有向图中入度 N-1 且出度 0 的节点。 ","date":"2019-02-03","objectID":"/leetcode/0997/:2:0","tags":null,"title":"0997：找到小镇的法官（★）","uri":"/leetcode/0997/"},{"categories":null,"content":"解答 def findJudge(self, n: int, trust: List[List[int]]) -\u003e int: indeg, outdeg = [0] * (n+1), [0] * (n+1) for u, v in trust: indeg[v] += 1 outdeg[u] += 1 for i in range(1, n+1): if indeg[i] == n-1 and outdeg[i] == 0: return i return -1 120 ms ","date":"2019-02-03","objectID":"/leetcode/0997/:3:0","tags":null,"title":"0997：找到小镇的法官（★）","uri":"/leetcode/0997/"},{"categories":null,"content":"题目 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4， 并采用两种不同的形式之一：“a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 提示： 1 \u003c= equations.length \u003c= 500 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 ‘=’，要么是 ‘!’ equ","date":"2019-01-29","objectID":"/leetcode/0990/:1:0","tags":null,"title":"0990：等式方程的可满足性（★）","uri":"/leetcode/0990/"},{"categories":null,"content":"分析 典型的并查集应用。先将所有等号两边的变量连通，然后再判断所有不等号两边的变量不连通即可。 ","date":"2019-01-29","objectID":"/leetcode/0990/:2:0","tags":null,"title":"0990：等式方程的可满足性（★）","uri":"/leetcode/0990/"},{"categories":null,"content":"解答 def equationsPossible(self, equations: List[str]) -\u003e bool: def find(i): if p.setdefault(i, i) != i: p[i] = find(p[i]) return p[i] def union(i, j): p[find(i)] = find(j) p = {} for eq in equations: if eq[1:-1] == '==': union(eq[0], eq[-1]) return all(find(eq[0]) != find(eq[-1]) for eq in equations ","date":"2019-01-29","objectID":"/leetcode/0990/:3:0","tags":null,"title":"0990：等式方程的可满足性（★）","uri":"/leetcode/0990/"},{"categories":null,"content":"家庭背景与人品都很棒！！一大群有前途的秀才所聚集的秀知院学园！！在那里的学生会相遇的副会长·四宫辉夜与会长·白银御行原本应该是彼此受到了对方吸引…但想不到都过半年了却仍然什么事情也没发生！！最麻烦的是这两个自尊心超强、无法坦率的家伙，居然开始想着要“设法让对方向自己告白”！？\n直到恋情有下落之前会很欢乐的故事！！新感觉“斗智”爱情喜剧、就此开战！！","date":"2019-01-12","objectID":"/anime/kaguya_love/","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"简介 家庭背景与人品都很棒！！一大群有前途的秀才所聚集的秀知院学园！！在那里的学生会相遇的副会长·四宫辉夜与会长·白银御行原本应该是彼此受到了对方吸引…但想不到都过半年了却仍然什么事情也没发生！！最麻烦的是这两个自尊心超强、无法坦率的家伙，居然开始想着要“设法让对方向自己告白”！？ 直到恋情有下落之前会很欢乐的故事！！新感觉“斗智”爱情喜剧、就此开战！！ 制作人员： 原作：赤坂明 导演：小俣真一 脚本：中西泰大、菅原雪绘 分镜：藤泽俊幸、中村哲治、及川启、齐藤哲人、十的一发 ","date":"2019-01-12","objectID":"/anime/kaguya_love/:1:0","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 四宫辉夜 しのみや かぐや、Shinomiya Kaguya 女 古賀葵 2 白银御行 しろがね みゆき、Shirogane Miyuki 男 古川慎 3 藤原千花 ふじわら ちか、Fujiwara Chika 女 小原好美 4 石上优 いしがみ ゆう 男 鈴木崚汰 5 早坂爱 はやさか あい、Hayasaka Ai 女 花守ゆみり 6 柏木渚 かしわぎ なぎさ 女 麻倉もも 7 田沼翼 柏木的男友、柏木の彼氏、たぬま つばさ、Tamema Tsubasa、男子生徒 男 八代拓 8 白银圭 しろがね けい、Shirogane Kei 女 鈴代紗弓 ","date":"2019-01-12","objectID":"/anime/kaguya_love/:2:0","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 辉夜大小姐想让我告白～天才们的恋爱头脑战～ 2019-01-12 12 bilibili 2 辉夜大小姐想让我告白？～天才们的恋爱头脑战～ 2020-04-11 12 bilibili 3 辉夜大小姐想让我告白-超级浪漫- 2022-04-08 13 bilibili ","date":"2019-01-12","objectID":"/anime/kaguya_love/:3:0","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"MAD ","date":"2019-01-12","objectID":"/anime/kaguya_love/:4:0","tags":null,"title":"辉夜大小姐想让我告白～天才们的恋爱头脑战～","uri":"/anime/kaguya_love/"},{"categories":null,"content":"晚唐年间，国师发动民众大量捕蛇。前去刺杀国师的白蛇意外失忆，被捕蛇村少年救下。为帮助少女找回记忆，两人踏上了一段冒险旅程。冒险的过程让两人感情迅速升温，但少女蛇妖的身份也逐渐显露，另一边国师与蛇族之间不可避免的大战也即将打响，两人的爱情将要接受巨大考验。","date":"2019-01-11","objectID":"/anime/white_snake/","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"简介 晚唐年间，国师发动民众大量捕蛇。前去刺杀国师的白蛇意外失忆，被捕蛇村少年救下。为帮助少女找回记忆，两人踏上了一段冒险旅程。冒险的过程让两人感情迅速升温，但少女蛇妖的身份也逐渐显露，另一边国师与蛇族之间不可避免的大战也即将打响，两人的爱情将要接受巨大考验。 制作人员： 导演：赵霁 脚本：王微 主题歌演出：周深 製作：华纳兄弟娱乐公司、追光人动画设计（北京）有限公司 ","date":"2019-01-11","objectID":"/anime/white_snake/:1:0","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小白 ハク 女 三森すずこ 2 阿宣 セン 男 杨天翔 3 肚兜 はらまき 杉田智和 4 小青 セイ 女 佐倉綾音 5 宝青坊主 宝青坊の主、ホウセイボウノヌシ 女 悠木碧 6 道士 ドウシ 男 石川界人 7 蛇母 ジャボ 本田貴子 8 国师 国師、コクシ 男 柴田秀勝 ","date":"2019-01-11","objectID":"/anime/white_snake/:2:0","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 白蛇：缘起 2019-01-11 99m 其它 ","date":"2019-01-11","objectID":"/anime/white_snake/:3:0","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"MAD ","date":"2019-01-11","objectID":"/anime/white_snake/:4:0","tags":null,"title":"白蛇：缘起","uri":"/anime/white_snake/"},{"categories":null,"content":"2018 年投稿的 MAD 盘点","date":"2018-12-31","objectID":"/anime/2018_mad/","tags":null,"title":"2018 MAD","uri":"/anime/2018_mad/"},{"categories":null,"content":"2018 年投稿的 MAD 盘点 ","date":"2018-12-31","objectID":"/anime/2018_mad/:0:0","tags":null,"title":"2018 MAD","uri":"/anime/2018_mad/"},{"categories":null,"content":"单素材 ","date":"2018-12-31","objectID":"/anime/2018_mad/:1:0","tags":null,"title":"2018 MAD","uri":"/anime/2018_mad/"},{"categories":null,"content":"多素材 ","date":"2018-12-31","objectID":"/anime/2018_mad/:2:0","tags":null,"title":"2018 MAD","uri":"/anime/2018_mad/"},{"categories":null,"content":"同人 ","date":"2018-12-31","objectID":"/anime/2018_mad/:3:0","tags":null,"title":"2018 MAD","uri":"/anime/2018_mad/"},{"categories":null,"content":"* 总结 ","date":"2018-12-31","objectID":"/anime/2018_mad/:4:0","tags":null,"title":"2018 MAD","uri":"/anime/2018_mad/"},{"categories":null,"content":"题目 在由 1 x 1 方格组成的 n x n 网格 grid 中，每个 1 x 1 方块由 ‘/’、’' 或空格构成。 这些字符会将方块划分为一些共边的区域。 给定网格 grid 表示为一个字符串数组，返回 区域的数量 。 请注意，反斜杠字符是转义的，因此 ‘' 用 ‘\\’ 表示。 示例 1： 输入：grid = [\" /\",\"/ \"]\r输出：2\r示例 2： 输入：grid = [\" /\",\" \"]\r输出：1\r示例 3： 输入：grid = [\"/\\\\\",\"\\\\/\"]\r输出：5\r解释：回想一下，因为 \\ 字符是转义的，所以 \"/\\\\\" 表示 /\\，而 \"\\\\/\" 表示 \\/。\r提示： n =","date":"2018-12-29","objectID":"/leetcode/0959/:1:0","tags":null,"title":"0959：由斜杠划分区域（★★）","uri":"/leetcode/0959/"},{"categories":null,"content":"分析 区域数量其实就是连通块的数量，考虑用并查集。 ‘/’ 和 ‘' 将方格分为四小块，遍历并连通即可。 注意方格 (i, j) 左小块和 (i, j-1) 右小块必然连通， 方格 (i, j) 上小块和 (i-1, j) 下小块必然连通。 ","date":"2018-12-29","objectID":"/leetcode/0959/:2:0","tags":null,"title":"0959：由斜杠划分区域（★★）","uri":"/leetcode/0959/"},{"categories":null,"content":"解答 def regionsBySlashes(self, grid: List[str]) -\u003e int: def find(x): if f.setdefault(x, x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) n, f = len(grid), {} for i, j in product(range(n), range(n)): if i: union((i, j, 0), (i-1, j, 2)) if j: union((i, j, 3), (i, j-1, 1)) if","date":"2018-12-29","objectID":"/leetcode/0959/:3:0","tags":null,"title":"0959：由斜杠划分区域（★★）","uri":"/leetcode/0959/"},{"categories":null,"content":"蜘蛛侠不止一个！漫威首部超英动画巨制《蜘蛛侠：平行宇宙》将经典漫画与CGI技术完美呈现，讲述了普通高中生迈尔斯·莫拉斯如何师从蜘蛛侠彼得·帕克，成长为新一代超级英雄的故事。影片中迈尔斯和从其它平行宇宙中穿越而来的彼得、女蜘蛛侠格温、暗影蜘蛛侠、潘妮·帕克和蜘猪侠集结成团，六位蜘蛛侠首次同框大银幕，对抗蜘蛛侠宇宙最强反派。","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":"简介 蜘蛛侠不止一个！漫威首部超英动画巨制《蜘蛛侠：平行宇宙》将经典漫画与CGI技术完美呈现，讲述了普通高中生迈尔斯·莫拉斯如何师从蜘蛛侠彼得·帕克，成长为新一代超级英雄的故事。影片中迈尔斯和从其它平行宇宙中穿越而来的彼得、女蜘蛛侠格温、暗影蜘蛛侠、潘妮·帕克和蜘猪侠集结成团，六位蜘蛛侠首次同框大银幕，对抗蜘蛛侠宇宙最强反派。 制作人员： 原作：斯坦·李、漫威娱乐 特效：索尼图形图像运作公司 制作：索尼影视娱乐 ","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/:1:0","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 蜘蛛侠 蜘蛛人、スパイダーマン 男 2 潘妮·帕克 蜘蛛机甲战士（SP//dr） 女 高橋李依 ","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/:2:0","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 蜘蛛侠：平行宇宙 2018-12-14 01:45:24 樱花 ","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/:3:0","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":"MAD ","date":"2018-12-14","objectID":"/anime/spider_man_a_new_universe/:4:0","tags":null,"title":"蜘蛛侠：平行宇宙","uri":"/anime/spider_man_a_new_universe/"},{"categories":null,"content":"“我不拯救世界，只管杀哥布林。”\n据说这间边境公会里，有个只靠讨伐哥布林升上了银等级（位列第三位）的罕见存在……一名女神官成为冒险者后，首次加入团队，就在冒险中陷入了危机。而拯救了她的，正是这名被称为“哥布林杀手”的男子。\n他不择手段，不辞劳苦，只致力于扫荡哥布林。 在他身边，有着饱受折腾的女神官、自己非常感激的柜台小姐，等待着他青梅竹马的牧牛少女。一名森人（妖精）少女听闻他的事迹，也前来委托任务——。","date":"2018-10-06","objectID":"/anime/goblin_slayer/","tags":null,"title":"哥布林杀手","uri":"/anime/goblin_slayer/"},{"categories":null,"content":"简介 “我不拯救世界，只管杀哥布林。” 据说这间边境公会里，有个只靠讨伐哥布林升上了银等级（位列第三位）的罕见存在……一名女神官成为冒险者后，首次加入团队，就在冒险中陷入了危机。而拯救了她的，正是这名被称为“哥布林杀手”的男子。 他不择手段，不辞劳苦，只致力于扫荡哥布林。 在他身边，有着饱受折腾的女神官、自己非常感激的柜台小姐，等待着他青梅竹马的牧牛少女。一名森人（妖精）少女听闻他的事迹，也前来委托任务——。 制作人员： 原作：蝸牛くも 导演：尾崎隆晴 脚本：仓田英之、黑田洋介 分镜：神谷纯、迫井政行、古贺一臣、小泽一浩 ","date":"2018-10-06","objectID":"/anime/goblin_slayer/:1:0","tags":null,"title":"哥布林杀手","uri":"/anime/goblin_slayer/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哥布林杀手 Goblin Slayer 男 松田颯水 2 女神官 Priestess 女 小倉唯 3 妖精弓手 High Elf Archer 女 東山奈央 4 矿人道士 Dwarf Shaman 男 中村悠一 5 蜥蜴僧侣 Lizard Priest 男 杉田智和 6 牧牛妹 Cow Girl 女 井口裕香 7 柜台小姐 Guild Girl 女 内田真礼 8 剑之圣女 Sword Maiden 女 遠藤綾 ","date":"2018-10-06","objectID":"/anime/goblin_slayer/:2:0","tags":null,"title":"哥布林杀手","uri":"/anime/goblin_slayer/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哥布林杀手 2018-10-06 12 樱花 2 哥布林杀手：哥布林的王冠 2020-02-01 1 樱花 ","date":"2018-10-06","objectID":"/anime/goblin_slayer/:3:0","tags":null,"title":"哥布林杀手","uri":"/anime/goblin_slayer/"},{"categories":null,"content":"女主出场不到两分钟，光速去世；为了拯救没落的佐贺县，7位僵尸小姐姐站了出来，决定成为偶像……","date":"2018-10-04","objectID":"/anime/zombie_land_saga/","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"简介 女主出场不到两分钟，光速去世；为了拯救没落的佐贺县，7位僵尸小姐姐站了出来，决定成为偶像…… 制作人员： 导演：境宗久 脚本：村越繁、增本拓也 分镜：后藤康徳、石田贵史、清水久敏、伊藤达文、宇田钢之介、佐藤威 ","date":"2018-10-04","objectID":"/anime/zombie_land_saga/:1:0","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 巽幸太郎 たつみ こうたろう、Tatsumi Kotaro 男 宮野真守 2 源樱 みなもと さくら、Minamoto Sakura 女 本渡楓 3 二阶堂咲 二阶堂笑、にかいどう さき、Nikaido Saki 女 田野アサミ 4 水野爱 みずの あい、Mizuno Ai 女 種田梨沙 5 绀野纯子 こんの じゅんこ、Konno Junko 女 河瀬茉希 6 夕雾 Yugiri 女 衣川里佳 7 星川莉莉 豪正雄、Hoshikawa Lily、ほしかわ リリィ、Hoshikawa Ririi、正雄哥 田中美海 8 山田多惠 山田妙、やまだ たえ、Yamad","date":"2018-10-04","objectID":"/anime/zombie_land_saga/:2:0","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 佐贺偶像是传奇 2018-10-04 12 acfun 2 佐贺偶像是传奇 复仇 2021-04-08 12 bilibili ","date":"2018-10-04","objectID":"/anime/zombie_land_saga/:3:0","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"MAD ","date":"2018-10-04","objectID":"/anime/zombie_land_saga/:4:0","tags":null,"title":"佐贺偶像是传奇","uri":"/anime/zombie_land_saga/"},{"categories":null,"content":"思春期症候群——这是一种只发生在易敏感和不稳定的青春期的、不可思议的现象。\n例如，在梓川咲太面前出现的野生兔女郎。\n她的真实身份是高中高年级学生，明星活动休止的女演员樱岛麻衣。她迷人的身姿，不知为何在周围的人眼里看不出来。\n咲太决定解开这一谜题。在于麻衣一起度过的时间里，咲太知道了她秘密的想法……\n女主人公们一个接一个地出现在咲太的周围，她们都有着“青春期症候群”。在天空和大海都很闪耀的小镇上，开始了令人激动的故事。","date":"2018-10-03","objectID":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/","tags":null,"title":"青春笨蛋少年不做兔女郎学姐的梦","uri":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/"},{"categories":null,"content":"简介 思春期症候群——这是一种只发生在易敏感和不稳定的青春期的、不可思议的现象。 例如，在梓川咲太面前出现的野生兔女郎。 她的真实身份是高中高年级学生，明星活动休止的女演员樱岛麻衣。她迷人的身姿，不知为何在周围的人眼里看不出来。 咲太决定解开这一谜题。在于麻衣一起度过的时间里，咲太知道了她秘密的想法…… 女主人公们一个接一个地出现在咲太的周围，她们都有着“青春期症候群”。在天空和大海都很闪耀的小镇上，开始了令人激动的故事。 制作人员： 原作：鸭志田一 导演：增井壮一 脚本：横谷昌宏 分镜：小野龙太、宫尾佳和、平牧大辅、岩田和也、堀口和树、倉川英揚 ","date":"2018-10-03","objectID":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/:1:0","tags":null,"title":"青春笨蛋少年不做兔女郎学姐的梦","uri":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 梓川咲太 梓川 咲太、あずさがわ さくた、Azusagawa Sakuta 男 石川界人 2 樱岛麻衣 さくらじま まい、Sakurajima Mai 女 瀬戸麻沙美 3 古贺朋绘 古賀 朋絵、こが ともえ、Koga Tomoe 女 東山奈央 4 双叶理央 双葉 理央、ふたば りお、Futaba Rio 女 種﨑敦美 5 丰滨和花 丰滨和香、とよはま のどか、Toyohama Nodoka 女 内田真礼 6 梓川枫 梓川 かえで、あずさがわ かえで、Azusagawa Kaede 女 久保ユリカ 7 牧之原翔子 まきのはら しょうこ、Makinohara S","date":"2018-10-03","objectID":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/:2:0","tags":null,"title":"青春笨蛋少年不做兔女郎学姐的梦","uri":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 青春笨蛋少年不做兔女郎学姐的梦 2018-10-03 13 bilibili 2 青春笨蛋少年不做怀梦美少女的梦 2019-06-15 1 bilibili ","date":"2018-10-03","objectID":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/:3:0","tags":null,"title":"青春笨蛋少年不做兔女郎学姐的梦","uri":"/anime/rascal_does_not_dream_of_bunny_girl_senpai/"},{"categories":null,"content":"题目 给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。 环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。 子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], …, nums[j] ， 不存在 i \u003c= k1, k2 \u003c= j 其中 k1 % n == k2 % n 。 示例 1： 输入：nums = [1,-2,3,-","date":"2018-09-30","objectID":"/leetcode/0918/:1:0","tags":null,"title":"0918：环形子数组的最大和（★★）","uri":"/leetcode/0918/"},{"categories":null,"content":"分析 ","date":"2018-09-30","objectID":"/leetcode/0918/:2:0","tags":null,"title":"0918：环形子数组的最大和（★★）","uri":"/leetcode/0918/"},{"categories":null,"content":"#1 涉及到子数组的和，首先想到前缀和。因为是环形数组，所以考虑求 nums*2 的前缀和。 得到前缀和数组 pre 后，问题转为：求最大的 pre[j]-pre[i] 满足 j-i\u003c=len(nums)。 那么遍历 j，维护 pre[j-n:j] 的最小值即可。这类似于 0239，可以用有序集合解决。 def maxSubarraySumCircular(self, nums: List[int]) -\u003e int: from sortedcontainers import SortedList pre = list(accumulate([0]+nums*2)) sl, n = Sorted","date":"2018-09-30","objectID":"/leetcode/0918/:2:1","tags":null,"title":"0918：环形子数组的最大和（★★）","uri":"/leetcode/0918/"},{"categories":null,"content":"#2 也可以采用 0239 的单调队列方法。 ","date":"2018-09-30","objectID":"/leetcode/0918/:2:2","tags":null,"title":"0918：环形子数组的最大和（★★）","uri":"/leetcode/0918/"},{"categories":null,"content":"解答 def maxSubarraySumCircular(self, nums: List[int]) -\u003e int: pre = list(accumulate([0]+nums*2)) queue, n = deque(), len(nums) res = float('-inf') for j, x in enumerate(pre): if j: res = max(res, x-queue[0][0]) while queue and queue[-1][0]\u003e=x: queue.pop() queue.append((x, j)) if queue[0][1]==j-n: que","date":"2018-09-30","objectID":"/leetcode/0918/:3:0","tags":null,"title":"0918：环形子数组的最大和（★★）","uri":"/leetcode/0918/"},{"categories":null,"content":"题目 给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X \u003e= 2 时返回 true。 示例 1： 输入：deck = [1,2,3,4,4,3,2,1]\r输出：true\r解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]\r示例 2： 输入：deck = [1,1,1,2,2,2,3,3]\r输出：false\r解释：没有满足要求的分组。\r提示： 1 \u003c= deck.length \u003c= 10^4 0 \u003c= deck[i] \u003c 10^4 ","date":"2018-09-26","objectID":"/leetcode/0914/:1:0","tags":null,"title":"0914：卡牌分组（★）","uri":"/leetcode/0914/"},{"categories":null,"content":"分析 先将相同的牌分到一组，发现如果所有组的牌数有一个大于 1 的最大公约数，则可行。 ","date":"2018-09-26","objectID":"/leetcode/0914/:2:0","tags":null,"title":"0914：卡牌分组（★）","uri":"/leetcode/0914/"},{"categories":null,"content":"解答 def hasGroupsSizeX(self, deck: List[int]) -\u003e bool: return reduce(gcd, Counter(deck).values())\u003e1 36 ms ","date":"2018-09-26","objectID":"/leetcode/0914/:3:0","tags":null,"title":"0914：卡牌分组（★）","uri":"/leetcode/0914/"},{"categories":null,"content":"题目 给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。 例如，如果 digits = [‘1’,‘3’,‘5’]，我们可以写数字，如 ‘13’, ‘551’, 和 ‘1351315’。 返回 可以生成的小于或等于给定整数 n 的正整数的个数 。 示例 1： 输入：digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\r输出：20\r解释：\r可写出的 20 个数字是：\r1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\r示例 ","date":"2018-07-17","objectID":"/leetcode/0902/:1:0","tags":null,"title":"0902：最大为 N 的数字组合（★★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"分析 ","date":"2018-07-17","objectID":"/leetcode/0902/:2:0","tags":null,"title":"0902：最大为 N 的数字组合（★★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"#1 求范围内数字满足某种性质的个数，容易想到用数位 dp，令 dfs(pos, state, bound) 代表某个状态下的结果： 遍历到 n 的第 pos 位 state 代表前面是否取了数 bound 代表前面取的数是否贴着 n 的上界 即可递归。 特别注意，“什么也不取”也被计算了，最后需要减去。 def atMostNGivenDigitSet(self, digits: List[str], n: int) -\u003e int: @lru_cache(None) def dfs(pos, state, bound): if pos==len(s): return 1 res, cur =","date":"2018-07-17","objectID":"/leetcode/0902/:2:1","tags":null,"title":"0902：最大为 N 的数字组合（★★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"#2 也可以利用排列组合知识直接分段计算。例如对于 n=7382，digits=[“1”,“3”,“5”,“7”]： [0, 1000) 的对应个数：4+4^2+4^3 [1000, 7000) 的对应个数：3*4^3 [7000, 7300) 的对应个数：1*4^2 [7300, 7380) 的对应个数：4*4 [7380, 7382) 的对应个数：0 具体实现时，假设 s=str(n) 的长度为 m： 先计算 0-10^(m-1) 的对应个数 然后遍历 i，在 s[:i] 不变的情况下，求 s[i] 能取的值，即 digits 中比 s[i] 小的值， 然后求 s[i+1:] 的可能排列个","date":"2018-07-17","objectID":"/leetcode/0902/:2:2","tags":null,"title":"0902：最大为 N 的数字组合（★★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"解答 def atMostNGivenDigitSet(self, digits: List[str], n: int) -\u003e int: s = str(n+1) m, k = len(s), len(digits) res = (k**m-k)//(k-1) if k\u003e1 else k*(m-1) for i, cur in enumerate(s): cand = [x for x in digits if x\u003ccur] res += len(cand)*pow(k, m-1-i) if cur not in digits: break return res 40 ms ","date":"2018-07-17","objectID":"/leetcode/0902/:3:0","tags":null,"title":"0902：最大为 N 的数字组合（★★★）","uri":"/leetcode/0902/"},{"categories":null,"content":"以1990年代为背景，描述热衷于格斗游戏的小学生“矢口春雄”，某次在电玩店与女主角“大野晶”因互相较量\n《街头霸王2》而认识。故事中除了街机文化之外，也有恋爱要素。由于身份上的差距，毫无交集的春雄和晶，偶然发现有着共同兴趣，\n原本只是互相切磋技术的好对手，不知不觉间，两人的关系开始有了变化……","date":"2018-07-13","objectID":"/anime/hi_score_girl/","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"简介 以1990年代为背景，描述热衷于格斗游戏的小学生“矢口春雄”，某次在电玩店与女主角“大野晶”因互相较量 《街头霸王2》而认识。故事中除了街机文化之外，也有恋爱要素。由于身份上的差距，毫无交集的春雄和晶，偶然发现有着共同兴趣， 原本只是互相切磋技术的好对手，不知不觉间，两人的关系开始有了变化…… 制作人员： 原作：押切莲介 导演：山川吉树 脚本：浦畑达彦、石野敦夫、富田赖子 分镜：松井仁之、佐山圣子 演出：樱美胜志 ","date":"2018-07-13","objectID":"/anime/hi_score_girl/:1:0","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 矢口春雄 矢口 春雄、やぐち はるお、Yaguchi Haruo 男 天﨑滉平 2 大野晶 大野 晶、おおの あきら、Oono Akira 女 鈴代紗弓 3 日高小春 日高 小春、ひだか こはる、Hidaka Koharu 女 広瀬ゆうき 4 大野真 Ono Makoto 女 赤﨑千夏 5 宫尾光太郎 Kataro Miyao 男 興津和幸 6 土井玄太 Genta Ooi 男 山下大輝 7 业田萌美 Goda Moemi 女 伊藤静 8 爷爷 Ziiya 男 チョー ","date":"2018-07-13","objectID":"/anime/hi_score_girl/:2:0","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 高分少女 2018-07-13 12 樱花 2 高分少女 EXTRA STAGE 2019-03-20 3 樱花 3 高分少女 第二季 2019-10-25 9 bilibili ","date":"2018-07-13","objectID":"/anime/hi_score_girl/:3:0","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"MAD ","date":"2018-07-13","objectID":"/anime/hi_score_girl/:4:0","tags":null,"title":"高分少女","uri":"/anime/hi_score_girl/"},{"categories":null,"content":"“舞台少女”——那是以未来的舞台女演员为目标，光芒四溢的少女们。\n\n某天，她们收到了一封邮件。“请去取得吧　你所希望的那颗星”为了摘取闪耀的星星，而聚集于选拔会场的9名舞台少女。\n\n追求光芒的心意、执着、命运——在舞台上交错。\n\n现在，正是拉开Revue的序幕之时。","date":"2018-07-12","objectID":"/anime/revue_starlight/","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":"简介 “舞台少女”——那是以未来的舞台女演员为目标，光芒四溢的少女们。 某天，她们收到了一封邮件。“请去取得吧　你所希望的那颗星”为了摘取闪耀的星星，而聚集于选拔会场的9名舞台少女。 追求光芒的心意、执着、命运——在舞台上交错。 现在，正是拉开Revue的序幕之时。 制作人员： 原作：Bushiroad、KINEMA CITRUS 导演：古川知宏 脚本：樋口达人 分镜：光田史亮、小出卓史、佐伯昭志、黑田结花 ","date":"2018-07-12","objectID":"/anime/revue_starlight/:1:0","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 爱城华恋 愛城 華恋、あいじょう かれん、Karen Aijo 女 小山百代 2 神乐光 神楽 ひかり、かぐら ひかり、Hikari Kagura 女 三森すずこ 3 天堂真矢 天堂 真矢、てんどう まや、Maya Tendo 女 富田麻帆 4 星见纯那 星見 純那、ほしみ じゅんな、Junna Hoshimi 女 佐藤日向 5 露崎真昼 露崎 まひる、つゆざき まひる、Mahiru Tsuyuzaki 女 岩田陽葵 6 大场奈奈 大場 なな、だいば なな、Daiba Nana、ばなな，バナナ 女 小泉萌香 7 西条克洛迪娜 西條 クロディーヌ、さいじょう ","date":"2018-07-12","objectID":"/anime/revue_starlight/:2:0","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 少女☆歌剧 Revue Starlight 2018-07-12 12 bilibili 2 剧场版 少女☆歌剧 Revue Starlight 2021-06-04 1 樱花 ","date":"2018-07-12","objectID":"/anime/revue_starlight/:3:0","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":"MAD ","date":"2018-07-12","objectID":"/anime/revue_starlight/:4:0","tags":null,"title":"少女☆歌剧 Revue Starlight","uri":"/anime/revue_starlight/"},{"categories":null,"content":"生在日本长在日本、完全不会说英语的金发美少女·奥莉薇，性格认真、知性洋溢、完全不会说英语的短发眼镜娘·香纯，以及虽然性格开朗却无法成为现充的下双马尾少女·华子，三名初中女生创造出来的是“游戏研究会”！？超级可爱有趣、令人捧腹绝倒的JC女生喜剧现在开幕！","date":"2018-07-08","objectID":"/anime/asobi_asobase/","tags":null,"title":"来玩游戏吧","uri":"/anime/asobi_asobase/"},{"categories":null,"content":"简介 生在日本长在日本、完全不会说英语的金发美少女·奥莉薇，性格认真、知性洋溢、完全不会说英语的短发眼镜娘·香纯，以及虽然性格开朗却无法成为现充的下双马尾少女·华子，三名初中女生创造出来的是“游戏研究会”！？超级可爱有趣、令人捧腹绝倒的JC女生喜剧现在开幕！ 制作人员： 原作：凉川铃 导演：岸诚二 脚本：柿原优子 分镜：濑村俊一郎、木野目优 演出：滨田将太、铃木芳成、大矢雄嗣、真野玲 ","date":"2018-07-08","objectID":"/anime/asobi_asobase/:1:0","tags":null,"title":"来玩游戏吧","uri":"/anime/asobi_asobase/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 本田华子 ほんだ はなこ、Honda Hanako 女 木野日菜 2 奥莉薇 Olivia 女 長江里加 3 野村香纯 のむら かすみ、Nomura Kasumi 女 小原好美 4 前多 まえだ、Maeda 男 置鮎龍太郎 5 学生会长 女 井上ほの花 6 冈露 おか るう、Oka Ruu、岡さん 女 金澤まい 7 阿格里帕 间桐安栗、間桐 あぐり、まとう あぐり、Matō Aguri 女 戸田めぐみ 8 青空鸫 あおぞら つぐみ、Aozora Tsugumi 悠木碧 ","date":"2018-07-08","objectID":"/anime/asobi_asobase/:2:0","tags":null,"title":"来玩游戏吧","uri":"/anime/asobi_asobase/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 来玩游戏吧 2018-07-08 12 樱花 ","date":"2018-07-08","objectID":"/anime/asobi_asobase/:3:0","tags":null,"title":"来玩游戏吧","uri":"/anime/asobi_asobase/"},{"categories":null,"content":"题目 给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链， 每条边之间的新节点数各不相同。 图用由边组成的二维数组 edges 表示，其中 edges[i] = [ui, vi, cnti] 表示原始图中节点 ui 和 vi 之间存在一条边， cnti 是将边 细分 后的新节点总数。注意，cnti == 0 表示边不可细分。 要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti 个新节点。新节点为 x1, x2, …, xcnti ， 新边为 [ui, x1], [x1, x2], [x2","date":"2018-06-27","objectID":"/leetcode/0882/:1:0","tags":null,"title":"0882：细分图中的可到达结点（★★★）","uri":"/leetcode/0882/"},{"categories":null,"content":"分析 将 cnt+1 条新边看作是原边的权重，那么可以用 dijkstra 计算出每个原节点到 0 的距离。 原节点距离不超过 maxMoves 即可倒达，新的细分节点则可以根据最近的原节点来判断。 ","date":"2018-06-27","objectID":"/leetcode/0882/:2:0","tags":null,"title":"0882：细分图中的可到达结点（★★★）","uri":"/leetcode/0882/"},{"categories":null,"content":"解答 def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -\u003e int: nxt = defaultdict(list) for u, v, cnt in edges: nxt[u].append((v, cnt+1)) nxt[v].append((u, cnt+1)) d, pq = defaultdict(lambda: float('inf')), [(0, 0)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, ","date":"2018-06-27","objectID":"/leetcode/0882/:3:0","tags":null,"title":"0882：细分图中的可到达结点（★★★）","uri":"/leetcode/0882/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-06-21","objectID":"/leetcode/0876/:0:0","tags":null,"title":"0876：链表的中间结点（★）","uri":"/leetcode/0876/"},{"categories":null,"content":"题目 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 提示：给定链表的结点数介于 1 和 100 之间。 示例 1： 输入：[1,2,3,4,5]\r输出：此列表中的结点 3 (序列化形式：[3,4,5])\r返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\r注意，我们返回了一个 ListNode 类型的对象 ans，这样：\rans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\r示例 2： 输入：[1","date":"2018-06-21","objectID":"/leetcode/0876/:1:0","tags":null,"title":"0876：链表的中间结点（★）","uri":"/leetcode/0876/"},{"categories":null,"content":"分析 ","date":"2018-06-21","objectID":"/leetcode/0876/:2:0","tags":null,"title":"0876：链表的中间结点（★）","uri":"/leetcode/0876/"},{"categories":null,"content":"#1 最简单的就是先遍历得到链表长度 n，然后从序号 n//2 的节点即为所求。 def middleNode(self, head: ListNode) -\u003e ListNode: n, p = 0, head while p: p = p.next n += 1 for _ in range(n//2): head = head.next return head 40 ms ","date":"2018-06-21","objectID":"/leetcode/0876/:2:1","tags":null,"title":"0876：链表的中间结点（★）","uri":"/leetcode/0876/"},{"categories":null,"content":"#2 还有个巧妙的想法，可以用两个指针同时从 head 出发，每轮一个指针移动两步，另一个指针移动一步。 当快指针越界时，慢指针即为所求。 这就是链表中经典的快慢指针法。 ","date":"2018-06-21","objectID":"/leetcode/0876/:2:2","tags":null,"title":"0876：链表的中间结点（★）","uri":"/leetcode/0876/"},{"categories":null,"content":"解答 def middleNode(self, head: ListNode) -\u003e ListNode: slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next return slow 36 ms ","date":"2018-06-21","objectID":"/leetcode/0876/:3:0","tags":null,"title":"0876：链表的中间结点（★）","uri":"/leetcode/0876/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-06-11","objectID":"/leetcode/0866/:0:0","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"题目 求出大于或等于 N 的最小回文素数。 回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是素数。 例如，2，3，5，7，11 以及 13 是素数。 回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是回文数。 例如，12321 是回文数。 $1 \u003c= N \u003c= 10^8$。答案肯定存在，且小于 $2 * 10^8$。 示例 1： 输入：6\r输出：7\r示例 2： 输入：8\r输出：11\r示例 3： 输入：13\r输出：101\r","date":"2018-06-11","objectID":"/leetcode/0866/:1:0","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"分析 ","date":"2018-06-11","objectID":"/leetcode/0866/:2:0","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"#1 有点类似 0564 ，可以基于某数并镜像的方法得到回文数，例如 10 镜像后得到两个回文数 101、1001。 而长度为 L 的回文数也必然可以基于前 (L+1)//2 个数字镜像得到，把它称作 L 的回文根。 因此，只要遍历回文根从 1 到 $10^5$，就可以得到所有从 1 到 $10^9$ 的回文数。 注意遍历顺序和两种镜像方式的顺序，即可从小到大得到回文数。具体为： 先从 1 位回文根通过两种镜像方式依次得到 1 位、2 位回文数\r再从 2 位回文根通过两种镜像方式依次得到 3 位、4 位回文数\r依此类推\r再判断是否 \u003e= N 且是质数即可。 def primePalindrom","date":"2018-06-11","objectID":"/leetcode/0866/:2:1","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"#2 还有个巧妙的优化。可以证明偶数位回文数必然是 11 的倍数。 首先证明 一个数是 11 的倍数 等价于 奇位数字之和与偶位数字之和的差是 11 的倍数。 设一个数 x 表示为 $\\overline{…a_5 a_4 a_3 a_2 a_1}$，那么： $$x = a_1 + 10 * a_2 + 100 * a_3 + 1000 * a_4 + 10000 * a_5 + … $$ $$x = a_1 + (11-1) * a_2 + (99+1) * a_3 + (1001-1) * a_4 + (9999+1) * a_5 + … $$ $$x = (a_1 - a_2 + a_3 ","date":"2018-06-11","objectID":"/leetcode/0866/:2:2","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"解答 def primePalindrome(self, N): def is_prime(n): return n \u003e= 2 and all(n%i for i in range(2, int(n**0.5) + 1)) if 8\u003c=N\u003c=11: return 11 L = len(str(N)) h = int(str(N)[:(L+1)//2]) for half in range(h, 10**6): n = int(str(half) + str(half)[-2::-1]) if n \u003e= N and is_prime(n): return n 56 ms ","date":"2018-06-11","objectID":"/leetcode/0866/:3:0","tags":null,"title":"0866：回文素数（★★）","uri":"/leetcode/0866/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ， 并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。 子数组 是数组中 连续 的一部分。 示例 1： 输入：nums = [1], k = 1\r输出：1\r示例 2： 输入：nums = [1,2], k = 4\r输出：-1\r示例 3： 输入：nums = [2,-1,2], k = 3\r输出：3\r提示： 1 \u003c= nums.length \u003c= 10^5 -10^5 \u003c= nums[i] \u003c= 10^5 1 \u003c= k \u003c= 10^9 ","date":"2018-06-07","objectID":"/leetcode/0862/:1:0","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"分析 ","date":"2018-06-07","objectID":"/leetcode/0862/:2:0","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"#1 涉及到子数组的和，首先想到前缀和。得到前缀和数组 pre 后，问题转为： 求最小的 j-i 使得 pre[i]\u003c=pre[j]-K。 暴力法就是遍历位置 j，在 pre[:j] 中找最大的满足要求的 i。 注意到如果 x \u003c y 且 pre[x] \u003e= pre[y]，那么 y 比 x 更优，在后面的遍历中都可以排除 x。 因此可以维护一个严格递增的栈 stack，保存有用的位置和值。 然后就可以二分查找最大的 i 了。 def shortestSubarray(self, nums: List[int], k: int) -\u003e int: pre = list(accumulate([0]","date":"2018-06-07","objectID":"/leetcode/0862/:2:1","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"#2 还有个巧妙的想法。对于栈中的 i，当遍历到第一个 j 使得 pre[i]\u003c=pre[j]-K，那么以 i 开头的最短子数组就是 pre[i:j+1]，可以弹出 i 并更新结果。 因此，可以维护一个单调队列。 ","date":"2018-06-07","objectID":"/leetcode/0862/:2:2","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"解答 def shortestSubarray(self, nums: List[int], k: int) -\u003e int: pre = list(accumulate([0]+nums)) res, queue = float('inf'), deque() for j,x in enumerate(pre): while queue and queue[-1][0]\u003e=x: queue.pop() while queue and queue[0][0]\u003c=x-k: res = min(res, j-queue.popleft()[1]) queue.append((x, j)) retur","date":"2018-06-07","objectID":"/leetcode/0862/:3:0","tags":null,"title":"0862：和至少为 K 的最短子数组（★★★）","uri":"/leetcode/0862/"},{"categories":null,"content":"题目 有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。 为了方便起见，我们将编号为 x 的人简称为 “person x “。 给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。 另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自洽 （也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更","date":"2018-05-27","objectID":"/leetcode/0851/:1:0","tags":null,"title":"0851：喧闹和富有（★★）","uri":"/leetcode/0851/"},{"categories":null,"content":"分析 将人看作顶点，richer 看作边，显然是一个有向无环图，因此可以直接递归。 ","date":"2018-05-27","objectID":"/leetcode/0851/:2:0","tags":null,"title":"0851：喧闹和富有（★★）","uri":"/leetcode/0851/"},{"categories":null,"content":"解答 def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -\u003e List[int]: @lru_cache(None) def dfs(u): return min([dfs(v) for v in nxt[u]]+[u], key=quiet.__getitem__) nxt = defaultdict(list) for v, u in richer: nxt[u].append(v) return [dfs(i) for i in range(len(quiet))] 72 ms ","date":"2018-05-27","objectID":"/leetcode/0851/:3:0","tags":null,"title":"0851：喧闹和富有（★★）","uri":"/leetcode/0851/"},{"categories":null,"content":"题目 我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle[i] = [x1, y1, x2, y2]， 其中（x1，y1）是矩形 i 左下角的坐标， (xi1, yi1) 是该矩形 左下角 的坐标， (xi2, yi2) 是该矩形 右上角 的坐标。 计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。 返回 总面积 。因为答案可能太大，返回 10^9 + 7 的 模 。 示例 1： 输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\r输出：6\r解释：如图所示","date":"2018-05-26","objectID":"/leetcode/0850/:1:0","tags":null,"title":"0850：矩形面积 II（★★★）","uri":"/leetcode/0850/"},{"categories":null,"content":"分析 有点类似 0218，不过遍历坐标 x 时，要维护的不是高度集合，而是区间集合。 每一轮根据当前横坐标 cur_x 、上一轮横坐标 prev_x，上一轮区间集合覆盖的长度 prev_h， 即可计算出 cur_x 和 prev_x 之间覆盖的面积。然后更新 prev_x 和 prev_h 即可。 ","date":"2018-05-26","objectID":"/leetcode/0850/:2:0","tags":null,"title":"0850：矩形面积 II（★★★）","uri":"/leetcode/0850/"},{"categories":null,"content":"解答 def rectangleArea(self, rectangles: List[List[int]]) -\u003e int: def cal(A): res, end = 0, 0 for s, e in A: res += max(end, e) - max(s, end) end = max(end, e) return res from sortedcontainers import SortedList d = defaultdict(list) for x1, y1, x2, y2 in rectangles: d[x1].append((y1, y2, 1)) d[x2].app","date":"2018-05-26","objectID":"/leetcode/0850/:3:0","tags":null,"title":"0850：矩形面积 II（★★★）","uri":"/leetcode/0850/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-05-23","objectID":"/leetcode/0847/:0:0","tags":null,"title":"0847：访问所有节点的最短路径（★★）","uri":"/leetcode/0847/"},{"categories":null,"content":"题目 存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。 给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。 返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。 提示： n == graph.length 1 \u003c= n \u003c= 12 0 \u003c= graph[i].length \u003c n graph[i] 不包含 i 如果 graph[a] 包含 b ，那么 graph[b] 也包含 a 输入的图总是连通图 示例 1： 输入：graph = [[1,2,3]","date":"2018-05-23","objectID":"/leetcode/0847/:1:0","tags":null,"title":"0847：访问所有节点的最短路径（★★）","uri":"/leetcode/0847/"},{"categories":null,"content":"分析 遍历时关心的状态其实是 (节点 u, 访问过的节点集合 s) 二元组。那么类似 0787，可以构造新图。 对于原边 \u003cu, v\u003e，从 (u, s) 到 (u, s|{v}) 连有向边，权重 1。 问题转为在新图中求任意 (u, {u}) 到任意 (v, 所有节点集合) 的最短路。 因为边的权重相等，所以可以用 bfs 解决。具体实现时不需要真的构造出新图。 注意 set 类型不能作为哈希的键，因此考虑用状态压缩来表示节点集合。 ","date":"2018-05-23","objectID":"/leetcode/0847/:2:0","tags":null,"title":"0847：访问所有节点的最短路径（★★）","uri":"/leetcode/0847/"},{"categories":null,"content":"解答 def shortestPathLength(self, graph: List[List[int]]) -\u003e int: n = len(graph) queue = deque([(0, u, 1\u003c\u003cu) for u in range(n)]) vis = {(u, 1\u003c\u003cu) for u in range(n)} while queue: w, u, s = queue.popleft() if s == (1\u003c\u003cn)-1: return w for v in graph[u]: s2 = s|(1\u003c\u003cv) if (v, s2) not in vis: vis.add((v, s2)","date":"2018-05-23","objectID":"/leetcode/0847/:3:0","tags":null,"title":"0847：访问所有节点的最短路径（★★）","uri":"/leetcode/0847/"},{"categories":null,"content":"题目 这是一个 交互式问题 。 我们给出了一个由一些 不同的 单词组成的列表 wordlist ，对于每个 wordlist[i] 长度均为 6 ， 这个列表中的一个单词将被选作 secret 。 你可以调用 Master.guess(word) 来猜单词。你所猜的单词应当是存在于原列表并且由 6 个小写字母组成的类型 string 。 此函数将会返回一个 integer ，表示你的猜测与秘密单词 secret 的准确匹配（值和位置同时匹配）的数目。 此外，如果你的猜测不在给定的单词列表中，它将返回 -1。 对于每个测试用例，你有 10 次机会来猜出这个单词。当所有调用都结束时，如果您对 Ma","date":"2018-05-19","objectID":"/leetcode/0843/:1:0","tags":null,"title":"0843：猜猜这个单词（★★★）","uri":"/leetcode/0843/"},{"categories":null,"content":"分析 ","date":"2018-05-19","objectID":"/leetcode/0843/:2:0","tags":null,"title":"0843：猜猜这个单词（★★★）","uri":"/leetcode/0843/"},{"categories":null,"content":"#1 可以发现任何方法都不能保证在 10 次内一定猜出来，比如 [‘aaaaaa’, ‘bbbbbb’, … ‘zzzzzz’] 26 个单词的列表， 必须要猜 26 次才能保证猜中。 因此只考虑 match=guess(word) 是有用信息的情况。那么可以通过 match 缩小查找范围 words。 比如示例 1 中，若选择了单词 word=‘ccbazz’，那么可以根据 guess(word)=3， 更新 words 为与该单词匹配 3 项的单词列表 [‘acckzz’]。依此类推，直到猜中。 def findSecretWord(self, wordlist: List[str], m","date":"2018-05-19","objectID":"/leetcode/0843/:2:1","tags":null,"title":"0843：猜猜这个单词（★★★）","uri":"/leetcode/0843/"},{"categories":null,"content":"#2 现在每次随机选单词，有时能 AC 有时不能。考虑能否去掉随机。 显然希望每一步得到的 words 范围更小，也就是选择 A 后更新得到的 words 长度最小。 但 match 是未知的，所以只能遍历 match 考虑最坏情形。 ","date":"2018-05-19","objectID":"/leetcode/0843/:2:2","tags":null,"title":"0843：猜猜这个单词（★★★）","uri":"/leetcode/0843/"},{"categories":null,"content":"解答 def findSecretWord(self, wordlist: List[str], master: 'Master') -\u003e None: def cal(A): return max(sum(sum(a==b for a,b in zip(A, B))==i for B in words) for i in range(6)) words = set(wordlist) for _ in range(10): A = min(words, key=cal) match = master.guess(A) if match == 6: return words = [B for B","date":"2018-05-19","objectID":"/leetcode/0843/:3:0","tags":null,"title":"0843：猜猜这个单词（★★★）","uri":"/leetcode/0843/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-05-17","objectID":"/leetcode/0841/:0:0","tags":null,"title":"0841：钥匙和房间（★）","uri":"/leetcode/0841/"},{"categories":null,"content":"题目 有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，…，N-1， 并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]， 每个钥匙 rooms[i][j] 由 [0,1，…，N-1] 中的一个整数表示， 其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。 最初，除 0 号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回 true，否则返回 false。 提示： 1 \u003c= rooms.length \u003c= 1000","date":"2018-05-17","objectID":"/leetcode/0841/:1:0","tags":null,"title":"0841：钥匙和房间（★）","uri":"/leetcode/0841/"},{"categories":null,"content":"分析 房间看作顶点，钥匙看作有向边，问题转为：判断顶点 0 出发能否达到所有顶点。 顶点 0 开始遍历即可。 ","date":"2018-05-17","objectID":"/leetcode/0841/:2:0","tags":null,"title":"0841：钥匙和房间（★）","uri":"/leetcode/0841/"},{"categories":null,"content":"解答 def canVisitAllRooms(self, rooms: List[List[int]]) -\u003e bool: queue, vis = deque([0]), {0} while queue: u = queue.popleft() for v in rooms[u]: if v not in vis: vis.add(v) queue.append(v) return len(vis)==len(rooms) 16 ms ","date":"2018-05-17","objectID":"/leetcode/0841/:3:0","tags":null,"title":"0841：钥匙和房间（★）","uri":"/leetcode/0841/"},{"categories":null,"content":"题目 如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。 如果这两个字符串本身是相等的，那它们也是相似的。 例如，“tars” 和 “rats” 是相似的 (交换 0 与 2 的位置)； “rats” 和 “arts” 也是相似的， 但是 “star” 不与 “tars”，“rats”，或 “arts” 相似。 总之，它们通过相似性形成了两个关联组：{“tars”, “rats”, “arts”} 和 {“star”}。 注意，“tars” 和 “arts” 是在同一组中，即使它们并不相似。形式上，对每个组而言， 要确定一个单词在组中，只","date":"2018-05-15","objectID":"/leetcode/0839/:1:0","tags":null,"title":"0839：相似字符串组（★★）","uri":"/leetcode/0839/"},{"categories":null,"content":"分析 典型的并查集应用。将相似的字符串连通，分到一组，最后统计有多少组即可。 ","date":"2018-05-15","objectID":"/leetcode/0839/:2:0","tags":null,"title":"0839：相似字符串组（★★）","uri":"/leetcode/0839/"},{"categories":null,"content":"解答 def numSimilarGroups(self, strs: List[str]) -\u003e int: def find(i): if p[i] != i: p[i] = find(p[i]) return p[i] def union(i, j): p[find(i)] = find(j) def is_sim(s1, s2): cnt = 0 for x, y in zip(s1, s2): cnt += (x != y) if cnt \u003e 2: return False return True n = len(strs) p = list(range(n)) for i in ra","date":"2018-05-15","objectID":"/leetcode/0839/:3:0","tags":null,"title":"0839：相似字符串组（★★）","uri":"/leetcode/0839/"},{"categories":null,"content":" 第 84 场周赛第 3 题 ","date":"2018-05-13","objectID":"/leetcode/0835/:0:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":"题目 给你两个图像 img1 和 img2 ，两个图像的大小都是 n x n ，用大小相同的二维正方形矩阵表示。 （并且为二进制矩阵，只包含若干 0 和若干 1 ） 转换其中一个图像，向左，右，上，或下滑动任何数量的单位，并把它放在另一个图像的上面。 之后，该转换的 重叠 是指两个图像都具有 1 的位置的数目。 （请注意，转换 不包括 向任何方向旋转。） 最大可能的重叠是多少？ 提示： n == img1.length n == img1[i].length n == img2.length n == img2[i].length 1 \u003c= n \u003c= 30 img1[i][j] 为 0 或 1","date":"2018-05-13","objectID":"/leetcode/0835/:1:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":"分析 数据范围较小，考虑暴力遍历。 令 x 代表 img1 水平滑动的单位，y 代表 img1 竖直滑动的单位，范围都是 [-(n-1), n-1]。 遍历 \u003cx, y\u003e，求重叠的 1 的数目即可。 ","date":"2018-05-13","objectID":"/leetcode/0835/:2:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":"解答 def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -\u003e int: def cal(x, y): return sum(0\u003c=i+x\u003cn and 0\u003c=j+y\u003cn and img2[i+x][j+y]==1 for i, j in points) n = len(img1) points = [(i, j) for i in range(n) for j in range(n) if img1[i][j]] return max(cal(x, y) for x in range(-n+1, n) f","date":"2018-05-13","objectID":"/leetcode/0835/:3:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":"*附加 还可以用另一种方式计算重叠的 1 的数目：将重叠部分对应的两个数相乘，并全部求和。 这其实就类似于卷积，因此调用 scipy.signal.correlate2d 即可求出每种滑动方式对应的重叠的 1 的数目。 def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -\u003e int: from scipy.signal import correlate2d return int(correlate2d(img1, img2).max()) 284 ms ","date":"2018-05-13","objectID":"/leetcode/0835/:4:0","tags":null,"title":"0835：图像重叠（★★）","uri":"/leetcode/0835/"},{"categories":null,"content":" 第 84 场周赛第 4 题 ","date":"2018-05-13","objectID":"/leetcode/0834/:0:0","tags":null,"title":"0834：树中距离之和（★★★）","uri":"/leetcode/0834/"},{"categories":null,"content":"题目 给定一个无向、连通的树。树中有 N 个标记为 0…N-1 的节点以及 N-1 条边 。 第 i 条边连接节点 edges[i][0] 和 edges[i][1] 。 返回一个表示节点 i 与其他所有节点距离之和的列表 ans。 说明: 1 \u003c= N \u003c= 10000 示例 1: 输入: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\r输出: [8,12,6,10,10,10]\r解释: 如下为给定的树的示意图：\r0\r/ \\\r1 2\r/|\\\r3 4 5\r我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dis","date":"2018-05-13","objectID":"/leetcode/0834/:1:0","tags":null,"title":"0834：树中距离之和（★★★）","uri":"/leetcode/0834/"},{"categories":null,"content":"分析 为了方便，考虑节点 0 为根的树形式。显然相邻节点对应的答案有很大联系，考虑递推。 若 u 是 v 的父节点，那么对于任意 v 的子节点 x（包括 v），dist(v,x)=dist(u,x)-1。 对于其它节点 x （包括 u），dist(v,x)=dist(u,x)+1。 因此令 cnt[v] 代表 v 的子节点个数，则 ans[v]=ans[u]-cnt[v]+(n-cnt[v])。 那么先一遍 dfs 从下往上求出 ans[0] 和 cnt 数组，再一遍 dfs 从上往下即可求出 ans 数组。 ","date":"2018-05-13","objectID":"/leetcode/0834/:2:0","tags":null,"title":"0834：树中距离之和（★★★）","uri":"/leetcode/0834/"},{"categories":null,"content":"解答 def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -\u003e List[int]: def dfs1(u, f): for v in nxt[u]: if v != f: dfs1(v, u) ans[u] += ans[v] + cnt[v] cnt[u] += cnt[v] def dfs2(u, f): for v in nxt[u]: if v != f: ans[v] = ans[u] + n - 2 * cnt[v] dfs2(v, u) nxt = defaultdict(list) for u, v i","date":"2018-05-13","objectID":"/leetcode/0834/:3:0","tags":null,"title":"0834：树中距离之和（★★★）","uri":"/leetcode/0834/"},{"categories":null,"content":" 第 84 场周赛第 2 题 ","date":"2018-05-13","objectID":"/leetcode/0833/:0:0","tags":null,"title":"0833：字符串中的查找与替换（★）","uri":"/leetcode/0833/"},{"categories":null,"content":"题目 某个字符串 S 需要执行一些替换操作，用新的字母组替换原有的字母组（不一定大小相同）。 每个替换操作具有 3 个参数：起始索引 i，源字 x 和目标字 y。规则是：如果 x 从原始字符串 S 中的位置 i 开始， 那么就用 y 替换出现的 x。如果没有，则什么都不做。 举个例子，如果 S = “abcd” 并且替换操作 i = 2，x = “cd”，y = “ffff”， 那么因为 “cd” 从原始字符串 S 中的位置 2 开始，所以用 “ffff” 替换它。 再来看 S = “abcd” 上的另一个例子，如果一个替换操作 i = 0，x = “ab”，y = “eee”， 以及另一个替","date":"2018-05-13","objectID":"/leetcode/0833/:1:0","tags":null,"title":"0833：字符串中的查找与替换（★）","uri":"/leetcode/0833/"},{"categories":null,"content":"分析 为了使替换操作互不干扰，考虑按索引逆序来替换。 ","date":"2018-05-13","objectID":"/leetcode/0833/:2:0","tags":null,"title":"0833：字符串中的查找与替换（★）","uri":"/leetcode/0833/"},{"categories":null,"content":"解答 def findReplaceString(self, s: str, indices: List[int], sources: List[str], targets: List[str]) -\u003e str: s = list(s) for idx, x, y in sorted(zip(indices, sources, targets), reverse=True): if s[idx:idx+len(x)]==list(x): s[idx:idx+len(x)] = list(y) return ''.join(s) 36 ms ","date":"2018-05-13","objectID":"/leetcode/0833/:3:0","tags":null,"title":"0833：字符串中的查找与替换（★）","uri":"/leetcode/0833/"},{"categories":null,"content":" 第 84 场周赛第 1 题 ","date":"2018-05-13","objectID":"/leetcode/0832/:0:0","tags":null,"title":"0832：翻转图像（★）","uri":"/leetcode/0832/"},{"categories":null,"content":"题目 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。 例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。 例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 提示： 1 \u003c= A.length = A[0].length \u003c= 20 0 \u003c= A[i][j] \u003c= 1 示例 1： 输入：[[1,1,0],[1,0,1],[0,0,0]]\r输出：[[1,0,0],[0,1,0],[1,1,1]]\r解释：首先翻转每一行: ","date":"2018-05-13","objectID":"/leetcode/0832/:1:0","tags":null,"title":"0832：翻转图像（★）","uri":"/leetcode/0832/"},{"categories":null,"content":"分析 每行逆序后再将每个元素与 1 异或即可。 ","date":"2018-05-13","objectID":"/leetcode/0832/:2:0","tags":null,"title":"0832：翻转图像（★）","uri":"/leetcode/0832/"},{"categories":null,"content":"解答 def flipAndInvertImage(self, image: List[List[int]]) -\u003e List[List[int]]: return [[val^1 for val in row[::-1]] for row in image] 28 ms ","date":"2018-05-13","objectID":"/leetcode/0832/:3:0","tags":null,"title":"0832：翻转图像（★）","uri":"/leetcode/0832/"},{"categories":null,"content":" 第 83 场周赛第 2 题 ","date":"2018-05-06","objectID":"/leetcode/0831/:0:0","tags":null,"title":"0831：隐藏个人信息（★）","uri":"/leetcode/0831/"},{"categories":null,"content":"题目 给你一条个人信息字符串 S，它可能是一个 邮箱地址 ，也可能是一串 电话号码 。 我们将隐藏它的隐私信息，通过如下规则: 电子邮箱 定义名称 name 是长度大于等于 2 （length ≥ 2），并且只包含小写字母 a-z 和大写字母 A-Z 的字符串。 电子邮箱地址由名称 name 开头，紧接着是符号 ‘@’，后面接着一个名称 name ，再接着一个点号 ‘.’，然后是一个名称 name。 电子邮箱地址确定为有效的，并且格式是 \"name1@name2.name3\"。 为了隐藏电子邮箱，所有的名称 name 必须被转换成小写的，并且第一个名称 name 的第一个字母和 最后一个字母的","date":"2018-05-06","objectID":"/leetcode/0831/:1:0","tags":null,"title":"0831：隐藏个人信息（★）","uri":"/leetcode/0831/"},{"categories":null,"content":"分析 邮箱转为小写再转换 ‘@’ 前的名字即可。电话号码则根据长度判断是否包含国际号码，分类转换即可。 ","date":"2018-05-06","objectID":"/leetcode/0831/:2:0","tags":null,"title":"0831：隐藏个人信息（★）","uri":"/leetcode/0831/"},{"categories":null,"content":"解答 def maskPII(self, s: str) -\u003e str: if '@' in s: name1, suf = s.lower().split('@') return name1[0]+'*'*5+name1[-1]+'@'+suf s = re.sub('[-+() ]', '', s) n = len(s) return ('+'+'*'*(n-10)+'-')*int(n\u003e10)+'***-***-'+s[-4:] 28 ms ","date":"2018-05-06","objectID":"/leetcode/0831/:3:0","tags":null,"title":"0831：隐藏个人信息（★）","uri":"/leetcode/0831/"},{"categories":null,"content":" 第 83 场周赛第 1 题 ","date":"2018-05-06","objectID":"/leetcode/0830/:0:0","tags":null,"title":"0830：较大分组的位置（★）","uri":"/leetcode/0830/"},{"categories":null,"content":"题目 在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。 分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。 上例中的 “xxxx” 分组用区间表示为 [3,6] 。 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。 提示： 1 \u003c= s.length \u003c= 1000 s 仅含小写英文","date":"2018-05-06","objectID":"/leetcode/0830/:1:0","tags":null,"title":"0830：较大分组的位置（★）","uri":"/leetcode/0830/"},{"categories":null,"content":"分析 遍历得到每一段，若长度大于等于 3 就将区间添加到结果即可。 ","date":"2018-05-06","objectID":"/leetcode/0830/:2:0","tags":null,"title":"0830：较大分组的位置（★）","uri":"/leetcode/0830/"},{"categories":null,"content":"解答 def largeGroupPositions(self, s: str) -\u003e List[List[int]]: res, i = [], 0 for j in range(len(s)): if j == len(s)-1 or s[j] != s[j+1]: if j - i \u003e= 2: res.append([i, j]) i = j+1 return res 40 ms ","date":"2018-05-06","objectID":"/leetcode/0830/:3:0","tags":null,"title":"0830：较大分组的位置（★）","uri":"/leetcode/0830/"},{"categories":null,"content":" 第 83 场周赛第 3 题 ","date":"2018-05-06","objectID":"/leetcode/0829/:0:0","tags":null,"title":"0829：连续整数求和（★★）","uri":"/leetcode/0829/"},{"categories":null,"content":"题目 定一个正整数 N，试求有多少组连续正整数满足所有数字之和为 N? 说明: 1 \u003c= N \u003c= 10 ^ 9 示例 1: 输入: 5\r输出: 2\r解释: 5 = 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。\r示例 2: 输入: 9\r输出: 3\r解释: 9 = 9 = 4 + 5 = 2 + 3 + 4\r示例 3: 输入: 15\r输出: 4\r解释: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\r","date":"2018-05-06","objectID":"/leetcode/0829/:1:0","tags":null,"title":"0829：连续整数求和（★★）","uri":"/leetcode/0829/"},{"categories":null,"content":"分析 ","date":"2018-05-06","objectID":"/leetcode/0829/:2:0","tags":null,"title":"0829：连续整数求和（★★）","uri":"/leetcode/0829/"},{"categories":null,"content":"#1 假设某组连续正整数的第一个数是 x，共有 k 个数，那么根据数学的求和公式有： $$ N = \\frac {(x+x+k-1)*k} 2 $$ $$ x = (\\frac {2 * N}k+1-k) / 2 $$ 那么遍历 k，只要对应的 x 是正整数，即得到一组答案。 而显然 k * k\u003c 2 * N，因此 $O(\\sqrt n)$ 时间即可完成遍历。 def consecutiveNumbersSum(self, n: int) -\u003e int: return sum(2 * n % k == 0 and (2 * n // k + 1 - k) % 2 == 0 and (2 * n","date":"2018-05-06","objectID":"/leetcode/0829/:2:1","tags":null,"title":"0829：连续整数求和（★★）","uri":"/leetcode/0829/"},{"categories":null,"content":"#2 公式还可以变形为： $$x = \\frac {N-k*(k-1)/2} k $$ 遍历 k 时，分子增加 1，分母减少 k，判断能否整除即可。 ","date":"2018-05-06","objectID":"/leetcode/0829/:2:2","tags":null,"title":"0829：连续整数求和（★★）","uri":"/leetcode/0829/"},{"categories":null,"content":"解答 def consecutiveNumbersSum(self, n: int) -\u003e int: res, k = 0, 1 while n \u003e 0: res += int(n % k == 0) n -= k k += 1 return res 140 ms ","date":"2018-05-06","objectID":"/leetcode/0829/:3:0","tags":null,"title":"0829：连续整数求和（★★）","uri":"/leetcode/0829/"},{"categories":null,"content":" 第 83 场周赛第 4 题 ","date":"2018-05-06","objectID":"/leetcode/0828/:0:0","tags":null,"title":"0828：统计子串中的唯一字符（★★）","uri":"/leetcode/0828/"},{"categories":null,"content":"题目 我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。 例如：s = “LEETCODE” ，则其中 “L”, “T”,“C”,“O”,“D” 都是唯一字符，因为它们只出现一次， 所以 countUniqueChars(s) = 5 。 本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。 注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串 （也就是说，你必须统计 s 的所有子字符串中的唯一字符）。 由于答案可能非常大，请将结果 mod 1","date":"2018-05-06","objectID":"/leetcode/0828/:1:0","tags":null,"title":"0828：统计子串中的唯一字符（★★）","uri":"/leetcode/0828/"},{"categories":null,"content":"分析 可以对每个字符统计其作为唯一字符的次数。 令 left[i] 代表 s[i] 上一次出现的位置，right[i] 代表 s[i] 下一次出现的位置。 显然对于 [left[i], right[i]] 范围内包含 s[i] 的子串，s[i] 都是唯一字符。 这样的子串个数即为 (i-left[i])*(right[i]-i)。 借助哈希表可以一趟得到所有的 left[i] 和 right[i]。 ","date":"2018-05-06","objectID":"/leetcode/0828/:2:0","tags":null,"title":"0828：统计子串中的唯一字符（★★）","uri":"/leetcode/0828/"},{"categories":null,"content":"解答 def uniqueLetterString(self, s: str) -\u003e int: n = len(s) left, right = [-1]*n, [n]*n d = {} for i, char in enumerate(s): if char in d: j = d[char] left[i] = j right[j] = i d[char] = i res, mod = 0, 10**9+7 for i in range(n): res += (i-left[i])*(right[i]-i) res %= mod return res 236 ms ","date":"2018-05-06","objectID":"/leetcode/0828/:3:0","tags":null,"title":"0828：统计子串中的唯一字符（★★）","uri":"/leetcode/0828/"},{"categories":null,"content":"题目 给出一个含有不重复整数元素的数组 arr ，每个整数 arr[i] 均大于 1。 用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。 满足条件的二叉树一共有多少个？答案可能很大，返回 对 10^9 + 7 取余 的结果。 示例 1: 输入: arr = [2, 4]\r输出: 3\r解释: 可以得到这些二叉树: [2], [4], [4, 2, 2]\r示例 2: 输入: arr = [2, 4, 5, 10]\r输出: 7\r解释: 可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], ","date":"2018-04-29","objectID":"/leetcode/0823/:1:0","tags":null,"title":"0823：带因子的二叉树（★★）","uri":"/leetcode/0823/"},{"categories":null,"content":"分析 非叶节点显然大于子节点，于是考虑将 arr 排序，然后遍历 arr[j] 作为根节点的情况。 arr[j] 为根节点，然后遍历前面的 arr[i]，如果 arr[j]/arr[i] 也在 arr 中存在，即可转为递归子问题。 为了方便递归，令 dp[x] 代表根节点值为 x 的二叉树个数。x 的值稀疏，因此用哈希表存储。 ","date":"2018-04-29","objectID":"/leetcode/0823/:2:0","tags":null,"title":"0823：带因子的二叉树（★★）","uri":"/leetcode/0823/"},{"categories":null,"content":"解答 def numFactoredBinaryTrees(self, arr: List[int]) -\u003e int: res, mod = 0, 10**9+7 d = defaultdict(lambda: 1) for x in sorted(arr): for y in list(d): if x%y==0 and x//y in d: d[x] = (d[x]+d[y]*d[x//y])%mod res = (res+d[x])%mod return res 240 ms ","date":"2018-04-29","objectID":"/leetcode/0823/:3:0","tags":null,"title":"0823：带因子的二叉树（★★）","uri":"/leetcode/0823/"},{"categories":null,"content":"在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。他平日是个热爱理发事业的理发师，善用剪刀，而剪刀也是他的刺杀武器——没错，伍六七背地里做着刺客生意。 伍六七是他的经纪人鸡大保从海边“捡”回来的，当时他重伤昏迷，失去了记忆，他的过去成了一个谜。鸡大保根据理发店门牌号给他取了个名字：伍六七。为了维持生计，鸡大保作为他的经纪人，以理发店为据点，替伍六七承接各种刺杀任务。初入刺客行当，伍六七排名靠后，因此接到的都是些奇葩的刺杀任务。在完成任务的过程中，他常与刺杀对象发生一系列有趣可笑的意外事件，每次任务都被搞得乱七八糟。伍六七从来没有成功完成过刺杀任务，但却每次都能意外的化解雇主的仇恨。也正因如此，他没拿到过任何报酬，行情越发低落，只能混迹于刺客行业的底层，生活穷困潦倒。 在这些奇葩任务的执行过程中，他看到了很多人，经历了很多事，开始渐渐的认清自我。伍六七身世之谜也渐渐浮出水面……","date":"2018-04-25","objectID":"/anime/killer_seven/","tags":null,"title":"刺客伍六七","uri":"/anime/killer_seven/"},{"categories":null,"content":"简介 在某个小岛上，有一个可以伪装成任何东西的廉价刺客，名叫伍六七。他平日是个热爱理发事业的理发师，善用剪刀，而剪刀也是他的刺杀武器——没错，伍六七背地里做着刺客生意。 伍六七是他的经纪人鸡大保从海边“捡”回来的，当时他重伤昏迷，失去了记忆，他的过去成了一个谜。鸡大保根据理发店门牌号给他取了个名字：伍六七。为了维持生计，鸡大保作为他的经纪人，以理发店为据点，替伍六七承接各种刺杀任务。初入刺客行当，伍六七排名靠后，因此接到的都是些奇葩的刺杀任务。在完成任务的过程中，他常与刺杀对象发生一系列有趣可笑的意外事件，每次任务都被搞得乱七八糟。伍六七从来没有成功完成过刺杀任务，但却每次都能意外的化解雇主的","date":"2018-04-25","objectID":"/anime/killer_seven/:1:0","tags":null,"title":"刺客伍六七","uri":"/anime/killer_seven/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伍六七 柒 男 何小疯 2 梅花十三 女 段艺璇 3 小飞鸡 鸡小飞 4 江惠莲 江主任 女 刘晓倩 5 可乐 女 朱蓉蓉 6 何大春 男 斑马 ","date":"2018-04-25","objectID":"/anime/killer_seven/:2:0","tags":null,"title":"刺客伍六七","uri":"/anime/killer_seven/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 刺客伍六七 2018-04-25 14 bilibili 2 伍六七之最强发型师 2019-10-23 10 bilibili 3 伍六七之玄武国篇 2021-01-27 10 bilibili ","date":"2018-04-25","objectID":"/anime/killer_seven/:3:0","tags":null,"title":"刺客伍六七","uri":"/anime/killer_seven/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-04-19","objectID":"/leetcode/0813/:0:0","tags":null,"title":"0813：最大平均值和的分组（★★）","uri":"/leetcode/0813/"},{"categories":null,"content":"题目 给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。 注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。 返回我们所能得到的最大 分数 是多少。答案误差在 10^-6 内被视为是正确的。 示例 1: 输入: nums = [9,1,2,3,9], k = 3\r输出: 20.00000\r解释: nums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. 我们也可以把 nums 分成[9, 1","date":"2018-04-19","objectID":"/leetcode/0813/:1:0","tags":null,"title":"0813：最大平均值和的分组（★★）","uri":"/leetcode/0813/"},{"categories":null,"content":"分析 按最后一组的长度即可转为递归子问题。 可以用前缀和优化递推过程。 ","date":"2018-04-19","objectID":"/leetcode/0813/:2:0","tags":null,"title":"0813：最大平均值和的分组（★★）","uri":"/leetcode/0813/"},{"categories":null,"content":"解答 def largestSumOfAverages(self, nums: List[int], k: int) -\u003e float: @lru_cache(None) def dfs(j, k): if j == 0: return 0 if k == 0: return float('-inf') return max((pre[j]-pre[i])/(j-i)+dfs(i, k-1) for i in range(j)) n, pre = len(nums), list(accumulate([0]+nums)) return dfs(n, k) 232 ms ","date":"2018-04-19","objectID":"/leetcode/0813/:3:0","tags":null,"title":"0813：最大平均值和的分组（★★）","uri":"/leetcode/0813/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-04-14","objectID":"/leetcode/0808/:0:0","tags":null,"title":"0808：分汤（★★★）","uri":"/leetcode/0808/"},{"categories":null,"content":"题目 有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作： 提供 100ml 的 汤A 和 0ml 的 汤B 。 提供 75ml 的 汤A 和 25ml 的 汤B 。 提供 50ml 的 汤A 和 50ml 的 汤B 。 提供 25ml 的 汤A 和 75ml 的 汤B 。 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。 如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。 注意 不存在先分配 100 ml 汤B 的操作。 需要返回的值： 汤A 先分配完的概率 + 汤A和汤B","date":"2018-04-14","objectID":"/leetcode/0808/:1:0","tags":null,"title":"0808：分汤（★★★）","uri":"/leetcode/0808/"},{"categories":null,"content":"分析 容易想到用递归，令 dfs(a, b) 代表初始汤 A、B 分别 a、b 毫升时对应的概率，即可递归。 问题在于 n 的范围较大，会超时。观察发现，当 n 够大时，结果会趋近于 1。 于是找到 n=5000 时，结果与 1 的差别不超过 10^-5，所以不需要计算 n\u003e=5000 的情况。 ","date":"2018-04-14","objectID":"/leetcode/0808/:2:0","tags":null,"title":"0808：分汤（★★★）","uri":"/leetcode/0808/"},{"categories":null,"content":"解答 def soupServings(self, n: int) -\u003e float: @lru_cache(None) def dfs(a, b): if a==0 or b==0: return 0.5 if a==b==0 else int(a==0) return sum(dfs(max(0, a-(4-x)*25), max(0, b-x*25)) for x in range(4)) / 4 return dfs(n, n) if n\u003c5000 else 1.0 52 ms ","date":"2018-04-14","objectID":"/leetcode/0808/:3:0","tags":null,"title":"0808：分汤（★★★）","uri":"/leetcode/0808/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-04-11","objectID":"/leetcode/0805/:0:0","tags":null,"title":"0805：数组的均值分割（★★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"题目 给定你一个整数数组 nums 我们要将 nums 数组中的每个元素移动到 A 数组 或者 B 数组中，使得 A 数组和 B 数组不为空， 并且 average(A) == average(B) 。 如果可以完成则返回true ， 否则返回 false 。 注意：对于数组 arr , average(arr) 是 arr 的所有元素除以 arr 长度的和。 示例 1: 输入: nums = [1,2,3,4,5,6,7,8]\r输出: true\r解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。\r示例 2: 输入: nums = [3,1]\r","date":"2018-04-11","objectID":"/leetcode/0805/:1:0","tags":null,"title":"0805：数组的均值分割（★★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"分析 ","date":"2018-04-11","objectID":"/leetcode/0805/:2:0","tags":null,"title":"0805：数组的均值分割（★★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"#1 类似 0416，不过分割条件从和相等变成了平均数相等。 什么情况下两者等价？平均数为 0 的时候。于是有个巧妙的想法： 将 nums 的数都减去平均数得到新数组 A，问题就等价于将 A 分割为和相等的两部分。 注意平均数可能为浮点数，为了精确，可以将 nums 的数都先乘以一个合适的 mul 使得平均数为整数。 转换完成后递推子集和的集合找 0 即可。 注意不能选取整个 A，因此考虑只遍历 A[:-1]，假如没有得到 0，即非真。证明： 假如 A[:-1] 的子集和都不为 0，那么 A[:-1] 的任意真子集 A’ 的和不等于 sum(A[:-1])（因为 A[:-1]-A’ 的和不为 ","date":"2018-04-11","objectID":"/leetcode/0805/:2:1","tags":null,"title":"0805：数组的均值分割（★★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"#2 还可以类似 0416 的状压优化方法，将集合状态压缩为一个数 state，优化递推时间。 这里有个问题是集合中有负数，不能压缩到 state 中。一个巧妙的想法是： 先遍历正数，再遍历负数 那么遇到某个子集和为负数时，必然已经遍历到负数，那么后面不可能变为 0 了，无需保存 所以只维护非负数的集合即可，可以压缩为 state ","date":"2018-04-11","objectID":"/leetcode/0805/:2:2","tags":null,"title":"0805：数组的均值分割（★★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"解答 def splitArraySameAverage(self, nums: List[int]) -\u003e bool: n, s = len(nums), sum(nums) mul = n//gcd(n, s) A = [num*mul-mul*s//n for num in nums] st = 0 for x in sorted(A[:-1], reverse=True): st |= (st|1)\u003c\u003cx if x\u003e=0 else st\u003e\u003e(-x) if st \u0026 1: return True return False 36 ms ","date":"2018-04-11","objectID":"/leetcode/0805/:3:0","tags":null,"title":"0805：数组的均值分割（★★★）","uri":"/leetcode/0805/"},{"categories":null,"content":"*附加 本题还有个经典的优化方法，折半搜索： 先遍历 A 的前半部分 B=A[:n//2]，得到所有子集和的集合 S 如果 S 中没有 0，再遍历 A 的后半部分 C=A[n//2:]，得到所有子集和的集合 S2 如果 S2 中也没有 0，那遍历 S2 中 的 x，判断 -x 是否在 S 中即可。 注意不能选取整个 A，所以不考虑 x=sum(C) 的情况。证明： C 的子集和都不为 0，那么 C 的任意真子集的和不等于 sum(C) 因此 x=sum(C) 必然对应整个 C B 的子集和都不为 0，那么 B 的任意真子集的和不等于 sum(B) 因此 -x=sum(B) 必然对应整个 B d","date":"2018-04-11","objectID":"/leetcode/0805/:4:0","tags":null,"title":"0805：数组的均值分割（★★★）","uri":"/leetcode/0805/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-04-08","objectID":"/leetcode/0802/:0:0","tags":null,"title":"0802：找到最终的安全状态（★★）","uri":"/leetcode/0802/"},{"categories":null,"content":"题目 在有向图中，从某个节点和每个转向处开始出发，沿着图的有向边走。 如果到达的节点是终点（即它没有连出的有向边），则停止。 如果从起始节点出发，最后必然能走到终点，就认为起始节点是 最终安全 的。 更具体地说，对于最终安全的起始节点而言，存在一个自然数 k ，无论选择沿哪条有向边行走 ， 走了不到 k 步后必能停止在一个终点上。 返回一个由图中所有最终安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。 该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。 图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j","date":"2018-04-08","objectID":"/leetcode/0802/:1:0","tags":null,"title":"0802：找到最终的安全状态（★★）","uri":"/leetcode/0802/"},{"categories":null,"content":"分析 安全节点就是不会走到环上的节点。和环有关容易想到拓扑排序，观察发现将边全部反向后，拓扑排序出队的节点即为所求。 ","date":"2018-04-08","objectID":"/leetcode/0802/:2:0","tags":null,"title":"0802：找到最终的安全状态（★★）","uri":"/leetcode/0802/"},{"categories":null,"content":"解答 def eventualSafeNodes(self, graph: List[List[int]]) -\u003e List[int]: n = len(graph) nxt, indeg = defaultdict(list), [0] * n for v in range(n): for u in graph[v]: nxt[u].append(v) indeg[v] += 1 queue = deque(u for u in range(n) if indeg[u] == 0) while queue: u = queue.popleft() for v in nxt[u]: indeg","date":"2018-04-08","objectID":"/leetcode/0802/:3:0","tags":null,"title":"0802：找到最终的安全状态（★★）","uri":"/leetcode/0802/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-04-07","objectID":"/leetcode/0801/:0:0","tags":null,"title":"0801：使序列递增的最小交换次数（★★）","uri":"/leetcode/0801/"},{"categories":null,"content":"题目 我们有两个长度相等且不为空的整型数组 nums1 和 nums2 。在一次操作中， 我们可以交换 nums1[i] 和 nums2[i]的元素。 例如，如果 nums1 = [1,2,3,8] ， nums2 =[5,6,7,4] ，你可以交换 i = 3 处的元素， 得到 nums1 =[1,2,3,4] 和 nums2 =[5,6,7,8] 。 返回 使 nums1 和 nums2 严格递增 所需操作的最小次数 。 数组 arr 严格递增 且 arr[0] \u003c arr[1] \u003c arr[2] \u003c … \u003c arr[arr.length - 1] 。 注意：用例保证可以实现操作。 示例 ","date":"2018-04-07","objectID":"/leetcode/0801/:1:0","tags":null,"title":"0801：使序列递增的最小交换次数（★★）","uri":"/leetcode/0801/"},{"categories":null,"content":"分析 最后一对元素交换/不交换是否有效只与倒数第二对元素的状态有关。 为了方便递推，令： dp[i][0] 代表第 i 对不交换的情况下使前 i 对有效的最小次数 dp[i][1] 代表第 i 对交换的情况下使前 i 对有效的最小次数 即可由 dp[i] 递推得到 dp[i+1]。还可以用滚动数组优化。 ","date":"2018-04-07","objectID":"/leetcode/0801/:2:0","tags":null,"title":"0801：使序列递增的最小交换次数（★★）","uri":"/leetcode/0801/"},{"categories":null,"content":"解答 def minSwap(self, nums1: List[int], nums2: List[int]) -\u003e int: n = len(nums1) a, b = 0, 1 for i in range(1, n): a2 = b2 = float('inf') if nums1[i]\u003enums1[i-1] and nums2[i]\u003enums2[i-1]: a2, b2 = min(a2, a), min(b2, b+1) if nums1[i]\u003enums2[i-1] and nums2[i]\u003enums1[i-1]: a2, b2 = min(a2, b), min(b2, a+1)","date":"2018-04-07","objectID":"/leetcode/0801/:3:0","tags":null,"title":"0801：使序列递增的最小交换次数（★★）","uri":"/leetcode/0801/"},{"categories":null,"content":"支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！\n容易暴走的雏，不论在组里还是在学校都为所欲为。新田为此头痛不已，但由于自己那老好人的性格而陷入总是要照顾她的境地。究竟这种生活会变得怎样呢？\n老好人不法之徒与任性超能力少女的危险而热闹的日常开始了！","date":"2018-04-06","objectID":"/anime/hina_matsuri/","tags":null,"title":"黑社会的超能力女儿","uri":"/anime/hina_matsuri/"},{"categories":null,"content":"简介 支持着芦川组的年轻智力型黑道新田义史，过着被喜欢的壶所包围的悠然自得单身生活。但某一天，随着装在神秘物体里的少女雏来到他家，他的生活为之一变。他被能使用念动力的雏所胁迫，迫不得已开始和她同居！ 容易暴走的雏，不论在组里还是在学校都为所欲为。新田为此头痛不已，但由于自己那老好人的性格而陷入总是要照顾她的境地。究竟这种生活会变得怎样呢？ 老好人不法之徒与任性超能力少女的危险而热闹的日常开始了！ 制作人员： 原作：大武政夫 导演：及川启 脚本：大知庆一郎 演出：平井义通、中田诚、名和宗则、山田晃、佐佐木达也 ","date":"2018-04-06","objectID":"/anime/hina_matsuri/:1:0","tags":null,"title":"黑社会的超能力女儿","uri":"/anime/hina_matsuri/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 新田雏 ヒナ 女 田中貴子 2 新田义史 にった よしふみ、Nitta Yoshifumi 男 中島ヨシキ 3 三岛瞳 みしま ひとみ、Mishima Hitomi 女 本渡楓 4 杏子 Anzu 女 村川梨衣 5 诗子 うたこ、Utako 女 日笠陽子 6 真绪 Mao 女 小澤亜李 7 少主 馬場 清、ばば きよし 男 小山剛志 8 跟班 阿三 男 河西健吾 ","date":"2018-04-06","objectID":"/anime/hina_matsuri/:2:0","tags":null,"title":"黑社会的超能力女儿","uri":"/anime/hina_matsuri/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 黑社会的超能力女儿 2018-04-06 12 bilibili ","date":"2018-04-06","objectID":"/anime/hina_matsuri/:3:0","tags":null,"title":"黑社会的超能力女儿","uri":"/anime/hina_matsuri/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-04-05","objectID":"/leetcode/0799/:0:0","tags":null,"title":"0799：香槟塔（★★）","uri":"/leetcode/0799/"},{"categories":null,"content":"题目 我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层， 每个玻璃杯 (250ml) 将盛有香槟。 从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。 当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上） 例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。 在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，","date":"2018-04-05","objectID":"/leetcode/0799/:1:0","tags":null,"title":"0799：香槟塔（★★）","uri":"/leetcode/0799/"},{"categories":null,"content":"分析 模拟递推即可。 ","date":"2018-04-05","objectID":"/leetcode/0799/:2:0","tags":null,"title":"0799：香槟塔（★★）","uri":"/leetcode/0799/"},{"categories":null,"content":"解答 def champagneTower(self, poured: int, query_row: int, query_glass: int) -\u003e float: dp = [[0]*(i+1) for i in range(query_row+1)] dp[0][0] = poured for i in range(query_row): for j in range(i+1): x = (dp[i][j]-1) / 2 if x\u003e0: dp[i+1][j] += x dp[i+1][j+1] += x return min(1, dp[-1][query_glass]) 108 ms","date":"2018-04-05","objectID":"/leetcode/0799/:3:0","tags":null,"title":"0799：香槟塔（★★）","uri":"/leetcode/0799/"},{"categories":null,"content":"将肉体与“外骨骼技术”融合的究极格斗技——“MEGALO BOX”，将自己的全部赌在上面的男人们的热血战斗开始！\n今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“Junk Dog”。虽然具备实力，却只有靠比赛造假赚钱这一条生存之道，他为自己的“现在”感到心焦。\n但，他与孤高的冠军·勇利相遇，作为MEGALO拳击手，作为男人，向自己的“现在”发起挑战——。 ","date":"2018-04-05","objectID":"/anime/megalo_box/","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":"简介 将肉体与“外骨骼技术”融合的究极格斗技——“MEGALO BOX”，将自己的全部赌在上面的男人们的热血战斗开始！ 今天也立于未认可地区的赌博比赛赛场上的MEGALO拳击手“Junk Dog”。虽然具备实力，却只有靠比赛造假赚钱这一条生存之道，他为自己的“现在”感到心焦。 但，他与孤高的冠军·勇利相遇，作为MEGALO拳击手，作为男人，向自己的“现在”发起挑战——。 制作人员： 导演：森山洋 脚本：真边克彦、小嶋健作 分镜：金井次郎、矢野博之、寺冈岩、佐山圣子、桥口淳一郎 ","date":"2018-04-05","objectID":"/anime/megalo_box/:1:0","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 JNK DOG JOE、NOMAD、Junk Dog、Gearless Joe 男 細谷佳正 2 勇利 Yuri、キング・オブ・キングス(King of Kings) 男 安元洋貴 3 白都有希子 しらと ゆきこ、Shirato Yukiko 女 森なな子 4 南部赝作 なんぶ がんさく、Nanbu Gansaku 男 斎藤志郎 5 荒垣 Aragaki 男 田村真 6 白都树生 しらと みきお、Shirato Mikio 男 鈴木達央 7 桑塔 男 種市桃子 8 奥乔 Oicho 女 内藤有海 ","date":"2018-04-05","objectID":"/anime/megalo_box/:2:0","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 MEGALO BOX 2018-04-05 13 bilibili 2 NOMAD MEGALO BOX 2 2021-04-04 13 bilibili ","date":"2018-04-05","objectID":"/anime/megalo_box/:3:0","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":"MAD ","date":"2018-04-05","objectID":"/anime/megalo_box/:4:0","tags":null,"title":"MEGALO BOX","uri":"/anime/megalo_box/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-04-03","objectID":"/leetcode/0797/:0:0","tags":null,"title":"0797：所有可能的路径（★★）","uri":"/leetcode/0797/"},{"categories":null,"content":"题目 给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序） 二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点 （译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ）空就是没有下一个结点了。 示例 1： 输入：graph = [[1,2],[3],[3],[]]\r输出：[[0,1,3],[0,2,3]]\r解释：有两条路径 0 -\u003e 1 -\u003e 3 和 0 -\u003e 2 -\u003e 3\r示例 2： 输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]\r输出：[[0,4],[0,3,4],[0,1,3,4","date":"2018-04-03","objectID":"/leetcode/0797/:1:0","tags":null,"title":"0797：所有可能的路径（★★）","uri":"/leetcode/0797/"},{"categories":null,"content":"分析 因为无环，所以可以直接递归。 ","date":"2018-04-03","objectID":"/leetcode/0797/:2:0","tags":null,"title":"0797：所有可能的路径（★★）","uri":"/leetcode/0797/"},{"categories":null,"content":"解答 def allPathsSourceTarget(self, graph: List[List[int]]) -\u003e List[List[int]]: def dfs(i): if i==n-1: return [[n-1]] return [[i]+path for j in graph[i] for path in dfs(j)] n = len(graph) return dfs(0) 72 ms ","date":"2018-04-03","objectID":"/leetcode/0797/:3:0","tags":null,"title":"0797：所有可能的路径（★★）","uri":"/leetcode/0797/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-04-02","objectID":"/leetcode/0796/:0:0","tags":null,"title":"0796：旋转字符串（★★）","uri":"/leetcode/0796/"},{"categories":null,"content":"题目 给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。 s 的 旋转操作 就是将 s 最左边的字符移动到最右边。 例如, 若 s = ‘abcde’，在旋转一次之后结果就是’bcdea’ 。 示例 1: 输入: s = \"abcde\", goal = \"cdeab\"\r输出: true\r示例 2: 输入: s = \"abcde\", goal = \"abced\"\r输出: false\r提示: 1 \u003c= s.length, goal.length \u003c= 100 s 和 goal 由小写英文字母组成 ","date":"2018-04-02","objectID":"/leetcode/0796/:1:0","tags":null,"title":"0796：旋转字符串（★★）","uri":"/leetcode/0796/"},{"categories":null,"content":"分析 每种旋转都等价于 s+s 的一个长为 len(s) 的子串，因此直接判断 goal 是否长 len(s) 且是 s+s 的子串即可。 ","date":"2018-04-02","objectID":"/leetcode/0796/:2:0","tags":null,"title":"0796：旋转字符串（★★）","uri":"/leetcode/0796/"},{"categories":null,"content":"解答 def rotateString(self, s: str, goal: str) -\u003e bool: return len(s)==len(goal) and goal in s*2 48 ms ","date":"2018-04-02","objectID":"/leetcode/0796/:3:0","tags":null,"title":"0796：旋转字符串（★★）","uri":"/leetcode/0796/"},{"categories":null,"content":"地球是蓝的。哥俩是蠢的。\n在人类将生活领域和自身欲望扩张到宇宙的时代，寻求自由的人们移民到宇宙中居住，他们的睿智孕育出发达的文明，不知不觉转变为对地球的一种威胁。\n宇宙历0156年，地球联邦政府经历了与祖母星格兰地玛斯有史以来的第四次接触（4th note），也正是从这一年开始，联邦政府与【梅杜斯子民】之间的对抗正式拉开帷幕。\n战争永无止境，牺牲不断增加……\n为了打开战局，联邦政府派出一名英姿飒爽的青年加入战局。年轻人名叫斯巴鲁·一之濑，不仅长相帅气、成绩优异，而且是宇宙战舰【提拉米斯】的王牌驾驶员。\n全人类的希望都寄托在他的身上。\n——然而，他实际上是个难以融入提拉米斯舰内集体生活，整日将自己关在专用机“杜兰德尔”驾驶舱内的“窝里蹲”……","date":"2018-04-02","objectID":"/anime/space_battleship_tiramisu/","tags":null,"title":"宇宙战舰提拉米斯","uri":"/anime/space_battleship_tiramisu/"},{"categories":null,"content":"简介 地球是蓝的。哥俩是蠢的。 在人类将生活领域和自身欲望扩张到宇宙的时代，寻求自由的人们移民到宇宙中居住，他们的睿智孕育出发达的文明，不知不觉转变为对地球的一种威胁。 宇宙历0156年，地球联邦政府经历了与祖母星格兰地玛斯有史以来的第四次接触（4th note），也正是从这一年开始，联邦政府与【梅杜斯子民】之间的对抗正式拉开帷幕。 战争永无止境，牺牲不断增加…… 为了打开战局，联邦政府派出一名英姿飒爽的青年加入战局。年轻人名叫斯巴鲁·一之濑，不仅长相帅气、成绩优异，而且是宇宙战舰【提拉米斯】的王牌驾驶员。 全人类的希望都寄托在他的身上。 ——然而，他实际上是个难以融入提拉米斯舰内集体生活，整","date":"2018-04-02","objectID":"/anime/space_battleship_tiramisu/:1:0","tags":null,"title":"宇宙战舰提拉米斯","uri":"/anime/space_battleship_tiramisu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 斯巴鲁·一之濑 Subaru Ichinose 男 石川界人 2 五十铃·一之濑 Isuzu Ichinose 男 櫻井孝宏 3 伏尔加·悍马 Vulgar Hummer 男 諏訪部順一 4 斯巴鲁·彼洋德 Subaru Beyond、スバルB、Subaru B 男 江口拓也 5 文图瑞·勒罗伊 Venturi Leory 男 土師孝也 6 莉裘·勒罗伊 Ligier Leory 女 遠藤綾 7 茂子·本田 Shigeruko Honda 女 新井里美 8 阴毛 THE UNDER HAIR、いんもう、Inmou ♂？ 中田譲治 ","date":"2018-04-02","objectID":"/anime/space_battleship_tiramisu/:2:0","tags":null,"title":"宇宙战舰提拉米斯","uri":"/anime/space_battleship_tiramisu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 宇宙战舰提拉米斯 2018-04-02 13 bilibili 2 宇宙战舰提拉米斯 2 2018-10-01 13 bilibili ","date":"2018-04-02","objectID":"/anime/space_battleship_tiramisu/:3:0","tags":null,"title":"宇宙战舰提拉米斯","uri":"/anime/space_battleship_tiramisu/"},{"categories":null,"content":"这是从异世界传承下光辉的姓名与竞跑能力的“马娘”、自久以来与人类共存着的世界的故事。\n从乡下转学到大都市的训中学园的马娘·特别周，与同学们互相切磋、赌上“日本第一马娘”的称号，目标：在“Twinkle系列”中的胜利！","date":"2018-04-01","objectID":"/anime/pretty_derby/","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"简介 这是从异世界传承下光辉的姓名与竞跑能力的“马娘”、自久以来与人类共存着的世界的故事。 从乡下转学到大都市的训中学园的马娘·特别周，与同学们互相切磋、赌上“日本第一马娘”的称号，目标：在“Twinkle系列”中的胜利！ 制作人员： 原作：Cygames 导演：及川启 脚本：米内山阳子、杉浦理史、池田亮 分镜：今泉贤一、增井壮一、高村彰 ","date":"2018-04-01","objectID":"/anime/pretty_derby/:1:0","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 特别周 特別週、Special Week 女 和氣あず未 2 无声铃鹿 無聲鈴鹿、Silence Suzuka 女 高野麻里佳 3 东海帝皇 东海帝王、Tokai Teio 女 Machico 4 伏特加 Vodka 女 大橋彩香 5 大和赤骥 大和赤驥、Daiwa Scarlet 女 木村千咲 6 黄金船 Gold Ship 女 上田瞳 7 目白麦昆 Mejiro McQueen 女 大西沙織 8 神鹰 神鷹、El Condor Pasa 女 髙橋ミナミ ","date":"2018-04-01","objectID":"/anime/pretty_derby/:2:0","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 赛马娘 Pretty Derby 2018-04-01 13 bilibili 2 赛马娘 Pretty Derby 第二季 2021-01-04 13 bilibili ","date":"2018-04-01","objectID":"/anime/pretty_derby/:3:0","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"MAD ","date":"2018-04-01","objectID":"/anime/pretty_derby/:4:0","tags":null,"title":"赛马娘 Pretty Derby","uri":"/anime/pretty_derby/"},{"categories":null,"content":"舞台是架空的大陆·努纳西亚。悠久的历史记载着无数的国家和文明的兴起、繁荣、战争、灭亡。\n住在绿意盎然的边境村落·丹德拉的凛，是个稍有些贪吃、充满精神的女孩子。与可靠又温柔的姐姐·梅尔、以世界第一的科学家为目标的科学宅少年·阿尔、严格但满怀关爱的爷爷一起过着平稳的生活。\n另一边，住在华丽的王都、被人民爱戴着的歌姬·菲妮丝。她虽然作为某位将要继承王位的王子的王妃候补，却在被重重墙壁包围的深宫中孤独度日。\n这两人有着其他人类所不具备的特殊力量。她们能够演唱出产生治愈伤口、创造出水、点火等各种各样奇迹的歌声。 ……命运将拥有歌之力量的这两人，分别引导到了残酷的旅程上。\n当战争的阴影笼罩王国时，即使是奇迹之歌的光辉也被染上了血色。所爱之人的生命被夺走，无声的悲鸣响彻石牢。\n两人的命运交汇，最后唱出的歌是希望？是绝望？还是……","date":"2018-03-31","objectID":"/anime/lost_song/","tags":null,"title":"失落的歌谣","uri":"/anime/lost_song/"},{"categories":null,"content":"简介 舞台是架空的大陆·努纳西亚。悠久的历史记载着无数的国家和文明的兴起、繁荣、战争、灭亡。 住在绿意盎然的边境村落·丹德拉的凛，是个稍有些贪吃、充满精神的女孩子。与可靠又温柔的姐姐·梅尔、以世界第一的科学家为目标的科学宅少年·阿尔、严格但满怀关爱的爷爷一起过着平稳的生活。 另一边，住在华丽的王都、被人民爱戴着的歌姬·菲妮丝。她虽然作为某位将要继承王位的王子的王妃候补，却在被重重墙壁包围的深宫中孤独度日。 这两人有着其他人类所不具备的特殊力量。她们能够演唱出产生治愈伤口、创造出水、点火等各种各样奇迹的歌声。 ……命运将拥有歌之力量的这两人，分别引导到了残酷的旅程上。 当战争的阴影笼罩王国时，即","date":"2018-03-31","objectID":"/anime/lost_song/:1:0","tags":null,"title":"失落的歌谣","uri":"/anime/lost_song/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 琳 Rin 女 鈴木このみ 2 菲妮丝 Finis 女 田村ゆかり 3 阿尔 男 久野美咲 4 波妮·古德莱特 女 たかはし智秋 5 亨利·利奥波德 男 山下誠一郎 6 阿琉·路克斯 女 瀬戸麻沙美 7 莫妮卡·路克斯 女 芹澤優 ","date":"2018-03-31","objectID":"/anime/lost_song/:2:0","tags":null,"title":"失落的歌谣","uri":"/anime/lost_song/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 失落的歌谣 2018-03-31 12 bilibili ","date":"2018-03-31","objectID":"/anime/lost_song/:3:0","tags":null,"title":"失落的歌谣","uri":"/anime/lost_song/"},{"categories":null,"content":"遥远的未来，因人类过度抽取地球资源，地球变得荒芜，不再适合居住，人类只好居住在移动要塞都市内，但时常需要外出获取无法产出的资源「熔岩燃料」，「熔岩燃料」的开采会吸引来半机械生命体「叫龙」，此时就轮到人类操对抗叫龙的「FranXX」机械人的出场了。究竟这些「叫龙」是敌是友，无从得知。\n少年阿广，驾驶部队代号016。他在少年时期被称作神童，如今却因无法驾驶「FranXX」，驾驶员生涯跌落谷底，是不被人需要的存在。在这样的广面前，某天，一位被称作02的神秘少女出现了。她的额头，长着两根艳丽的角。少女对广说：「终于找到你了，我的DARLING」。以此次偶遇为契机，广对驾驶机械人重新燃起了信心。","date":"2018-01-13","objectID":"/anime/darling_in_the_franxx/","tags":null,"title":"DARLING in the FRANXX","uri":"/anime/darling_in_the_franxx/"},{"categories":null,"content":"简介 遥远的未来，因人类过度抽取地球资源，地球变得荒芜，不再适合居住，人类只好居住在移动要塞都市内，但时常需要外出获取无法产出的资源「熔岩燃料」，「熔岩燃料」的开采会吸引来半机械生命体「叫龙」，此时就轮到人类操对抗叫龙的「FranXX」机械人的出场了。究竟这些「叫龙」是敌是友，无从得知。 少年阿广，驾驶部队代号016。他在少年时期被称作神童，如今却因无法驾驶「FranXX」，驾驶员生涯跌落谷底，是不被人需要的存在。在这样的广面前，某天，一位被称作02的神秘少女出现了。她的额头，长着两根艳丽的角。少女对广说：「终于找到你了，我的DARLING」。以此次偶遇为契机，广对驾驶机械人重新燃起了信心。 ","date":"2018-01-13","objectID":"/anime/darling_in_the_franxx/:1:0","tags":null,"title":"DARLING in the FRANXX","uri":"/anime/darling_in_the_franxx/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 广 CODE:016、HIRO 男 小清水亜美 2 02 CODE:002、ZERO TWO、パートナー殺し / 搭档杀手 女 戸松遥 3 五郎 CODE:056、GORO 男 梅原裕一郎 4 莓 CODE:015、ICHIGO 女 市ノ瀬加那 5 纯位数 CODE:666、揃目、ZOROME 男 田村睦心 6 未来 CODE:390、MIKU 女 山下七海 7 满 CODE:326、充、MITSURU 男 早見沙織 8 心 CODE:556、KOKORO 女 早見沙織 ","date":"2018-01-13","objectID":"/anime/darling_in_the_franxx/:2:0","tags":null,"title":"DARLING in the FRANXX","uri":"/anime/darling_in_the_franxx/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 DARLING in the FRANXX 2018-01-13 24 樱花 ","date":"2018-01-13","objectID":"/anime/darling_in_the_franxx/:3:0","tags":null,"title":"DARLING in the FRANXX","uri":"/anime/darling_in_the_franxx/"},{"categories":null,"content":"平凡的大学生·野本裕也，与神秘少女·瞳相遇了。\n在没有人烟的废弃场，野本目击到了她变成野兽的模样，\n与狮子怪物展开死战的一幕。\n他们的真实身份，是同时拥有人类的头脑与野兽的獠牙的“兽斗士”。\n并且，瞳是隐藏着最强斗争本能的兽斗士“蜜獾”。\n兽斗士们被自古以来支配日本经济的四大财阀三门、八菱、角供、石田所雇佣，\n并作为其代理人展开决斗，争夺霸权。之后，野本通过再次与瞳相遇，\n被卷入了这些兽斗士们的炽烈战斗“牙斗”当中——。 ","date":"2018-01-12","objectID":"/anime/killing_bites/","tags":null,"title":"牙斗","uri":"/anime/killing_bites/"},{"categories":null,"content":"简介 平凡的大学生·野本裕也，与神秘少女·瞳相遇了。 在没有人烟的废弃场，野本目击到了她变成野兽的模样， 与狮子怪物展开死战的一幕。 他们的真实身份，是同时拥有人类的头脑与野兽的獠牙的“兽斗士”。 并且，瞳是隐藏着最强斗争本能的兽斗士“蜜獾”。 兽斗士们被自古以来支配日本经济的四大财阀三门、八菱、角供、石田所雇佣， 并作为其代理人展开决斗，争夺霸权。之后，野本通过再次与瞳相遇， 被卷入了这些兽斗士们的炽烈战斗“牙斗”当中——。 制作人员： 原作：隅田かずあさ、村田真哉 导演：西片康人 脚本：朱白葵、风埜隼人、小柳启伍 分镜：中川淳、阿部记之、山内爱弥 ","date":"2018-01-12","objectID":"/anime/killing_bites/:1:0","tags":null,"title":"牙斗","uri":"/anime/killing_bites/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宇崎瞳 うざき ひとみ、Uzaki Hitomi、蜜獾、ラーテル、Ratel 女 雨宮天 2 野本裕也 のもと ゆうや、Nomoto Yuya 男 羽多野渉 3 中西获座 なかにし えるざ、Nakanishi Elza 女 内田真礼 4 稻叶初 いなば うい、Inaba Ui、兔、兎、ラビ、Rabi 女 上坂すみれ 5 祠堂零一 祠堂 零一、しどう れいいち、Shidoh Reiichi 男 小山力也 6 筱崎舞 篠崎 舞、しのざき まい、Shinozaki Mai 女 赤﨑千夏 7 冈岛壹之助 岡島 壱之助、おかじま いちのすけ、Okajima Ichin","date":"2018-01-12","objectID":"/anime/killing_bites/:2:0","tags":null,"title":"牙斗","uri":"/anime/killing_bites/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 牙斗 2018-01-12 12 樱花 ","date":"2018-01-12","objectID":"/anime/killing_bites/:3:0","tags":null,"title":"牙斗","uri":"/anime/killing_bites/"},{"categories":null,"content":"哈库梅伊与蜜珂析。\n住在绿意盎然的森林中的，两位小小的女孩子。\n在树洞里建造家、把树叶当做伞、坐在昆虫或鸟的背上……\n身高9厘米的话，这种事情也是能做得到的。\n不去悄悄地偷看一下吗？\n她们那安详而愉快，十分可爱的生活。","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"简介 哈库梅伊与蜜珂析。 住在绿意盎然的森林中的，两位小小的女孩子。 在树洞里建造家、把树叶当做伞、坐在昆虫或鸟的背上…… 身高9厘米的话，这种事情也是能做得到的。 不去悄悄地偷看一下吗？ 她们那安详而愉快，十分可爱的生活。 制作人员： 原作：樫木祐人 导演：安藤正臣 脚本：大河内一楼、吉田玲子、国泽真理子 分镜：名村英敏、木野目优、大桥明代、夕澄庆英 ","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/:1:0","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哈库梅伊 白明 女 松田利冴 2 蜜珂析 御子地 女 下地紫野 3 康居 女 悠木碧 4 千 女 安済知佳 5 鰯谷 男 松風雅也 6 マヤ マスター 女 緒方恵美 7 伽达 女 新谷真弓 8 亚由音 女 生天目仁美 ","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/:2:0","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 妖精森林的小不点 2018-01-12 13 bilibili ","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/:3:0","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"MAD ","date":"2018-01-12","objectID":"/anime/tiny_little_life_in_the_woods/:4:0","tags":null,"title":"妖精森林的小不点","uri":"/anime/tiny_little_life_in_the_woods/"},{"categories":null,"content":"某个大陆的、某个时代。\n大陆南北分割的战争结束了，世界逐渐走向了和平。\n在战争中、作为军人而战斗的薇尔莉特·伊芙加登离开了军队，来到了大港口城市。怀抱着战场上一个对她而言比谁都重要的人告诉了她“某个话语”――。\n街道上人群踊跃，有轨电车在排列着煤气灯的马路上穿梭着。薇尔莉特在街道上找到了“代写书信”的工作。那是根据委托人的想法来组织出相应语言的工作。\n她直面着委托人、触碰着委托人内心深处的坦率感情。与此同时，薇尔莉特在记录书信时，那一天所告知的那句话的意思也逐渐接近了。","date":"2018-01-10","objectID":"/anime/violet_evergarden/","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"简介 某个大陆的、某个时代。 大陆南北分割的战争结束了，世界逐渐走向了和平。 在战争中、作为军人而战斗的薇尔莉特·伊芙加登离开了军队，来到了大港口城市。怀抱着战场上一个对她而言比谁都重要的人告诉了她“某个话语”――。 街道上人群踊跃，有轨电车在排列着煤气灯的马路上穿梭着。薇尔莉特在街道上找到了“代写书信”的工作。那是根据委托人的想法来组织出相应语言的工作。 她直面着委托人、触碰着委托人内心深处的坦率感情。与此同时，薇尔莉特在记录书信时，那一天所告知的那句话的意思也逐渐接近了。 制作人员： 原作：晓佳奈 导演：石立太一 脚本：吉田玲子、浦畑达彦、铃木贵昭 分镜：藤田春香、河浪荣作、木上益治、小川","date":"2018-01-10","objectID":"/anime/violet_evergarden/:1:0","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 薇尔莉特·伊芙加登 Violet Evergarden 女 石川由依 2 基尔伯特·布甘比利亚 Gilbert Bougainvillea 男 浪川大輔 3 克劳迪亚·霍金斯 Claudia Hodgins 男 子安武人 4 嘉德丽雅·波德莱尔 Cattleya Baudelaire 女 遠藤綾 5 贝内迪克特·布卢 Benedict Blue 男 内山昂輝 6 艾丽卡·布朗 埃丽卡·布朗、Erica Brown 女 茅原実里 7 爱丽丝·卡娜莉 艾丽斯·卡纳利、Iris Cannary 女 戸松遥 8 蒂法尼·伊芙加登 Tiffany Evergarden","date":"2018-01-10","objectID":"/anime/violet_evergarden/:2:0","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 紫罗兰永恒花园 2018-01-10 13 bilibili 2 紫罗兰永恒花园 外传 - 永远与自动手记人偶 - 2019-09-06 1 bilibili 3 剧场版 紫罗兰永恒花园 2020-09-18 1 bilibili ","date":"2018-01-10","objectID":"/anime/violet_evergarden/:3:0","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"MAD ","date":"2018-01-10","objectID":"/anime/violet_evergarden/:4:0","tags":null,"title":"紫罗兰永恒花园","uri":"/anime/violet_evergarden/"},{"categories":null,"content":"玄关门一打开，眼前冒出了一位小学女生——\n“我依照约定来了，请收我为弟子！”\n年仅十六岁便拥有将棋界最高头衔“龙王”的九头龙八一家里，出现一位名叫雏鹤爱的小学三年级生，九岁。\n“什么？……弟子？你在说什么？”\n“……您不记得了吗？”\n八一对自己答应过的事情完全没有印象，却展开了与小学女生同居的生活。受到爱直率的热情影响，八一也逐渐取回险些丧失的热忱——","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"简介 玄关门一打开，眼前冒出了一位小学女生—— “我依照约定来了，请收我为弟子！” 年仅十六岁便拥有将棋界最高头衔“龙王”的九头龙八一家里，出现一位名叫雏鹤爱的小学三年级生，九岁。 “什么？……弟子？你在说什么？” “……您不记得了吗？” 八一对自己答应过的事情完全没有印象，却展开了与小学女生同居的生活。受到爱直率的热情影响，八一也逐渐取回险些丧失的热忱—— 制作人员： 原作：白鸟士郎 导演：柳伸亮 脚本：金子祐介、志茂文彦、杉泽悟 分镜：奥村吉昭、岛津裕行、福岛利规、岩田和也 ","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/:1:0","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 九头龙八一 くずりゅう やいち、Kuzuryu Yaichi 男 内田雄馬 2 雏鹤爱 ひなづる あい、Hinazuru Ai 女 日高里菜 3 夜叉神天衣 やしゃじん あい、Yashajin Ai、天ちゃん 女 佐倉綾音 4 空银子 そら ぎんこ、Sora Ginko 女 金元寿子 5 清泷桂香 きよたき けいか、Kiyotaki Keika 女 茅野愛衣 6 水越澪 みずこし みお、Mizukoshi Mio 女 久保ユリカ 7 贞任绫乃 さだとう あやの、Sadato Ayano 女 橋本ちなみ 8 夏绿蒂·伊索亚尔 Charlotte Izoard ","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/:2:0","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙王的工作！ 2018-01-08 12 bilibili ","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/:3:0","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"MAD ","date":"2018-01-08","objectID":"/anime/ryuuou_no_oshigoto/:4:0","tags":null,"title":"龙王的工作！","uri":"/anime/ryuuou_no_oshigoto/"},{"categories":null,"content":"永远的“6时59分”开始了——\n在佑河家有着代代相传的止界术，使用止界术，能够进入森罗万象尽数停止的“止界”。某天，主人公树里的外甥和哥哥，被诱拐犯绑架了。她为了救出他们而不得已使用了“止界术”，却遭到不应存在于那里的、除自己以外的“会动的”人类袭击。他们是尊崇止界术的「真纯实爱会」。围绕着使用止界术时所必需的“石头”，止界之谜、佑河家之谜逐渐浮出水面……","date":"2018-01-07","objectID":"/anime/kokkoku/","tags":null,"title":"刻刻","uri":"/anime/kokkoku/"},{"categories":null,"content":"简介 永远的“6时59分”开始了—— 在佑河家有着代代相传的止界术，使用止界术，能够进入森罗万象尽数停止的“止界”。某天，主人公树里的外甥和哥哥，被诱拐犯绑架了。她为了救出他们而不得已使用了“止界术”，却遭到不应存在于那里的、除自己以外的“会动的”人类袭击。他们是尊崇止界术的「真纯实爱会」。围绕着使用止界术时所必需的“石头”，止界之谜、佑河家之谜逐渐浮出水面…… 制作人员： 原作：堀尾省太 导演：大桥誉志光 脚本：猪爪慎一、木村畅、高木圣子 分镜：汤川敦之、寺冈岩、难波日登志 ","date":"2018-01-07","objectID":"/anime/kokkoku/:1:0","tags":null,"title":"刻刻","uri":"/anime/kokkoku/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佑河树里 佑河 樹里、ゆかわ じゅり、Yukawa Juri 女 安済知佳 2 爷爷 男 山路和弘 3 间岛翔子 間島 翔子、まじま しょうこ、Majima Shoko 女 瀬戸麻沙美 4 佐河顺治 佐河 順治、さがわ じゅんじ、Sagawa Junji 男 郷田ほづみ 5 佑河贵文 佑河 貴文、ゆかわ たかふみ、Yukawa Sakafumi 男 辻谷耕史 6 佑河翼 佑河 翼、ゆかわ つばさ、Yukawa Tsubasa 男 野島裕史 7 佑河真 佑河 真、ゆかわ まこと、Yukawa Makoto 男 岩田龍門 8 迫 さこ、Sako 男 吉野裕行 ","date":"2018-01-07","objectID":"/anime/kokkoku/:2:0","tags":null,"title":"刻刻","uri":"/anime/kokkoku/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 刻刻 2018-01-07 12 bilibili ","date":"2018-01-07","objectID":"/anime/kokkoku/:3:0","tags":null,"title":"刻刻","uri":"/anime/kokkoku/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-01-05","objectID":"/leetcode/0790/:0:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":"题目 有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。 给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 10^9 + 7 取模 的值。 平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个， 使得恰好有一个平铺有一个瓷砖占据两个正方形。 示例 1: 输入: n = 3\r输出: 5\r解释: 五种不同的方法如上所示。\r示例 2: 输入: n = 1\r输出: 1\r提示： 1 \u003c= n \u003c= 1000 ","date":"2018-01-05","objectID":"/leetcode/0790/:1:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":"分析 假设最后一列竖着铺 1x2，显然转为递归子问题，横着铺两个 1x2，也同理。 假如最后一列铺 ‘L’ 性，则要求平铺 2x(n-1) 但最后一列只铺一个的方法数。 为了方便递推，令： dp[i][0] 代表平铺 i-1 列的方法数 dp[i][1] 代表平铺 i 列但最后一列只铺一个的方法数 dp[i][2] 代表平铺 i 列的方法数 即可由 dp[i] 递推出 dp[i+1]。还可以优化为 3 个变量。 ","date":"2018-01-05","objectID":"/leetcode/0790/:2:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":"解答 def numTilings(self, n: int) -\u003e int: a, b, c, mod = 0, 0, 1, 10**9+7 for _ in range(n): a, b, c = c, (2*a+b)%mod, (a+b+c)%mod return c 36 ms ","date":"2018-01-05","objectID":"/leetcode/0790/:3:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":"*附加 这是完全的线性递推关系，因此可以用矩阵快速幂优化。 注意在矩阵乘法时也取模即可。 def numTilings(self, n: int) -\u003e int: def mpow(mat, n): res = mat for bit in bin(n)[3:]: res = res*res%mod if bit=='1': res = res*mat%mod return res import numpy as np mod = 10**9+7 A = np.mat([[0,0,1],[2,1,0],[1,1,1]]) dp = np.mat([[0],[0],[1]]) dp = mpow","date":"2018-01-05","objectID":"/leetcode/0790/:4:0","tags":null,"title":"0790：多米诺和托米诺平铺（★★）","uri":"/leetcode/0790/"},{"categories":null,"content":"随着恶魔觉醒，人类世界陷入混乱。性格温柔的男孩与恶魔合体，在神秘好友飞鸟了的指引下，卷入一场残酷、堕落的对抗邪恶之战。","date":"2018-01-05","objectID":"/anime/devilman_crybaby/","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":"简介 随着恶魔觉醒，人类世界陷入混乱。性格温柔的男孩与恶魔合体，在神秘好友飞鸟了的指引下，卷入一场残酷、堕落的对抗邪恶之战。 制作人员： 原作：永井豪 导演：汤浅政明 脚本：大河内一楼 分镜：筱原启辅、许平康、Abel Gongora、柴田胜纪、霜山朋久 ","date":"2018-01-05","objectID":"/anime/devilman_crybaby/:1:0","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 不动明 ふどう あきら、Fudou Akira 男 内山昂輝 2 飞鸟了 あすか りょう、Asuka Ryo 男 村瀬歩 3 牧村美树 牧村ミキ、まきむら みき、Makimura Miki 女 潘めぐみ 4 美子 黒田美樹、Mi-ko 女 小清水亜美 5 死丽濡 Silene 女 田中敦子 6 槐梦 Kaimu 男 小山力也 7 ゼノン Zenon 男 アヴちゃん 8 长崎光司 ながさき こうじ、Nagasaki Kōji 男 津田健次郎 ","date":"2018-01-05","objectID":"/anime/devilman_crybaby/:2:0","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 恶魔人 crybaby 2018-01-05 10 樱花 ","date":"2018-01-05","objectID":"/anime/devilman_crybaby/:3:0","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":"MAD ","date":"2018-01-05","objectID":"/anime/devilman_crybaby/:4:0","tags":null,"title":"恶魔人 crybaby","uri":"/anime/devilman_crybaby/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-01-03","objectID":"/leetcode/0788/:0:0","tags":null,"title":"0788：旋转数字（★★）","uri":"/leetcode/0788/"},{"categories":null,"content":"题目 我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的， 且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己； 2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）； 6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 示例： 输入: 10\r输出: 4\r解释: 在[1, 10]中有四个好数： 2, 5,","date":"2018-01-03","objectID":"/leetcode/0788/:1:0","tags":null,"title":"0788：旋转数字（★★）","uri":"/leetcode/0788/"},{"categories":null,"content":"分析 暴力做法是遍历 1 到 N，判断是否不含 ‘347’ 且至少有一个 ‘2569’ 即可。 不过这是求范围内数字满足某种性质的个数，典型的数位 dp 问题，能极大优化时间。 令 dfs(pos, st, bound) 代表： 遍历到 n 的第 pos 位 st 代表前面是否至少有一个 ‘2569’ bound 代表前面取的数是否贴着 n 的上界 即可递归。 ","date":"2018-01-03","objectID":"/leetcode/0788/:2:0","tags":null,"title":"0788：旋转数字（★★）","uri":"/leetcode/0788/"},{"categories":null,"content":"解答 def rotatedDigits(self, n: int) -\u003e int: @lru_cache(None) def dfs(pos, st, bound): if pos == len(s): return int(st) res, cur = 0, int(s[pos]) up = cur if bound else 9 for x in range(up+1): if x not in [3,4,7]: res += dfs(pos+1, st or x in [2,5,6,9], bound and x==cur) return res s = str(n) return d","date":"2018-01-03","objectID":"/leetcode/0788/:3:0","tags":null,"title":"0788：旋转数字（★★）","uri":"/leetcode/0788/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2018-01-02","objectID":"/leetcode/0787/:0:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★★）","uri":"/leetcode/0787/"},{"categories":null,"content":"题目 有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。 示例 1： 输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\rsrc = 0, dst = 2, k = 1\r输出: 200\r解释: 城市航班图如下\r从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。\r示例 2： 输入: n = 3, edge","date":"2018-01-02","objectID":"/leetcode/0787/:1:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★★）","uri":"/leetcode/0787/"},{"categories":null,"content":"分析 ","date":"2018-01-02","objectID":"/leetcode/0787/:2:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★★）","uri":"/leetcode/0787/"},{"categories":null,"content":"#1 限制了路径长度的可以先考虑动态规划。 用 dp[i][j] 代表从 src 到 i 最多飞 j 次的最低价格，即可递推。 def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -\u003e int: dp = [[float('inf')]*(k+2) for _ in range(n)] dp[src] = [0] * (k+2) for j in range(k+1): for u, v, w in flights: dp[v][j+1] = min(dp[v][j+","date":"2018-01-02","objectID":"/leetcode/0787/:2:1","tags":null,"title":"0787：K 站中转内最便宜的航班（★★）","uri":"/leetcode/0787/"},{"categories":null,"content":"#2 可以优化为一维数组。观察发现，这本质上就是 Bellman-Ford 算法。 区别在于必须保存上一轮的距离数组，保证每轮只多松弛一次 ","date":"2018-01-02","objectID":"/leetcode/0787/:2:2","tags":null,"title":"0787：K 站中转内最便宜的航班（★★）","uri":"/leetcode/0787/"},{"categories":null,"content":"解答 def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -\u003e int: dp = [float('inf')] * n dp[src] = 0 for _ in range(k + 1): prev, flag = dp[:], True for u, v, w in flights: if prev[u]+w \u003c dp[v]: dp[v] = prev[u]+w flag = False if flag: break res = dp[dst] return re","date":"2018-01-02","objectID":"/leetcode/0787/:3:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★★）","uri":"/leetcode/0787/"},{"categories":null,"content":"*附加 还有个巧妙的解法。 将状态 (城市 u，飞行次数 c) 看作顶点，如果 c \u003ck+1，那么对于航班 \u003cu,v,w\u003e，从 (u, c) 到 (v, c+1) 连有向边，权重 w。 问题即转为在新图中求 (src, 0) 到 (dst, 0\u003c=c\u003c=k+1) 的最短路，可以用 dijkstra 算法。 具体实现时不需要真的构造出新图。 ","date":"2018-01-02","objectID":"/leetcode/0787/:3:1","tags":null,"title":"0787：K 站中转内最便宜的航班（★★）","uri":"/leetcode/0787/"},{"categories":null,"content":"解答 def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -\u003e int: nxt = defaultdict(list) for u, v, w in flights: nxt[u].append((v, w)) d, pq = {}, [(0, src, 0)] while pq: w, u, c = heappop(pq) if (u, c) in d: continue if u == dst: return w d[(u, c)] = w if c \u003c k +","date":"2018-01-02","objectID":"/leetcode/0787/:4:0","tags":null,"title":"0787：K 站中转内最便宜的航班（★★）","uri":"/leetcode/0787/"},{"categories":null,"content":"题目 给定一个表达式 expression 如 expression = “e + 8 - a + 5” 和一个求值映射， 如 {“e”: 1}（给定的形式为 evalvars = [“e”] 和 evalints = [1]）， 返回表示简化表达式的标记列表，例如 [\"-1 * a\",“14”] 表达式交替使用块和符号，每个块和符号之间有一个空格。 块要么是括号中的表达式，要么是变量，要么是非负整数。 块是括号中的表达式，变量或非负整数。 变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母， 并注意变量从不具有像 “2x” 或 “-x” 这样的前导系数或一元运算符 。","date":"2017-12-16","objectID":"/leetcode/0770/:1:0","tags":null,"title":"0770：基本计算器 IV（★★★）","uri":"/leetcode/0770/"},{"categories":null,"content":"分析 本质上是多项式的计算。为了方便，考虑用 Counter() 存储变量和系数。 为了合并同类项，考虑用变量的有序元组来作为 key。常数项直接用空的元组作为 key。 比如 5 + a * b + bb * cc 表示为 {(): 5, (a, b): 1, (bb, cc): 1}。 具体实现时，括号内是 List(Counter) 的形式，先按顺序计算乘法，再按顺序计算加减，得到一个 Counter。 然后用栈模拟递归即可。 计算完毕后，所有单项式按 (元组长度, 元组本身) 排序，转为要求的字符串格式即可。 ","date":"2017-12-16","objectID":"/leetcode/0770/:2:0","tags":null,"title":"0770：基本计算器 IV（★★★）","uri":"/leetcode/0770/"},{"categories":null,"content":"解答 def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -\u003e List[str]: def mul(ct0, ct1): res = Counter() for k0, k1 in product(ct0, ct1): res[tuple(sorted(k0 + k1))] += ct0[k0] * ct1[k1] return res def cal(A): stack = [] for item in A: if isinstance(item, dict) and ","date":"2017-12-16","objectID":"/leetcode/0770/:3:0","tags":null,"title":"0770：基本计算器 IV（★★★）","uri":"/leetcode/0770/"},{"categories":null,"content":"*附加 本题不含正负号，所以和 0227 类似，可以用更通用的方法。 遍历到某个运算符时，将前面优先级更高的先运算了。 def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -\u003e List[str]: def mul(ct0, ct1): tmp = ct0.copy() ct0.clear() for k0, k1 in product(tmp, ct1): ct0[tuple(sorted(k0 + k1))] += tmp[k0] * ct1[k1] func = {'","date":"2017-12-16","objectID":"/leetcode/0770/:4:0","tags":null,"title":"0770：基本计算器 IV（★★★）","uri":"/leetcode/0770/"},{"categories":null,"content":"题目 在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。 mines[i] = [xi, yi]表示 grid[xi][yi] == 0 返回 grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。 一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ， 以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。 注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。 示例 1： 输入: n = 5, mines =","date":"2017-12-10","objectID":"/leetcode/0764/:1:0","tags":null,"title":"0764：最大加号标志（★★）","uri":"/leetcode/0764/"},{"categories":null,"content":"分析 分别递推找到 (i,j) 往四个方向的臂长即可。 ","date":"2017-12-10","objectID":"/leetcode/0764/:2:0","tags":null,"title":"0764：最大加号标志（★★）","uri":"/leetcode/0764/"},{"categories":null,"content":"解答 def orderOfLargestPlusSign(self, n: int, mines: List[List[int]]) -\u003e int: mines = {(x, y) for x,y in mines} A = [[int((x,y) not in mines) for y in range(n)] for x in range(n)] cal = lambda row: list(accumulate(row, lambda x,y:(x+y)*y)) L = [cal(row) for row in A] R = [cal(row[::-1])[::-1] for row ","date":"2017-12-10","objectID":"/leetcode/0764/:3:0","tags":null,"title":"0764：最大加号标志（★★）","uri":"/leetcode/0764/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-11-29","objectID":"/leetcode/0753/:0:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":"题目 有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, …, k-1 中的一个 。 你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。 举个例子，假设密码是 “345”，你可以输入 “012345” 来打开它，只是你输入了 6 个字符. 请返回一个能打开保险箱的最短字符串。 示例1: 输入: n = 1, k = 2\r输出: \"01\"\r说明: \"10\"也可以打开保险箱。\r示例2: 输入: n = 2, k = 2\r输出: \"00110\"\r说明: \"01100\", \"10011\", \"11001\" 也能打开保险箱。\r提示：","date":"2017-11-29","objectID":"/leetcode/0753/:1:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":"分析 本题有个非常巧妙的方法。将所有 n-1 位数作为顶点，如果 u 的后 n-2 位和 v 的前 n-2 位相同，就添加一条边 u 指向 v。 那么输入的字符串可以看作是有向图中的一条路径。字符串要覆盖所有密码，等价于图中的路径要经过所有边。 因此问题转化为求最短的经过所有边的路径。 该图中所有顶点的入度和出度相同，因此是欧拉图。用 Hierholzer 算法求欧拉回路即可。注意 n==1 的特殊情况。 ","date":"2017-11-29","objectID":"/leetcode/0753/:2:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":"解答 def crackSafe(self, n: int, k: int) -\u003e str: def dfs(u): while nxt[u] \u003c k: nxt[u] += 1 dfs(u[1:]+str(nxt[u]-1)) stack.append(u[-1]) if n == 1: return ''.join(str(i) for i in range(k)) stack, nxt = [], defaultdict(int) dfs('0'*(n-1)) return ''.join(stack) + '0'*(n-2) 44 ms ","date":"2017-11-29","objectID":"/leetcode/0753/:3:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":"*附加 其实只要每次都选最大的后继顶点，就不会遇到死胡同。所以本题还可以直接构造。 def crackSafe(self, n: int, k: int) -\u003e str: if n == 1: return ''.join(str(i) for i in range(k)) res, nxt = '0' * (n-1), defaultdict(lambda: k-1) for _ in range(k**n): u = res[1-n:] res += str(nxt[u]) nxt[u] -= 1 return res 40 ms ","date":"2017-11-29","objectID":"/leetcode/0753/:4:0","tags":null,"title":"0753：破解保险箱（★★★）","uri":"/leetcode/0753/"},{"categories":null,"content":"小男孩米格（安东尼·冈萨雷斯 Anthony Gonzalez 配音）一心梦想成为音乐家，更希望自己能和偶像歌神德拉库斯（本杰明·布拉特 Benjamin Bratt 配音）一样，创造出打动人心的音乐，但他的家族却世代禁止族人接触音乐。米格痴迷音乐，无比渴望证明自己的音乐才能，却因为一系列怪事，来到了五彩斑斓又光怪陆离的神秘世界。在那里，米格遇见了魅力十足的落魄乐手埃克托（盖尔·加西亚·贝纳尔 Gael García Bernal 配音），他们一起踏上了探寻米格家族不为人知往事的奇妙之旅，并开启了一段震撼心灵、感动非凡、永生难忘的旅程。","date":"2017-11-22","objectID":"/anime/coco/","tags":null,"title":"寻梦环游记","uri":"/anime/coco/"},{"categories":null,"content":"简介 小男孩米格（安东尼·冈萨雷斯 Anthony Gonzalez 配音）一心梦想成为音乐家，更希望自己能和偶像歌神德拉库斯（本杰明·布拉特 Benjamin Bratt 配音）一样，创造出打动人心的音乐，但他的家族却世代禁止族人接触音乐。米格痴迷音乐，无比渴望证明自己的音乐才能，却因为一系列怪事，来到了五彩斑斓又光怪陆离的神秘世界。在那里，米格遇见了魅力十足的落魄乐手埃克托（盖尔·加西亚·贝纳尔 Gael García Bernal 配音），他们一起踏上了探寻米格家族不为人知往事的奇妙之旅，并开启了一段震撼心灵、感动非凡、永生难忘的旅程。 制作人员： 制作：迪士尼电影公司 动画制作：皮克斯","date":"2017-11-22","objectID":"/anime/coco/:1:0","tags":null,"title":"寻梦环游记","uri":"/anime/coco/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 米格尔 男 Anthony Gonzalez ","date":"2017-11-22","objectID":"/anime/coco/:2:0","tags":null,"title":"寻梦环游记","uri":"/anime/coco/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 寻梦环游记 2017-11-22 1 樱花 ","date":"2017-11-22","objectID":"/anime/coco/:3:0","tags":null,"title":"寻梦环游记","uri":"/anime/coco/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-11-19","objectID":"/leetcode/0743/:0:0","tags":null,"title":"0743：网络延迟时间（★★）","uri":"/leetcode/0743/"},{"categories":null,"content":"题目 有 n 个网络节点，标记为 1 到 n。 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。 示例 1： 输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\r输出：2\r示例 2： 输入：times = [[1,2,1]], n = 2, k = 1\r输出：1\r示例 3： 输入：ti","date":"2017-11-19","objectID":"/leetcode/0743/:1:0","tags":null,"title":"0743：网络延迟时间（★★）","uri":"/leetcode/0743/"},{"categories":null,"content":"分析 典型的单源最短路径问题，可以用堆优化的 dijkstra 算法。 ","date":"2017-11-19","objectID":"/leetcode/0743/:2:0","tags":null,"title":"0743：网络延迟时间（★★）","uri":"/leetcode/0743/"},{"categories":null,"content":"解答 def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: nxt = defaultdict(list) for u, v, w in times: nxt[u-1].append((v-1, w)) d, pq = {}, [(0, k-1)] while pq: w, u = heappop(pq) if u in d: continue d[u] = w for v, w2 in nxt[u]: if v not in d: heappush(pq, (w+w2, v)) return ma","date":"2017-11-19","objectID":"/leetcode/0743/:3:0","tags":null,"title":"0743：网络延迟时间（★★）","uri":"/leetcode/0743/"},{"categories":null,"content":"*附加 本题可以练习各种最短路算法。 ","date":"2017-11-19","objectID":"/leetcode/0743/:4:0","tags":null,"title":"0743：网络延迟时间（★★）","uri":"/leetcode/0743/"},{"categories":null,"content":"#1 Floyd def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: d = [[float('inf')]*n for _ in range(n)] for i in range(n): d[i][i] = 0 for u, v, w in times: d[u-1][v-1] = w for x, i, j in product(range(n), range(n), range(n)): d[i][j] = min(d[i][j], d[i][x]+d[x][j]) res = max(d[","date":"2017-11-19","objectID":"/leetcode/0743/:4:1","tags":null,"title":"0743：网络延迟时间（★★）","uri":"/leetcode/0743/"},{"categories":null,"content":"#2 Bellman-Ford def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: d = [float('inf')] * n d[k-1] = 0 for _ in range(n - 1): flag = True for u, v, w in times: if d[u-1] + w \u003c d[v-1]: d[v-1] = d[u-1] + w flag = False if flag: break res = max(d) return res if res \u003c float('inf') ","date":"2017-11-19","objectID":"/leetcode/0743/:4:2","tags":null,"title":"0743：网络延迟时间（★★）","uri":"/leetcode/0743/"},{"categories":null,"content":"#3 SPFA def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: nxt = defaultdict(list) for u, v, w in times: nxt[u-1].append((v-1, w)) d = [float('inf')] * n d[k-1] = 0 queue, vis = deque([k-1]), {k-1} while queue: u = queue.popleft() vis.remove(u) for v, w in nxt[u]: if d[u] + w","date":"2017-11-19","objectID":"/leetcode/0743/:4:3","tags":null,"title":"0743：网络延迟时间（★★）","uri":"/leetcode/0743/"},{"categories":null,"content":"#4 Dijkstra 朴素 def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003e int: nxt = defaultdict(list) for u, v, w in times: nxt[u-1].append((v-1, w)) d, Q = [float('inf')] * n, set(range(n)) d[k-1] = 0 while Q: u = min(Q, key=d.__getitem__) Q.remove(u) for v, w in nxt[u]: if v in Q: d[v]","date":"2017-11-19","objectID":"/leetcode/0743/:4:4","tags":null,"title":"0743：网络延迟时间（★★）","uri":"/leetcode/0743/"},{"categories":null,"content":"题目 一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示： 0 表示这个格子是空的，所以你可以穿过它。 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 -1 表示这个格子里有荆棘，挡着你的路。 你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃： 从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）； 当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子； 当你经过一个格子且这个格子包含一个樱桃时，","date":"2017-11-17","objectID":"/leetcode/0741/:1:0","tags":null,"title":"0741：摘樱桃（★★★）","uri":"/leetcode/0741/"},{"categories":null,"content":"分析 单程是个很显然的 dp 问题，双程则会互相影响，不能分开求。 那么考虑一起递推，到 (i,j) 位置的双程的最大值，依赖于上一步两条线路的结尾。 为了递推，令 dfs(i1,j1,i2,j2) 代表两条线路分别到 (i1,j1)、(i2,j2) 位置时的最大值，即可递推。 注意到递推过程中 i1+j1==i2+j2，因此可以简化为 dfs(k, i1, i2) 代表第 k 步 两条线路分别到 (i1,k-i1)、(i2,k-i2) 位置时的最大值。 ","date":"2017-11-17","objectID":"/leetcode/0741/:2:0","tags":null,"title":"0741：摘樱桃（★★★）","uri":"/leetcode/0741/"},{"categories":null,"content":"解答 class Solution: def cherryPickup(self, grid: List[List[int]]) -\u003e int: @lru_cache(None) def dfs(k, i1, i2): if k==0: return grid[0][0] if grid[i1][k-i1] == -1 or grid[i2][k-i2] == -1: return float('-inf') res, cur = float('-inf'), sum(grid[i][k-i] for i in {i1, i2}) for x1, x2 in product([i1, i1-1","date":"2017-11-17","objectID":"/leetcode/0741/:3:0","tags":null,"title":"0741：摘樱桃（★★★）","uri":"/leetcode/0741/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，你可以对它进行一些操作。 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后， 你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 示例 1： 输入：nums = [3,4,2]\r输出：6\r解释：\r删除 4 获得 4 个点数，因此 3 也被删除。\r之后，删除 2 获得 2 个点数。总共获得 6 个点数。\r示例 2： 输入：nums = [2,2,3,3,3,4]\r输出：9\r解释：\r删除 3 获得 3 个点数，接着要删除两个 2 ","date":"2017-11-16","objectID":"/leetcode/0740/:1:0","tags":null,"title":"0740：删除与获得点数（★★）","uri":"/leetcode/0740/"},{"categories":null,"content":"分析 拿了 nums[i] 的点数，就拿不到 nums[i]-1 和 nums[i]+1 的点数，这个限制类似 0198 打家劫舍。 因此，统计得到 min(nums) 到 max(nums) 每个数能拿到的点数，就转为打家劫舍问题了。 ","date":"2017-11-16","objectID":"/leetcode/0740/:2:0","tags":null,"title":"0740：删除与获得点数（★★）","uri":"/leetcode/0740/"},{"categories":null,"content":"解答 def deleteAndEarn(self, nums: List[int]) -\u003e int: ct, a, b = Counter(nums), 0, 0 for x in range(min(ct), max(ct)+1): a, b = b, max(b, a+x*ct[x]) return b 40 ms ","date":"2017-11-16","objectID":"/leetcode/0740/:3:0","tags":null,"title":"0740：删除与获得点数（★★）","uri":"/leetcode/0740/"},{"categories":null,"content":"题目 给定一个字符串 s，返回 s 中不同的非空「回文子序列」个数 。 通过从 s 中删除 0 个或多个字符来获得子序列。 如果一个字符序列与它反转后的字符序列一致，那么它是「回文字符序列」。 如果有某个 i , 满足 ai != bi ，则两个序列 a1, a2, … 和 b1, b2, … 不同。 注意： 结果可能很大，你需要对 10^9 + 7 取模 。 示例 1： 输入：s = 'bccb'\r输出：6\r解释：6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。\r注意：'bcb' 虽然出现两次但仅计数一次。\r示例 2： 输入：s ","date":"2017-11-06","objectID":"/leetcode/0730/:1:0","tags":null,"title":"0730：统计不同回文子序列（★★★）","uri":"/leetcode/0730/"},{"categories":null,"content":"分析 不考虑重复的话，就是一般的区间 dp 问题，按序列最外层的字符递推。 考虑重复的话要复杂很多。假设最外层字符为 ‘a’，位置分别为 i、j，那么： [i,j] 范围内最外层为 ‘b’/‘c’/’d’ 的不同回文子序列，加上 ‘a’ 后显然是不同的 [i,j] 范围内最外层为 ‘a’ 的不同回文子序列，加上 ‘a’ 后也是不同的 但加/不加 ‘a’ 的两个集合是有很多重复的 观察发现，加上 ‘a’ 后基本包括了不加 ‘a’ 的集合，除了 ‘a’ 和 ‘aa’ 两个集合的大小是相同的，因此加/不加 ‘a’ 的合集只比不加 ‘a’ 的集合多 2 于是令 dp[i][j][x] 代表 [i,j]","date":"2017-11-06","objectID":"/leetcode/0730/:2:0","tags":null,"title":"0730：统计不同回文子序列（★★★）","uri":"/leetcode/0730/"},{"categories":null,"content":"解答 def countPalindromicSubsequences(self, s: str) -\u003e int: n, mod = len(s), 10**9+7 A = [ord(c)-ord('a') for c in s] dp = [[[0]*4 for _ in range(n)] for _ in range(n)] for j in range(n): dp[j][j][A[j]] = 1 for i in range(j-1, -1, -1): dp[i][j] = dp[i+1][j-1][:] if A[i]==A[j]: dp[i][j][A[i]] = (sum(dp","date":"2017-11-06","objectID":"/leetcode/0730/:3:0","tags":null,"title":"0730：统计不同回文子序列（★★★）","uri":"/leetcode/0730/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-11-01","objectID":"/leetcode/0725/:0:0","tags":null,"title":"0725：分隔链表（★）","uri":"/leetcode/0725/"},{"categories":null,"content":"题目 给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。 每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。 这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。 返回一个符合上述规则的链表的列表。 提示: root 的长度范围： [0, 1000]. 输入的每个节点的大小范围：[0, 999]. k 的取值范围： [1, 50]. 示例 1： 输入: root = [1, 2, 3], k = 5\r输出: [[1],[2],[3],[],[]]\r解释:\r输入输出各部","date":"2017-11-01","objectID":"/leetcode/0725/:1:0","tags":null,"title":"0725：分隔链表（★）","uri":"/leetcode/0725/"},{"categories":null,"content":"分析 先得到链表长度 n，应该平均分为 n // k 长度，但可能有余数 extra。根据题目要求，应该将前 extra 个链表的长度再分别加 1。 注意可能分为空链表，所以每轮从哑结点开始，防止越界。 ","date":"2017-11-01","objectID":"/leetcode/0725/:2:0","tags":null,"title":"0725：分隔链表（★）","uri":"/leetcode/0725/"},{"categories":null,"content":"解答 def splitListToParts(self, root: ListNode, k: int) -\u003e List[ListNode]: n, p = 0, root while p: n += 1 p = p.next avg, extra = divmod(n, k) res, p = [root], ListNode(next=root) for i in range(k-1): for _ in range(avg+(i\u003cextra)): p = p.next res.append(p.next) p.next = None p = ListNode(next=res[-1])","date":"2017-11-01","objectID":"/leetcode/0725/:3:0","tags":null,"title":"0725：分隔链表（★）","uri":"/leetcode/0725/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-10-31","objectID":"/leetcode/0724/:0:0","tags":null,"title":"0724：寻找数组的中心索引（★）","uri":"/leetcode/0724/"},{"categories":null,"content":"题目 给你一个整数数组 nums，请编写一个能够返回数组 “中心索引” 的方法。 数组 中心索引 是数组的一个索引，其左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，返回 -1 。如果数组有多个中心索引，应该返回最靠近左边的那一个。 注意：中心索引可能出现在数组的两端。 提示： 1 \u003c= nums.length \u003c= 10^4 -1000 \u003c= nums[i] \u003c= 1000 示例 1： 输入：nums = [1, 7, 3, 6, 5, 6]\r输出：3\r解释：\r中心索引是 3 。\r左侧数之和 (1 + 7 + 3 = 11)，\r右侧数之和 (5 + 6 = 11) ，","date":"2017-10-31","objectID":"/leetcode/0724/:1:0","tags":null,"title":"0724：寻找数组的中心索引（★）","uri":"/leetcode/0724/"},{"categories":null,"content":"分析 对于中心索引 i，sum(nums[:i])==sum(nums[i+1:])，等价于 sum(nums[:i])*2+nums[i]==sum(nums)。所以遍历 i 判断是否符合即可。 ","date":"2017-10-31","objectID":"/leetcode/0724/:2:0","tags":null,"title":"0724：寻找数组的中心索引（★）","uri":"/leetcode/0724/"},{"categories":null,"content":"解答 def pivotIndex(self, nums: List[int]) -\u003e int: s, pre = sum(nums), 0 for i, num in enumerate(nums): if pre*2+num == s: return i pre += num return -1 60 ms ","date":"2017-10-31","objectID":"/leetcode/0724/:3:0","tags":null,"title":"0724：寻找数组的中心索引（★）","uri":"/leetcode/0724/"},{"categories":null,"content":"题目 给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)， 其余元素是 emails 表示该账户的邮箱地址。 现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。 请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。 一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。 合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按字符 ASCII 顺序排列的邮箱地址。 账户本身可以以任意顺序返回。","date":"2017-10-28","objectID":"/leetcode/0721/:1:0","tags":null,"title":"0721：账户合并（★★）","uri":"/leetcode/0721/"},{"categories":null,"content":"分析 容易想到用并查集。如果账户 i 和 j 有共同邮箱，将 i 和 j 连通，最终每个连通子图即代表一个人。具体实现： 用字典 belong[email]=i 表示邮箱 email 属于账户 i\r遍历到账户 i，对于含有的每个邮箱 email：\r如果已在字典 belong 中，那么将 i 和 belong[email] 连通\r如果不在字典 belong 中，那么添加 belong[email]=i\r并查集连通后，连通子图中的账户有相同的祖先账号，因此可以遍历账户，将含有的邮箱都合并到祖先账号的邮箱中，最后输出所有祖先账号即可。 ","date":"2017-10-28","objectID":"/leetcode/0721/:2:0","tags":null,"title":"0721：账户合并（★★）","uri":"/leetcode/0721/"},{"categories":null,"content":"解答 def accountsMerge(self, accounts: List[List[str]]) -\u003e List[List[str]]: def find(i): if p[i] != i: p[i] = find(p[i]) return p[i] def union(i, j): p[find(i)] = find(j) n = len(accounts) p, belong = list(range(n)), {} for i in range(n): for email in accounts[i][1:]: if email in belong: union(i, belo","date":"2017-10-28","objectID":"/leetcode/0721/:3:0","tags":null,"title":"0721：账户合并（★★）","uri":"/leetcode/0721/"},{"categories":null,"content":"题目 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。 示例 1： 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\r输出：3\r解释：长度最长的公共子数组是 [3,2,1] 。\r示例 2： 输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\r输出：5\r提示： 1 \u003c= nums1.length, nums2.length \u003c= 1000 0 \u003c= nums1[i], nums2[i] \u003c= 100 ","date":"2017-10-25","objectID":"/leetcode/0718/:1:0","tags":null,"title":"0718：最长重复子数组（★★）","uri":"/leetcode/0718/"},{"categories":null,"content":"分析 ","date":"2017-10-25","objectID":"/leetcode/0718/:2:0","tags":null,"title":"0718：最长重复子数组（★★）","uri":"/leetcode/0718/"},{"categories":null,"content":"#1 令 dp[i][j] 代表最长的长度 size 使得 nums1[i-size:i]==nums2[j-size:j]，显然可以递推。 最后 dp 数组中的最大值即为所求。 def findLength(self, nums1: List[int], nums2: List[int]) -\u003e int: m, n = len(nums1), len(nums2) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): dp[i][j] = 0 if nums1[i-1] != ","date":"2017-10-25","objectID":"/leetcode/0718/:2:1","tags":null,"title":"0718：最长重复子数组（★★）","uri":"/leetcode/0718/"},{"categories":null,"content":"#2 还有个巧妙的方法，如果 nums1 和 nums2 存在长度 x 的公共子数组，那么对任意 y\u003cx，必然也存在长度 y 的公共子数组。 因此令 check(x) 代表 nums1 和 nums2 是否存在长度 x 的公共子数组，该函数具有单调性，可以二分查找最大的 x，即为所求。 具体实现 check(x) 时，可以用滚动哈希在 O(N+M) 时间得到 nums1 和 nums2 所有长 x 的子数组的哈希值，判断是否有交集即可。 元素种类最多 100，用到的窗口种类最多 10^4，因此考虑 base 取 113，mod 取 10^9+7 ","date":"2017-10-25","objectID":"/leetcode/0718/:2:2","tags":null,"title":"0718：最长重复子数组（★★）","uri":"/leetcode/0718/"},{"categories":null,"content":"解答 def findLength(self, nums1: List[int], nums2: List[int]) -\u003e int: def gen(A, L): ans, w, bL = set(), 0, pow(base, L, mod) for j, a in enumerate(A): w = w*base+a if j\u003e=L: w -= A[j-L]*bL w %= mod if j\u003e=L-1: ans.add(w) return ans base, mod = 113, 10**9+7 self.__class__.__getitem__ = lambda self, L: n","date":"2017-10-25","objectID":"/leetcode/0718/:3:0","tags":null,"title":"0718：最长重复子数组（★★）","uri":"/leetcode/0718/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-10-19","objectID":"/leetcode/0712/:0:0","tags":null,"title":"0712： 两个字符串的最小ASCII删除和（★★）","uri":"/leetcode/0712/"},{"categories":null,"content":"题目 给定两个字符串s1 和 s2，返回 使两个字符串相等所需删除字符的 ASCII 值的最小和 。 示例 1: 输入: s1 = \"sea\", s2 = \"eat\"\r输出: 231\r解释: 在 \"sea\" 中删除 \"s\" 并将 \"s\" 的值(115)加入总和。\r在 \"eat\" 中删除 \"t\" 并将 116 加入总和。\r结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。\r示例 2: 输入: s1 = \"delete\", s2 = \"leet\"\r输出: 403\r解释: 在 \"delete\" 中删除 \"dee\" 字符串变成 \"let\"，\r将 100[d]+101[e]+","date":"2017-10-19","objectID":"/leetcode/0712/:1:0","tags":null,"title":"0712： 两个字符串的最小ASCII删除和（★★）","uri":"/leetcode/0712/"},{"categories":null,"content":"分析 0583 升级版，修改下删除代价即可。 ","date":"2017-10-19","objectID":"/leetcode/0712/:2:0","tags":null,"title":"0712： 两个字符串的最小ASCII删除和（★★）","uri":"/leetcode/0712/"},{"categories":null,"content":"解答 def minimumDeleteSum(self, s1: str, s2: str) -\u003e int: m, n = len(s1), len(s2) dp = [0]+list(accumulate(map(ord, s2))) for c in s1: prev = dp[:] dp[0] += ord(c) for j in range(1, n+1): if s2[j-1]==c: dp[j] = prev[j-1] else: dp[j] = min(ord(c)+prev[j], ord(s2[j-1])+dp[j-1]) return dp[-1] 512 ms ","date":"2017-10-19","objectID":"/leetcode/0712/:3:0","tags":null,"title":"0712： 两个字符串的最小ASCII删除和（★★）","uri":"/leetcode/0712/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-10-17","objectID":"/leetcode/0710/:0:0","tags":null,"title":"0710：黑名单中的随机数（★★★）","uri":"/leetcode/0710/"},{"categories":null,"content":"题目 给定一个整数 n 和一个 无重复 黑名单整数数组 blacklist 。设计一种算法，从 [0, n - 1] 范围内的任意整数中选取一个 未加入 黑名单 blacklist 的整数。 任何在上述范围内且不在黑名单 blacklist 中的整数都应该有 同等的可能性 被返回。 优化你的算法，使它最小化调用语言 内置 随机函数的次数。 实现 Solution 类: Solution(int n, int[] blacklist) 初始化整数 n 和被加入黑名单 blacklist 的整数 int pick() 返回一个范围为 [0, n - 1] 且不在黑名单 blacklist 中的随机","date":"2017-10-17","objectID":"/leetcode/0710/:1:0","tags":null,"title":"0710：黑名单中的随机数（★★★）","uri":"/leetcode/0710/"},{"categories":null,"content":"分析 设数组 A=list(range(n))，要求的即是从 A 中随机选一个不在黑名单中的数。 为了方便随机，考虑将黑名单的数都交换到前面。设 m=len(blacklist)，交换完成后从 A[m:] 中随机选一个数即可。 但是 n 很大，直接构造 A 会超时。有个巧妙的想法是 A[m:] 中最多有 m 个数是经过了交换的，其它的就等于下标。 那么用哈希表 d 维护 A[m:] 中经过了交换的数，则对于任意 y\u003e=m，A[y]=d.get(y, y)。 因此随机取 \u003e=m 的下标 y，返回 d.get(y, y) 即可。 具体维护哈希表时，将 （黑名单中 \u003e=m 的数） 和 （[0,m) ","date":"2017-10-17","objectID":"/leetcode/0710/:2:0","tags":null,"title":"0710：黑名单中的随机数（★★★）","uri":"/leetcode/0710/"},{"categories":null,"content":"解答 class Solution: def __init__(self, n: int, blacklist: List[int]): m, vis = len(blacklist), set(blacklist) B = [y for y in vis if y\u003e=m] A = [x for x in range(m) if x not in vis] self.d = dict(zip(B, A)) self.n = n self.m = m def pick(self) -\u003e int: y = random.randint(self.m, self.n-1) return self.d","date":"2017-10-17","objectID":"/leetcode/0710/:3:0","tags":null,"title":"0710：黑名单中的随机数（★★★）","uri":"/leetcode/0710/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-10-14","objectID":"/leetcode/0707/:0:0","tags":null,"title":"0707：设计链表（★★）","uri":"/leetcode/0707/"},{"categories":null,"content":"题目 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。 val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表， 则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后","date":"2017-10-14","objectID":"/leetcode/0707/:1:0","tags":null,"title":"0707：设计链表（★★）","uri":"/leetcode/0707/"},{"categories":null,"content":"分析 先定义节点 ListNode，然后再设计链表。需要经常判断索引是否有效，因此可以维护链表的长度。 ","date":"2017-10-14","objectID":"/leetcode/0707/:2:0","tags":null,"title":"0707：设计链表（★★）","uri":"/leetcode/0707/"},{"categories":null,"content":"解答 class ListNode: def __init__(self, x=None, next=None): self.val = x self.next = next class MyLinkedList: def __init__(self): self.size = 0 self.dummy = ListNode() def get(self, index: int) -\u003e int: if index \u003c 0 or index \u003e= self.size: return -1 p = self.dummy for _ in range(index+1): p = p.next ret","date":"2017-10-14","objectID":"/leetcode/0707/:3:0","tags":null,"title":"0707：设计链表（★★）","uri":"/leetcode/0707/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-10-13","objectID":"/leetcode/0706/:0:0","tags":null,"title":"0706：设计哈希映射（★）","uri":"/leetcode/0706/"},{"categories":null,"content":"题目 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。 实现 MyHashMap 类： MyHashMap() 用空映射初始化对象 void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。 如果 key 已经存在于映射中，则更新其对应的值 value 。 int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。 void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。 进阶：你能否不使用内置的 ","date":"2017-10-13","objectID":"/leetcode/0706/:1:0","tags":null,"title":"0706：设计哈希映射（★）","uri":"/leetcode/0706/"},{"categories":null,"content":"分析 类似 0705，只不过要将 key 和 value 一起存储。 ","date":"2017-10-13","objectID":"/leetcode/0706/:2:0","tags":null,"title":"0706：设计哈希映射（★）","uri":"/leetcode/0706/"},{"categories":null,"content":"解答 class MyHashMap: def __init__(self): self.size = 1009 self.A = [[] for _ in range(self.size)] def put(self, key: int, value: int) -\u003e None: arr = self.A[key % self.size] for pair in arr: if pair[0] == key: pair[1] = value return arr.append([key, value]) def get(self, key: int) -\u003e int: for pair in ","date":"2017-10-13","objectID":"/leetcode/0706/:3:0","tags":null,"title":"0706：设计哈希映射（★）","uri":"/leetcode/0706/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-10-12","objectID":"/leetcode/0705/:0:0","tags":null,"title":"0705：设计哈希集合（★）","uri":"/leetcode/0705/"},{"categories":null,"content":"题目 不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： void add(key) 向哈希集合中插入值 key 。 bool contains(key) 返回哈希集合中是否存在这个值 key 。 void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 你可以不使用内建的哈希集合库解决此问题吗？ 提示： 0 \u003c= key \u003c= 10^6 最多调用 10^4 次 add、remove 和 contains 。 示例： 输入：\r[\"MyHashSet\", \"add\", \"add\", \"contains\"","date":"2017-10-12","objectID":"/leetcode/0705/:1:0","tags":null,"title":"0705：设计哈希集合（★）","uri":"/leetcode/0705/"},{"categories":null,"content":"分析 ","date":"2017-10-12","objectID":"/leetcode/0705/:2:0","tags":null,"title":"0705：设计哈希集合（★）","uri":"/leetcode/0705/"},{"categories":null,"content":"#1 key 的范围较小，可以直接用一个数组一一对应。 class MyHashSet: def __init__(self): self.A = [False] * (10**6+1) def add(self, key: int) -\u003e None: self.A[key] = True def remove(self, key: int) -\u003e None: self.A[key] = False def contains(self, key: int) -\u003e bool: return self.A[key] 268 ms ","date":"2017-10-12","objectID":"/leetcode/0705/:2:1","tags":null,"title":"0705：设计哈希集合（★）","uri":"/leetcode/0705/"},{"categories":null,"content":"#2 一般哈希表会用更小的空间来存储，这时要考虑冲突的情况。最简单的就是拉链法。 ","date":"2017-10-12","objectID":"/leetcode/0705/:2:2","tags":null,"title":"0705：设计哈希集合（★）","uri":"/leetcode/0705/"},{"categories":null,"content":"解答 class MyHashSet: def __init__(self): self.size = 1009 self.A = [[] for _ in range(self.size)] def add(self, key: int) -\u003e None: if not self.contains(key): self.A[key%self.size].append(key) def remove(self, key: int) -\u003e None: if self.contains(key): self.A[key%self.size].remove(key) def contains(sel","date":"2017-10-12","objectID":"/leetcode/0705/:3:0","tags":null,"title":"0705：设计哈希集合（★）","uri":"/leetcode/0705/"},{"categories":null,"content":"「如果有妹妹的话就能拥有最棒的人生了，为什么我却没有妹妹呢……？」\n专写妹系作品的妹控小说家羽岛伊月，身边聚集着各式各样不同个性的人物。有天才变态作家可儿那由多、女大学生白川京、插画家屁桃，以及鬼畜税务师大野艾希莉等等。\n伊月等人虽然各自有着不同的烦恼，但还是一边写着小说，玩着电玩，喝着酒，申报所得税，过着喧闹的日常生活。\n在一旁温暖守护着伊月等人的，是伊月的继弟千寻。然而，千寻竟藏着一个天大的秘密……\n欢乐又锥心，由天才、凡人与怪咖所展开的多重路线青春恋爱喜剧，现在开演！","date":"2017-10-08","objectID":"/anime/a_sisters_all_you_need/","tags":null,"title":"如果有妹妹就好了。","uri":"/anime/a_sisters_all_you_need/"},{"categories":null,"content":"简介 「如果有妹妹的话就能拥有最棒的人生了，为什么我却没有妹妹呢……？」 专写妹系作品的妹控小说家羽岛伊月，身边聚集着各式各样不同个性的人物。有天才变态作家可儿那由多、女大学生白川京、插画家屁桃，以及鬼畜税务师大野艾希莉等等。 伊月等人虽然各自有着不同的烦恼，但还是一边写着小说，玩着电玩，喝着酒，申报所得税，过着喧闹的日常生活。 在一旁温暖守护着伊月等人的，是伊月的继弟千寻。然而，千寻竟藏着一个天大的秘密…… 欢乐又锥心，由天才、凡人与怪咖所展开的多重路线青春恋爱喜剧，现在开演！ 制作人员： 原作：平坂读 导演：大沼心 分镜：宇根信也、渡边慎一、二瓶勇一、玉村仁、泽井幸次、凑未来 ","date":"2017-10-08","objectID":"/anime/a_sisters_all_you_need/:1:0","tags":null,"title":"如果有妹妹就好了。","uri":"/anime/a_sisters_all_you_need/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 羽岛伊月 はしま いつき、Hashima Itsuki 男 小林裕介 2 羽岛千寻 はしま ちひろ、Hashima Chihiro 女 山本希望 3 可儿那由多 かに なゆた、Kani Nayuta、螃蟹公、本田和子、ほんでんかずこ、羽岛和子 女 金元寿子 4 白川京 しらかわ みやこ、Shirakawa Miyako 女 加隈亜衣 5 不破春斗 松尾晴彦、ふわ はると、Fuwa Haruto 男 日野聡 6 土岐健次郎 とき けんじろう、Toki Kenjirō 男 鳥海浩輔 7 惠那刹那 恵那 刹那、えな せつな、Ena Setsuna 男 代永翼 8 ","date":"2017-10-08","objectID":"/anime/a_sisters_all_you_need/:2:0","tags":null,"title":"如果有妹妹就好了。","uri":"/anime/a_sisters_all_you_need/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 如果有妹妹就好了。 2017-10-08 12 樱花 ","date":"2017-10-08","objectID":"/anime/a_sisters_all_you_need/:3:0","tags":null,"title":"如果有妹妹就好了。","uri":"/anime/a_sisters_all_you_need/"},{"categories":null,"content":"这是成长的故事——\n宝石中最年少的磷叶石，仅有3.5的脆弱硬度，韧性也很弱，因而不适于战斗。此外，也没有对其他工作的适应性。被看做是只会出一张嘴，完完全全的吊车尾。这样的磷叶石，在即将满三百岁时终于被交付了第一件工作。那是，名为编纂博物志的工作。磷叶石对这不起眼的工作感到不满，但他在通过自己的双眼看见世界，经历各种各样事情的同时，接连被巨大的波澜吞没。之后，他终于获得了梦寐以求的“强大”，却并非是以自己所期望的形式——\n\n这是友情的故事——\n拥有比磷叶石更为特殊的体质的辰砂。仅仅是在那里，身体就会散播毒液的辰砂，为了不给周围人添麻烦，而在夜晚独自将自己关在室内，并封锁了心灵。某天，就在即将被月人掳走时被辰砂所救的磷叶石，和他做了“接下来就该我来救你了”的约定。磷叶石一边为编纂博物志而奔走，一边为了将辰砂带往光明的世界而寻找着适合他的工作。究竟磷叶石的想法能否传达给辰砂呢？两人的约定究竟会不会有实现的一天呢——？\n\n这是战斗的故事——\n从月球飞来的神秘敌人“月人”。他们将宝石作为装饰品，特别中意美丽的宝石，将宝石们一个接一个地掳走，真实身份不明。而且被掳走的宝石被加工成为武器，反过来加害于宝石。得到月人的不断改良，变得更加强力。面对接连现身的月人，二十八位宝石能否赢得胜利？他们的真正目的是什么？这场无止境的战斗，能否画下终止符？","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"简介 这是成长的故事—— 宝石中最年少的磷叶石，仅有3.5的脆弱硬度，韧性也很弱，因而不适于战斗。此外，也没有对其他工作的适应性。被看做是只会出一张嘴，完完全全的吊车尾。这样的磷叶石，在即将满三百岁时终于被交付了第一件工作。那是，名为编纂博物志的工作。磷叶石对这不起眼的工作感到不满，但他在通过自己的双眼看见世界，经历各种各样事情的同时，接连被巨大的波澜吞没。之后，他终于获得了梦寐以求的“强大”，却并非是以自己所期望的形式—— 这是友情的故事—— 拥有比磷叶石更为特殊的体质的辰砂。仅仅是在那里，身体就会散播毒液的辰砂，为了不给周围人添麻烦，而在夜晚独自将自己关在室内，并封锁了心灵。某天，就在即将","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/:1:0","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 磷叶石 法斯、Phosphophyllite 黒沢ともよ 2 辰砂 朱砂、Cinnabar 小松未可子 3 钻石 Diamond 茅野愛衣 4 圆粒金刚石 波尔茨、Bort 佐倉綾音 5 摩根石 Morganite 田村睦心 6 透绿柱石 Goshenite 早見沙織 7 金红石 Rutile 内山夕実 8 翡翠 Jade 高垣彩陽 ","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/:2:0","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 宝石之国 2017-10-07 12 bilibili ","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/:3:0","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"MAD ","date":"2017-10-07","objectID":"/anime/land_of_the_lustrous/:4:0","tags":null,"title":"宝石之国","uri":"/anime/land_of_the_lustrous/"},{"categories":null,"content":"距离极尽繁荣与荣华的人类文明迎来末日，已经经过了漫长的岁月。人类几乎死绝，就连生物都消失的迎来末日的世界。复杂建造的都市化作宛如迷宫的废墟，无从整备的机械也渐渐停止了动作。是何时结束的呢，是从何时开始结束的呢，就连这种想法也不复存在的终末世界中，有两位少女漫无目的地持续着旅行。千户与尤莉，今天也乘着爱车Kettenkrad，在废墟当中彷徨。\n在终末世界中温暖地求生的后启示录幻想剧，就此开幕。","date":"2017-10-06","objectID":"/anime/girls_last_tour/","tags":null,"title":"少女终末旅行","uri":"/anime/girls_last_tour/"},{"categories":null,"content":"简介 距离极尽繁荣与荣华的人类文明迎来末日，已经经过了漫长的岁月。人类几乎死绝，就连生物都消失的迎来末日的世界。复杂建造的都市化作宛如迷宫的废墟，无从整备的机械也渐渐停止了动作。是何时结束的呢，是从何时开始结束的呢，就连这种想法也不复存在的终末世界中，有两位少女漫无目的地持续着旅行。千户与尤莉，今天也乘着爱车Kettenkrad，在废墟当中彷徨。 在终末世界中温暖地求生的后启示录幻想剧，就此开幕。 制作人员： 原作：月水 导演：尾崎隆晴 脚本：笔安一幸 分镜：迫井政行、小泽一浩、川村贤一 演出：三上喜子 ","date":"2017-10-06","objectID":"/anime/girls_last_tour/:1:0","tags":null,"title":"少女终末旅行","uri":"/anime/girls_last_tour/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 千户 千都、Chito 女 水瀬いのり 2 尤莉 优梨、Yūri 女 久保ユリカ 3 金泽 Kanazawa 男 石田彰 4 石井 Ishii 女 三石琴乃 5 自律机械 じりつ きかい、Jiritsu-kikai 梶裕貴 6 锚 猫、Nuko 花澤香菜 ","date":"2017-10-06","objectID":"/anime/girls_last_tour/:2:0","tags":null,"title":"少女终末旅行","uri":"/anime/girls_last_tour/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 少女终末旅行 2017-10-06 12 bilibili ","date":"2017-10-06","objectID":"/anime/girls_last_tour/:3:0","tags":null,"title":"少女终末旅行","uri":"/anime/girls_last_tour/"},{"categories":null,"content":"题目 给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例 1： 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4\r输出： True\r说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。\r示例 2: 输入: nums = [1,2,3,4], k = 3\r输出: false\r提示： 1 \u003c= k \u003c= len(nums) \u003c= 16 0 \u003c nums[i] \u003c 10000 每个元素的频率在 [1,4] 范围内 ","date":"2017-10-05","objectID":"/leetcode/0698/:1:0","tags":null,"title":"0698：划分为k个相等的子集（★★★）","uri":"/leetcode/0698/"},{"categories":null,"content":"分析 0473 升级版，将 4 改为 k 即可。 ","date":"2017-10-05","objectID":"/leetcode/0698/:2:0","tags":null,"title":"0698：划分为k个相等的子集（★★★）","uri":"/leetcode/0698/"},{"categories":null,"content":"解答 def canPartitionKSubsets(self, nums: List[int], k: int) -\u003e bool: s = sum(nums) if s%k: return False n, t = len(nums), s//k dp = [0]+[-1]*((1\u003c\u003cn)-1) for st in range(1\u003c\u003cn): if dp[st]\u003e=0: for i in range(n): if not st\u0026(1\u003c\u003ci) and dp[st]+nums[i]\u003c=t: dp[st|(1\u003c\u003ci)] = (dp[st]+nums[i])%t return dp[-1]==0 1","date":"2017-10-05","objectID":"/leetcode/0698/:3:0","tags":null,"title":"0698：划分为k个相等的子集（★★★）","uri":"/leetcode/0698/"},{"categories":null,"content":"       高中三年级的冬天、剩下没多久的高中生活，大家都认为会在毫无变化的情况下迎来毕业之日……但在某一天，他突然回来了，在中学时搬到遥远城镇的同学，变成不合时节的转学生再次相会，伴随着某种不确定的感情、转变开始的信号微弱的发出了声响……","date":"2017-10-05","objectID":"/anime/just_because/","tags":null,"title":"Just Because!","uri":"/anime/just_because/"},{"categories":null,"content":"简介 高中三年级的冬天、剩下没多久的高中生活，大家都认为会在毫无变化的情况下迎来毕业之日……但在某一天，他突然回来了，在中学时搬到遥远城镇的同学，变成不合时节的转学生再次相会，伴随着某种不确定的感情、转变开始的信号微弱的发出了声响…… 制作人员： 导演：小林敦 脚本：鸭志田一 分镜：吉田泰三、羽多野浩平、冲田宫奈、长井春树、川畑荣郎、林直孝 ","date":"2017-10-05","objectID":"/anime/just_because/:1:0","tags":null,"title":"Just Because!","uri":"/anime/just_because/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 泉瑛太 いずみ えいた、Izumi Eita 男 市川蒼 2 夏目美绪 なつめ みお、Natsume Mio 女 礒部花凜 3 相马阳斗 そうま ようと、Sōma Haruto 男 村田太志 4 森川叶月 もりかわ はつき、Morikawa Hazuki 女 芳野由奈 5 小宫惠那 こみや えな、Komiya Ena 女 Lynn 6 乾依子 Inui Yoriko 女 櫻庭有紗 7 高桥早苗 Takahashi Sanae 女 貫井柚佳 8 铃木桃花 Suzuki Momoka 女 近藤玲奈 ","date":"2017-10-05","objectID":"/anime/just_because/:2:0","tags":null,"title":"Just Because!","uri":"/anime/just_because/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Just Because! 2017-10-05 12 bilibili ","date":"2017-10-05","objectID":"/anime/just_because/:3:0","tags":null,"title":"Just Because!","uri":"/anime/just_because/"},{"categories":null,"content":"每十二年举办一次的，第十二回“十二大战”。\n持有干支之名的十二名狞猛战士，以自己的性命与灵魂为赌注的战斗。\n参加者是『子』『丑』『寅』『卯』『辰』『巳』『午』『未』『申』『酉』『戌』『亥』的十二位异样的战士们。\n\n摘得这场战争的胜果的人，任何愿望都可以成真，但数额只有一个。\n无论如何都想要成真的、那仅此一个的愿望——\n\n最后活下来的会是谁？在谋策与杀戮的战场漩涡之中，流下的是谁的泪水？\n震撼灵魂的盛大战斗，即将开战。","date":"2017-10-03","objectID":"/anime/juni_taisen/","tags":null,"title":"十二大战","uri":"/anime/juni_taisen/"},{"categories":null,"content":"简介 每十二年举办一次的，第十二回“十二大战”。 持有干支之名的十二名狞猛战士，以自己的性命与灵魂为赌注的战斗。 参加者是『子』『丑』『寅』『卯』『辰』『巳』『午』『未』『申』『酉』『戌』『亥』的十二位异样的战士们。 摘得这场战争的胜果的人，任何愿望都可以成真，但数额只有一个。 无论如何都想要成真的、那仅此一个的愿望—— 最后活下来的会是谁？在谋策与杀戮的战场漩涡之中，流下的是谁的泪水？ 震撼灵魂的盛大战斗，即将开战。 制作人员： 原作：西尾维新 导演：细田直人 脚本：高桥龙也、高木登、山田哲弥、村井贞之 分镜：牧原亮太郎、原博 ","date":"2017-10-03","objectID":"/anime/juni_taisen/:1:0","tags":null,"title":"十二大战","uri":"/anime/juni_taisen/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 寝住 ねずみ、墨野継義（すみの つぎよし） 男 堀江瞬 2 失井 うしい、樫井栄児（かしい えいじ） 男 梅原裕一郎 3 妬良 姶良香奈江（あいら かなえ）、とら 女 五十嵐裕美 4 郁城 うさぎ 男 岡本信彦 5 断罪·兄 積田長幸（つみた ながゆき）、たつみ 男 江口拓也 6 断罪·弟 積田剛保（つみた たけやす）、たつみ 男 鳥海浩輔 7 迂迂真 早間好実（そうま よしみ）、ううま 男 緑川光 8 必爷 辻家純彦（つじいえ すみひこ）、ひつじい 男 チョー ","date":"2017-10-03","objectID":"/anime/juni_taisen/:2:0","tags":null,"title":"十二大战","uri":"/anime/juni_taisen/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 十二大战 2017-10-03 12 樱花 ","date":"2017-10-03","objectID":"/anime/juni_taisen/:3:0","tags":null,"title":"十二大战","uri":"/anime/juni_taisen/"},{"categories":null,"content":"题目 给定一个包含了一些 0 和 1 的非空二维数组 grid 。 一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。 你可以假设 grid 的四个边缘都被 0（代表水）包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。) 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0],\r[0,0,0,0,0,0,0,1,1,1,0,0,0],\r[0,1,1,0,1,0,0,0,0,0,0,0,0],\r[0,1,0,0,1,1,0,0","date":"2017-10-02","objectID":"/leetcode/0695/:1:0","tags":null,"title":"0695：岛屿的最大面积（★★）","uri":"/leetcode/0695/"},{"categories":null,"content":"分析 ","date":"2017-10-02","objectID":"/leetcode/0695/:2:0","tags":null,"title":"0695：岛屿的最大面积（★★）","uri":"/leetcode/0695/"},{"categories":null,"content":"#1 类似 0200，只不过从求岛屿数量换成求最大岛屿。 遍历时记录面积即可。 def maxAreaOfIsland(self, grid: List[List[int]]) -\u003e int: def dfs(i, j): cnt, grid[i][j] = 1, 'M' for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n and grid[x][y] == 1: cnt += dfs(x, y) return cnt res, m, n = 0, len(grid","date":"2017-10-02","objectID":"/leetcode/0695/:2:1","tags":null,"title":"0695：岛屿的最大面积（★★）","uri":"/leetcode/0695/"},{"categories":null,"content":"#2 也可以用并查集，将相邻的陆地连通。最终统计陆地连通块的大小即可。 ","date":"2017-10-02","objectID":"/leetcode/0695/:2:2","tags":null,"title":"0695：岛屿的最大面积（★★）","uri":"/leetcode/0695/"},{"categories":null,"content":"解答 def maxAreaOfIsland(self, grid: List[List[int]]) -\u003e int: def find(x): if f.setdefault(x, x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) f, m, n = {}, len(grid), len(grid[0]) for i, j in product(range(m), range(n)): if i and grid[i - 1][j] == grid[i][j] == 1: union((i","date":"2017-10-02","objectID":"/leetcode/0695/:3:0","tags":null,"title":"0695：岛屿的最大面积（★★）","uri":"/leetcode/0695/"},{"categories":null,"content":"题目 我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。 您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。 如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。 返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。 注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的， 并且 target 被选择为两个随机单词的连接。 示例 1： 输入： stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\r输出：3\r解释：\r","date":"2017-09-28","objectID":"/leetcode/0691/:1:0","tags":null,"title":"0691：贴纸拼词（★★）","uri":"/leetcode/0691/"},{"categories":null,"content":"分析 按 target[0] 由哪个贴纸切割可以转为递归子问题。 本质上是完全背包问题 ","date":"2017-09-28","objectID":"/leetcode/0691/:2:0","tags":null,"title":"0691：贴纸拼词（★★）","uri":"/leetcode/0691/"},{"categories":null,"content":"解答 def minStickers(self, stickers: List[str], target: str) -\u003e int: @lru_cache(None) def dfs(t): if not t: return 0 res = float('inf') for ct in A: if t[0] in ct: new = t for x in ct: new = new.replace(x, '', ct[x]) res = min(res, 1+dfs(new)) return res A = [Counter(s) for s in stickers] res = dfs(ta","date":"2017-09-28","objectID":"/leetcode/0691/:3:0","tags":null,"title":"0691：贴纸拼词（★★）","uri":"/leetcode/0691/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、 且全部数字和（3 * k 项）最大的子数组，并返回这三个子数组。 以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。 如果有多个结果，返回字典序最小的一个。 示例 1： 输入：nums = [1,2,1,2,6,7,5,1], k = 2\r输出：[0,3,5]\r解释：子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。\r也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。\r示例 2： 输入：nums = [1,","date":"2017-09-26","objectID":"/leetcode/0689/:1:0","tags":null,"title":"0689：三个无重叠子数组的最大和（★★）","uri":"/leetcode/0689/"},{"categories":null,"content":"分析 令 A[i] 代表 sum(nums[i:i+k])，问题转为求满足 x+k\u003c=y\u003c=z-k 的最大的 A[x]+A[y]+A[z]。 那么遍历 y，求 max(A[:y-k+1])+y+max(A[y+k:]) 即可。 令 left[i] 代表 max(A[:i+1])，right[i] 代表 max(A[i:])，都可以 O(N) 递推得到。 因为要返回下标位置，所以修改下，令 left 和 right 返回最大值对应的最小下标即可。 ","date":"2017-09-26","objectID":"/leetcode/0689/:2:0","tags":null,"title":"0689：三个无重叠子数组的最大和（★★）","uri":"/leetcode/0689/"},{"categories":null,"content":"解答 def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -\u003e List[int]: pre = list(accumulate([0]+nums)) A = [pre[i+k]-pre[i] for i in range(len(pre)-k)] n = len(A) left, right = list(range(n)), list(range(n)) for i in range(1, n): left[i] = i if A[i]\u003eA[left[i-1]] else left[i-1] for i in range(n-","date":"2017-09-26","objectID":"/leetcode/0689/:3:0","tags":null,"title":"0689：三个无重叠子数组的最大和（★★）","uri":"/leetcode/0689/"},{"categories":null,"content":"题目 在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。 行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。 象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。 每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。 骑士继续移动，直到它走了 k 步或离开了棋盘。 返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。 示例 1： 输入: n = 3, k = 2, row = 0, col","date":"2017-09-25","objectID":"/leetcode/0688/:1:0","tags":null,"title":"0688：骑士在棋盘上的概率（★★）","uri":"/leetcode/0688/"},{"categories":null,"content":"分析 按第一步的移动方向即可转为递归子问题。 ","date":"2017-09-25","objectID":"/leetcode/0688/:2:0","tags":null,"title":"0688：骑士在棋盘上的概率（★★）","uri":"/leetcode/0688/"},{"categories":null,"content":"解答 def knightProbability(self, n: int, k: int, row: int, column: int) -\u003e float: @lru_cache(None) def dfs(i, j, k): if not (0\u003c=i\u003cn and 0\u003c=j\u003cn): return 0 if k == 0: return 1 return sum(dfs(i+dx, j+dy, k-1) for dx, dy in A)/len(A) A = [(1, 2), (-1, 2), (1, -2), (-1, -2), (2, 1), (-2, 1), (2, -1), (-2, ","date":"2017-09-25","objectID":"/leetcode/0688/:3:0","tags":null,"title":"0688：骑士在棋盘上的概率（★★）","uri":"/leetcode/0688/"},{"categories":null,"content":"题目 给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。 注意：字符串 “abc” 重复叠加 0 次是 “\"，重复叠加 1 次是 “abc”，重复叠加 2 次是 “abcabc”。 示例 1： 输入：a = \"abcd\", b = \"cdabcdab\"\r输出：3\r解释：a 重复叠加三遍后为 \"abcdabcdabcd\", 此时 b 是其子串。\r示例 2： 输入：a = \"a\", b = \"aa\"\r输出：2\r示例 3： 输入：a = \"a\", b = \"a\"\r输出：1\r示例 4： 输入：a = \"abc\", b","date":"2017-09-23","objectID":"/leetcode/0686/:1:0","tags":null,"title":"0686：重复叠加字符串匹配（★★）","uri":"/leetcode/0686/"},{"categories":null,"content":"分析 假设 b 是叠加 a 的子串，且 b[0] 匹配 a[i]， 那么根据 i 的范围可知 a 叠加后的长度最少 len(b)，最多 len(a)-1+len(b)。 因此令 k=len(b)//len(a)，那么 a 最少叠加 k 次，最多叠加 k+2 次，逐个判断即可。 ","date":"2017-09-23","objectID":"/leetcode/0686/:2:0","tags":null,"title":"0686：重复叠加字符串匹配（★★）","uri":"/leetcode/0686/"},{"categories":null,"content":"解答 def repeatedStringMatch(self, a: str, b: str) -\u003e int: m, n = len(a), len(b) for x in range(n//m, n//m+3): if b in a*x: return x return -1 36 ms ","date":"2017-09-23","objectID":"/leetcode/0686/:3:0","tags":null,"title":"0686：重复叠加字符串匹配（★★）","uri":"/leetcode/0686/"},{"categories":null,"content":"题目 在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。 该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。 输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。 附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边， 其中 ui 是 vi 的一个父节点。 返回一条能删除的边，使得剩下的图是有 n 个节点的有根","date":"2017-09-22","objectID":"/leetcode/0685/:1:0","tags":null,"title":"0685：冗余连接 II（★★★）","uri":"/leetcode/0685/"},{"categories":null,"content":"分析 显然有根树等价于 所有节点连通，且只有一个节点入度为 0，其它节点入度都为 1。输入的图有两种情况： 多余的边指向根节点 图中所有节点的入度都为 1 ，形成一个环，而且去掉环中任意一条边都可以\r多余的边指向其它节点 v 图中只有节点 v 的入度为 2，应该选择一条指向 v 的边去掉使得剩下的所有节点连通\r因此可以先遍历边，统计入度，若有节点 v 的入度为 2，先用并查集判断删除第二条指向 v 的边是否满足条件，不满足就应该删除第一条。 若没有节点 v 的入度为 2，转为 0684 。 ","date":"2017-09-22","objectID":"/leetcode/0685/:2:0","tags":null,"title":"0685：冗余连接 II（★★★）","uri":"/leetcode/0685/"},{"categories":null,"content":"解答 def findRedundantDirectedConnection(self, edges: List[List[int]]) -\u003e List[int]: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) def isvalid(u, v): for x, y in edges: if (x, y) != (u, v): union(x - 1, y - 1) return sum(find(i)==i for i in range(n)) ==","date":"2017-09-22","objectID":"/leetcode/0685/:3:0","tags":null,"title":"0685：冗余连接 II（★★★）","uri":"/leetcode/0685/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-09-21","objectID":"/leetcode/0684/:0:0","tags":null,"title":"0684：冗余连接（★★）","uri":"/leetcode/0684/"},{"categories":null,"content":"题目 在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。 附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u \u003c v， 表示连接顶点u 和v的无向图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案， 则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u \u003c v。 示例 1： 输入: [[1,2], [1,3], [2,3]]\r输出: [2,3]\r解释: ","date":"2017-09-21","objectID":"/leetcode/0684/:1:0","tags":null,"title":"0684：冗余连接（★★）","uri":"/leetcode/0684/"},{"categories":null,"content":"分析 ","date":"2017-09-21","objectID":"/leetcode/0684/:2:0","tags":null,"title":"0684：冗余连接（★★）","uri":"/leetcode/0684/"},{"categories":null,"content":"#1 典型的并查集应用。遍历边，如果两个顶点已经连通则返回，否则就连通。 def findRedundantConnection(self, edges: List[List[int]]) -\u003e List[int]: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) f = list(range(len(edges) + 1)) for u, v in edges: if find(u) == find(v): return [u, v] union(u,","date":"2017-09-21","objectID":"/leetcode/0684/:2:1","tags":null,"title":"0684：冗余连接（★★）","uri":"/leetcode/0684/"},{"categories":null,"content":"#2 也可以用拓扑排序。先将所有入度为 1 的顶点入队。然后每轮弹出队首顶点，将所有后继顶点的入度减一， 并将其中所有入度为 1 的顶点入队。循环直到队空，剩下的环中的顶点的入度都大于 1， 返回最后一条剩下的边即可。 ","date":"2017-09-21","objectID":"/leetcode/0684/:2:2","tags":null,"title":"0684：冗余连接（★★）","uri":"/leetcode/0684/"},{"categories":null,"content":"解答 def findRedundantConnection(self, edges: List[List[int]]) -\u003e List[int]: n = len(edges) nxt, indeg = defaultdict(list), [0] * (n+1) for u, v in edges: nxt[u].append(v) nxt[v].append(u) indeg[u] += 1 indeg[v] += 1 queue = deque(u for u in range(1, n+1) if indeg[u]==1) while queue: u = queue.popleft","date":"2017-09-21","objectID":"/leetcode/0684/:3:0","tags":null,"title":"0684：冗余连接（★★）","uri":"/leetcode/0684/"},{"categories":null,"content":"题目 给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则： 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。 示例 1: 输入: \"()\"\r输出: True\r示例 2: 输入: \"(*)\"\r输出: True\r示例 3: 输入: \"(*))\"\r输出: True\r注意: 字符串大小将在 [1，100] 范围内。 ","date":"2017-09-15","objectID":"/leetcode/0678/:1:0","tags":null,"title":"0678：有效的括号字符串（★★★）","uri":"/leetcode/0678/"},{"categories":null,"content":"分析 先不考虑星号，那么类似 0032，可以得到不属于有效子串的括号的位置。 再考虑星号，要使得字符串变为有效，那么无效 ‘)’ 的左边必然有星号作为 ‘(’，无效 ‘(’ 的右边必然有星号作为 ‘)’。 因此再用一个栈维护星号的位置，遇到无效 ‘)’ 时弹出一个星号。最终判断栈里的无效 ‘(’ 是否都能分配一个处于右边的星号即可。 ","date":"2017-09-15","objectID":"/leetcode/0678/:2:0","tags":null,"title":"0678：有效的括号字符串（★★★）","uri":"/leetcode/0678/"},{"categories":null,"content":"解答 def checkValidString(self, s: str) -\u003e bool: stack, stack2 = [], [] for i, char in enumerate(s): if char == '(': stack.append(i) elif char == '*': stack2.append(i) elif stack: stack.pop() elif stack2: stack2.pop() else: return False while stack: if not stack2 or stack.pop() \u003e stack2.pop(): return ","date":"2017-09-15","objectID":"/leetcode/0678/:3:0","tags":null,"title":"0678：有效的括号字符串（★★★）","uri":"/leetcode/0678/"},{"categories":null,"content":"题目 实现一个 MapSum 类，支持两个方法，insert 和 sum： MapSum() 初始化 MapSum 对象 void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。 如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。 int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。 提示： 1 \u003c= key.length, prefix.length \u003c= 50 key 和 prefix 仅由小写英文字母组成 1 \u003c= val \u003c= 10","date":"2017-09-14","objectID":"/leetcode/0677/:1:0","tags":null,"title":"0677：键值映射（★★）","uri":"/leetcode/0677/"},{"categories":null,"content":"分析 ","date":"2017-09-14","objectID":"/leetcode/0677/:2:0","tags":null,"title":"0677：键值映射（★★）","uri":"/leetcode/0677/"},{"categories":null,"content":"#1 最简单的就是直接用哈希。计算 sum 时，遍历哈希中所有 key 判断是否以 prefix 开头即可。 class MapSum: def __init__(self): self.d = {} def insert(self, key: str, val: int) -\u003e None: self.d[key] = val def sum(self, prefix: str) -\u003e int: return sum(self.d[key] for key in self.d if key.startswith(prefix)) 36 ms ","date":"2017-09-14","objectID":"/leetcode/0677/:2:1","tags":null,"title":"0677：键值映射（★★）","uri":"/leetcode/0677/"},{"categories":null,"content":"#2 还可以用字典树优化时间。在 insert 时可以动态维护前缀对应的键值和（每个节点都新加一个 ‘val’ 属性来维护），计算 sum 时查询即可。 注意到 insert 时，若 key 已经存在，路径上所有的节点都需要更新 ‘val’ 的值。 ","date":"2017-09-14","objectID":"/leetcode/0677/:2:2","tags":null,"title":"0677：键值映射（★★）","uri":"/leetcode/0677/"},{"categories":null,"content":"解答 class MapSum: def __init__(self): T = lambda: defaultdict(T) self.trie = T() self.d = defaultdict(int) def insert(self, key: str, val: int) -\u003e None: diff = val - self.d[key] self.d[key] = val p = self.trie for char in key: p = p[char] p['val'] = p.get('val', 0) + diff def sum(self, prefix: str) -","date":"2017-09-14","objectID":"/leetcode/0677/:3:0","tags":null,"title":"0677：键值映射（★★）","uri":"/leetcode/0677/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-09-13","objectID":"/leetcode/0676/:0:0","tags":null,"title":"0676：实现一个魔法字典（★★）","uri":"/leetcode/0676/"},{"categories":null,"content":"题目 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。 实现 MagicDictionary 类： MagicDictionary() 初始化对象 void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同 bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母， ","date":"2017-09-13","objectID":"/leetcode/0676/:1:0","tags":null,"title":"0676：实现一个魔法字典（★★）","uri":"/leetcode/0676/"},{"categories":null,"content":"分析 因为单词的长度较短且只含小写字母，所以可以遍历所有能转换得到的单词，判断是否在字典中即可。 还有个巧妙的想法，可以将单词的某一位改为 ‘.’ 作为单词的 key。 例如 hit 的 key 为 ‘.it’、‘h.t’、‘hi.’。 那么先将字典中的单词按所有的 key 存在哈希表中，查询时找 key 相同且不同的单词即可。 ","date":"2017-09-13","objectID":"/leetcode/0676/:2:0","tags":null,"title":"0676：实现一个魔法字典（★★）","uri":"/leetcode/0676/"},{"categories":null,"content":"解答 class MagicDictionary: def __init__(self): self.d = defaultdict(set) def buildDict(self, dictionary: List[str]) -\u003e None: for word in dictionary: for i in range(len(word)): key = word[:i] + '.' + word[i+1:] self.d[key].add(word) def search(self, searchWord: str) -\u003e bool: for i in range(len(searchW","date":"2017-09-13","objectID":"/leetcode/0676/:3:0","tags":null,"title":"0676：实现一个魔法字典（★★）","uri":"/leetcode/0676/"},{"categories":null,"content":"题目 给定一个未排序的整数数组 nums ，返回最长递增子序列的个数 。 注意 这个数列必须是 严格 递增的。 示例 1: 输入: [1,3,5,4,7]\r输出: 2\r解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。\r示例 2: 输入: [2,2,2,2,2]\r输出: 5\r解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。\r提示: 1 \u003c= nums.length \u003c= 2000 -10^6 \u003c= nums[i] \u003c= 10^6 ","date":"2017-09-10","objectID":"/leetcode/0673/:1:0","tags":null,"title":"0673：最长递增子序列的个数（★★★）","uri":"/leetcode/0673/"},{"categories":null,"content":"分析 ","date":"2017-09-10","objectID":"/leetcode/0673/:2:0","tags":null,"title":"0673：最长递增子序列的个数（★★★）","uri":"/leetcode/0673/"},{"categories":null,"content":"#1 0300 的升级版，可以先求出 dp[j] 代表结尾位置 j 的最长递增子序列长度。 再令 dp2[j] 代表结尾位置 j 的最长递增子序列长度的个数，则： dp2[j] = sum(dp2[i] for i in range(j) if nums[i]\u003cnums[j] and dp[i]==dp[j]-1) or 1\r最终所有满足 dp[j]==max(dp) 的 dp2[j] 之和即为所求。 def findNumberOfLIS(self, nums: List[int]) -\u003e int: n = len(nums) dp, dp2 = [0]*n, [0]*n for j in ","date":"2017-09-10","objectID":"/leetcode/0673/:2:1","tags":null,"title":"0673：最长递增子序列的个数（★★★）","uri":"/leetcode/0673/"},{"categories":null,"content":"#2 0300 中能优化 dp 的递推。考虑能否优化 dp2 的递推。 注意到递推 dp2[j] 时，只需要满足 dp[i]==dp[j]-1 的位置 i。 考虑维护 B[x] 代表 dp[i]==x 的所有 \u003cnums[i],dp2[i]\u003e，问题转为求 sum(b for a,b in B[dp[j]-1] if a\u003cnums[j])。 然后将 \u003cnums[j],dp2[j]\u003e 添加到 B[dp[j]] 中即可维护 B。 注意到 B[x] 中的第一个元素必然是单调非减的，因此可以二分查找到第一个 pos 满足 B[dp[j]-1][pos][0]\u003cnums[j]，问题转为求 sum(b fo","date":"2017-09-10","objectID":"/leetcode/0673/:2:2","tags":null,"title":"0673：最长递增子序列的个数（★★★）","uri":"/leetcode/0673/"},{"categories":null,"content":"解答 def findNumberOfLIS(self, nums: List[int]) -\u003e int: B = [[(float('inf'), 0), (float('-inf'), 1)]] for num in nums: self.__class__.__getitem__ = lambda self, x: x==len(B) or B[x][-1][0]\u003e=num x = bisect_left(self, True, 0, len(B)) if x==len(B): B.append([(float('inf'), 0)]) self.__class__.__getitem_","date":"2017-09-10","objectID":"/leetcode/0673/:3:0","tags":null,"title":"0673：最长递增子序列的个数（★★★）","uri":"/leetcode/0673/"},{"categories":null,"content":"塔利班残酷统治下的阿富汗，平民百姓尤其是女性过着水深火热犹如地狱一般的生活。倔强的小女孩帕瓦娜（莎拉·乔德利 Saara Chaudry 配音）随父亲（Ali Rizvi Badshah 配音）外出挣钱养家，不仅目睹了父亲被昔日的学生辱骂羞辱，更和家人目击了父亲遭到非法逮捕的一幕。家中有病弱的母亲、成年的姐姐以及嗷嗷待哺的弟弟，年幼的帕瓦娜只能剪去秀发，伪装成男孩走出家门，踏上生死未卜的养家之路。在此过程中，她遇到了同样扮成男孩的昔日伙伴，也与一名沉默魁梧的塔利班分子成为朋友。当战争的阴影再度逼近时，帕瓦娜想方设法要找到下落不明的父亲，将他带回家中……  \n\n本片根据黛博拉·艾里斯的同名小说改编。","date":"2017-09-08","objectID":"/anime/the_breadwinner/","tags":null,"title":"养家之人","uri":"/anime/the_breadwinner/"},{"categories":null,"content":"简介 塔利班残酷统治下的阿富汗，平民百姓尤其是女性过着水深火热犹如地狱一般的生活。倔强的小女孩帕瓦娜（莎拉·乔德利 Saara Chaudry 配音）随父亲（Ali Rizvi Badshah 配音）外出挣钱养家，不仅目睹了父亲被昔日的学生辱骂羞辱，更和家人目击了父亲遭到非法逮捕的一幕。家中有病弱的母亲、成年的姐姐以及嗷嗷待哺的弟弟，年幼的帕瓦娜只能剪去秀发，伪装成男孩走出家门，踏上生死未卜的养家之路。在此过程中，她遇到了同样扮成男孩的昔日伙伴，也与一名沉默魁梧的塔利班分子成为朋友。当战争的阴影再度逼近时，帕瓦娜想方设法要找到下落不明的父亲，将他带回家中…… 本片根据黛博拉·艾里斯的同名小说改","date":"2017-09-08","objectID":"/anime/the_breadwinner/:1:0","tags":null,"title":"养家之人","uri":"/anime/the_breadwinner/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 养家之人 2017-09-08 01:32:55 樱花 ","date":"2017-09-08","objectID":"/anime/the_breadwinner/:2:0","tags":null,"title":"养家之人","uri":"/anime/the_breadwinner/"},{"categories":null,"content":"暑假，某个海边小镇。在烟花晚会之前，热热闹闹的聊着“升空的烟花从侧面看是圆的？还是平的？”这样的话题的同班同学。\n与此同时，典道暗恋着的荠，因为荠的母亲的再婚对象已确定所以要转学了。\n\n「我们私奔、吧」\n荠向典道发出了一起逃出小镇的邀请，却在那之前被母亲带走了。\n而典道只是眼睁睁地看着这一切。\n\n「如果，那时候我……」\n没有救下荠的典道，因为心中的苛责而丢出了荠在海中捡到的不可思议的珠子。就这样，不知何时起，时间被倒回到了荠被带走之前的时候……。\n一次又一次被重复的一天，荠与典道的命运会……？","date":"2017-08-18","objectID":"/anime/fireworks/","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"简介 暑假，某个海边小镇。在烟花晚会之前，热热闹闹的聊着“升空的烟花从侧面看是圆的？还是平的？”这样的话题的同班同学。 与此同时，典道暗恋着的荠，因为荠的母亲的再婚对象已确定所以要转学了。 「我们私奔、吧」 荠向典道发出了一起逃出小镇的邀请，却在那之前被母亲带走了。 而典道只是眼睁睁地看着这一切。 「如果，那时候我……」 没有救下荠的典道，因为心中的苛责而丢出了荠在海中捡到的不可思议的珠子。就这样，不知何时起，时间被倒回到了荠被带走之前的时候……。 一次又一次被重复的一天，荠与典道的命运会……？ 制作人员： 原作：岩井俊二 导演：武内宣之 脚本：大根仁 演出：铃木利正、宫本幸裕、城所圣明、塚田","date":"2017-08-18","objectID":"/anime/fireworks/:1:0","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 及川荠 及川奈砂、及川 なずな、おいかわ なずな、Oikawa Nazuna、及川菜津奈 女 広瀬すず 2 岛田典道 男 菅田将暉 3 安昙祐介 男 宮野真守 4 纯一 男 浅沼晋太郎 5 和弘 男 豊永利行 6 稔 男 梶裕貴 7 荠母亲的再婚对象 奈砂母亲的再婚对象 男 三木眞一郎 8 三浦老师 女 花澤香菜 ","date":"2017-08-18","objectID":"/anime/fireworks/:2:0","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 烟花 2017-08-18 01:30:00 bilibili ","date":"2017-08-18","objectID":"/anime/fireworks/:3:0","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"MAD ","date":"2017-08-18","objectID":"/anime/fireworks/:4:0","tags":null,"title":"烟花","uri":"/anime/fireworks/"},{"categories":null,"content":"题目 有台奇怪的打印机有以下两个特殊要求： 打印机每次只能打印由 同一个字符 组成的序列。 每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。 给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。 示例 1： 输入：s = \"aaabbb\"\r输出：2\r解释：首先打印 \"aaa\" 然后打印 \"bbb\"。\r示例 2： 输入：s = \"aba\"\r输出：2\r解释：首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 'a'。\r提示： 1 \u003c= s.length \u003c= 100 s 由小写英文字母组成 ","date":"2017-08-10","objectID":"/leetcode/0664/:1:0","tags":null,"title":"0664：奇怪的打印机（★★）","uri":"/leetcode/0664/"},{"categories":null,"content":"分析 显然连续相同的字符最后是一起打印的，考虑将连续相同的字符合并得到 s’，节省时间。 考虑字符 s[-1]，它要么单独打印，要么和前面相同的字符一起打印 假如 s[-1] 单独打印，显然转为递归子问题 假如 s[-1] 和 s[i] 一起打印 先打印了 s[:i+1] 部分，顺便将 s[-1] 一起打印了 然后打印 s[i+1:-1] 部分 这两部分都是递归子问题 因此令 dfs(s) 代表打印 s 的最小次数，即可递归。 ","date":"2017-08-10","objectID":"/leetcode/0664/:2:0","tags":null,"title":"0664：奇怪的打印机（★★）","uri":"/leetcode/0664/"},{"categories":null,"content":"解答 def strangePrinter(self, s: str) -\u003e int: @lru_cache(None) def dfs(s): if not s: return 0 res = 1+dfs(s[:-1]) for i in range(len(s)-2): if s[i]==s[-1]: res = min(res, dfs(s[:i+1])+dfs(s[i+1:-1])) return res s = ''.join(key for key, _ in groupby(s)) return dfs(s) 272 ms ","date":"2017-08-10","objectID":"/leetcode/0664/:3:0","tags":null,"title":"0664：奇怪的打印机（★★）","uri":"/leetcode/0664/"},{"categories":null,"content":"题目 最初记事本上只有一个字符 ‘A’ 。你每次可以对这个记事本进行两种操作： Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。 Paste（粘贴）：粘贴 上一次 复制的字符。 给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 ‘A’ 。 返回能够打印出 n 个 ‘A’ 的最少操作次数。 示例 1： 输入：3\r输出：3\r解释：\r最初, 只有一个字符 'A'。\r第 1 步, 使用 Copy All 操作。\r第 2 步, 使用 Paste 操作来获得 'AA'。\r第 3 步, 使用 Paste 操作来获得 'AAA'。\r示例 2： 输入：","date":"2017-07-26","objectID":"/leetcode/0650/:1:0","tags":null,"title":"0650：只有两个键的键盘（★★）","uri":"/leetcode/0650/"},{"categories":null,"content":"分析 操作必然是先复制再粘贴 k 次的形式。而这等价于将个数乘以 k+1。 因此可以将问题转化为，求 n 的一个因数分解形式，使得因数和最小。 根据代数知识可知，质因数分解形式的因数和最小，因此将 n 质因数分解即可。 ","date":"2017-07-26","objectID":"/leetcode/0650/:2:0","tags":null,"title":"0650：只有两个键的键盘（★★）","uri":"/leetcode/0650/"},{"categories":null,"content":"解答 def minSteps(self, n: int) -\u003e int: res = 0 for i in range(2, int(sqrt(n))+1): if n%i == 0: while n%i==0: n //= i res += i return res + (n if n\u003e1 else 0) 40 ms ","date":"2017-07-26","objectID":"/leetcode/0650/:3:0","tags":null,"title":"0650：只有两个键的键盘（★★）","uri":"/leetcode/0650/"},{"categories":null,"content":"题目 在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。 现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。 如果继承词有许多可以形成它的词根，则用最短的词根替换它。 你需要输出替换之后的句子。 提示： 1 \u003c= dictionary.length \u003c= 1000 1 \u003c= dictionary[i].length \u003c= 100 dictionary[i] 仅由小写字母组成。 1","date":"2017-07-24","objectID":"/leetcode/0648/:1:0","tags":null,"title":"0648：单词替换（★★）","uri":"/leetcode/0648/"},{"categories":null,"content":"分析 容易想到用前缀树，先将词根插入，并在末尾用 ‘#’ 标记。 再对句子的每个单词搜索最短词根，遍历前缀树找到第一个 ‘#’ 标记即可。 ","date":"2017-07-24","objectID":"/leetcode/0648/:2:0","tags":null,"title":"0648：单词替换（★★）","uri":"/leetcode/0648/"},{"categories":null,"content":"解答 def replaceWords(self, dictionary: List[str], sentence: str) -\u003e str: def find(word): p = trie for i, char in enumerate(word): if char not in p: return word p = p[char] if '#' in p: return word[:i+1] return word T = lambda: defaultdict(T) trie = T() for prefix in dictionary: reduce(dict.__getitem_","date":"2017-07-24","objectID":"/leetcode/0648/:3:0","tags":null,"title":"0648：单词替换（★★）","uri":"/leetcode/0648/"},{"categories":null,"content":"题目 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 输入：s = \"abc\" 输出：3 解释：三个回文子串: \"a\", \"b\", \"c\" 示例 2： 输入：s = \"aaa\" 输出：6 解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\" 提示： 1 \u003c= s.length \u003c= 1000 s 由小写英文字母组成 ","date":"2017-07-23","objectID":"/leetcode/0647/:1:0","tags":null,"title":"0647：回文子串（★★）","uri":"/leetcode/0647/"},{"categories":null,"content":"分析 ","date":"2017-07-23","objectID":"/leetcode/0647/:2:0","tags":null,"title":"0647：回文子串（★★）","uri":"/leetcode/0647/"},{"categories":null,"content":"#1 类似 0005，可以发现在用 区间 dp 或中心扩展法的过程中，即可得到所有的回文子串。 这里用中心扩展法。 def countSubstrings(self, s: str) -\u003e int: def expand(s, left, right): while left \u003e 0 and right \u003c len(s)-1 and s[left-1] == s[right+1]: left -= 1 right += 1 self.res += 1 self.res = len(s) for i in range(len(s)): expand(s, i, i) expand(s, i+1,","date":"2017-07-23","objectID":"/leetcode/0647/:2:1","tags":null,"title":"0647：回文子串（★★）","uri":"/leetcode/0647/"},{"categories":null,"content":"#2 还可以尝试经典的 Manacher 算法。 ","date":"2017-07-23","objectID":"/leetcode/0647/:2:2","tags":null,"title":"0647：回文子串（★★）","uri":"/leetcode/0647/"},{"categories":null,"content":"解答 def countSubstrings(self, s: str) -\u003e int: def expand(l, r): while l and r\u003clen(ss)-1 and ss[l-1]==ss[r+1]: l -= 1 r += 1 return (r-l)//2 res = 0 pair, ss = (0, 0), '#' + '#'.join(s) + '#' A, center, right = [], 0, 0 for i in range(len(ss)): min_arm = min(A[2*center-i], right-i) if right \u003e i else 0","date":"2017-07-23","objectID":"/leetcode/0647/:3:0","tags":null,"title":"0647：回文子串（★★）","uri":"/leetcode/0647/"},{"categories":null,"content":"题目 给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。 现在，我们定义一种跟随关系，当且仅当 b \u003c c 时，数对(c, d) 才可以跟在 (a, b) 后面。 我们用这种形式来构造一个数对链。 给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对， 你可以以任何顺序选择其中的一些数对来构造。 示例： 输入：[[1,2], [2,3], [3,4]] 输出：2 解释：最长的数对链是 [1,2] -\u003e [3,4] 提示： 给出数对的个数在 [1, 1000] 范围内。 ","date":"2017-07-22","objectID":"/leetcode/0646/:1:0","tags":null,"title":"0646：最长数对链（★★）","uri":"/leetcode/0646/"},{"categories":null,"content":"分析 类似 0435，贪心地选第二个数最小的数对即可。 ","date":"2017-07-22","objectID":"/leetcode/0646/:2:0","tags":null,"title":"0646：最长数对链（★★）","uri":"/leetcode/0646/"},{"categories":null,"content":"解答 def findLongestChain(self, pairs: List[List[int]]) -\u003e int: pairs.sort(key=lambda x: x[1]) res, end = 0, float('-inf') for s, e in pairs: if s\u003eend: res += 1 end = e return res 56 ms ","date":"2017-07-22","objectID":"/leetcode/0646/:3:0","tags":null,"title":"0646：最长数对链（★★）","uri":"/leetcode/0646/"},{"categories":null,"content":"题目 一条包含字母 A-Z 的消息通过以下的方式进行了 编码 ： 'A' -\u003e \"1\"\r'B' -\u003e \"2\"\r...\r'Z' -\u003e \"26\"\r要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。 例如，“11106” 可以映射为： “AAJF” 对应分组 (1 1 10 6) “KJF” 对应分组 (11 10 6) 注意，像 (1 11 06) 这样的分组是无效的，因为 “06” 不可以映射为 ‘F’ ，因为 “6” 与 “06” 不同。 除了 上面描述的数字字母映射方案，编码消息中可能包含 ‘’ 字符，可以表示从 ‘1’ 到 ‘9’ 的","date":"2017-07-15","objectID":"/leetcode/0639/:1:0","tags":null,"title":"0639：解码方法 II（★★）","uri":"/leetcode/0639/"},{"categories":null,"content":"分析 和 0091 的区别在于存在 ‘*’ 字符，递推式的系数会不同。 注意到包含 ‘*’ 的单/双字符，所对应的系数是固定的，比如 ’ **’ 必然对应系数 15， 因此考虑用哈希表保存对应关系，再递推即可。 ","date":"2017-07-15","objectID":"/leetcode/0639/:2:0","tags":null,"title":"0639：解码方法 II（★★）","uri":"/leetcode/0639/"},{"categories":null,"content":"解答 def numDecodings(self, s: str) -\u003e int: d1 = {'*': 9, '0': 0} d2 = {'**': 15, '1*':9, '2*':6} for i in range(10): d2['*'+str(i)] = 2 if i\u003c=6 else 1 for i in range(10, 27): d2[str(i)] = 1 a, b, mod = 0, 1, 10**9+7 for i in range(len(s)): a, b = b, (b*d1.get(s[i], 1) + a*d2.get(s[i-1:i+1], 0)) % mod","date":"2017-07-15","objectID":"/leetcode/0639/:3:0","tags":null,"title":"0639：解码方法 II（★★）","uri":"/leetcode/0639/"},{"categories":null,"content":"题目 在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包， 每个大礼包以优惠的价格捆绑销售一组物品。 给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单， 其中 needs[i] 是需要购买第 i 件物品的数量。 还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[i][j] 表示 第 i 个大礼包中内含第 j 件物品的数量，且 special[i][n] （也就是数组中的最后一个整数）为第 i 个大礼包的","date":"2017-07-14","objectID":"/leetcode/0638/:1:0","tags":null,"title":"0638：大礼包（★★）","uri":"/leetcode/0638/"},{"categories":null,"content":"分析 按最后一个礼包是否是 special[-1]，可以转为递归子问题。 令 dfs(i, needs) 代表用 special[:i+1] 满足 needs 的最小价格，即可递归。 这是典型的完全背包问题 ","date":"2017-07-14","objectID":"/leetcode/0638/:2:0","tags":null,"title":"0638：大礼包（★★）","uri":"/leetcode/0638/"},{"categories":null,"content":"解答 def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -\u003e int: @lru_cache(None) def dfs(i, needs): if i==-1: return sum(a*b for a,b in zip(price, needs)) res = dfs(i-1, needs) A = tuple(b-a for a,b in zip(special[i], needs)) if all(a\u003e=0 for a in A): res = min(res, ","date":"2017-07-14","objectID":"/leetcode/0638/:3:0","tags":null,"title":"0638：大礼包（★★）","uri":"/leetcode/0638/"},{"categories":null,"content":"“……和我一起，试着加入游戏部怎样？”兴趣是游戏，除此之外毫无显眼的特征，仅仅是个龙套的游戏玩家雨野景太，某天突然被学园第一的美少女，游戏部部长天道花怜搭话了。\n由此开始，景太的日常为之一转，开始了与喜爱游戏的美少女们共度的恋爱喜剧展开的日子……本以为如此！？只有游戏的价值观不同，特立独行的女子玩家星之守千秋。班上的中心人物，虽然有女友却私下里爱好游戏的残念现充上原祐。祐的女友，毫无游戏知识的亚玖璃。\n将这些人物一并卷入，重复着互相误会、徒劳无功、陷入迷途，乱成一团的游戏玩家们带来的“擦肩而过青春错综系恋爱喜剧”开幕！","date":"2017-07-13","objectID":"/anime/gamers/","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"简介 “……和我一起，试着加入游戏部怎样？”兴趣是游戏，除此之外毫无显眼的特征，仅仅是个龙套的游戏玩家雨野景太，某天突然被学园第一的美少女，游戏部部长天道花怜搭话了。 由此开始，景太的日常为之一转，开始了与喜爱游戏的美少女们共度的恋爱喜剧展开的日子……本以为如此！？只有游戏的价值观不同，特立独行的女子玩家星之守千秋。班上的中心人物，虽然有女友却私下里爱好游戏的残念现充上原祐。祐的女友，毫无游戏知识的亚玖璃。 将这些人物一并卷入，重复着互相误会、徒劳无功、陷入迷途，乱成一团的游戏玩家们带来的“擦肩而过青春错综系恋爱喜剧”开幕！ 制作人员： 原作：葵关南 导演：冈本学 脚本：内田裕基 分镜：川村贤","date":"2017-07-13","objectID":"/anime/gamers/:1:0","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雨野景太 雨野 景太、あまの けいた、Amano Keita 男 潘めぐみ 2 天道花怜 天道 花憐、てんどう かれん、Tendou Karen 女 金元寿子 3 星之守千秋 星ノ守 千秋、ほしのもり ちあき、Hoshinomori Chiaki 女 石見舞菜香 4 樱野亚玖璃 桜野 亜玖璃、さくらの あぐり、Sakurano Aguri 女 大久保瑠美 5 上原祐 うえはら　たすく、uehara tasuku 男 豊永利行 6 星之守心春 ほしのもり　このは 女 桑原由気 7 三角瑛一 みすみ　えいいち 男 花江夏樹 8 加濑岳人 男 内匠靖明 ","date":"2017-07-13","objectID":"/anime/gamers/:2:0","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 GAMERS电玩咖 2017-07-13 12 bilibili ","date":"2017-07-13","objectID":"/anime/gamers/:3:0","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"MAD ","date":"2017-07-13","objectID":"/anime/gamers/:4:0","tags":null,"title":"GAMERS电玩咖","uri":"/anime/gamers/"},{"categories":null,"content":"住在湾岸城镇樱渊市的少年反田野良，在某个春日的上学途中，看到了一位美少女。这位名叫帕特莉西亚的少女乃是冥界的皇女，为了将野良等人所居住的地上生物灭绝而来。当天中午，野良由于某起事件而与帕特莉西亚接吻了。紧接着，野良的身体就变成了一只黑猫。由于帕特莉西亚所拥有的魔力，野良成为了她的眷属。数日后，野良终于可以变回人类的样子，但在那之后他又几次重复变成猫和恢复人形的过程。","date":"2017-07-12","objectID":"/anime/nora_to_oujo_to_noraneko_heart/","tags":null,"title":"野良和皇女和流浪猫之心","uri":"/anime/nora_to_oujo_to_noraneko_heart/"},{"categories":null,"content":"简介 住在湾岸城镇樱渊市的少年反田野良，在某个春日的上学途中，看到了一位美少女。这位名叫帕特莉西亚的少女乃是冥界的皇女，为了将野良等人所居住的地上生物灭绝而来。当天中午，野良由于某起事件而与帕特莉西亚接吻了。紧接着，野良的身体就变成了一只黑猫。由于帕特莉西亚所拥有的魔力，野良成为了她的眷属。数日后，野良终于可以变回人类的样子，但在那之后他又几次重复变成猫和恢复人形的过程。 制作人员： 原作：HARUKAZE 导演：森井健史郎 脚本：はと 分镜：衣谷早知、宫岛星矢、藤森苍、磐田麒麟、雏田悠一、かけひなな ","date":"2017-07-12","objectID":"/anime/nora_to_oujo_to_noraneko_heart/:1:0","tags":null,"title":"野良和皇女和流浪猫之心","uri":"/anime/nora_to_oujo_to_noraneko_heart/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 反田野良 Nora Handa 朝井彩加 2 帕特里夏·奥夫·恩德 Patricia of End 女 高森奈津美 3 黑木未知 黒木 未知、くろき みち、Kuroki Michi 女 仙台エリ 4 夕莉夏琪 夕莉 シャチ、ゆうり しゃち、Yūri Shachi 女 浅川悠 5 明日原优纪 明日原优希、明日原 ユウキ、あすはら ゆうき、Asuhara Yūki 女 種﨑敦美 6 高田信千奈 高田 ノブチナ、たかだ のぶちな、Takada Nobuchina 女 山岡ゆり 7 露西亚·奥夫·恩德 Lucia of End 女 大地葉 8 尤菈夏·奥夫·恩德 E","date":"2017-07-12","objectID":"/anime/nora_to_oujo_to_noraneko_heart/:2:0","tags":null,"title":"野良和皇女和流浪猫之心","uri":"/anime/nora_to_oujo_to_noraneko_heart/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 野良和皇女和流浪猫之心 2017-07-12 12 9anime ","date":"2017-07-12","objectID":"/anime/nora_to_oujo_to_noraneko_heart/:3:0","tags":null,"title":"野良和皇女和流浪猫之心","uri":"/anime/nora_to_oujo_to_noraneko_heart/"},{"categories":null,"content":"这里是梦世界。\n是欲望、希望、绝望成形的，意识与无意识的夹缝间。\n在总是做梦的自己的房间里，再次陷入睡眠的月城遥人，偶然进入了他人的梦境。那是，心灵被囚禁在这梦世界里的魔女们的梦。陷入拒绝现实、逃往梦境、持续睡眠的“睡美人病”当中的，她们的梦的姿态。\n迷失在魔女的梦世界中的遥人，寻找着出口的门，并和她们打着招呼。","date":"2017-07-07","objectID":"/anime/18if/","tags":null,"title":"18if","uri":"/anime/18if/"},{"categories":null,"content":"简介 这里是梦世界。 是欲望、希望、绝望成形的，意识与无意识的夹缝间。 在总是做梦的自己的房间里，再次陷入睡眠的月城遥人，偶然进入了他人的梦境。那是，心灵被囚禁在这梦世界里的魔女们的梦。陷入拒绝现实、逃往梦境、持续睡眠的“睡美人病”当中的，她们的梦的姿态。 迷失在魔女的梦世界中的遥人，寻找着出口的门，并和她们打着招呼。 制作人员： 导演：吉川志我津、大原实、藤井俊郎、高桥幸雄、千明孝一、石山贵明、西森章、森本晃司、数井浩子 ","date":"2017-07-07","objectID":"/anime/18if/:1:0","tags":null,"title":"18if","uri":"/anime/18if/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 月城遥人 Tsukishiro Haruto 男 島﨑信長 2 神崎カツミ Kanzaki Katsumi 男 子安武人 3 リリィ Lily 女 名塚佳織 ","date":"2017-07-07","objectID":"/anime/18if/:2:0","tags":null,"title":"18if","uri":"/anime/18if/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 18if 2017-07-07 13 bilibili ","date":"2017-07-07","objectID":"/anime/18if/:3:0","tags":null,"title":"18if","uri":"/anime/18if/"},{"categories":null,"content":"题目 给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。 逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i \u003c j且 a[i] \u003e a[j]，则其为一个逆序对；否则不是。 由于答案可能很大，只需要返回 答案 mod 10^9 + 7 的值。 示例 1: 输入: n = 3, k = 0 输出: 1 解释: 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。 示例 2: 输入: n = 3, k = 1 输出: 2 解释: 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。 说明: n 的范围是","date":"2017-07-05","objectID":"/leetcode/0629/:1:0","tags":null,"title":"0629：K个逆序对数组（★★★）","uri":"/leetcode/0629/"},{"categories":null,"content":"分析 假设 n 放到位置 idx，那么包含 n 的逆序对有 n-idx-1，然后转为了子问题：1 到 n-1 的排列中恰好 k-(n-idx-1) 个逆序对的个数。 因此令 dp[i][j] 代表 1 到 i 的排列中恰好 j 个逆序对的个数，即可递推： dp[i][j] = sum(dp[i-1][j-cnt] for cnt in range(i) if j-cnt\u003e=0) 但这个时间复杂度会超时。 观察发现递推式中其实是 dp[i-1] 的连续区间的和，于是想到用前缀和。 事先保存 dp[i-1] 的前缀和数组 pre，递推式变为： dp[i][j] = pre[j+1]-pre[max","date":"2017-07-05","objectID":"/leetcode/0629/:2:0","tags":null,"title":"0629：K个逆序对数组（★★★）","uri":"/leetcode/0629/"},{"categories":null,"content":"解答 def kInversePairs(self, n: int, k: int) -\u003e int: dp, mod = [1]+[0]*k, 10**9+7 for i in range(1, n+1): pre = list(accumulate([0]+dp, lambda x,y:(x+y)%mod)) dp = [pre[j+1]-pre[max(0, j-i+1)] for j in range(k+1)] return dp[-1]%mod 548 ms ","date":"2017-07-05","objectID":"/leetcode/0629/:3:0","tags":null,"title":"0629：K个逆序对数组（★★★）","uri":"/leetcode/0629/"},{"categories":null,"content":"文藏高中新生欢迎会。\n1年级的越山识，意外地被猜谜研究会要求参加了“新生抢答大赛”。\n就在爱好读书且不喜欢引人注目的识感到慌张的时候，同班的深见真理在谜题读完之前就接连按下按钮，压倒周围的人们。\n“知道答案后再按下去就太迟了。抢答在0.01秒的差距下，就能分出胜败”\n在看着这样的真理的途中，识注意到了“在猜谜当中有着能确定答案的要点”……。\n与猜谜研究会的前辈及伙伴、以及拥有压倒性强大的对手·御来屋千智的相遇，正解时的喜悦，无法按下按钮时的悔恨……\n并不只是知识，也要磨炼各种技术，并与同伴一同以胜利为目标的“竞技猜谜”的世界当中，越山识以猜谜拼上青春的每一天开始了。","date":"2017-07-04","objectID":"/anime/fastest_finger_first/","tags":null,"title":"猜谜王","uri":"/anime/fastest_finger_first/"},{"categories":null,"content":"简介 文藏高中新生欢迎会。 1年级的越山识，意外地被猜谜研究会要求参加了“新生抢答大赛”。 就在爱好读书且不喜欢引人注目的识感到慌张的时候，同班的深见真理在谜题读完之前就接连按下按钮，压倒周围的人们。 “知道答案后再按下去就太迟了。抢答在0.01秒的差距下，就能分出胜败” 在看着这样的真理的途中，识注意到了“在猜谜当中有着能确定答案的要点”……。 与猜谜研究会的前辈及伙伴、以及拥有压倒性强大的对手·御来屋千智的相遇，正解时的喜悦，无法按下按钮时的悔恨…… 并不只是知识，也要磨炼各种技术，并与同伴一同以胜利为目标的“竞技猜谜”的世界当中，越山识以猜谜拼上青春的每一天开始了。 制作人员： 原作：杉","date":"2017-07-04","objectID":"/anime/fastest_finger_first/:1:0","tags":null,"title":"猜谜王","uri":"/anime/fastest_finger_first/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 越山识 こしやま しき、Koshiyama Shiki 男 堀江瞬 2 深见真理 ふかみ まり、Fukami Mari 女 川島海荷 3 御来屋千智 みくりやちさと、Mikuriya Chisato 男 石川界人 4 笹岛学人 ささじま がくと、Sasajima Gakuto 男 佐藤拓也 5 井上大将 井上 大将、いのうえ だいすけ、Inoue Daisuke 男 畠中祐 6 笹岛迅子 笹島 迅子、ささじま じんこ、Sasajima Jinko 女 松田颯水 7 苑原明良 苑原 明良、そのはら あきら、Sonohara Akira 男 永塚拓馬 8 上月由","date":"2017-07-04","objectID":"/anime/fastest_finger_first/:2:0","tags":null,"title":"猜谜王","uri":"/anime/fastest_finger_first/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 猜谜王 2017-07-04 12 樱花 ","date":"2017-07-04","objectID":"/anime/fastest_finger_first/:3:0","tags":null,"title":"猜谜王","uri":"/anime/fastest_finger_first/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-05-29","objectID":"/leetcode/0600/:0:0","tags":null,"title":"0600：不含连续1的非负整数（★★）","uri":"/leetcode/0600/"},{"categories":null,"content":"题目 给定一个正整数 n ，返回范围在 [0, n] 都非负整数中，其二进制表示不包含 连续的 1 的个数。 示例 1: 输入: n = 5\r输出: 5\r解释: 下面是带有相应二进制表示的非负整数\u003c= 5：\r0 : 0\r1 : 1\r2 : 10\r3 : 11\r4 : 100\r5 : 101\r其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。\r示例 2: 输入: n = 1\r输出: 2\r示例 3: 输入: n = 2\r输出: 3\r提示: 1 \u003c= n \u003c= 10^9 ","date":"2017-05-29","objectID":"/leetcode/0600/:1:0","tags":null,"title":"0600：不含连续1的非负整数（★★）","uri":"/leetcode/0600/"},{"categories":null,"content":"分析 求范围内数字满足某种性质的个数，典型的数位 dp 问题， 令 dfs(pos, st, bound) 代表某个状态下的结果： 遍历到 n 的第 pos 位 前面一个数是 st bound 代表前面取的数是否贴着 n 的上界 即可递归。 注意本题是限制二进制，所以用 bin。 ","date":"2017-05-29","objectID":"/leetcode/0600/:2:0","tags":null,"title":"0600：不含连续1的非负整数（★★）","uri":"/leetcode/0600/"},{"categories":null,"content":"解答 def findIntegers(self, n: int) -\u003e int: @lru_cache(None) def dfs(pos, st, bound): if pos==len(s): return 1 res, cur = 0, int(s[pos]) up = cur if bound else 1 for x in range(up+1): if not x\u0026st: res += dfs(pos+1, x, bound and x==cur) return res s = bin(n)[2:] return dfs(0, 0, True) 64 ms ","date":"2017-05-29","objectID":"/leetcode/0600/:3:0","tags":null,"title":"0600：不含连续1的非负整数（★★）","uri":"/leetcode/0600/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-05-28","objectID":"/leetcode/0599/:0:0","tags":null,"title":"0599：两个列表的最小索引总和（★）","uri":"/leetcode/0599/"},{"categories":null,"content":"题目 假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。 提示: 两个列表的长度范围都在 [1, 1000]内。 两个列表中的字符串的长度将在[1，30]的范围内。 下标从0开始，到列表的长度减1。 两个列表都没有重复的元素。 示例 1: 输入:\r[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\r[\"Piatti\", \"The Grill at ","date":"2017-05-28","objectID":"/leetcode/0599/:1:0","tags":null,"title":"0599：两个列表的最小索引总和（★）","uri":"/leetcode/0599/"},{"categories":null,"content":"分析 遍历两个列表，找到公共的元素，根据索引和修改结果即可。 注意可以先用哈希表保存一个列表的元素及索引，然后遍历另一个列表，根据哈希表即可快速查询元素。 ","date":"2017-05-28","objectID":"/leetcode/0599/:2:0","tags":null,"title":"0599：两个列表的最小索引总和（★）","uri":"/leetcode/0599/"},{"categories":null,"content":"解答 def findRestaurant(self, list1: List[str], list2: List[str]) -\u003e List[str]: res, Min = [], 2000 A = {item: i for i, item in enumerate(list1)} for i, item in enumerate(list2): s = i + A.get(item, 2001) if s == Min: res.append(item) elif s \u003c Min: res, Min = [item], s return res 52 ms ","date":"2017-05-28","objectID":"/leetcode/0599/:3:0","tags":null,"title":"0599：两个列表的最小索引总和（★）","uri":"/leetcode/0599/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-05-23","objectID":"/leetcode/0594/:0:0","tags":null,"title":"0594：最长和谐子序列（★）","uri":"/leetcode/0594/"},{"categories":null,"content":"题目 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。 现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。 数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。 提示： 1 \u003c= nums.length \u003c= 2 * 104 -10^9 \u003c= nums[i] \u003c= 10^9 示例 1： 输入：nums = [1,3,2,2,5,2,3,7]\r输出：5\r解释：最长的和谐子序列是 [3,2,2,2,3]\r示例 2： 输入：nums = [1,2,3,4]\r输出：2\r示例 3： 输入：nu","date":"2017-05-23","objectID":"/leetcode/0594/:1:0","tags":null,"title":"0594：最长和谐子序列（★）","uri":"/leetcode/0594/"},{"categories":null,"content":"分析 先统计得到每个数的个数 ct。 然后遍历数组存在的数 x 作为最小值，如果 x+1 也存在数组中，那么对应的最长和谐子序列长度即为 ct[x] + ct[x+1]。 ","date":"2017-05-23","objectID":"/leetcode/0594/:2:0","tags":null,"title":"0594：最长和谐子序列（★）","uri":"/leetcode/0594/"},{"categories":null,"content":"解答 def findLHS(self, nums: List[int]) -\u003e int: ct = Counter(nums) return max(ct[x]+ct[x+1] if ct[x+1] else 0 for x in ct) 88 ms ","date":"2017-05-23","objectID":"/leetcode/0594/:3:0","tags":null,"title":"0594：最长和谐子序列（★）","uri":"/leetcode/0594/"},{"categories":null,"content":"住在寂静的渔港小镇日无町的初中少年海，与父亲以及在做阳伞师傅的祖父三人一起生活。他原本住在东京，但随着双亲的离婚而移居到了父母的故乡日无町。无法说出对于父母的复杂心思，海就这么怀着郁闷的心情，在学校也十分地消极。他唯一的生活寄托，就是将自己作曲的音乐上传到网络上。\n一天，他被同班同学国男和游步邀请参加他们组成的乐队“Siren”。他勉强地前往练习地点人鱼岛，在那里，人鱼少女·露出现在3人的面前。显得很愉快地歌唱、天真无邪地起舞的露。随着每天与这样的露共同行动，海也逐渐变得能够将自己的心情说出口了。\n但是，在日无町，人鱼自古以来就是带来灾祸的存在。由于偶然的事件，露与镇民之间产生了巨大的隔阂。随即，危机造访了小镇。海发自内心的呐喊，究竟能否拯救小镇呢？","date":"2017-05-19","objectID":"/anime/lu_over_the_wall/","tags":null,"title":"宣告黎明的露之歌","uri":"/anime/lu_over_the_wall/"},{"categories":null,"content":"简介 住在寂静的渔港小镇日无町的初中少年海，与父亲以及在做阳伞师傅的祖父三人一起生活。他原本住在东京，但随着双亲的离婚而移居到了父母的故乡日无町。无法说出对于父母的复杂心思，海就这么怀着郁闷的心情，在学校也十分地消极。他唯一的生活寄托，就是将自己作曲的音乐上传到网络上。 一天，他被同班同学国男和游步邀请参加他们组成的乐队“Siren”。他勉强地前往练习地点人鱼岛，在那里，人鱼少女·露出现在3人的面前。显得很愉快地歌唱、天真无邪地起舞的露。随着每天与这样的露共同行动，海也逐渐变得能够将自己的心情说出口了。 但是，在日无町，人鱼自古以来就是带来灾祸的存在。由于偶然的事件，露与镇民之间产生了巨大的隔","date":"2017-05-19","objectID":"/anime/lu_over_the_wall/:1:0","tags":null,"title":"宣告黎明的露之歌","uri":"/anime/lu_over_the_wall/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 露 Lu 女 谷花音 2 足元海 Kai 男 下田翔大 3 ルーのパパ 男 篠原信一 4 海老名游步 Yuho 女 寿美菜子 5 国夫 Kunio 男 斉藤壮馬 6 海的祖父 男 柄本明 7 足元照夫 男 鈴村健一 8 伊佐木 女 伊藤静 ","date":"2017-05-19","objectID":"/anime/lu_over_the_wall/:2:0","tags":null,"title":"宣告黎明的露之歌","uri":"/anime/lu_over_the_wall/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 宣告黎明的露之歌 2017-05-19 01:52:13 bilibili ","date":"2017-05-19","objectID":"/anime/lu_over_the_wall/:3:0","tags":null,"title":"宣告黎明的露之歌","uri":"/anime/lu_over_the_wall/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-05-12","objectID":"/leetcode/0583/:0:0","tags":null,"title":"0583：两个字符串的删除操作（★★）","uri":"/leetcode/0583/"},{"categories":null,"content":"题目 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。 每步 可以删除任意一个字符串中的一个字符。 示例 1： 输入: word1 = \"sea\", word2 = \"eat\"\r输出: 2\r解释: 第一步将 \"sea\" 变为 \"ea\" ，第二步将 \"eat \"变为 \"ea\"\r示例 2: 输入：word1 = \"leetcode\", word2 = \"etco\"\r输出：4\r提示： 1 \u003c= word1.length, word2.length \u003c= 500 word1 和 word2 只包含小写英文字母 ","date":"2017-05-12","objectID":"/leetcode/0583/:1:0","tags":null,"title":"0583：两个字符串的删除操作（★★）","uri":"/leetcode/0583/"},{"categories":null,"content":"分析 显然用动态规划即可，可以用滚动数组优化。 ","date":"2017-05-12","objectID":"/leetcode/0583/:2:0","tags":null,"title":"0583：两个字符串的删除操作（★★）","uri":"/leetcode/0583/"},{"categories":null,"content":"解答 def minDistance(self, word1: str, word2: str) -\u003e int: m, n = len(word1), len(word2) dp = list(range(n+1)) for char in word1: prev = dp[:] dp[0] += 1 for j in range(1, n+1): if word2[j-1]==char: dp[j] = prev[j-1] else: dp[j] = 1+min(prev[j], dp[j-1]) return dp[-1] 244 ms ","date":"2017-05-12","objectID":"/leetcode/0583/:3:0","tags":null,"title":"0583：两个字符串的删除操作（★★）","uri":"/leetcode/0583/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-05-05","objectID":"/leetcode/0576/:0:0","tags":null,"title":"0576：出界的路径数（★★）","uri":"/leetcode/0576/"},{"categories":null,"content":"题目 给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。 你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。 你 最多 可以移动 maxMove 次球。 给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。 因为答案可能非常大，返回对 10^9 + 7 取余 后的结果。 示例 1： 输入：m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\r输出：6\r示例 2： 输入：m = 1","date":"2017-05-05","objectID":"/leetcode/0576/:1:0","tags":null,"title":"0576：出界的路径数（★★）","uri":"/leetcode/0576/"},{"categories":null,"content":"分析 按第一步的移动方向即可转为递归子问题。 ","date":"2017-05-05","objectID":"/leetcode/0576/:2:0","tags":null,"title":"0576：出界的路径数（★★）","uri":"/leetcode/0576/"},{"categories":null,"content":"解答 def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -\u003e int: @lru_cache(None) def dfs(i, j, k): if not 0\u003c=i\u003cm or not 0\u003c=j\u003cn: return 1 if k==0: return 0 return sum(dfs(x, y, k-1) for x,y in [(i+1, j),(i-1,j),(i,j+1),(i,j-1)])%mod mod = 10**9+7 return dfs(startRow, sta","date":"2017-05-05","objectID":"/leetcode/0576/:3:0","tags":null,"title":"0576：出界的路径数（★★）","uri":"/leetcode/0576/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-05-04","objectID":"/leetcode/0575/:0:0","tags":null,"title":"0575：分糖果","uri":"/leetcode/0575/"},{"categories":null,"content":"题目 给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。 你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。 示例 1: 输入: candies = [1,1,2,2,3,3]\r输出: 3\r解析: 一共有三种种类的糖果，每一种都有两个。\r最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。\r示例 2 : 输入: candies = [1,1,2,3]\r输出: 2\r解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最","date":"2017-05-04","objectID":"/leetcode/0575/:1:0","tags":null,"title":"0575：分糖果","uri":"/leetcode/0575/"},{"categories":null,"content":"分析 妹妹分到 x = len(candyType) // 2 个糖果，若糖果种类足够多，显然 x 即是结果。 若糖果种类 y 小于 x，那么妹妹就只能分到 y 种。 ","date":"2017-05-04","objectID":"/leetcode/0575/:2:0","tags":null,"title":"0575：分糖果","uri":"/leetcode/0575/"},{"categories":null,"content":"解答 def distributeCandies(self, candyType: List[int]) -\u003e int: return min(len(candyType)//2, len(set(candyType))) 92 ms ","date":"2017-05-04","objectID":"/leetcode/0575/:3:0","tags":null,"title":"0575：分糖果","uri":"/leetcode/0575/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-04-23","objectID":"/leetcode/0564/:0:0","tags":null,"title":"0564：寻找最近的回文数（★★★）","uri":"/leetcode/0564/"},{"categories":null,"content":"题目 给定一个整数 n ，你需要找到与它最近的回文数（不包括自身）。 “最近的”定义为两个整数差的绝对值最小。如果有多个结果，返回最小的那个。 示例 1: 输入: \"123\"\r输出: \"121\"\r","date":"2017-04-23","objectID":"/leetcode/0564/:1:0","tags":null,"title":"0564：寻找最近的回文数（★★★）","uri":"/leetcode/0564/"},{"categories":null,"content":"分析 显然用暴力法太耗时了，考虑直接构造的方法。 尝试几次发现可以用固定前半并镜像的方法得到一个相近的回文数。 例如 356，固定住 35 并镜像得到 353，又如 6482 固定住 64 并镜像得到 6446。 这样得到的回文数和原数的差必然在 $10^{len(n)//2}$ 以内，所以暴力法要遍历 $O(\\sqrt N)$ 次。 但这并不一定是最近的，比如说 731 最近的应该是 727 而不是 737 ，399 最近的应该是 404 而不是 393。 也就是说，设 n 的前半为 half，以 half 镜像得到的不一定是最近的。但分别以 half-1、half、half+1 镜像的三个","date":"2017-04-23","objectID":"/leetcode/0564/:2:0","tags":null,"title":"0564：寻找最近的回文数（★★★）","uri":"/leetcode/0564/"},{"categories":null,"content":"解答 def nearestPalindromic(self, n: str) -\u003e str: L = len(n) half, flag = n[:(L+1)//2], L % 2 h1, h2 = str(int(half)-1), str(int(half)+1) a = h1 + h1[-flag-1::-1] if h1!='0' and len(h1)==len(half) else str(10**(L-1)-1) b = half + half[-flag-1::-1] c = h2 + h2[-flag-1::-1] if len(h2)==len(half) else st","date":"2017-04-23","objectID":"/leetcode/0564/:3:0","tags":null,"title":"0564：寻找最近的回文数（★★★）","uri":"/leetcode/0564/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-04-13","objectID":"/leetcode/0554/:0:0","tags":null,"title":"0554：砖墙（★★）","uri":"/leetcode/0554/"},{"categories":null,"content":"题目 你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。 每一行砖块的宽度之和相等。 你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。 你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。 给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。 你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。 提示： n == wall.length 1 \u003c= n \u003c= 10^4 1 \u003c= wall","date":"2017-04-13","objectID":"/leetcode/0554/:1:0","tags":null,"title":"0554：砖墙（★★）","uri":"/leetcode/0554/"},{"categories":null,"content":"分析 显然找一条穿过边缘最多的垂线（除了墙边）即可。于是记录每行的边缘位置（横坐标 y），找到对应了最多行的位置即可。 ","date":"2017-04-13","objectID":"/leetcode/0554/:2:0","tags":null,"title":"0554：砖墙（★★）","uri":"/leetcode/0554/"},{"categories":null,"content":"解答 def leastBricks(self, wall: List[List[int]]) -\u003e int: return len(wall) - (max(Counter([y for row in wall for y in accumulate(row[:-1])]).values() or [0])) 60 ms ","date":"2017-04-13","objectID":"/leetcode/0554/:3:0","tags":null,"title":"0554：砖墙（★★）","uri":"/leetcode/0554/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2017-04-11","objectID":"/leetcode/0552/:0:0","tags":null,"title":"0552：学生出勤记录 II（★★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"题目 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。 记录中只含下面三种字符： ‘A’：Absent，缺勤 ‘L’：Late，迟到 ‘P’：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： 按 总出勤 计，学生缺勤（‘A’）严格 少于两天。 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（‘L’）记录。 给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。 答案可能很大，所以返回对 109 + 7 取余 的结果。 示例 1： 输入：n = 2\r输","date":"2017-04-11","objectID":"/leetcode/0552/:1:0","tags":null,"title":"0552：学生出勤记录 II（★★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"分析 最后一个字符有三种情况： 假如为 ‘A’，那么前面不能再有 ‘A’ 假如为 ‘L’，那么前两个字符不能都为 ‘L’ 假如为 ‘P’，前面的是子问题 那么令 dp[i][j][k] 代表 长度 i 有 j 个’A’ 末尾有 k 个连续 ‘L’ 条件下的数量，即可递归。最后 sum(dp[n][0])+sum(dp[n][1]) 即为所求。 还可以用滚动数组优化。并且因为 j 和 k 的范围很小，可以合并为一维数组。 ","date":"2017-04-11","objectID":"/leetcode/0552/:2:0","tags":null,"title":"0552：学生出勤记录 II（★★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"解答 def checkRecord(self, n: int) -\u003e int: mod = 10**9+7 dp = [1]+[0]*5 for i in range(1, n+1): dp = [sum(dp[:3])%mod, dp[0], dp[1], sum(dp)%mod, dp[3], dp[4]] return sum(dp)%mod 772 ms ","date":"2017-04-11","objectID":"/leetcode/0552/:3:0","tags":null,"title":"0552：学生出勤记录 II（★★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"*附加 这是完全的线性递推关系，因此可以用矩阵快速幂优化。 注意在矩阵乘法时也取模即可。 def checkRecord(self, n: int) -\u003e int: def mpow(mat, n): res = mat for bit in bin(n)[3:]: res = res*res%mod if bit=='1': res = res*mat%mod return res import numpy as np mod = 10**9+7 A = np.mat([[1,1,1,0,0,0],[1,0,0,0,0,0],[0,1,0,0,0,0], [1,1,1,1,1,1],[0,0","date":"2017-04-11","objectID":"/leetcode/0552/:4:0","tags":null,"title":"0552：学生出勤记录 II（★★★）","uri":"/leetcode/0552/"},{"categories":null,"content":"       被称作妖精兵器的少女们与残存的准勇者之间的虚幻而痛切的物语。\n       地上遭到正体不明的怪物“兽”的蹂躏，包括人类在内的多种族被毁灭之后的世界。\n       勉强残存的种族离开地面，移居到名为浮游大陆群（Regulu Ere）的空中群岛上生活。\n       在500年后的空中醒来的威廉·克梅修，在无法守护自己本欲守护之物，甚至仅剩自己一人的绝望之中度过着与世隔绝的生活，但在出乎意料地开展的兵器管理工作当中，他与少女们相遇了。","date":"2017-04-11","objectID":"/anime/worldend/","tags":null,"title":"末日时在做什么？有没有空？可以来拯救吗？","uri":"/anime/worldend/"},{"categories":null,"content":"简介 被称作妖精兵器的少女们与残存的准勇者之间的虚幻而痛切的物语。 地上遭到正体不明的怪物“兽”的蹂躏，包括人类在内的多种族被毁灭之后的世界。 勉强残存的种族离开地面，移居到名为浮游大陆群（Regulu Ere）的空中群岛上生活。 在500年后的空中醒来的威廉·克梅修，在无法守护自己本欲守护之物，甚至仅剩自己一人的绝望之中度过着与世隔绝的生活，但在出乎意料地开展的兵器管理工作当中，他与少女们相遇了。 制作人员： 原作：枯野瑛 导演：和田纯一 脚本：望月真里子、永井真吾、根元岁三 分镜：佐藤英一、池下博纪、安田贤司 ","date":"2017-04-11","objectID":"/anime/worldend/:1:0","tags":null,"title":"末日时在做什么？有没有空？可以来拯救吗？","uri":"/anime/worldend/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 威廉·克梅修 Willem-Kmetsch 男 新井良平 2 珂朵莉·诺塔·瑟尼欧里斯 Chtholly-Nota-Seniorious 女 田所あずさ 3 艾瑟雅·麦杰·瓦尔卡利斯 Ithea-Myse-Valgulious 女 Machico 4 奈芙莲·卢可·因萨尼亚 Nephren Ruq Insania 女 上原あかり 5 兰朵露可·伊瑟利·赫斯托利亚 Rhantolk-Ytri-Historia 女 荒浪和沙 6 诺夫特·K·迪斯佩拉提奥 Nopht-Keh-Desperatio 女 水瀬いのり 7 缇亚特 Tiat 女 水間友美 8 潘丽宝 P","date":"2017-04-11","objectID":"/anime/worldend/:2:0","tags":null,"title":"末日时在做什么？有没有空？可以来拯救吗？","uri":"/anime/worldend/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 末日时在做什么？有没有空？可以来拯救吗？ 2017-04-11 12 樱花 ","date":"2017-04-11","objectID":"/anime/worldend/:3:0","tags":null,"title":"末日时在做什么？有没有空？可以来拯救吗？","uri":"/anime/worldend/"},{"categories":null,"content":"I-MACHINE——这是在极限环境之中进行作业的大型机器人的总称。\n联盟学院的学生·三栗麻耶在使用I-MACHINE时被卷入了一场事故，幸而被同样使用I-MACHINE来采掘“欧利哈尔特矿石”的一批人救下，并坐上了他们的宇宙船。\n就这样成为了实际上等同于宇宙海盗的埃斯卡维特公司的“职员”之一……。","date":"2017-04-09","objectID":"/anime/id-0/","tags":null,"title":"ID-0","uri":"/anime/id-0/"},{"categories":null,"content":"简介 I-MACHINE——这是在极限环境之中进行作业的大型机器人的总称。 联盟学院的学生·三栗麻耶在使用I-MACHINE时被卷入了一场事故，幸而被同样使用I-MACHINE来采掘“欧利哈尔特矿石”的一批人救下，并坐上了他们的宇宙船。 就这样成为了实际上等同于宇宙海盗的埃斯卡维特公司的“职员”之一……。 制作人员： 导演：谷口悟朗 脚本：黑田洋介 分镜：须永司、大桥誉志光、林直孝 演出：松下周平、久保田雄大、野上和男 ","date":"2017-04-09","objectID":"/anime/id-0/:1:0","tags":null,"title":"ID-0","uri":"/anime/id-0/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊度 伊德、Ido、イド機 男 興津和幸 2 三栗麻耶 ミクリ マヤ、Mikuri Maya 女 津田美波 3 柯莱雅·北条 Clair Hojo、クレア ホウジョウ 女 金元寿子 4 谜之少女 女 上田麗奈 5 里克·艾尔 Rick Ayer、リック機、リック エイヤー 男 松風雅也 6 卡菈·米拉·福登 Karla Milla-Foden、カーラ機 女 大原さやか 7 格雷曼 Grayman、グレイマン機 男 小山力也 8 法路泽 Fa-Loser、ファルザ機 小澤亜李 ","date":"2017-04-09","objectID":"/anime/id-0/:2:0","tags":null,"title":"ID-0","uri":"/anime/id-0/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 ID-0 2017-04-09 12 bilibili ","date":"2017-04-09","objectID":"/anime/id-0/:3:0","tags":null,"title":"ID-0","uri":"/anime/id-0/"},{"categories":null,"content":"对学妹“黑发少女”一见倾心的“前辈”，今天也是进行着名为『尽可能进入她的眼帘』的作战——简称“尽(进)她眼作战”。\n春之先斗町、夏之旧书市、秋之学园祭、而后是冬天的到来…。在京都这个城市中，在被卷入充满个性的同伴们所引发的一个个奇妙事件的同时，季节流转。\n只能埋藏于内心的“前辈”的恋心，到底会去向何方！？","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"简介 对学妹“黑发少女”一见倾心的“前辈”，今天也是进行着名为『尽可能进入她的眼帘』的作战——简称“尽(进)她眼作战”。 春之先斗町、夏之旧书市、秋之学园祭、而后是冬天的到来…。在京都这个城市中，在被卷入充满个性的同伴们所引发的一个个奇妙事件的同时，季节流转。 只能埋藏于内心的“前辈”的恋心，到底会去向何方！？ 制作人员： 原作：森见登美彦 导演：汤浅政明 脚本：上田诚 分镜：崔恩映、夏目真悟、大平晋也 演出：许平康 ","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/:1:0","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 前辈 男 星野源 2 黑发少女 女 花澤香菜 3 学园祭事务局长 男 神谷浩史 4 内裤大头目 内裤总番长 男 秋山竜次 5 樋口清太郎 樋口 清太郎、樋口師匠 男 中井和哉 6 羽贯凉子 羽貫さん、羽貫 涼子 女 甲斐田裕子 7 旧书市集之神 古书市的神 男 吉野裕行 8 纪子 須田紀子、須田 紀子 女 新妻聖子 ","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/:2:0","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 春宵苦短，少女前进吧！ 2017-04-07 01:32:35 bilibili ","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/:3:0","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"MAD ","date":"2017-04-07","objectID":"/anime/the_night_is_short_walk_on_girl/:4:0","tags":null,"title":"春宵苦短，少女前进吧！","uri":"/anime/the_night_is_short_walk_on_girl/"},{"categories":null,"content":"题目 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连， 且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示 第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 返回矩阵中 省份 的数量。 示例 1： 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]\r输出：2\r示例 2： ","date":"2017-04-06","objectID":"/leetcode/0547/:1:0","tags":null,"title":"0547：省份数量（★）","uri":"/leetcode/0547/"},{"categories":null,"content":"分析 即是求无向图的连通分量数，可以通过遍历求解，bfs 和 dfs 都可以。 不过一般这类问题用并查集，更直观。 ","date":"2017-04-06","objectID":"/leetcode/0547/:2:0","tags":null,"title":"0547：省份数量（★）","uri":"/leetcode/0547/"},{"categories":null,"content":"解答 def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) n = len(isConnected) f = list(range(n)) for i, j in product(range(n), range(n)): if isConnected[i][j]: union(i, j) return sum(f[i] == i for ","date":"2017-04-06","objectID":"/leetcode/0547/:3:0","tags":null,"title":"0547：省份数量（★）","uri":"/leetcode/0547/"},{"categories":null,"content":"茜与小太郎。\n初三时第一次被分到同班，相识的两人。\n同班同学、社团伙伴、教师、父母……与周围的关联，自己的成长。\n在那个一边被变化与不安追着，一边慌慌张张地向前飞奔的季节之中，稚嫩而又令人眩目的青春期之恋。","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"简介 茜与小太郎。 初三时第一次被分到同班，相识的两人。 同班同学、社团伙伴、教师、父母……与周围的关联，自己的成长。 在那个一边被变化与不安追着，一边慌慌张张地向前飞奔的季节之中，稚嫩而又令人眩目的青春期之恋。 制作人员： 导演：岸诚二 脚本：柿原优子 分镜：及川启、岩崎光洋、浅井义之、平井义通、斋藤德明、平峰义大 ","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/:1:0","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 安昙小太郎 あずみ こたろう、Azumi Kotaro 男 千葉翔也 2 水野茜 みずの あかね、Mizuno Akane 女 小原好美 3 比良拓海 ひら たくみ、Hira Takumi 男 田丸篤志 4 西尾千夏 にしお ちなつ、Nishio Chinatsu 女 村川梨衣 5 泷泽葵 たきざわ あおい、Takizawa Aoi 女 白石晴香 6 山科浪漫 やましな ろまん、Yamashina Roman 男 筆村栄心 7 小笠原大地 Daichi Ogasawara 男 金子誠 8 宫本心咲 Aira Miyamoto 女 石見舞菜香 ","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/:2:0","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 月色真美 2017-04-06 12 bilibili ","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/:3:0","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"MAD ","date":"2017-04-06","objectID":"/anime/tsuki_ga_kirei/:4:0","tags":null,"title":"月色真美","uri":"/anime/tsuki_ga_kirei/"},{"categories":null,"content":"题目 给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的 连续 k 个盒子（k \u003e= 1），这样一轮之后你将得到 k * k 个积分。 返回 你能获得的最大积分和 。 示例 1： 输入：boxes = [1,3,2,2,2,3,4,3,1]\r输出：23\r解释：\r[1, 3, 2, 2, 2, 3, 4, 3, 1] ----\u003e [1, 3, 3, 4, 3, 1] (3*3=9 分) ----\u003e [1, 3, 3, 3, 1] (1*1=1 分) ----\u003e [1, 1] (3*3=9 分)","date":"2017-04-05","objectID":"/leetcode/0546/:1:0","tags":null,"title":"0546：移除盒子（★★★）","uri":"/leetcode/0546/"},{"categories":null,"content":"分析 显然初始连续的盒子最后是一起移除的，考虑将连续段合并，得到元素为 (颜色，连续段长度) 的数组 A。 考虑元素 A[-1]，它要么单独移除，要么和前面颜色相同的元素一起移除 假如 A[-1] 单独移除，显然转为递归子问题 假如 A[-1] 和 A[i] 一起移除 必然先移除了 A[i+1:-1] 部分，这部分即是子问题 然后将 A[-1] 的长度累加到 A[i] 上，剩下的也是子问题 因此令 dfs(A) 代表数组 A 的最大积分，即可递归。 ","date":"2017-04-05","objectID":"/leetcode/0546/:2:0","tags":null,"title":"0546：移除盒子（★★★）","uri":"/leetcode/0546/"},{"categories":null,"content":"解答 def removeBoxes(self, boxes: List[int]) -\u003e int: @lru_cache(None) def dfs(A): if not A: return 0 c, k = A[-1] res = dfs(A[:-1])+k**2 for i in range(len(A)-2): if A[i][0]==c: B = A[:i]+((c, A[i][1]+k),) res = max(res, dfs(B)+dfs(A[i+1:-1])) return res A = tuple((x, len(list(g))) for x, g in groupby","date":"2017-04-05","objectID":"/leetcode/0546/:3:0","tags":null,"title":"0546：移除盒子（★★★）","uri":"/leetcode/0546/"},{"categories":null,"content":"*附加 时间复杂度分析： 注意到递归时只会对区间数组的末尾进行修改，因此可以改写成一般的区间 dp 形式 令 dfs(i, j, k) 代表 A[i:j+1] 且 A[j] 额外加了 k 的最大积分，即可递归 显然 k 小于 n，因此一般的区间 dp 写法的时间复杂度是 O(N^4) 直接递归区间数组的形式，有切片操作，所以时间复杂度更高 但因为本题的数值范围很小，一般会存在重复的区间数组，所以直接递归区间数组的实际时间更快 ","date":"2017-04-05","objectID":"/leetcode/0546/:4:0","tags":null,"title":"0546：移除盒子（★★★）","uri":"/leetcode/0546/"},{"categories":null,"content":"半数居民都拥有特殊能力的街道，咲良田。在负责监视能力者的“管理局”管理下，居民过着和平的生活。“想要消去眼前之人的泪水”、“想要将声音传达给某人”。伴随着这种温柔而又细微的“愿望”，这条街道的能力诞生了。\n拥有能够回想起过去体验过的全部记忆的“记忆保持”能力的浅井惠，以及拥有“最大能够将世界倒带3天”的“重启”能力的春埼美空。她自身也受到“重启”的影响而失去了记忆，但通过与决不会忘记任何事情的惠齐心协力，两人得以将过去重来，并改变现在——\n但，也存在着即使是这样的两人也无法重来的“过去”。那是，两年前同级生相麻堇受到“重启”的影响而消失的事情。\n两人从属于名为“服务社团”的社团活动，一边过着完成学生们各种各样委托的每一天，一边寻找着能够让相麻堇复活的方法。这样的他们收到了一件委托——“希望让死去的猫复活”。\n为了消除在过去发生的“悲哀”，少年与少女穿越时间，前去改变世界——","date":"2017-04-05","objectID":"/anime/sagrada_reset/","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":"简介 半数居民都拥有特殊能力的街道，咲良田。在负责监视能力者的“管理局”管理下，居民过着和平的生活。“想要消去眼前之人的泪水”、“想要将声音传达给某人”。伴随着这种温柔而又细微的“愿望”，这条街道的能力诞生了。 拥有能够回想起过去体验过的全部记忆的“记忆保持”能力的浅井惠，以及拥有“最大能够将世界倒带3天”的“重启”能力的春埼美空。她自身也受到“重启”的影响而失去了记忆，但通过与决不会忘记任何事情的惠齐心协力，两人得以将过去重来，并改变现在—— 但，也存在着即使是这样的两人也无法重来的“过去”。那是，两年前同级生相麻堇受到“重启”的影响而消失的事情。 两人从属于名为“服务社团”的社团活动，一边","date":"2017-04-05","objectID":"/anime/sagrada_reset/:1:0","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 浅井惠 浅井 ケイ、あさい ケイ、Asai Kei 男 石川界人 2 春埼美空 春埼 美空、はるき みそら、Haruki Misora 女 花澤香菜 3 相麻堇 相麻 菫、そうま すみれ、Souma Sumire 女 悠木碧 4 仓川真理 Kurakawa Mari 女 久野美咲 5 中野智树 中野 智樹、なかの ともき、Nakano Tomoki 男 江口拓也 6 皆实未来 皆実 未来、みなみ みらい、Minami Mirai 女 山田悠希 7 村濑阳香 村瀬 陽香、むらせ ようか、Murase Youka 女 牧野由依 8 野之尾盛夏 野ノ尾 盛夏、のの","date":"2017-04-05","objectID":"/anime/sagrada_reset/:2:0","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 重启咲良田 2017-04-05 24 bilibili ","date":"2017-04-05","objectID":"/anime/sagrada_reset/:3:0","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":"MAD ","date":"2017-04-05","objectID":"/anime/sagrada_reset/:4:0","tags":null,"title":"重启咲良田","uri":"/anime/sagrada_reset/"},{"categories":null,"content":"题目 给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重。 请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1） 选出并返回一个下标。选取下标 i 的 概率 为 w[i] / sum(w) 。 例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%）， 而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。 示例 1： 输入：\r[\"Solution\",\"pickIndex\"]\r[[[1]],","date":"2017-03-18","objectID":"/leetcode/0528/:1:0","tags":null,"title":"0528：按权重随机选择（★★）","uri":"/leetcode/0528/"},{"categories":null,"content":"分析 等价于变为数组 A = [0]*w[0]+[1]*w[1]+…，然后随机取一个值。 反过来，可以随机取 A 的索引值，求出对应的数即可，不需要实际构造出 A。 具体求对应的数容易想到前缀和数组，然后二分查找即可。 ","date":"2017-03-18","objectID":"/leetcode/0528/:2:0","tags":null,"title":"0528：按权重随机选择（★★）","uri":"/leetcode/0528/"},{"categories":null,"content":"解答 class Solution: def __init__(self, w: List[int]): self.A = list(accumulate(w)) def pickIndex(self) -\u003e int: pos = random.randint(0, self.A[-1]-1) return bisect_right(self.A, pos) 224 ms ","date":"2017-03-18","objectID":"/leetcode/0528/:3:0","tags":null,"title":"0528：按权重随机选择（★★）","uri":"/leetcode/0528/"},{"categories":null,"content":"题目 假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始）， 只要满足下述条件 之一 ，该数组就是一个 优美的排列 ： perm[i] 能够被 i 整除 i 能够被 perm[i] 整除 给你一个整数 n ，返回可以构造的 优美排列 的 数量 。 示例 1： 输入：n = 2\r输出：2\r解释：\r第 1 个优美的排列是 [1,2]：\r- perm[1] = 1 能被 i = 1 整除\r- perm[2] = 2 能被 i = 2 整除\r第 2 个优美的排列是 [2,1]:\r- perm[1] = 2 能被 i = 1 整除\r- i = 2 能被 perm[2","date":"2017-03-16","objectID":"/leetcode/0526/:1:0","tags":null,"title":"0526：优美的排列（★★）","uri":"/leetcode/0526/"},{"categories":null,"content":"分析 假设最后一个数是 x，满足 x%n==0 或 n%x==0， 那么剩下的转为子问题：求集合 set(range(1,n+1))-{x} 中构造优美排列的个数。 所以令 dfs(A) 代表集合 A 构造的优美排列个数，即可递归。 为了方便，可以将集合状态压缩为一个数。 ","date":"2017-03-16","objectID":"/leetcode/0526/:2:0","tags":null,"title":"0526：优美的排列（★★）","uri":"/leetcode/0526/"},{"categories":null,"content":"解答 def countArrangement(self, n: int) -\u003e int: dp = [1]+[0]*((1\u003c\u003cn)-1) for st in range(1\u003c\u003cn): idx = bin(st).count('1')+1 for x in range(n): if not st\u0026(1\u003c\u003cx) and ((x+1)%idx==0 or idx%(x+1)==0): dp[st|(1\u003c\u003cx)] += dp[st] return dp[-1] 160 ms ","date":"2017-03-16","objectID":"/leetcode/0526/:3:0","tags":null,"title":"0526：优美的排列（★★）","uri":"/leetcode/0526/"},{"categories":null,"content":"题目 给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。 请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。 所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。 尽量最少调用内置的随机函数，并且优化时间和空间复杂度。 实现 Solution 类： Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象 int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变","date":"2017-03-09","objectID":"/leetcode/0519/:1:0","tags":null,"title":"0519：随机翻转矩阵（★★★）","uri":"/leetcode/0519/"},{"categories":null,"content":"分析 ","date":"2017-03-09","objectID":"/leetcode/0519/:2:0","tags":null,"title":"0519：随机翻转矩阵（★★★）","uri":"/leetcode/0519/"},{"categories":null,"content":"#1 调用次数最多 1000，所以可以考虑暴力法。维护值为 1 的下标集合，每轮拒绝采样即可。 class Solution: def __init__(self, m: int, n: int): self.m = m self.n = n self.vis = set() def flip(self) -\u003e List[int]: while True: i = random.randint(0, self.m-1) j = random.randint(0, self.n-1) if (i, j) not in self.vis: self.vis.add((i, j)) return [","date":"2017-03-09","objectID":"/leetcode/0519/:2:1","tags":null,"title":"0519：随机翻转矩阵（★★★）","uri":"/leetcode/0519/"},{"categories":null,"content":"#2 还有个巧妙的方法是类似 0710，将返回过的下标映射为连续区间，从而方便随机。 具体来说： 设数组 A=list(range(m*n))，将 (i, j) 看作是 A 的下标 i*n+j\r设已经选过了 cnt 个下标，并且都交换到了 A[:cnt]\r用哈希表 d 维护 A[cnt:] 中经过了交换的数\r那么调用 flip 时\r随机一个 \u003e=cnt 的下标 y，A[y]=d.get(y,y)，转回二维坐标 (i,j) 即是结果\r更新 d[y] = d.get(cnt, cnt)，代表 A[y] 和 A[cnt] 进行了交换\r","date":"2017-03-09","objectID":"/leetcode/0519/:2:2","tags":null,"title":"0519：随机翻转矩阵（★★★）","uri":"/leetcode/0519/"},{"categories":null,"content":"解答 class Solution: def __init__(self, m: int, n: int): self.m = m self.n = n self.cnt = 0 self.d = {} def flip(self) -\u003e List[int]: y = random.randint(self.cnt, self.m*self.n-1) x = self.d.get(y, y) self.d[y] = self.d.get(self.cnt, self.cnt) self.cnt += 1 return [x // self.n, x % self.n] def reset(se","date":"2017-03-09","objectID":"/leetcode/0519/:3:0","tags":null,"title":"0519：随机翻转矩阵（★★★）","uri":"/leetcode/0519/"},{"categories":null,"content":"题目 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 示例 1： 输入：amount = 5, coins = [1, 2, 5]\r输出：4\r解释：有四种方式可以凑成总金额：\r5=5\r5=2+2+1\r5=2+1+1+1\r5=1+1+1+1+1\r示例 2： 输入：amount = 3, coins = [2]\r输出：0\r解释：只用面额 2 的硬币不能凑成总金额 3 。\r示例 3： 输入：a","date":"2017-03-08","objectID":"/leetcode/0518/:1:0","tags":null,"title":"0518：零钱兑换 II（★★）","uri":"/leetcode/0518/"},{"categories":null,"content":"分析 ","date":"2017-03-08","objectID":"/leetcode/0518/:2:0","tags":null,"title":"0518：零钱兑换 II（★★）","uri":"/leetcode/0518/"},{"categories":null,"content":"#1 将硬币组合按升序排列，只要排列不同，就是不同的组合。 那么总金额 amount 的组合有两种可能： 最后一个硬币是 coins[-1]，转为 (amount-coins[-1], coins) 的子问题 最后一个硬币不是 coins[-1]，转为 (amount, coins[:-1]) 的子问题 因此，令 dfs(i, j) 代表总金额 j 由 coins[:i+1] 组成的种数，即可递归。 def change(self, amount: int, coins: List[int]) -\u003e int: @lru_cache(None) def dfs(i, j): if i\u003c0 or ","date":"2017-03-08","objectID":"/leetcode/0518/:2:1","tags":null,"title":"0518：零钱兑换 II（★★）","uri":"/leetcode/0518/"},{"categories":null,"content":"#2 可以改写成非递归形式，递推式为： dp[i][j]=dp[i][j-coins[i]]+dp[i-1][j]\r注意到 dp[i][j] 依赖的是 dp[i-1][j]，可以直接优化为一维数组。 这是典型的完全背包问题 ","date":"2017-03-08","objectID":"/leetcode/0518/:2:2","tags":null,"title":"0518：零钱兑换 II（★★）","uri":"/leetcode/0518/"},{"categories":null,"content":"解答 def change(self, amount: int, coins: List[int]) -\u003e int: dp = [1]+[0]*amount for coin in coins: for j in range(coin, amount+1): dp[j] += dp[j-coin] return dp[-1] 116 ms ","date":"2017-03-08","objectID":"/leetcode/0518/:3:0","tags":null,"title":"0518：零钱兑换 II（★★）","uri":"/leetcode/0518/"},{"categories":null,"content":"题目 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 输入：s = \"bbbab\"\r输出：4\r解释：一个可能的最长回文子序列为 \"bbbb\" 。\r示例 2： 输入：s = \"cbbd\"\r输出：2\r解释：一个可能的最长回文子序列为 \"bb\" 。\r提示： 1 \u003c= s.length \u003c= 1000 s 仅由小写英文字母组成 ","date":"2017-03-06","objectID":"/leetcode/0516/:1:0","tags":null,"title":"0516：最长回文子序列（★★）","uri":"/leetcode/0516/"},{"categories":null,"content":"分析 显然当 s[0]==s[-1] 时，可以转为子问题。当 s[0]!=s[-1] 时，发现也可以转为两个子问题。 因此令 dfs(i, j) 代表 s[i:j+1] 的最长回文子序列的长度，即可递归。 这是典型的区间 dp。 ","date":"2017-03-06","objectID":"/leetcode/0516/:2:0","tags":null,"title":"0516：最长回文子序列（★★）","uri":"/leetcode/0516/"},{"categories":null,"content":"解答 def longestPalindromeSubseq(self, s: str) -\u003e int: @lru_cache(None) def dfs(i, j): if i\u003e=j: return j-i+1 if s[i]==s[j]: return 2+dfs(i+1, j-1) return max(dfs(i+1, j), dfs(i, j-1)) return dfs(0, len(s)-1) 时间复杂度 O(N^2)，852 ms ","date":"2017-03-06","objectID":"/leetcode/0516/:3:0","tags":null,"title":"0516：最长回文子序列（★★）","uri":"/leetcode/0516/"},{"categories":null,"content":"那个国家中栖息着龙——\n神话中说，古时的人与龙定下了契约，龙帮助人，人帮助龙……\n舞台是“龙之国”。\n主人公是为国之守护神“龙”清理蛀牙菌的新手牙医——野野子。\n与邻国的战争日趋激烈，某天她在龙的牙上发现了昏倒的敌国少年兵。\n少年的名字是贝尔。\n他在被称作巨大灾难前会出现的不可思议现象中，于巨大的牙齿中复活了。\n贝尔对自己的处境感到茫然。为了鼓励他，野野子将他接纳为龙的牙医。\n虽然被卷入了激烈的战争，两人不久将去接受自己的命运……\n这是一场前所未有的雄壮、奇幻冒险！","date":"2017-02-18","objectID":"/anime/the_dragon_dentist/","tags":null,"title":"龙的牙医","uri":"/anime/the_dragon_dentist/"},{"categories":null,"content":"简介 那个国家中栖息着龙—— 神话中说，古时的人与龙定下了契约，龙帮助人，人帮助龙…… 舞台是“龙之国”。 主人公是为国之守护神“龙”清理蛀牙菌的新手牙医——野野子。 与邻国的战争日趋激烈，某天她在龙的牙上发现了昏倒的敌国少年兵。 少年的名字是贝尔。 他在被称作巨大灾难前会出现的不可思议现象中，于巨大的牙齿中复活了。 贝尔对自己的处境感到茫然。为了鼓励他，野野子将他接纳为龙的牙医。 虽然被卷入了激烈的战争，两人不久将去接受自己的命运…… 这是一场前所未有的雄壮、奇幻冒险！ 制作人员： 原作：舞城王太郎 导演：鹤卷和哉 脚本：榎户洋司 分镜：寺冈岩、片山一良、鬼冢大辅、吉崎响 ","date":"2017-02-18","objectID":"/anime/the_dragon_dentist/:1:0","tags":null,"title":"龙的牙医","uri":"/anime/the_dragon_dentist/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 岸井野野子 Kishii Nonoko、きしい ののこ 女 清水富美加 2 ベルナール・オクタビアス 男 岡本信彦 3 悟堂ヨ世夫 男 山寺宏一 4 夏目柴名 女 林原めぐみ 5 サルバトール・ブランコ 男 松尾スズキ 6 有栖川カンネ 女 名塚佳織 7 佐藤修三 男 徳本恭敏 8 家村宗达 男 高木渉 ","date":"2017-02-18","objectID":"/anime/the_dragon_dentist/:2:0","tags":null,"title":"龙的牙医","uri":"/anime/the_dragon_dentist/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙的牙医 2017-02-18 01:32:00 bilibili ","date":"2017-02-18","objectID":"/anime/the_dragon_dentist/:3:0","tags":null,"title":"龙的牙医","uri":"/anime/the_dragon_dentist/"},{"categories":null,"content":"在单身的辛苦OL小林身边突然出现的女仆装束的美少女托尔。\n长着角和尾巴的她的身姿正是所谓的龙娘。\n在醉酒的小林邀请下说要到家里去的托尔，鬼使神差地开始以小林家女仆的身份工作……！？\n“女仆”+“龙”=“女仆龙”有着笨手笨脚的可爱之处！\n龙娘与人类之间基本上很温暖、偶尔有些黑暗的异种族间交流喜剧！！","date":"2017-01-11","objectID":"/anime/dragon_maid/","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":"简介 在单身的辛苦OL小林身边突然出现的女仆装束的美少女托尔。 长着角和尾巴的她的身姿正是所谓的龙娘。 在醉酒的小林邀请下说要到家里去的托尔，鬼使神差地开始以小林家女仆的身份工作……！？ “女仆”+“龙”=“女仆龙”有着笨手笨脚的可爱之处！ 龙娘与人类之间基本上很温暖、偶尔有些黑暗的异种族间交流喜剧！！ 制作人员： 原作：酷教信徒 导演：武本康弘 脚本：西川昌志、山田由香、志茂文彦 分镜：木上益治、石原立也、山田尚子 ","date":"2017-01-11","objectID":"/anime/dragon_maid/:1:0","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小林小姐 小林、こばやし、Kobayashi 女 田村睦心 2 托尔 朵露、小林托尔、Tohru、小林 トール、こばやし トール、Kobayashi Tōru 女 桑原由気 3 康娜卡姆依 小林康娜(小林 カンナ,こばやし カンナ,Kobayashi Kanna)、神奈神威、阿澄雷神、カンナカムイ、Kanna Kamui 女 長縄まりあ 4 艾露玛 艾尔玛、艾玛、上井艾露玛、上井艾尔玛、上井艾玛、Joui Elma、上井エルマ、じょうい エルマ、Jōi Eruma 女 高田憂希 5 露科亚 露可亚、尔科亚、ルコア、Rukoa、Lucoa、魁札尔科亚特尔、Qu","date":"2017-01-11","objectID":"/anime/dragon_maid/:2:0","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 小林家的龙女仆 2017-01-11 13 bilibili 2 小林家的龙女仆S 2021-07-07 12 bilibili ","date":"2017-01-11","objectID":"/anime/dragon_maid/:3:0","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":"MAD ","date":"2017-01-11","objectID":"/anime/dragon_maid/:4:0","tags":null,"title":"小林家的龙女仆","uri":"/anime/dragon_maid/"},{"categories":null,"content":"《动物朋友》是由“动物朋友企划”（famima.com、东京电视台、KADOKAWA、胜利娱乐、Crunchyroll SC动画基金、AT-X、SYS、人脉、Age Global Networks、Just Production、DOCOMO动画商城、武士道）发起的跨媒体企划。该企划最初的产品是由总部位于东京的游戏公司Nexon在2015年开发的手机游戏。以游戏中的兽娘为主角的漫画《动物朋友 -欢迎来到加帕里公园！-》则于同年5月至2017年1月在《月刊少年Ace》连载。《Keroro军曹》的作者吉崎观音是该企划的概念设计和角色设计者。\n\n2016年10月21日，“动物朋友企划A”宣布制作电视动画《动物朋友》。动画于2017年1月10日首播。\n\n建造于这个世界某处的超巨大综合动物园“Japari Park”，在那里，在神秘物质“Sandstar”的力量下，动物们接连变身成为拥有人类姿态的“动物娘”——！她们开始与来访的人们热闹地游玩。\n但，时间流逝……\n有一天，动物园里出现了一个看上去很困扰的迷路孩子。本是为了回家而踏上的旅途，因为动物娘们的加入，变成了一场大冒险！？","date":"2017-01-10","objectID":"/anime/kemono_friends/","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":"简介 《动物朋友》是由“动物朋友企划”（famima.com、东京电视台、KADOKAWA、胜利娱乐、Crunchyroll SC动画基金、AT-X、SYS、人脉、Age Global Networks、Just Production、DOCOMO动画商城、武士道）发起的跨媒体企划。该企划最初的产品是由总部位于东京的游戏公司Nexon在2015年开发的手机游戏。以游戏中的兽娘为主角的漫画《动物朋友 -欢迎来到加帕里公园！-》则于同年5月至2017年1月在《月刊少年Ace》连载。《Keroro军曹》的作者吉崎观音是该企划的概念设计和角色设计者。 2016年10月21日，“动物朋友企划A”宣布制作","date":"2017-01-10","objectID":"/anime/kemono_friends/:1:0","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 薮猫 Serval、Sābaru、Leptailurus serval 野中藍 2 包 小包、卡邦、背包、小鞄、Kaban、鞄 女 内田彩 3 幸运兽 Lackey beast、ボス、老大、Lucky Beast、幸運の獣、らっきーびーすと、ラッキーさん ？？？ 4 耳廓狐 Vulpes zerda、Fennec、Fenekku 本宮佳奈 5 浣熊 Procyon lotor、Common raccoon、Araiguma 小野早稀 6 巴布亚企鹅 金图企鹅、Gentoo penguin、Jentsūpengin、Pygoscelis papua 田村響華 ","date":"2017-01-10","objectID":"/anime/kemono_friends/:2:0","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 兽娘动物园 2017-01-10 12 bilibili ","date":"2017-01-10","objectID":"/anime/kemono_friends/:3:0","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":"MAD ","date":"2017-01-10","objectID":"/anime/kemono_friends/:4:0","tags":null,"title":"兽娘动物园","uri":"/anime/kemono_friends/"},{"categories":null,"content":"题目 电子游戏“辐射4”中，任务 “通向自由” 要求玩家到达名为 “Freedom Trail Ring” 的金属表盘， 并使用表盘拼写特定关键词才能开门。 给定一个字符串 ring ，表示刻在外环上的编码；给定另一个字符串 key ，表示需要拼写的关键词。 您需要算出能够拼写关键词中所有字符的最少步数。 最初，ring 的第一个字符与 12:00 方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符 在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。 旋转 ring 拼出 key 字符 key[i] 的阶段中： 您可以将 ring 顺时针或逆","date":"2016-12-30","objectID":"/leetcode/0514/:1:0","tags":null,"title":"0514：自由之路（★★）","uri":"/leetcode/0514/"},{"categories":null,"content":"分析 先按顺/逆时针找到第一个 key[0] 后，可以转为递归子问题。 那么令 dfs(i, j) 代表当 ring[i] 对齐北方时，拼写 key[j:] 的最少步数，即可递推。 要找与 ring[i] 最近的 key[j] 位置，考虑保存 ring 中每个字符的位置列表（递增的）， 然后可以二分查找离 i 最近的某字符位置，节省时间。 ","date":"2016-12-30","objectID":"/leetcode/0514/:2:0","tags":null,"title":"0514：自由之路（★★）","uri":"/leetcode/0514/"},{"categories":null,"content":"解答 def findRotateSteps(self, ring: str, key: str) -\u003e int: @lru_cache(None) def dfs(i, j): if j == len(key): return 0 A = d[key[j]] pos = bisect_left(A, i) left, right = A[pos-1], A[pos % len(A)] return 1+min((i-left)%n+dfs(left, j+1), (right-i)%n+dfs(right, j+1)) d, n = defaultdict(list), len(ring) ","date":"2016-12-30","objectID":"/leetcode/0514/:3:0","tags":null,"title":"0514：自由之路（★★）","uri":"/leetcode/0514/"},{"categories":null,"content":"　　曾拥有过辉煌风光年代的一家歌剧院正逐步走向没落，更面临被银行抵押没收的命运。现任老板考拉巴斯特（马修·麦康纳希 Matthew McConaughey 配音）不愿见父亲毕生的心血就此终结，于是决定策划一场歌唱选秀比赛，却没留神把奖金印成了他根本无力承担的10万美元。受到奖金和歌唱梦想的鼓舞，猪妈妈罗茜塔（瑞茜·威瑟斯彭 Reese Witherspoon 饰）、少女豪猪艾什（斯嘉丽·约翰森 Scarlett Johansson 饰）、老鼠歌手麦克（塞斯·麦克法兰 Seth MacFarlane 饰）、害羞的小象米纳（托瑞·凯利Tori Kelly 饰）、大猩猩强尼（塔伦·埃格顿 Taron Egerton 饰）等音乐爱好者都纷纷前来应征。\n　　他们有着各自难以逾越的障碍，而为了各自的梦想，有竭尽全力，追逐哪怕一点点微茫的希望……","date":"2016-12-21","objectID":"/anime/sing/","tags":null,"title":"欢乐好声音","uri":"/anime/sing/"},{"categories":null,"content":"简介 曾拥有过辉煌风光年代的一家歌剧院正逐步走向没落，更面临被银行抵押没收的命运。现任老板考拉巴斯特（马修·麦康纳希 Matthew McConaughey 配音）不愿见父亲毕生的心血就此终结，于是决定策划一场歌唱选秀比赛，却没留神把奖金印成了他根本无力承担的10万美元。受到奖金和歌唱梦想的鼓舞，猪妈妈罗茜塔（瑞茜·威瑟斯彭 Reese Witherspoon 饰）、少女豪猪艾什（斯嘉丽·约翰森 Scarlett Johansson 饰）、老鼠歌手麦克（塞斯·麦克法兰 Seth MacFarlane 饰）、害羞的小象米纳（托瑞·凯利Tori Kelly 饰）、大猩猩强尼（塔伦·埃格顿 Taro","date":"2016-12-21","objectID":"/anime/sing/:1:0","tags":null,"title":"欢乐好声音","uri":"/anime/sing/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾什 雌 Scarlett Johansson 2 月伯乐 雄 Matthew McConaughey 3 Mike 雄 Seth MacFarlane 4 罗茜塔 雌 5 米娜 雌 6 乔尼 雄 7 埃迪 雄 John C. Reilly 8 Bob News Reporter Dog 雄 Bill Farmer ","date":"2016-12-21","objectID":"/anime/sing/:2:0","tags":null,"title":"欢乐好声音","uri":"/anime/sing/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 欢乐好声音 2016-12-21 1 樱花 ","date":"2016-12-21","objectID":"/anime/sing/:3:0","tags":null,"title":"欢乐好声音","uri":"/anime/sing/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-12-16","objectID":"/leetcode/0500/:0:0","tags":null,"title":"0500：键盘行（★）","uri":"/leetcode/0500/"},{"categories":null,"content":"题目 给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。 美式键盘 中： 第一行由字符 “qwertyuiop” 组成。 第二行由字符 “asdfghjkl” 组成。 第三行由字符 “zxcvbnm” 组成。 提示： 1 \u003c= words.length \u003c= 20 1 \u003c= words[i].length \u003c= 100 words[i] 由英文字母（小写和大写字母）组成 示例 1： 输入：words = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]\r输出：[\"Alaska\",\"Dad\"]\r示例 2： 输入：words ","date":"2016-12-16","objectID":"/leetcode/0500/:1:0","tags":null,"title":"0500：键盘行（★）","uri":"/leetcode/0500/"},{"categories":null,"content":"分析 遍历判断每个单词的字符集合是否是某一行的子集即可。 注意单词可能有大写，要先全转为小写。 ","date":"2016-12-16","objectID":"/leetcode/0500/:2:0","tags":null,"title":"0500：键盘行（★）","uri":"/leetcode/0500/"},{"categories":null,"content":"解答 def findWords(self, words: List[str]) -\u003e List[str]: return [word for word in words if any(set(word.lower()) \u003c= set(s) for s in [\"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\"])] 32 ms ","date":"2016-12-16","objectID":"/leetcode/0500/:3:0","tags":null,"title":"0500：键盘行（★）","uri":"/leetcode/0500/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-12-13","objectID":"/leetcode/0497/:0:0","tags":null,"title":"0497：非重叠矩形中的随机点（★★）","uri":"/leetcode/0497/"},{"categories":null,"content":"题目 给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点，(xi, yi) 是第 i 个矩形的右上角角点。 设计一个算法来挑选一个随机整数点内的空间所覆盖的一个给定的矩形。矩形周长上的一个点包含在矩形覆盖的空间中。 在一个给定的矩形覆盖的空间内任何整数点都有可能被返回。 请注意 ，整数点是具有整数坐标的点。 实现 Solution 类: Solution(int[][] rects) 用给定的矩形数组 rects 初始化对象。 int[] pick() 返回一个随机的整数点 [u, ","date":"2016-12-13","objectID":"/leetcode/0497/:1:0","tags":null,"title":"0497：非重叠矩形中的随机点（★★）","uri":"/leetcode/0497/"},{"categories":null,"content":"分析 类似 0528 ，不过变成了二维。 矩阵内点的个数即是矩阵权重。 随机取到一个点后，先找出属于哪一个矩形，还可以得到在该矩形中排第几位，再按预定映射得到该矩形中的某一点。 ","date":"2016-12-13","objectID":"/leetcode/0497/:2:0","tags":null,"title":"0497：非重叠矩形中的随机点（★★）","uri":"/leetcode/0497/"},{"categories":null,"content":"解答 class Solution: def __init__(self, rects: List[List[int]]): self.rects = rects self.pre = list(accumulate((x2-x1+1)*(y2-y1+1) for x1,y1,x2,y2 in rects)) def pick(self) -\u003e List[int]: rank = random.randint(1, self.pre[-1]) i = bisect_left(self.pre, rank) rank -= self.pre[i-1] if i else 0 x1, y1, x2","date":"2016-12-13","objectID":"/leetcode/0497/:3:0","tags":null,"title":"0497：非重叠矩形中的随机点（★★）","uri":"/leetcode/0497/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 ‘+’ 或 ‘-’ ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 输入：nums = [1,1,1,1,1], target = 3\r输出：5\r解释：一共有 5 种方法让最终目标和为 3 。\r-1 + 1 + 1 + 1 + 1 = 3\r+1 - 1 + 1 + 1 + 1 ","date":"2016-12-10","objectID":"/leetcode/0494/:1:0","tags":null,"title":"0494：目标和（★★）","uri":"/leetcode/0494/"},{"categories":null,"content":"分析 注意到 sum(nums)\u003c=1000，因此考虑直接递推表达式的和与对应的个数。 令 dp[i] 代表 nums[:i] 得到的计数器，key 为表达式的和，即可递推。 ","date":"2016-12-10","objectID":"/leetcode/0494/:2:0","tags":null,"title":"0494：目标和（★★）","uri":"/leetcode/0494/"},{"categories":null,"content":"解答 def findTargetSumWays(self, nums: List[int], target: int) -\u003e int: ct = Counter({0: 1}) for num in nums: ct2 = Counter() for k in ct: ct2[k+num] += ct[k] ct2[k-num] += ct[k] ct = ct2 return ct[target] 260 ms ","date":"2016-12-10","objectID":"/leetcode/0494/:3:0","tags":null,"title":"0494：目标和（★★）","uri":"/leetcode/0494/"},{"categories":null,"content":"题目 给定一个数组 nums ，如果 i \u003c j 且 nums[i] \u003e 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。 你需要返回给定数组中的重要翻转对的数量。 示例 1: 输入: [1,3,2,3,1] 输出: 2 示例 2: 输入: [2,4,3,5,1] 输出: 3 注意: 给定数组的长度不会超过50000。 输入数组中的所有数字都在32位整数的表示范围内。 ","date":"2016-12-09","objectID":"/leetcode/0493/:1:0","tags":null,"title":"0493：翻转对（★★）","uri":"/leetcode/0493/"},{"categories":null,"content":"分析 遍历 j，找 nums[:j] 中大于 2*nums[j] 的个数。容易想到用有序集合维护 nums[:j]，然后二分查找即可。 ","date":"2016-12-09","objectID":"/leetcode/0493/:2:0","tags":null,"title":"0493：翻转对（★★）","uri":"/leetcode/0493/"},{"categories":null,"content":"解答 def reversePairs(self, nums: List[int]) -\u003e int: from sortedcontainers import SortedList res, sl = 0, SortedList() for num in nums: res += len(sl)-sl.bisect_right(num*2) sl.add(num) return res 832 ms ","date":"2016-12-09","objectID":"/leetcode/0493/:3:0","tags":null,"title":"0493：翻转对（★★）","uri":"/leetcode/0493/"},{"categories":null,"content":"题目 给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。 玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。 每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]）， 取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。 如果玩家 1 能成为赢家，返回 true 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家， 也返回 true 。你可以假设每个玩家的玩法都会使他的分数最大化。 示例 1：","date":"2016-12-02","objectID":"/leetcode/0486/:1:0","tags":null,"title":"0486：预测赢家（★★）","uri":"/leetcode/0486/"},{"categories":null,"content":"分析 博弈问题容易想到用递归。 考虑令 dfs(i, j) 表示用 nums[i:j+1] 玩游戏得到的玩家 1 和 2 的分数差，即可递归。 ","date":"2016-12-02","objectID":"/leetcode/0486/:2:0","tags":null,"title":"0486：预测赢家（★★）","uri":"/leetcode/0486/"},{"categories":null,"content":"解答 def PredictTheWinner(self, nums: List[int]) -\u003e bool: @lru_cache(None) def dfs(i, j): if i\u003ej: return 0 return max(nums[i]-dfs(i+1, j), nums[j]-dfs(i, j-1)) return dfs(0, len(nums)-1)\u003e=0 40 ms ","date":"2016-12-02","objectID":"/leetcode/0486/:3:0","tags":null,"title":"0486：预测赢家（★★）","uri":"/leetcode/0486/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-12-01","objectID":"/leetcode/0485/:0:0","tags":null,"title":"0485：最大连续 1 的个数","uri":"/leetcode/0485/"},{"categories":null,"content":"题目 给定一个二进制数组，计算其中最大连续 1 的个数。 提示： 输入的数组只包含 0 和 1 。 输入数组的长度是正整数，且不超过 10,000。 示例： 输入：[1,1,0,1,1,1]\r输出：3\r解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.\r","date":"2016-12-01","objectID":"/leetcode/0485/:1:0","tags":null,"title":"0485：最大连续 1 的个数","uri":"/leetcode/0485/"},{"categories":null,"content":"分析 遍历计数，遇到 0 重新开始计数即可。 ","date":"2016-12-01","objectID":"/leetcode/0485/:2:0","tags":null,"title":"0485：最大连续 1 的个数","uri":"/leetcode/0485/"},{"categories":null,"content":"解答 def findMaxConsecutiveOnes(self, nums: List[int]) -\u003e int: res, cnt = 0, 0 for num in nums: cnt = cnt + 1 if num else 0 res = max(res, cnt) return res 104 ms ","date":"2016-12-01","objectID":"/leetcode/0485/:3:0","tags":null,"title":"0485：最大连续 1 的个数","uri":"/leetcode/0485/"},{"categories":null,"content":"题目 给定圆的半径和圆心的位置，实现函数 randPoint ，在圆中产生均匀随机点。 实现 Solution 类: Solution(double radius, double x_center, double y_center) 用圆的半径 radius 和圆心的位置 (x_center, y_center) 初始化对象 randPoint() 返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回 [x, y] 。 示例 1： 输入: [\"Solution\",\"randPoint\",\"randPoint\",\"randPoint\"]\r[[1.0, 0.0, 0.0], [], [","date":"2016-11-25","objectID":"/leetcode/0478/:1:0","tags":null,"title":"0478：在圆内随机生成点（★★）","uri":"/leetcode/0478/"},{"categories":null,"content":"分析 可以用拒绝抽样，在外接正方形中随机，落在圆里就返回结果。 ","date":"2016-11-25","objectID":"/leetcode/0478/:2:0","tags":null,"title":"0478：在圆内随机生成点（★★）","uri":"/leetcode/0478/"},{"categories":null,"content":"解答 class Solution: def __init__(self, radius: float, x_center: float, y_center: float): self.x = x_center self.y = y_center self.r = radius def randPoint(self) -\u003e List[float]: while True: a = 1-2*random.random() b = 1-2*random.random() if a*a+b*b\u003c=1: return [self.x+a*self.r, self.y+b*self.r] 228 ms ","date":"2016-11-25","objectID":"/leetcode/0478/:3:0","tags":null,"title":"0478：在圆内随机生成点（★★）","uri":"/leetcode/0478/"},{"categories":null,"content":"题目 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 输入：strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\r输出：4\r解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。\r其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"1","date":"2016-11-21","objectID":"/leetcode/0474/:1:0","tags":null,"title":"0474：一和零（★★）","uri":"/leetcode/0474/"},{"categories":null,"content":"分析 ","date":"2016-11-21","objectID":"/leetcode/0474/:2:0","tags":null,"title":"0474：一和零（★★）","uri":"/leetcode/0474/"},{"categories":null,"content":"#1 显然按是否选 strs[0]，可以转为递归子问题。 令 dfs(i, j, k) 代表 strs[i:] 中最多 j 个 0、k 个 1 的最大子集长度，即可递归。 注意每个字符串有用的信息只有 0 和 1 的个数，可以提前求出保存，节省时间。 这本质上是个 01 背包问题，m、n 是限制条件，字符串的 0/1 个数是代价，求最多能选多少个。 def findMaxForm(self, strs: List[str], m: int, n: int) -\u003e int: @lru_cache(None) def dfs(i, j, k): if j\u003c0 or k\u003c0: return floa","date":"2016-11-21","objectID":"/leetcode/0474/:2:1","tags":null,"title":"0474：一和零（★★）","uri":"/leetcode/0474/"},{"categories":null,"content":"#2 可以改写成非递归形式，并且倒序遍历 j、k，将 dp 优化为二维数组。 ","date":"2016-11-21","objectID":"/leetcode/0474/:2:2","tags":null,"title":"0474：一和零（★★）","uri":"/leetcode/0474/"},{"categories":null,"content":"解答 def findMaxForm(self, strs: List[str], m: int, n: int) -\u003e int: dp = [[0]*(n+1) for _ in range(m+1)] for s in strs: cnt0, cnt1 = s.count('0'), s.count('1') for j in range(m, cnt0-1, -1): for k in range(n, cnt1-1, -1): dp[j][k] = max(dp[j][k], 1+dp[j-cnt0][k-cnt1]) return dp[-1][-1] 2652 ms ","date":"2016-11-21","objectID":"/leetcode/0474/:3:0","tags":null,"title":"0474：一和零（★★）","uri":"/leetcode/0474/"},{"categories":null,"content":"题目 你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。 你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。 如果你能使这个正方形，则返回 true ，否则返回 false 。 示例 1: 输入: matchsticks = [1,1,2,2,2]\r输出: true\r解释: 能拼成一个边长为2的正方形，每边两根火柴。\r示例 2: 输入: matchsticks = [3,3,3,3,4]\r输出: false\r解释: 不能用所有火柴拼成一个正方形。\r提示: 1 \u003c","date":"2016-11-20","objectID":"/leetcode/0473/:1:0","tags":null,"title":"0473：火柴拼正方形（★★★）","uri":"/leetcode/0473/"},{"categories":null,"content":"分析 为了方便，令 A=matchsticks，s=sum(A)。 显然当 s%4!=0 时非真。否则，要将 A 划分为四个和为 t=s//4 的子集。 暴力法就是遍历 A 的所有排列，判断是否能分割成功 假如排列的最后一个数是 x，那么只要 A-{x} 能组成 3 个和 t 的子集，即可成功 一般性地，令 dfs(B) 代表集合 B 能否组成 sum(B)//t 个和 t 的子集，尝试递推 从 B 中任选一个数 x，集合 C=B-x，只要 dfs(C) 为真且 x+sum(C)%t\u003c=t，dfs(B) 即为真 为了方便，可以令 dfs(B) 返回 sum(B)%t，若集合 B 非真，则返回 ","date":"2016-11-20","objectID":"/leetcode/0473/:2:0","tags":null,"title":"0473：火柴拼正方形（★★★）","uri":"/leetcode/0473/"},{"categories":null,"content":"解答 def makesquare(self, matchsticks: List[int]) -\u003e bool: s = sum(matchsticks) if s%4: return False A, n = matchsticks, len(matchsticks) dp = [0]+[-1]*((1\u003c\u003cn)-1) for st in range(1\u003c\u003cn): if dp[st]\u003e=0: for i in range(n): if not st\u0026(1\u003c\u003ci) and dp[st]+A[i]\u003c=s//4: dp[st|(1\u003c\u003ci)] = (dp[st]+A[i])%(s//4) return","date":"2016-11-20","objectID":"/leetcode/0473/:3:0","tags":null,"title":"0473：火柴拼正方形（★★★）","uri":"/leetcode/0473/"},{"categories":null,"content":"题目 给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。 你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。 每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。 示例 1: 输入: 1\r输出: [2]\r示例 2: 输入: 2\r输出: [2,8]\r示例 3: 输入: 3\r输出: [3,8,10]\r提示: 1 \u003c= n \u003c= 10^5 ","date":"2016-11-17","objectID":"/leetcode/0470/:1:0","tags":null,"title":"0470：用 Rand7() 实现 Rand10()（★）","uri":"/leetcode/0470/"},{"categories":null,"content":"分析 典型的拒绝抽样。调用两次 rand7，可以等价于 rand49，然后 1 到 40 均匀分为 10 份即可等价于 rand10。 如果大于 40，就重新抽样。 ","date":"2016-11-17","objectID":"/leetcode/0470/:2:0","tags":null,"title":"0470：用 Rand7() 实现 Rand10()（★）","uri":"/leetcode/0470/"},{"categories":null,"content":"解答 def rand10(self): while True: res = (rand7() - 1) * 7 + rand7() if res \u003c= 40: return res % 10 + 1 340 ms ","date":"2016-11-17","objectID":"/leetcode/0470/:3:0","tags":null,"title":"0470：用 Rand7() 实现 Rand10()（★）","uri":"/leetcode/0470/"},{"categories":null,"content":"题目 把字符串 s 看作是 “abcdefghijklmnopqrstuvwxyz” 的无限环绕字符串，所以 s 看起来是这样的： “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….” . 现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。 示例 1: 输入: p = \"a\"\r输出: 1\r解释: 字符串 s 中只有一个\"a\"子字符。\r示例 2: 输入: p = \"cac\"\r输出: 2\r解释: 字符串 s 中的字符串“cac”只有两个子串“a”、“c”。.\r示例 3: 输入: p = \"zab\"","date":"2016-11-14","objectID":"/leetcode/0467/:1:0","tags":null,"title":"0467：环绕字符串中唯一的子字符串（★★）","uri":"/leetcode/0467/"},{"categories":null,"content":"分析 容易想到用 dp[i] 代表以 p[i] 结尾的在 s 中的子串数量，即可递推。 但这样存在重复计算的问题，比如 ‘cac’ 中 ‘c’ 会被计算两次。 一个巧妙的想法是只需要找到以 ‘c’ 结尾的最长的在 s 中的子串，只统计这一个 ‘c’ 即可。 因此令 dp[x] 代表以 x 结尾的在 s 中的最长子串长度，最后 sum(dp[x]) 即为所求。 def findSubstringInWraproundString(self, p: str) -\u003e int: dp, cnt = defaultdict(int), 0 for i, x in enumerate(p): cnt = ","date":"2016-11-14","objectID":"/leetcode/0467/:2:0","tags":null,"title":"0467：环绕字符串中唯一的子字符串（★★）","uri":"/leetcode/0467/"},{"categories":null,"content":"题目 在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和， 先使得累计整数和 达到或超过 100 的玩家，即为胜者。 如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？ 例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 \u003e= 100。 给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和）， 若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。 示例 1： 输入：maxChoosableI","date":"2016-11-11","objectID":"/leetcode/0464/:1:0","tags":null,"title":"0464：我能赢吗（★★★）","uri":"/leetcode/0464/"},{"categories":null,"content":"分析 为了方便，令 M=maxChoosableInteger，T=desiredTotal。 假如 M*(M+1)//2\u003cT，显然没有人能赢。否则： 如果第一个玩家选了 x 后第二个玩家要输，则第一个玩家必赢 第一个玩家选了 x 后，第二个玩家面临的情况等价于可选集合为 {原集合去掉 x}、目标为 T-x 的子问题 因此令 dfs(A, T) 代表可选集合为 A、 目标 T 的情况下第一个玩家是否稳赢，即可递归。 为了方便表示集合，可以用状态压缩。 def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -\u003e bool: ","date":"2016-11-11","objectID":"/leetcode/0464/:2:0","tags":null,"title":"0464：我能赢吗（★★★）","uri":"/leetcode/0464/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-11-10","objectID":"/leetcode/0463/:0:0","tags":null,"title":"0463：岛屿的周长（★）","uri":"/leetcode/0463/"},{"categories":null,"content":"题目 给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。 网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围， 但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。 网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 提示： row == grid.length col == grid[i].length 1 \u003c= row, col \u003c= 1","date":"2016-11-10","objectID":"/leetcode/0463/:1:0","tags":null,"title":"0463：岛屿的周长（★）","uri":"/leetcode/0463/"},{"categories":null,"content":"分析 遍历陆地并去掉相邻陆地的重叠边即可。 ","date":"2016-11-10","objectID":"/leetcode/0463/:2:0","tags":null,"title":"0463：岛屿的周长（★）","uri":"/leetcode/0463/"},{"categories":null,"content":"解答 def islandPerimeter(self, grid: List[List[int]]) -\u003e int: res, m, n = 0, len(grid), len(grid[0]) for i, j in product(range(m), range(n)): if grid[i][j]: res += 4 if i and grid[i-1][j]: res -= 2 if j and grid[i][j-1]: res -= 2 return res 96 ms ","date":"2016-11-10","objectID":"/leetcode/0463/:3:0","tags":null,"title":"0463：岛屿的周长（★）","uri":"/leetcode/0463/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-11-06","objectID":"/leetcode/0460/:0:0","tags":null,"title":"0460：LFU 缓存（★★★）","uri":"/leetcode/0460/"},{"categories":null,"content":"题目 请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。 实现 LFUCache 类： LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象 int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。 void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。 当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。 在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。 注意「项的使用次数」就是自插入该项","date":"2016-11-06","objectID":"/leetcode/0460/:1:0","tags":null,"title":"0460：LFU 缓存（★★★）","uri":"/leetcode/0460/"},{"categories":null,"content":"分析 0146 的升级版。需要先找到最小使用次数的键集合，再找到最久未使用的键。 因此考虑用哈希表存 key 的使用次数 freq。而对于相同 freq 的键, 用 OrderedDict 维护顺序。 get 和 put 时先得到 key 的使用次数 freq，从 freq 对应的字典中弹出 key，并添加到 freq+1 对应的字典中。 如果是 put 新的 key 且容量达到上限，则找到最小使用次数 minFreq，从 minFreq 对应的 OrderedDict 中弹出首位元素。 注意到当 get 或 put 已有 key 时，minFreq 只可能不变或加 1，而 put 新的 ke","date":"2016-11-06","objectID":"/leetcode/0460/:2:0","tags":null,"title":"0460：LFU 缓存（★★★）","uri":"/leetcode/0460/"},{"categories":null,"content":"解答 class LFUCache: def __init__(self, capacity: int): self.ct = Counter() self.d = defaultdict(OrderedDict) self.capacity = capacity self.minFreq = 0 def pop(self, key): freq = self.ct[key] val = self.d[freq].pop(key) if not self.d[freq] and self.minFreq == freq: self.minFreq = freq+1 return freq, v","date":"2016-11-06","objectID":"/leetcode/0460/:3:0","tags":null,"title":"0460：LFU 缓存（★★★）","uri":"/leetcode/0460/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-11-05","objectID":"/leetcode/0459/:0:0","tags":null,"title":"0459：重复的子字符串（★★）","uri":"/leetcode/0459/"},{"categories":null,"content":"题目 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 示例 1: 输入: s = \"abab\"\r输出: true\r解释: 可由子串 \"ab\" 重复两次构成。\r示例 2: 输入: s = \"aba\"\r输出: false\r示例 3: 输入: s = \"abcabcabcabc\"\r输出: true\r解释: 可由子串 \"abc\" 重复四次构成。 (或子串 \"abcabc\" 重复两次构成。)\r提示： 1 \u003c= s.length \u003c= 10^4 s 由小写英文字母组成 ","date":"2016-11-05","objectID":"/leetcode/0459/:1:0","tags":null,"title":"0459：重复的子字符串（★★）","uri":"/leetcode/0459/"},{"categories":null,"content":"分析 ","date":"2016-11-05","objectID":"/leetcode/0459/:2:0","tags":null,"title":"0459：重复的子字符串（★★）","uri":"/leetcode/0459/"},{"categories":null,"content":"#1 假如长为 n 的 s 能由长 m 的子串 ss 组成，那么显然 n 是 m 的倍数。 因此考虑遍历所有 n 的因数（不包括 n）m，判断 s 是否由 s[:m] 重复构成即可。 def repeatedSubstringPattern(self, s: str) -\u003e bool: n = len(s) for i in range(1, int(sqrt(n))+1): if n%i==0: for j in [i, n//i]: if j\u003cn and s[:j]*(n//j)==s: return True return False 时间复杂度 $O(N*\\sqrt N)$，32 ms","date":"2016-11-05","objectID":"/leetcode/0459/:2:1","tags":null,"title":"0459：重复的子字符串（★★）","uri":"/leetcode/0459/"},{"categories":null,"content":"#2 还有个巧妙的方法，s 由子串 ss 重复组成等价于 ss 是 s[1:]+s[:-1] 的子串。 这也是一个经典的方法：证明 ","date":"2016-11-05","objectID":"/leetcode/0459/:2:2","tags":null,"title":"0459：重复的子字符串（★★）","uri":"/leetcode/0459/"},{"categories":null,"content":"解答 def repeatedSubstringPattern(self, s: str) -\u003e bool: return s in (s+s)[1:-1] 48 ms ","date":"2016-11-05","objectID":"/leetcode/0459/:3:0","tags":null,"title":"0459：重复的子字符串（★★）","uri":"/leetcode/0459/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-10-31","objectID":"/leetcode/0454/:0:0","tags":null,"title":"0454：四数相加 II（★★）","uri":"/leetcode/0454/"},{"categories":null,"content":"题目 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。 所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。 例如: 输入:\rA = [ 1, 2]\rB = [-2,-1]\rC = [-1, 2]\rD = [ 0, 2]\r输出:\r2\r解释:\r两个元组如下:\r1. (0, 0, 0, 1) -\u003e A[0] + B[0] + C[0] ","date":"2016-10-31","objectID":"/leetcode/0454/:1:0","tags":null,"title":"0454：四数相加 II（★★）","uri":"/leetcode/0454/"},{"categories":null,"content":"分析 采用 0018 的方法会超时，注意到本题是计算四元组的个数，而不需要列举出来。 因此在遍历时，可以直接用哈希表保存后两个数的和以及对应的频次，一下去掉后两层循环。 ","date":"2016-10-31","objectID":"/leetcode/0454/:2:0","tags":null,"title":"0454：四数相加 II（★★）","uri":"/leetcode/0454/"},{"categories":null,"content":"解答 def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -\u003e int: ct = Counter(c+d for c in nums3 for d in nums4) return sum(ct[-a-b] for a in nums1 for b in nums2) 时间复杂度 O(N^2)，576 ms ","date":"2016-10-31","objectID":"/leetcode/0454/:3:0","tags":null,"title":"0454：四数相加 II（★★）","uri":"/leetcode/0454/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-10-25","objectID":"/leetcode/0448/:0:0","tags":null,"title":"0448：找到所有数组中消失的数字（★）","uri":"/leetcode/0448/"},{"categories":null,"content":"题目 给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。 请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。 提示： n == nums.length 1 \u003c= n \u003c= 10^5 1 \u003c= nums[i] \u003c= n 进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。 示例 1： 输入：nums = [4,3,2,7,8,2,3,1]\r输出：[5,6]\r示例 2： 输入：nums = [1,1]\r输出：[2]\r","date":"2016-10-25","objectID":"/leetcode/0448/:1:0","tags":null,"title":"0448：找到所有数组中消失的数字（★）","uri":"/leetcode/0448/"},{"categories":null,"content":"分析 没说不能修改 nums，因此可以用 nums 来保存信息。遍历到 num 时，将对应的位置 num-1 取负数。 最后还为正数的位置 i，其对应的数 i+1 即是没有出现过的数字。 ","date":"2016-10-25","objectID":"/leetcode/0448/:2:0","tags":null,"title":"0448：找到所有数组中消失的数字（★）","uri":"/leetcode/0448/"},{"categories":null,"content":"解答 def findDisappearedNumbers(self, nums: List[int]) -\u003e List[int]: for num in nums: i = abs(num)-1 nums[i] = -abs(nums[i]) return [i+1 for i, num in enumerate(nums) if num\u003e0] 124 ms ","date":"2016-10-25","objectID":"/leetcode/0448/:3:0","tags":null,"title":"0448：找到所有数组中消失的数字（★）","uri":"/leetcode/0448/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-10-24","objectID":"/leetcode/0447/:0:0","tags":null,"title":"0447：回旋镖的数量（★）","uri":"/leetcode/0447/"},{"categories":null,"content":"题目 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。 回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 返回平面上所有回旋镖的数量。 提示： n == points.length 1 \u003c= n \u003c= 500 points[i].length == 2 -10^4 \u003c= xi, yi \u003c= 10^4 所有点都 互不相同 示例 1： 输入：points = [[0,0],[1,0],[2,0]]\r输出：2\r解释：两个回旋镖为 [[1,0],[0,0],[2,0","date":"2016-10-24","objectID":"/leetcode/0447/:1:0","tags":null,"title":"0447：回旋镖的数量（★）","uri":"/leetcode/0447/"},{"categories":null,"content":"分析 n 个点各不相同，因此可以遍历 n 个点，作为回旋镖的中心，计算能构成多少回旋镖。 具体的，可以统计每个点到该点的距离。假设有 v 个点到该点的距离都为 dis，那么对应的回旋镖数量即为 v*(v-1)。 ","date":"2016-10-24","objectID":"/leetcode/0447/:2:0","tags":null,"title":"0447：回旋镖的数量（★）","uri":"/leetcode/0447/"},{"categories":null,"content":"解答 def numberOfBoomerangs(self, points: List[List[int]]) -\u003e int: res = 0 for x in points: ct = Counter((x[0]-y[0])**2+(x[1]-y[1])**2 for y in points) res += sum(v*(v-1) for v in ct.values()) return res 1292 ms ","date":"2016-10-24","objectID":"/leetcode/0447/:3:0","tags":null,"title":"0447：回旋镖的数量（★）","uri":"/leetcode/0447/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-10-23","objectID":"/leetcode/0446/:0:0","tags":null,"title":"0446：等差数列划分 II - 子序列（★★）","uri":"/leetcode/0446/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。 如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。 例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。 再例如，[1, 1, 2, 5, 7] 不是等差序列。 数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。 例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。 题目数据保证答案是一个 32-bit 整数。 示例 1： 输入：nums = [2,4,6,8,10]\r输","date":"2016-10-23","objectID":"/leetcode/0446/:1:0","tags":null,"title":"0446：等差数列划分 II - 子序列（★★）","uri":"/leetcode/0446/"},{"categories":null,"content":"分析 考虑求以 nums[i] 结尾的等差子序列数目，遍历 j\u003ci，只要知道了以 nums[j] 结尾且差为 nums[i]-nums[j] 的等差子序列数目（长度 2 的也算），即可递推。 因此令 dp[i] 代表以 nums[i] 结尾的长度 \u003e=2 的等差子序列的计数器，计数的 key 是差。 递推过程中，将长度 \u003e=3 的等差子序列数目累加即可。 ","date":"2016-10-23","objectID":"/leetcode/0446/:2:0","tags":null,"title":"0446：等差数列划分 II - 子序列（★★）","uri":"/leetcode/0446/"},{"categories":null,"content":"解答 def numberOfArithmeticSlices(self, nums: List[int]) -\u003e int: res, n = 0, len(nums) dp = [defaultdict(int) for _ in range(n)] for i in range(n): for j in range(i): diff = nums[i]-nums[j] dp[i][diff] += 1+dp[j][diff] res += dp[j][diff] return res 904 ms ","date":"2016-10-23","objectID":"/leetcode/0446/:3:0","tags":null,"title":"0446：等差数列划分 II - 子序列（★★）","uri":"/leetcode/0446/"},{"categories":null,"content":"不善言辞却成为营业部员的马缔光也，与看似轻佻却成为辞典编辑部员的西冈正志，偶然在街上相遇。\n推进着中型国语辞典《大渡海》刊行计划的出版社·玄武书房的老牌编辑·荒木，因自己临近退休而努力寻找着后继者。此时他从西冈那里听闻了马缔的事情，于是选上了他……。\n“将联系人与人的——言语编织起来”\n无法传达的话语。不能传达的思念。\n这是，如此笨拙的人们所展开的故事。","date":"2016-10-13","objectID":"/anime/the_great_passage/","tags":null,"title":"编舟记","uri":"/anime/the_great_passage/"},{"categories":null,"content":"简介 不善言辞却成为营业部员的马缔光也，与看似轻佻却成为辞典编辑部员的西冈正志，偶然在街上相遇。 推进着中型国语辞典《大渡海》刊行计划的出版社·玄武书房的老牌编辑·荒木，因自己临近退休而努力寻找着后继者。此时他从西冈那里听闻了马缔的事情，于是选上了他……。 “将联系人与人的——言语编织起来” 无法传达的话语。不能传达的思念。 这是，如此笨拙的人们所展开的故事。 制作人员： 原作：三浦紫苑 导演：黑柳利充 脚本：富田赖子、木户雄一郎、根元岁三、佐藤卓哉 分镜：田头忍、长屋诚志郎 ","date":"2016-10-13","objectID":"/anime/the_great_passage/:1:0","tags":null,"title":"编舟记","uri":"/anime/the_great_passage/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 马缔光也 馬締 光也、まじめ みつや、Majime Mitsuya 男 櫻井孝宏 2 林香具矢 林 香具矢、はやし かぐや、Hayashi Kaguya 女 坂本真綾 3 西冈正志 西岡 正志、にしおか まさし、Nishioka Masashi 男 神谷浩史 4 荒木公平 あらきこうへい 男 金尾哲夫 5 松本朋佑 まつもとともすけ 男 麦人 6 佐佐木薰 ささき かおる 女 榊原良子 7 三好丽美 みよし れみ 女 斎藤千和 8 岸边绿 きしべ みどり、Kishibe Midori 女 日笠陽子 ","date":"2016-10-13","objectID":"/anime/the_great_passage/:2:0","tags":null,"title":"编舟记","uri":"/anime/the_great_passage/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 编舟记 2016-10-13 11 bilibili ","date":"2016-10-13","objectID":"/anime/the_great_passage/:3:0","tags":null,"title":"编舟记","uri":"/anime/the_great_passage/"},{"categories":null,"content":"题目 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。 返回 需要移除区间的最小数量，使剩余区间互不重叠 。 示例 1: 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]\r输出: 1\r解释: 移除 [1,3] 后，剩下的区间没有重叠。\r示例 2: 输入: intervals = [ [1,2], [1,2], [1,2] ]\r输出: 2\r解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\r示例 3: 输入: intervals = [ [1,2], [2,3] ]\r输出: 0\r解释: 你不","date":"2016-10-12","objectID":"/leetcode/0435/:1:0","tags":null,"title":"0435：无重叠区间（★★）","uri":"/leetcode/0435/"},{"categories":null,"content":"分析 ","date":"2016-10-12","objectID":"/leetcode/0435/:2:0","tags":null,"title":"0435：无重叠区间（★★）","uri":"/leetcode/0435/"},{"categories":null,"content":"#1 可以反过来找最大的不重叠区间子集，剩下的即是最小数量。 考虑先排序，然后问题等价于找一个最长的递增子序列（区间意义上的大小关系）。 于是可以用 0300 的方法解决，但要注意区间比较大小的特殊性： 令 A[k] 代表当前所有长度为 k+1 的递增子序列的最小尾数（这里是指最后一个区间的 end） 对于区间 \u003cstart, end\u003e，二分查找最后一个 k 使得 A[k]\u003c=start 更新 A[k+1] 为 min(A[k+1], end) def eraseOverlapIntervals(self, intervals: List[List[int]]) -\u003e int: interva","date":"2016-10-12","objectID":"/leetcode/0435/:2:1","tags":null,"title":"0435：无重叠区间（★★）","uri":"/leetcode/0435/"},{"categories":null,"content":"#2 本题还有个巧妙的想法，必然存在一个最优解使得第一个区间是 end 最小的区间。 证明很简单，假如最优解的第一个区间是 \u003cs, e\u003e，那么将它替换为 end 最小的区间，依然是最优解。 那么去除掉与第一个区间重叠的区间后，剩下的就是子问题了，可以用同样的策略。 因此将区间按 end 最小到大排序，能放就放即可。 ","date":"2016-10-12","objectID":"/leetcode/0435/:2:2","tags":null,"title":"0435：无重叠区间（★★）","uri":"/leetcode/0435/"},{"categories":null,"content":"解答 def eraseOverlapIntervals(self, intervals: List[List[int]]) -\u003e int: intervals.sort(key=lambda x: x[1]) cnt, end = 0, float('-inf') for s, e in intervals: if s\u003e=end: end = e cnt += 1 return len(intervals)-cnt 188 ms ","date":"2016-10-12","objectID":"/leetcode/0435/:3:0","tags":null,"title":"0435：无重叠区间（★★）","uri":"/leetcode/0435/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-10-09","objectID":"/leetcode/0432/:0:0","tags":null,"title":"0432：全 O(1) 的数据结构（★★★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"题目 请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。 实现 AllOne 类： AllOne() 初始化数据结构的对象。 inc(String key) 字符串 key 的计数增加 1 。如果数据结构中尚不存在 key ，那么插入计数为 1 的 key 。 dec(String key) 字符串 key 的计数减少 1 。如果 key 的计数在减少后为 0 ，那么需要将这个 key 从数据结构中删除。 测试用例保证：在减少计数前，key 存在于数据结构中。 getMaxKey() 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 \"\" 。 getM","date":"2016-10-09","objectID":"/leetcode/0432/:1:0","tags":null,"title":"0432：全 O(1) 的数据结构（★★★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"分析 ","date":"2016-10-09","objectID":"/leetcode/0432/:2:0","tags":null,"title":"0432：全 O(1) 的数据结构（★★★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"#1 容易想到用一个计数器维护每个 key 的计数，然后维护一个 \u003c计数，key\u003e 的有序集合，首尾即为计数最小/大的 key。 class AllOne: def __init__(self): from sortedcontainers import SortedList self.ct = Counter() self.sl = SortedList() def inc(self, key: str) -\u003e None: freq = self.ct[key] if freq: self.sl.remove((freq, key)) self.ct[key] = freq + 1 self","date":"2016-10-09","objectID":"/leetcode/0432/:2:1","tags":null,"title":"0432：全 O(1) 的数据结构（★★★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"#2 要求全部单次操作 O(1)，考虑用 双向链表+哈希表 来维护 \u003c计数，key\u003e 的有序集合 。 具体来说： 操作过程中要维护： 双向链表的每个节点对应一个计数值 x，并且按值的升序相连 节点 x 保存所有计数为 x 的 key 集合 哈希表保存 key 对应的节点 Inc/Dec 时，将 key 从对应的节点 x 弹出，加入到节点 x+1/x-1 中。若 没有对应的节点，就新建一个。若节点 x 的 key 集合为空了，就去掉该节点。 GetMaxKey 和 GetMinKey 时，取首/尾节点（排除哑结点）的任意一个 key 返回即可 ","date":"2016-10-09","objectID":"/leetcode/0432/:2:2","tags":null,"title":"0432：全 O(1) 的数据结构（★★★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"解答 class Node: def __init__(self, val, keys=[]): self.val = val self.keys = set(keys) self.next = None self.prev = None def insert(self, node): node.next = self.next node.prev = self self.next = node node.next.prev = node def pop(self, key): self.keys.discard(key) if not self.keys: self.prev.next = ","date":"2016-10-09","objectID":"/leetcode/0432/:3:0","tags":null,"title":"0432：全 O(1) 的数据结构（★★★★）","uri":"/leetcode/0432/"},{"categories":null,"content":"幽灵？那种东西不可能存在吧！\n我闻悠太是高中2年生。\n他运营着以一夜致富为目标的超自然汇总系营销博客“轻轻松松破假象”，为了将世上存在的多数超常现象以科学的解释来“干净利落地砍掉！”，而日夜挑战着超自然现象。\n然而，以他的博客为契机，彻底、狂热、古怪的同志们全都集结到一起了。\n自我矛盾型自称救世主、神愈灵能媒介者、全否定型超理论派大学生、萌系占卜大老师、死后世界引导人、未来预知型同人漫画家大姐姐、黑魔术代行屋、现充系杂志记者、残念系Cosplay阿宅刑警，本来不应相遇的他们的命运不可思议地交错起来。\n之后，他们的周围开始产生一些小小的“违和感”。\n它们逐渐化作巨大的波澜，并发展成为超乎想象的大事件——","date":"2016-10-08","objectID":"/anime/occultic_nine/","tags":null,"title":"超自然9人组","uri":"/anime/occultic_nine/"},{"categories":null,"content":"简介 幽灵？那种东西不可能存在吧！ 我闻悠太是高中2年生。 他运营着以一夜致富为目标的超自然汇总系营销博客“轻轻松松破假象”，为了将世上存在的多数超常现象以科学的解释来“干净利落地砍掉！”，而日夜挑战着超自然现象。 然而，以他的博客为契机，彻底、狂热、古怪的同志们全都集结到一起了。 自我矛盾型自称救世主、神愈灵能媒介者、全否定型超理论派大学生、萌系占卜大老师、死后世界引导人、未来预知型同人漫画家大姐姐、黑魔术代行屋、现充系杂志记者、残念系Cosplay阿宅刑警，本来不应相遇的他们的命运不可思议地交错起来。 之后，他们的周围开始产生一些小小的“违和感”。 它们逐渐化作巨大的波澜，并发展成为超乎想","date":"2016-10-08","objectID":"/anime/occultic_nine/:1:0","tags":null,"title":"超自然9人组","uri":"/anime/occultic_nine/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 我闻悠太 我聞 悠太、がもん ゆうた、Gamon Yuuta、ガモタン 男 梶裕貴 2 成泽稜歌 成沢 稜歌、なるさわ りょうか、Narusawa Ryouka、りょーたす 女 佐倉綾音 3 桥上萨来伊 桥上浚、橋上 サライ、はしがみ さらい、Hashigami Sarai 男 石川界人 4 相川实优羽 みゅう、幽语、相川 実優羽、あいかわ みゆう、Aikawa Miyuu、幽语妹 女 吉田仁美 5 澄风桐子 澄風 桐子、すみかぜ とうこ、Sumikaze Touko 女 伊藤静 6 红之亚里亚 みなせ りあ、Minase Ria、水无濑莉爱、水無瀬莉愛、く","date":"2016-10-08","objectID":"/anime/occultic_nine/:2:0","tags":null,"title":"超自然9人组","uri":"/anime/occultic_nine/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 超自然9人组 2016-10-08 12 bilibili ","date":"2016-10-08","objectID":"/anime/occultic_nine/:3:0","tags":null,"title":"超自然9人组","uri":"/anime/occultic_nine/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-10-07","objectID":"/leetcode/0430/:0:0","tags":null,"title":"0430：扁平化多级双向链表（★★）","uri":"/leetcode/0430/"},{"categories":null,"content":"题目 多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。 这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。 给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。 示例 1： 输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\r输出：[1,2,3,7,8,11,12,9,10,4,5,6]\r解释：\r输入的多级列表如下图所示：\r扁平化后的链表如下图：\r示例 2： 输入：head = [1,2,null,3]\r输","date":"2016-10-07","objectID":"/leetcode/0430/:1:0","tags":null,"title":"0430：扁平化多级双向链表（★★）","uri":"/leetcode/0430/"},{"categories":null,"content":"分析 ","date":"2016-10-07","objectID":"/leetcode/0430/:2:0","tags":null,"title":"0430：扁平化多级双向链表（★★）","uri":"/leetcode/0430/"},{"categories":null,"content":"#1 先考虑递归。有子链表时，调用递归程序将子链表扁平化，然后改变当前节点、子链表头尾节点、下一个节点的指针即可。 递归程序应该返回扁平化后的尾节点。 def flatten(self, head: 'Node') -\u003e 'Node': def help(p): while p and (p.next or p.child): if p.child: t = help(p.child) t.next = p.next if t.next: t.next.prev = t p.next = p.child p.next.prev = p p.child = None p = t else: p ","date":"2016-10-07","objectID":"/leetcode/0430/:2:1","tags":null,"title":"0430：扁平化多级双向链表（★★）","uri":"/leetcode/0430/"},{"categories":null,"content":"#2 也可以用迭代的方法。按 [p.next, p.child] 的顺序将节点入栈，每次出栈时改变当前节点和上一个节点的指针即可。 ","date":"2016-10-07","objectID":"/leetcode/0430/:2:2","tags":null,"title":"0430：扁平化多级双向链表（★★）","uri":"/leetcode/0430/"},{"categories":null,"content":"解答 def flatten(self, head: 'Node') -\u003e 'Node': stack, prev = [head], None while stack: node = stack.pop() if node: if prev: prev.next = node node.prev = prev stack.extend([node.next,node.child]) node.child = None prev = node return head 48 ms ","date":"2016-10-07","objectID":"/leetcode/0430/:3:0","tags":null,"title":"0430：扁平化多级双向链表（★★）","uri":"/leetcode/0430/"},{"categories":null,"content":"对你而言，世界是怎样的呢——。\n获得了打开大门的钥匙的两位女主人公，帕皮卡和可可娜。\n少女与少女相遇，开始了在不同的时间、相异的空间“Pure Illusion”的冒险。\n在寻找着据说能实现愿望的神秘结晶体“耳之碎片”而游历Pure Illusion的两人面前，\n出现了各种各样的困难。\n当两人陷入危机之时，“耳之碎片”发出光芒，而她们也因此变身了。","date":"2016-10-06","objectID":"/anime/flip_flappers/","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"简介 对你而言，世界是怎样的呢——。 获得了打开大门的钥匙的两位女主人公，帕皮卡和可可娜。 少女与少女相遇，开始了在不同的时间、相异的空间“Pure Illusion”的冒险。 在寻找着据说能实现愿望的神秘结晶体“耳之碎片”而游历Pure Illusion的两人面前， 出现了各种各样的困难。 当两人陷入危机之时，“耳之碎片”发出光芒，而她们也因此变身了。 制作人员： 导演：押山清高 脚本：绫奈由仁子、久弥直树、关根步美 分镜：榎户骏、出合小都美、新留俊哉 ","date":"2016-10-06","objectID":"/anime/flip_flappers/:1:0","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 帕皮卡 Papika 女 M・A・O 2 可可娜 Kokona 女 髙橋ミナミ 3 雅雅卡 Yayaka 女 大橋彩香 4 索尔特 Soruto 男 津田健次郎 5 托托 Toto 男 井上沙香 6 优优 Yuyu 女 歳納愛梨 7 希达卡 日高、Shidaka 男 福島潤 8 小百合 Sayuri 女 日笠陽子 ","date":"2016-10-06","objectID":"/anime/flip_flappers/:2:0","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Flip Flappers 2016-10-06 13 樱花 ","date":"2016-10-06","objectID":"/anime/flip_flappers/:3:0","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"MAD ","date":"2016-10-06","objectID":"/anime/flip_flappers/:4:0","tags":null,"title":"Flip Flappers","uri":"/anime/flip_flappers/"},{"categories":null,"content":"“伯纳德小姐”町田佐和子与爱读书的朋友们在图书馆展开的文学日常。\n对古今东西各种书籍的爱，以及充满“确实是读书家呢”这类细节的“名著礼赞”搞笑剧！","date":"2016-10-06","objectID":"/anime/miss_bernard_said/","tags":null,"title":"伯纳德小姐说。","uri":"/anime/miss_bernard_said/"},{"categories":null,"content":"简介 “伯纳德小姐”町田佐和子与爱读书的朋友们在图书馆展开的文学日常。 对古今东西各种书籍的爱，以及充满“确实是读书家呢”这类细节的“名著礼赞”搞笑剧！ 制作人员： 原作：施川汤雨期 导演：平泽久义 脚本：内堀优一 分镜：橘纱央莉、空久保美贵 人物原案：なつのはむと 人物设定：ゴンタ ","date":"2016-10-06","objectID":"/anime/miss_bernard_said/:1:0","tags":null,"title":"伯纳德小姐说。","uri":"/anime/miss_bernard_said/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 町田佐和子 女 喜多村英梨 2 神林诗织 女 小松未可子 3 远藤 男 市来光弘 4 长谷川澄香 女 洲崎綾 ","date":"2016-10-06","objectID":"/anime/miss_bernard_said/:2:0","tags":null,"title":"伯纳德小姐说。","uri":"/anime/miss_bernard_said/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 伯纳德小姐说。 2016-10-06 13 bilibili ","date":"2016-10-06","objectID":"/anime/miss_bernard_said/:3:0","tags":null,"title":"伯纳德小姐说。","uri":"/anime/miss_bernard_said/"},{"categories":null,"content":"主人公·大叔是一位外表帅气却过着放荡生活的父亲，工作是马桶盖设计师。和妻子离婚后与学习运动万能的女儿小敏一起生活。某天在一次平常的厕所蹲坑中大叔竟然让马桶吸了进去！ 穿越到未知世界的大叔被赋予拯救地球的重任，稀里糊涂的成为了超级英雄！而成为英雄的代价却是将原本英俊帅气的大叔变成了臃肿丑陋的大胖子！！守护地球和小敏的战斗，就此开始…","date":"2016-10-04","objectID":"/anime/to_be_hero/","tags":null,"title":"凸变英雄","uri":"/anime/to_be_hero/"},{"categories":null,"content":"简介 主人公·大叔是一位外表帅气却过着放荡生活的父亲，工作是马桶盖设计师。和妻子离婚后与学习运动万能的女儿小敏一起生活。某天在一次平常的厕所蹲坑中大叔竟然让马桶吸了进去！ 穿越到未知世界的大叔被赋予拯救地球的重任，稀里糊涂的成为了超级英雄！而成为英雄的代价却是将原本英俊帅气的大叔变成了臃肿丑陋的大胖子！！守护地球和小敏的战斗，就此开始… 制作人员： 原作：李豪凌 导演：渡边慎一 演出：LAN 音乐：東タカゴー、宫崎京一 ","date":"2016-10-04","objectID":"/anime/to_be_hero/:1:0","tags":null,"title":"凸变英雄","uri":"/anime/to_be_hero/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伢叔 大叔、姜子伢 男 津田健次郎 2 姜辰敏 ミソ、ミンちゃん、小敏 女 山新 3 美少女 女 西田望見 4 王子 猛猛哒 男 杉田智和 5 老王 山田さん 青山穣 ","date":"2016-10-04","objectID":"/anime/to_be_hero/:2:0","tags":null,"title":"凸变英雄","uri":"/anime/to_be_hero/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 凸变英雄 2016-10-04 12 bilibili 2 凸变英雄 LEAF 2018-04-14 12 bilibili ","date":"2016-10-04","objectID":"/anime/to_be_hero/:3:0","tags":null,"title":"凸变英雄","uri":"/anime/to_be_hero/"},{"categories":null,"content":"1555年，时为战国时代。\n有位青年怀抱着远大的梦想，被人称作大傻瓜的他正是后来的织田信长。\n有一位仰慕着青年的少女，被信长的梦想所吸引的她笑着说道“我要成为信长大人的忍者！”\n目标只有一个，那就是天下布武！","date":"2016-10-04","objectID":"/anime/ninja_girl/","tags":null,"title":"信长的忍者","uri":"/anime/ninja_girl/"},{"categories":null,"content":"简介 1555年，时为战国时代。 有位青年怀抱着远大的梦想，被人称作大傻瓜的他正是后来的织田信长。 有一位仰慕着青年的少女，被信长的梦想所吸引的她笑着说道“我要成为信长大人的忍者！” 目标只有一个，那就是天下布武！ 制作人员： 原作：重野なおき 导演：大地丙太郎 演出：山口光、神原敏昭、备前克彦、赤城博昭、菅井嘉浩 ","date":"2016-10-04","objectID":"/anime/ninja_girl/:1:0","tags":null,"title":"信长的忍者","uri":"/anime/ninja_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 千鸟 ちどり、Chidori 女 水瀬いのり 2 织田信长 おだ のぶなが、Oda Nobunaga 男 羽多野渉 3 助藏 すけぞう、Sukezō 男 村瀬歩 4 归蝶 きちょう、Kichō 女 たかはし智秋 5 木下秀吉 きのした ひでよし、Kinoshita Hideyoshi 男 山口勝平 6 宁宁 ねね、Nene 女 釘宮理恵 7 阿市 おいち、Oichi 女 三森すずこ 8 柴田胜家 しばた かついえ、Shibata Katsuie 男 大川透 ","date":"2016-10-04","objectID":"/anime/ninja_girl/:2:0","tags":null,"title":"信长的忍者","uri":"/anime/ninja_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 信长的忍者 2016-10-04 26 bilibili 2 信长的忍者 伊势·金崎篇 2017-04-07 26 bilibili 3 信长的忍者 姊川·石山篇 2018-04-06 26 bilibili ","date":"2016-10-04","objectID":"/anime/ninja_girl/:3:0","tags":null,"title":"信长的忍者","uri":"/anime/ninja_girl/"},{"categories":null,"content":" 第 场周赛第 题 ","date":"2016-09-30","objectID":"/leetcode/0409/:0:0","tags":null,"title":"0409：最长回文串（★）","uri":"/leetcode/0409/"},{"categories":null,"content":"题目 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。 注意: 假设字符串的长度不会超过 1010。 示例 1: 输入:\r\"abccccdd\"\r输出:\r7\r解释:\r我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。\r","date":"2016-09-30","objectID":"/leetcode/0409/:1:0","tags":null,"title":"0409：最长回文串（★）","uri":"/leetcode/0409/"},{"categories":null,"content":"分析 显然如果字符的出现次数是偶数，都能用上。如果次数是奇数，多余的那个只能作为回文串中心。 如果多个字符的出现次数都是奇数，只能选一个多余的作为回文串中心，剩下的都是真正多余的。 因此统计出现次数为奇数的字符个数 n，多余的个数即为 max(0, n-1)。 ","date":"2016-09-30","objectID":"/leetcode/0409/:2:0","tags":null,"title":"0409：最长回文串（★）","uri":"/leetcode/0409/"},{"categories":null,"content":"解答 def longestPalindrome(self, s: str) -\u003e int: return len(s) - max(0, sum(v % 2 for v in Counter(s).values())-1) 36 ms ","date":"2016-09-30","objectID":"/leetcode/0409/:3:0","tags":null,"title":"0409：最长回文串（★）","uri":"/leetcode/0409/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果， 其中 0 ≤ i ≤ j \u003c n 。 你能在O(n)的时间解决这个问题吗？ 提示： 1 \u003c= nums.length \u003c= 2 * 10^4 0 \u003c= nums[i] \u003c= 2^31 - 1 示例 1： 输入：nums = [3,10,5,25,2,8]\r输出：28\r解释：最大运算结果是 5 XOR 25 = 28.\r示例 2： 输入：nums = [0]\r输出：0\r示例 3： 输入：nums = [2,4]\r输出：6\r示例 4： 输入：nums = [8,10,2]\r输出：10\r示例 5： 输","date":"2016-09-28","objectID":"/leetcode/0421/:1:0","tags":null,"title":"0421：数组中两个数的最大异或值（★★★）","uri":"/leetcode/0421/"},{"categories":null,"content":"分析 结果的二进制表示最多 31 位。为了使结果最大，应该尽可能让二进制的高位取 1。 假如结果的最大 k 位前缀为 x，那么最大的 k+1 位前缀应该尽量取 (x«1)+1，如果取不到，那么就是 x«1。 如果存在两个数的 k 位前缀 y、z，使得 y^z=x，那么 k 位前缀 x 就能取到。 但这样太耗时，有个巧妙的方法是利用异或的重要性质：如果 y^z=x，那么 y^x=z。 将每个数的 k 位前缀保存在哈希表 vis 中。遍历 vis 中的 y，如果 y^x 也在 vis 中， 即代表 k 位前缀 x 能取到。 于是从 k=0 递推到 k=31 的最大 k 位前缀，每轮 O(N) 时间","date":"2016-09-28","objectID":"/leetcode/0421/:2:0","tags":null,"title":"0421：数组中两个数的最大异或值（★★★）","uri":"/leetcode/0421/"},{"categories":null,"content":"解答 def findMaximumXOR(self, nums: List[int]) -\u003e int: res = 0 for i in range(30, -1, -1): res, vis = res \u003c\u003c 1, {num \u003e\u003e i for num in nums} res += int(any((res+1) ^ val in vis for val in vis)) return res 480 ms ","date":"2016-09-28","objectID":"/leetcode/0421/:3:0","tags":null,"title":"0421：数组中两个数的最大异或值（★★★）","uri":"/leetcode/0421/"},{"categories":null,"content":"*附加 有个更通用的字典树解法。 遍历每个数 nums[j], 将 31 位二进制表示当作字符串，添加到字典树中。 然后可以根据当前的字典树在 31 步内找到 max(nums[j]^nums[i] for i in range(j+1))。 def findMaximumXOR(self, nums: List[int]) -\u003e int: T = lambda: defaultdict(T) res, trie = 0, T() for num in nums: val = bin(num)[2:].zfill(31) reduce(dict.__getitem__, val, trie) ","date":"2016-09-28","objectID":"/leetcode/0421/:4:0","tags":null,"title":"0421：数组中两个数的最大异或值（★★★）","uri":"/leetcode/0421/"},{"categories":null,"content":" 第 6 场周赛第 4 题 ","date":"2016-09-25","objectID":"/leetcode/0407/:0:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":"题目 给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。 示例 1: 输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\r输出: 4\r解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。\r示例 2: 输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\r输出: 10\r提示: m == heightMap.length n == heig","date":"2016-09-25","objectID":"/leetcode/0407/:1:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":"分析 对于每个位置，如果有一外圈的柱子都更高，那么该位置就能接到雨水，并且至少接到 （该外圈的最矮柱子高度 H - 当前高度 h）的雨水。 找到使 H 最大的外圈，就得到该位置总共能接到的雨水 maxH - h。 显然遍历所有外圈太耗时了，有个巧妙的想法是从最外圈开始，假设最矮柱子 A 高度 H， 那么相邻内侧位置 B 能接到的雨水就是 max(0, H - B的高度)。 然后可以将位置 A 替换成位置 B，并更新 B 的高度为 max(H, h)，得到一个缩小一格的新外圈， 显然不影响里面位置的结果。 这样遍历逐步缩小的外圈即可得到所有位置能接到的雨水。 具体实现可以用小顶堆维护外圈的高度集","date":"2016-09-25","objectID":"/leetcode/0407/:2:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":"解答 def trapRainWater(self, heightMap: List[List[int]]) -\u003e int: pq, H = [], heightMap m, n = len(H), len(H[0]) for i, j in product(range(m), range(n)): if i in [0, m-1] or j in [0, n-1]: heappush(pq, [H[i][j], i, j]) H[i][j] = -1 res = 0 while pq: h, i, j = heappop(pq) for x, y in [(i+1, j), (i-1, j)","date":"2016-09-25","objectID":"/leetcode/0407/:3:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":"*附加 还有个巧妙的并查集做法。 先考虑简化问题：有哪些格子能接到高度为 1 的雨水？ 将高度小于 1 的格子标记为 ‘O’，其它格子都看作 ‘X’，显然只有被 ‘X’ 围绕的 ‘O’ 才能接到高度 1 的雨水。 这类似于问题 0130，可以用并查集解决。将边界上的 ‘O’ 都与一个哑节点 dummy 连通， 再将所有相邻的 ‘O’ 连通。最终所有与 dummy 连通的即是不被围绕的 ‘O’。 同理，对于高度 2，将高度小于 2 的格子标记为 ‘O’，即可求出哪些格子能接到高度为 2 的雨水。 注意到前一步被标记为 ‘O’ 的格子无需改变，只需要将高度为 1 的格子标记为 ‘O’ 即可。 因此","date":"2016-09-25","objectID":"/leetcode/0407/:4:0","tags":null,"title":"0407：接雨水 II（★★★）","uri":"/leetcode/0407/"},{"categories":null,"content":" 第 6 场周赛第 3 题 ","date":"2016-09-25","objectID":"/leetcode/0406/:0:0","tags":null,"title":"0406：根据身高重建队列（★★）","uri":"/leetcode/0406/"},{"categories":null,"content":"题目 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。 每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ， 其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],","date":"2016-09-25","objectID":"/leetcode/0406/:1:0","tags":null,"title":"0406：根据身高重建队列（★★）","uri":"/leetcode/0406/"},{"categories":null,"content":"分析 构造类题目先考虑极端情况： 假设最高 h0 且唯一，显然他的属性必然为 [h0, 0]，且可以随意安排 假设 h0 不唯一，那么这些人的属性必然为 [h0, 0], [h0, 1], [h0, 2], …, 并依此顺序 然后假设次高 h1 且唯一，他的属性为 [h1,k]，显然他应该插入到第 k 个 h0 之后 依此类推，即可构造出结果 实现时，将数组按 \u003c-hi,ki\u003e 排序，遍历并插入即可。 ","date":"2016-09-25","objectID":"/leetcode/0406/:2:0","tags":null,"title":"0406：根据身高重建队列（★★）","uri":"/leetcode/0406/"},{"categories":null,"content":"解答 def reconstructQueue(self, people: List[List[int]]) -\u003e List[List[int]]: res = [] for p in sorted(people, key=lambda x: (-x[0], x[1])): res.insert(p[1], p) return res 48 ms ","date":"2016-09-25","objectID":"/leetcode/0406/:3:0","tags":null,"title":"0406：根据身高重建队列（★★）","uri":"/leetcode/0406/"},{"categories":null,"content":" 第 6 场周赛第 2 题 ","date":"2016-09-25","objectID":"/leetcode/0405/:0:0","tags":null,"title":"0405：数字转换为十六进制数（★）","uri":"/leetcode/0405/"},{"categories":null,"content":"题目 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0’来表示； 对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 示例 1： 输入:\r26\r输出:\r\"1a\"\r示例 2： 输入:\r-1\r输出:\r\"ffffffff\"\r","date":"2016-09-25","objectID":"/leetcode/0405/:1:0","tags":null,"title":"0405：数字转换为十六进制数（★）","uri":"/leetcode/0405/"},{"categories":null,"content":"分析 ","date":"2016-09-25","objectID":"/leetcode/0405/:2:0","tags":null,"title":"0405：数字转换为十六进制数（★）","uri":"/leetcode/0405/"},{"categories":null,"content":"#1 最简单的就是调库 def toHex(self, num: int) -\u003e str: return hex(num%(1\u003c\u003c32))[2:] 44 ms ","date":"2016-09-25","objectID":"/leetcode/0405/:2:1","tags":null,"title":"0405：数字转换为十六进制数（★）","uri":"/leetcode/0405/"},{"categories":null,"content":"#2 也可以模拟进制转换的方法。 注意 num 为 0 时的特殊情况 ","date":"2016-09-25","objectID":"/leetcode/0405/:2:2","tags":null,"title":"0405：数字转换为十六进制数（★）","uri":"/leetcode/0405/"},{"categories":null,"content":"解答 def toHex(self, num: int) -\u003e str: num %= 1\u003c\u003c32 res, s = '', '0123456789abcdef' while num: res = s[num%16]+res num //= 16 return res if res else '0' 44 ms ","date":"2016-09-25","objectID":"/leetcode/0405/:3:0","tags":null,"title":"0405：数字转换为十六进制数（★）","uri":"/leetcode/0405/"},{"categories":null,"content":" 第 6 场周赛第 1 题 ","date":"2016-09-25","objectID":"/leetcode/0404/:0:0","tags":null,"title":"0404：左叶子之和（★）","uri":"/leetcode/0404/"},{"categories":null,"content":"题目 给定二叉树的根节点 root ，返回所有左叶子之和。 示例 1： 输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 输入: root = [1] 输出: 0 提示: 节点数在 [1, 1000] 范围内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2016-09-25","objectID":"/leetcode/0404/:1:0","tags":null,"title":"0404：左叶子之和（★）","uri":"/leetcode/0404/"},{"categories":null,"content":"分析 遍历时标记节点是左孩子还是右孩子即可。也可以用递归。 ","date":"2016-09-25","objectID":"/leetcode/0404/:2:0","tags":null,"title":"0404：左叶子之和（★）","uri":"/leetcode/0404/"},{"categories":null,"content":"解答 def sumOfLeftLeaves(self, root: Optional[TreeNode]) -\u003e int: res, stack = 0, [(root, 1)] while stack: node, flag = stack.pop() if node: if not node.left and not node.right and flag == 0: res += node.val stack.extend([(node.left, 0), (node.right, 1)]) return res 36 ms ","date":"2016-09-25","objectID":"/leetcode/0404/:3:0","tags":null,"title":"0404：左叶子之和（★）","uri":"/leetcode/0404/"},{"categories":null,"content":"题目 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集， 使得两个子集的元素和相等。 示例 1： 输入：nums = [1,5,11,5]\r输出：true\r解释：数组可以分割成 [1, 5, 5] 和 [11] 。\r示例 2： 输入：nums = [1,2,3,5]\r输出：false\r解释：数组不能分割成两个元素和相等的子集。\r提示： 1 \u003c= nums.length \u003c= 200 1 \u003c= nums[i] \u003c= 100 ","date":"2016-09-23","objectID":"/leetcode/0416/:1:0","tags":null,"title":"0416：分割等和子集（★★）","uri":"/leetcode/0416/"},{"categories":null,"content":"分析 ","date":"2016-09-23","objectID":"/leetcode/0416/:2:0","tags":null,"title":"0416：分割等和子集（★★）","uri":"/leetcode/0416/"},{"categories":null,"content":"#1 令 s=sum(nums)，s 为奇数时显然无解。s 为偶数时，问题等价于找子集使得和为 s//2。 注意到 s//2 最大为 10^4，于是考虑递推 nums[:i] 能得到的所有子集和。 令 dp[i] 代表nums[:i] 能得到的所有小于等于 s//2 的子集和，那么 dp[i] = dp[i-1] | {x+nums[i-1] for x in dp[i-1] if x+nums[i-1]\u003c=s//2}\r只要递推过程中找到 s//2 即为真。 def canPartition(self, nums: List[int]) -\u003e bool: s = sum(nums) if s%","date":"2016-09-23","objectID":"/leetcode/0416/:2:1","tags":null,"title":"0416：分割等和子集（★★）","uri":"/leetcode/0416/"},{"categories":null,"content":"#2 还有个巧妙的想法，可以将集合状态压缩为一个数 state，然后集合内所有数加上 num 得到的集合即是 state«num。 这样显著优化了递推的时间。 ","date":"2016-09-23","objectID":"/leetcode/0416/:2:2","tags":null,"title":"0416：分割等和子集（★★）","uri":"/leetcode/0416/"},{"categories":null,"content":"解答 def canPartition(self, nums: List[int]) -\u003e bool: s = sum(nums) if s % 2: return False state = 1 for num in nums: state |= state \u003c\u003c num if state \u0026 (1 \u003c\u003c (s//2)): return True return False 32 ms ","date":"2016-09-23","objectID":"/leetcode/0416/:3:0","tags":null,"title":"0416：分割等和子集（★★）","uri":"/leetcode/0416/"},{"categories":null,"content":"题目 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。 给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。 子数组 是数组中的一个连续序列。 示例 1： 输入：nums = [1,2,3,4]\r输出：3\r解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。\r示例 2： 输入：nums = [1]\r输出：0\r提示： 1 \u003c= nums.length \u003c= 5000 -1000 \u003c","date":"2016-09-20","objectID":"/leetcode/0413/:1:0","tags":null,"title":"0413：等差数列划分（★★）","uri":"/leetcode/0413/"},{"categories":null,"content":"分析 令 dp[i] 代表以 i 结尾的子数组个数，那么： 假如 nums[i]-nums[i-1]==nums[i-1]-nums[i-2]，dp[i]=dp[i-1]+1 否则，dp[i]=0 最后 sum(dp) 即为所求。 ","date":"2016-09-20","objectID":"/leetcode/0413/:2:0","tags":null,"title":"0413：等差数列划分（★★）","uri":"/leetcode/0413/"},{"categories":null,"content":"解答 def numberOfArithmeticSlices(self, nums: List[int]) -\u003e int: n = len(nums) dp = [0]*n for i in range(2, n): dp[i] = dp[i-1]+1 if 2*nums[i-1]==nums[i]+nums[i-2] else 0 return sum(dp) 40 ms ","date":"2016-09-20","objectID":"/leetcode/0413/:3:0","tags":null,"title":"0413：等差数列划分（★★）","uri":"/leetcode/0413/"},{"categories":null,"content":" 第 5 场周赛第 4 题 ","date":"2016-09-18","objectID":"/leetcode/0403/:0:0","tags":null,"title":"0403：青蛙过河（★★）","uri":"/leetcode/0403/"},{"categories":null,"content":"题目 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。 给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。 开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。 示例 1： 输入：stones = [0,1","date":"2016-09-18","objectID":"/leetcode/0403/:1:0","tags":null,"title":"0403：青蛙过河（★★）","uri":"/leetcode/0403/"},{"categories":null,"content":"分析 典型的递归问题。令 dfs(i, k) 代表上一步跳跃 k 位到达位置 i 的情况下能否过河，即可递归。 注意有重复子问题，所以用记忆化递归。 ","date":"2016-09-18","objectID":"/leetcode/0403/:2:0","tags":null,"title":"0403：青蛙过河（★★）","uri":"/leetcode/0403/"},{"categories":null,"content":"解答 def canCross(self, stones: List[int]) -\u003e bool: @lru_cache(None) def dfs(i, k): if i == last: return True return any(dfs(i+j, j) for j in [k-1, k, k+1] if i\u003ci+j\u003c=last and i+j in vis) vis, last = set(stones), stones[-1] return dfs(0, 0) 36 ms ","date":"2016-09-18","objectID":"/leetcode/0403/:3:0","tags":null,"title":"0403：青蛙过河（★★）","uri":"/leetcode/0403/"},{"categories":null,"content":" 第 5 场周赛第 3 题 ","date":"2016-09-18","objectID":"/leetcode/0402/:0:0","tags":null,"title":"0402：移掉K位数字（★★）","uri":"/leetcode/0402/"},{"categories":null,"content":"题目 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。 请你以字符串形式返回这个最小的数字。 示例 1 ： 输入：num = \"1432219\", k = 3 输出：\"1219\" 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。 示例 2 ： 输入：num = \"10200\", k = 1 输出：\"200\" 解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 ： 输入：num = \"10\", k = 2 输出：\"0\" 解释：从原数字移除所有的数字，剩余为空就是 0 。 提示：","date":"2016-09-18","objectID":"/leetcode/0402/:1:0","tags":null,"title":"0402：移掉K位数字（★★）","uri":"/leetcode/0402/"},{"categories":null,"content":"分析 经典的贪心问题： 遍历 num，如果当前数字比上一个数字小，可以移除上一个数字 移除后若还是比上一个数字小，可以继续移除 循环操作，直到当前数字大于等于上一个数字，或者 k 用完了 如果最终 k 还有剩余，说明剩下的数字是升序的，去掉最后几位即可 在遍历过程中，每一步能减小的最高位就是上一位，因此这样得到的数就是最小的。 ","date":"2016-09-18","objectID":"/leetcode/0402/:2:0","tags":null,"title":"0402：移掉K位数字（★★）","uri":"/leetcode/0402/"},{"categories":null,"content":"解答 def removeKdigits(self, num: str, k: int) -\u003e str: stack, n = [], len(num)-k for char in num: while k and stack and stack[-1] \u003e char: stack.pop() k -= 1 stack.append(char) return ''.join(stack[:n]).lstrip('0') or '0' 36 ms ","date":"2016-09-18","objectID":"/leetcode/0402/:3:0","tags":null,"title":"0402：移掉K位数字（★★）","uri":"/leetcode/0402/"},{"categories":null,"content":" 第 5 场周赛第 2 题 ","date":"2016-09-18","objectID":"/leetcode/0401/:0:0","tags":null,"title":"0401：二进制手表（★★）","uri":"/leetcode/0401/"},{"categories":null,"content":"题目 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。 每个 LED 代表一个 0 或 1，最低位在右侧。 例如，下面的二进制手表读取 “3:25” 。 给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。 小时不会以零开头： 例如，“01:00” 是无效的时间，正确的写法应该是 “1:00” 。 分钟必须由两位数组成，可能会以零开头： 例如，“10:2” 是无效的时间，正确的写法应该是 “10:02” 。 示例 1： 输入：turnedOn = 1\r输出","date":"2016-09-18","objectID":"/leetcode/0401/:1:0","tags":null,"title":"0401：二进制手表（★★）","uri":"/leetcode/0401/"},{"categories":null,"content":"分析 数据量较小，因此可以直接遍历所有有效时间，判断对应的 1 的数量是否为 turnedOn 即可 。 ","date":"2016-09-18","objectID":"/leetcode/0401/:2:0","tags":null,"title":"0401：二进制手表（★★）","uri":"/leetcode/0401/"},{"categories":null,"content":"解答 def readBinaryWatch(self, turnedOn: int) -\u003e List[str]: return ['%d:%02d' % (h, m) for h in range(12) for m in range(60) if (bin(h)+bin(m)).count('1')==turnedOn] 32 ms ","date":"2016-09-18","objectID":"/leetcode/0401/:3:0","tags":null,"title":"0401：二进制手表（★★）","uri":"/leetcode/0401/"},{"categories":null,"content":" 第 5 场周赛第 1 题 ","date":"2016-09-18","objectID":"/leetcode/0400/:0:0","tags":null,"title":"0400：第 N 位数字（★★）","uri":"/leetcode/0400/"},{"categories":null,"content":"题目 给你一个整数 n ，请你在无限的整数序列 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …] 中找出并返回第 n 位上的数字。 示例 1： 输入：n = 3\r输出：3\r示例 2： 输入：n = 11\r输出：0\r解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。\r提示： 1 \u003c= n \u003c= 2^31 - 1 第 n 位上的数字是按计数单位（digit）从前往后数的第 n 个数，参见 示例 2 。 ","date":"2016-09-18","objectID":"/leetcode/0400/:1:0","tags":null,"title":"0400：第 N 位数字（★★）","uri":"/leetcode/0400/"},{"categories":null,"content":"分析 依次统计发现 [1, 9] 共 1*9 位\r[10, 99] 共 2*90 位\r[100, 999] 共 3*900 位\r。。。\r因此可以计算出第 n 位数字对应的是 几位数中的第几个。 ","date":"2016-09-18","objectID":"/leetcode/0400/:2:0","tags":null,"title":"0400：第 N 位数字（★★）","uri":"/leetcode/0400/"},{"categories":null,"content":"解答 def findNthDigit(self, n: int) -\u003e int: x, y = 1, 9 while n \u003e x*y: n -= x*y x+=1 y*=10 q, r = divmod(n-1, x) ans = 10**(x-1)+q return int(str(ans)[r]) 24 ms ","date":"2016-09-18","objectID":"/leetcode/0400/:3:0","tags":null,"title":"0400：第 N 位数字（★★）","uri":"/leetcode/0400/"},{"categories":null,"content":" 第 4 场周赛第 4 题 ","date":"2016-09-11","objectID":"/leetcode/0399/:0:0","tags":null,"title":"0399：除法求值（★★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"题目 给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。 每个 Ai 或 Bi 是一个表示单个变量的字符串。 另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题， 请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。 返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。 如果问题中出现了给定的已知条件中没有出现的字符串，也需要","date":"2016-09-11","objectID":"/leetcode/0399/:1:0","tags":null,"title":"0399：除法求值（★★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"分析 ","date":"2016-09-11","objectID":"/leetcode/0399/:2:0","tags":null,"title":"0399：除法求值（★★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"#1 将等式看作边 (a, b)，value 看作边的权重，同时反向边 (b, a) 的权重为 1/value。 那么问题就相当于找到从 c 到 d 在图中的路径，计算路径的权重乘积。 因为数据规模较小，所以可以对每个问题进行遍历查找，bfs 或 dfs 都可以。 def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -\u003e List[float]: def bfs(c, d): queue, vis = deque([(c, 1.0)]), set() ","date":"2016-09-11","objectID":"/leetcode/0399/:2:1","tags":null,"title":"0399：除法求值（★★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"#2 更节省时间的做法是并查集。每个节点维护到父节点的权重，注意路径压缩和合并时都要同步更新。 最终查询 c、d 的比值时，如果 c、d 都出现过且连通，那么 c、d 路径压缩后的权重比值即为所求。 ","date":"2016-09-11","objectID":"/leetcode/0399/:2:2","tags":null,"title":"0399：除法求值（★★★）","uri":"/leetcode/0399/"},{"categories":null,"content":"解答 def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -\u003e List[float]: def find(x): if f.setdefault(x, x) != x: root = find(f[x]) w[x] *= w[f[x]] f[x] = root return f[x] def union(x, y, val): root = find(x) f[root] = find(y) w[root] = w[y] * val / w[x] f","date":"2016-09-11","objectID":"/leetcode/0399/:3:0","tags":null,"title":"0399：除法求值（★★★）","uri":"/leetcode/0399/"},{"categories":null,"content":" 第 4 场周赛第 3 题 ","date":"2016-09-11","objectID":"/leetcode/0398/:0:0","tags":null,"title":"0398：随机数索引（★★）","uri":"/leetcode/0398/"},{"categories":null,"content":"题目 给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。 注意： 数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。 示例: int[] nums = new int[] {1,2,3,3,3};\rSolution solution = new Solution(nums);\r// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。\rsolution.pick(3);\r// pick(1) 应该返回 0。因为只有nums[0]等于1。\rsolution.pick(1);\r","date":"2016-09-11","objectID":"/leetcode/0398/:1:0","tags":null,"title":"0398：随机数索引（★★）","uri":"/leetcode/0398/"},{"categories":null,"content":"分析 ","date":"2016-09-11","objectID":"/leetcode/0398/:2:0","tags":null,"title":"0398：随机数索引（★★）","uri":"/leetcode/0398/"},{"categories":null,"content":"#1 最简单的就是用哈希表保存每个数对应的索引列表。 class Solution: def __init__(self, nums: List[int]): self.d = defaultdict(list) for i, num in enumerate(nums): self.d[num].append(i) def pick(self, target: int) -\u003e int: return random.choice(self.d[target]) 148 ms ","date":"2016-09-11","objectID":"/leetcode/0398/:2:1","tags":null,"title":"0398：随机数索引（★★）","uri":"/leetcode/0398/"},{"categories":null,"content":"#2 要求额外空间小，想到蓄水池抽样。遇到第 cnt 个等于 target 的数时，以 1/cnt 的概率将该数的索引赋值给 res。 ","date":"2016-09-11","objectID":"/leetcode/0398/:2:2","tags":null,"title":"0398：随机数索引（★★）","uri":"/leetcode/0398/"},{"categories":null,"content":"解答 class Solution: def __init__(self, nums: List[int]): self.nums = nums def pick(self, target: int) -\u003e int: res, cnt = 0, 0 for i, num in enumerate(self.nums): if num == target: cnt += 1 if random.randint(1, cnt) == cnt: res = i return res 112 ms ","date":"2016-09-11","objectID":"/leetcode/0398/:3:0","tags":null,"title":"0398：随机数索引（★★）","uri":"/leetcode/0398/"},{"categories":null,"content":" 第 4 场周赛第 2 题 ","date":"2016-09-11","objectID":"/leetcode/0397/:0:0","tags":null,"title":"0397：整数替换（★）","uri":"/leetcode/0397/"},{"categories":null,"content":"题目 给定一个正整数 n ，你可以做如下操作： 如果 n 是偶数，则用 n / 2替换 n 。 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。 返回 n 变为 1 所需的 最小替换次数 。 示例 1： 输入：n = 8\r输出：3\r解释：8 -\u003e 4 -\u003e 2 -\u003e 1\r示例 2： 输入：n = 7\r输出：4\r解释：7 -\u003e 8 -\u003e 4 -\u003e 2 -\u003e 1\r或 7 -\u003e 6 -\u003e 3 -\u003e 2 -\u003e 1\r示例 3： 输入：n = 4\r输出：2\r提示： 1 \u003c= n \u003c= 2^31 - 1 ","date":"2016-09-11","objectID":"/leetcode/0397/:1:0","tags":null,"title":"0397：整数替换（★）","uri":"/leetcode/0397/"},{"categories":null,"content":"分析 显然递归即可。 ","date":"2016-09-11","objectID":"/leetcode/0397/:2:0","tags":null,"title":"0397：整数替换（★）","uri":"/leetcode/0397/"},{"categories":null,"content":"解答 def integerReplacement(self, n: int) -\u003e int: @lru_cache(None) def dfs(n): if n == 1: return 0 if n % 2 == 0: return 1 + dfs(n//2) return 1+min(dfs(n+1), dfs(n-1)) return dfs(n) 24 ms ","date":"2016-09-11","objectID":"/leetcode/0397/:3:0","tags":null,"title":"0397：整数替换（★）","uri":"/leetcode/0397/"},{"categories":null,"content":" 第 4 场周赛第 1 题 ","date":"2016-09-11","objectID":"/leetcode/0396/:0:0","tags":null,"title":"0396：旋转函数（★）","uri":"/leetcode/0396/"},{"categories":null,"content":"题目 给定一个长度为 n 的整数数组 A 。 假设 Bk 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为： F(k) = 0 * Bk[0] + 1 * Bk[1] + … + (n-1) * Bk[n-1]。 计算F(0), F(1), …, F(n-1)中的最大值。 注意:可以认为 n 的值小于 10^5。 示例: A = [4, 3, 2, 6] F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (","date":"2016-09-11","objectID":"/leetcode/0396/:1:0","tags":null,"title":"0396：旋转函数（★）","uri":"/leetcode/0396/"},{"categories":null,"content":"分析 观察发现 F(k) 可以递推： F[k] = F[k-1]+sum(A)-len(A)*A[-k] ","date":"2016-09-11","objectID":"/leetcode/0396/:2:0","tags":null,"title":"0396：旋转函数（★）","uri":"/leetcode/0396/"},{"categories":null,"content":"解答 def maxRotateFunction(self, nums: List[int]) -\u003e int: n, s = len(nums), sum(nums) res = f = sum(i*x for i, x in enumerate(nums)) for k in range(1, n): f += s-n*nums[-k] res = max(res, f) return res 320 ms ","date":"2016-09-11","objectID":"/leetcode/0396/:3:0","tags":null,"title":"0396：旋转函数（★）","uri":"/leetcode/0396/"},{"categories":null,"content":" 第 3 场周赛第 4 题 ","date":"2016-09-04","objectID":"/leetcode/0395/:0:0","tags":null,"title":"0395：至少有K个重复字符的最长子串（★★）","uri":"/leetcode/0395/"},{"categories":null,"content":"题目 给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。 提示： 1 \u003c= s.length \u003c= 10^4 s 仅由小写英文字母组成 1 \u003c= k \u003c= 10^5 示例 1： 输入：s = \"aaabb\", k = 3 输出：3 解释：最长子串为 \"aaa\" ，其中 'a' 重复了 3 次。 示例 2： 输入：s = \"ababbc\", k = 2 输出：5 解释：最长子串为 \"ababb\" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。 ","date":"2016-09-04","objectID":"/leetcode/0395/:1:0","tags":null,"title":"0395：至少有K个重复字符的最长子串（★★）","uri":"/leetcode/0395/"},{"categories":null,"content":"分析 若某字符 char 在 s 中出现的次数小于 k，显然子串就不能含有 char。 所以可以将 s 按 char 分割，转为递归子问题。 ","date":"2016-09-04","objectID":"/leetcode/0395/:2:0","tags":null,"title":"0395：至少有K个重复字符的最长子串（★★）","uri":"/leetcode/0395/"},{"categories":null,"content":"解答 def longestSubstring(self, s: str, k: int) -\u003e int: def dfs(s): A = [c for c, freq in Counter(s).items() if freq \u003c k] return len(s) if not A else max(dfs(sub) for sub in re.split('|'.join(A), s)) return dfs(s) 56 ms ","date":"2016-09-04","objectID":"/leetcode/0395/:3:0","tags":null,"title":"0395：至少有K个重复字符的最长子串（★★）","uri":"/leetcode/0395/"},{"categories":null,"content":" 第 3 场周赛第 3 题 ","date":"2016-09-04","objectID":"/leetcode/0394/:0:0","tags":null,"title":"0394：字符串解码（★★）","uri":"/leetcode/0394/"},{"categories":null,"content":"题目 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。 注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例 1： 输入：s = \"3[a]2[bc]\"\r输出：\"aaabcbc\"\r示例 2： 输入：s = \"3[a2[c]]\"\r输出：\"accaccacc\"\r示例 3： 输入：s = \"2","date":"2016-09-04","objectID":"/leetcode/0394/:1:0","tags":null,"title":"0394：字符串解码（★★）","uri":"/leetcode/0394/"},{"categories":null,"content":"分析 显然 s 的编码由子串递归地组成。可以用栈模拟这个过程，一趟解决。 ","date":"2016-09-04","objectID":"/leetcode/0394/:2:0","tags":null,"title":"0394：字符串解码（★★）","uri":"/leetcode/0394/"},{"categories":null,"content":"解答 def decodeString(self, s: str) -\u003e str: stack = [[]] for left, sub, right in re.findall(r'(\\[)|([a-z]+|\\d+)|(\\])', s): if left: stack.append([]) elif right: x = ''.join(stack.pop()) stack[-1][-1] = x*int(stack[-1][-1]) else: stack[-1].append(sub) return ''.join(stack[0]) 32 ms ","date":"2016-09-04","objectID":"/leetcode/0394/:3:0","tags":null,"title":"0394：字符串解码（★★）","uri":"/leetcode/0394/"},{"categories":null,"content":" 第 3 场周赛第 2 题 ","date":"2016-09-04","objectID":"/leetcode/0393/:0:0","tags":null,"title":"0393：UTF-8 编码验证（★★）","uri":"/leetcode/0393/"},{"categories":null,"content":"题目 UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。 对于 n 字节的字符 (n \u003e 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。 剩下的没有提及的二进制位，全部为这个符号的 unicode 码。 这是 UTF-8 编码的工作方式： Char. number range | UTF-8 octet sequence\r(hexadecimal) | (binary)\r--------------------+--------","date":"2016-09-04","objectID":"/leetcode/0393/:1:0","tags":null,"title":"0393：UTF-8 编码验证（★★）","uri":"/leetcode/0393/"},{"categories":null,"content":"分析 先取第一个字节，得到第一个字符的长度，然后判断是否符合。再从该字符后的位置循环即可。 ","date":"2016-09-04","objectID":"/leetcode/0393/:2:0","tags":null,"title":"0393：UTF-8 编码验证（★★）","uri":"/leetcode/0393/"},{"categories":null,"content":"解答 def validUtf8(self, data: List[int]) -\u003e bool: def cal(num): bits = bin(num\u0026255)[2:].zfill(8) return len(bits.split('0')[0]) i, n = 0, len(data) while i \u003c n: x = cal(data[i]) if x not in [0, 2, 3, 4]: return False x = x or 1 if i+x \u003e n or any(cal(num) != 1 for num in data[i+1:i+x]): return False i","date":"2016-09-04","objectID":"/leetcode/0393/:3:0","tags":null,"title":"0393：UTF-8 编码验证（★★）","uri":"/leetcode/0393/"},{"categories":null,"content":" 第 3 场周赛第 1 题 ","date":"2016-09-04","objectID":"/leetcode/0392/:0:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"题目 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。 （例如，“ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k \u003e= 10亿，你需要依次检查它们是否为 T 的子序列。 在这种情况下，你会怎样改变代码？ 提示： 0 \u003c= s.length \u003c= 100 0 \u003c= t.length \u003c= 10^4 两个字符串都只由小写字符组成 示例 1： 输入：s = \"abc\", t = \"ahbgdc\"\r输出：t","date":"2016-09-04","objectID":"/leetcode/0392/:1:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"分析 ","date":"2016-09-04","objectID":"/leetcode/0392/:2:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"#1 遍历 s 的每个字符，在剩下的 t 中找第一个位置即可。 def isSubsequence(self, s: str, t: str) -\u003e bool: pos = 0 for char in s: pos = t.find(char, pos) + 1 if not pos: return False return True 24 ms ","date":"2016-09-04","objectID":"/leetcode/0392/:2:1","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"#2 也可以遍历 t，逐步匹配 s。 def isSubsequence(self, s: str, t: str) -\u003e bool: i, n = 0, len(s) for char in t: if i\u003cn and char == s[i]: i += 1 return i==n 40 ms ","date":"2016-09-04","objectID":"/leetcode/0392/:2:2","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"#3 还有种简单的迭代器写法。 ","date":"2016-09-04","objectID":"/leetcode/0392/:2:3","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"解答 def isSubsequence(self, s: str, t: str) -\u003e bool: it = iter(t) return all(c in it for c in s) 40 ms ","date":"2016-09-04","objectID":"/leetcode/0392/:3:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":"*附加 如果有大量的 s，考虑保存 t 中字符 x 对应的下标列表，遍历 s 时从下标列表中二分查询即可。 ","date":"2016-09-04","objectID":"/leetcode/0392/:4:0","tags":null,"title":"0392：判断子序列（★）","uri":"/leetcode/0392/"},{"categories":null,"content":" 第 2 场周赛第 3 题 ","date":"2016-08-28","objectID":"/leetcode/0391/:0:0","tags":null,"title":"0391：完美矩形（★★★）","uri":"/leetcode/0391/"},{"categories":null,"content":"题目 我们有 N 个与坐标轴对齐的矩形, 其中 N \u003e 0, 判断它们是否能精确地覆盖一个矩形区域。 每个矩形用左下角的点和右上角的点的坐标来表示。例如， 一个单位正方形可以表示为 [1,1,2,2]。 ( 左下角的点的坐标为 (1, 1) 以及右上角的点的坐标为 (2, 2) )。 示例 1: rectangles = [\r[1,1,3,3],\r[3,1,4,2],\r[3,2,4,4],\r[1,3,2,4],\r[2,3,3,4]\r]\r返回 true。5个矩形一起可以精确地覆盖一个矩形区域。\r示例 2: rectangles = [\r[1,1,2,3],\r[1,3,2,4],\r[3,1,4,2","date":"2016-08-28","objectID":"/leetcode/0391/:1:0","tags":null,"title":"0391：完美矩形（★★★）","uri":"/leetcode/0391/"},{"categories":null,"content":"分析 精确覆盖即代表没有重叠、没有间隙。考虑根据轮廓线来判断，类似 0218 遍历所有边缘坐标 x，维护还没掠过的高度区间集合，如果该集合精确覆盖一个区间且一直不变，即说明是完美矩形。 在边缘 x 处（除了第一个和最后一个 x），只需要判断新增的区间集合和弹出的区间集合是否等价即可。 不需要真的维护整个区间集合。 ","date":"2016-08-28","objectID":"/leetcode/0391/:2:0","tags":null,"title":"0391：完美矩形（★★★）","uri":"/leetcode/0391/"},{"categories":null,"content":"解答 def isRectangleCover(self, rectangles: List[List[int]]) -\u003e bool: def merge(A): res = [] for s, e in sorted(A): if not res or res[-1][1] \u003c s: res.append([s, e]) elif res[-1][1] == s: res[-1][1] = e else: return None return res d = defaultdict(list) for x1, y1, x2, y2 in rectangles: d[x1].append((y","date":"2016-08-28","objectID":"/leetcode/0391/:3:0","tags":null,"title":"0391：完美矩形（★★★）","uri":"/leetcode/0391/"},{"categories":null,"content":" 第 2 场周赛第 2 题 ","date":"2016-08-28","objectID":"/leetcode/0390/:0:0","tags":null,"title":"0390：消除游戏（★★）","uri":"/leetcode/0390/"},{"categories":null,"content":"题目 给定一个从1 到 n 排序的整数列表。 首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。 第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。 我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。 返回长度为 n 的列表中，最后剩下的数字。 示例： 输入: n = 9, 1 2 3 4 5 6 7 8 9 2 4 6 8 2 6 6 输出: 6 ","date":"2016-08-28","objectID":"/leetcode/0390/:1:0","tags":null,"title":"0390：消除游戏（★★）","uri":"/leetcode/0390/"},{"categories":null,"content":"分析 典型的递归。令 dfs(n) 代表长度 n 玩游戏最终剩下的是第几个数字： 设初始数组 A，第一轮后剩下长度为 n//2 的数组 B=A[1::2] 最终数字即是 B 的第 dfs(n//2) 个数字 B[0] 是 A 中第 n//2*2 个数字 最终数字即是 A 的第 n//2 * 2 - 2 * (dfs(n//2)-1) 个数字 ","date":"2016-08-28","objectID":"/leetcode/0390/:2:0","tags":null,"title":"0390：消除游戏（★★）","uri":"/leetcode/0390/"},{"categories":null,"content":"解答 def lastRemaining(self, n: int) -\u003e int: return 1 if n==1 else n//2*2-2*(self.lastRemaining(n//2)-1) 52 ms ","date":"2016-08-28","objectID":"/leetcode/0390/:3:0","tags":null,"title":"0390：消除游戏（★★）","uri":"/leetcode/0390/"},{"categories":null,"content":" 第 2 场周赛第 1 题 ","date":"2016-08-28","objectID":"/leetcode/0389/:0:0","tags":null,"title":"0389：找不同","uri":"/leetcode/0389/"},{"categories":null,"content":"题目 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 提示： 0 \u003c= s.length \u003c= 1000 t.length == s.length + 1 s 和 t 只包含小写字母 示例 1： 输入：s = \"abcd\", t = \"abcde\" 输出：\"e\" 解释：'e' 是那个被添加的字母。 示例 2： 输入：s = \"\", t = \"y\" 输出：\"y\" 示例 3： 输入：s = \"a\", t = \"aa\" 输出：\"a\" 示例 4： 输入：s = \"ae\", t = \"aea\" 输出：\"a","date":"2016-08-28","objectID":"/leetcode/0389/:1:0","tags":null,"title":"0389：找不同","uri":"/leetcode/0389/"},{"categories":null,"content":"分析 简单的计数。 ","date":"2016-08-28","objectID":"/leetcode/0389/:2:0","tags":null,"title":"0389：找不同","uri":"/leetcode/0389/"},{"categories":null,"content":"解答 def findTheDifference(self, s: str, t: str) -\u003e str: return (Counter(t) - Counter(s)).popitem()[0] 24 ms ","date":"2016-08-28","objectID":"/leetcode/0389/:3:0","tags":null,"title":"0389：找不同","uri":"/leetcode/0389/"},{"categories":null,"content":"　　在每千年回归一次的彗星造访过一个月之后的日本。\n　　某个深山的乡下小镇，女高中生三叶每天都过着忧郁的生活。\n　　而她烦恼的不光有担任镇长的父亲所举行的选举运动，还有家传神社的古老习俗。\n　　在这个小小的城镇，周围都只是些爱瞎操心的老人。为此三叶对于大都市充满了憧憬。\n　　“下辈子就让我成为东京的帅哥吧……！！！”\n　　然而某一天，自己做了一个变成男孩子的梦。\n　　这儿有着陌生的房间、陌生的朋友。而眼前出现的则是东京的街道。\n　　三叶虽然感到困惑，但是能够来到朝思暮想的都市生活，让她觉得神清气爽。\n　　“不可思议的梦……”\n　　另一方面在东京生活的男高中生·泷也做了个奇怪的梦。\n　　他在一个从未去过的深山小镇中，变成了女高中生……\n　　那么他们体验的梦境到底有什么秘密呢？\n　　原本不会相遇的两人由此相逢。\n　　少女和少年奇迹的故事，开始了。","date":"2016-08-26","objectID":"/anime/your_name/","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":"简介 在每千年回归一次的彗星造访过一个月之后的日本。 某个深山的乡下小镇，女高中生三叶每天都过着忧郁的生活。 而她烦恼的不光有担任镇长的父亲所举行的选举运动，还有家传神社的古老习俗。 在这个小小的城镇，周围都只是些爱瞎操心的老人。为此三叶对于大都市充满了憧憬。 “下辈子就让我成为东京的帅哥吧……！！！” 然而某一天，自己做了一个变成男孩子的梦。 这儿有着陌生的房间、陌生的朋友。而眼前出现的则是东京的街道。 三叶虽然感到困惑，但是能够来到朝思暮想的都市生活，让她觉得神清气爽。 “不可思议的梦……” 另一方面在东京生活的男高中生·泷也做了个奇怪的梦。 他在一个从未去过的深山小镇中，变成了女高中生…","date":"2016-08-26","objectID":"/anime/your_name/:1:0","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 立花泷 たちばな たき、Tachibana Taki 男 神木隆之介 2 宫水三叶 みやみず みつは、Miyamizu Mitsuha 女 上白石萌音 3 奥寺美纪 おくでら ミキ、Okudera Miki 女 長澤まさみ 4 宫水一叶 女 市原悦子 5 敕使河原克彦 てしがわら かつひこ、Teshigawara Katsuhiko 男 成田凌 6 名取早耶香 なとり さやか、Natori Sayaka 女 悠木碧 7 藤井司 ふじい つかさ、Fujii Tsukasa 男 島﨑信長 8 高木真太 たかぎ しんた、Takagi Shinta 男 石川界人 ","date":"2016-08-26","objectID":"/anime/your_name/:2:0","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 你的名字。 2016-08-26 1 bilibili ","date":"2016-08-26","objectID":"/anime/your_name/:3:0","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":"MAD ","date":"2016-08-26","objectID":"/anime/your_name/:4:0","tags":null,"title":"你的名字。","uri":"/anime/your_name/"},{"categories":null,"content":" 第 1 场周赛第 3 题 ","date":"2016-08-21","objectID":"/leetcode/0388/:0:0","tags":null,"title":"0388：文件的最长绝对路径（★）","uri":"/leetcode/0388/"},{"categories":null,"content":"题目 假设文件系统如下图所示： 这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。 subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2， 该子目录下包含文件 file2.ext 。 在文本格式中，如下所示(⟶表示制表符)： dir ⟶ subdir1 ⟶ ⟶ file1.ext ⟶ ⟶ subsubdir1 ⟶ subdir2 ⟶ ⟶ subsubdir2 ⟶ ⟶ ⟶ file2.ext 如果是代码表示，上面的文件系统可以写为 \"dir\\n\\tsubdir1\\n\\t\\","date":"2016-08-21","objectID":"/leetcode/0388/:1:0","tags":null,"title":"0388：文件的最长绝对路径（★）","uri":"/leetcode/0388/"},{"categories":null,"content":"分析 观察可知： input 按 ‘\\n’ 分割即为文本格式 分割后，每一行开头的 ‘\\t’ 个数即代表层级 若包含 ‘.’ 即为文件名，否则为目录名 维护每一层对应的绝对路径长度，即可得到当前目录/文件的绝对路径长度。 ","date":"2016-08-21","objectID":"/leetcode/0388/:2:0","tags":null,"title":"0388：文件的最长绝对路径（★）","uri":"/leetcode/0388/"},{"categories":null,"content":"解答 def lengthLongestPath(self, input: str) -\u003e int: res, d = 0, {-1: -1} for line in input.split('\\n'): name = line.strip('\\t') rank = len(line)-len(name) d[rank] = d[rank-1]+1+len(name) if '.' in name: res = max(res, d[rank]) return res 32 ms ","date":"2016-08-21","objectID":"/leetcode/0388/:3:0","tags":null,"title":"0388：文件的最长绝对路径（★）","uri":"/leetcode/0388/"},{"categories":null,"content":" 第 1 场周赛第 2 题 ","date":"2016-08-21","objectID":"/leetcode/0387/:0:0","tags":null,"title":"0387：字符串中的第一个唯一字符","uri":"/leetcode/0387/"},{"categories":null,"content":"题目 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 提示：你可以假定该字符串只包含小写字母。 示例： s = \"leetcode\"\r返回 0\rs = \"loveleetcode\"\r返回 2\r","date":"2016-08-21","objectID":"/leetcode/0387/:1:0","tags":null,"title":"0387：字符串中的第一个唯一字符","uri":"/leetcode/0387/"},{"categories":null,"content":"分析 记录每个字符出现的次数，遍历找到第一个出现一次的字符即可。 ","date":"2016-08-21","objectID":"/leetcode/0387/:2:0","tags":null,"title":"0387：字符串中的第一个唯一字符","uri":"/leetcode/0387/"},{"categories":null,"content":"解答 def firstUniqChar(self, s: str) -\u003e int: ct = Counter(s) for i, char in enumerate(s): if ct[char] == 1: return i return -1 92 ms ","date":"2016-08-21","objectID":"/leetcode/0387/:3:0","tags":null,"title":"0387：字符串中的第一个唯一字符","uri":"/leetcode/0387/"},{"categories":null,"content":" 第 1 场周赛第 1 题 ","date":"2016-08-21","objectID":"/leetcode/0386/:0:0","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"题目 给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。 示例 1： 输入：n = 13\r输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]\r示例 2： 输入：n = 2\r输出：[1,2]\r提示： 1 \u003c= n \u003c= 5 * 10^4 ","date":"2016-08-21","objectID":"/leetcode/0386/:1:0","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"分析 ","date":"2016-08-21","objectID":"/leetcode/0386/:2:0","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"#1 观察知道字典排序和字符串排序是一样的，可直接调包。 def lexicalOrder(self, n: int) -\u003e List[int]: return sorted(range(1, n+1), key=str) 44 ms ","date":"2016-08-21","objectID":"/leetcode/0386/:2:1","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"#2 要求时间 O(N)，空间 O(1)，可以用 dfs 构造。 先考虑 ‘1’，然后在后面加 ‘0’，当大于 n 时就返回上一步，尝试加更大的数。 ","date":"2016-08-21","objectID":"/leetcode/0386/:2:2","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"解答 def lexicalOrder(self, n: int) -\u003e List[int]: def dfs(i): for j in range(max(1, i*10), min(i*10+10, n+1)): res.append(j) dfs(j) res = [] dfs(0) return res 136 ms ","date":"2016-08-21","objectID":"/leetcode/0386/:3:0","tags":null,"title":"0386：字典序排数（★）","uri":"/leetcode/0386/"},{"categories":null,"content":"　　平凡的中学二年级少年影山茂夫，因其微弱的存在感与名字茂夫的谐音被周遭人称为龙套（モブ），但不起眼的他其实是强大的天生超能力者。历经每一次的成长，龙套开始认为自己的超能力是危险的存在，为了不让超能力失控，龙套无意识的压抑著情感。虽然只想平凡的度过每一天，但各种麻烦却接二连三找上他，随着被压抑的情感在内心一点点膨胀，龙套体内积累的力量似乎也正蠢蠢欲动......","date":"2016-07-11","objectID":"/anime/mob_psycho_100/","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":"简介 平凡的中学二年级少年影山茂夫，因其微弱的存在感与名字茂夫的谐音被周遭人称为龙套（モブ），但不起眼的他其实是强大的天生超能力者。历经每一次的成长，龙套开始认为自己的超能力是危险的存在，为了不让超能力失控，龙套无意识的压抑著情感。虽然只想平凡的度过每一天，但各种麻烦却接二连三找上他，随着被压抑的情感在内心一点点膨胀，龙套体内积累的力量似乎也正蠢蠢欲动…… 制作人员： 原作：ONE 导演：立川让 脚本：濑古浩司 分镜：重原克也、安斋刚文、川畑乔、藤泽研一、米谷良知 ","date":"2016-07-11","objectID":"/anime/mob_psycho_100/:1:0","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 影山茂夫 龙套、影山 茂夫、かげやま しげお、Kageyama Shigeo、モブ 男 伊藤節生 2 灵幻新隆 霊幻 新隆、れいげん あらたか、Reigen Arataka 男 櫻井孝宏 3 小酒窝 エクボ、Ekubo 男 大塚明夫 4 影山律 影山 律、かげやま りつ、Kageyama Ritsu 男 入野自由 5 花泽辉气 花沢 輝気、はなざわ てるき、Hanazawa Teruki 男 松岡禎丞 6 鬼瓦天牙 鬼瓦 天牙、おにがわら てんが、Onigawara Tenga 男 細谷佳正 7 米里一 米里 イチ、めざと イチ、Mezato Ichi 女 ","date":"2016-07-11","objectID":"/anime/mob_psycho_100/:2:0","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 灵能百分百 2016-07-11 12 bilibili 2 灵能百分百 REIGEN ～不为人知的奇迹的灵能力者～ 2018-03-18 1 bilibili 3 灵能百分百 第二季 2019-01-07 13 bilibili 4 灵能百分百 第一回灵能相谈所犒劳旅行～心满意足的治愈之旅～ 2019-09-25 1 bilibili 5 灵能百分百 第三季 2022-10-05 12 bilibili ","date":"2016-07-11","objectID":"/anime/mob_psycho_100/:3:0","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":"MAD ","date":"2016-07-11","objectID":"/anime/mob_psycho_100/:4:0","tags":null,"title":"灵能百分百","uri":"/anime/mob_psycho_100/"},{"categories":null,"content":"高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能力，以不起眼、不和他人有所牵扯为信条，默默无闻地过日子。但不知为何，他的身边总是聚集着不可思议的人类（生物），风暴般的灾难接连不断地降临！","date":"2016-07-10","objectID":"/anime/saiki_kusuo/","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"简介 高中生·齐木楠雄是超能力者。心灵感应、念动力、透视、预知、瞬间移动、千里眼等，不论任何事情都自由自在。但这任谁都羡慕不已的最强能力，实际上对于本人而言是引来灾难的不幸元凶。因此，他在别人面前封印了超能力，以不起眼、不和他人有所牵扯为信条，默默无闻地过日子。但不知为何，他的身边总是聚集着不可思议的人类（生物），风暴般的灾难接连不断地降临！ 制作人员： 原作：麻生周一 导演：樱井弘明 脚本：横谷昌宏、横手美智子、金杉弘子、杉原研二 分镜：赤城博昭、名村英敏、梶井濑贺 ","date":"2016-07-10","objectID":"/anime/saiki_kusuo/:1:0","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 齐木楠雄 斉木 楠雄、さいき くすお、Saiki Kusuo 男 神谷浩史 2 燃堂力 燃堂 力、ねんどう りき、Nendō Riki 男 小野大輔 3 海藤瞬 海藤 瞬、かいどう しゅん、Kaidō Shun 男 島﨑信長 4 灰吕杵志 灰呂 杵志、はいろ きねし、Hairo Kineshi 男 日野聡 5 鸟束零太 鳥束 零太、とりつか れいた、Toritsuka Reita 男 花江夏樹 6 照桥心美 照橋 心美、てるはし ここみ、Teruhashi Kokomi 女 茅野愛衣 7 梦原知予 夢原 知予、ゆめはら ちよ、Yumehara Chiyo 女","date":"2016-07-10","objectID":"/anime/saiki_kusuo/:2:0","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 齐木楠雄的灾难 2016-07-10 24 bilibili 2 齐木楠雄的灾难 第二季 2018-01-16 24 bilibili 3 齐木楠雄的灾难 完结篇 2018-12-28 2 bilibili 4 齐木楠雄的灾难 再始动篇 2019-12-30 6 bilibili ","date":"2016-07-10","objectID":"/anime/saiki_kusuo/:3:0","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"MAD ","date":"2016-07-10","objectID":"/anime/saiki_kusuo/:4:0","tags":null,"title":"齐木楠雄的灾难","uri":"/anime/saiki_kusuo/"},{"categories":null,"content":"B\u0026T首部动画电影巨作《大鱼 海棠》，导演用了三年形成《大鱼.海棠》的创意，用了三年写完《大鱼.海棠》的剧本。影片讲述了一个属于中国人的奇幻故事。试图向观众展现那条游弋在每个中国人血液和灵魂中的大鱼——鲲。\n\n获第十六届上海电视节“最佳创意奖”。影片预览获第十四届韩国首尔国际动漫节最佳技术奖，并入选第五十届法国昂西国际动漫节。","date":"2016-07-08","objectID":"/anime/big_fish/","tags":null,"title":"大鱼·海棠","uri":"/anime/big_fish/"},{"categories":null,"content":"简介 B\u0026T首部动画电影巨作《大鱼 海棠》，导演用了三年形成《大鱼.海棠》的创意，用了三年写完《大鱼.海棠》的剧本。影片讲述了一个属于中国人的奇幻故事。试图向观众展现那条游弋在每个中国人血液和灵魂中的大鱼——鲲。 获第十六届上海电视节“最佳创意奖”。影片预览获第十四届韩国首尔国际动漫节最佳技术奖，并入选第五十届法国昂西国际动漫节。 制作人员： 原作：梁旋 音乐：吉田洁 原画：羊廷牧 主题歌演出：陈奕迅 製作：霍尔果斯彩条屋影业有限公司、北京光线影业有限公司 制作助手：震雷动画 ","date":"2016-07-08","objectID":"/anime/big_fish/:1:0","tags":null,"title":"大鱼·海棠","uri":"/anime/big_fish/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 椿 女 季冠霖 2 湫 男 苏尚卿 3 鲲 男 ","date":"2016-07-08","objectID":"/anime/big_fish/:2:0","tags":null,"title":"大鱼·海棠","uri":"/anime/big_fish/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 大鱼·海棠 2016-07-08 1 bilibili ","date":"2016-07-08","objectID":"/anime/big_fish/:3:0","tags":null,"title":"大鱼·海棠","uri":"/anime/big_fish/"},{"categories":null,"content":"在封印的都市中被废弃的天象馆，误入其中的男人所见到的机器人少女，那是被繁星所引导的奇迹的物语。\n那是世界大战之后不再降雨的世界。受到细菌武器的影响，而被人们抛弃了的最危险的城市【封印都市】。在某个百货商场的天文馆中，有一个机器人少女。她的名字是“星野梦美”。她是天文馆的解说员，1年之中只有7日运行的损坏的机器人。就这样，少女在这30年间始终相信着会有某个人到访天文馆，一个人在这个没有其他人的世界等待着。然后，在第三十个年头醒来的那天，她的面前出现了一个男人。\n“恭喜您！您正正好是250万个客人！”\n对突然出现的机器人进行警戒的男人——“废墟猎人”，以自城市回收贵重物资作为生计的他，正为了生存潜入【封印都市】，被在都市中徘徊的战斗机械的袭击，而误入了这个天文馆。\n“要来观赏一下天象仪吗。无论何时都不会消失的美丽的无尽的星光……漫天的星星们正在等着大家呢”\n在大战的影响之下，连星星都无法再看见的濒临毁灭的这个世界，他究竟在那里看到了什么。一年之中只有7天能够运行的机器人少女，苏醒的那一天正遇上那偶然的到访。\n奇迹就这样发生了……","date":"2016-07-07","objectID":"/anime/planetarian/","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":"简介 在封印的都市中被废弃的天象馆，误入其中的男人所见到的机器人少女，那是被繁星所引导的奇迹的物语。 那是世界大战之后不再降雨的世界。受到细菌武器的影响，而被人们抛弃了的最危险的城市【封印都市】。在某个百货商场的天文馆中，有一个机器人少女。她的名字是“星野梦美”。她是天文馆的解说员，1年之中只有7日运行的损坏的机器人。就这样，少女在这30年间始终相信着会有某个人到访天文馆，一个人在这个没有其他人的世界等待着。然后，在第三十个年头醒来的那天，她的面前出现了一个男人。 “恭喜您！您正正好是250万个客人！” 对突然出现的机器人进行警戒的男人——“废墟猎人”，以自城市回收贵重物资作为生计的他，正为了","date":"2016-07-07","objectID":"/anime/planetarian/:1:0","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 星野梦美 ほしのゆめみ、Hoshino yumemi 女 すずきけいこ 2 废墟猎人 星の人、くずや、Kuzuya 男 小野大輔 ","date":"2016-07-07","objectID":"/anime/planetarian/:2:0","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 星之梦 2016-07-07 5 bilibili 2 星之梦～星之人～ 2016-09-03 1 bilibili 3 星之梦～雪圏球～ 2021-08-25 1 bilibili ","date":"2016-07-07","objectID":"/anime/planetarian/:3:0","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":"MAD ","date":"2016-07-07","objectID":"/anime/planetarian/:4:0","tags":null,"title":"星之梦","uri":"/anime/planetarian/"},{"categories":null,"content":"海崎新太（27岁）在作为新毕业生进入的公司工作了3个月就辞职了。\n之后他的就职活动也不顺利。\n双亲寄来的生活费也中断了，不得已只好回到乡下。\n能够倾听他烦恼的朋友和女友全都没有……\n穷途末路的海崎面前出现了一位神秘人物·夜明了。\n夜明向海崎提出，要他参加以尼特为对象的社会复归程序“ReLIFE”。\n其内容是，利用神秘的秘药，仅仅让外表回复年轻，并在一年内以高中生的身份去读高中——。","date":"2016-07-01","objectID":"/anime/relife/","tags":null,"title":"ReLIFE","uri":"/anime/relife/"},{"categories":null,"content":"简介 海崎新太（27岁）在作为新毕业生进入的公司工作了3个月就辞职了。 之后他的就职活动也不顺利。 双亲寄来的生活费也中断了，不得已只好回到乡下。 能够倾听他烦恼的朋友和女友全都没有…… 穷途末路的海崎面前出现了一位神秘人物·夜明了。 夜明向海崎提出，要他参加以尼特为对象的社会复归程序“ReLIFE”。 其内容是，利用神秘的秘药，仅仅让外表回复年轻，并在一年内以高中生的身份去读高中——。 制作人员： 原作：夜宵草 导演：小坂知 脚本：兵头一步、横手美智子 分镜：备前克彦、关晓子、山田弘和、添田和弘 ","date":"2016-07-01","objectID":"/anime/relife/:1:0","tags":null,"title":"ReLIFE","uri":"/anime/relife/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 日代千鹤 日代 千鶴、ひしろ ちづる、Hishiro Chizuru 女 茅野愛衣 2 海崎新太 海崎 新太、かいざき あらた、Kaizaki Arata 男 小野賢章 3 小野屋杏 小野屋 杏、おのや あん、Onoya An 女 上田麗奈 4 夜明了 夜明 了、よあけ りょう、Yoake Ryou 男 木村良平 5 大神和臣 大神 和臣、おおが かずおみ、Ooga Kazuomi 男 内田雄馬 6 狩生玲奈 狩生 玲奈、かりう れな、Kariu Rena 女 戸松遥 7 玉来萌香 玉来 ほのか、たまらい ほのか、Tamerai Honoka 女 茜屋日海夏","date":"2016-07-01","objectID":"/anime/relife/:2:0","tags":null,"title":"ReLIFE","uri":"/anime/relife/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 ReLIFE 2016-07-01 13 bilibili 2 ReLIFE 完结篇 2018-03-21 4 bilibili ","date":"2016-07-01","objectID":"/anime/relife/:3:0","tags":null,"title":"ReLIFE","uri":"/anime/relife/"},{"categories":null,"content":"《ISLAND》是Frontwing制作的冒险电脑游戏，Frontwing15周年纪念作品。故事穿插着各种各样的关键词，通过巧妙的伏笔，“世界的秘密”一点点揭晓。","date":"2016-04-28","objectID":"/game/island/","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":"简介 《ISLAND》是Frontwing制作的冒险电脑游戏，Frontwing15周年纪念作品。 故事穿插着各种各样的关键词，通过巧妙的伏笔， “世界的秘密”一点点揭晓。 制作人员： 开发：前翼 剧本：G.O. 音乐：安濑圣 人物设定：空中幼彩 主题歌作曲：藤田淳平 主题歌演出：riya ","date":"2016-04-28","objectID":"/game/island/:1:0","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 三千界切那 さんぜんかい せつな、Sanzenkai Setsuna 男 没有人 2 御原凛音 おはら りんね、Ohara Rinne 女 田村ゆかり 3 枢都夏莲 くるつ かれん、Kurutsu Karen 女 阿澄佳奈 4 伽蓝堂纱罗 がらんどう さら、Garandou Sara 女 村川梨衣 5 御原玖音 おはら くおん、Ohara Kuon 女 佐藤利奈 6 播守太郎 播守 太郎、はりす たろう、Harisu Tarou、駐在 男 茂木たかまさ 7 山吹桃香 やまぶき ももか、Yamabuki Momoka 女 加隈亜衣 8 枢都守春 くつる すばる","date":"2016-04-28","objectID":"/game/island/:2:0","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":"系列 系列名 发行时间 1 ISLAND 2016-04-28 ","date":"2016-04-28","objectID":"/game/island/:3:0","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":"配乐 ","date":"2016-04-28","objectID":"/game/island/:4:0","tags":null,"title":"island","uri":"/game/island/"},{"categories":null,"content":"以伤痛相连的羁绊物语——。\n少年少女们分享“疼痛”的青春群像剧，现在开始！！\n舞台是在废弃的土地上建造的城镇·洲笼市。住在这座曾以未来型都市而繁荣的城镇的高中生·阿形胜平，不知为何拥有着感觉不到疼痛的不可思议身体。在暑假近在眼前的某天，胜平在谜之少女·园崎法子的引领下，被选为共享疼痛的同伴“羁绊者”之一。以及，同样以“羁绊者”身份被联系起来的同班同学们。但，他们原本各自属于从未交流过的集团。园崎说“这是，将充满纷争的世界导向和平的实验。”与这番话语同时，众多的试炼降临到他们的身上。\n背负着各自的伤痛，少年少女们的夏日物语由此开始！","date":"2016-04-09","objectID":"/anime/kiznaiver/","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":"简介 以伤痛相连的羁绊物语——。 少年少女们分享“疼痛”的青春群像剧，现在开始！！ 舞台是在废弃的土地上建造的城镇·洲笼市。住在这座曾以未来型都市而繁荣的城镇的高中生·阿形胜平，不知为何拥有着感觉不到疼痛的不可思议身体。在暑假近在眼前的某天，胜平在谜之少女·园崎法子的引领下，被选为共享疼痛的同伴“羁绊者”之一。以及，同样以“羁绊者”身份被联系起来的同班同学们。但，他们原本各自属于从未交流过的集团。园崎说“这是，将充满纷争的世界导向和平的实验。”与这番话语同时，众多的试炼降临到他们的身上。 背负着各自的伤痛，少年少女们的夏日物语由此开始！ 制作人员： 原作：TRIGGER、冈田麿里 导演：小林宽","date":"2016-04-09","objectID":"/anime/kiznaiver/:1:0","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿形胜平 阿形 勝平、あかた かつひら、AGATA KATSUHIRA 男 梶裕貴 2 园崎法子 園崎 法子、そのさき のりこ、SONOZAKI NORIKO 女 山村響 3 天河一 天河 一、てんが はじめ、TENGA HAJIME 男 前野智昭 4 由多次人 由多 次人、よしだ つぐと、YUTA TSUGUHITO 男 島﨑信長 5 牧穗乃香 牧 穂乃香、まき ほのか、MAKI HONOKA 女 佐藤利奈 6 高城千鸟 高城 千鳥、たかしろ ちどり、TAKASHIRO CHIDORI 女 寺崎裕香 7 新山仁子 新山 仁子、にいやま にこ、NIYAMA ","date":"2016-04-09","objectID":"/anime/kiznaiver/:2:0","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 羁绊者 2016-04-09 12 樱花 ","date":"2016-04-09","objectID":"/anime/kiznaiver/:3:0","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":"MAD ","date":"2016-04-09","objectID":"/anime/kiznaiver/:4:0","tags":null,"title":"羁绊者","uri":"/anime/kiznaiver/"},{"categories":null,"content":"酷、很酷、最最酷的高中生登场了！\n本故事是某个很酷，不，是最酷的高中生坂本的校园生活的集锦。\n刚入学不久，就出现一位被全班，不是被全校瞩目的学生。\n他名为坂本。\n一旦与他扯上关系，普通的反复横跳就会升级为秘技“Repetition Side Step”\n他把上级生强加于他的“跑腿活”华丽升格为“尽心尽责的服务”。\n这样炫酷的他，一举手一投足都摄人心魄。","date":"2016-04-07","objectID":"/anime/sakamoto_desu_ga/","tags":null,"title":"在下坂本，有何贵干？","uri":"/anime/sakamoto_desu_ga/"},{"categories":null,"content":"简介 酷、很酷、最最酷的高中生登场了！ 本故事是某个很酷，不，是最酷的高中生坂本的校园生活的集锦。 刚入学不久，就出现一位被全班，不是被全校瞩目的学生。 他名为坂本。 一旦与他扯上关系，普通的反复横跳就会升级为秘技“Repetition Side Step” 他把上级生强加于他的“跑腿活”华丽升格为“尽心尽责的服务”。 这样炫酷的他，一举手一投足都摄人心魄。 制作人员： 原作：佐野菜见 导演：高松信司 分镜：城所圣明、川崎逸朗、齐藤哲人、稻垣隆行、名村英敏 ","date":"2016-04-07","objectID":"/anime/sakamoto_desu_ga/:1:0","tags":null,"title":"在下坂本，有何贵干？","uri":"/anime/sakamoto_desu_ga/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 坂本 さかもと、Sakamoto、屌神 男 緑川光 2 久保田吉伸 久保田 吉伸 男 石田彰 3 濑良裕也 瀬良 裕也 男 森久保祥太郎 4 黑沼爱菜 黒沼 あいな 女 堀江由衣 5 隼 ハヤブサ先輩 男 遊佐浩二 6 丸山 まるやま 男 稲田徹 7 藤田惠 藤田 恵 女 中原麻衣 8 久保田茂美 くぼた しげみ 女 くじら ","date":"2016-04-07","objectID":"/anime/sakamoto_desu_ga/:2:0","tags":null,"title":"在下坂本，有何贵干？","uri":"/anime/sakamoto_desu_ga/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 在下坂本，有何贵干？ 2016-04-07 13 bilibili ","date":"2016-04-07","objectID":"/anime/sakamoto_desu_ga/:3:0","tags":null,"title":"在下坂本，有何贵干？","uri":"/anime/sakamoto_desu_ga/"},{"categories":null,"content":"　　从便利店回来的路上突然被召唤到异世界的少年，菜月昴。在无可依赖的异世界，无力的少年所唯一拥有的力量……那就是死后便会使时间倒转的“死亡回归”的力量。为了守护重要的人，并取回那些无可替代的时间，少年向绝望抗争，挺身面对残酷的命运。","date":"2016-04-03","objectID":"/anime/re0/","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"简介 从便利店回来的路上突然被召唤到异世界的少年，菜月昴。在无可依赖的异世界，无力的少年所唯一拥有的力量……那就是死后便会使时间倒转的“死亡回归”的力量。为了守护重要的人，并取回那些无可替代的时间，少年向绝望抗争，挺身面对残酷的命运。 制作人员： 原作：长月达平 导演：渡边政治 脚本：梅原英司、横谷昌宏、中村能子 分镜：细田直人、长山延好、相泽昌弘、山岸大悟 ","date":"2016-04-03","objectID":"/anime/re0/:1:0","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 菜月昴 なつき・すばる、Natsuki Subaru 男 小林裕介 2 艾米莉娅 爱蜜莉雅、Emilia、EMT 女 高橋李依 3 蕾姆 雷姆、REM、Remu 女 水瀬いのり 4 拉姆 RAM、ラム、Ramu 女 村川梨衣 5 碧翠丝 ベティ、贝阿特莉丝、Beatrice、ベアトリス、Beatorisu、Betty，贝蒂 女 新井里美 6 帕克 PACK、パック、Pakku 内山夕実 7 菲鲁特 FELT、フェルト、Feruto 女 赤﨑千夏 8 莱茵哈鲁特·梵·阿斯特雷亚 Reinhard Van Astrea 男 中村悠一 ","date":"2016-04-03","objectID":"/anime/re0/:2:0","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Re：从零开始的异世界生活 2016-04-03 25 bilibili 2 Re：从零开始的异世界生活 第二季 2020-07-08 13 bilibili 3 Re：从零开始的异世界生活 第二季 后半部分 2021-01-06 12 bilibili ","date":"2016-04-03","objectID":"/anime/re0/:3:0","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"MAD ","date":"2016-04-03","objectID":"/anime/re0/:4:0","tags":null,"title":"Re：从零开始的异世界生活","uri":"/anime/re0/"},{"categories":null,"content":"　　在宇宙人与地球人共同生活的银河指定宇宙移民特区OGIKUBO和父亲两人生活，随处可见的“超普通”现役女初中生露露子。在过着普通生活的露露子面前突然出现的神秘转学生AΩ·诺瓦。这次“相遇”让露露子的命运卷起波澜。","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":"简介 在宇宙人与地球人共同生活的银河指定宇宙移民特区OGIKUBO和父亲两人生活，随处可见的“超普通”现役女初中生露露子。在过着普通生活的露露子面前突然出现的神秘转学生AΩ·诺瓦。这次“相遇”让露露子的命运卷起波澜。 制作人员： 原作：TRIGGER、今石洋之 脚本：上野贵美子、若林广海、雨宫哲、佐藤裕 分镜：大岛博之 ","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/:1:0","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 露露子 luluco、ルルコ、Ruruko 女 M・A・O 2 ΑΩ·Nova 男 榎木淳弥 3 碧·拯救世界 绿、Midori Save The World、Midori 女 新谷真弓 4 OverJustice本部长 男 稲田徹 5 启司 Keiji 男 岩田光央 6 拉拉子·神佑 Rarako・Godspeed 女 本名陽子 7 宇宙巡警银河总司令 男 檜山修之 8 秘书 秘 書 女 ","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/:2:0","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 宇宙巡警露露子 2016-04-01 13 bilibili ","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/:3:0","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":"MAD ","date":"2016-04-01","objectID":"/anime/uchuu_patrol_luluco/:4:0","tags":null,"title":"宇宙巡警露露子","uri":"/anime/uchuu_patrol_luluco/"},{"categories":null,"content":"　　在这个没有人类，全由动物构成的大都会里，一只叫尼克的狐狸需要和一位兔子警官朱迪通力合作，揭开颠覆动物世界的巨大危机。不过他们好像并不容易相处……","date":"2016-03-04","objectID":"/anime/zootopia/","tags":null,"title":"疯狂动物城","uri":"/anime/zootopia/"},{"categories":null,"content":"简介 在这个没有人类，全由动物构成的大都会里，一只叫尼克的狐狸需要和一位兔子警官朱迪通力合作，揭开颠覆动物世界的巨大危机。不过他们好像并不容易相处…… 制作人员： 导演：拜伦·霍华德、里奇·摩尔 音乐：迈克·吉亚奇诺 人物设定：Jin Kim 原案：珍妮佛·李、Jim Reardon、Jared Bush ","date":"2016-03-04","objectID":"/anime/zootopia/:1:0","tags":null,"title":"疯狂动物城","uri":"/anime/zootopia/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 尼克·王尔德 狐尼克、Nicholas Piberius Wilde 男 Jason Kent Bateman 2 朱迪·霍普斯 兔朱迪、Officer Judy Hopps 女 Ginnifer Goodwin 3 闪电 Flash 男 Raymond S. Persi 4 杜克·威斯顿 雄 Alan Tudyk 5 大先生 雄 Maurice LaMarche 6 Priscilla 雌 Kristen Bell ","date":"2016-03-04","objectID":"/anime/zootopia/:2:0","tags":null,"title":"疯狂动物城","uri":"/anime/zootopia/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 疯狂动物城 2016-03-04 108分钟 樱花 ","date":"2016-03-04","objectID":"/anime/zootopia/:3:0","tags":null,"title":"疯狂动物城","uri":"/anime/zootopia/"},{"categories":null,"content":"题目 给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。 列表中的每个元素只可能是整数或整数嵌套列表 示例 1： 输入：s = \"324\",\r输出：324\r解释：你应该返回一个 NestedInteger 对象，其中只包含整数值 324。\r示例 2： 输入：s = \"[123,[456,[789]]]\",\r输出：[123,[456,[789]]]\r解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：\r1. 一个 integer 包含值 123\r2. 一个包含两个元素的嵌套列表：\ri. 一个 intege","date":"2016-01-20","objectID":"/leetcode/0385/:1:0","tags":null,"title":"0385：迷你语法分析器（★★★）","uri":"/leetcode/0385/"},{"categories":null,"content":"分析 显然 s 的对象由子串递归地组成。可以用栈模拟这个过程，一趟解决。 特别注意数字前可能有负号。 ","date":"2016-01-20","objectID":"/leetcode/0385/:2:0","tags":null,"title":"0385：迷你语法分析器（★★★）","uri":"/leetcode/0385/"},{"categories":null,"content":"解答 def deserialize(self, s: str) -\u003e NestedInteger: stack = [NestedInteger()] for left, num, right in re.findall(r'(\\[)|(-?\\d+)|(\\])', s): if left: stack.append(NestedInteger()) elif num: stack[-1].add(NestedInteger(int(num))) else: x = stack.pop() stack[-1].add(x) return stack[0].getList()[0] 40 ms ","date":"2016-01-20","objectID":"/leetcode/0385/:3:0","tags":null,"title":"0385：迷你语法分析器（★★★）","uri":"/leetcode/0385/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。 实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 示例 1： 输入\r[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"]\r[[[1, 2, 3]], [], [], []]\r输出\r[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\r解释\rSolution solution = n","date":"2016-01-19","objectID":"/leetcode/0384/:1:0","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"分析 ","date":"2016-01-19","objectID":"/leetcode/0384/:2:0","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"#1 最简单的就是调包 random.shuffle()。 class Solution: def __init__(self, nums: List[int]): self.nums = nums self.A = nums[:] def reset(self) -\u003e List[int]: return self.nums def shuffle(self) -\u003e List[int]: random.shuffle(self.A) return self.A 192 ms ","date":"2016-01-19","objectID":"/leetcode/0384/:2:1","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"#2 经典的洗牌方法就是第 i 轮随机取 [i, n) 的一个索引 j，将 A[i]、A[j] 互换。 ","date":"2016-01-19","objectID":"/leetcode/0384/:2:2","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"解答 class Solution: def __init__(self, nums: List[int]): self.nums = nums self.A = nums[:] def reset(self) -\u003e List[int]: return self.nums def shuffle(self) -\u003e List[int]: for i in range(len(self.A)): j = random.randint(i, len(self.A)-1) self.A[i], self.A[j] = self.A[j], self.A[i] return self.A 228 ms ","date":"2016-01-19","objectID":"/leetcode/0384/:3:0","tags":null,"title":"0384：打乱数组（★）","uri":"/leetcode/0384/"},{"categories":null,"content":"题目 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 输入：ransomNote = \"a\", magazine = \"b\"\r输出：false\r示例 2： 输入：ransomNote = \"aa\", magazine = \"ab\"\r输出：false\r示例 3： 输入：ransomNote = \"aa\", magazine = \"aab\"\r输出：true\r提示： 1 \u003c=","date":"2016-01-18","objectID":"/leetcode/0383/:1:0","tags":null,"title":"0383：赎金信（★）","uri":"/leetcode/0383/"},{"categories":null,"content":"分析 显然只要 ransomNote 中每个字符的频数都小于等于在 magazine 中的频数即可。 ","date":"2016-01-18","objectID":"/leetcode/0383/:2:0","tags":null,"title":"0383：赎金信（★）","uri":"/leetcode/0383/"},{"categories":null,"content":"解答 def canConstruct(self, ransomNote: str, magazine: str) -\u003e bool: return not (Counter(ransomNote) - Counter(magazine)) 48 ms ","date":"2016-01-18","objectID":"/leetcode/0383/:3:0","tags":null,"title":"0383：赎金信（★）","uri":"/leetcode/0383/"},{"categories":null,"content":"题目 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。 实现 Solution 类： Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 示例： 输入\r[\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"]\r[[[1, 2, 3]], [], [], [], [], []]\r输出\r[null, 1, 3, 2, 2, 3]\r解","date":"2016-01-17","objectID":"/leetcode/0382/:1:0","tags":null,"title":"0382：链表随机节点（★★）","uri":"/leetcode/0382/"},{"categories":null,"content":"分析 ","date":"2016-01-17","objectID":"/leetcode/0382/:2:0","tags":null,"title":"0382：链表随机节点（★★）","uri":"/leetcode/0382/"},{"categories":null,"content":"#1 最简单的就是保存在数组中，然后随机抽取。 class Solution: def __init__(self, head: ListNode): self.A = [] while head: self.A.append(head.val) head = head.next def getRandom(self) -\u003e int: return random.choice(self.A) 84 ms ","date":"2016-01-17","objectID":"/leetcode/0382/:2:1","tags":null,"title":"0382：链表随机节点（★★）","uri":"/leetcode/0382/"},{"categories":null,"content":"#2 还有个经典的蓄水池抽样方法，无需事先知道长度。 遍历 1 到 n，第 i 轮以 1/i 的概率将 i 赋值到结果。最后结果即是 1 到 n 的随机数。 ","date":"2016-01-17","objectID":"/leetcode/0382/:2:2","tags":null,"title":"0382：链表随机节点（★★）","uri":"/leetcode/0382/"},{"categories":null,"content":"解答 class Solution: def __init__(self, head: ListNode): self.head = head def getRandom(self) -\u003e int: res, i = 0, 0 p = self.head while p: i += 1 if random.randint(1, i) == 1: res = p.val p = p.next return res 180 ms ","date":"2016-01-17","objectID":"/leetcode/0382/:3:0","tags":null,"title":"0382：链表随机节点（★★）","uri":"/leetcode/0382/"},{"categories":null,"content":"题目 RandomizedCollection 是一种包含数字集合(可能是重复的)的数据结构。 它应该支持插入和删除特定元素，以及删除随机元素。 实现 RandomizedCollection 类: RandomizedCollection()初始化空的 RandomizedCollection 对象。 bool insert(int val) 将一个 val 项插入到集合中，即使该项已经存在。 如果该项不存在，则返回 true ，否则返回 false 。 bool remove(int val) 如果存在，从集合中移除一个 val 项。如果该项存在，则返回 true ， 否则返回 false","date":"2016-01-16","objectID":"/leetcode/0381/:1:0","tags":null,"title":"0381：O(1) 时间插入、删除和获取随机元素 - 允许重复（★★★）","uri":"/leetcode/0381/"},{"categories":null,"content":"分析 0380 进阶版，只是允许元素重复了，于是用哈希表记录元素的所有位置即可。 为了保证 O(1)，哈希表用 {int:set} 的结构。 ","date":"2016-01-16","objectID":"/leetcode/0381/:2:0","tags":null,"title":"0381：O(1) 时间插入、删除和获取随机元素 - 允许重复（★★★）","uri":"/leetcode/0381/"},{"categories":null,"content":"解答 class RandomizedCollection: def __init__(self): self.A = [] self.d = defaultdict(set) def insert(self, val: int) -\u003e bool: self.A.append(val) self.d[val].add(len(self.A)-1) return len(self.d[val]) == 1 def remove(self, val: int) -\u003e bool: if not self.d[val]: return False i, last = self.d[val].pop()","date":"2016-01-16","objectID":"/leetcode/0381/:3:0","tags":null,"title":"0381：O(1) 时间插入、删除和获取随机元素 - 允许重复（★★★）","uri":"/leetcode/0381/"},{"categories":null,"content":"题目 实现RandomizedSet 类： RandomizedSet() 初始化 RandomizedSet 对象 bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。 bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。 int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。 每个元素应该有 相同的概率 被返回。 你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1","date":"2016-01-15","objectID":"/leetcode/0380/:1:0","tags":null,"title":"0380：常数时间插入、删除和获取随机元素（★★）","uri":"/leetcode/0380/"},{"categories":null,"content":"分析 如果用哈希表，可以 O(1) 时间内判断元素是否存在，并添加/移除元素， 但不能 O(1) 时间返回随机项。 如果用数组，可以 O(1) 时间内返回随机项，但不能 O(1) 时间判断元素是否存在。 有个巧妙的方法是结合数组和哈希表： 用数组维护元素集合，哈希表维护每个元素和在数组中的位置 insert 时，用哈希表判断元素是否存在，若不存在，更新到数组末尾和哈希表中 remove 时，用哈希表判断元素是否存在，若存在，弹出元素，更新数组和哈希表 要 O(1) 时间弹出数组某个位置的元素，有个巧妙的方法 将数组该位置的元素和末尾元素互换，再从末尾弹出即可 特别注意同步更新哈希表 ","date":"2016-01-15","objectID":"/leetcode/0380/:2:0","tags":null,"title":"0380：常数时间插入、删除和获取随机元素（★★）","uri":"/leetcode/0380/"},{"categories":null,"content":"解答 class RandomizedSet: def __init__(self): self.A = [] self.d = {} def insert(self, val: int) -\u003e bool: if val in self.d: return False self.A.append(val) self.d[val] = len(self.A)-1 return True def remove(self, val: int) -\u003e bool: if val not in self.d: return False i, last = self.d[val], self.A[-1] s","date":"2016-01-15","objectID":"/leetcode/0380/:3:0","tags":null,"title":"0380：常数时间插入、删除和获取随机元素（★★）","uri":"/leetcode/0380/"},{"categories":null,"content":"　　17年前，非洲的战场上出现了绝对不会死的人，人们将这种未知的新生物称为“亚人”。在暑假即将到来之时，日本普通高中生永井圭在放学途中遭遇了交通事故而当场死亡，不过又随即复活，正因如此，其“亚人”的身份暴露，并被投以高额的悬赏。就这样，身为众人类敌人的少年逃避之旅开始了……","date":"2016-01-15","objectID":"/anime/ajin/","tags":null,"title":"亚人","uri":"/anime/ajin/"},{"categories":null,"content":"简介 17年前，非洲的战场上出现了绝对不会死的人，人们将这种未知的新生物称为“亚人”。在暑假即将到来之时，日本普通高中生永井圭在放学途中遭遇了交通事故而当场死亡，不过又随即复活，正因如此，其“亚人”的身份暴露，并被投以高额的悬赏。就这样，身为众人类敌人的少年逃避之旅开始了…… 制作人员： 原作：樱井画门 导演：安藤裕章 脚本：猪原健太、熊谷纯、濑古浩司 分镜：井出惠介、鹿住朗生、福岛宏之、森田宏幸 ","date":"2016-01-15","objectID":"/anime/ajin/:1:0","tags":null,"title":"亚人","uri":"/anime/ajin/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 永井圭 永井 圭、ながい けい、Nagai Kei 男 宮野真守 2 佐藤 帽子、さとう、Satou 男 大塚芳忠 3 户崎优 戸崎 優、とさき ゆう、Tosaki Yuu 男 櫻井孝宏 4 海斗 かいと、Kaito 男 細谷佳正 5 下村泉 田井中陽子、たいなか ようこ、Tainaka Yōko、田井中阳子、下村 泉、しもむら いずみ、Shimomura Izumi 女 小松未可子 6 田中功次 田中 功次、たなか こうじ、Tanaka Kouji 男 平川大輔 7 永井慧理子 永井 慧理子、ながい えりこ、Nagai Eriko 女 洲崎綾 8 小仓郁也","date":"2016-01-15","objectID":"/anime/ajin/:2:0","tags":null,"title":"亚人","uri":"/anime/ajin/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 亚人 2016-01-15 13 樱花 2 亚人 OAD 2016-05-06 3 樱花 3 亚人 第二季 2016-10-07 13 樱花 ","date":"2016-01-15","objectID":"/anime/ajin/:3:0","tags":null,"title":"亚人","uri":"/anime/ajin/"},{"categories":null,"content":"题目 给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。 请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。 你必须找到一个内存复杂度优于 O(n^2) 的解决方案。 示例 1： 输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\r输出：13\r解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13\r示例 2： 输入：matrix = [[-5]], k = 1\r输出：-5\r提示： n == matrix.length n == ","date":"2016-01-13","objectID":"/leetcode/0378/:1:0","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★★★）","uri":"/leetcode/0378/"},{"categories":null,"content":"分析 ","date":"2016-01-13","objectID":"/leetcode/0378/:2:0","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★★★）","uri":"/leetcode/0378/"},{"categories":null,"content":"#1 每一行都是升序列表。问题等价于归并排序矩阵的 n 行，取第 k 项，可以用堆实现。 def kthSmallest(self, matrix: List[List[int]], k: int) -\u003e int: n = len(matrix) pq = [(matrix[i][0], i, 0) for i in range(min(n, k))] for _ in range(k-1): _, i, j = heappop(pq) if j+1 \u003c n: heappush(pq, (matrix[i][j+1], i, j+1)) return heappop(pq)[0] 时间复杂度 ","date":"2016-01-13","objectID":"/leetcode/0378/:2:1","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★★★）","uri":"/leetcode/0378/"},{"categories":null,"content":"#2 还有个巧妙的二分查找方法。 以最终答案 x 为界 若 y\u003cx，那么矩阵中小于等于 y 的元素小于 k个 若 y\u003e=x，矩阵中小于等于 y 的元素大于等于 k个 令 check(x) 代表矩阵中小于等于 x 的元素是否大于等于 k 个， 二分查找第一个满足 check(x) 为真的 x 即可 具体求 check(x)，每一行二分查找 x 的位置即可 ","date":"2016-01-13","objectID":"/leetcode/0378/:2:2","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★★★）","uri":"/leetcode/0378/"},{"categories":null,"content":"解答 def kthSmallest(self, matrix: List[List[int]], k: int) -\u003e int: def check(x): return sum(bisect_right(row, x) for row in matrix) \u003e= k self.__class__.__getitem__ = lambda self, i: check(i-10**9) return bisect_left(self, True, 0, 2*10**9)-10**9 时间复杂度 $O(N * logN * logS)$，44 ms ","date":"2016-01-13","objectID":"/leetcode/0378/:3:0","tags":null,"title":"0378：有序矩阵中第 K 小的元素（★★★）","uri":"/leetcode/0378/"},{"categories":null,"content":"　　热爱游戏的家里蹲少年·佐藤和真的人生，因交通事故（!?）而轻易闭幕……本该是这样，但当他醒来之时，眼前有一位自称是女神的美少女。“喂，我有点好事要告诉你。要去异世界吗？只带一样你喜欢的东西没问题喔。”“那，我就带着你好了。”由此开始，在异世界转生的和真的魔王讨伐大冒险开始了……虽然是这么想的，但他却为了获得衣食住行而开始劳动！想要平稳度日的和真，却由于女神引起的各种问题，而终于被魔王军盯上了!? ","date":"2016-01-13","objectID":"/anime/konosuba/","tags":null,"title":"为美好的世界献上祝福！","uri":"/anime/konosuba/"},{"categories":null,"content":"简介 热爱游戏的家里蹲少年·佐藤和真的人生，因交通事故（!?）而轻易闭幕……本该是这样，但当他醒来之时，眼前有一位自称是女神的美少女。“喂，我有点好事要告诉你。要去异世界吗？只带一样你喜欢的东西没问题喔。”“那，我就带着你好了。”由此开始，在异世界转生的和真的魔王讨伐大冒险开始了……虽然是这么想的，但他却为了获得衣食住行而开始劳动！想要平稳度日的和真，却由于女神引起的各种问题，而终于被魔王军盯上了!? 制作人员： 原作：晓夏目 导演：金崎贵臣 脚本：朱白葵、中村浩二郎、上江洲诚 分镜：稻垣隆行、齐藤哲人、伊势昌弘 ","date":"2016-01-13","objectID":"/anime/konosuba/:1:0","tags":null,"title":"为美好的世界献上祝福！","uri":"/anime/konosuba/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐藤和真 佐藤 和真、サトウ カズマ、Satou Kazuma 男 福島潤 2 阿克娅 阿库娅、Aqua、アクア、Akua、茶包 女 雨宮天 3 惠惠 めぐみん、Megumin 女 高橋李依 4 达克妮斯 达斯堤尼斯·福特·拉拉蒂娜、Raratina Dustiness Ford、ダスティネス・フォード・ララティーナ、Dukunesu 女 茅野愛衣 5 厄里斯 Eris、エリス、Erisu 女 諏訪彩花 6 露娜 Luna、Runa 女 原紗友里 7 贝尔迪亚 Beldia、Berudia 男 安元洋貴 8 克莉丝 Chris、クリス、Kurisu 女 諏訪","date":"2016-01-13","objectID":"/anime/konosuba/:2:0","tags":null,"title":"为美好的世界献上祝福！","uri":"/anime/konosuba/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 为美好的世界献上祝福！ 2016-01-13 10 樱花 2 为美好的世界献上祝福！ 第二季 2017-01-11 10 樱花 3 电影 为美好的世界献上祝福！红传说 2019-08-30 1 樱花 ","date":"2016-01-13","objectID":"/anime/konosuba/:3:0","tags":null,"title":"为美好的世界献上祝福！","uri":"/anime/konosuba/"},{"categories":null,"content":"题目 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。 请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 示例 1： 输入：nums = [1,2,3], target = 4\r输出：7\r解释：\r所有可能的组合为：\r(1, 1, 1, 1)\r(1, 1, 2)\r(1, 2, 1)\r(1, 3)\r(2, 1, 1)\r(2, 2)\r(3, 1)\r请注意，顺序不同的序列被视作不同的组合。\r示例 2： 输入：nums = [9], target = 3\r输出：0\r提示： 1 \u003c= nums.length \u003c=","date":"2016-01-12","objectID":"/leetcode/0377/:1:0","tags":null,"title":"0377：组合总和 Ⅳ（★★）","uri":"/leetcode/0377/"},{"categories":null,"content":"分析 典型的线性 dp，按最后一个数即可递归。 ","date":"2016-01-12","objectID":"/leetcode/0377/:2:0","tags":null,"title":"0377：组合总和 Ⅳ（★★）","uri":"/leetcode/0377/"},{"categories":null,"content":"解答 def combinationSum4(self, nums: List[int], target: int) -\u003e int: dp = [1] * (target+1) for i in range(1, target+1): dp[i] = sum(dp[i-x] for x in nums if x\u003c=i) return dp[-1] 44 ms ","date":"2016-01-12","objectID":"/leetcode/0377/:3:0","tags":null,"title":"0377：组合总和 Ⅳ（★★）","uri":"/leetcode/0377/"},{"categories":null,"content":"题目 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。 第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数， 第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。 给你一个整数数组 nums","date":"2016-01-11","objectID":"/leetcode/0376/:1:0","tags":null,"title":"0376：摆动序列（★★）","uri":"/leetcode/0376/"},{"categories":null,"content":"分析 ","date":"2016-01-11","objectID":"/leetcode/0376/:2:0","tags":null,"title":"0376：摆动序列（★★）","uri":"/leetcode/0376/"},{"categories":null,"content":"#1 观察发现可以递推。 令 dp[i][0]、dp[i][1] 分别代表以位置 i 结尾且最后一个差值为 正/负 的最长摆动序列长度， 即可递推。 def wiggleMaxLength(self, nums: List[int]) -\u003e int: n = len(nums) dp = [[1, 1] for _ in range(n)] for i in range(1, n): dp[i][0] = 1 + max([dp[j][1] for j in range(i) if nums[j]\u003cnums[i]], default=0) dp[i][1] = 1 + max([dp[j][0","date":"2016-01-11","objectID":"/leetcode/0376/:2:1","tags":null,"title":"0376：摆动序列（★★）","uri":"/leetcode/0376/"},{"categories":null,"content":"#2 还有个巧妙的贪心方法： 显然相邻重复的点只留一个即可，其它可以忽略 假设存在 nums[i-1]\u003cnums[i]\u003cnums[i+1] 任意包含 nums[i] 的摆动序列都可以将 nums[i] 替换为 nums[i-1] 或 nums[i+1]， 依然是摆动序列 所以可以忽略掉这样的 nums[i] 同理，当 nums[i-1]\u003enums[i]\u003enums[i+1] 时，也可以忽略掉 nums[i] 因此只需要考虑波峰/谷的点，其它点都可以忽略掉 而所有波峰/谷的点组成的显然是摆动序列，即为所求 具体判断波峰/谷时，只要该点与前后点的差的正负性一致，即为波峰/谷。 注意首尾也是波峰/谷。","date":"2016-01-11","objectID":"/leetcode/0376/:2:2","tags":null,"title":"0376：摆动序列（★★）","uri":"/leetcode/0376/"},{"categories":null,"content":"解答 def wiggleMaxLength(self, nums: List[int]) -\u003e int: A = [a for a,_ in groupby(nums)] n = len(A) return sum(i in [0, n-1] or (A[i]-A[i-1])*(A[i]-A[i+1])\u003e0 for i in range(n)) 时间复杂度 O(N)，36 ms ","date":"2016-01-11","objectID":"/leetcode/0376/:3:0","tags":null,"title":"0376：摆动序列（★★）","uri":"/leetcode/0376/"},{"categories":null,"content":"被垃圾堆里的奇妙生物说了“你有魔法少女的素质”的柚香。\n变身成魔法少女的她，衣服竟然是泳装！？而且也没有什么敌人，不去帮助别人、不去收集道具也无所谓！？\n漫无目的的魔法少女生活开始了……。","date":"2016-01-11","objectID":"/anime/mahou_shoujo_nante/","tags":null,"title":"魔法少女什么的已经够了啦。","uri":"/anime/mahou_shoujo_nante/"},{"categories":null,"content":"简介 被垃圾堆里的奇妙生物说了“你有魔法少女的素质”的柚香。 变身成魔法少女的她，衣服竟然是泳装！？而且也没有什么敌人，不去帮助别人、不去收集道具也无所谓！？ 漫无目的的魔法少女生活开始了……。 制作人员： 原作：双见醉 导演：米田和弘 脚本：村上桃子、笔安一幸 音乐：中山真斗 人物设定：岛田和晃 ","date":"2016-01-11","objectID":"/anime/mahou_shoujo_nante/:1:0","tags":null,"title":"魔法少女什么的已经够了啦。","uri":"/anime/mahou_shoujo_nante/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 叶波柚香 葉波 ゆずか、はなみ ゆずか、Hanami Yuzuka 女 藤田茜 2 米咚 Miton 若井友希 3 坂上千叶 坂上 ちや、さかがみ ちや、Sakagami Chiya 女 大森日雅 4 黛雅 Daiya 女 田中美海 5 篠木真冬 篠木 真冬、しのぎ まふゆ、Shinogi Mafuyu 女 伊藤美来 6 波奇 Pochi 西明日香 7 柚香的父亲 ゆずかの父 男 諏訪部順一 8 美代子 Miyoko 女 斎藤千和 ","date":"2016-01-11","objectID":"/anime/mahou_shoujo_nante/:2:0","tags":null,"title":"魔法少女什么的已经够了啦。","uri":"/anime/mahou_shoujo_nante/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔法少女什么的已经够了啦。 2016-01-11 12 bilibili 2 魔法少女什么的已经够了啦。第二季 2016-10-05 12 bilibili ","date":"2016-01-11","objectID":"/anime/mahou_shoujo_nante/:3:0","tags":null,"title":"魔法少女什么的已经够了啦。","uri":"/anime/mahou_shoujo_nante/"},{"categories":null,"content":"题目 我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字。 你来猜我选了哪个数字。 如果你猜到正确的数字，就会 赢得游戏 。 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。 示例 1： 输入：n = 10\r输出：16\r解释：制胜策略如下：\r- 数字范围是 [1,10] 。你先猜测数字为 7 。\r- 如果这是我选中的数字，你的总费用为 $0 。否则","date":"2016-01-10","objectID":"/leetcode/0375/:1:0","tags":null,"title":"0375：猜数字大小 II（★★）","uri":"/leetcode/0375/"},{"categories":null,"content":"分析 典型的区间 dp，按一开始猜的数字即可递归。 令 dp[i][j] 代表在 [i, j] 玩游戏的最小必胜现金： 选 x 时，最坏情况下要支付 x+max(dp[i][x-1], dp[x+1][n]) 遍历 x，取最小的必胜值即可 ","date":"2016-01-10","objectID":"/leetcode/0375/:2:0","tags":null,"title":"0375：猜数字大小 II（★★）","uri":"/leetcode/0375/"},{"categories":null,"content":"解答 def getMoneyAmount(self, n: int) -\u003e int: dp = [[0]*(n+2) for _ in range(n+2)] for i in range(n, 0, -1): for j in range(i+1, n+1): dp[i][j] = min(x+max(dp[i][x-1], dp[x+1][j]) for x in range(i, j+1)) return dp[1][n] 时间复杂度 O(N^3)，1536 ms ","date":"2016-01-10","objectID":"/leetcode/0375/:3:0","tags":null,"title":"0375：猜数字大小 II（★★）","uri":"/leetcode/0375/"},{"categories":null,"content":"我们为什么要这么做……？\n\n哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方是哪里。\n\n他的身边有一群和他一样失去记忆，只记得自己名字的男女；而离开了地底后，等待着众人的是一个「宛如游戏」的世界。\n\n为求生存，哈尔希洛与自己有着相同境遇的伙伴们组成队伍、学习技能，以义勇兵见习者的身份踏入了这个世界--「格林姆迦尔」。\n\n没有人知道未来会遇见什么……这一切，就是从灰烬之中所诞生的冒险谭。 ","date":"2016-01-10","objectID":"/anime/grimgar_of_fantasy_and_ash/","tags":null,"title":"灰与幻想的格林姆迦尔","uri":"/anime/grimgar_of_fantasy_and_ash/"},{"categories":null,"content":"简介 我们为什么要这么做……？ 哈尔希洛回过神来，才发现自己身处在黑暗当中，他完全不知道自己人在何处，也不明白这个地方是哪里。 他的身边有一群和他一样失去记忆，只记得自己名字的男女；而离开了地底后，等待着众人的是一个「宛如游戏」的世界。 为求生存，哈尔希洛与自己有着相同境遇的伙伴们组成队伍、学习技能，以义勇兵见习者的身份踏入了这个世界–「格林姆迦尔」。 没有人知道未来会遇见什么……这一切，就是从灰烬之中所诞生的冒险谭。 制作人员： 原作：十文字青 导演：中村亮介 分镜：仁贺绿朗、角铜博之、玄马宣彦、工藤进、川村贤一、飞田刚 ","date":"2016-01-10","objectID":"/anime/grimgar_of_fantasy_and_ash/:1:0","tags":null,"title":"灰与幻想的格林姆迦尔","uri":"/anime/grimgar_of_fantasy_and_ash/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哈尔希洛 Haruhiro 男 細谷佳正 2 梦儿 Yume 女 小松未可子 3 席赫露 Shihoru 女 照井春佳 4 蓝德 Ranta 男 吉野裕行 5 梅莉 女 安済知佳 6 莫古索 Mogzo 男 落合福嗣 7 马纳多 Manato 男 島﨑信長 8 莲崎 Renji 男 関智一 ","date":"2016-01-10","objectID":"/anime/grimgar_of_fantasy_and_ash/:2:0","tags":null,"title":"灰与幻想的格林姆迦尔","uri":"/anime/grimgar_of_fantasy_and_ash/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 灰与幻想的格林姆迦尔 2016-01-10 12 bilibili ","date":"2016-01-10","objectID":"/anime/grimgar_of_fantasy_and_ash/:3:0","tags":null,"title":"灰与幻想的格林姆迦尔","uri":"/anime/grimgar_of_fantasy_and_ash/"},{"categories":null,"content":"题目 猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果， 返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick \u003c num 1：我选出的数字比你猜的数字大 pick \u003e num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。 示例 1： 输入：n = 10, pick = 6\r输出：6\r示例 2：","date":"2016-01-09","objectID":"/leetcode/0374/:1:0","tags":null,"title":"0374：猜数字大小","uri":"/leetcode/0374/"},{"categories":null,"content":"分析 典型的二分查找。 ","date":"2016-01-09","objectID":"/leetcode/0374/:2:0","tags":null,"title":"0374：猜数字大小","uri":"/leetcode/0374/"},{"categories":null,"content":"解答 def guessNumber(self, n: int) -\u003e int: self.__class__.__getitem__ = lambda self, i: guess(i)\u003c=0 return bisect_left(self, True, 1, n) 28 ms ","date":"2016-01-09","objectID":"/leetcode/0374/:3:0","tags":null,"title":"0374：猜数字大小","uri":"/leetcode/0374/"},{"categories":null,"content":"题目 给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。 找到和最小的 k 对数字 (u1,v1), (u2,v2) … (uk,vk)。 示例 1: 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 输出: [1,2],[1,4],[1,6] 解释: 返回序列中的前 3 对数： [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] 示例 2: 输入: nums1 = [1,1,2]","date":"2016-01-08","objectID":"/leetcode/0373/:1:0","tags":null,"title":"0373：查找和最小的 K 对数字（★★）","uri":"/leetcode/0373/"},{"categories":null,"content":"分析 有个巧妙的想法。令 A[i][j] 代表 nums1[i]+nums2[j]，每一行都是升序列表。 问题等价于归并排序 A 的前 k 行，取前 k 项，可以用堆实现。 具体实现时，不需要真的构造出 A，归并时根据下标计算值即可。 ","date":"2016-01-08","objectID":"/leetcode/0373/:2:0","tags":null,"title":"0373：查找和最小的 K 对数字（★★）","uri":"/leetcode/0373/"},{"categories":null,"content":"解答 def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -\u003e List[List[int]]: m, n = len(nums1), len(nums2) res, A = [], [(nums1[i]+nums2[0], i, 0) for i in range(min(m, k))] for _ in range(min(m * n, k)): _, i, j = heappop(A) res.append([nums1[i], nums2[j]]) if j \u003c n - 1: heappush(A, ","date":"2016-01-08","objectID":"/leetcode/0373/:3:0","tags":null,"title":"0373：查找和最小的 K 对数字（★★）","uri":"/leetcode/0373/"},{"categories":null,"content":"外表不管哪里不管怎么看都是金发辣妹，实际却是纯情女生。以有着辣妹外表和直率温柔的内心这种反差萌的辣妹子为中心，戴着眼镜小巧玲珑的宅子，以及举止文雅天真烂漫的大小姐，三个人在各种场所展开女生会话的日常喜剧。","date":"2016-01-08","objectID":"/anime/galko_chan/","tags":null,"title":"告诉我！辣妹子酱","uri":"/anime/galko_chan/"},{"categories":null,"content":"简介 外表不管哪里不管怎么看都是金发辣妹，实际却是纯情女生。以有着辣妹外表和直率温柔的内心这种反差萌的辣妹子为中心，戴着眼镜小巧玲珑的宅子，以及举止文雅天真烂漫的大小姐，三个人在各种场所展开女生会话的日常喜剧。 制作人员： 原作：铃木健也 导演：川口敬一郎 演出：藤井隆文、新田义方、松下周平、冈村正弘、关大 ","date":"2016-01-08","objectID":"/anime/galko_chan/:1:0","tags":null,"title":"告诉我！辣妹子酱","uri":"/anime/galko_chan/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 辣妹子 女 和氣あず未 2 宅子 女 富田美憂 3 大小姐 女 髙橋ミナミ 4 轻薄男 男 櫻井孝宏 5 运动男 男 小野大輔 6 宅男 男 松岡禎丞 7 阿部先 男 中村悠一 8 超嗨美 女 石上静香 ","date":"2016-01-08","objectID":"/anime/galko_chan/:2:0","tags":null,"title":"告诉我！辣妹子酱","uri":"/anime/galko_chan/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 告诉我！辣妹子酱 2016-01-08 12 樱花 ","date":"2016-01-08","objectID":"/anime/galko_chan/:3:0","tags":null,"title":"告诉我！辣妹子酱","uri":"/anime/galko_chan/"},{"categories":null,"content":"无法忘记在刑务所的落语慰问会中见到的大名人·八云的“死神”，出狱的与太郎径直前往寄席。拜倒在八云面前，成为他住所雇工以及弟子的与太郎，却发现在八云之处住着一位名叫小夏的女性。八云与小夏似乎有着他人无从触及的因缘……。","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":"简介 无法忘记在刑务所的落语慰问会中见到的大名人·八云的“死神”，出狱的与太郎径直前往寄席。拜倒在八云面前，成为他住所雇工以及弟子的与太郎，却发现在八云之处住着一位名叫小夏的女性。八云与小夏似乎有着他人无从触及的因缘……。 制作人员： 原作：云田晴子 导演：小俣真一 脚本：中西泰大、熊谷纯、待田堂子、柿原优子 分镜：园田雅裕、阿部达也 ","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/:1:0","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 三代目有乐亭助六 九代目有乐亭八云、九代目有楽亭八雲、強次、よたろう、与太郎、三代目有楽亭助六、さんだいめ ゆうらくてい すけろく、与太 男 関智一 2 八代目有乐亭八云 八云、菊比古、きくひこ、八代目有楽亭八雲、やくも、yakumo 男 石田彰 3 小夏 小夏、こなつ、konatsu 女 小林ゆう 4 二代目有乐亭助六 助六、信さん、はつたろう、初太郎、二代目有楽亭助六、にだいめ ゆうらくてい すけろく 男 山寺宏一 5 美代吉 ユリエ、みよ吉、みよきち、miyokichi 女 林原めぐみ 6 黑道大哥 男 加瀬康之 7 お栄 おえい 女 斎藤恵理 8 四","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/:2:0","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 昭和元禄落语心中 2016-01-08 13 樱花 2 昭和元禄落语心中 -助六再临篇- 2017-01-06 12 樱花 ","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/:3:0","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":"MAD ","date":"2016-01-08","objectID":"/anime/rakugo_shinjuu/:4:0","tags":null,"title":"昭和元禄落语心中","uri":"/anime/rakugo_shinjuu/"},{"categories":null,"content":"题目 你的任务是计算 a^b 对 1337 取模，a 是一个正整数， b 是一个非常大的正整数且会以数组形式给出。 示例 1： 输入：a = 2, b = [3]\r输出：8\r示例 2： 输入：a = 2, b = [1,0]\r输出：1024\r示例 3： 输入：a = 1, b = [4,3,3,8,5,2]\r输出：1\r示例 4： 输入：a = 2147483647, b = [2,0,0]\r输出：1198\r提示： 1 \u003c= a \u003c= 2^31 - 1 1 \u003c= b.length \u003c= 2000 0 \u003c= b[i] \u003c= 9 b 不含前导 0 ","date":"2016-01-07","objectID":"/leetcode/0372/:1:0","tags":null,"title":"0372：超级次方（★★）","uri":"/leetcode/0372/"},{"categories":null,"content":"分析 可以递推。令 dp[i] 代表 $a^{n_i}，n_i$ 是 b[:i+1] 对应的数，那么： $$ dp[i]=a^{n_i}=a^{n_{i-1}*10+b[i]} = (a^{n_{i-1}})^{10}*a^{b[i]} =dp[i-1]^{10}*a^{b[i]}$$ 再注意取模即可。 ","date":"2016-01-07","objectID":"/leetcode/0372/:2:0","tags":null,"title":"0372：超级次方（★★）","uri":"/leetcode/0372/"},{"categories":null,"content":"解答 def superPow(self, a: int, b: List[int]) -\u003e int: dp, mod = 1, 1337 for x in b: dp = pow(dp, 10, 1337)*pow(a, x, 1337)%mod return dp 100 ms ","date":"2016-01-07","objectID":"/leetcode/0372/:3:0","tags":null,"title":"0372：超级次方（★★）","uri":"/leetcode/0372/"},{"categories":null,"content":"　　藤沼悟是一个三流漫画家，但是他却拥有着名为“再上映”（可以穿越到事件发生之前的时间点，阻止事件发生，但失败了会一直重复）的能力。某天，当回到家里的时候他发现了自己母亲遇害的一幕，并且自己被嫁祸为杀人凶手。就在这时候，由于再上映的关系，他突然回到了18年前·小学五年级的时候，而这一刻他不但要拯救母亲，也要为了同学的安全而战……","date":"2016-01-07","objectID":"/anime/erased/","tags":null,"title":"只有我不存在的城市","uri":"/anime/erased/"},{"categories":null,"content":"简介 藤沼悟是一个三流漫画家，但是他却拥有着名为“再上映”（可以穿越到事件发生之前的时间点，阻止事件发生，但失败了会一直重复）的能力。某天，当回到家里的时候他发现了自己母亲遇害的一幕，并且自己被嫁祸为杀人凶手。就在这时候，由于再上映的关系，他突然回到了18年前·小学五年级的时候，而这一刻他不但要拯救母亲，也要为了同学的安全而战…… 制作人员： 原作：三部敬 导演：伊藤智彦 脚本：安永丰、岸本卓 分镜：江崎慎平、绵田慎也、平川哲生、こさや ","date":"2016-01-07","objectID":"/anime/erased/:1:0","tags":null,"title":"只有我不存在的城市","uri":"/anime/erased/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤沼悟 ふじぬま さとる、Fujinuma Satoru、藤沼 悟 男 満島真之介 2 雏月加代 雛月 加代、ひなづき かよ、Hinazuki Kayo 女 悠木碧 3 片桐爱梨 片桐 愛梨、かたぎり あいり、Katagiri Airi 女 赤﨑千夏 4 藤沼佐知子 藤沼 佐知子、ふじぬま さちこ、Fujinuma Sachiko 女 高山みなみ 5 小林贤也 ケンヤ、小林 賢也、こばやし けんや、Kobayashi Kenya 男 大地葉 6 杉田广美 杉田 広美、すぎた ひろみ、Sugita Hiromi、ヒロミ 男 田丸篤志 7 和 カズ、Kazu 男","date":"2016-01-07","objectID":"/anime/erased/:2:0","tags":null,"title":"只有我不存在的城市","uri":"/anime/erased/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 只有我不存在的城市 2016-01-07 12 bilibili ","date":"2016-01-07","objectID":"/anime/erased/:3:0","tags":null,"title":"只有我不存在的城市","uri":"/anime/erased/"},{"categories":null,"content":"题目 给你两个整数 a 和 b ，不使用 运算符 + 和 - ，计算并返回两整数之和。 示例 1： 输入：a = 1, b = 2\r输出：3\r示例 2： 输入：a = 2, b = 3\r输出：5\r提示： 1000 \u003c= a, b \u003c= 1000 ","date":"2016-01-06","objectID":"/leetcode/0371/:1:0","tags":null,"title":"0371：两整数之和（★★）","uri":"/leetcode/0371/"},{"categories":null,"content":"分析 可以用位运算来解决，但 python 处理本题的负数较为麻烦，所以直接调库。 def getSum(self, a: int, b: int) -\u003e int: return sum([a,b]) 40 ms ","date":"2016-01-06","objectID":"/leetcode/0371/:2:0","tags":null,"title":"0371：两整数之和（★★）","uri":"/leetcode/0371/"},{"categories":null,"content":"题目 给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ， 子集中每一元素对 (answer[i], answer[j]) 都应当满足： answer[i] % answer[j] == 0 ，或 answer[j] % answer[i] == 0 如果存在多个有效解子集，返回其中任何一个均可。 示例 1： 输入：nums = [1,2,3]\r输出：[1,2]\r解释：[1,3] 也会被视为正确答案。\r示例 2： 输入：nums = [1,2,4,8]\r输出：[1,2,4,8]\r提示： 1 \u003c= nums.length \u003c= 1000 1 \u003c= ","date":"2016-01-03","objectID":"/leetcode/0368/:1:0","tags":null,"title":"0368：最大整除子集（★★★）","uri":"/leetcode/0368/"},{"categories":null,"content":"分析 典型的子序列 dp。先将 nums 排序后得到数组 A。 令 dp[i] 代表以 A[i] 结尾的最大整除子集的长度， 按整除子集的倒数第二个数的位置即可递推。 本题要求给出一个最大整除子集，考虑从递推的路径反推： 先找到终点，即是 max(dp) 的位置 i 当 A[i]%A[j]==0 且 dp[j]==dp[i]-1，那么可以经过 j 得到最长路径 依此类推，当 dp[i]==1 时，即得到一条最长路径 ","date":"2016-01-03","objectID":"/leetcode/0368/:2:0","tags":null,"title":"0368：最大整除子集（★★★）","uri":"/leetcode/0368/"},{"categories":null,"content":"解答 def largestDivisibleSubset(self, nums: List[int]) -\u003e List[int]: A, n = sorted(nums), len(nums) dp = [1]*n for i in range(n): dp[i] = 1+max([dp[j] for j in range(i) if A[i]%A[j]==0], default=0) i = dp.index(max(dp)) res = [A[i]] while dp[i] != 1: for j in range(i): if dp[j]==dp[i]-1 and A[i]%A[j]=","date":"2016-01-03","objectID":"/leetcode/0368/:3:0","tags":null,"title":"0368：最大整除子集（★★★）","uri":"/leetcode/0368/"},{"categories":null,"content":"题目 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。 进阶：不要 使用任何内置的库函数，如 sqrt 。 示例 1： 输入：num = 16\r输出：true\r示例 2： 输入：num = 14\r输出：false\r提示： 1 \u003c= num \u003c= 2^31 - 1 ","date":"2016-01-02","objectID":"/leetcode/0367/:1:0","tags":null,"title":"0367：有效的完全平方数（★）","uri":"/leetcode/0367/"},{"categories":null,"content":"分析 0069 升级版，找到平方根取整后，判断其平方是否等于 num 即可。 找平方根可以用二分查找，也可以用牛顿迭代法。 ","date":"2016-01-02","objectID":"/leetcode/0367/:2:0","tags":null,"title":"0367：有效的完全平方数（★）","uri":"/leetcode/0367/"},{"categories":null,"content":"解答 def isPerfectSquare(self, num: int) -\u003e bool: i = num while i * i \u003e num: i = (i+num//i) // 2 return i * i == num 32 ms ","date":"2016-01-02","objectID":"/leetcode/0367/:3:0","tags":null,"title":"0367：有效的完全平方数（★）","uri":"/leetcode/0367/"},{"categories":null,"content":"故事发生在当代的人间江南小镇和神界。 \n\n门神神荼和郁垒是两兄弟。因为近年人间不再关注神仙，神界经济萧条，门神、土地爷、八仙等等小神们面临下岗失业的危险。门神郁垒决定去人间，做一番惊天动地的事情，证明门神的价值。郁垒和神荼先后来到人间，遇到了小镇上的单亲母女小英和雨儿，之后发生了一系列意想不到的有趣惊险故事……","date":"2016-01-01","objectID":"/anime/little_door_gods/","tags":null,"title":"小门神","uri":"/anime/little_door_gods/"},{"categories":null,"content":"简介 故事发生在当代的人间江南小镇和神界。 门神神荼和郁垒是两兄弟。因为近年人间不再关注神仙，神界经济萧条，门神、土地爷、八仙等等小神们面临下岗失业的危险。门神郁垒决定去人间，做一番惊天动地的事情，证明门神的价值。郁垒和神荼先后来到人间，遇到了小镇上的单亲母女小英和雨儿，之后发生了一系列意想不到的有趣惊险故事…… 制作人员： 导演：王微 剪辑：赵霁 製作：追光人动画设计（北京）有限公司 配音监督：陈家恒 ","date":"2016-01-01","objectID":"/anime/little_door_gods/:1:0","tags":null,"title":"小门神","uri":"/anime/little_door_gods/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 小门神 2016-01-01 1 樱花 ","date":"2016-01-01","objectID":"/anime/little_door_gods/:2:0","tags":null,"title":"小门神","uri":"/anime/little_door_gods/"},{"categories":null,"content":"题目 有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。 确定是否有可能使用这两个壶准确得到 targetCapacity 升。 如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。 你可以： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: 输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4\r输出: true\r解释：来自著名的 \"Die Hard\"\r示例 ","date":"2015-12-31","objectID":"/leetcode/0365/:1:0","tags":null,"title":"0365：水壶问题（★★）","uri":"/leetcode/0365/"},{"categories":null,"content":"分析 注意到有效的操作对应的容量变化只能是 ±x、±y、0： 有效的 z 必然能表示为 ax+by（a、b为整数） 反过来，若 z 能表示为 ax+by（a、b为整数），且 z\u003c=x+y，可以构造出方案得到 z 根据 裴蜀定理，z 能表示为 ax+by（a、b为整数） 等价于 z 是 a、b 的最大公约数的倍数 因此满足 z\u003c=x+y 且 z%gcd(x,y)==0 即可 ","date":"2015-12-31","objectID":"/leetcode/0365/:2:0","tags":null,"title":"0365：水壶问题（★★）","uri":"/leetcode/0365/"},{"categories":null,"content":"解答 def canMeasureWater(self, x: int, y: int, z: int) -\u003e bool: return z\u003c=x+y and z%gcd(x,y)==0 28 ms ","date":"2015-12-31","objectID":"/leetcode/0365/:3:0","tags":null,"title":"0365：水壶问题（★★）","uri":"/leetcode/0365/"},{"categories":null,"content":"题目 给你一个 m x n 的矩阵 matrix 和一个整数 k ， 找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。 题目数据保证总会存在一个数值和不超过 k 的矩形区域。 示例 1： 输入：matrix = [[1,0,1],[0,-2,3]], k = 2\r输出：2\r解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，\r且 2 是不超过 k 的最大数字（k = 2）。\r示例 2： 输入：matrix = [[2,2,-1]], k = 3\r输出：3\r提示： m == matrix.length n == matrix[i].length 1 \u003c= m","date":"2015-12-29","objectID":"/leetcode/0363/:1:0","tags":null,"title":"0363：矩形区域不超过 K 的最大数值和（★★★）","uri":"/leetcode/0363/"},{"categories":null,"content":"分析 矩形区域的个数是 $O(M^2N^2)$ 级别，光遍历就会超时了。因此要考虑不完全遍历的方法： 左右边界固定为 \u003cy1,y2\u003e 时，求出每一行 [y1,y2] 的区间和，得到数组 A 问题转为求 A 中不超过 k 的最大区间和，可以用前缀和+有序集合解决 预先保存每一行的前缀和，即可快速求出每一行 [y1,y2] 的区间和 ","date":"2015-12-29","objectID":"/leetcode/0363/:2:0","tags":null,"title":"0363：矩形区域不超过 K 的最大数值和（★★★）","uri":"/leetcode/0363/"},{"categories":null,"content":"解答 def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -\u003e int: from sortedcontainers import SortedList res, m, n = float('-inf'), len(matrix), len(matrix[0]) P = [list(accumulate([0]+row)) for row in matrix] for y1 in range(n): for y2 in range(y1, n): A = [row[y2+1]-row[y1] for row in P] sl =","date":"2015-12-29","objectID":"/leetcode/0363/:3:0","tags":null,"title":"0363：矩形区域不超过 K 的最大数值和（★★★）","uri":"/leetcode/0363/"},{"categories":null,"content":"题目 给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 \u003c= x \u003c 10^n 。 示例 1： 输入：n = 2\r输出：91\r解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x \u003c 100 范围内的所有数字。 示例 2： 输入：n = 0\r输出：1\r提示： 0 \u003c= n \u003c= 8 ","date":"2015-12-23","objectID":"/leetcode/0357/:1:0","tags":null,"title":"0357：计算各个位数不同的数字个数（★★）","uri":"/leetcode/0357/"},{"categories":null,"content":"分析 根据数学知识： [1, 9] 的对应个数：9 [10, 99] 的对应个数：9*9 [100, 999] 的对应个数：998 一般性的，[10^k, 10^(k+1)-1] 的对应个数为 9*perm(9, k)。 因此可以分段计算 [0, 10^n-1] 的对应个数。甚至可以直接打表。 ","date":"2015-12-23","objectID":"/leetcode/0357/:2:0","tags":null,"title":"0357：计算各个位数不同的数字个数（★★）","uri":"/leetcode/0357/"},{"categories":null,"content":"解答 def countNumbersWithUniqueDigits(self, n: int) -\u003e int: return 1+9*sum(perm(9, k) for k in range(n)) 36 ms ","date":"2015-12-23","objectID":"/leetcode/0357/:3:0","tags":null,"title":"0357：计算各个位数不同的数字个数（★★）","uri":"/leetcode/0357/"},{"categories":null,"content":"题目 设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户， 能够看见关注人（包括自己）的最近 10 条推文。 实现 Twitter 类： Twitter() 初始化简易版推特对象 void postTweet(int userId, int tweetId) 根据给定的 tweetId 和 userId 创建一条新推文。 每次调用此函数都会使用一个不同的 tweetId 。 List getNewsFeed(int userId) 检索当前用户新闻推送中最近 10 条推文的 ID 。 新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须","date":"2015-12-21","objectID":"/leetcode/0355/:1:0","tags":null,"title":"0355：设计推特（★★）","uri":"/leetcode/0355/"},{"categories":null,"content":"分析 维护一个时间变量 t，记录每个用户发过的推文及时间，记录每个用户的关注列表，检索时将相关的推文合并排序即可。 ","date":"2015-12-21","objectID":"/leetcode/0355/:2:0","tags":null,"title":"0355：设计推特（★★）","uri":"/leetcode/0355/"},{"categories":null,"content":"解答 class Twitter: def __init__(self): self.t = 0 self.tw = defaultdict(list) self.fo = defaultdict(set) def postTweet(self, userId: int, tweetId: int) -\u003e None: self.tw[userId].append((tweetId, self.t)) self.t += 1 def getNewsFeed(self, userId: int) -\u003e List[int]: news = {tid: t for uid in (self.fo[us","date":"2015-12-21","objectID":"/leetcode/0355/:3:0","tags":null,"title":"0355：设计推特（★★）","uri":"/leetcode/0355/"},{"categories":null,"content":"题目 给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 注意：不允许旋转信封。 示例 1： 输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]\r输出：3\r解释：最多信封的个数为 3, 组合为: [2,3] =\u003e [5,4] =\u003e [6,7]。\r示例 2： 输入：envelopes = [","date":"2015-12-20","objectID":"/leetcode/0354/:1:0","tags":null,"title":"0354：俄罗斯套娃信封问题（★★★）","uri":"/leetcode/0354/"},{"categories":null,"content":"分析 将信封按宽度排序： 如果宽度各不相同，等价于在高度序列中找最长递增子序列，即是问题 0300 若存在宽度相同的信封，按高度反序排列，就依然等价 ","date":"2015-12-20","objectID":"/leetcode/0354/:2:0","tags":null,"title":"0354：俄罗斯套娃信封问题（★★★）","uri":"/leetcode/0354/"},{"categories":null,"content":"解答 def maxEnvelopes(self, envelopes: List[List[int]]) -\u003e int: A = [] for _, h in sorted(envelopes, key=lambda x: [x[0], -x[1]]): j = bisect_left(A, h) A[j:j + 1] = [h] return len(A) 56 ms ","date":"2015-12-20","objectID":"/leetcode/0354/:3:0","tags":null,"title":"0354：俄罗斯套娃信封问题（★★★）","uri":"/leetcode/0354/"},{"categories":null,"content":"题目 给你一个由非负整数 a1, a2, …, an 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。 实现 SummaryRanges 类： SummaryRanges() 使用一个空数据流初始化对象。 void addNum(int val) 向数据流中加入整数 val 。 int[][] getIntervals() 以不相交区间 [starti, endi] 的列表形式返回对数据流中整数的总结。 示例： 输入：\r[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\"","date":"2015-12-18","objectID":"/leetcode/0352/:1:0","tags":null,"title":"0352：将数据流变为多个不相交区间（★★）","uri":"/leetcode/0352/"},{"categories":null,"content":"分析 0057 升级版。 addNum 时二分查找与 [val,val] 相交的区间下标，替换为合并后的区间即可。 ","date":"2015-12-18","objectID":"/leetcode/0352/:2:0","tags":null,"title":"0352：将数据流变为多个不相交区间（★★）","uri":"/leetcode/0352/"},{"categories":null,"content":"解答 class SummaryRanges: def __init__(self): self.A = [] def addNum(self, val: int) -\u003e None: L, R = val, val i = bisect_left(self.A, L-1, key=lambda x: x[1]) j = bisect_right(self.A, R+1, key=lambda x: x[0]) if i\u003cj: L, R = min(L, self.A[i][0]), max(R, self.A[j-1][1]) self.A[i:j] = [[L, R]] def getInt","date":"2015-12-18","objectID":"/leetcode/0352/:3:0","tags":null,"title":"0352：将数据流变为多个不相交区间（★★）","uri":"/leetcode/0352/"},{"categories":null,"content":"题目 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数， 应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2]\r输出：[2,2]\r示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\r输出：[4,9]\r提示： 1 \u003c= nums1.length, nums2.length \u003c= 1000 0 \u003c= nums1[i], nums2[i] \u003c= 1000 进阶： 如果给","date":"2015-12-16","objectID":"/leetcode/0350/:1:0","tags":null,"title":"0350：两个数组的交集 II","uri":"/leetcode/0350/"},{"categories":null,"content":"分析 直接调用 Counter 求交集即可。 ","date":"2015-12-16","objectID":"/leetcode/0350/:2:0","tags":null,"title":"0350：两个数组的交集 II","uri":"/leetcode/0350/"},{"categories":null,"content":"解答 def intersect(self, nums1: List[int], nums2: List[int]) -\u003e List[int]: return list((Counter(nums1)\u0026Counter(nums2)).elements()) 36 ms ","date":"2015-12-16","objectID":"/leetcode/0350/:3:0","tags":null,"title":"0350：两个数组的交集 II","uri":"/leetcode/0350/"},{"categories":null,"content":"题目 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。 我们可以 不考虑输出结果的顺序 。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2]\r输出：[2]\r示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\r输出：[9,4]\r解释：[4,9] 也是可通过的\r提示： 1 \u003c= nums1.length, nums2.length \u003c= 1000 0 \u003c= nums1[i], nums2[i] \u003c= 1000 ","date":"2015-12-15","objectID":"/leetcode/0349/:1:0","tags":null,"title":"0349：两个数组的交集","uri":"/leetcode/0349/"},{"categories":null,"content":"分析 直接调用 set 取交集即可。 ","date":"2015-12-15","objectID":"/leetcode/0349/:2:0","tags":null,"title":"0349：两个数组的交集","uri":"/leetcode/0349/"},{"categories":null,"content":"解答 def intersection(self, nums1: List[int], nums2: List[int]) -\u003e List[int]: return list(set(nums1)\u0026set(nums2)) 44 ms ","date":"2015-12-15","objectID":"/leetcode/0349/:3:0","tags":null,"title":"0349：两个数组的交集","uri":"/leetcode/0349/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。 你可以按 任意顺序 返回答案。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2\r输出: [1,2]\r示例 2: 输入: nums = [1], k = 1\r输出: [1]\r提示： 1 \u003c= nums.length \u003c= 10^5 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 ","date":"2015-12-13","objectID":"/leetcode/0347/:1:0","tags":null,"title":"0347：前 K 个高频元素（★）","uri":"/leetcode/0347/"},{"categories":null,"content":"分析 典型的排序问题。要求优于 O(n log n)，考虑用堆排序。 ","date":"2015-12-13","objectID":"/leetcode/0347/:2:0","tags":null,"title":"0347：前 K 个高频元素（★）","uri":"/leetcode/0347/"},{"categories":null,"content":"解答 def topKFrequent(self, nums: List[int], k: int) -\u003e List[int]: ct = Counter(nums) return nlargest(k, ct.keys(), key=ct.get) 44 ms ","date":"2015-12-13","objectID":"/leetcode/0347/:3:0","tags":null,"title":"0347：前 K 个高频元素（★）","uri":"/leetcode/0347/"},{"categories":null,"content":"题目 给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。 元音字母包括 ‘a’、’e’、‘i’、‘o’、‘u’，且可能以大小写两种形式出现。 示例 1： 输入：s = \"hello\"\r输出：\"holle\"\r示例 2： 输入：s = \"leetcode\"\r输出：\"leotcede\"\r提示： 1 \u003c= s.length \u003c= 3 * 10^5 s 由 可打印的 ASCII 字符组成 ","date":"2015-12-11","objectID":"/leetcode/0345/:1:0","tags":null,"title":"0345：反转字符串中的元音字母（★）","uri":"/leetcode/0345/"},{"categories":null,"content":"分析 0344 升级版，指针移动时跳过非元音字母即可。 ","date":"2015-12-11","objectID":"/leetcode/0345/:2:0","tags":null,"title":"0345：反转字符串中的元音字母（★）","uri":"/leetcode/0345/"},{"categories":null,"content":"解答 def reverseVowels(self, s: str) -\u003e str: s = list(s) i, j = 0, len(s) -1 while i \u003c j: if s[i].lower() not in 'aeiou': i += 1 elif s[j].lower() not in 'aeiou': j -= 1 else: s[i], s[j] = s[j], s[i] i += 1 j -= 1 return ''.join(s) 68 ms ","date":"2015-12-11","objectID":"/leetcode/0345/:3:0","tags":null,"title":"0345：反转字符串中的元音字母（★）","uri":"/leetcode/0345/"},{"categories":null,"content":"题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 示例 1： 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\r输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\r示例 2： 输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\r输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\r提示： 1 \u003c= s.length \u003c= 10^5 s[i] 都是 ASCII 码表中的可打印字符 ","date":"2015-12-10","objectID":"/leetcode/0344/:1:0","tags":null,"title":"0344：反转字符串","uri":"/leetcode/0344/"},{"categories":null,"content":"分析 典型的双指针应用。 ","date":"2015-12-10","objectID":"/leetcode/0344/:2:0","tags":null,"title":"0344：反转字符串","uri":"/leetcode/0344/"},{"categories":null,"content":"解答 def reverseString(self, s: List[str]) -\u003e None: i, j = 0, len(s)-1 while i \u003c j: s[i], s[j] = s[j], s[i] i += 1 j -= 1 48 ms ","date":"2015-12-10","objectID":"/leetcode/0344/:3:0","tags":null,"title":"0344：反转字符串","uri":"/leetcode/0344/"},{"categories":null,"content":"题目 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 输入: 2\r输出: 1\r解释: 2 = 1 + 1, 1 × 1 = 1。\r示例 2: 输入: 10\r输出: 36\r解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\r提示: 2 \u003c= n \u003c= 58 ","date":"2015-12-09","objectID":"/leetcode/0343/:1:0","tags":null,"title":"0343：整数拆分（★★）","uri":"/leetcode/0343/"},{"categories":null,"content":"分析 ","date":"2015-12-09","objectID":"/leetcode/0343/:2:0","tags":null,"title":"0343：整数拆分（★★）","uri":"/leetcode/0343/"},{"categories":null,"content":"#1 可以用 dp，按最后一个拆分的数即可递归。 def integerBreak(self, n: int) -\u003e int: dp = [1] * n for i in range(2, n): dp[i] = max(i, max(dp[j]*dp[i-j] for j in range(1, i))) return max(dp[j]*dp[n-j] for j in range(1, n)) 时间复杂度 O(N^2)，28 ms ","date":"2015-12-09","objectID":"/leetcode/0343/:2:1","tags":null,"title":"0343：整数拆分（★★）","uri":"/leetcode/0343/"},{"categories":null,"content":"#2 还可以利用数学知识： 假如拆分出的某个数 x\u003e=4 那么将 x 拆为 2 和 x-2，2*(x-2)\u003e=x，乘积不变或增大 因此必然存在最佳方案，拆出的数都小于等于 3 除了 n=2 或 3 的特殊情况，显然拆出 1 会使乘积减小 因此 n\u003e3 时，必然存在最佳方案，拆出的数都是 2 或 3 3 个 2 换成 2 个 3，乘积增大 因此 n\u003e3 时，必然存在最佳方案，拆出 2 的个数 \u003c=2，其它的都是 3。 根据 n%3 的值，即可确定一种最佳方案： n%3 == 0 时，全拆为 3 即可 n%3 == 1 时，拆为 2 个 2，剩下的都为 3 即可 n%3 == 2 时，拆为 1 个","date":"2015-12-09","objectID":"/leetcode/0343/:2:2","tags":null,"title":"0343：整数拆分（★★）","uri":"/leetcode/0343/"},{"categories":null,"content":"解答 def integerBreak(self, n: int) -\u003e int: if n \u003c= 3: return n-1 q, r = divmod(n, 3) return 3**q if r==0 else 3**(q-1)*4 if r==1 else 3**q*2 时间复杂度 O(1)，28 ms ","date":"2015-12-09","objectID":"/leetcode/0343/:3:0","tags":null,"title":"0343：整数拆分（★★）","uri":"/leetcode/0343/"},{"categories":null,"content":"题目 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4^x 示例 1： 输入：n = 16\r输出：true\r示例 2： 输入：n = 5\r输出：false\r示例 3： 输入：n = 1\r输出：true\r提示：-2^31 \u003c= n \u003c= 2^31 - 1 ","date":"2015-12-08","objectID":"/leetcode/0342/:1:0","tags":null,"title":"0342：4的幂（★）","uri":"/leetcode/0342/"},{"categories":null,"content":"分析 0231 升级版。n 是 4 的幂等价于 n 是 2 的幂且 n 的二进制中的 1 在偶数位上。 只要 n \u0026 0xAAAAAAAA == 0，即说明 n 的二进制不存在奇数位的 1。 ","date":"2015-12-08","objectID":"/leetcode/0342/:2:0","tags":null,"title":"0342：4的幂（★）","uri":"/leetcode/0342/"},{"categories":null,"content":"解答 def isPowerOfFour(self, n: int) -\u003e bool: return n \u003e 0 and n\u0026(n-1) == 0 and n \u0026 0xAAAAAAAA == 0 32 ms ","date":"2015-12-08","objectID":"/leetcode/0342/:3:0","tags":null,"title":"0342：4的幂（★）","uri":"/leetcode/0342/"},{"categories":null,"content":"题目 给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表； 该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。 实现扁平迭代器类 NestedIterator ： NestedIterator(List nestedList) 用嵌套列表 nestedList 初始化迭代器。 int next() 返回嵌套列表的下一个整数。 boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。 示例 1： 输入：nestedList = [[1,1],2,[1,1]]","date":"2015-12-07","objectID":"/leetcode/0341/:1:0","tags":null,"title":"0341：扁平化嵌套列表迭代器（★★）","uri":"/leetcode/0341/"},{"categories":null,"content":"分析 ","date":"2015-12-07","objectID":"/leetcode/0341/:2:0","tags":null,"title":"0341：扁平化嵌套列表迭代器（★★）","uri":"/leetcode/0341/"},{"categories":null,"content":"#1 可以直接递归将 nextedList 转为一维列表，然后迭代返回即可。 为了方便，可以用转为队列，不断弹出首位元素即可。 class NestedIterator: def __init__(self, nestedList: [NestedInteger]): def dfs(nest): if nest.isInteger(): return [nest.getInteger()] return [x for sub in nest.getList() for x in dfs(sub)] self.A = deque(x for sub in nestedList for x in","date":"2015-12-07","objectID":"/leetcode/0341/:2:1","tags":null,"title":"0341：扁平化嵌套列表迭代器（★★）","uri":"/leetcode/0341/"},{"categories":null,"content":"#2 还可以边迭代边转换： 如果队首是列表，就拆为元素加到队首 循环操作直到队首是整数，再弹出即可 为了方便，在 hasNext() 中完成转换，从而判断是否为空 ","date":"2015-12-07","objectID":"/leetcode/0341/:2:2","tags":null,"title":"0341：扁平化嵌套列表迭代器（★★）","uri":"/leetcode/0341/"},{"categories":null,"content":"解答 class NestedIterator: def __init__(self, nestedList: [NestedInteger]): self.A = deque(nestedList) def next(self) -\u003e int: return self.A.popleft().getInteger() def hasNext(self) -\u003e bool: while self.A and not self.A[0].isInteger(): self.A.extendleft(self.A.popleft().getList()[::-1]) return bool(self","date":"2015-12-07","objectID":"/leetcode/0341/:3:0","tags":null,"title":"0341：扁平化嵌套列表迭代器（★★）","uri":"/leetcode/0341/"},{"categories":null,"content":"题目 给你一个整数 n ，对于 0 \u003c= i \u003c= n 中的每个 i ，计算其二进制表示中 1 的个数 ， 返回一个长度为 n + 1 的数组 ans 作为答案。 示例 1： 输入：n = 2\r输出：[0,1,1]\r解释：\r0 --\u003e 0\r1 --\u003e 1\r2 --\u003e 10\r示例 2： 输入：n = 5\r输出：[0,1,1,2,1,2]\r解释：\r0 --\u003e 0\r1 --\u003e 1\r2 --\u003e 10\r3 --\u003e 11\r4 --\u003e 100\r5 --\u003e 101\r提示： 0 \u003c= n \u003c= 10^5 进阶： 很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用","date":"2015-12-04","objectID":"/leetcode/0338/:1:0","tags":null,"title":"0338：比特位计数（★★）","uri":"/leetcode/0338/"},{"categories":null,"content":"分析 0191 进阶版。已知 n \u0026 (n-1) 等价于将 n 中最后一个 1 变为 0。 所以 n 的 1 的数目就是 n \u0026 (n-1) 的 1 的数目加 1。递推即可。 ","date":"2015-12-04","objectID":"/leetcode/0338/:2:0","tags":null,"title":"0338：比特位计数（★★）","uri":"/leetcode/0338/"},{"categories":null,"content":"解答 def countBits(self, num: int) -\u003e List[int]: dp = [0] for i in range(1, num + 1): dp.append(dp[i \u0026 (i - 1)] + 1) return dp 40 ms ","date":"2015-12-04","objectID":"/leetcode/0338/:3:0","tags":null,"title":"0338：比特位计数（★★）","uri":"/leetcode/0338/"},{"categories":null,"content":"题目 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后， 聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。 示例 1: 输入: root = [3,2,3,null,3,null,1]\r输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7\r示例 2: 输入: root = [3,4,5,1,3,null,1","date":"2015-12-03","objectID":"/leetcode/0337/:1:0","tags":null,"title":"0337：打家劫舍 III（★★）","uri":"/leetcode/0337/"},{"categories":null,"content":"分析 令 dfs(node) 同时返回 能偷的最高金额 不偷 node 情况下的最高金额 即可递归。 ","date":"2015-12-03","objectID":"/leetcode/0337/:2:0","tags":null,"title":"0337：打家劫舍 III（★★）","uri":"/leetcode/0337/"},{"categories":null,"content":"解答 def rob(self, root: TreeNode) -\u003e int: def dfs(node): if not node: return 0, 0 l1, l2 = dfs(node.left) r1, r2 = dfs(node.right) return max(node.val+l2+r2, l1+r1), l1+r1 return dfs(root)[0] 48 ms ","date":"2015-12-03","objectID":"/leetcode/0337/:3:0","tags":null,"title":"0337：打家劫舍 III（★★）","uri":"/leetcode/0337/"},{"categories":null,"content":"题目 给定一组 互不相同 的单词， 找出所有 不同 的索引对 (i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。 示例 1： 输入：words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"] 输出：[[0,1],[1,0],[3,2],[2,4]] 解释：可拼接成的回文串为 [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"] 示例 2： 输入：words = [\"bat\",\"tab\",\"cat\"] 输出：[[0,1],[1,0]] 解释：可拼接成的回文串为 [\"battab\",\"tabbat\"","date":"2015-12-02","objectID":"/leetcode/0336/:1:0","tags":null,"title":"0336：回文对（★★★）","uri":"/leetcode/0336/"},{"categories":null,"content":"分析 单词个数范围较大，而单词长度范围较小，因此考虑优化搜索方法。 假如 w1+w2 是回文串，那么必然是以下情况之一： len(w1) == len(w2)，w1==w2[::-1] len(w1) \u003c len(w2), w2 可拆分为 pre、suf，pre==pre[::-1]，suf==w1[::-1] len(w1) \u003e len(w2), w1 可拆分为 pre、suf，pre==w2[::-1]，suf==suf[::-1] 因此，遍历单词 x 的所有拆分方式，假如能拆分为一个回文串和另一个单词 y 的反序， 那么 x+y 或者 y+x 就是回文串。 特别注意空单词的情况，空单词+","date":"2015-12-02","objectID":"/leetcode/0336/:2:0","tags":null,"title":"0336：回文对（★★★）","uri":"/leetcode/0336/"},{"categories":null,"content":"解答 def palindromePairs(self, words: List[str]) -\u003e List[List[int]]: res, d = [], {x: i for i, x in enumerate(words)} for i, x in enumerate(words): if x != x[::-1] and x[::-1] in d: res.append([i, d[x[::-1]]]) if x and x==x[::-1] and '' in d: res.extend([[i, d['']], [d[''], i]]) for k in range(1, len(","date":"2015-12-02","objectID":"/leetcode/0336/:3:0","tags":null,"title":"0336：回文对（★★★）","uri":"/leetcode/0336/"},{"categories":null,"content":"题目 给你一个整数数组 distance 。 从 X-Y 平面上的点 (0,0) 开始，先向北移动 distance[0] 米，然后向西移动 distance[1] 米， 向南移动 distance[2] 米，向东移动 distance[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。 判断你所经过的路径是否相交。如果相交，返回 true ；否则，返回 false 。 示例 1： 输入：distance = [2,1,1,2]\r输出：true\r示例 2： 输入：distance = [1,2,3,4]\r输出：false\r示例 3： 输入：distance = [1,1,1,1","date":"2015-12-01","objectID":"/leetcode/0335/:1:0","tags":null,"title":"0335：路径交叉（★★★）","uri":"/leetcode/0335/"},{"categories":null,"content":"分析 观察发现，第 i 步的路径只可能和 [i-5,i-3] 范围内的路径交叉。分别判断即可。 ","date":"2015-12-01","objectID":"/leetcode/0335/:2:0","tags":null,"title":"0335：路径交叉（★★★）","uri":"/leetcode/0335/"},{"categories":null,"content":"解答 def isSelfCrossing(self, distance: List[int]) -\u003e bool: n, A = len(distance), distance for i in range(3, n): if A[i]\u003e=A[i-2] and A[i-1]\u003c=A[i-3]: return True if i\u003e=4 and A[i-1]==A[i-3] and A[i]+A[i-4]\u003e=A[i-2]: return True if i\u003e=5 and A[i]+A[i-4]\u003e=A[i-2]\u003e=A[i-4] and A[i-1]+A[i-5]\u003e=A[i-3]\u003e=A[i-1]: re","date":"2015-12-01","objectID":"/leetcode/0335/:3:0","tags":null,"title":"0335：路径交叉（★★★）","uri":"/leetcode/0335/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标 (i, j, k) 且满足 i \u003c j \u003c k ， 使得 nums[i] \u003c nums[j] \u003c nums[k] ，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [1,2,3,4,5]\r输出：true\r解释：任何 i \u003c j \u003c k 的三元组都满足题意\r示例 2： 输入：nums = [5,4,3,2,1]\r输出：false\r解释：不存在满足题意的三元组\r示例 3： 输入：nums = [2,1,5,0,4,6]\r输出：true\r解释：三元组 (3, ","date":"2015-11-30","objectID":"/leetcode/0334/:1:0","tags":null,"title":"0334：递增的三元子序列（★★）","uri":"/leetcode/0334/"},{"categories":null,"content":"分析 0300 简化版，当最长递增子序列的长度大于 2 时，即可返回 True。 ","date":"2015-11-30","objectID":"/leetcode/0334/:2:0","tags":null,"title":"0334：递增的三元子序列（★★）","uri":"/leetcode/0334/"},{"categories":null,"content":"解答 def increasingTriplet(self, nums: List[int]) -\u003e bool: A = [] for num in nums: j = bisect_left(A, num) A[j:j + 1] = [num] if len(A) \u003e 2: return True return False 132 ms ","date":"2015-11-30","objectID":"/leetcode/0334/:3:0","tags":null,"title":"0334：递增的三元子序列（★★）","uri":"/leetcode/0334/"},{"categories":null,"content":"题目 给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。 请你对该行程进行重新规划排序。 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。 如果存在多种有效的行程，请你按字典排序返回最小的行程组合。 例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前。 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。 示例 1： 输入：tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],","date":"2015-11-28","objectID":"/leetcode/0332/:1:0","tags":null,"title":"0332：重新安排行程（★★★）","uri":"/leetcode/0332/"},{"categories":null,"content":"分析 本题是经典的欧拉图问题，可以用精妙的 Hierholzer 算法 。 ","date":"2015-11-28","objectID":"/leetcode/0332/:2:0","tags":null,"title":"0332：重新安排行程（★★★）","uri":"/leetcode/0332/"},{"categories":null,"content":"解答 def findItinerary(self, tickets: List[List[str]]) -\u003e List[str]: def dfs(u): while nxt[u]: dfs(heappop(nxt[u])) res.append(u) nxt = defaultdict(list) for u, v in tickets: heappush(nxt[u], v) res = [] dfs('JFK') return res[::-1] 32 ms ","date":"2015-11-28","objectID":"/leetcode/0332/:3:0","tags":null,"title":"0332：重新安排行程（★★★）","uri":"/leetcode/0332/"},{"categories":null,"content":"题目 序列化二叉树的一种方法是使用 前序遍历 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。 如果它是一个空节点，我们可以使用一个标记值记录，例如 # 。 例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#\"，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。 你可以认为输入格式总是有效的 例如它永远不会包含两个连续的逗号，比如 “1,,3” 。 注意：不允许重建树。 示例 1: 输","date":"2015-11-27","objectID":"/leetcode/0331/:1:0","tags":null,"title":"0331：验证二叉树的前序序列化（★★）","uri":"/leetcode/0331/"},{"categories":null,"content":"分析 前序序列中，叶子节点后必然是两个空节点。 不断将叶子节点和后面的两个空节点替换为一个空节点， 直到只剩下一个空节点，即说明是正确的。 具体实现可以用栈。 ","date":"2015-11-27","objectID":"/leetcode/0331/:2:0","tags":null,"title":"0331：验证二叉树的前序序列化（★★）","uri":"/leetcode/0331/"},{"categories":null,"content":"解答 def isValidSerialization(self, preorder: str) -\u003e bool: stack = [] for c in preorder.split(','): while len(stack)\u003e1 and c==stack[-1]=='#'!=stack[-2]: stack.pop() stack.pop() stack.append(c) return stack == ['#'] 32 ms ","date":"2015-11-27","objectID":"/leetcode/0331/:3:0","tags":null,"title":"0331：验证二叉树的前序序列化（★★）","uri":"/leetcode/0331/"},{"categories":null,"content":"题目 给定一个已排序的正整数数组 nums ，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中， 使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。 请返回 满足上述要求的最少需要补充的数字个数 。 示例 1: 输入: nums = [1,3], n = 6\r输出: 1 解释:\r根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。\r现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。\r其和可以表示数字 1, 2, 3, 4","date":"2015-11-26","objectID":"/leetcode/0330/:1:0","tags":null,"title":"0330：按要求补齐数组（★★★）","uri":"/leetcode/0330/"},{"categories":null,"content":"分析 假设现有组合不能得到的最小数是 x，显然 x 是必须要补充的。加上 x 并更新组合能得到的数，依此循环即可。 具体实现： 先找到第一个 i 使得 nums[i] \u003e sum(nums[:i])+1，sum(nums[:i])+1 即是 x 在位置 i 插入 x，跳回上一步 实际实现时不需要真的插入，更新 s=sum(nums[:i]) 即可 ","date":"2015-11-26","objectID":"/leetcode/0330/:2:0","tags":null,"title":"0330：按要求补齐数组（★★★）","uri":"/leetcode/0330/"},{"categories":null,"content":"解答 def minPatches(self, nums: List[int], n: int) -\u003e int: res, Q, s = 0, deque(nums), 0 while s \u003c n: if Q and Q[0] \u003c= s+1: s += Q.popleft() else: s += s + 1 res += 1 return res 32 ms ","date":"2015-11-26","objectID":"/leetcode/0330/:3:0","tags":null,"title":"0330：按要求补齐数组（★★★）","uri":"/leetcode/0330/"},{"categories":null,"content":"题目 给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。 示例 1： 输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]\r输出：4 解释：最长递增路径为 [1, 2, 6, 9]。\r示例 2： 输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]\r输出：4 解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。\r示例 3： 输入：matrix = [[1]]\r输出：1\r提示：","date":"2015-11-25","objectID":"/leetcode/0329/:1:0","tags":null,"title":"0329：矩阵中的最长递增路径（★★）","uri":"/leetcode/0329/"},{"categories":null,"content":"分析 显然路径中不存在环，所以直接递归每个点出发的最长路径即可。 ","date":"2015-11-25","objectID":"/leetcode/0329/:2:0","tags":null,"title":"0329：矩阵中的最长递增路径（★★）","uri":"/leetcode/0329/"},{"categories":null,"content":"解答 def longestIncreasingPath(self, matrix: List[List[int]]) -\u003e int: @lru_cache(None) def dfs(i, j): res = 1 for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0\u003c=x\u003cm and 0\u003c=y\u003cn and matrix[i][j]\u003cmatrix[x][y]: res = max(res, 1+dfs(x, y)) return res m, n = len(matrix), len(matrix[0]) return max(d","date":"2015-11-25","objectID":"/leetcode/0329/:3:0","tags":null,"title":"0329：矩阵中的最长递增路径（★★）","uri":"/leetcode/0329/"},{"categories":null,"content":"题目 给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。 第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。 请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。 你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。 示例 1: 输入: head = [1,2,3,4,5]\r输出: [1,3,5,2,4]\r示例 2: 输入: head = [2,1,3,5,6,4,7]\r输出: [2,3,6,7,1,5,4]\r提示: n == 链表中的节点数 0 \u003c= n \u003c= 10^4 -1","date":"2015-11-24","objectID":"/leetcode/0328/:1:0","tags":null,"title":"0328：奇偶链表（★★）","uri":"/leetcode/0328/"},{"categories":null,"content":"分析 类似于 0086 ，将奇数节点先提出来，按顺序链接，末尾再链接到原链表即可。 ","date":"2015-11-24","objectID":"/leetcode/0328/:2:0","tags":null,"title":"0328：奇偶链表（★★）","uri":"/leetcode/0328/"},{"categories":null,"content":"解答 def oddEvenList(self, head: ListNode) -\u003e ListNode: dummy1 = p = ListNode(next=head) dummy2 = q = ListNode() while p and p.next: q.next = p.next q = q.next p.next = p.next.next p = p.next q.next = dummy1.next return dummy2.next 48 ms ","date":"2015-11-24","objectID":"/leetcode/0328/:3:0","tags":null,"title":"0328：奇偶链表（★★）","uri":"/leetcode/0328/"},{"categories":null,"content":"题目 给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。 区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。 示例 1： 输入：nums = [-2,5,-1], lower = -2, upper = 2\r输出：3\r解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。\r示例 2： 输入：nums = [0], lower = 0, upper = ","date":"2015-11-23","objectID":"/leetcode/0327/:1:0","tags":null,"title":"0327：区间和的个数（★★★）","uri":"/leetcode/0327/"},{"categories":null,"content":"分析 区间和容易想到前缀和，于是先得到前缀和数组 pre，pre[i]=sum(nums[:i])。 遍历位置 j，求满足 i\u003cj, lower\u003c=pre[j]-pre[i]\u003c=upper 的 i 个数即可。 于是考虑维护 pre[:j] 的有序集合，即可二分查找 i 的个数。 要进行插入、查找的操作，考虑用 SortedList，都能在 O(logN) 时间内完成。 ","date":"2015-11-23","objectID":"/leetcode/0327/:2:0","tags":null,"title":"0327：区间和的个数（★★★）","uri":"/leetcode/0327/"},{"categories":null,"content":"解答 def countRangeSum(self, nums: List[int], lower: int, upper: int) -\u003e int: from sortedcontainers import SortedList res, sl = 0, SortedList() for x in accumulate([0]+nums): res += sl.bisect_right(x-lower)-sl.bisect_left(x-upper) sl.add(x) return res 时间复杂度 O(N*logN)，1492 ms ","date":"2015-11-23","objectID":"/leetcode/0327/:3:0","tags":null,"title":"0327：区间和的个数（★★★）","uri":"/leetcode/0327/"},{"categories":null,"content":"题目 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3^x 示例 1： 输入：n = 27\r输出：true\r示例 2： 输入：n = 0\r输出：false\r示例 3： 输入：n = 9\r输出：true\r示例 4： 输入：n = 45\r输出：false\r提示：-2^31 \u003c= n \u003c= 2^31 - 1 ","date":"2015-11-22","objectID":"/leetcode/0326/:1:0","tags":null,"title":"0326：3的幂（★）","uri":"/leetcode/0326/"},{"categories":null,"content":"分析 类似 0231 ，n 是 3 的幂等价于 n 是正整数且 n 被 3^19 整除。 （3^19 是给定范围内最大的 3 的幂次方） ","date":"2015-11-22","objectID":"/leetcode/0326/:2:0","tags":null,"title":"0326：3的幂（★）","uri":"/leetcode/0326/"},{"categories":null,"content":"解答 def isPowerOfThree(self, n: int) -\u003e bool: return n \u003e 0 and (3**19) % n == 0 72 ms ","date":"2015-11-22","objectID":"/leetcode/0326/:3:0","tags":null,"title":"0326：3的幂（★）","uri":"/leetcode/0326/"},{"categories":null,"content":"题目 给你一个整数数组 nums，将它重新排列成 nums[0] \u003c nums[1] \u003e nums[2] \u003c nums[3]… 的顺序。 你可以假设所有输入数组都可以得到满足题目要求的结果。 示例 1： 输入：nums = [1,5,1,1,6,4]\r输出：[1,6,1,5,1,4]\r解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。\r示例 2： 输入：nums = [1,3,2,2,3,1]\r输出：[2,3,1,3,1,2]\r提示： 1 \u003c= nums.length \u003c= 5 * 10^4 0 \u003c= nums[i] \u003c= 5000 题目数据保证，对于给定的输入 ","date":"2015-11-20","objectID":"/leetcode/0324/:1:0","tags":null,"title":"0324：摆动排序 II（★★★）","uri":"/leetcode/0324/"},{"categories":null,"content":"分析 容易想到将较小的一半和较大的一半交叉放： 令 a=max(较小的一半数)，b=min(较大的一半) 假如 a\u003cb，按顺序放就可以了 假如 a==b 时，按顺序放可能不行 比如用例 [1，2，4，4，4，6] 按顺序放是 [1,4,2,4,4,6] 直觉上来说，应该使 a、b 尽量远离。因此考虑令 a 尽量靠左放，b 尽量靠右放 比如用例 [1，2，4，4，4，6] 可以放置为 [4,6,1,4,2,4] 即符合条件 为了方便，较小/大的一半都逆序放即可 最后证明一下该方案不可行时，必然无解： 假设 n=len(nums) 为偶数 该方案不可行，意味着某个数 x 出现了至少 n//2+1 ","date":"2015-11-20","objectID":"/leetcode/0324/:2:0","tags":null,"title":"0324：摆动排序 II（★★★）","uri":"/leetcode/0324/"},{"categories":null,"content":"解答 def wiggleSort(self, nums: List[int]) -\u003e None: n = len(nums) nums.sort(reverse=True) nums[1::2], nums[::2] = nums[:n//2], nums[n//2:] 48 ms ","date":"2015-11-20","objectID":"/leetcode/0324/:3:0","tags":null,"title":"0324：摆动排序 II（★★★）","uri":"/leetcode/0324/"},{"categories":null,"content":"题目 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 输入：coins = [1, 2, 5], amount = 11\r输出：3 解释：11 = 5 + 5 + 1\r示例 2： 输入：coins = [2], amount = 3\r输出：-1\r示例 3： 输入：coins = [1], amount = 0\r输出：0\r提示： 1 \u003c= coins.length \u003c= 12 1 \u003c= coins[","date":"2015-11-18","objectID":"/leetcode/0322/:1:0","tags":null,"title":"0322：零钱兑换（★★）","uri":"/leetcode/0322/"},{"categories":null,"content":"分析 典型的线性 dp，按最后选择的硬币即可递归。 ","date":"2015-11-18","objectID":"/leetcode/0322/:2:0","tags":null,"title":"0322：零钱兑换（★★）","uri":"/leetcode/0322/"},{"categories":null,"content":"解答 def coinChange(self, coins: List[int], amount: int) -\u003e int: dp = [0] * (amount+1) for i in range(1, amount+1): dp[i] = 1 + min(dp[i-coin] if coin\u003c=i else float('inf') for coin in coins) return dp[-1] if dp[-1]\u003cfloat('inf') else -1 时间复杂度 O(N*S)，848 ms ","date":"2015-11-18","objectID":"/leetcode/0322/:3:0","tags":null,"title":"0322：零钱兑换（★★）","uri":"/leetcode/0322/"},{"categories":null,"content":"题目 给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。 现在从这两个数组中选出 k (k \u003c= m + n) 个数字拼接成一个新的数， 要求从同一个数组中取出的数字保持其在原数组中的相对顺序。 求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。 说明: 请尽可能地优化你算法的时间和空间复杂度。 示例 1: 输入:\rnums1 = [3, 4, 6, 5]\rnums2 = [9, 1, 2, 5, 8, 3]\rk = 5\r输出:\r[9, 8, 6, 5, 3]\r示例 2: 输入:\rnums1 = [6, 7]\rnums2 = [6, ","date":"2015-11-17","objectID":"/leetcode/0321/:1:0","tags":null,"title":"0321：拼接最大数（★★★）","uri":"/leetcode/0321/"},{"categories":null,"content":"分析 假设 nums1 取出 x 个，nums2 取出 k-x 个： 显然应该使 nums1 取出的 x 个数拼成的数最大，这等价于 0402 同理取出 nums2 的数 可以归求出这 k 个数能拼成的最大数 那么遍历 x，分别计算即可。 注意归并时当两个指针指向元素相等，要比较后面的元素。为了方便，可以直接比较数组后缀。 ","date":"2015-11-17","objectID":"/leetcode/0321/:2:0","tags":null,"title":"0321：拼接最大数（★★★）","uri":"/leetcode/0321/"},{"categories":null,"content":"解答 def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -\u003e List[int]: def select(A, i): stack, j = [], len(A)-i for x in A: while j and stack and stack[-1]\u003cx: stack.pop() j -= 1 stack.append(x) return stack[:i] def gen(i): A, B = select(nums1, i), select(nums2, k-i) return [max(A,B).pop(0","date":"2015-11-17","objectID":"/leetcode/0321/:3:0","tags":null,"title":"0321：拼接最大数（★★★）","uri":"/leetcode/0321/"},{"categories":null,"content":"题目 初始时有 n 个灯泡处于关闭状态。 对某个灯泡切换开关意味着：如果灯泡状态为关闭，那该灯泡就会被开启；而灯泡状态为开启，那该灯泡就会被关闭。 第 1 轮，每个灯泡切换一次开关。即，打开所有的灯泡。 第 2 轮，每两个灯泡切换一次开关。 即，每两个灯泡关闭一个。 第 3 轮，每三个灯泡切换一次开关。 第 i 轮，每 i 个灯泡切换一次开关。 而第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 示例 1： 输入：n = 3\r输出：1 解释：\r初始时, 灯泡状态 [关闭, 关闭, 关闭].\r第一轮后, 灯泡状态 [开启, 开启, 开启].\r第二轮后, 灯泡状态 [开","date":"2015-11-15","objectID":"/leetcode/0319/:1:0","tags":null,"title":"0319：灯泡开关（★）","uri":"/leetcode/0319/"},{"categories":null,"content":"分析 可以观察每个位置的灯泡切换了多少次： 位置 x 的灯泡，第 i 轮切换等价于 x % i == 0 位置 x 的灯泡的切换次数即为 x 的因数个数 根据数学知识，只有完全平方数有奇数个因数，其它都是偶数个因数。 因此计算 1 到 n 有多少个完全平方数即可。 ","date":"2015-11-15","objectID":"/leetcode/0319/:2:0","tags":null,"title":"0319：灯泡开关（★）","uri":"/leetcode/0319/"},{"categories":null,"content":"解答 def bulbSwitch(self, n: int) -\u003e int: return int(sqrt(n)) 44 ms ","date":"2015-11-15","objectID":"/leetcode/0319/:3:0","tags":null,"title":"0319：灯泡开关（★）","uri":"/leetcode/0319/"},{"categories":null,"content":"题目 给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值， 并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。 示例 1: 输入: [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\r输出: 16 解释: 这两个单词为 \"abcw\", \"xtfn\"。\r示例 2: 输入: [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\r输出: 4 解释: 这两个单词为 \"ab\", \"cd\"。\r示例 3: 输入: [\"a\",\"aa\",\"a","date":"2015-11-14","objectID":"/leetcode/0318/:1:0","tags":null,"title":"0318：最大单词长度乘积（★★）","uri":"/leetcode/0318/"},{"categories":null,"content":"分析 ","date":"2015-11-14","objectID":"/leetcode/0318/:2:0","tags":null,"title":"0318：最大单词长度乘积（★★）","uri":"/leetcode/0318/"},{"categories":null,"content":"#1 先保存每个单词的字母集合，然后遍历每一对单词，判断是否有公共字母即可。 def maxProduct(self, words: List[str]) -\u003e int: A, n = [set(w) for w in words], len(words) return max(len(words[i])*len(words[j]) if not A[i] \u0026 A[j] else 0 for i in range(n) for j in range(i)) 1024 ms ","date":"2015-11-14","objectID":"/leetcode/0318/:2:1","tags":null,"title":"0318：最大单词长度乘积（★★）","uri":"/leetcode/0318/"},{"categories":null,"content":"#2 注意到可能有多个单词的字母集合相同，所以可以用状态压缩表示的字母集合作为 key，保存对应的最大长度。 ","date":"2015-11-14","objectID":"/leetcode/0318/:2:2","tags":null,"title":"0318：最大单词长度乘积（★★）","uri":"/leetcode/0318/"},{"categories":null,"content":"解答 def maxProduct(self, words: List[str]) -\u003e int: d = defaultdict(int) for w in words: st = reduce(lambda x, y: x | 1 \u003c\u003c (ord(y) - ord('a')), w, 0) d[st] = max(d[st], len(w)) return max([d[a] * d[b] for a in d for b in d if not a \u0026 b], default=0) 284 ms ","date":"2015-11-14","objectID":"/leetcode/0318/:3:0","tags":null,"title":"0318：最大单词长度乘积（★★）","uri":"/leetcode/0318/"},{"categories":null,"content":"题目 给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。 需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 示例 1： 输入：s = \"bcabc\"\r输出：\"abc\"\r示例 2： 输入：s = \"cbacdcbc\"\r输出：\"acdb\"\r提示： 1 \u003c= s.length \u003c= 10^4 s 由小写英文字母组成 ","date":"2015-11-12","objectID":"/leetcode/0316/:1:0","tags":null,"title":"0316：去除重复字母（★★★）","uri":"/leetcode/0316/"},{"categories":null,"content":"分析 0402 的进阶版。如果没有每个字母出现一次的限制，保持字符串升序即可。 为了保证每个字母出现一次: 若某个字母已经在栈中，应该跳过它 若某个字母后面不再出现，就不能去掉它 ","date":"2015-11-12","objectID":"/leetcode/0316/:2:0","tags":null,"title":"0316：去除重复字母（★★★）","uri":"/leetcode/0316/"},{"categories":null,"content":"解答 def removeDuplicateLetters(self, s: str) -\u003e str: stack, vis, ct = [], set(), Counter(s) for c in s: ct[c] -= 1 if c not in vis: while stack and stack[-1]\u003ec and ct[stack[-1]]: vis.remove(stack.pop()) stack.append(c) vis.add(c) return ''.join(stack) 32 ms ","date":"2015-11-12","objectID":"/leetcode/0316/:3:0","tags":null,"title":"0316：去除重复字母（★★★）","uri":"/leetcode/0316/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例 1： 输入：nums = [5,2,6,1]\r输出：[2,1,1,0] 解释：\r5 的右侧有 2 个更小的元素 (2 和 1)\r2 的右侧仅有 1 个更小的元素 (1)\r6 的右侧有 1 个更小的元素 (1)\r1 的右侧有 0 个更小的元素\r示例 2： 输入：nums = [-1]\r输出：[0]\r示例 3： 输入：nums = [-1,-1]\r输出：[0,0]\r提示： 1 \u003c= nums.lengt","date":"2015-11-11","objectID":"/leetcode/0315/:1:0","tags":null,"title":"0315：计算右侧小于当前元素的个数（★★）","uri":"/leetcode/0315/"},{"categories":null,"content":"分析 考虑从右往左遍历，并维护一个有序集合。二分查找 nums[i] 的位置即可得到 counts[i]。 要进行插入、查找的操作，考虑用 SortedList 维护，都能在 O(logN) 时间内完成。 ","date":"2015-11-11","objectID":"/leetcode/0315/:2:0","tags":null,"title":"0315：计算右侧小于当前元素的个数（★★）","uri":"/leetcode/0315/"},{"categories":null,"content":"解答 def countSmaller(self, nums: List[int]) -\u003e List[int]: from sortedcontainers import SortedList n = len(nums) res, sl = [0]*n, SortedList() for i in range(n-1, -1, -1): res[i] = sl.bisect_left(nums[i]) sl.add(nums[i]) return res 时间复杂度 O(N*logN)，1088 ms ","date":"2015-11-11","objectID":"/leetcode/0315/:3:0","tags":null,"title":"0315：计算右侧小于当前元素的个数（★★）","uri":"/leetcode/0315/"},{"categories":null,"content":"题目 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。 给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。 题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。 示例 1： 输入：n = 12, primes = [2,7,13,19]\r输出：32 解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：\r[1,2,4,7,8,13,14,16,19,26,28,32] 。\r示例 2： 输入：n = 1, primes = [2,3,5]\r输出：1\r解释：1 不含质因数，","date":"2015-11-09","objectID":"/leetcode/0313/:1:0","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"分析 ","date":"2015-11-09","objectID":"/leetcode/0313/:2:0","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"#1 类似 0264，只不过质数数组不固定了。 def nthSuperUglyNumber(self, n: int, primes: List[int]) -\u003e int: dp, A = [1] * n, defaultdict(int) for i in range(1, n): dp[i] = min(dp[A[p]] * p for p in primes) for p in primes: if dp[A[p]] * p == dp[i]: A[p] += 1 return dp[-1] 时间复杂度 O(N*M)，超时了 ","date":"2015-11-09","objectID":"/leetcode/0313/:2:1","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"#2 注意到每次是取最小的 dp[A[p]]*p，想到可以用堆来维护 \u003cdp[A[p]]*p, A[p], p\u003e 三元组，可以快速获得最小值。 ","date":"2015-11-09","objectID":"/leetcode/0313/:2:2","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"解答 def nthSuperUglyNumber(self, n: int, primes: List[int]) -\u003e int: dp = [1] * n pq = [(p, 0, p) for p in primes] for i in range(1, n): dp[i] = pq[0][0] while pq and pq[0][0] == dp[i]: _, idx, p = heappop(pq) heappush(pq, (dp[idx+1] * p, idx+1, p)) return dp[-1] 时间复杂度 O(N*logM)，2548 ms ","date":"2015-11-09","objectID":"/leetcode/0313/:3:0","tags":null,"title":"0313：超级丑数（★★★）","uri":"/leetcode/0313/"},{"categories":null,"content":"题目 有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界， 那么就当它是一个数字为 1 的气球。 求所能获得硬币的最大数量。 示例 1： 输入：nums = [3,1,5,8]\r输出：167\r解释：\rnums = [3,1,5,8] --\u003e [3,5,8] --\u003e [3,8] --\u003e [8","date":"2015-11-08","objectID":"/leetcode/0312/:1:0","tags":null,"title":"0312：戳气球（★★★）","uri":"/leetcode/0312/"},{"categories":null,"content":"分析 为了方便，在前后各加一个数字 1 的气球得到数组 A。问题转为求 A 戳破非边界气球能得到的最大硬币数。 假设最后戳破第 k 个气球，获得 A[0]*A[-1]*A[k] 个硬币，剩下的即转为 A[:k+1] 和 A[k:] 的递归子问题。 令 dp[i][j] 代表 A[i:j+1] 能得到的最大硬币数，则递推式为： dp[i][j] = max(A[k]*A[i]*A[j]+dp[i][k]+dp[k][j] for k in range(i+1, j))\r","date":"2015-11-08","objectID":"/leetcode/0312/:2:0","tags":null,"title":"0312：戳气球（★★★）","uri":"/leetcode/0312/"},{"categories":null,"content":"解答 def maxCoins(self, nums: List[int]) -\u003e int: A = [1]+nums+[1] n = len(A) dp = [[0]*n for _ in range(n)] for i in range(n-3, -1, -1): for j in range(i+2, n): dp[i][j] = max(A[k]*A[i]*A[j]+dp[i][k]+dp[k][j] for k in range(i+1, j)) return dp[0][-1] 时间复杂度 O(N^3)，2968 ms ","date":"2015-11-08","objectID":"/leetcode/0312/:3:0","tags":null,"title":"0312：戳气球（★★★）","uri":"/leetcode/0312/"},{"categories":null,"content":"题目 树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。 给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签）， 其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。 可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。 在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。 请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。 树","date":"2015-11-06","objectID":"/leetcode/0310/:1:0","tags":null,"title":"0310：最小高度树（★★★）","uri":"/leetcode/0310/"},{"categories":null,"content":"分析 本题是拓扑排序的变种。从最外层的叶子节点向里面广度遍历，最里面的一层即是所求。 无向图的拓扑排序从考虑入度 0 变为考虑入度 1 的节点即可。 注意 n=1 的特殊情况。 ","date":"2015-11-06","objectID":"/leetcode/0310/:2:0","tags":null,"title":"0310：最小高度树（★★★）","uri":"/leetcode/0310/"},{"categories":null,"content":"解答 def findMinHeightTrees(self, n: int, edges: List[List[int]]) -\u003e List[int]: nxt, indeg = defaultdict(list), [0] * n for u, v in edges: nxt[u].append(v) nxt[v].append(u) indeg[u] += 1 indeg[v] += 1 res, Q = [], [u for u in range(n) if indeg[u] \u003c= 1] while Q: res, Q = Q, [] for u in res: for v in nx","date":"2015-11-06","objectID":"/leetcode/0310/:3:0","tags":null,"title":"0310：最小高度树（★★★）","uri":"/leetcode/0310/"},{"categories":null,"content":"题目 给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: prices = [1,2,3,0,2]\r输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\r示例 2: 输入: prices = [1]\r输出: 0\r提示： 1 \u003c= prices.length \u003c= 5000 0 ","date":"2015-11-05","objectID":"/leetcode/0309/:1:0","tags":null,"title":"0309：最佳买卖股票时机含冷冻期（★★）","uri":"/leetcode/0309/"},{"categories":null,"content":"分析 0122 升级版，dp[i][0] 的递推式有变化： dp[i][0] = max(dp[i-1][0], dp[i-2][1]-prices[i-1])\r","date":"2015-11-05","objectID":"/leetcode/0309/:2:0","tags":null,"title":"0309：最佳买卖股票时机含冷冻期（★★）","uri":"/leetcode/0309/"},{"categories":null,"content":"解答 def maxProfit(self, prices: List[int]) -\u003e int: a, b, c = float('-inf'), 0, 0 for price in prices: a, b, c = max(a, b-price), c, max(c, a+price) return c 32 ms ","date":"2015-11-05","objectID":"/leetcode/0309/:3:0","tags":null,"title":"0309：最佳买卖股票时机含冷冻期（★★）","uri":"/leetcode/0309/"},{"categories":null,"content":"题目 给你一个数组 nums ，请你完成两类查询。 其中一类查询要求 更新 数组 nums 下标对应的值 另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left \u003c= right 实现 NumArray 类： NumArray(int[] nums) 用整数数组 nums 初始化对象 void update(int index, int val) 将 nums[index] 的值 更新 为 val int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right ","date":"2015-11-03","objectID":"/leetcode/0307/:1:0","tags":null,"title":"0307：区域和检索 - 数组可修改（★★）","uri":"/leetcode/0307/"},{"categories":null,"content":"分析 0303 升级版，元素不固定了。 每次 sumRange 都挨个求和，显然会有大量不必要的运算。 有个想法是维护一些区间和，修改的数无关时就无需重新计算区间和。 这个想法也就是块状数组： 将数组分成大小 size 的块，并计算得到每一块的和 update 时，更新该数所属的块的和即可 sumRange 时，其中包含的完整的块的和无需再计算，只需计算两边的残块的和 完整的块最多有 n//size 个，残块的元素个数不超过 2*size 个 因此，当 size 取 $\\sqrt n$ 时，sumRange 时间是 $O(\\sqrt n)$ ","date":"2015-11-03","objectID":"/leetcode/0307/:2:0","tags":null,"title":"0307：区域和检索 - 数组可修改（★★）","uri":"/leetcode/0307/"},{"categories":null,"content":"解答 class NumArray: def __init__(self, nums: List[int]): n = len(nums) self.size = int(sqrt(n)) self.B = [0]*((n-1)//self.size+1) for i in range(n): self.B[i//self.size] += nums[i] self.nums = nums def update(self, index: int, val: int) -\u003e None: self.B[index//self.size] += val-self.nums[index] self.n","date":"2015-11-03","objectID":"/leetcode/0307/:3:0","tags":null,"title":"0307：区域和检索 - 数组可修改（★★）","uri":"/leetcode/0307/"},{"categories":null,"content":"*附加 还有个更巧妙的方法来维护一些区间和，即树状数组。 树状数组专门针对 单点更新+区间查询 的情况，实现时间复杂度 O(logN)。 为了方便，用 tree[i] 维护数组 [0]+nums 的区间 (i-lowbit(i), i] 的和 class NumArray: def __init__(self, nums: List[int]): self.nums = nums self.tree = [0] * (len(nums)+1) for i, num in enumerate(nums): self.add(i+1, num) def lowbit(self, x): retur","date":"2015-11-03","objectID":"/leetcode/0307/:4:0","tags":null,"title":"0307：区域和检索 - 数组可修改（★★）","uri":"/leetcode/0307/"},{"categories":null,"content":"题目 累加数是一个字符串，组成它的数字可以形成累加序列。 一个有效的累加序列必须至少包含 3 个数。 除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。 给定一个只包含数字 ‘0’-‘9’ 的字符串，编写一个算法来判断给定输入是否是累加数。 说明: 累加序列里的数不会以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。 示例 1: 输入: \"112358\"\r输出: true 解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\r示例 2: 输入: \"199100","date":"2015-11-02","objectID":"/leetcode/0306/:1:0","tags":null,"title":"0306：累加数（★★）","uri":"/leetcode/0306/"},{"categories":null,"content":"分析 类似 0093，回溯即可。 ","date":"2015-11-02","objectID":"/leetcode/0306/:2:0","tags":null,"title":"0306：累加数（★★）","uri":"/leetcode/0306/"},{"categories":null,"content":"解答 def isAdditiveNumber(self, num: str) -\u003e bool: def dfs(i): if len(path) \u003e= 3 and path[-1] != path[-2] + path[-3]: return False if i == n: return len(path) \u003e 2 for j in range(i+1, n + 1 if num[i] != '0' else i+2): path.append(int(num[i:j])) if dfs(j): return True path.pop() return False path, n = [","date":"2015-11-02","objectID":"/leetcode/0306/:3:0","tags":null,"title":"0306：累加数（★★）","uri":"/leetcode/0306/"},{"categories":null,"content":"题目 给定一个二维矩阵 matrix，以下类型的多个请求： 计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。 实现 NumMatrix 类： NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化 int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。 示例 1： 输入: [\"NumMatrix\",\"sumRegion\",\"sumRegion\"","date":"2015-10-31","objectID":"/leetcode/0304/:1:0","tags":null,"title":"0304：二维区域和检索 - 矩阵不可变（★★）","uri":"/leetcode/0304/"},{"categories":null,"content":"分析 0303 的升级版，需要用二维前缀和。 令 pre[i][j] 代表 sum(matrix[r][c] for r in range(i) for c in range(j))，那么： sumRegion(r1, c1, r2, c2) = pre[r2+1][c2+1]-pre[r1][c2+1]-pre[r2+1][c1]+pre[r1][c1]\r","date":"2015-10-31","objectID":"/leetcode/0304/:2:0","tags":null,"title":"0304：二维区域和检索 - 矩阵不可变（★★）","uri":"/leetcode/0304/"},{"categories":null,"content":"解答 class NumMatrix: def __init__(self, matrix: List[List[int]]): self.pre = [list(accumulate((0,)+col)) for col in zip(*matrix)] self.pre = [list(accumulate((0,)+col)) for col in zip(*self.pre)] def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -\u003e int: return self.pre[row2+1][col2+1]-s","date":"2015-10-31","objectID":"/leetcode/0304/:3:0","tags":null,"title":"0304：二维区域和检索 - 矩阵不可变（★★）","uri":"/leetcode/0304/"},{"categories":null,"content":"题目 给定一个整数数组 nums，处理以下类型的多个查询: 计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left \u003c= right 实现 NumArray 类： NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ， 包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + … + nums[right] ) 示例 1： 输入：\r[\"N","date":"2015-10-30","objectID":"/leetcode/0303/:1:0","tags":null,"title":"0303：区域和检索 - 数组不可变（★）","uri":"/leetcode/0303/"},{"categories":null,"content":"分析 典型的前缀和问题。 ","date":"2015-10-30","objectID":"/leetcode/0303/:2:0","tags":null,"title":"0303：区域和检索 - 数组不可变（★）","uri":"/leetcode/0303/"},{"categories":null,"content":"解答 class NumArray: def __init__(self, nums: List[int]): self.pre = list(accumulate([0]+nums)) def sumRange(self, left: int, right: int) -\u003e int: return self.pre[right+1] - self.pre[left] 76 ms ","date":"2015-10-30","objectID":"/leetcode/0303/:3:0","tags":null,"title":"0303：区域和检索 - 数组不可变（★）","uri":"/leetcode/0303/"},{"categories":null,"content":"题目 给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。 返回所有可能的结果。答案可以按 任意顺序 返回。 示例 1： 输入：s = \"()())()\"\r输出：[\"(())()\",\"()()()\"]\r示例 2： 输入：s = \"(a)())()\"\r输出：[\"(a())()\",\"(a)()()\"]\r示例 3： 输入：s = \")(\"\r输出：[\"\"]\r提示： 1 \u003c= s.length \u003c= 25 s 由小写英文字母以及括号 ‘(’ 和 ‘)’ 组成 s 中至多含 20 个括号 ","date":"2015-10-28","objectID":"/leetcode/0301/:1:0","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"分析 ","date":"2015-10-28","objectID":"/leetcode/0301/:2:0","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"#1 1249 的升级版，但要求所有最少删除数的方案。 考虑先得到最少删除数 k，然后遍历所有删除 k 个括号的子序列，判断是否有效即可。 def removeInvalidParentheses(self, s: str) -\u003e List[str]: def cal(s): ans, stack = 0, [] for char in s: if char == '(': stack.append(char) elif char == ')': if stack: stack.pop() else: ans += 1 return ans + len(stack) ss = {s} for ","date":"2015-10-28","objectID":"/leetcode/0301/:2:1","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"#2 注意到计算最少删除数时，其实只关心栈的长度。所以可以用一个变量来维护，而无需真正地进行栈操作。 ","date":"2015-10-28","objectID":"/leetcode/0301/:2:2","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"解答 def removeInvalidParentheses(self, s: str) -\u003e List[str]: def cal(s): ans, size = 0, 0 for char in s: size += 1 if char == '(' else -1 if char == ')' else 0 if size \u003c 0: ans, size = ans+1, 0 return ans + size ss = {s} for _ in range(cal(s)): ss = {sub[:i]+sub[i+1:] for sub in ss for i in range(len","date":"2015-10-28","objectID":"/leetcode/0301/:3:0","tags":null,"title":"0301：删除无效的括号（★★）","uri":"/leetcode/0301/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。 例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18]\r输出：4\r解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\r示例 2： 输入：nums = [0,1,0,3,2,3]\r输出：4\r示例 3： 输入：nums = [7,7,7,7,7,7,7]\r输出：1\r提示： 1 \u003c= nums.length \u003c= 2500 -10^4","date":"2015-10-27","objectID":"/leetcode/0300/:1:0","tags":null,"title":"0300：最长递增子序列（★★★）","uri":"/leetcode/0300/"},{"categories":null,"content":"分析 ","date":"2015-10-27","objectID":"/leetcode/0300/:2:0","tags":null,"title":"0300：最长递增子序列（★★★）","uri":"/leetcode/0300/"},{"categories":null,"content":"#1 子序列/子数组相关的问题容易想到遍历结尾位置 j，分别找最值。 令 dp[j] 代表结尾位置 j 的最长递增子序列长度。那么： dp[j] = 1 + max(dp[i] for i in range(j) if nums[i]\u003cnums[j])\r递推即可。 def lengthOfLIS(self, nums: List[int]) -\u003e int: n = len(nums) dp = [0] * n for j in range(n): dp[j] = 1 + max([dp[i] for i in range(j) if nums[i]\u003cnums[j]], default=0) r","date":"2015-10-27","objectID":"/leetcode/0300/:2:1","tags":null,"title":"0300：最长递增子序列（★★★）","uri":"/leetcode/0300/"},{"categories":null,"content":"#2 本题还有个很经典的优化解法： 假如 dp[i1]==dp[i2] 且 nums[i1]\u003cnums[i2]，那么在递推式中只需要考虑 i1 而不用考虑 i2 那么令 A[y] 代表使 dp[i]==y 的最小 nums[i]，问题转为求 max(y for y in range(j) if A[y]\u003cnums[j]) 注意到 A 必然是严格递增的，因此可以二分查找最大的 x 而得到 dp[j] 后，只需要更新 A[y+1] = nums[j] 即可维护 A 因此每轮递推只需 O(logN)，总的时间复杂度 O(N*logN) 额外的，令 A 初始为空数组并动态维护，那么最终 len(A) ","date":"2015-10-27","objectID":"/leetcode/0300/:2:2","tags":null,"title":"0300：最长递增子序列（★★★）","uri":"/leetcode/0300/"},{"categories":null,"content":"解答 def lengthOfLIS(self, nums: List[int]) -\u003e int: A = [] for num in nums: j = bisect_left(A, num) A[j:j + 1] = [num] return len(A) 40 ms ","date":"2015-10-27","objectID":"/leetcode/0300/:3:0","tags":null,"title":"0300：最长递增子序列（★★★）","uri":"/leetcode/0300/"},{"categories":null,"content":"题目 你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下： 写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示： 猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛）， 有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说， 这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。 给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。 提示的格式为 “xAyB” ，x 是公牛个数， y 是奶牛个数，A 表示公牛，B 表示奶牛。 请注意秘密数","date":"2015-10-26","objectID":"/leetcode/0299/:1:0","tags":null,"title":"0299：猜数字游戏（★★）","uri":"/leetcode/0299/"},{"categories":null,"content":"分析 计算 “Bulls” 很简单，但 “Cows” 较麻烦。可以考虑先计算 Bulls+Cows，即数字正确的个数， 再减去 Bulls 即是 Cows。 ","date":"2015-10-26","objectID":"/leetcode/0299/:2:0","tags":null,"title":"0299：猜数字游戏（★★）","uri":"/leetcode/0299/"},{"categories":null,"content":"解答 def getHint(self, secret: str, guess: str) -\u003e str: A = sum(s==g for s,g in zip(secret, guess)) C = sum((Counter(secret)\u0026Counter(guess)).values()) return '%dA%dB' % (A, C-A) 48 ms ","date":"2015-10-26","objectID":"/leetcode/0299/:3:0","tags":null,"title":"0299：猜数字游戏（★★）","uri":"/leetcode/0299/"},{"categories":null,"content":"题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中， 同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 示例 1： 输入：root = [1,2,3,null,nul","date":"2015-10-24","objectID":"/leetcode/0297/:1:0","tags":null,"title":"0297：二叉树的序列化与反序列化（★★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"分析 ","date":"2015-10-24","objectID":"/leetcode/0297/:2:0","tags":null,"title":"0297：二叉树的序列化与反序列化（★★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"#1 最简单粗暴的是 json 做法， 将树转为多重字典，用 json 序列化/反序列化。 class Codec: def serialize(self, root): def dfs(node): if not node: return 'None' return {'val': node.val, 'left':dfs(node.left), 'right':dfs(node.right) } return json.dumps(dfs(root)) def deserialize(self, data): def dfs(data): if data=='None': return N","date":"2015-10-24","objectID":"/leetcode/0297/:2:1","tags":null,"title":"0297：二叉树的序列化与反序列化（★★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"#2 也可以用树的遍历列表来对应，空节点用 ‘#’ 表示即可。 这里采用前序遍历： 序列化时，递归地拼接遍历列表。 反序列化时，从遍历列表 Q 中弹出第一个元素作为 root，然后递归地构建左右子树。 遇到空节点时就返回上一层递归即可。 ","date":"2015-10-24","objectID":"/leetcode/0297/:2:2","tags":null,"title":"0297：二叉树的序列化与反序列化（★★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"解答 class Codec: def serialize(self, root): def dfs(node): if not node: return '#' return '%d,%s,%s' % (node.val, dfs(node.left), dfs(node.right)) return dfs(root) def deserialize(self, data): def dfs(): val = Q.popleft() return None if val=='#' else TreeNode(val, dfs(), dfs()) Q = deque(data.split('","date":"2015-10-24","objectID":"/leetcode/0297/:3:0","tags":null,"title":"0297：二叉树的序列化与反序列化（★★★）","uri":"/leetcode/0297/"},{"categories":null,"content":"题目 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例： addNum(1)\raddNum(2)\rfindMedian() -\u003e 1.5\raddNum(3) findMedian() -\u003e 2\r进阶: 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法","date":"2015-10-22","objectID":"/leetcode/0295/:1:0","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"分析 ","date":"2015-10-22","objectID":"/leetcode/0295/:2:0","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"#1 考虑维护一个有序集合，根据中间位置的一个数或两个数即可得到中位数。 要进行插入、访问的操作，考虑用 SortedList，都能在 O(logN) 时间内完成。 class MedianFinder: def __init__(self): from sortedcontainers import SortedList self.sl = SortedList() def addNum(self, num: int) -\u003e None: self.sl.add(num) def findMedian(self) -\u003e float: n = len(self.sl) return (self.","date":"2015-10-22","objectID":"/leetcode/0295/:2:1","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"#2 也可以用双堆维护： 用两个堆 low、high 分别维护较小的一半和较大的一半 low 为大顶堆，high 为小顶堆，并且保证 len(low)\u003e=len(high) addNum 时 先将元素添加到 low 中，弹出堆顶并添加到 high 中 如果 len(low)\u003clen(high)，就再弹出 high 堆顶添加到 low 中 findMedian 时 若 len(low)==len(high)，中位数等于 (max(low)+min(high))//2 若 len(low)\u003elen(high)，中位数等于 max(low) addNum 时间复杂度 O(logN)，findMedi","date":"2015-10-22","objectID":"/leetcode/0295/:2:2","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"解答 class MedianFinder: def __init__(self): self.low, self.high = [], [] def addNum(self, num: int) -\u003e None: heappush(self.high, -heappushpop(self.low, -num)) if len(self.high) \u003e len(self.low): heappush(self.low, -heappop(self.high)) def findMedian(self) -\u003e float: return (-self.low[0]+self.high[0]) /","date":"2015-10-22","objectID":"/leetcode/0295/:3:0","tags":null,"title":"0295：数据流的中位数（★★）","uri":"/leetcode/0295/"},{"categories":null,"content":"题目 你和你的朋友，两个人一起玩 Nim 游戏： 桌子上有一堆石头。 你们轮流进行自己的回合，你作为先手。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。 如果可以赢，返回 true；否则，返回 false 。 示例 1： 输入：n = 4\r输出：false 解释：如果堆中有 4 块石头，那么你永远不会赢得比赛；\r因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。\r示例 2： 输入：n = 1\r输出：true\r示例 3： 输入：n","date":"2015-10-19","objectID":"/leetcode/0292/:1:0","tags":null,"title":"0292：Nim 游戏（★）","uri":"/leetcode/0292/"},{"categories":null,"content":"分析 经典的博弈： 如果 n 是 4 的倍数，先手必输 因为后手可以保证每一轮共拿走 4 块，最后一轮刚好拿完 如果 n 不是 4 的倍数，先手比赢 因为先手拿走 n%4 块使得 n 变为 4 的倍数，就变为上面的情况了 ","date":"2015-10-19","objectID":"/leetcode/0292/:2:0","tags":null,"title":"0292：Nim 游戏（★）","uri":"/leetcode/0292/"},{"categories":null,"content":"解答 def canWinNim(self, n: int) -\u003e bool: return n % 4 != 0 32 ms ","date":"2015-10-19","objectID":"/leetcode/0292/:3:0","tags":null,"title":"0292：Nim 游戏（★）","uri":"/leetcode/0292/"},{"categories":null,"content":"题目 给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的 每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = \"abba\", str = \"dog cat cat dog\"\r输出: true\r示例 2: 输入:pattern = \"abba\", str = \"dog cat cat fish\"\r输出: false\r示例 3: 输入: pattern = \"aaaa\", str = \"dog cat cat dog\"\r输出: false\r提示: 1 \u003c","date":"2015-10-17","objectID":"/leetcode/0290/:1:0","tags":null,"title":"0290：单词规律（★）","uri":"/leetcode/0290/"},{"categories":null,"content":"分析 类似 0205，注意先判断 s 的单词数和 pattern 长度是否相同即可。 ","date":"2015-10-17","objectID":"/leetcode/0290/:2:0","tags":null,"title":"0290：单词规律（★）","uri":"/leetcode/0290/"},{"categories":null,"content":"解答 def wordPattern(self, pattern: str, s: str) -\u003e bool: A, B = pattern, s.split() return len(A)==len(B) and len(set(A))==len(set(B))==len(set(zip(A, B))) 32 ms ","date":"2015-10-17","objectID":"/leetcode/0290/:3:0","tags":null,"title":"0290：单词规律（★）","uri":"/leetcode/0290/"},{"categories":null,"content":"题目 根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的 细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； ","date":"2015-10-16","objectID":"/leetcode/0289/:1:0","tags":null,"title":"0289：生命游戏（★★）","uri":"/leetcode/0289/"},{"categories":null,"content":"分析 ","date":"2015-10-16","objectID":"/leetcode/0289/:2:0","tags":null,"title":"0289：生命游戏（★★）","uri":"/leetcode/0289/"},{"categories":null,"content":"#1 先写出额外数组的方法。根据规则，下一个状态是存活只有两种情况： 周围加自身共有三个活细胞 周围加自身共有四个活细胞，且当前状态是存活 def gameOfLife(self, board: List[List[int]]) -\u003e None: m, n = len(board), len(board[0]) tmp = [[0] * n for _ in range(m)] for i, j in product(range(m), range(n)): cnt = 0 for x, y in product([i - 1, i, i + 1], [j - 1, j, j + 1]): i","date":"2015-10-16","objectID":"/leetcode/0289/:2:1","tags":null,"title":"0289：生命游戏（★★）","uri":"/leetcode/0289/"},{"categories":null,"content":"#2 要求原地算法，考虑用 board 自身来保存信息。 最简单的就是增加一位 bit 来表示下一轮状态，于是遍历中可能遇到的标志有： 0，当前状态为死，下一轮状态未知 1，当前状态为活，下一轮状态未知 10，当前状态为死，下一轮状态为活 11，当前状态为活，下一轮状态为活 那么遍历中 值%2 即是当前状态，遍历完后 值//2 即是下一轮状态。 ","date":"2015-10-16","objectID":"/leetcode/0289/:2:2","tags":null,"title":"0289：生命游戏（★★）","uri":"/leetcode/0289/"},{"categories":null,"content":"解答 def gameOfLife(self, board: List[List[int]]) -\u003e None: m, n = len(board), len(board[0]) for i, j in product(range(m), range(n)): cnt = 0 for x, y in product([i - 1, i, i + 1], [j - 1, j, j + 1]): if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n and board[x][y] % 2: cnt += 1 board[i][j] += 2 if cnt == 3 or (cnt == 4 a","date":"2015-10-16","objectID":"/leetcode/0289/:3:0","tags":null,"title":"0289：生命游戏（★★）","uri":"/leetcode/0289/"},{"categories":null,"content":"题目 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。 你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。 示例 1： 输入：nums = [1,3,4,2,2]\r输出：2\r示例 2： 输入：nums = [3,1,3,4,2]\r输出：3\r示例 3： 输入：nums = [1,1]\r输出：1\r示例 4： 输入：nums = [1,1,2]\r输出：1\r提示： 1 \u003c= n \u003c= 10^5 nums.length == n +","date":"2015-10-14","objectID":"/leetcode/0287/:1:0","tags":null,"title":"0287：寻找重复数（★★★）","uri":"/leetcode/0287/"},{"categories":null,"content":"分析 ","date":"2015-10-14","objectID":"/leetcode/0287/:2:0","tags":null,"title":"0287：寻找重复数（★★★）","uri":"/leetcode/0287/"},{"categories":null,"content":"#1 以重复的数 x 为界，任意 y\u003cx 必然满足 [1,y] 范围内的个数 \u003c= y，任意 y\u003e=x 则反之。 因此二分查找第一个满足 [1,y] 范围内的个数 \u003e y 的 y 即可。 def findDuplicate(self, nums: List[int]) -\u003e int: self.__class__.__getitem__ = lambda self, x: sum(num\u003c=x for num in nums)\u003ex return bisect_left(self, True, 1, len(nums)-1) 时间复杂度 O(N*logN)，384 ms ","date":"2015-10-14","objectID":"/leetcode/0287/:2:1","tags":null,"title":"0287：寻找重复数（★★★）","uri":"/leetcode/0287/"},{"categories":null,"content":"#2 要求 O(N)，有个非常巧妙的方法： 将 nums 看作是链表，nums[i] 表示节点 i 指向节点 nums[i] 那么从节点 0 出发的链表必然存在一个环，入环的节点即是所求 问题便等价于 0142 了 ","date":"2015-10-14","objectID":"/leetcode/0287/:2:2","tags":null,"title":"0287：寻找重复数（★★★）","uri":"/leetcode/0287/"},{"categories":null,"content":"解答 def findDuplicate(self, nums: List[int]) -\u003e int: slow = fast = 0 while True: slow, fast = nums[slow], nums[nums[fast]] if slow == fast: break slow = 0 while slow != fast: slow, fast = nums[slow], nums[fast] return slow 时间复杂度 O(N)，108 ms ","date":"2015-10-14","objectID":"/leetcode/0287/:3:0","tags":null,"title":"0287：寻找重复数（★★★）","uri":"/leetcode/0287/"},{"categories":null,"content":"*附加 如果可以修改数组，那么还有种时间 O(N)，空间 O(1) 的做法： 遍历到值 x 时，将位置 abs(x) 的值标记为负数 若位置 abs(x) 的值已经被标记为负数，abs(x) 即为所求 def findDuplicate(self, nums: List[int]) -\u003e int: for x in nums: if nums[abs(x)]\u003c0: return abs(x) nums[abs(x)] *= -1 120 ms ","date":"2015-10-14","objectID":"/leetcode/0287/:4:0","tags":null,"title":"0287：寻找重复数（★★★）","uri":"/leetcode/0287/"},{"categories":null,"content":"题目 请你在设计一个迭代器，在集成现有迭代器拥有的 hasNext 和 next 操作的基础上，还额外支持 peek 操作。 实现 PeekingIterator 类： PeekingIterator(Iterator nums) 使用指定整数迭代器 nums 初始化迭代器。 int next() 返回数组中的下一个元素，并将指针移动到下个元素处。 bool hasNext() 如果数组中存在下一个元素，返回 true ；否则，返回 false 。 int peek() 返回数组中的下一个元素，但 不 移动指针。 注意：每种语言可能有不同的构造函数和迭代器 Iterator，但均支持 int ","date":"2015-10-11","objectID":"/leetcode/0284/:1:0","tags":null,"title":"0284：顶端迭代器（★★）","uri":"/leetcode/0284/"},{"categories":null,"content":"分析 peek 必须获得下一个元素，但不能移动指针。 因此考虑用缓存保存已看过但还没移到的元素，每次 next/hasNext/peek 时先看缓存，没有再调用迭代器。 ","date":"2015-10-11","objectID":"/leetcode/0284/:2:0","tags":null,"title":"0284：顶端迭代器（★★）","uri":"/leetcode/0284/"},{"categories":null,"content":"解答 class PeekingIterator: def __init__(self, iterator): self.it = iterator self.cache = None def peek(self): self.cache = self.cache or self.it.next() return self.cache def next(self): res = self.cache or self.it.next() self.cache = None return res def hasNext(self): return bool(self.cache) or self.","date":"2015-10-11","objectID":"/leetcode/0284/:3:0","tags":null,"title":"0284：顶端迭代器（★★）","uri":"/leetcode/0284/"},{"categories":null,"content":"题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 输入: nums = [0,1,0,3,12]\r输出: [1,3,12,0,0]\r示例 2: 输入: nums = [0]\r输出: [0]\r提示: 1 \u003c= nums.length \u003c= 10^4 -2^31 \u003c= nums[i] \u003c= 2^31 - 1 进阶：你能尽量减少完成的操作次数吗？ ","date":"2015-10-10","objectID":"/leetcode/0283/:1:0","tags":null,"title":"0283：移动零（★）","uri":"/leetcode/0283/"},{"categories":null,"content":"分析 类似 0027 ，等价于移除前面的 0 ，再在后面补 0 即可。 ","date":"2015-10-10","objectID":"/leetcode/0283/:2:0","tags":null,"title":"0283：移动零（★）","uri":"/leetcode/0283/"},{"categories":null,"content":"解答 def moveZeroes(self, nums: List[int]) -\u003e None: i = 0 for num in nums: if num != 0: nums[i] = num i += 1 nums[i:] = [0] * (len(nums)-i) 40 ms ","date":"2015-10-10","objectID":"/leetcode/0283/:3:0","tags":null,"title":"0283：移动零（★）","uri":"/leetcode/0283/"},{"categories":null,"content":"题目 给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ， 在 num 的数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回 所有 能够得到 target 的表达式。 注意，返回表达式中的操作数 不应该 包含前导零。 示例 1: 输入: num = \"123\", target = 6\r输出: [\"1+2+3\", \"1*2*3\"] 解释: “1*2*3” 和 “1+2+3” 的值都是6。\r示例 2: 输入: num = \"232\", target = 8\r输出: [\"2*3+2\", \"2+3*2\"]\r解释: “2*3+2” 和 “2+3*2” 的值都是8。\r","date":"2015-10-09","objectID":"/leetcode/0282/:1:0","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"分析 ","date":"2015-10-09","objectID":"/leetcode/0282/:2:0","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"#1 最简单的就是遍历每一种情况，判断是否等于 target。 可以用 dfs，每一步添加 +、-、* 或空。注意不能有前置 0。 def addOperators(self, num: str, target: int) -\u003e List[str]: def dfs(i, exp): if i == n: if eval(exp) == target: res.append(exp) return ops = ['+','-','*',''] if not exp: ops = [''] elif exp[-2:] in ['0','+0','-0','*0']: ops = '+-*' fo","date":"2015-10-09","objectID":"/leetcode/0282/:2:1","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"2 考虑在遍历时维护当前表达式的值，节省时间。 为了递推 exp+op+num[i:j] 的值，需要知道 exp 计算后的值 val exp 计算了乘法之后的最后一个数（包括正负号） prev 因此 dfs 时添加两个传递的变量。 ","date":"2015-10-09","objectID":"/leetcode/0282/:2:2","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"解答 def addOperators(self, num: str, target: int) -\u003e List[str]: def dfs(i, exp, prev, val): if i == n: if val == target: res.append(exp) return for j in range(i+1, i+2 if num[i] == '0' else n+1): s = num[i:j] x = int(s) if not exp: dfs(j, s, x, x) else: dfs(j, exp+'+'+s, x, val+x) dfs(j, exp+'-'+s, -","date":"2015-10-09","objectID":"/leetcode/0282/:3:0","tags":null,"title":"0282：给表达式添加运算符（★★）","uri":"/leetcode/0282/"},{"categories":null,"content":"题目 你给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。 你需要让组成和的完全平方数的个数最少。 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。 例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 输入：n = 12\r输出：3 解释：12 = 4 + 4 + 4\r示例 2： 输入：n = 13\r输出：2\r解释：13 = 4 + 9\r提示：1 \u003c= n \u003c= 10^4 ","date":"2015-10-06","objectID":"/leetcode/0279/:1:0","tags":null,"title":"0279：完全平方数（★）","uri":"/leetcode/0279/"},{"categories":null,"content":"分析 典型的线性 dp，按分割递归即可。 ","date":"2015-10-06","objectID":"/leetcode/0279/:2:0","tags":null,"title":"0279：完全平方数（★）","uri":"/leetcode/0279/"},{"categories":null,"content":"解答 def numSquares(self, n: int) -\u003e int: dp = [0] * (n+1) for i in range(1, n+1): dp[i] = 1 + min(dp[i - j * j] for j in range(1, int(sqrt(i)) + 1)) return dp[-1] 时间复杂度 $O(N*\\sqrt N)$，1648 ms ","date":"2015-10-06","objectID":"/leetcode/0279/:3:0","tags":null,"title":"0279：完全平方数（★）","uri":"/leetcode/0279/"},{"categories":null,"content":"*附加 根据数学上的 四平方和定理 ，每个正整数均可表示为4个整数的平方和。 因此只需逐层遍历 i 个正整数平方的和，找到 n 即可。 def numSquares(self, n: int) -\u003e int: queue, vis = deque([(0, 0)]), {0} while True: u, step = queue.popleft() for j in range(1, int(sqrt(n-u))+1): v = u + j*j if v not in vis: if v == n: return step+1 vis.add(v) queue.append((v, step","date":"2015-10-06","objectID":"/leetcode/0279/:4:0","tags":null,"title":"0279：完全平方数（★）","uri":"/leetcode/0279/"},{"categories":null,"content":"题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。 由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。 实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 1： 输入：n = 5, bad = 4\r输出：4\r解释：\r调用 isBadVersion(3) -\u003e fals","date":"2015-10-05","objectID":"/leetcode/0278/:1:0","tags":null,"title":"0278：第一个错误的版本","uri":"/leetcode/0278/"},{"categories":null,"content":"分析 以出错版本 bad 为界，前面的都是正确的，后面的都是错的。所以可以二分查找。 ","date":"2015-10-05","objectID":"/leetcode/0278/:2:0","tags":null,"title":"0278：第一个错误的版本","uri":"/leetcode/0278/"},{"categories":null,"content":"解答 def firstBadVersion(self, n): self.__class__.__getitem__ = lambda self, i: isBadVersion(i) return bisect_left(self, True, 1, n) 32 ms ","date":"2015-10-05","objectID":"/leetcode/0278/:3:0","tags":null,"title":"0278：第一个错误的版本","uri":"/leetcode/0278/"},{"categories":null,"content":"题目 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数， citations 已经按照 升序排列 。计算并返回该研究者的 h 指数。 h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他 （她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文 每篇被引用次数 不超过 h 次。 提示：如果 h 有多种可能的值，h 指数 是其中最大的那个。 请你设计并实现对数时间复杂度的算法解决此问题。 示例 1： 输入：citations = [0,1,3,","date":"2015-10-02","objectID":"/leetcode/0275/:1:0","tags":null,"title":"0275：H 指数 II（★）","uri":"/leetcode/0275/"},{"categories":null,"content":"分析 类似 0274，找第一个满足 n-i\u003c=citations[i] 的 i 即可。 本题已排好序了，由于单调性，可以二分查找。 ","date":"2015-10-02","objectID":"/leetcode/0275/:2:0","tags":null,"title":"0275：H 指数 II（★）","uri":"/leetcode/0275/"},{"categories":null,"content":"解答 def hIndex(self, citations: List[int]) -\u003e int: n = len(citations) self.__class__.__getitem__ = lambda self, i: n-i\u003c=citations[i] return n - bisect_left(self, True, 0, n) 时间复杂度 O(log N)，44 ms ","date":"2015-10-02","objectID":"/leetcode/0275/:3:0","tags":null,"title":"0275：H 指数 II（★）","uri":"/leetcode/0275/"},{"categories":null,"content":"题目 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。 计算并返回该研究者的 h 指数。 根据维基百科上 h 指数的定义：h 代表“高引用次数”，一名科研人员的 h指数是指他（她） 的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。 且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。 如果 h 有多种可能的值，h 指数 是其中最大的那个。 示例 1： 输入：citations = [3,0,6,1,5]\r输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5","date":"2015-10-01","objectID":"/leetcode/0274/:1:0","tags":null,"title":"0274：H 指数（★）","uri":"/leetcode/0274/"},{"categories":null,"content":"分析 将 citations 排序后，citations[i:] 这 n-i 篇论文的最低引用数是 citations[i]。 因此遍历找到第一个满足 n-i\u003c=citations[i] 的 i 即可。 ","date":"2015-10-01","objectID":"/leetcode/0274/:2:0","tags":null,"title":"0274：H 指数（★）","uri":"/leetcode/0274/"},{"categories":null,"content":"解答 def hIndex(self, citations: List[int]) -\u003e int: n = len(citations) for i, c in enumerate(sorted(citations)): if n-i \u003c= c: return n-i return 0 时间复杂度 O(N*logN)，28 ms ","date":"2015-10-01","objectID":"/leetcode/0274/:3:0","tags":null,"title":"0274：H 指数（★）","uri":"/leetcode/0274/"},{"categories":null,"content":"题目 将非负整数 num 转换为其对应的英文表示。 示例 1： 输入：num = 123\r输出：\"One Hundred Twenty Three\"\r示例 2： 输入：num = 12345\r输出：\"Twelve Thousand Three Hundred Forty Five\"\r示例 3： 输入：num = 1234567\r输出：\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\r提示： 0 \u003c= num \u003c= 2^31 - 1 ","date":"2015-09-30","objectID":"/leetcode/0273/:1:0","tags":null,"title":"0273：整数转换英文表示（★★★）","uri":"/leetcode/0273/"},{"categories":null,"content":"分析 容易看出用递归，但要注意细节处理： 当 num 为 0 时要返回 Zero 其它数（比如100）递归求 0 的表示时应该返回空 为了方便处理空格，dfs 返回元组形式，主函数再拼接 ","date":"2015-09-30","objectID":"/leetcode/0273/:2:0","tags":null,"title":"0273：整数转换英文表示（★★★）","uri":"/leetcode/0273/"},{"categories":null,"content":"解答 def numberToWords(self, num: int) -\u003e str: def dfs(num): if num == 0: return () for unit, exp in zip([10**9, 10**6, 10**3, 10**2], ['Billion', 'Million', 'Thousand', 'Hundred']): if num \u003e= unit: return dfs(num//unit)+(exp,)+dfs(num%unit) return (ones[num-1],) if num \u003c 20 else (tens[num//10-2],)+df","date":"2015-09-30","objectID":"/leetcode/0273/:3:0","tags":null,"title":"0273：整数转换英文表示（★★★）","uri":"/leetcode/0273/"},{"categories":null,"content":"题目 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 示例 1： 输入：nums = [3,0,1]\r输出：2\r解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，\r因为它没有出现在 nums 中。\r示例 2： 输入：nums = [0,1]\r输出：2\r解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，\r因为它没有出现在 nums 中。\r示例 3： 输入：nums = [9,6,4,2,3,5,7,0,1]\r输出：8\r解释：n = 9，","date":"2015-09-25","objectID":"/leetcode/0268/:1:0","tags":null,"title":"0268：丢失的数字","uri":"/leetcode/0268/"},{"categories":null,"content":"分析 直接算比原本的总和 sum(range(n+1)) 少了多少即可。 ","date":"2015-09-25","objectID":"/leetcode/0268/:2:0","tags":null,"title":"0268：丢失的数字","uri":"/leetcode/0268/"},{"categories":null,"content":"解答 def missingNumber(self, nums: List[int]) -\u003e int: return sum(range(len(nums)+1)) - sum(nums) 32 ms ","date":"2015-09-25","objectID":"/leetcode/0268/:3:0","tags":null,"title":"0268：丢失的数字","uri":"/leetcode/0268/"},{"categories":null,"content":"题目 给你一个整数 n ，请你找出并返回第 n 个 丑数 。 丑数 就是只包含质因数 2、3 和/或 5 的正整数。 示例 1： 输入：n = 10\r输出：12\r解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。\r示例 2： 输入：n = 1\r输出：1\r解释：1 通常被视为丑数。\r提示：1 \u003c= n \u003c= 1690 ","date":"2015-09-21","objectID":"/leetcode/0264/:1:0","tags":null,"title":"0264：丑数 II（★★★）","uri":"/leetcode/0264/"},{"categories":null,"content":"分析 0263 升级版，有个巧妙的 dp 方法。 显然后面的丑数必然是前面的某个丑数乘 2/3/5 得到。令 dp[n] 代表第 n 个丑数，那么： dp[n]=min(dp[j]*p for j in range(n) for p in [2,3,5] if dp[j]*p\u003edp[n-1])\r观察发现，对于 p=2/3/5，只需要考虑第一个使得 dp[j]*p\u003edp[n-1] 的 j。 于是用 A[p] 维护第一个使得 dp[j]*p\u003edp[n-1] 的 j，递推式转为： dp[n]=min(dp[A[p]]*p for p in [2,3,5])\r维护 A[p] 很简单，当 dp[A[p]","date":"2015-09-21","objectID":"/leetcode/0264/:2:0","tags":null,"title":"0264：丑数 II（★★★）","uri":"/leetcode/0264/"},{"categories":null,"content":"解答 def nthUglyNumber(self, n: int) -\u003e int: dp, A = [1] * n, defaultdict(int) for i in range(1, n): dp[i] = min(dp[A[p]]*p for p in [2,3,5]) for p in [2,3,5]: if dp[A[p]]*p == dp[i]: A[p] += 1 return dp[-1] 时间复杂度 O(N)，224 ms ","date":"2015-09-21","objectID":"/leetcode/0264/:3:0","tags":null,"title":"0264：丑数 II（★★★）","uri":"/leetcode/0264/"},{"categories":null,"content":"题目 丑数 就是只包含质因数 2、3 和 5 的正整数。 给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。 示例 1： 输入：n = 6\r输出：true\r解释：6 = 2 × 3\r示例 2： 输入：n = 1\r输出：true\r解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。\r示例 3： 输入：n = 14\r输出：false\r解释：14 不是丑数，因为它包含了另外一个质因数 7 。\r提示： -2^31 \u003c= n \u003c= 2^31-1 ","date":"2015-09-20","objectID":"/leetcode/0263/:1:0","tags":null,"title":"0263：丑数（★★）","uri":"/leetcode/0263/"},{"categories":null,"content":"分析 ","date":"2015-09-20","objectID":"/leetcode/0263/:2:0","tags":null,"title":"0263：丑数（★★）","uri":"/leetcode/0263/"},{"categories":null,"content":"#1 去掉所有 2、3、5 的因子，看是否变为 1 即可。 def isUgly(self, n: int) -\u003e bool: if n \u003c= 0: return False for p in [2, 3, 5]: while n % p == 0: n //= p return n == 1 36 ms ","date":"2015-09-20","objectID":"/leetcode/0263/:2:1","tags":null,"title":"0263：丑数（★★）","uri":"/leetcode/0263/"},{"categories":null,"content":"#2 丑数必然是 $2^{a}*3^{b}*5^{c}$ 的形式。 而所给范围内的丑数，必然有 a\u003c=30，b\u003c=19，c\u003c=13。 因此丑数等价于是 $2^{30}*3^{19}*5^{13}$ 的因数。 ","date":"2015-09-20","objectID":"/leetcode/0263/:2:2","tags":null,"title":"0263：丑数（★★）","uri":"/leetcode/0263/"},{"categories":null,"content":"解答 def isUgly(self, n: int) -\u003e bool: return n \u003e 0 and pow(2,30)*pow(3,19)*pow(5,13)%n == 0 36 ms ","date":"2015-09-20","objectID":"/leetcode/0263/:3:0","tags":null,"title":"0263：丑数（★★）","uri":"/leetcode/0263/"},{"categories":null,"content":"题目 SQL架构 表：Trips\r+-------------+----------+\r| Column Name | Type |\r+-------------+----------+\r| id | int |\r| client_id | int |\r| driver_id | int |\r| city_id | int |\r| status | enum |\r| request_at | date | +-------------+----------+\rid 是这张表的主键。\r这张表中存所有出租车的行程信息。每段行程有唯一 id ，其中 client_id 和 driver_id 是 U","date":"2015-09-19","objectID":"/leetcode/0262/:1:0","tags":null,"title":"0262：行程和用户（★★★）","uri":"/leetcode/0262/"},{"categories":null,"content":"分析 先通过连接筛出非禁止用户的请求，然后按日期分组，求每组的取消率即可。 ","date":"2015-09-19","objectID":"/leetcode/0262/:2:0","tags":null,"title":"0262：行程和用户（★★★）","uri":"/leetcode/0262/"},{"categories":null,"content":"解答 select request_at as Day, round(avg(status!='completed'), 2) as 'Cancellation Rate' from Trips a inner join Users b on a.client_id = b.users_id and b.banned = 'No' inner join Users c on a.driver_id = c.users_id and c.banned = 'No' where request_at between '2013-10-01' and '2013-10-03' group by re","date":"2015-09-19","objectID":"/leetcode/0262/:3:0","tags":null,"title":"0262：行程和用户（★★★）","uri":"/leetcode/0262/"},{"categories":null,"content":"题目 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。 示例 1： 输入：nums = [1,2,1,3,2,5]\r输出：[3,5]\r解释：[5, 3] 也是有效的答案。\r示例 2： 输入：nums = [-1,0]\r输出：[-1,0]\r示例 3： 输入：nums = [0,1]\r输出：[1,0]\r提示： 2 \u003c= nums.length \u003c= 3 * 10^4 -2^31 \u003c= nums[i] \u003c= 2^31 - 1 除两个只出现一次的整数外，nums 中的其他数字都出现两次 进阶：你的算法应该具有","date":"2015-09-17","objectID":"/leetcode/0260/:1:0","tags":null,"title":"0260：只出现一次的数字 III（★★）","uri":"/leetcode/0260/"},{"categories":null,"content":"分析 ","date":"2015-09-17","objectID":"/leetcode/0260/:2:0","tags":null,"title":"0260：只出现一次的数字 III（★★）","uri":"/leetcode/0260/"},{"categories":null,"content":"#1 0136 升级版，最简单的依然是哈希表。 def singleNumber(self, nums: List[int]) -\u003e List[int]: ct = Counter(nums) return [num for num in nums if ct[num]==1] 44 ms ","date":"2015-09-17","objectID":"/leetcode/0260/:2:1","tags":null,"title":"0260：只出现一次的数字 III（★★）","uri":"/leetcode/0260/"},{"categories":null,"content":"#2 同样有巧妙的位运算方法： 设出现两次的元素是 a、b 将所有数字异或得到 x，显然 x = a^b 在 x 的二进制表示中，任选一个为 1 的位置 i， 按二进制的位置 i 是否为 1 可以将 nums 分为两组 显然 a、b 必然在不同的组，而相同的数必然在同一组 每一组就转为问题 0136 ","date":"2015-09-17","objectID":"/leetcode/0260/:2:2","tags":null,"title":"0260：只出现一次的数字 III（★★）","uri":"/leetcode/0260/"},{"categories":null,"content":"解答 def singleNumber(self, nums: List[int]) -\u003e List[int]: x = reduce(xor, nums) i = len(bin(x))-3 a, b = 0, 0 for num in nums: if num \u0026 (1\u003c\u003ci): a ^= num else: b ^= num return [a, b] 40 ms ","date":"2015-09-17","objectID":"/leetcode/0260/:3:0","tags":null,"title":"0260：只出现一次的数字 III（★★）","uri":"/leetcode/0260/"},{"categories":null,"content":"题目 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。 示例 1: 输入: num = 38\r输出: 2 解释: 各位相加的过程为：\r38 --\u003e 3 + 8 --\u003e 11\r11 --\u003e 1 + 1 --\u003e 2\r由于 2 是一位数，所以返回 2。\r示例 2: 输入: num = 0\r输出: 0\r提示： 0 \u003c= num \u003c= 2^31 - 1 进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？ ","date":"2015-09-15","objectID":"/leetcode/0258/:1:0","tags":null,"title":"0258：各位相加（★）","uri":"/leetcode/0258/"},{"categories":null,"content":"分析 ","date":"2015-09-15","objectID":"/leetcode/0258/:2:0","tags":null,"title":"0258：各位相加（★）","uri":"/leetcode/0258/"},{"categories":null,"content":"#1 模拟即可。 def addDigits(self, num: int) -\u003e int: while num \u003e= 10: num = sum(map(int, str(num))) return num ","date":"2015-09-15","objectID":"/leetcode/0258/:2:1","tags":null,"title":"0258：各位相加（★）","uri":"/leetcode/0258/"},{"categories":null,"content":"#2 由数学知识可知，一个数各位相加模 9 的余数等于该数模 9 的余数。 注意排除 num 为 0 的情况。 ","date":"2015-09-15","objectID":"/leetcode/0258/:2:2","tags":null,"title":"0258：各位相加（★）","uri":"/leetcode/0258/"},{"categories":null,"content":"解答 def addDigits(self, num: int) -\u003e int: return num%9 or min(num, 9) 32 ms ","date":"2015-09-15","objectID":"/leetcode/0258/:3:0","tags":null,"title":"0258：各位相加（★）","uri":"/leetcode/0258/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [1,2,3,null,5]\r输出：[\"1-\u003e2-\u003e5\",\"1-\u003e3\"]\r示例 2： 输入：root = [1]\r输出：[\"1\"]\r提示： 树中节点的数目在范围 [1, 100] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-09-14","objectID":"/leetcode/0257/:1:0","tags":null,"title":"0257：二叉树的所有路径（★）","uri":"/leetcode/0257/"},{"categories":null,"content":"分析 遍历时维护根节点到当前节点的路径，遇到叶子节点就加到结果中即可。 ","date":"2015-09-14","objectID":"/leetcode/0257/:2:0","tags":null,"title":"0257：二叉树的所有路径（★）","uri":"/leetcode/0257/"},{"categories":null,"content":"解答 def binaryTreePaths(self, root: TreeNode) -\u003e List[str]: res, stack = [], [(root, '')] while stack: node, s = stack.pop() if node: s += ('-\u003e' if s else '') + str(node.val) if not node.left and not node.right: res.append(s) stack.extend([(node.right, s), (node.left, s)]) return res 24 ms ","date":"2015-09-14","objectID":"/leetcode/0257/:3:0","tags":null,"title":"0257：二叉树的所有路径（★）","uri":"/leetcode/0257/"},{"categories":null,"content":"题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 示例 1: 输入: s = \"anagram\", t = \"nagaram\"\r输出: true\r示例 2: 输入: s = \"rat\", t = \"car\"\r输出: false\r提示: 1 \u003c= s.length, t.length \u003c= 5 * 10^4 s 和 t 仅包含小写字母 ","date":"2015-08-30","objectID":"/leetcode/0242/:1:0","tags":null,"title":"0242：有效的字母异位词","uri":"/leetcode/0242/"},{"categories":null,"content":"分析 用排序或者计数即可。 ","date":"2015-08-30","objectID":"/leetcode/0242/:2:0","tags":null,"title":"0242：有效的字母异位词","uri":"/leetcode/0242/"},{"categories":null,"content":"解答 def isAnagram(self, s: str, t: str) -\u003e bool: return Counter(s)==Counter(t) 48 ms ","date":"2015-08-30","objectID":"/leetcode/0242/:3:0","tags":null,"title":"0242：有效的字母异位词","uri":"/leetcode/0242/"},{"categories":null,"content":"题目 给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符， 计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。 示例 1： 输入：expression = \"2-1-1\"\r输出：[0,2]\r解释：\r((2-1)-1) = 0 (2-(1-1)) = 2\r示例 2： 输入：expression = \"2*3-4*5\"\r输出：[-34,-14,-10,-10,10]\r解释：\r(2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4","date":"2015-08-29","objectID":"/leetcode/0241/:1:0","tags":null,"title":"0241：为运算表达式设计优先级（★）","uri":"/leetcode/0241/"},{"categories":null,"content":"分析 典型的区间 dp，按最后一步运算的运算符即可递归。 ","date":"2015-08-29","objectID":"/leetcode/0241/:2:0","tags":null,"title":"0241：为运算表达式设计优先级（★）","uri":"/leetcode/0241/"},{"categories":null,"content":"解答 def diffWaysToCompute(self, expression: str) -\u003e List[int]: @lru_cache(None) def dfs(s): res = [] for i, c in enumerate(s): if c in func: res.extend(func[c](x, y) for x in dfs(s[:i]) for y in dfs(s[i+1:])) return res if res else [int(s)] func = {'+': int.__add__, '-': int.__sub__, '*': int.__mul__","date":"2015-08-29","objectID":"/leetcode/0241/:3:0","tags":null,"title":"0241：为运算表达式设计优先级（★）","uri":"/leetcode/0241/"},{"categories":null,"content":"题目 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],\r[18,21,23,26,30]], target = 5\r输出：true\r示例 2： 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],\r[18,21,23,26,30","date":"2015-08-28","objectID":"/leetcode/0240/:1:0","tags":null,"title":"0240：搜索二维矩阵 II（★★）","uri":"/leetcode/0240/"},{"categories":null,"content":"分析 ","date":"2015-08-28","objectID":"/leetcode/0240/:2:0","tags":null,"title":"0240：搜索二维矩阵 II（★★）","uri":"/leetcode/0240/"},{"categories":null,"content":"#1 最简单的就是遍历每行，二分查找即可。 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: return any(target \u003c= row[-1] and row[bisect_left(row, target)]==target for row in matrix) 时间复杂度 O(M*logN)，156ms ","date":"2015-08-28","objectID":"/leetcode/0240/:2:1","tags":null,"title":"0240：搜索二维矩阵 II（★★）","uri":"/leetcode/0240/"},{"categories":null,"content":"#2 上一方法只利用了每行升序的条件，没有利用到每列升序的条件。 先在第 i=m//2 行二分查找到第一个 \u003e=target 的位置 j，如果 matrix[i][j] != target，则： 位于矩形 (\u003c0, 0\u003e, \u003ci, j-1\u003e) 内的元素必然小于 target 位于矩形 (\u003ci, j\u003e, \u003cm-1, n-1\u003e) 内的元素必然大于 target 转为搜索矩形 (\u003ci+1, 0\u003e, \u003cm-1, j-1\u003e) 和矩形 (\u003c0, j\u003e, \u003ci-1, n-1\u003e) 搜索范围至少缩小了一半，递归搜索即可 ","date":"2015-08-28","objectID":"/leetcode/0240/:2:2","tags":null,"title":"0240：搜索二维矩阵 II（★★）","uri":"/leetcode/0240/"},{"categories":null,"content":"解答 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: def help(x0, y0, x1, y1): if x0 \u003e x1 or y0 \u003e y1: return False i = x0 + (x1 - x0) // 2 j = bisect_left(matrix[i], target, y0, y1+1) if j \u003c= y1 and matrix[i][j] == target: return True return help(i+1, y0, x1, j-1) or help(x0, j, ","date":"2015-08-28","objectID":"/leetcode/0240/:3:0","tags":null,"title":"0240：搜索二维矩阵 II（★★）","uri":"/leetcode/0240/"},{"categories":null,"content":"*附加 还有个巧妙的双指针方法。 方法一中每行二分查找 target 得到的位置 j 必然是递减的 初始令 \u003ci,j\u003e=\u003c0,n-1\u003e 遍历每一行，移动 j 直到 matrix[i][j]\u003c=target 即可 j 最多移动 n 步，总共最多 m+n 步即可完成 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: m, n = len(matrix), len(matrix[0]) i, j = 0, n-1 for i in range(m): while j \u003e= 0 and matrix[i][j] ","date":"2015-08-28","objectID":"/leetcode/0240/:4:0","tags":null,"title":"0240：搜索二维矩阵 II（★★）","uri":"/leetcode/0240/"},{"categories":null,"content":"题目 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。 你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 1： 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\r输出：[3,3,5,5,6,7]\r解释：\r滑动窗口的位置 最大值\r--------------- -----\r[1 3 -1] -3 5 3 6 7 3\r1 [3 -1 -3] 5 3 6 7 3\r1 3 [-1 -3 5] 3 6 7 5\r1 3 -1 [-3 5 3] 6 7 5\r1 3 -1 -3 [5 3 ","date":"2015-08-27","objectID":"/leetcode/0239/:1:0","tags":null,"title":"0239：滑动窗口最大值（★★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"分析 ","date":"2015-08-27","objectID":"/leetcode/0239/:2:0","tags":null,"title":"0239：滑动窗口最大值（★★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"#1 考虑维护一个长度 k 的有序窗口，每轮取最大值即可。 窗口要进行插入、删除、取最大值的操作，考虑用有序集合 SortedList，都能在 O(logN) 时间内完成。 def maxSlidingWindow(self, nums: List[int], k: int) -\u003e List[int]: from sortedcontainers import SortedList res, sl = [], SortedList() for j, num in enumerate(nums): sl.add(num) if j \u003e= k: sl.remove(nums[j-k]) if j ","date":"2015-08-27","objectID":"/leetcode/0239/:2:1","tags":null,"title":"0239：滑动窗口最大值（★★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"#2 有个巧妙的单调队列方法。 当窗口内存在 i\u003cj 且 nums[i]\u003c=nums[j] 时，去掉 nums[i] 不影响结果 去掉所有这种情况的元素，剩下的即是一个严格单调递减队列 每轮维护这个队列，队首即是最大值 注意当队首不在窗口内时，要删掉，因此队列还需保存下标 ","date":"2015-08-27","objectID":"/leetcode/0239/:2:2","tags":null,"title":"0239：滑动窗口最大值（★★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"解答 def maxSlidingWindow(self, nums: List[int], k: int) -\u003e List[int]: res, Q = [], deque() for j, y in enumerate(nums): while Q and Q[-1][1] \u003c= y: Q.pop() Q.append((j, y)) if Q[0][0] == j-k: Q.popleft() if j \u003e= k-1: res.append(Q[0][1]) return res 时间复杂度 O(N)，396 ms ","date":"2015-08-27","objectID":"/leetcode/0239/:3:0","tags":null,"title":"0239：滑动窗口最大值（★★★）","uri":"/leetcode/0239/"},{"categories":null,"content":"题目 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 示例 1: 输入: nums = [1,2,3,4]\r输出: [24,12,8,6]\r示例 2: 输入: nums = [-1,1,0,-3,3]\r输出: [0,0,9,0,0]\r提示： 2 \u003c= nums.length \u003c= 10^5 -30 \u003c= nums[i] \u003c= 30 保证 数组 n","date":"2015-08-26","objectID":"/leetcode/0238/:1:0","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"分析 ","date":"2015-08-26","objectID":"/leetcode/0238/:2:0","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"#1 要求不用除法，只能考虑 answer[i] 等于 nums[:i] 的连乘再乘以 nums[i+1:] 的连乘。 于是先遍历得到前缀乘和后缀乘，再相乘即可。 def productExceptSelf(self, nums: List[int]) -\u003e List[int]: pre = list(accumulate([1]+nums[:-1], mul)) suf = list(accumulate([1]+nums[:0:-1], mul))[::-1] return [a*b for a,b in zip(pre, suf)] 48 ms ","date":"2015-08-26","objectID":"/leetcode/0238/:2:1","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"#2 要求常数空间，可以用 answer 先保存前缀乘的信息，再遍历后缀乘并修改。 ","date":"2015-08-26","objectID":"/leetcode/0238/:2:2","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"解答 def productExceptSelf(self, nums: List[int]) -\u003e List[int]: ans, n = [1], len(nums) for i in range(n-1): ans.append(nums[i]*ans[-1]) suf = 1 for i in range(n-1, -1, -1): ans[i] *= suf suf *= nums[i] return ans 52 ms ","date":"2015-08-26","objectID":"/leetcode/0238/:3:0","tags":null,"title":"0238：除自身以外数组的乘积（★）","uri":"/leetcode/0238/"},{"categories":null,"content":"题目 请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意， 你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。 题目数据保证需要删除的节点 不是末尾节点 。 示例 1： 输入：head = [4,5,1,9], node = 5\r输出：[4,1,9]\r解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 1 -\u003e 9\r示例 2： 输入：head = [4,5,1,9], node = 1\r输出：[4,5,9]\r解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 5 -\u003e 9\r提示： ","date":"2015-08-25","objectID":"/leetcode/0237/:1:0","tags":null,"title":"0237：删除链表中的节点（★）","uri":"/leetcode/0237/"},{"categories":null,"content":"分析 要求原地操作，节点为非末尾节点。因此赋值为下一个节点，删除下一个节点即可。 ","date":"2015-08-25","objectID":"/leetcode/0237/:2:0","tags":null,"title":"0237：删除链表中的节点（★）","uri":"/leetcode/0237/"},{"categories":null,"content":"解答 def deleteNode(self, node): node.val = node.next.val node.next = node.next.next 48 ms ","date":"2015-08-25","objectID":"/leetcode/0237/:3:0","tags":null,"title":"0237：删除链表中的节点（★）","uri":"/leetcode/0237/"},{"categories":null,"content":"题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x， 满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1: 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\r输出：3\r解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\r示例 2: 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\r输出：5\r解释：节点 5 和节点 4","date":"2015-08-24","objectID":"/leetcode/0236/:1:0","tags":null,"title":"0236：二叉树的最近公共祖先（★★）","uri":"/leetcode/0236/"},{"categories":null,"content":"分析 与 0235 的区别在于只是二叉树，并不有序。 依然可以考虑递归： 如果 root 等于 p 或 q，结果就是 root 如果 p、q 分别在 root 的左右子树，结果就是 root 如果 p、q 都在 root 的左子树或右子树，转为递归子问题 于是令 dfs(node) 代表 node 包含 p、q 的状态： 若 node 同时有 p、q，返回 p、q 的最近公共祖先 若 node 中有 p 或 q，返回 p 或 q 节点 若 node 中都没有，返回 None 即可递归。 ","date":"2015-08-24","objectID":"/leetcode/0236/:2:0","tags":null,"title":"0236：二叉树的最近公共祖先（★★）","uri":"/leetcode/0236/"},{"categories":null,"content":"解答 def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u003e 'TreeNode': def dfs(node): if not node or node in [p, q]: return node l, r = dfs(node.left), dfs(node.right) return node if l and r else (l or r) return dfs(root) 56 ms ","date":"2015-08-24","objectID":"/leetcode/0236/:3:0","tags":null,"title":"0236：二叉树的最近公共祖先（★★）","uri":"/leetcode/0236/"},{"categories":null,"content":"题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x， 满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\r输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。\r示例 2: 输入: root = [6,2,8,0","date":"2015-08-23","objectID":"/leetcode/0235/:1:0","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"分析 ","date":"2015-08-23","objectID":"/leetcode/0235/:2:0","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"#1 由 root 和 p、q 的大小关系可以分类讨论： 如果 root 比 p、q 的值都大，结果必然在 root 的左子树中。 如果 root 比 p、q 的值都小，结果必然在 root 的右子树中。 如果 root 在 p、q 的值之间，结果就是 root 于是可以递归解决。 def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u003e 'TreeNode': if root.val \u003e max(p.val, q.val): return self.lowestCommonAncesto","date":"2015-08-23","objectID":"/leetcode/0235/:2:1","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"#2 也可以写成迭代的形式。 ","date":"2015-08-23","objectID":"/leetcode/0235/:2:2","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"解答 def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u003e 'TreeNode': while root: if root.val \u003e max(p.val, q.val): root = root.left elif root.val \u003c min(p.val, q.val): root = root.right else: return root 92 ms ","date":"2015-08-23","objectID":"/leetcode/0235/:3:0","tags":null,"title":"0235：二叉搜索树的最近公共祖先（★）","uri":"/leetcode/0235/"},{"categories":null,"content":"题目 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。 如果是，返回 true ；否则，返回 false 。 示例 1： 输入：head = [1,2,2,1]\r输出：true\r示例 2： 输入：head = [1,2]\r输出：false\r提示： 链表中节点数目在范围[1, 10^5] 内 0 \u003c= Node.val \u003c= 9 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ ","date":"2015-08-22","objectID":"/leetcode/0234/:1:0","tags":null,"title":"0234：回文链表（★★）","uri":"/leetcode/0234/"},{"categories":null,"content":"分析 ","date":"2015-08-22","objectID":"/leetcode/0234/:2:0","tags":null,"title":"0234：回文链表（★★）","uri":"/leetcode/0234/"},{"categories":null,"content":"#1 用额外空间的话很简单。 def isPalindrome(self, head: ListNode) -\u003e bool: tmp = [] while head: tmp.append(head.val) head = head.next return tmp == tmp[::-1] 780 ms ","date":"2015-08-22","objectID":"/leetcode/0234/:2:1","tags":null,"title":"0234：回文链表（★★）","uri":"/leetcode/0234/"},{"categories":null,"content":"#2 不用额外空间，考虑将链表均分为两部分，反转其中一部分，再遍历判断两部分的节点值序列是否相同。 找中点可以用快慢指针，而反转链表即是 0206 。 ","date":"2015-08-22","objectID":"/leetcode/0234/:2:2","tags":null,"title":"0234：回文链表（★★）","uri":"/leetcode/0234/"},{"categories":null,"content":"解答 def isPalindrome(self, head: ListNode) -\u003e bool: def reverseList(head): tail = head while tail and tail.next: tmp = tail.next tail.next = tmp.next tmp.next = head head = tmp return head dummy = slow = fast = ListNode(next=head) while fast and fast.next: slow, fast = slow.next, fast.next.next head2","date":"2015-08-22","objectID":"/leetcode/0234/:3:0","tags":null,"title":"0234：回文链表（★★）","uri":"/leetcode/0234/"},{"categories":null,"content":"题目 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 示例 1： 输入：n = 13\r输出：6\r示例 2： 输入：n = 0\r输出：0\r提示：0 \u003c= n \u003c= 10^9 ","date":"2015-08-21","objectID":"/leetcode/0233/:1:0","tags":null,"title":"0233：数字 1 的个数（★★★）","uri":"/leetcode/0233/"},{"categories":null,"content":"分析 求范围内数字满足某种性质的个数，典型的数位 dp 问题。 令 dfs(pos, st, bound) 代表某个状态下的结果： 遍历到 n 的第 pos 位 前面取的数中有 st 个 1 bound 代表前面取的数是否贴着 n 的上界 即可递归。 ","date":"2015-08-21","objectID":"/leetcode/0233/:2:0","tags":null,"title":"0233：数字 1 的个数（★★★）","uri":"/leetcode/0233/"},{"categories":null,"content":"解答 def countDigitOne(self, n: int) -\u003e int: @lru_cache(None) def dfs(pos, st, bound): if pos == len(s): return st cur = int(s[pos]) up = cur if bound else 9 return sum(dfs(pos+1, st+(x==1), bound and x==cur) for x in range(up+1)) s = str(n) return dfs(0, 0, 1) 32 ms ","date":"2015-08-21","objectID":"/leetcode/0233/:3:0","tags":null,"title":"0233：数字 1 的个数（★★★）","uri":"/leetcode/0233/"},{"categories":null,"content":"题目 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list","date":"2015-08-20","objectID":"/leetcode/0232/:1:0","tags":null,"title":"0232：用栈实现队列（★）","uri":"/leetcode/0232/"},{"categories":null,"content":"分析 python 一般直接用 deque 作为队列。本题要求用栈实现，pop 时只能先把后面所有元素都出栈。 这里有个巧妙的想法，将出栈的元素依次保存到另一个栈 stack2 中，相当于反序保存了， 后面要 pop 时若 stack2 还有元素，直接弹出即可。 ","date":"2015-08-20","objectID":"/leetcode/0232/:2:0","tags":null,"title":"0232：用栈实现队列（★）","uri":"/leetcode/0232/"},{"categories":null,"content":"解答 class MyQueue: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, x: int) -\u003e None: self.stack1.append(x) def pop(self) -\u003e int: if self.stack2: return self.stack2.pop() for _ in range(len(self.stack1)-1): self.stack2.append(self.stack1.pop()) return self.stack1.pop() def peek(sel","date":"2015-08-20","objectID":"/leetcode/0232/:3:0","tags":null,"title":"0232：用栈实现队列（★）","uri":"/leetcode/0232/"},{"categories":null,"content":"题目 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 示例 1： 输入：n = 1\r输出：true\r解释：20 = 1\r示例 2： 输入：n = 16\r输出：true\r解释：24 = 16\r示例 3： 输入：n = 3\r输出：false\r示例 4： 输入：n = 4\r输出：true\r示例 5： 输入：n = 5\r输出：false\r提示： -2^31 \u003c= n \u003c= 2^31 - 1 ","date":"2015-08-19","objectID":"/leetcode/0231/:1:0","tags":null,"title":"0231：2 的幂（★）","uri":"/leetcode/0231/"},{"categories":null,"content":"分析 n 是 2 的幂等价于 n 是正整数且 n 的二进制中只有一个 1。 那么用 n\u0026(n-1) 移除最后一个 1 即变为 0。或者用 n\u0026(-n) 提取出最后一个 1 后面的部分，应该等于 n。 ","date":"2015-08-19","objectID":"/leetcode/0231/:2:0","tags":null,"title":"0231：2 的幂（★）","uri":"/leetcode/0231/"},{"categories":null,"content":"解答 def isPowerOfTwo(self, n: int) -\u003e bool: return n\u003e0 and n\u0026(n-1)==0 40 ms ","date":"2015-08-19","objectID":"/leetcode/0231/:3:0","tags":null,"title":"0231：2 的幂（★）","uri":"/leetcode/0231/"},{"categories":null,"content":"*附加 还有个巧妙的方法。n 是 2 的幂等价于 n 是正整数且 n 被 2**31 整除。 def isPowerOfTwo(self, n: int) -\u003e bool: return n\u003e0 and (1\u003c\u003c31)%n==0 32 ms ","date":"2015-08-19","objectID":"/leetcode/0231/:4:0","tags":null,"title":"0231：2 的幂（★）","uri":"/leetcode/0231/"},{"categories":null,"content":"题目 给定一个二叉搜索树的根节点 root ，和一个整数 k ， 请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。 示例 1： 输入：root = [3,1,4,null,2], k = 1\r输出：1\r示例 2： 输入：root = [5,3,6,2,4,null,null,1], k = 3\r输出：3\r提示： 树中的节点数为 n 。 1 \u003c= k \u003c= n \u003c= 10^4 0 \u003c= Node.val \u003c= 10^4 ","date":"2015-08-18","objectID":"/leetcode/0230/:1:0","tags":null,"title":"0230：二叉搜索树中第K小的元素（★）","uri":"/leetcode/0230/"},{"categories":null,"content":"分析 中序遍历到第 k 个数即可。 ","date":"2015-08-18","objectID":"/leetcode/0230/:2:0","tags":null,"title":"0230：二叉搜索树中第K小的元素（★）","uri":"/leetcode/0230/"},{"categories":null,"content":"解答 def kthSmallest(self, root: TreeNode, k: int) -\u003e int: stack = [root] while stack: node = stack.pop() if isinstance(node, int): k -= 1 if k == 0: return node elif node: stack.extend([node.right, node.val, node.left] 52 ms ","date":"2015-08-18","objectID":"/leetcode/0230/:3:0","tags":null,"title":"0230：二叉搜索树中第K小的元素（★）","uri":"/leetcode/0230/"},{"categories":null,"content":"题目 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 示例 1： 输入：[3,2,3]\r输出：[3]\r示例 2： 输入：nums = [1]\r输出：[1]\r示例 3： 输入：[1,1,1,3,3,2,2,2]\r输出：[1,2]\r提示： 1 \u003c= nums.length \u003c= 5 * 10^4 -10^9 \u003c= nums[i] \u003c= 10^9 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。 ","date":"2015-08-17","objectID":"/leetcode/0229/:1:0","tags":null,"title":"0229：求众数 II（★★）","uri":"/leetcode/0229/"},{"categories":null,"content":"分析 0169 升级版，可以直接计数，也可以考虑摩尔投票法。 在 nums 中任意消除三个不同的数直到剩下两种数或一种数 假如 nums 中存在超过 ⌊ n/3 ⌋ 次的元素，那么该元素必然会留下来 因此检查最终留下来的数是否符合即可 这可以推广到求超过 ⌊ n/k ⌋ 次的元素。 ","date":"2015-08-17","objectID":"/leetcode/0229/:2:0","tags":null,"title":"0229：求众数 II（★★）","uri":"/leetcode/0229/"},{"categories":null,"content":"解答 def majorityElement(self, nums: List[int]) -\u003e List[int]: d = defaultdict(int) for num in nums: d[num] += 1 if len(d)==3: for x in list(d): d[x] -= 1 if d[x] == 0: del d[x] return [x for x in d if nums.count(x)\u003elen(nums)//3] 52 ms ","date":"2015-08-17","objectID":"/leetcode/0229/:3:0","tags":null,"title":"0229：求众数 II（★★）","uri":"/leetcode/0229/"},{"categories":null,"content":"题目 给定一个无重复元素的有序整数数组 nums 。 返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说， nums 的每个元素都恰好被某个区间范围所覆盖， 并且不存在属于某个范围但不属于 nums 的数字 x 。 列表中的每个区间范围 [a,b] 应该按如下格式输出： “a-\u003eb” ，如果 a != b “a” ，如果 a == b 示例 1： 输入：nums = [0,1,2,4,5,7]\r输出：[\"0-\u003e2\",\"4-\u003e5\",\"7\"]\r解释：区间范围是：\r[0,2] --\u003e \"0-\u003e2\"\r[4,5] --\u003e \"4-\u003e5\"\r[7,7] --\u003e \"7\"\r示例 2： 输入：num","date":"2015-08-16","objectID":"/leetcode/0228/:1:0","tags":null,"title":"0228：汇总区间（★）","uri":"/leetcode/0228/"},{"categories":null,"content":"分析 遍历数组，记录连续区间的首尾即可。 ","date":"2015-08-16","objectID":"/leetcode/0228/:2:0","tags":null,"title":"0228：汇总区间（★）","uri":"/leetcode/0228/"},{"categories":null,"content":"解答 def summaryRanges(self, nums: List[int]) -\u003e List[str]: res, i = [], 0 for j, num in enumerate(nums): if j==len(nums)-1 or nums[j+1] != num+1: res.append('%d-\u003e%d' % (nums[i], num) if j\u003ei else str(num)) i = j+1 return res 32 ms ","date":"2015-08-16","objectID":"/leetcode/0228/:3:0","tags":null,"title":"0228：汇总区间（★）","uri":"/leetcode/0228/"},{"categories":null,"content":"题目 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 整数除法仅保留整数部分。 你可以假设给定的表达式总是有效的。所有中间结果将在 [-2^31, 2^31 - 1] 的范围内。 注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。 示例 1： 输入：s = \"3+2*2\"\r输出：7\r示例 2： 输入：s = \" 3/2 \"\r输出：1\r示例 3： 输入：s = \" 3+5 / 2 \"\r输出：5\r提示： 1 \u003c= s.length \u003c= 3 * 10^5 s 由整数和算符 (’+’, ‘-’, ‘*’, ‘/’) 组成，中间由一些空格隔开 s ","date":"2015-08-15","objectID":"/leetcode/0227/:1:0","tags":null,"title":"0227：基本计算器 II（★★）","uri":"/leetcode/0227/"},{"categories":null,"content":"分析 ","date":"2015-08-15","objectID":"/leetcode/0227/:2:0","tags":null,"title":"0227：基本计算器 II（★★）","uri":"/leetcode/0227/"},{"categories":null,"content":"#1 本题不含括号和符号位，所以将 ‘/’ 替换为 ‘//’ 就可以直接调用 eval 了。 def calculate(self, s: str) -\u003e int: return eval(s.replace('/', '//')) 64 ms ","date":"2015-08-15","objectID":"/leetcode/0227/:2:1","tags":null,"title":"0227：基本计算器 II（★★）","uri":"/leetcode/0227/"},{"categories":null,"content":"#2 也可以自己实现 eval，有个通用的方法： 用一个栈 stack 维护数字，一个栈 op 维护运算符 遍历到某个运算符时，将前面优先级更高的运算符从 op 弹出，先运算了 比如遇到 ‘+-’ 时，可以将 op 栈顶的 ‘+-*/’ 先运算了 注意最终栈 op 非空时，还需要弹出运算。 更方便的方法是末尾添加优先级最低的运算符，让所有运算符都出栈。 ","date":"2015-08-15","objectID":"/leetcode/0227/:2:2","tags":null,"title":"0227：基本计算器 II（★★）","uri":"/leetcode/0227/"},{"categories":null,"content":"解答 def calculate(self, s: str) -\u003e int: func = {'+': int.__add__, '-': int.__sub__, '*': int.__mul__, '/': lambda x, y: x//y} pro = dict(zip('+-*/', [1, 1, 2, 2])) stack, ops = [], [] for num, op in re.findall(r'(\\d+)|([-+/*])', s+'+'): if num: stack.append(int(num)) else: while ops and pro[ops[-1]] ","date":"2015-08-15","objectID":"/leetcode/0227/:3:0","tags":null,"title":"0227：基本计算器 II（★★）","uri":"/leetcode/0227/"},{"categories":null,"content":"题目 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 示例 1： 输入：root = [4,2,7,1,3,6,9]\r输出：[4,7,2,9,6,3,1]\r示例 2： 输入：root = [2,1,3]\r输出：[2,3,1]\r示例 3： 输入：root = []\r输出：[]\r提示： 树中节点数目范围在 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-08-14","objectID":"/leetcode/0226/:1:0","tags":null,"title":"0226：翻转二叉树（★）","uri":"/leetcode/0226/"},{"categories":null,"content":"分析 递归翻转即可。 ","date":"2015-08-14","objectID":"/leetcode/0226/:2:0","tags":null,"title":"0226：翻转二叉树（★）","uri":"/leetcode/0226/"},{"categories":null,"content":"解答 def invertTree(self, root: TreeNode) -\u003e TreeNode: if not root: return None root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root 36 ms ","date":"2015-08-14","objectID":"/leetcode/0226/:3:0","tags":null,"title":"0226：翻转二叉树（★）","uri":"/leetcode/0226/"},{"categories":null,"content":"题目 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list","date":"2015-08-13","objectID":"/leetcode/0225/:1:0","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"分析 ","date":"2015-08-13","objectID":"/leetcode/0225/:2:0","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"#1 python 一般直接用 list 作为栈。 class MyStack: def __init__(self): self.stack = [] def push(self, x: int) -\u003e None: self.stack.append(x) def pop(self) -\u003e int: return self.stack.pop() def top(self) -\u003e int: return self.stack[-1] def empty(self) -\u003e bool: return not self.stack 40 ms ","date":"2015-08-13","objectID":"/leetcode/0225/:2:1","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"#2 要求用队列实现，那么 pop 时只能把前面所有元素都出队再加在末尾。 ","date":"2015-08-13","objectID":"/leetcode/0225/:2:2","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"解答 class MyStack: def __init__(self): self.queue = deque() def push(self, x: int) -\u003e None: self.queue.append(x) def pop(self) -\u003e int: for _ in range(len(self.queue)-1): self.queue.append(self.queue.popleft()) return self.queue.popleft() def top(self) -\u003e int: return self.queue[-1] def empty(self) -\u003e ","date":"2015-08-13","objectID":"/leetcode/0225/:3:0","tags":null,"title":"0225：用队列实现栈","uri":"/leetcode/0225/"},{"categories":null,"content":"题目 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 示例 1： 输入：s = \"1 + 1\"\r输出：2\r示例 2： 输入：s = \" 2-1 + 2 \"\r输出：3\r示例 3： 输入：s = \"(1+(4+5+2)-3)+(6+8)\"\r输出：23\r提示： 1 \u003c= s.length \u003c= 3 * 105 s 由数字、’+’、’-’、’(’、’)’、和 ’ ’ 组成 s 表示一个有效的表达式 ‘+’ 不能用作一元运算(例如， “+1” 和 “+(2 + 3)” 无效) ‘-’ 可以用作一元运算(即 “-1” 和 “-(2 + 3)” 是有效的) 输入中不存在两个连续的操作","date":"2015-08-12","objectID":"/leetcode/0224/:1:0","tags":null,"title":"0224：基本计算器（★★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"分析 ","date":"2015-08-12","objectID":"/leetcode/0224/:2:0","tags":null,"title":"0224：基本计算器（★★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"#1 python 的 eval 最多只能处理 200 层括号，因此考虑用栈模拟递归过程， 先处理括号内并转为一个值。括号内的计算就可以直接用 eval 了。 def calculate(self, s: str) -\u003e int: stack = [''] for char in s: if char == '(': stack.append('') elif char == ')': x = eval(stack.pop()) stack[-1] += str(x) elif char: stack[-1] += char return eval(stack[0]) 100 ms ","date":"2015-08-12","objectID":"/leetcode/0224/:2:1","tags":null,"title":"0224：基本计算器（★★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"#2 也可以自己实现 eval。 本题只有加减号，看作是带正负号的数之和即可。 注意当括号内结果为负数，且括号前为负号时，会出现 ‘- -’ 的情况，提前替换为 ‘+’ 即可。 ","date":"2015-08-12","objectID":"/leetcode/0224/:2:2","tags":null,"title":"0224：基本计算器（★★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"解答 def calculate(self, s: str) -\u003e int: def cal(ss): return sum(map(int, re.findall('[-+]?\\d+', ss.replace('--', '+')))) stack = [''] for char in s: if char == '(': stack.append('') elif char == ')': x = cal(stack.pop()) stack[-1] += str(x) elif char != ' ': stack[-1] += char return cal(stack[0]) 84 ","date":"2015-08-12","objectID":"/leetcode/0224/:3:0","tags":null,"title":"0224：基本计算器（★★★）","uri":"/leetcode/0224/"},{"categories":null,"content":"题目 给你 二维 平面上两个 由直线构成的 矩形，请你计算并返回两个矩形覆盖的总面积。 每个矩形由其 左下 顶点和 右上 顶点坐标表示： 第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。 第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。 示例 1： Rectangle Area\r输入：ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\r输出：45\r示例 2： 输入：ax1 = -2, ay1 = -2, ax2 = 2, ay","date":"2015-08-11","objectID":"/leetcode/0223/:1:0","tags":null,"title":"0223：矩形面积（★★）","uri":"/leetcode/0223/"},{"categories":null,"content":"分析 用两个矩形面积的和去掉重叠面积即可： 若有重叠部分，宽必然等于 [ax1, ax2] 和 [bx1, bx2] 的重叠长度，即 min(ax2, bx2)-max(ax1, bx1)\r高也同理。 ","date":"2015-08-11","objectID":"/leetcode/0223/:2:0","tags":null,"title":"0223：矩形面积（★★）","uri":"/leetcode/0223/"},{"categories":null,"content":"解答 def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -\u003e int: x = max(0, min(ax2, bx2)-max(ax1, bx1)) y = max(0, min(ay2, by2)-max(ay1, by1)) return (ax2-ax1)*(ay2-ay1)+(bx2-bx1)*(by2-by1)-x*y 52 ms ","date":"2015-08-11","objectID":"/leetcode/0223/:3:0","tags":null,"title":"0223：矩形面积（★★）","uri":"/leetcode/0223/"},{"categories":null,"content":"题目 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值， 并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例 1： 输入：root = [1,2,3,4,5,6]\r输出：6\r示例 2： 输入：root = []\r输出：0\r示例 3： 输入：root = [1]\r输出：1\r提示： 树中节点的数目范围是[0, 5 * 10^4] 0 \u003c= Node.val \u003c= 5 * 10^4 题目数据保证输入的树是 完全二叉树 进阶：遍历树","date":"2015-08-10","objectID":"/leetcode/0222/:1:0","tags":null,"title":"0222：完全二叉树的节点个数（★★★）","uri":"/leetcode/0222/"},{"categories":null,"content":"分析 递归很简单。 ","date":"2015-08-10","objectID":"/leetcode/0222/:2:0","tags":null,"title":"0222：完全二叉树的节点个数（★★★）","uri":"/leetcode/0222/"},{"categories":null,"content":"解答 def countNodes(self, root: TreeNode) -\u003e int: return 0 if not root else 1 + self.countNodes(root.left)+self.countNodes(root.right) 64 ms ","date":"2015-08-10","objectID":"/leetcode/0222/:3:0","tags":null,"title":"0222：完全二叉树的节点个数（★★★）","uri":"/leetcode/0222/"},{"categories":null,"content":"*附加 利用完全二叉树的特性，还有个巧妙的二分查找方法。 先遍历到最底层最左边的节点，得到高度 h 该完全二叉树的节点数 x 必然满足 x\u003c=2^(h+1)-1 以节点数 x 为界，序号 [1, x] 的节点都存在，序号 [x+1, M] 都不存在 因此可以在 [0， 2^(h+1)-1] 范围内二分查找 x 判断序号 y 是否存在，可以按 y 的二进制遍历树 def countNodes(self, root: TreeNode) -\u003e int: def check(x): p = root for bit in bin(x)[3:]: p = p.left if bit == '0' el","date":"2015-08-10","objectID":"/leetcode/0222/:4:0","tags":null,"title":"0222：完全二叉树的节点个数（★★★）","uri":"/leetcode/0222/"},{"categories":null,"content":"题目 在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。 示例 1： 输入：matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],\r[\"1\",\"0\",\"0\",\"1\",\"0\"]]\r输出：4\r示例 2： 输入：matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\r输出：1\r示例 3： 输入：matrix = [[\"0\"]]\r输出：0\r提示： m == matrix.length n == matrix[i].length 1 \u003c= m, n \u003c= ","date":"2015-08-09","objectID":"/leetcode/0221/:1:0","tags":null,"title":"0221：最大正方形（★★）","uri":"/leetcode/0221/"},{"categories":null,"content":"分析 ","date":"2015-08-09","objectID":"/leetcode/0221/:2:0","tags":null,"title":"0221：最大正方形（★★）","uri":"/leetcode/0221/"},{"categories":null,"content":"#1 本题是 0085 的子问题，修改一下即可。 def maximalSquare(self, matrix: List[List[str]]) -\u003e int: def cal(H): res, stack = 0, [] for j, y in enumerate(H+[0]): while stack and stack[-1][1] \u003e= y: i, x = stack.pop() left = stack[-1][0] if stack else -1 h = min(j-left-1, x) res = max(res, h*h) stack.append((j, y)) retu","date":"2015-08-09","objectID":"/leetcode/0221/:2:1","tags":null,"title":"0221：最大正方形（★★）","uri":"/leetcode/0221/"},{"categories":null,"content":"#2 还有个巧妙的 dp 方法： 令 dp[i][j] 代表以 (i,j) 为右下顶点的最大正方形的边长，当 matrix[i][j] == ‘1’ 时： dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\r证明： 该值显然是成立的 假设 dp[i][j]=x，则 dp[i-][j-1] 必然 \u003e=x-1，故 x \u003c= 1+dp[i-1][j-1] 同理可得 dp[i][j] \u003c= 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) 故 dp[i][j] 等于该值 可以用滚动数组优化空间。 ","date":"2015-08-09","objectID":"/leetcode/0221/:2:2","tags":null,"title":"0221：最大正方形（★★）","uri":"/leetcode/0221/"},{"categories":null,"content":"解答 def maximalSquare(self, matrix: List[List[str]]) -\u003e int: m, n = len(matrix), len(matrix[0]) side, dp = 0, [0]*n for i in range(m): new = [0]*n for j in range(n): if matrix[i][j] == '1': new[j] = 1 if i==0 or j==0 else 1 + min(dp[j-1], dp[j], new[j-1]) side = max(side, new[j]) dp = new return side","date":"2015-08-09","objectID":"/leetcode/0221/:3:0","tags":null,"title":"0221：最大正方形（★★）","uri":"/leetcode/0221/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j， 使得 abs(nums[i] - nums[j]) \u003c= t ，同时又满足 abs(i - j) \u003c= k 。 如果存在则返回 true，不存在返回 false。 示例 1： 输入：nums = [1,2,3,1], k = 3, t = 0\r输出：true\r示例 2： 输入：nums = [1,0,1,1], k = 1, t = 2\r输出：true\r示例 3： 输入：nums = [1,5,9,1,5,9], k = 2, t = 3\r输出：false\r提示： 0 \u003c= nums.le","date":"2015-08-08","objectID":"/leetcode/0220/:1:0","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"分析 ","date":"2015-08-08","objectID":"/leetcode/0220/:2:0","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"#1 0219 升级版，要找的不是相同数而是一个范围内的数了。 考虑维护窗口 [j-k, j-1] 有序，即可二分查找离 nums[j] 最近的数 有序窗口要进行插入、删除、查找操作，考虑用有序集合 SortedList 实现 def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -\u003e bool: from sortedcontainers import SortedList sl = SortedList() for j, num in enumerate(nums): if j \u003e k: sl.re","date":"2015-08-08","objectID":"/leetcode/0220/:2:1","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"#2 还有个巧妙的桶排序方法。 桶的 size 设为 t+1，维护窗口 [j-k, j-1] 的桶状态。 符合条件的数和 nums[j] 要么在一个桶，要么在相邻桶 如果某个桶有两个元素，显然已经符合了 因此每轮最多与三个桶中的唯一元素比较，时间复杂度 O(N) ","date":"2015-08-08","objectID":"/leetcode/0220/:2:2","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"解答 def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -\u003e bool: bucket, size = {}, t + 1 for j, num in enumerate(nums): if j \u003e k: bucket.pop(nums[j - k - 1] // size) key = num // size if any(kk in bucket and abs(bucket[kk]-num)\u003c=t for kk in [key, key-1, key+1]): return True buck","date":"2015-08-08","objectID":"/leetcode/0220/:3:0","tags":null,"title":"0220：存在重复元素 III（★★）","uri":"/leetcode/0220/"},{"categories":null,"content":"题目 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ， 满足 nums[i] == nums[j] 且 abs(i - j) \u003c= k 。如果存在，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [1,2,3,1], k = 3\r输出：true\r示例 2： 输入：nums = [1,0,1,1], k = 1\r输出：true\r示例 3： 输入：nums = [1,2,3,1,2,3], k = 2\r输出：false\r提示： 1 \u003c= nums.length \u003c= 10^5 -10^9 \u003c= nums[i] \u003c= 10","date":"2015-08-07","objectID":"/leetcode/0219/:1:0","tags":null,"title":"0219：存在重复元素 II（★）","uri":"/leetcode/0219/"},{"categories":null,"content":"分析 典型的哈希表，边遍历边存储元素位置，并判断上一个位置是否在范围内即可。 ","date":"2015-08-07","objectID":"/leetcode/0219/:2:0","tags":null,"title":"0219：存在重复元素 II（★）","uri":"/leetcode/0219/"},{"categories":null,"content":"解答 def containsNearbyDuplicate(self, nums: List[int], k: int) -\u003e bool: d = {} for i, num in enumerate(nums): if num in d and i-d[num] \u003c= k: return True d[num] = i return False 40 ms ","date":"2015-08-07","objectID":"/leetcode/0219/:3:0","tags":null,"title":"0219：存在重复元素 II（★）","uri":"/leetcode/0219/"},{"categories":null,"content":"题目 城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。 给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 。 每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示： lefti 是第 i 座建筑物左边缘的 x 坐标。 righti 是第 i 座建筑物右边缘的 x 坐标。 heighti 是第 i 座建筑物的高度。 你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。 天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,","date":"2015-08-06","objectID":"/leetcode/0218/:1:0","tags":null,"title":"0218：天际线问题（★★★）","uri":"/leetcode/0218/"},{"categories":null,"content":"分析 典型的扫描线问题： 显然只有边缘处才可能改变高度，考虑按顺序遍历所有边缘坐标 x 遍历 x 时，维护还没有掠过的建筑物高度集合 H，max(H) 就是对应的轮廓高度 max(H) 和上一个关键点高度比较，即可判断高度是否改变 具体实现时，H 要进行插入、删除、取最大值的操作，考虑用有序集合 SortedList， 都能在 O(logN) 时间内完成。 ","date":"2015-08-06","objectID":"/leetcode/0218/:2:0","tags":null,"title":"0218：天际线问题（★★★）","uri":"/leetcode/0218/"},{"categories":null,"content":"解答 def getSkyline(self, buildings: List[List[int]]) -\u003e List[List[int]]: from sortedcontainers import SortedList d = defaultdict(list) for left, right, h in buildings: d[left].append((h, 1)) d[right].append((h, 0)) res, H = [], SortedList() for x in sorted(d): for h, flag in d[x]: H.add(h) if flag el","date":"2015-08-06","objectID":"/leetcode/0218/:3:0","tags":null,"title":"0218：天际线问题（★★★）","uri":"/leetcode/0218/"},{"categories":null,"content":"题目 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ； 如果数组中每个元素互不相同，返回 false 。 示例 1： 输入：nums = [1,2,3,1]\r输出：true\r示例 2： 输入：nums = [1,2,3,4]\r输出：false\r示例 3： 输入：nums = [1,1,1,3,3,4,3,2,4,2]\r输出：true\r提示： 1 \u003c= nums.length \u003c= 10^5 -10^9 \u003c= nums[i] \u003c= 10^9 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/contains-dup","date":"2015-08-05","objectID":"/leetcode/0217/:1:0","tags":null,"title":"0217：存在重复元素","uri":"/leetcode/0217/"},{"categories":null,"content":"分析 典型的哈希应用，判断去重后长度是否减小即可。 ","date":"2015-08-05","objectID":"/leetcode/0217/:2:0","tags":null,"title":"0217：存在重复元素","uri":"/leetcode/0217/"},{"categories":null,"content":"解答 def containsDuplicate(self, nums: List[int]) -\u003e bool: return len(nums) != len(set(nums)) 44 ms ","date":"2015-08-05","objectID":"/leetcode/0217/:3:0","tags":null,"title":"0217：存在重复元素","uri":"/leetcode/0217/"},{"categories":null,"content":"题目 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 示例 1: 输入: k = 3, n = 7\r输出: [[1,2,4]]\r解释:\r1 + 2 + 4 = 7\r没有其他符合的组合了。\r示例 2: 输入: k = 3, n = 9\r输出: [[1,2,6], [1,3,5], [2,3,4]]\r解释:\r1 + 2 + 6 = 9\r1 + 3 + 5 = 9\r2 + 3 + 4 = 9\r没有其他符合的组合了。\r示例 3: 输入: k = 4, n =","date":"2015-08-04","objectID":"/leetcode/0216/:1:0","tags":null,"title":"0216：组合总和 III（★★）","uri":"/leetcode/0216/"},{"categories":null,"content":"分析 类似 0077 ，添加和的限制即可。 ","date":"2015-08-04","objectID":"/leetcode/0216/:2:0","tags":null,"title":"0216：组合总和 III（★★）","uri":"/leetcode/0216/"},{"categories":null,"content":"解答 def combinationSum3(self, k: int, n: int) -\u003e List[List[int]]: return [A for A in combinations(range(1, 10), k) if sum(A) == n] 32 ms ","date":"2015-08-04","objectID":"/leetcode/0216/:3:0","tags":null,"title":"0216：组合总和 III（★★）","uri":"/leetcode/0216/"},{"categories":null,"content":"题目 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2\r输出: 5\r示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\r输出: 4\r提示： 1 \u003c= k \u003c= nums.length \u003c= 10^4 -10^4 \u003c= nums[i] \u003c= 10^4 ","date":"2015-08-03","objectID":"/leetcode/0215/:1:0","tags":null,"title":"0215：数组中的第K个最大元素","uri":"/leetcode/0215/"},{"categories":null,"content":"分析 直接调用排序或者堆即可。 ","date":"2015-08-03","objectID":"/leetcode/0215/:2:0","tags":null,"title":"0215：数组中的第K个最大元素","uri":"/leetcode/0215/"},{"categories":null,"content":"解答 def findKthLargest(self, nums: List[int], k: int) -\u003e int: return nlargest(k, nums)[-1] 32 ms ","date":"2015-08-03","objectID":"/leetcode/0215/:3:0","tags":null,"title":"0215：数组中的第K个最大元素","uri":"/leetcode/0215/"},{"categories":null,"content":"*附加 借助快排的思想可以在 O(N) 时间内完成。 随机取一个数 pivot，按照快排的方法将 pivot 调整到位置 i，使得左边都 \u003c=pivot，右边都 \u003e=pivot。 假如 i == n-k ， pivot 即为所求 假如 i \u003c n-k ， 转为求 nums[i+1:] 中第 k 大的数 假如 i \u003e n-k ， 转为求 nums[:i] 中第 k-(n-i) 大的数 每次只递归一边，时间复杂度 O(N)。 def findKthLargest(self, nums: List[int], k: int) -\u003e int: def quick(l, r, k): x = rando","date":"2015-08-03","objectID":"/leetcode/0215/:4:0","tags":null,"title":"0215：数组中的第K个最大元素","uri":"/leetcode/0215/"},{"categories":null,"content":"题目 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。 找到并返回可以用这种方式转换的最短回文串。 示例 1： 输入：s = \"aacecaaa\"\r输出：\"aaacecaaa\"\r示例 2： 输入：s = \"abcd\"\r输出：\"dcbabcd\"\r提示： 0 \u003c= s.length \u003c= 5 * 10^4 s 仅由小写英文字母组成 ","date":"2015-08-02","objectID":"/leetcode/0214/:1:0","tags":null,"title":"0214：最短回文串（★★★）","uri":"/leetcode/0214/"},{"categories":null,"content":"分析 观察可知问题等价于找到 s 最长的前缀回文子串 s[:i]，然后在前面添加 s[i:][::-1] 即可。 与回文相关，首先想到 Manacher 算法。Manacher 算法能在 O(N) 时间内得到每个位置 i 的臂长， 那么找最后一个 i 满足其臂长等于 i 即可。 ","date":"2015-08-02","objectID":"/leetcode/0214/:2:0","tags":null,"title":"0214：最短回文串（★★★）","uri":"/leetcode/0214/"},{"categories":null,"content":"解答 def shortestPalindrome(self, s: str) -\u003e str: def expand(l, r): while l \u003e 0 and r \u003c len(ss) - 1 and ss[l - 1] == ss[r + 1]: l -= 1 r += 1 return (r - l) // 2 pos, ss = 0, '#' + '#'.join(s) + '#' A, center, right = [], 0, 0 for i in range(len(ss)//2+1): min_arm = min(A[2*center-i], right-i) if righ","date":"2015-08-02","objectID":"/leetcode/0214/:3:0","tags":null,"title":"0214：最短回文串（★★★）","uri":"/leetcode/0214/"},{"categories":null,"content":"*附加 还有个很巧妙的 KMP 解法。 若 s[:i] 是回文子串，那么 s[::-1][-i:] 也是回文子串，ss[::-1][-i:] 和 s[:i] 相同。 因此将 s 作为模式串在 s[::-1] 中用 KMP 匹配，最终匹配到的 s[:j] 即为最长的前缀回文子串。 def shortestPalindrome(self, s: str) -\u003e str: nxt, j, n = [-1], -1, len(s) for i in range(n): while j \u003e= 0 and s[i] != s[j]: j = nxt[j] j += 1 nxt.append(j) t, j","date":"2015-08-02","objectID":"/leetcode/0214/:4:0","tags":null,"title":"0214：最短回文串（★★★）","uri":"/leetcode/0214/"},{"categories":null,"content":"题目 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ， 这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统， 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2]\r输出：3\r解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\r示例 2： 输入：nums = [1,2,3,1]\r输出：4\r解释：你可","date":"2015-08-01","objectID":"/leetcode/0213/:1:0","tags":null,"title":"0213：打家劫舍 II（★★）","uri":"/leetcode/0213/"},{"categories":null,"content":"分析 0198 升级版，只是第一个房屋和最后一个房屋也不能同时偷了， 按偷不偷第一个房屋分类即可。 ","date":"2015-08-01","objectID":"/leetcode/0213/:2:0","tags":null,"title":"0213：打家劫舍 II（★★）","uri":"/leetcode/0213/"},{"categories":null,"content":"解答 def rob(self, nums: List[int]) -\u003e int: def dfs(nums): a, b = 0, 0 for num in nums: a, b = b, max(num + a, b) return b return max(dfs(nums[1:]), nums[0]+dfs(nums[2:-1])) 32 ms ","date":"2015-08-01","objectID":"/leetcode/0213/:3:0","tags":null,"title":"0213：打家劫舍 II（★★）","uri":"/leetcode/0213/"},{"categories":null,"content":"题目 请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。 实现词典类 WordDictionary ： WordDictionary() 初始化词典对象 void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配 bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ； 否则，返回 false 。word 中可能包含一些 ‘.’ ，每个 . 都可以表示任何一个字母。 示例： 输入：\r[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"s","date":"2015-07-30","objectID":"/leetcode/0211/:1:0","tags":null,"title":"0211：添加与搜索单词 - 数据结构设计（★★）","uri":"/leetcode/0211/"},{"categories":null,"content":"分析 0208 升级版，search 里可能含有 ‘.’。 按首位是否为 ‘.’，分别递归即可。 ","date":"2015-07-30","objectID":"/leetcode/0211/:2:0","tags":null,"title":"0211：添加与搜索单词 - 数据结构设计（★★）","uri":"/leetcode/0211/"},{"categories":null,"content":"解答 class WordDictionary: def __init__(self): T = lambda: defaultdict(T) self.trie = T() def addWord(self, word: str) -\u003e None: reduce(dict.__getitem__, word, self.trie)['#'] = {} def search(self, word: str) -\u003e bool: def dfs(p, w): if not w: return True if w[0]=='.': return any(dfs(q, w[1:]) for q in ","date":"2015-07-30","objectID":"/leetcode/0211/:3:0","tags":null,"title":"0211：添加与搜索单词 - 数据结构设计（★★）","uri":"/leetcode/0211/"},{"categories":null,"content":"题目 给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 找出所有同时在二维网格和字典中出现的单词。 单词必须按照字母顺序，通过 相邻的单元格 内的字母构成， 其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。 同一个单元格内的字母在一个单词中不允许被重复使用。 示例 1： 输入：board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\r输出：[\"eat\",\"oath\"]\r示例 ","date":"2015-07-30","objectID":"/leetcode/0212/:1:0","tags":null,"title":"0212：单词搜索 II（★★★）","uri":"/leetcode/0212/"},{"categories":null,"content":"分析 0079 的升级版，变成搜索多个单词。 单词数量太多，一个个搜会超时，考虑怎么同时搜索： 只要搜索路径是某一个单词的前缀，就可以继续搜索 否则，可以直接跳出 当搜索路径匹配某一个单词时，添加到结果中即可 于是想到用 trie 树，方便判断路径是否单词前缀或单词本身。 注意不同路径可能找到相同单词，结果要去重 ","date":"2015-07-30","objectID":"/leetcode/0212/:2:0","tags":null,"title":"0212：单词搜索 II（★★★）","uri":"/leetcode/0212/"},{"categories":null,"content":"解答 def findWords(self, board: List[List[str]], words: List[str]) -\u003e List[str]: def dfs(p, i, j): if '#' in p: res.add(p['#']) A = product(range(m),range(n)) if p==trie else [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] for x, y in A: if 0 \u003c=x\u003cm and 0\u003c=y\u003cn and board[x][y] in p: c = board[x][y] board[x][y] = '0' ","date":"2015-07-30","objectID":"/leetcode/0212/:3:0","tags":null,"title":"0212：单词搜索 II（★★★）","uri":"/leetcode/0212/"},{"categories":null,"content":"*附加 针对本题有巧妙的优化： 找到单词的同时将 ‘#’ 弹出，就不会搜索到相同单词，最后无需再去重 弹出 ‘#’ 后，非 ‘#’ 的叶子结点也可以弹出，无需再考虑 def findWords(self, board: List[List[str]], words: List[str]) -\u003e List[str]: def dfs(p, i, j): if '#' in p: res.append(p.pop('#')) A = product(range(m),range(n)) if p==trie else [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] for x,","date":"2015-07-30","objectID":"/leetcode/0212/:4:0","tags":null,"title":"0212：单词搜索 II（★★★）","uri":"/leetcode/0212/"},{"categories":null,"content":"题目 现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ， 其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。 如果不可能完成所有课程，返回 一个空数组 。 示例 1： 输入：numCourses = 2, prerequisites = [[1,0]]\r输出：[0,","date":"2015-07-29","objectID":"/leetcode/0210/:1:0","tags":null,"title":"0210：课程表 II（★★）","uri":"/leetcode/0210/"},{"categories":null,"content":"分析 类似 0207，保存出队节点即可。 ","date":"2015-07-29","objectID":"/leetcode/0210/:2:0","tags":null,"title":"0210：课程表 II（★★）","uri":"/leetcode/0210/"},{"categories":null,"content":"解答 def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -\u003e List[int]: n = numCourses nxt, indeg = defaultdict(list), [0]*n for v, u in prerequisites: nxt[u].append(v) indeg[v] += 1 res, Q = [], deque(u for u in range(n) if indeg[u]==0) while Q: u = Q.popleft() res.append(u) for v in ","date":"2015-07-29","objectID":"/leetcode/0210/:3:0","tags":null,"title":"0210：课程表 II（★★）","uri":"/leetcode/0210/"},{"categories":null,"content":"题目 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。 如果不存在符合条件的子数组，返回 0 。 示例 1： 输入：target = 7, nums = [2,3,1,2,4,3]\r输出：2\r解释：子数组 [4,3] 是该条件下的长度最小的子数组。\r示例 2： 输入：target = 4, nums = [1,4,4]\r输出：1\r示例 3： 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\r输出","date":"2015-07-28","objectID":"/leetcode/0209/:1:0","tags":null,"title":"0209：长度最小的子数组（★）","uri":"/leetcode/0209/"},{"categories":null,"content":"分析 遍历每个位置 j 作为结尾，找符合条件的最短子串 [i, j] 即可。 发现遍历中 i 必然是不动或向右移的，因此是滑动窗口。 ","date":"2015-07-28","objectID":"/leetcode/0209/:2:0","tags":null,"title":"0209：长度最小的子数组（★）","uri":"/leetcode/0209/"},{"categories":null,"content":"解答 def minSubArrayLen(self, target: int, nums: List[int]) -\u003e int: res, i, s = float('inf'), 0, 0 for j, num in enumerate(nums): s += num while s \u003e= target: res = min(res, j-i+1) s -= nums[i] i += 1 return res if res \u003c float('inf') else 0 36 ms ","date":"2015-07-28","objectID":"/leetcode/0209/:3:0","tags":null,"title":"0209：长度最小的子数组（★）","uri":"/leetcode/0209/"},{"categories":null,"content":"*附加 有个巧妙的二分查找方法： 以答案 x 为界，长度小于 x 的子数组必然都不符合，长度 \u003e= x 的子数组中必然有一个符合 因此可以二分查找第一个 y 使得存在长度 y 的子数组符合 判断是否存在长度 y 的子数组符合，可以用滑动窗口在 O(N) 内实现 y 的取值范围是 [1,n]，所以最终的时间复杂度为 O(N log N) def minSubArrayLen(self, target: int, nums: List[int]) -\u003e int: def check(x): s = 0 for j, num in enumerate(nums): s += num if j \u003e= ","date":"2015-07-28","objectID":"/leetcode/0209/:4:0","tags":null,"title":"0209：长度最小的子数组（★）","uri":"/leetcode/0209/"},{"categories":null,"content":"题目 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。 这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）； 否则，返回 false 。 bool","date":"2015-07-27","objectID":"/leetcode/0208/:1:0","tags":null,"title":"0208：实现 Trie (前缀树)（★★）","uri":"/leetcode/0208/"},{"categories":null,"content":"分析 trie 树是一种经典的树结构，python 中用 defaultdict 实现比较方便。 insert 时将没有的节点补齐即可 为了区分前缀和整个单词，insert 时添加结尾标志 “#” startsWith 时，判断 trie 中是否有该路径即可 search 某个单词 w 等价于 startsWith(w+’#') ","date":"2015-07-27","objectID":"/leetcode/0208/:2:0","tags":null,"title":"0208：实现 Trie (前缀树)（★★）","uri":"/leetcode/0208/"},{"categories":null,"content":"解答 class Trie: def __init__(self): T = lambda: defaultdict(T) self.trie = T() def insert(self, word: str) -\u003e None: reduce(dict.__getitem__, word, self.trie)['#'] = {} def search(self, word: str) -\u003e bool: return self.startsWith(word + '#') def startsWith(self, prefix: str) -\u003e bool: p = self.trie for ","date":"2015-07-27","objectID":"/leetcode/0208/:3:0","tags":null,"title":"0208：实现 Trie (前缀树)（★★）","uri":"/leetcode/0208/"},{"categories":null,"content":"题目 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出， 其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。 示例 1： 输入：numCourses = 2, prerequisites = [[1,0]]\r输出：tr","date":"2015-07-26","objectID":"/leetcode/0207/:1:0","tags":null,"title":"0207：课程表（★★）","uri":"/leetcode/0207/"},{"categories":null,"content":"分析 典型的拓扑排序，等价于判断有向图中是否有环。 一般用 bfs 实现，更容易理解： 初始将所有入度为 0 的顶点入队 每轮弹出队首顶点，将所有后继顶点的入度减一，入度变为 0 的顶点入队 循环直到队空，判断弹出的顶点个数是否等于 numCourses 即可 ","date":"2015-07-26","objectID":"/leetcode/0207/:2:0","tags":null,"title":"0207：课程表（★★）","uri":"/leetcode/0207/"},{"categories":null,"content":"解答 def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -\u003e bool: n = numCourses nxt, indeg = defaultdict(list), [0]*n for v, u in prerequisites: nxt[u].append(v) indeg[v] += 1 res, Q = 0, deque(u for u in range(n) if indeg[u]==0) while Q: u = Q.popleft() res += 1 for v in nxt[u]: ind","date":"2015-07-26","objectID":"/leetcode/0207/:3:0","tags":null,"title":"0207：课程表（★★）","uri":"/leetcode/0207/"},{"categories":null,"content":"题目 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5]\r输出：[5,4,3,2,1]\r示例 2： 输入：head = [1,2]\r输出：[2,1]\r示例 3： 输入：head = []\r输出：[]\r提示： 链表中节点的数目范围是 [0, 5000] -5000 \u003c= Node.val \u003c= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ ","date":"2015-07-25","objectID":"/leetcode/0206/:1:0","tags":null,"title":"0206：反转链表（★）","uri":"/leetcode/0206/"},{"categories":null,"content":"分析 ","date":"2015-07-25","objectID":"/leetcode/0206/:2:0","tags":null,"title":"0206：反转链表（★）","uri":"/leetcode/0206/"},{"categories":null,"content":"#1 先考虑递归方法： 首先反转 head.next 后的链表，这是递归子问题 然后改变 head.next 和 head 之间的指向即可 def reverseList(self, head: ListNode) -\u003e ListNode: if not head or not head.next: return head newhead = self.reverseList(head.next) head.next.next = head head.next = None return newhead 48 ms ","date":"2015-07-25","objectID":"/leetcode/0206/:2:1","tags":null,"title":"0206：反转链表（★）","uri":"/leetcode/0206/"},{"categories":null,"content":"#2 也可以用迭代法： 用 tail 维护已经反转部分的尾节点 初始新建哑节点，tail 指向 head tail 后面还剩节点时，将该节点去除并插入到哑结点后即可 ","date":"2015-07-25","objectID":"/leetcode/0206/:2:2","tags":null,"title":"0206：反转链表（★）","uri":"/leetcode/0206/"},{"categories":null,"content":"解答 def reverseList(self, head: ListNode) -\u003e ListNode: dummy, tail = ListNode(next=head), head while tail and tail.next: tmp = tail.next tail.next = tmp.next tmp.next = dummy.next dummy.next = tmp return dummy.next 36 ms ","date":"2015-07-25","objectID":"/leetcode/0206/:3:0","tags":null,"title":"0206：反转链表（★）","uri":"/leetcode/0206/"},{"categories":null,"content":"题目 给定两个字符串 s 和 t ，判断它们是否是同构的。 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。 不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。 示例 1: 输入：s = \"egg\", t = \"add\"\r输出：true\r示例 2： 输入：s = \"foo\", t = \"bar\"\r输出：false\r示例 3： 输入：s = \"paper\", t = \"title\"\r输出：true\r提示： 1 \u003c= s.length \u003c= 5 * 10^4 t.len","date":"2015-07-24","objectID":"/leetcode/0205/:1:0","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"分析 ","date":"2015-07-24","objectID":"/leetcode/0205/:2:0","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"#1 显然可以用哈希表。因为要求一一对应，所以用两个哈希表来记录双向关系。 def isIsomorphic(self, s: str, t: str) -\u003e bool: d1, d2 = {}, {} for a, b in zip(s, t): if d1.setdefault(a, b) != b or d2.setdefault(b, a) != a: return False return True 40 ms ","date":"2015-07-24","objectID":"/leetcode/0205/:2:1","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"#2 还有个更巧妙的方法。 若 len(set(s))==len(set(zip(s,t)))，代表 s 到 t 是单射 若 len(set(t))==len(set(zip(s,t)))，代表 t 到 s 是单射 同时满足即说明是双射 ","date":"2015-07-24","objectID":"/leetcode/0205/:2:2","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"解答 def isIsomorphic(self, s: str, t: str) -\u003e bool: return len(set(s))==len(set(t))==len(set(zip(s,t))) 32 ms ","date":"2015-07-24","objectID":"/leetcode/0205/:3:0","tags":null,"title":"0205：同构字符串（★）","uri":"/leetcode/0205/"},{"categories":null,"content":"题目 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。 示例 1： 输入：n = 10\r输出：4\r解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\r示例 2： 输入：n = 0\r输出：0\r示例 3： 输入：n = 1\r输出：0\r提示： 0 \u003c= n \u003c= 5 * 10^6 ","date":"2015-07-23","objectID":"/leetcode/0204/:1:0","tags":null,"title":"0204：计数质数（★★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"分析 本题有个经典的埃氏筛法。当遍历到质数 x ，可以将之后以 x 为因数的合数都标记为 0。 那么整个遍历过程中，遇到的没标记的数就是质数。 ","date":"2015-07-23","objectID":"/leetcode/0204/:2:0","tags":null,"title":"0204：计数质数（★★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"解答 def countPrimes(self, n: int) -\u003e int: flags = [0] * 2 + [1] * (n - 2) for i in range(2, int(sqrt(n)) + 1): if flags[i]: flags[i*i:n:i] = [0] * ((n-1-i*i)//i+1) return sum(flags) 时间复杂度 O(N log N)，784 ms ","date":"2015-07-23","objectID":"/leetcode/0204/:3:0","tags":null,"title":"0204：计数质数（★★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"*附加 ","date":"2015-07-23","objectID":"/leetcode/0204/:4:0","tags":null,"title":"0204：计数质数（★★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"#1 基于埃氏筛法还有个很巧妙的动态规划方法。 令 dp[p][v] 代表埃氏筛法遍历到数 p 时没有标记的 [2, v] 内的个数： 如果 p*p \u003e v 或者 p 是合数: p 筛不到数，$dp[p][v] = dp[p-1][v]$。 如果 p*p \u003c= v 且 p 是质数: p 能筛掉合数 C=p*x 当且仅当 x 的最小质因数大于等于 p 因此 C 的个数 = x 的个数 = [p, v//p] 内最小质因数大于等于 p 的个数\r= 遍历到 p-1 时还没标记的 [p, v//p] 内的个数\r= dp[p-1][v//p] - dp[p-1][p-1]\r所以 $dp[p][v] = ","date":"2015-07-23","objectID":"/leetcode/0204/:4:1","tags":null,"title":"0204：计数质数（★★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"#2 注意反向遍历 v 就可以优化为一维数组。 并且当 p*p \u003e v 或者 p 是合数时，可以直接跳出遍历，极大地优化时间。 def countPrimes(self, n: int) -\u003e int: n -= 1 if n \u003c 2: return 0 r = int(sqrt(n)) V = [n//x for x in range(1, r)] + list(range(n//r, 0, -1)) dp = {v: v-1 for v in V} for p in range(2, r+1): for v in V: if dp[p]==dp[p-1] or p*p\u003ev: break d","date":"2015-07-23","objectID":"/leetcode/0204/:4:2","tags":null,"title":"0204：计数质数（★★★★★）","uri":"/leetcode/0204/"},{"categories":null,"content":"题目 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6\r输出：[1,2,3,4,5]\r示例 2： 输入：head = [], val = 1\r输出：[]\r示例 3： 输入：head = [7,7,7,7], val = 7\r输出：[]\r提示： 列表中的节点数目在范围 [0, 10^4] 内 1 \u003c= Node.val \u003c= 50 0 \u003c= val \u003c= 50 ","date":"2015-07-22","objectID":"/leetcode/0203/:1:0","tags":null,"title":"0203：移除链表元素","uri":"/leetcode/0203/"},{"categories":null,"content":"分析 遍历删除即可。头节点也可能删除，所以要建个哑结点。 ","date":"2015-07-22","objectID":"/leetcode/0203/:2:0","tags":null,"title":"0203：移除链表元素","uri":"/leetcode/0203/"},{"categories":null,"content":"解答 def removeElements(self, head: ListNode, val: int) -\u003e ListNode: dummy = p = ListNode(next=head) while p.next: if p.next.val == val: p.next = p.next.next else: p = p.next return dummy.next 76 ms ","date":"2015-07-22","objectID":"/leetcode/0203/:3:0","tags":null,"title":"0203：移除链表元素","uri":"/leetcode/0203/"},{"categories":null,"content":"题目 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 true ；不是，则返回 false 。 示例 1： 输入：19\r输出：true\r解释：\r12 + 92 = 82\r82 + 22 = 68\r62 + 82 = 100\r12 + 02 + 02 = 1\r示例 2： 输入：n = 2\r输出：false\r提示：1 \u003c= n \u003c= 2^31 - 1 ","date":"2015-07-21","objectID":"/leetcode/0202/:1:0","tags":null,"title":"0202：快乐数（★）","uri":"/leetcode/0202/"},{"categories":null,"content":"分析 直觉上这个过程中数不会越来越大，最终必然进入一个循环，判断是否在 1 上循环即可。 可以用数学知识证明： 设 n 是一个 k 位数，第一次替换后得到 n' 必然有 n’\u003c=81*k，n’的位数 \u003c= $3+\\lfloor log_{10}k \\rfloor$。 有限步之后 n 的位数必然 \u003c=3 ","date":"2015-07-21","objectID":"/leetcode/0202/:2:0","tags":null,"title":"0202：快乐数（★）","uri":"/leetcode/0202/"},{"categories":null,"content":"解答 def isHappy(self, n: int) -\u003e bool: vis = set() while n not in vis: vis.add(n) n = sum(int(x)**2 for x in str(n)) return n == 1 36 ms ","date":"2015-07-21","objectID":"/leetcode/0202/:3:0","tags":null,"title":"0202：快乐数（★）","uri":"/leetcode/0202/"},{"categories":null,"content":"*附加 还可以遍历 [0, 999] 来找出所有循环。最后发现只有两种循环： 1 → 1\r4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4\r故无需哈希表，直接判断是否变成 1 或 4 即可。 def isHappy(self, n: int) -\u003e bool: while n not in [1, 4]: n = sum(int(x)**2 for x in str(n)) return n == 1 32 ms ","date":"2015-07-21","objectID":"/leetcode/0202/:4:0","tags":null,"title":"0202：快乐数（★）","uri":"/leetcode/0202/"},{"categories":null,"content":"题目 给你两个整数 left 和 right ，表示区间 [left, right] ， 返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。 示例 1： 输入：left = 5, right = 7\r输出：4\r示例 2： 输入：left = 0, right = 0\r输出：0\r示例 3： 输入：left = 1, right = 2147483647\r输出：0\r提示： 0 \u003c= left \u003c= right \u003c= 2^31 - 1 ","date":"2015-07-20","objectID":"/leetcode/0201/:1:0","tags":null,"title":"0201：数字范围按位与（★★★）","uri":"/leetcode/0201/"},{"categories":null,"content":"分析 本题要利用位运算与的特性： 假如 right 的二进制位数比 left 多，结果必然为 0 假如位数相等，去掉 right 和 left 二进制的第一位，转为递归子问题 因此只需要找到 right 和 left 的二进制表示的公共前缀，后面补 0 即可 具体实现时有个巧妙的方法：right 不断去掉最右边的 1 直到 right\u003c=left，即为所求。 ","date":"2015-07-20","objectID":"/leetcode/0201/:2:0","tags":null,"title":"0201：数字范围按位与（★★★）","uri":"/leetcode/0201/"},{"categories":null,"content":"解答 def rangeBitwiseAnd(self, left: int, right: int) -\u003e int: while right \u003e left: right \u0026= right - 1 return right 48 ms ","date":"2015-07-20","objectID":"/leetcode/0201/:3:0","tags":null,"title":"0201：数字范围按位与（★★★）","uri":"/leetcode/0201/"},{"categories":null,"content":"题目 给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 输入：grid = [\r[\"1\",\"1\",\"1\",\"1\",\"0\"],\r[\"1\",\"1\",\"0\",\"1\",\"0\"],\r[\"1\",\"1\",\"0\",\"0\",\"0\"],\r[\"0\",\"0\",\"0\",\"0\",\"0\"]\r]\r输出：1\r示例 2： 输入：grid = [\r[\"1\",\"1\",\"0\",\"0\",\"0\"],\r[\"1\",\"1\",\"0\",\"0\",\"0\"],\r[\"0\",\"0\",\"","date":"2015-07-19","objectID":"/leetcode/0200/:1:0","tags":null,"title":"0200：岛屿数量（★★）","uri":"/leetcode/0200/"},{"categories":null,"content":"分析 本题可以用 dfs/bfs 遍历找到每一个岛。 不过连通问题一般还是用并查集，方便进阶问题的解决。 并查集做法： 将相邻的陆地连通 最终连通块的个数即是岛屿数量 ","date":"2015-07-19","objectID":"/leetcode/0200/:2:0","tags":null,"title":"0200：岛屿数量（★★）","uri":"/leetcode/0200/"},{"categories":null,"content":"解答 def numIslands(self, grid: List[List[str]]) -\u003e int: def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) f, m, n = {}, len(grid), len(grid[0]) for i, j in product(range(m), range(n)): if grid[i][j] == '1': f[(i, j)] = (i, j) if i and grid[i-1][j] == '1': ","date":"2015-07-19","objectID":"/leetcode/0200/:3:0","tags":null,"title":"0200：岛屿数量（★★）","uri":"/leetcode/0200/"},{"categories":null,"content":"题目 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序， 返回从右侧所能看到的节点值。 示例 1: 输入: [1,2,3,null,5,null,4]\r输出: [1,3,4]\r示例 2: 输入: [1,null,3]\r输出: [1,3]\r示例 3: 输入: []\r输出: []\r提示: 二叉树的节点个数的范围是 [0,100] -100 \u003c= Node.val \u003c= 100 ","date":"2015-07-18","objectID":"/leetcode/0199/:1:0","tags":null,"title":"0199：二叉树的右视图（★）","uri":"/leetcode/0199/"},{"categories":null,"content":"分析 层序遍历，保存每层的最后一个元素即可。 ","date":"2015-07-18","objectID":"/leetcode/0199/:2:0","tags":null,"title":"0199：二叉树的右视图（★）","uri":"/leetcode/0199/"},{"categories":null,"content":"解答 def rightSideView(self, root: Optional[TreeNode]) -\u003e List[int]: res, Q = [], [root] if root else [] while Q: res.append(Q[-1].val) Q = [child for p in Q for child in [p.left, p.right] if child] return res 28 ms ","date":"2015-07-18","objectID":"/leetcode/0199/:3:0","tags":null,"title":"0199：二叉树的右视图（★）","uri":"/leetcode/0199/"},{"categories":null,"content":"题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金， 影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统， 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ， 一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1]\r输出：4\r解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\r偷窃到的最高金额 = 1 + 3 = 4 。\r示例 2： 输入：[2,7,9,3,1]\r输出：12\r解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房","date":"2015-07-17","objectID":"/leetcode/0198/:1:0","tags":null,"title":"0198：打家劫舍（★）","uri":"/leetcode/0198/"},{"categories":null,"content":"分析 典型的线性 dp，按偷不偷最后一家即可递归。 按非递归形式的动态规划写时，可以优化为两个变量。 ","date":"2015-07-17","objectID":"/leetcode/0198/:2:0","tags":null,"title":"0198：打家劫舍（★）","uri":"/leetcode/0198/"},{"categories":null,"content":"解答 def rob(self, nums: List[int]) -\u003e int: a, b = 0, 0 for x in nums: a, b = b, max(x+a, b) return b 28 ms ","date":"2015-07-17","objectID":"/leetcode/0198/:3:0","tags":null,"title":"0198：打家劫舍（★）","uri":"/leetcode/0198/"},{"categories":null,"content":"题目 SQL架构 表： Weather +---------------+---------+\r| Column Name | Type |\r+---------------+---------+\r| id | int |\r| recordDate | date |\r| temperature | int |\r+---------------+---------+\rid 是这个表的主键\r该表包含特定日期的温度信息\r编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。 返回结果 不要求顺序 。 查询结果格式如下例。 示例 1： 输入：\rWeather 表：\r+--","date":"2015-07-16","objectID":"/leetcode/0197/:1:0","tags":null,"title":"0197：上升的温度（★）","uri":"/leetcode/0197/"},{"categories":null,"content":"分析 自连接并按条件选取即可。时间比较可以用 datediff。 ","date":"2015-07-16","objectID":"/leetcode/0197/:2:0","tags":null,"title":"0197：上升的温度（★）","uri":"/leetcode/0197/"},{"categories":null,"content":"解答 select a.id as id from weather a inner join weather b on datediff(a.recordDate , b.recordDate )=1 and a.Temperature\u003eb.Temperature 480 ms ","date":"2015-07-16","objectID":"/leetcode/0197/:3:0","tags":null,"title":"0197：上升的温度（★）","uri":"/leetcode/0197/"},{"categories":null,"content":"题目 SQL架构 表: Person +-------------+---------+\r| Column Name | Type |\r+-------------+---------+\r| id | int |\r| email | varchar |\r+-------------+---------+\rid是该表的主键列。\r该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。\r编写一个 SQL 删除语句来 删除 所有重复的电子邮件，只保留一个id最小的唯一电子邮件。 以 任意顺序 返回结果表。 （注意： 仅需要写删除语句，将自动对剩余结果进行查询） 查询结果格式如下所示。 示例 1: 输","date":"2015-07-15","objectID":"/leetcode/0196/:1:0","tags":null,"title":"0196：删除重复的电子邮箱（★）","uri":"/leetcode/0196/"},{"categories":null,"content":"分析 自连接然后按条件删除即可。 ","date":"2015-07-15","objectID":"/leetcode/0196/:2:0","tags":null,"title":"0196：删除重复的电子邮箱（★）","uri":"/leetcode/0196/"},{"categories":null,"content":"解答 delete p1 from Person p1 inner join Person p2 on p1.email = p2.email and p1.id \u003e p2.id 861 ms ","date":"2015-07-15","objectID":"/leetcode/0196/:3:0","tags":null,"title":"0196：删除重复的电子邮箱（★）","uri":"/leetcode/0196/"},{"categories":null,"content":"题目 给定一个文本文件 file.txt，请只打印这个文件中的第十行。 示例: 假设 file.txt 有如下内容： Line 1\rLine 2\rLine 3\rLine 4\rLine 5\rLine 6\rLine 7\rLine 8\rLine 9\rLine 10\r你的脚本应当显示第十行： Line 10\r说明: 如果文件少于十行，你应当输出什么？ 至少有三种不同的解法，请尝试尽可能多的方法来解题。 ","date":"2015-07-14","objectID":"/leetcode/0195/:1:0","tags":null,"title":"0195：第十行（★）","uri":"/leetcode/0195/"},{"categories":null,"content":"分析 需要用到的操作： sed -n '1p' -n 定位到第 1 行，然后 p 打印\r","date":"2015-07-14","objectID":"/leetcode/0195/:2:0","tags":null,"title":"0195：第十行（★）","uri":"/leetcode/0195/"},{"categories":null,"content":"解答 sed -n '10p' file.txt 4 ms ","date":"2015-07-14","objectID":"/leetcode/0195/:3:0","tags":null,"title":"0195：第十行（★）","uri":"/leetcode/0195/"},{"categories":null,"content":"题目 给定一个文件 file.txt，转置它的内容。 你可以假设每行列数相同，并且每个字段由 ’ ’ 分隔。 示例： 假设 file.txt 文件内容如下： name age\ralice 21\rryan 30\r应当输出： name alice ryan\rage 21 30\r","date":"2015-07-13","objectID":"/leetcode/0194/:1:0","tags":null,"title":"0194：转置文件（★★）","uri":"/leetcode/0194/"},{"categories":null,"content":"分析 需要用到的操作： cat 浏览文件\rhead -n 取前 n 行\rwc -w 获取当前行的列数\rxargs 转为单行输出\rcut -d' ' f1 按空格分割，取第一列\r","date":"2015-07-13","objectID":"/leetcode/0194/:2:0","tags":null,"title":"0194：转置文件（★★）","uri":"/leetcode/0194/"},{"categories":null,"content":"解答 col=$(cat file.txt | head -n 1 | wc -w) for i in $(seq 1 $col) do cut -d' ' -f$i file.txt | xargs done 8 ms ","date":"2015-07-13","objectID":"/leetcode/0194/:3:0","tags":null,"title":"0194：转置文件（★★）","uri":"/leetcode/0194/"},{"categories":null,"content":"题目 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt， 写一个单行 bash 脚本输出所有有效的电话号码。 你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字） 你也可以假设每行前后没有多余的空格字符。 示例： 假设 file.txt 内容如下： 987-123-4567\r123 456 7890\r(123) 456-7890\r你的脚本应当输出下列有效的电话号码： 987-123-4567\r(123) 456-7890\r","date":"2015-07-12","objectID":"/leetcode/0193/:1:0","tags":null,"title":"0193：有效电话号码（★★）","uri":"/leetcode/0193/"},{"categories":null,"content":"分析 正则匹配，需要用到的操作： grep -P 用 perl 模式的正则，能支持 \\d\r","date":"2015-07-12","objectID":"/leetcode/0193/:2:0","tags":null,"title":"0193：有效电话号码（★★）","uri":"/leetcode/0193/"},{"categories":null,"content":"解答 grep -P '^(\\d{3}-|\\(\\d{3}\\) )\\d{3}-\\d{4}$' file.txt 8 ms ","date":"2015-07-12","objectID":"/leetcode/0193/:3:0","tags":null,"title":"0193：有效电话号码（★★）","uri":"/leetcode/0193/"},{"categories":null,"content":"题目 写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。 为了简单起见，你可以假设： words.txt只包括小写字母和 ’ ’ 。 每个单词只由小写字母组成。 单词间由一个或多个空格字符分隔。 示例: 假设 words.txt 内容如下： the day is sunny the the\rthe sunny is is\r你的脚本应当输出（以词频降序排列）： the 4\ris 3\rsunny 2\rday 1\r说明: 不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。 你可以使用一行 Unix pipes 实现吗？ ","date":"2015-07-11","objectID":"/leetcode/0192/:1:0","tags":null,"title":"0192：统计词频（★★）","uri":"/leetcode/0192/"},{"categories":null,"content":"分析 需要用到的操作： cat 浏览文件\rtr -s 替换字符串\rsort 排序\runiq -c 输出 sort -r 反向排序\rawk 格式化输出， $1、$2 取元素\r","date":"2015-07-11","objectID":"/leetcode/0192/:2:0","tags":null,"title":"0192：统计词频（★★）","uri":"/leetcode/0192/"},{"categories":null,"content":"解答 cat words.txt | tr -s ' ' '\\n' | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' 8 ms ","date":"2015-07-11","objectID":"/leetcode/0192/:3:0","tags":null,"title":"0192：统计词频（★★）","uri":"/leetcode/0192/"},{"categories":null,"content":"题目 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中 数字位数为 ‘1’ 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下， 输入和输出都将被指定为有符号整数类型，并且不应影响您的实现， 因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此， 在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1： 输入：00000000000000000000000000001011\r输出：3\r解释：输入的二进制串 0000000","date":"2015-07-10","objectID":"/leetcode/0191/:1:0","tags":null,"title":"0191：位1的个数（★）","uri":"/leetcode/0191/"},{"categories":null,"content":"分析 ","date":"2015-07-10","objectID":"/leetcode/0191/:2:0","tags":null,"title":"0191：位1的个数（★）","uri":"/leetcode/0191/"},{"categories":null,"content":"#1 可以直接调包。 def hammingWeight(self, n: int) -\u003e int: return n.bit_count() 32 ms ","date":"2015-07-10","objectID":"/leetcode/0191/:2:1","tags":null,"title":"0191：位1的个数（★）","uri":"/leetcode/0191/"},{"categories":null,"content":"#2 有个巧妙的位计算技巧，n \u0026 (n-1) 等价于将 n 中最后一个 1 变为 0。 循环操作直到 n 变为 0 即可。 ","date":"2015-07-10","objectID":"/leetcode/0191/:2:2","tags":null,"title":"0191：位1的个数（★）","uri":"/leetcode/0191/"},{"categories":null,"content":"解答 def hammingWeight(self, n: int) -\u003e int: res = 0 while n: n \u0026= n - 1 res += 1 return res 40 ms ","date":"2015-07-10","objectID":"/leetcode/0191/:3:0","tags":null,"title":"0191：位1的个数（★）","uri":"/leetcode/0191/"},{"categories":null,"content":"题目 颠倒给定的 32 位无符号整数的二进制位。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下， 输入和输出都将被指定为有符号整数类型，并且不应影响您的实现， 因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中， 输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 示例 1： 输入：n = 00000010100101000001111010011100\r输出：964176192 (0011100101111000001010010100","date":"2015-07-09","objectID":"/leetcode/0190/:1:0","tags":null,"title":"0190：颠倒二进制位（★）","uri":"/leetcode/0190/"},{"categories":null,"content":"分析 类似于 0007，转为字符串再反转，或者按位依次构建皆可。 ","date":"2015-07-09","objectID":"/leetcode/0190/:2:0","tags":null,"title":"0190：颠倒二进制位（★）","uri":"/leetcode/0190/"},{"categories":null,"content":"解答 def reverseBits(self, n: int) -\u003e int: return int(bin(n)[2:].zfill(32)[::-1], 2) 32 ms ","date":"2015-07-09","objectID":"/leetcode/0190/:3:0","tags":null,"title":"0190：颠倒二进制位（★）","uri":"/leetcode/0190/"},{"categories":null,"content":"题目 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3\r输出: [5,6,7,1,2,3,4]\r解释:\r向右旋转 1 步: [7,1,2,3,4,5,6]\r向右旋转 2 步: [6,7,1,2,3,4,5]\r向右旋转 3 步: [5,6,7,1,2,3,4]\r示例 2: 输入：nums = [-1,-100,3,99], k = 2\r输出：[3,99,-1,-100]\r解释: 向右旋转 1 步: [99,-1,-100,3]\r向右旋转 2 步: [3,99,-1,-100]\r提示： 1 \u003c= ","date":"2015-07-08","objectID":"/leetcode/0189/:1:0","tags":null,"title":"0189：旋转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"分析 ","date":"2015-07-08","objectID":"/leetcode/0189/:2:0","tags":null,"title":"0189：旋转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"#1 最简单的就是切片。 def rotate(self, nums: List[int], k: int) -\u003e None: k %= len(nums) nums[:] = nums[-k:] + nums[:-k] 40 ms ","date":"2015-07-08","objectID":"/leetcode/0189/:2:1","tags":null,"title":"0189：旋转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"#2 要求空间复杂度 O(1)，有一个很巧妙的方法。 将 nums 反转，和最终结果比较，发现只要再将 nums[:k] 和 nums[k:] 反转即可。 ","date":"2015-07-08","objectID":"/leetcode/0189/:2:2","tags":null,"title":"0189：旋转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"解答 def rotate(self, nums: List[int], k: int) -\u003e None: def rev(i, j): while i \u003c j: nums[i], nums[j] = nums[j], nums[i] i += 1 j -= 1 n = len(nums) k %= n rev(0, n-1) rev(0, k-1) rev(k, n-1) 56 ms ","date":"2015-07-08","objectID":"/leetcode/0189/:3:0","tags":null,"title":"0189：旋转数组（★）","uri":"/leetcode/0189/"},{"categories":null,"content":"题目 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 输入：k = 2, prices = [2,4,1]\r输出：2\r解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，\r这笔交易所能获得利润 = 4-2 = 2 。\r示例 2： 输入：k = 2, prices = [3,2,6,5,0,3]\r输出：7\r解释：在第 2 天 (股票价","date":"2015-07-07","objectID":"/leetcode/0188/:1:0","tags":null,"title":"0188：买卖股票的最佳时机 IV（★★★）","uri":"/leetcode/0188/"},{"categories":null,"content":"分析 类似 0121，只是从 2 次变成了 k 次。 ","date":"2015-07-07","objectID":"/leetcode/0188/:2:0","tags":null,"title":"0188：买卖股票的最佳时机 IV（★★★）","uri":"/leetcode/0188/"},{"categories":null,"content":"解答 def maxProfit(self, k: int, prices: List[int]) -\u003e int: n = len(prices) dp = [[float('-inf'), 0] for _ in range(k+1)] for x in prices: prev = dp[:] for j in range(1, k+1): dp[j][0] = max(prev[j][0], prev[j-1][1]-x) dp[j][1] = max(prev[j][1], prev[j][0]+x) return dp[-1][-1] 84 ms ","date":"2015-07-07","objectID":"/leetcode/0188/:3:0","tags":null,"title":"0188：买卖股票的最佳时机 IV（★★★）","uri":"/leetcode/0188/"},{"categories":null,"content":"题目 DNA序列 由一系列核苷酸组成，缩写为 ‘A’, ‘C’, ‘G’ 和 ‘T’.。 例如，“ACGAATTCCG” 是一个 DNA序列 。 在研究 DNA 时，识别 DNA 中的重复序列非常有用。 给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。 你可以按 任意顺序 返回答案。 示例 1： 输入：s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\r输出：[\"AAAAACCCCC\",\"CCCCCAAAAA\"]\r示例 2： 输入：s = \"AAAAAAAAAAAAA\"\r输出：[\"AAAAAAAAA","date":"2015-07-06","objectID":"/leetcode/0187/:1:0","tags":null,"title":"0187：重复的DNA序列（★★）","uri":"/leetcode/0187/"},{"categories":null,"content":"分析 ","date":"2015-07-06","objectID":"/leetcode/0187/:2:0","tags":null,"title":"0187：重复的DNA序列（★★）","uri":"/leetcode/0187/"},{"categories":null,"content":"#1 最简单的就是依次遍历子串，用哈希表判断是否出现过即可。 def findRepeatedDnaSequences(self, s: str) -\u003e List[str]: ct = Counter(s[i:i + 10] for i in range(len(s) - 9)) return [sub for sub, freq in ct.items() if freq \u003e 1] 60 ms ","date":"2015-07-06","objectID":"/leetcode/0187/:2:1","tags":null,"title":"0187：重复的DNA序列（★★）","uri":"/leetcode/0187/"},{"categories":null,"content":"#2 当子串长度较大时，朴素哈希比较耗时。更为通用的方法是滚动哈希。 ","date":"2015-07-06","objectID":"/leetcode/0187/:2:2","tags":null,"title":"0187：重复的DNA序列（★★）","uri":"/leetcode/0187/"},{"categories":null,"content":"解答 def findRepeatedDnaSequences(self, s: str) -\u003e List[str]: d = dict(zip('ACGT', range(4))) base, L = 5, 10 w, bL = 0, base**L res, ct = [], Counter() for j, char in enumerate(s): w = w * base + d[char] if j \u003e= L: w -= d[s[j-L]] * bL if j \u003e= L-1: ct[w] += 1 if ct[w] == 2: res.append(s[j-L+1:j+1]) re","date":"2015-07-06","objectID":"/leetcode/0187/:3:0","tags":null,"title":"0187：重复的DNA序列（★★）","uri":"/leetcode/0187/"},{"categories":null,"content":"题目 SQL架构 表: Employee +--------------+---------+\r| Column Name | Type |\r+--------------+---------+\r| id | int |\r| name | varchar |\r| salary | int |\r| departmentId | int |\r+--------------+---------+\rId是该表的主键列。\rdepartmentId是Department表中ID的外键。\r该表的每一行都表示员工的ID、姓名和工资。它还包含了他们部门的ID。\r表: Department +----------","date":"2015-07-04","objectID":"/leetcode/0185/:1:0","tags":null,"title":"0185：部门工资前三高的所有员工（★★）","uri":"/leetcode/0185/"},{"categories":null,"content":"分析 0184 升级版。 可以将每个员工和比自己工资高的连接，将连接数小于 3 的员工返回即可。 ","date":"2015-07-04","objectID":"/leetcode/0185/:2:0","tags":null,"title":"0185：部门工资前三高的所有员工（★★）","uri":"/leetcode/0185/"},{"categories":null,"content":"解答 select b.name as Department, a.name as Employee, a.salary as Salary from Employee a left join Department b on a.departmentId = b.id left join Employee c on a.departmentId = c.departmentId and a.salary \u003c c.salary group by a.id having count(distinct c.salary)\u003c3 881 ms ","date":"2015-07-04","objectID":"/leetcode/0185/:3:0","tags":null,"title":"0185：部门工资前三高的所有员工（★★）","uri":"/leetcode/0185/"},{"categories":null,"content":"思春期的少年少女中极少部分人会发作的特殊能力。\n驱使着无人知晓的能力，过着顺风顺水学园生活的乙坂有宇。\n突然出现在这样的他的面前的少女，友利奈绪。\n从与她相遇之日起，被揭露出来的特殊能力者的宿命。\n这是由麻枝准所描绘的，特殊能力者们奔跑着的青春物语——。","date":"2015-07-04","objectID":"/anime/charlotte/","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":"简介 思春期的少年少女中极少部分人会发作的特殊能力。 驱使着无人知晓的能力，过着顺风顺水学园生活的乙坂有宇。 突然出现在这样的他的面前的少女，友利奈绪。 从与她相遇之日起，被揭露出来的特殊能力者的宿命。 这是由麻枝准所描绘的，特殊能力者们奔跑着的青春物语——。 制作人员： 原作：Visual Art’s、Key、麻枝准 导演：浅井义之 分镜：筱原俊哉、湖山祯崇、福田道生 ","date":"2015-07-04","objectID":"/anime/charlotte/:1:0","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 友利奈绪 友利 奈緒、ともり なお、Tomori Nao 女 佐倉綾音 2 乙坂有宇 Yuu Otosaka、乙坂 有宇、おとさか ゆう、Otosaka Yū、独眼死神（隻眼の死神） 男 内山昂輝 3 高城丈士朗 高城 丈士朗、たかじょう じょうじろう、Takajō Jōjirō 男 水島大宙 4 西森柚咲 黑羽柚咲、西森 柚咲、にしもり ゆさ、Nishimori Yusa、黒羽柚咲、くろはね ゆさ、Kurobane Yusa 女 内田真礼 5 乙坂步未 乙坂 歩未、おとさか あゆみ、Otosaka Ayumi 女 麻倉もも 6 黑羽美砂 黒羽 美砂、くろば","date":"2015-07-04","objectID":"/anime/charlotte/:2:0","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 夏洛特 2015-07-04 14 bilibili ","date":"2015-07-04","objectID":"/anime/charlotte/:3:0","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":"MAD ","date":"2015-07-04","objectID":"/anime/charlotte/:4:0","tags":null,"title":"夏洛特","uri":"/anime/charlotte/"},{"categories":null,"content":"题目 SQL架构 表： Employee +--------------+---------+\r| 列名 | 类型 |\r+--------------+---------+\r| id | int |\r| name | varchar |\r| salary | int |\r| departmentId | int |\r+--------------+---------+\rid是此表的主键列。\rdepartmentId是Department表中ID的外键。\r此表的每一行都表示员工的ID、姓名和工资。它还包含他们所在部门的ID。\r表： Department +-------------+------","date":"2015-07-03","objectID":"/leetcode/0184/:1:0","tags":null,"title":"0184：部门工资最高的员工（★★）","uri":"/leetcode/0184/"},{"categories":null,"content":"分析 先按部门分组得到每个组的最大工资，并作为临时表， 然后与 Employee、Department 按部门 id 连接并判断员工工资是否为最大工资即可。 ","date":"2015-07-03","objectID":"/leetcode/0184/:2:0","tags":null,"title":"0184：部门工资最高的员工（★★）","uri":"/leetcode/0184/"},{"categories":null,"content":"解答 select b.name as Department, a.name as Employee, a.salary as Salary from Employee a left join Department b on a.departmentId = b.id inner join ( select departmentId, max(salary) salary from Employee group by departmentId ) c on a.departmentId = c.departmentId and a.salary = c.salary 681 ms ","date":"2015-07-03","objectID":"/leetcode/0184/:3:0","tags":null,"title":"0184：部门工资最高的员工（★★）","uri":"/leetcode/0184/"},{"categories":null,"content":"题目 SQL架构 某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： +----+-------+\r| Id | Name |\r+----+-------+\r| 1 | Joe |\r| 2 | Henry |\r| 3 | Sam |\r| 4 | Max |\r+----+-------+\rOrders 表： +----+------------+\r| Id | CustomerId |\r+----+------------+\r| 1 | 3 |\r| 2 | 1 |\r+----+------------+","date":"2015-07-02","objectID":"/leetcode/0183/:1:0","tags":null,"title":"0183：从不订购的客户（★）","uri":"/leetcode/0183/"},{"categories":null,"content":"分析 返回左连接没成功的即可。 ","date":"2015-07-02","objectID":"/leetcode/0183/:2:0","tags":null,"title":"0183：从不订购的客户（★）","uri":"/leetcode/0183/"},{"categories":null,"content":"解答 select a.Name as Customers from Customers a left join Orders b on a.Id = b.CustomerId where b.Id is null 520 ms ","date":"2015-07-02","objectID":"/leetcode/0183/:3:0","tags":null,"title":"0183：从不订购的客户（★）","uri":"/leetcode/0183/"},{"categories":null,"content":"题目 SQL架构 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 示例： +----+---------+\r| Id | Email |\r+----+---------+\r| 1 | a@b.com |\r| 2 | c@d.com |\r| 3 | a@b.com |\r+----+---------+\r根据以上输入，你的查询应返回以下结果： +---------+\r| Email |\r+---------+\r| a@b.com |\r+---------+\r说明：所有电子邮箱都是小写字母。 ","date":"2015-07-01","objectID":"/leetcode/0182/:1:0","tags":null,"title":"0182：查找重复的电子邮箱（★）","uri":"/leetcode/0182/"},{"categories":null,"content":"分析 分组计数即可。 ","date":"2015-07-01","objectID":"/leetcode/0182/:2:0","tags":null,"title":"0182：查找重复的电子邮箱（★）","uri":"/leetcode/0182/"},{"categories":null,"content":"解答 select Email from Person group by Email having count(Email) \u003e 1 394 ms ","date":"2015-07-01","objectID":"/leetcode/0182/:3:0","tags":null,"title":"0182：查找重复的电子邮箱（★）","uri":"/leetcode/0182/"},{"categories":null,"content":"题目 SQL架构 表：Employee +-------------+---------+\r| Column Name | Type |\r+-------------+---------+\r| id | int |\r| name | varchar |\r| salary | int |\r| managerId | int |\r+-------------+---------+\rId是该表的主键。\r该表的每一行都表示雇员的ID、姓名、工资和经理的ID。\r编写一个SQL查询来查找收入比经理高的员工。 以 任意顺序 返回结果表。 查询结果格式如下所示。 示例 1: 输入: Employee 表:\r+","date":"2015-06-30","objectID":"/leetcode/0181/:1:0","tags":null,"title":"0181：超过经理收入的员工（★）","uri":"/leetcode/0181/"},{"categories":null,"content":"分析 自连接并判断即可。 ","date":"2015-06-30","objectID":"/leetcode/0181/:2:0","tags":null,"title":"0181：超过经理收入的员工（★）","uri":"/leetcode/0181/"},{"categories":null,"content":"解答 select a.name as Employee from Employee a inner join Employee b on a.managerId = b.id and a.salary \u003e b.salary 375 ms ","date":"2015-06-30","objectID":"/leetcode/0181/:3:0","tags":null,"title":"0181：超过经理收入的员工（★）","uri":"/leetcode/0181/"},{"categories":null,"content":"题目 SQL架构 表：Logs +-------------+---------+\r| Column Name | Type |\r+-------------+---------+\r| id | int |\r| num | varchar |\r+-------------+---------+\rid 是这个表的主键。\r编写一个 SQL 查询，查找所有至少连续出现三次的数字。 返回的结果表中的数据可以按 任意顺序 排列。 查询结果格式如下面的例子所示： 示例 1: 输入：\rLogs 表：\r+----+-----+\r| Id | Num |\r+----+-----+\r| 1 | 1 |\r| 2 |","date":"2015-06-29","objectID":"/leetcode/0180/:1:0","tags":null,"title":"0180：连续出现的数字（★★）","uri":"/leetcode/0180/"},{"categories":null,"content":"分析 可以采用窗口函数 lag/lead。 ","date":"2015-06-29","objectID":"/leetcode/0180/:2:0","tags":null,"title":"0180：连续出现的数字（★★）","uri":"/leetcode/0180/"},{"categories":null,"content":"解答 select distinct num as ConsecutiveNums from ( select num, lag(num, 1, null) over (order by id) prev, lead(num, 1, null) over (order by id) post from logs ) a where a.num = a.prev and a.num = a.post 536 ms ","date":"2015-06-29","objectID":"/leetcode/0180/:3:0","tags":null,"title":"0180：连续出现的数字（★★）","uri":"/leetcode/0180/"},{"categories":null,"content":"题目 给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。 示例 1： 输入：nums = [10,2]\r输出：\"210\"\r示例 2： 输入：nums = [3,30,34,5,9]\r输出：\"9534330\"\r提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 10^9 ","date":"2015-06-28","objectID":"/leetcode/0179/:1:0","tags":null,"title":"0179：最大数（★★★）","uri":"/leetcode/0179/"},{"categories":null,"content":"分析 首先想到按字典序降序拼接，但是某些情况并不适用。 例如 [3,30,34,5,9] 的字典序降序为 [9,5,34,30,3]，但正确的顺序应该是 [9,5,34,3,30]。 因此需要重新定义优先顺序。这里有个巧妙的想法，只要 $\\overline{AB}\u003e\\overline{BA}$， 就认为 A 的优先级更高，应该排在前面。直觉告诉我们这样很可能是正确的，不过需要证明一下。 采用反证法： 假设最大结果 res 中存在 $\\overline{AB}\u003e\\overline{BA}$ 但 B 排在 A 的前面。 显然 B 和 A 不可能是相邻的，否则直接交换就得到更大的结果了。 故res ","date":"2015-06-28","objectID":"/leetcode/0179/:2:0","tags":null,"title":"0179：最大数（★★★）","uri":"/leetcode/0179/"},{"categories":null,"content":"解答 def largestNumber(self, nums: List[int]) -\u003e str: compare = lambda x,y: 1 if x+y\u003cy+x else -1 if x+y\u003ey+x else 0 res = ''.join(sorted(map(str, nums), key=cmp_to_key(compare))) return res.lstrip('0') or '0' 时间复杂度 $O(N*log_N)$，44 ms ","date":"2015-06-28","objectID":"/leetcode/0179/:3:0","tags":null,"title":"0179：最大数（★★★）","uri":"/leetcode/0179/"},{"categories":null,"content":"题目 SQL架构 表: Scores +-------------+---------+\r| Column Name | Type |\r+-------------+---------+\r| id | int |\r| score | decimal |\r+-------------+---------+\rId是该表的主键。\r该表的每一行都包含了一场比赛的分数。Score是一个有两位小数点的浮点值。\r编写 SQL 查询对分数进行排序。排名按以下规则计算: 分数应按从高到低排列。 如果两个分数相等，那么两个分数的排名应该相同。 在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不","date":"2015-06-27","objectID":"/leetcode/0178/:1:0","tags":null,"title":"0178：分数排名（★★）","uri":"/leetcode/0178/"},{"categories":null,"content":"分析 调用 dense_rank 即可。 ","date":"2015-06-27","objectID":"/leetcode/0178/:2:0","tags":null,"title":"0178：分数排名（★★）","uri":"/leetcode/0178/"},{"categories":null,"content":"解答 select score, dense_rank() over (order by score desc) as \"rank\" from Scores 280 ms ","date":"2015-06-27","objectID":"/leetcode/0178/:3:0","tags":null,"title":"0178：分数排名（★★）","uri":"/leetcode/0178/"},{"categories":null,"content":"题目 SQL架构 表: Employee +-------------+------+\r| Column Name | Type |\r+-------------+------+\r| id | int |\r| salary | int |\r+-------------+------+\rId是该表的主键列。\r该表的每一行都包含有关员工工资的信息。\r编写一个SQL查询来报告 Employee 表中第 n 高的工资。 如果没有第 n 个最高工资，查询应该报告为 null 。 查询结果格式如下所示。 示例 1: 输入: Employee table:\r+----+--------+\r| id | sa","date":"2015-06-26","objectID":"/leetcode/0177/:1:0","tags":null,"title":"0177：第N高的薪水（★★）","uri":"/leetcode/0177/"},{"categories":null,"content":"分析 0176 升级版，注意查找中不能运算 N-1，所以提前减 1。 ","date":"2015-06-26","objectID":"/leetcode/0177/:2:0","tags":null,"title":"0177：第N高的薪水（★★）","uri":"/leetcode/0177/"},{"categories":null,"content":"解答 CREATE FUNCTION getNthHighestSalary ( N INT ) RETURNS INT BEGIN SET N = N - 1; RETURN ( # Write your MySQL query statement below. SELECT DISTINCT salary FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET N ); END 372 ms ","date":"2015-06-26","objectID":"/leetcode/0177/:3:0","tags":null,"title":"0177：第N高的薪水（★★）","uri":"/leetcode/0177/"},{"categories":null,"content":"题目 SQL架构 Employee 表： +-------------+------+\r| Column Name | Type |\r+-------------+------+\r| id | int |\r| salary | int |\r+-------------+------+\rid 是这个表的主键。\r表的每一行包含员工的工资信息。\r编写一个 SQL 查询，获取并返回 Employee 表中第二高的薪水 。 如果不存在第二高的薪水，查询应该返回 null 。 查询结果如下例所示。 示例 1： 输入：\rEmployee 表：\r+----+--------+\r| id | salary |\r","date":"2015-06-25","objectID":"/leetcode/0176/:1:0","tags":null,"title":"0176：第二高的薪水（★★）","uri":"/leetcode/0176/"},{"categories":null,"content":"分析 按 salary 排序即可。注意： 要去掉重复值，用 distinct 没有时要返回 null，所以外面再套一层 ","date":"2015-06-25","objectID":"/leetcode/0176/:2:0","tags":null,"title":"0176：第二高的薪水（★★）","uri":"/leetcode/0176/"},{"categories":null,"content":"解答 select ( select distinct salary from Employee order by salary desc limit 1 offset 1 ) as SecondHighestSalary 233 ms ","date":"2015-06-25","objectID":"/leetcode/0176/:3:0","tags":null,"title":"0176：第二高的薪水（★★）","uri":"/leetcode/0176/"},{"categories":null,"content":"题目 SQL架构 表: Person +-------------+---------+\r| 列名 | 类型 |\r+-------------+---------+\r| PersonId | int |\r| FirstName | varchar |\r| LastName | varchar |\r+-------------+---------+\rpersonId 是该表的主键列。\r该表包含一些人的 ID 和他们的姓和名的信息。\r表: Address +-------------+---------+\r| 列名 | 类型 |\r+-------------+---------+\r| Addres","date":"2015-06-24","objectID":"/leetcode/0175/:1:0","tags":null,"title":"0175：组合两个表（★）","uri":"/leetcode/0175/"},{"categories":null,"content":"分析 左连接即可。 ","date":"2015-06-24","objectID":"/leetcode/0175/:2:0","tags":null,"title":"0175：组合两个表（★）","uri":"/leetcode/0175/"},{"categories":null,"content":"解答 select p.firstName,p.lastName,a.city,a.state from Person p left join Address a on p.personId = a.personId 408 ms ","date":"2015-06-24","objectID":"/leetcode/0175/:3:0","tags":null,"title":"0175：组合两个表（★）","uri":"/leetcode/0175/"},{"categories":null,"content":"题目 一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。 我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数 （若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0）， 要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。 为了尽快到达公主，骑士决定每次只向右或向下移动一步。 编写一个函数来计","date":"2015-06-23","objectID":"/leetcode/0174/:1:0","tags":null,"title":"0174：地下城游戏（★★）","uri":"/leetcode/0174/"},{"categories":null,"content":"分析 典型的矩阵 dp，按第一步向右或向下递归即可。 注意必须一直保持正整数。 ","date":"2015-06-23","objectID":"/leetcode/0174/:2:0","tags":null,"title":"0174：地下城游戏（★★）","uri":"/leetcode/0174/"},{"categories":null,"content":"解答 def calculateMinimumHP(self, dungeon: List[List[int]]) -\u003e int: @lru_cache(None) def dfs(i, j): if (i, j) == (m-1, n-1): return max(1, 1-dungeon[i][j]) res = min(dfs(x, y) for x, y in [(i+1, j), (i, j+1)] if x\u003cm and y\u003cn) return max(1, res-dungeon[i][j]) m, n = len(dungeon), len(dungeon[0]) return ","date":"2015-06-23","objectID":"/leetcode/0174/:3:0","tags":null,"title":"0174：地下城游戏（★★）","uri":"/leetcode/0174/"},{"categories":null,"content":"题目 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器： BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。 BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字， 且该数字小于 BST 中的任何元素。 boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。 int next()将指针向右移动，然后返回指针处的数字。 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次","date":"2015-06-22","objectID":"/leetcode/0173/:1:0","tags":null,"title":"0173：二叉搜索树迭代器（★）","uri":"/leetcode/0173/"},{"categories":null,"content":"分析 模拟中序遍历的过程即可。 为了方便，可以将遍历过程写在 hasNext 中，然后每次 next 时先调用 hasNext。 ","date":"2015-06-22","objectID":"/leetcode/0173/:2:0","tags":null,"title":"0173：二叉搜索树迭代器（★）","uri":"/leetcode/0173/"},{"categories":null,"content":"解答 class BSTIterator: def __init__(self, root: TreeNode): self.stack = [root] def next(self) -\u003e int: if self.hasNext(): return self.stack.pop() def hasNext(self) -\u003e bool: while self.stack: node = self.stack.pop() if isinstance(node, int): self.stack.append(node) return True if node: self.stack.exten","date":"2015-06-22","objectID":"/leetcode/0173/:3:0","tags":null,"title":"0173：二叉搜索树迭代器（★）","uri":"/leetcode/0173/"},{"categories":null,"content":"题目 给定一个整数 n ，返回 n! 结果中尾随零的数量。 提示 n! = n * (n - 1) * (n - 2) * … * 3 * 2 * 1 示例 1： 输入：n = 3\r输出：0\r解释：3! = 6 ，不含尾随 0\r示例 2： 输入：n = 5\r输出：1\r解释：5! = 120 ，有一个尾随 0\r示例 3： 输入：n = 0\r输出：0\r提示： 0 \u003c= n \u003c= 10^4 进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？ ","date":"2015-06-21","objectID":"/leetcode/0172/:1:0","tags":null,"title":"0172：阶乘后的零（★）","uri":"/leetcode/0172/"},{"categories":null,"content":"分析 数学分析： 结尾零的个数等于 n! 的质因数中 (2, 5) 对的个数 显然 5 更少，因此结果就等于因子 5 的个数 从 1 到 n ，含有 1 个因子 5 的个数是 n // 5，含有 2 个因子 5 的个数是 n // 25，依此类推 因此结果为： n // 5 + n // 25 + n // 125 + ...\r","date":"2015-06-21","objectID":"/leetcode/0172/:2:0","tags":null,"title":"0172：阶乘后的零（★）","uri":"/leetcode/0172/"},{"categories":null,"content":"解答 def trailingZeroes(self, n: int) -\u003e int: res = 0 while n: n //= 5 res += n return res 28 ms ","date":"2015-06-21","objectID":"/leetcode/0172/:3:0","tags":null,"title":"0172：阶乘后的零（★）","uri":"/leetcode/0172/"},{"categories":null,"content":"题目 给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。 例如： A -\u003e 1\rB -\u003e 2\rC -\u003e 3\r...\rZ -\u003e 26\rAA -\u003e 27\rAB -\u003e 28 ...\r示例 1: 输入: columnTitle = \"A\"\r输出: 1\r示例 2: 输入: columnTitle = \"AB\"\r输出: 28\r示例 3: 输入: columnTitle = \"ZY\"\r输出: 701\r提示： 1 \u003c= columnTitle.length \u003c= 7 columnTitle 仅由大写英文组成 columnTitle 在范围 [“A”, “","date":"2015-06-20","objectID":"/leetcode/0171/:1:0","tags":null,"title":"0171：Excel表列序号","uri":"/leetcode/0171/"},{"categories":null,"content":"分析 类似 26 进制，只不过每一位的范围是 [1, 26] 而不是 [0, 25]。 ","date":"2015-06-20","objectID":"/leetcode/0171/:2:0","tags":null,"title":"0171：Excel表列序号","uri":"/leetcode/0171/"},{"categories":null,"content":"解答 def titleToNumber(self, columnTitle: str) -\u003e int: res = 0 for char in columnTitle: res = res * 26 + ord(char) - ord('A') + 1 return res 36 ms ","date":"2015-06-20","objectID":"/leetcode/0171/:3:0","tags":null,"title":"0171：Excel表列序号","uri":"/leetcode/0171/"},{"categories":null,"content":"题目 给定一个大小为 n 的数组 nums ，返回其中的多数元素。 多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 输入：nums = [3,2,3]\r输出：3\r示例 2： 输入：nums = [2,2,1,1,1,2,2]\r输出：2\r提示： n == nums.length 1 \u003c= n \u003c= 5 * 104 -10^9 \u003c= nums[i] \u003c= 10^9 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。 ","date":"2015-06-18","objectID":"/leetcode/0169/:1:0","tags":null,"title":"0169：多数元素（★）","uri":"/leetcode/0169/"},{"categories":null,"content":"分析 ","date":"2015-06-18","objectID":"/leetcode/0169/:2:0","tags":null,"title":"0169：多数元素（★）","uri":"/leetcode/0169/"},{"categories":null,"content":"#1 时间复杂度 O(N) 很简单，直接计数即可。 def majorityElement(self, nums: List[int]) -\u003e int: ct = Counter(nums) return max(ct, key=ct.get) ","date":"2015-06-18","objectID":"/leetcode/0169/:2:1","tags":null,"title":"0169：多数元素（★）","uri":"/leetcode/0169/"},{"categories":null,"content":"#2 要求空间复杂度 O(1)，有个经典的摩尔投票法 ： 在 nums 中任意消除两个不同的数直到剩下的数都相同 假如 nums 中存在多数元素，那么该元素必然会留下来 因此返回最终留下来的数即可 ","date":"2015-06-18","objectID":"/leetcode/0169/:2:2","tags":null,"title":"0169：多数元素（★）","uri":"/leetcode/0169/"},{"categories":null,"content":"解答 def majorityElement(self, nums: List[int]) -\u003e int: cand, cnt = None, 0 for num in nums: cand = cand if cnt else num cnt += 1 if num == cand else -1 return cand 56 ms ","date":"2015-06-18","objectID":"/leetcode/0169/:3:0","tags":null,"title":"0169：多数元素（★）","uri":"/leetcode/0169/"},{"categories":null,"content":"题目 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。 例如： A -\u003e 1\rB -\u003e 2\rC -\u003e 3\r...\rZ -\u003e 26\rAA -\u003e 27\rAB -\u003e 28 ...\r示例 1： 输入：columnNumber = 1\r输出：\"A\"\r示例 2： 输入：columnNumber = 28\r输出：\"AB\"\r示例 3： 输入：columnNumber = 701\r输出：\"ZY\"\r示例 4： 输入：columnNumber = 2147483647\r输出：\"FXSHRXW\"\r提示： 1 \u003c= columnNumber \u003c= 2^31 - 1 ","date":"2015-06-17","objectID":"/leetcode/0168/:1:0","tags":null,"title":"0168：Excel表列名称（★）","uri":"/leetcode/0168/"},{"categories":null,"content":"分析 类似 26 进制，只不过每一位的范围是 [1, 26] 而不是 [0, 25]，注意每次除 26 之前先减一。 ","date":"2015-06-17","objectID":"/leetcode/0168/:2:0","tags":null,"title":"0168：Excel表列名称（★）","uri":"/leetcode/0168/"},{"categories":null,"content":"解答 def convertToTitle(self, columnNumber: int) -\u003e str: res, n = '', columnNumber while n: n, r = divmod(n-1, 26) res = chr(ord('A')+r) + res return res 28 ms ","date":"2015-06-17","objectID":"/leetcode/0168/:3:0","tags":null,"title":"0168：Excel表列名称（★）","uri":"/leetcode/0168/"},{"categories":null,"content":"题目 给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ， 请你从数组中找出满足相加之和等于目标数 target 的两个数。 如果设这两个数分别是 numbers[index1] 和 numbers[index2] ， 则 1 \u003c= index1 \u003c index2 \u003c= numbers.length 。 以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。 你所设计的解决方案必须只使用常量级的额外空间。 示例 1： 输","date":"2015-06-16","objectID":"/leetcode/0167/:1:0","tags":null,"title":"0167：两数之和 II - 输入有序数组（★）","uri":"/leetcode/0167/"},{"categories":null,"content":"分析 类似 0001，可以用哈希表。 数组有序，也可以用双指针来解决： 初始指针 i、j 分别指向 numbers 的首尾。 如果 numbers[i]+numbers[j]\u003ctarget，则 numbers[i] 与任意 [i+1,j-1] 内的数相加更小， 故可以不再考虑 numbers[i]，缩小查找范围为 [i+1,j]。 同理，如果 numbers[i]+numbers[j]\u003etarget，可以缩小查找范围为 [i, j-1]。 循环操作直到找到结果即可 ","date":"2015-06-16","objectID":"/leetcode/0167/:2:0","tags":null,"title":"0167：两数之和 II - 输入有序数组（★）","uri":"/leetcode/0167/"},{"categories":null,"content":"解答 def twoSum(self, numbers: List[int], target: int) -\u003e List[int]: i, j = 0, len(numbers) - 1 while numbers[i] + numbers[j] != target: if numbers[i] + numbers[j] \u003c target: i += 1 else: j -= 1 return [i+1, j+1] 40 ms ","date":"2015-06-16","objectID":"/leetcode/0167/:3:0","tags":null,"title":"0167：两数之和 II - 输入有序数组（★）","uri":"/leetcode/0167/"},{"categories":null,"content":"题目 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。 如果小数部分为循环小数，则将循环的部分括在括号内。 如果存在多个答案，只需返回 任意一个。 对于所有给定的输入，保证 答案字符串的长度小于 10^4。 示例 1： 输入：numerator = 1, denominator = 2\r输出：\"0.5\"\r示例 2： 输入：numerator = 2, denominator = 1\r输出：\"2\"\r示例 3： 输入：numerator = 4, denominator = 333\r输出：\"0.(012)\"\r提示： -2^31 \u003c= ","date":"2015-06-15","objectID":"/leetcode/0166/:1:0","tags":null,"title":"0166：分数到小数（★★）","uri":"/leetcode/0166/"},{"categories":null,"content":"分析 模拟除法，用哈希表检测循环即可。注意边界条件较多： 转为两个非负数相除，并判断是否加上负号 若能整除，直接返回商，没有小数点 若不能整除，加上小数点，每轮相除，添加商 若除得尽，直接返回 若除不尽，用哈希表找到循环起点，添加括号即可 ","date":"2015-06-15","objectID":"/leetcode/0166/:2:0","tags":null,"title":"0166：分数到小数（★★）","uri":"/leetcode/0166/"},{"categories":null,"content":"解答 def fractionToDecimal(self, numerator: int, denominator: int) -\u003e str: res = '' if numerator*denominator \u003e= 0 else '-' m, n = abs(numerator), abs(denominator) q, r = divmod(m, n) res += str(q) if r == 0: return res res += '.' d = {} while True: d[r] = len(res) q, r = divmod(r*10, n) res += str(q) ","date":"2015-06-15","objectID":"/leetcode/0166/:3:0","tags":null,"title":"0166：分数到小数（★★）","uri":"/leetcode/0166/"},{"categories":null,"content":"题目 给你两个版本号 version1 和 version2 ，请你比较它们。 版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。 每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ， 下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。 也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。 例如，","date":"2015-06-14","objectID":"/leetcode/0165/:1:0","tags":null,"title":"0165：比较版本号（★）","uri":"/leetcode/0165/"},{"categories":null,"content":"分析 把版本号按 ‘.’ 分割为数组，依次比较即可。 ","date":"2015-06-14","objectID":"/leetcode/0165/:2:0","tags":null,"title":"0165：比较版本号（★）","uri":"/leetcode/0165/"},{"categories":null,"content":"解答 def compareVersion(self, version1: str, version2: str) -\u003e int: A, B = version1.split('.'), version2.split('.') for a, b in zip_longest(A, B, fillvalue=0): a, b = int(a), int(b) if a != b: return 1 if a \u003e b else -1 return 0 32 ms ","date":"2015-06-14","objectID":"/leetcode/0165/:3:0","tags":null,"title":"0165：比较版本号（★）","uri":"/leetcode/0165/"},{"categories":null,"content":"题目 给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。 如果数组元素个数小于 2，则返回 0 。 您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。 示例 1: 输入: nums = [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 输入: nums = [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 提示: 1 \u003c= nums.length \u003c= 10^5 0 \u003c= nums[i] \u003c= 10^9 ","date":"2015-06-13","objectID":"/leetcode/0164/:1:0","tags":null,"title":"0164：最大间距（★★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"分析 ","date":"2015-06-13","objectID":"/leetcode/0164/:2:0","tags":null,"title":"0164：最大间距（★★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"#1 最简单的是排序后遍历间距即可。 def maximumGap(self, nums: List[int]) -\u003e int: return max([b-a for a,b in pairwise(sorted(nums))], default=0) 180 ms ","date":"2015-06-13","objectID":"/leetcode/0164/:2:1","tags":null,"title":"0164：最大间距（★★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"#2 要求线性时间排序，数据范围又较大，考虑用桶排序。 根据抽屉原理，最大间距必定 \u003e= (max(nums)-min(nums)) // (N-1) 取该下界作为桶长 size，桶内元素的间距小于最大间距，无需再比较 比较相邻桶的间距即可，而最多 N 个桶，故满足 O(N) 时间 特别注意 size 不能取 0 ","date":"2015-06-13","objectID":"/leetcode/0164/:2:2","tags":null,"title":"0164：最大间距（★★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"解答 def maximumGap(self, nums: List[int]) -\u003e int: n, Min, Max = len(nums), min(nums), max(nums) if n \u003c 2: return 0 B, size = defaultdict(list), max(1, (Max-Min)//(n-1)) for x in nums: B[x//size].append(x) res, pre = 0, float('inf') for key in range(Min//size, Max//size+1): if key in B: res = max(res,","date":"2015-06-13","objectID":"/leetcode/0164/:3:0","tags":null,"title":"0164：最大间距（★★★）","uri":"/leetcode/0164/"},{"categories":null,"content":"题目 峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值， 在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞ 。 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。 示例 1： 输入：nums = [1,2,3,1]\r输出：2\r解释：3 是峰值元素，你的函数应该返回其索引 2。\r示例 2： 输入：nums = [1,2,1,3,5,6,4]\r输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2；\r或者返回索引 5， 其峰值元素为 6。\r提示：","date":"2015-06-11","objectID":"/leetcode/0162/:1:0","tags":null,"title":"0162：寻找峰值（★★）","uri":"/leetcode/0162/"},{"categories":null,"content":"分析 显然最大值即是一个峰值。但要求时间复杂度 O(log N)，考虑二分查找。 nums[mid] \u003e max(nums[mid-1], nums[mid+1])，mid 即为所求 nums[mid] \u003c nums[mid+1]，[mid+1, n-1] 范围内必然有一个峰值 nums[mid] \u003c nums[mid-1]，[0, mid-1] 范围内必然有一个峰值 ","date":"2015-06-11","objectID":"/leetcode/0162/:2:0","tags":null,"title":"0162：寻找峰值（★★）","uri":"/leetcode/0162/"},{"categories":null,"content":"解答 def findPeakElement(self, nums: List[int]) -\u003e int: n = len(nums) i, j = 0, n - 1 while i \u003c= j: mid = i + (j - i) // 2 if (mid == 0 or nums[mid] \u003e nums[mid-1]) and (mid == n-1 or nums[mid] \u003e nums[mid+1]): return mid if nums[mid] \u003c nums[mid+1]: i = mid + 1 else: j = mid - 1 32 ms ","date":"2015-06-11","objectID":"/leetcode/0162/:3:0","tags":null,"title":"0162：寻找峰值（★★）","uri":"/leetcode/0162/"},{"categories":null,"content":"题目 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。 如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1： 输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\r输出： Reference of the node with value = 8\r输入解释： 相交节点的值为 8 （注意，如果两个链表相交","date":"2015-06-09","objectID":"/leetcode/0160/:1:0","tags":null,"title":"0160：相交链表（★★）","uri":"/leetcode/0160/"},{"categories":null,"content":"分析 ","date":"2015-06-09","objectID":"/leetcode/0160/:2:0","tags":null,"title":"0160：相交链表（★★）","uri":"/leetcode/0160/"},{"categories":null,"content":"#1 最直接的是哈希。 def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u003e ListNode: p, q, vis = headA, headB, set() while p: vis.add(p) p = p.next while q: if q in vis: return q q = q.next return None 140 ms ","date":"2015-06-09","objectID":"/leetcode/0160/:2:1","tags":null,"title":"0160：相交链表（★★）","uri":"/leetcode/0160/"},{"categories":null,"content":"#2 要求 O(1) 空间，有个巧妙的方法。 初始指针 p、q 分别指向 A、B 链表开头 每轮同时移动一步 p、q p 到达 A 末尾时重定向到 B 开头，q 到达 B 末尾时重定向到 A 开头。 经过 (A长度+B长度-相交部分长度) 轮后 p、q 相遇在相交节点（或者是空节点） ","date":"2015-06-09","objectID":"/leetcode/0160/:2:2","tags":null,"title":"0160：相交链表（★★）","uri":"/leetcode/0160/"},{"categories":null,"content":"解答 def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u003e ListNode: p, q = headA, headB while p != q: p = p.next if p else headB q = q.next if q else headA return p 164 ms ","date":"2015-06-09","objectID":"/leetcode/0160/:3:0","tags":null,"title":"0160：相交链表（★★）","uri":"/leetcode/0160/"},{"categories":null,"content":"题目 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 示例 1: 输入：\r[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\r[[],[-2],[0],[-3],[],[],[],[]]\r输出：\r[null,null","date":"2015-06-04","objectID":"/leetcode/0155/:1:0","tags":null,"title":"0155：最小栈（★）","uri":"/leetcode/0155/"},{"categories":null,"content":"分析 每次入栈的同时保存当前最小值即可。 ","date":"2015-06-04","objectID":"/leetcode/0155/:2:0","tags":null,"title":"0155：最小栈（★）","uri":"/leetcode/0155/"},{"categories":null,"content":"解答 class MinStack: def __init__(self): self.stack = [] def push(self, val: int) -\u003e None: Min = min(self.stack[-1][1], val) if self.stack else val self.stack.append((val, Min)) def pop(self) -\u003e None: self.stack.pop() def top(self) -\u003e int: return self.stack[-1][0] def getMin(self) -\u003e int: return self.","date":"2015-06-04","objectID":"/leetcode/0155/:3:0","tags":null,"title":"0155：最小栈（★）","uri":"/leetcode/0155/"},{"categories":null,"content":"题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。 例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。 请你找出并返回数","date":"2015-06-03","objectID":"/leetcode/0154/:1:0","tags":null,"title":"0154：寻找旋转排序数组中的最小值 II（★★）","uri":"/leetcode/0154/"},{"categories":null,"content":"分析 直接调用 0153 的方法会出错， 因为有重复元素，可能 nums[0] 等于 nums[-1]，不满足二分条件。 那么不断弹出末尾元素使得 nums[0] \u003e nums[-1] 即可转换为 0153 。 注意 nums 全都相等的特殊情况。 ","date":"2015-06-03","objectID":"/leetcode/0154/:2:0","tags":null,"title":"0154：寻找旋转排序数组中的最小值 II（★★）","uri":"/leetcode/0154/"},{"categories":null,"content":"解答 def findMin(self, nums: List[int]) -\u003e int: while len(nums) \u003e 1 and nums[-1] == nums[0]: nums.pop() self.__class__.__getitem__ = lambda self, i: nums[i]\u003c=nums[-1] return nums[bisect_left(self, True, 0, len(nums)-1)] 36 ms ","date":"2015-06-03","objectID":"/leetcode/0154/:3:0","tags":null,"title":"0154：寻找旋转排序数组中的最小值 II（★★）","uri":"/leetcode/0154/"},{"categories":null,"content":"题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。 例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。 请你找出并返回数组中","date":"2015-06-02","objectID":"/leetcode/0153/:1:0","tags":null,"title":"0153：寻找旋转排序数组中的最小值（★★）","uri":"/leetcode/0153/"},{"categories":null,"content":"分析 以最小值位置 i 为界，nums[:i] 都大于 nums[-1]，nums[i:] 都小于等于 nums[-1]。 因此二分查找第一个小于等于 nums[-1] 的数即可。 ","date":"2015-06-02","objectID":"/leetcode/0153/:2:0","tags":null,"title":"0153：寻找旋转排序数组中的最小值（★★）","uri":"/leetcode/0153/"},{"categories":null,"content":"解答 def findMin(self, nums: List[int]) -\u003e int: self.__class__.__getitem__ = lambda self, i: nums[i]\u003c=nums[-1] return nums[bisect_left(self, True, 0, len(nums)-1)] 24 ms ","date":"2015-06-02","objectID":"/leetcode/0153/:3:0","tags":null,"title":"0153：寻找旋转排序数组中的最小值（★★）","uri":"/leetcode/0153/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字）， 并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 子数组 是数组的连续子序列。 示例 1: 输入: nums = [2,3,-2,4]\r输出: 6\r解释: 子数组 [2,3] 有最大乘积 6。\r示例 2: 输入: nums = [-2,0,-1]\r输出: 0\r解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\r提示: 1 \u003c= nums.length \u003c= 2 * 10^4 -10 \u003c= nums[i] \u003c= 10 nums 的任何前缀或后缀的乘积都 保证 ","date":"2015-06-01","objectID":"/leetcode/0152/:1:0","tags":null,"title":"0152：乘积最大子数组（★）","uri":"/leetcode/0152/"},{"categories":null,"content":"分析 0053 进阶版，加法变成了乘法。 注意乘法的最值和正负有关。因此令 dp[j][0]、dp[j][1] 分别代表以位置 j 结尾的最小/大乘积，即可递推。 还可以优化为两个参数。 ","date":"2015-06-01","objectID":"/leetcode/0152/:2:0","tags":null,"title":"0152：乘积最大子数组（★）","uri":"/leetcode/0152/"},{"categories":null,"content":"解答 def maxProduct(self, nums: List[int]) -\u003e int: res, Min, Max = float('-inf'), 1, 1 for num in nums: Min, _, Max = sorted([num*Max, num*Min, num]) res = max(res, Max) return res 44 ms ","date":"2015-06-01","objectID":"/leetcode/0152/:3:0","tags":null,"title":"0152：乘积最大子数组（★）","uri":"/leetcode/0152/"},{"categories":null,"content":"题目 给你一个字符串 s ，颠倒字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。 返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 示例 1： 输入：s = \"the sky is blue\"\r输出：\"blue is sky the\"\r示例 2： 输入：s = \" hello world \"\r输出：\"world hello\"\r解释：颠倒后的字符串中不能存在前导空格和尾随空格","date":"2015-05-31","objectID":"/leetcode/0151/:1:0","tags":null,"title":"0151：翻转字符串里的单词","uri":"/leetcode/0151/"},{"categories":null,"content":"分析 按空格分割得到单词列表，将列表反转后再用空格拼接起来即可。 ","date":"2015-05-31","objectID":"/leetcode/0151/:2:0","tags":null,"title":"0151：翻转字符串里的单词","uri":"/leetcode/0151/"},{"categories":null,"content":"解答 def reverseWords(self, s: str) -\u003e str: return ' '.join(s.split()[::-1]) 24 ms ","date":"2015-05-31","objectID":"/leetcode/0151/:3:0","tags":null,"title":"0151：翻转字符串里的单词","uri":"/leetcode/0151/"},{"categories":null,"content":"题目 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 注意 两个整数之间的除法只保留整数部分。 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\r输出：9\r解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\r示例 2： 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\r输出：6\r解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)","date":"2015-05-30","objectID":"/leetcode/0150/:1:0","tags":null,"title":"0150：逆波兰表达式求值（★）","uri":"/leetcode/0150/"},{"categories":null,"content":"分析 栈的典型应用，每次遇到运算符出栈两个数字进行计算，将结果入栈即可。 注意 python 中 // 是向下取整，不满足要求，应该用 int(x/y) 。 ","date":"2015-05-30","objectID":"/leetcode/0150/:2:0","tags":null,"title":"0150：逆波兰表达式求值（★）","uri":"/leetcode/0150/"},{"categories":null,"content":"解答 def evalRPN(self, tokens: List[str]) -\u003e int: func = {'+': int.__add__, '-': int.__sub__, '*': int.__mul__, '/': lambda x,y: int(x/y)} stack = [] for token in tokens: if token in func: y, x = stack.pop(), stack.pop() stack.append(func[token](x, y)) else: stack.append(int(token)) return stack[0] 40","date":"2015-05-30","objectID":"/leetcode/0150/:3:0","tags":null,"title":"0150：逆波兰表达式求值（★）","uri":"/leetcode/0150/"},{"categories":null,"content":"题目 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。 求最多有多少个点在同一条直线上。 示例 1： 输入：points = [[1,1],[2,2],[3,3]]\r输出：3\r示例 2： 输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\r输出：4\r提示： 1 \u003c= points.length \u003c= 300 points[i].length == 2 -10^4 \u003c= xi, yi \u003c= 10^4 points 中的所有点 互不相同 ","date":"2015-05-29","objectID":"/leetcode/0149/:1:0","tags":null,"title":"0149：直线上最多的点数（★★）","uri":"/leetcode/0149/"},{"categories":null,"content":"分析 本题可能有重复点，因此不能按直线遍历，考虑按点来遍历： 对于点 i，首先统计重复个数 same 然后将其它点可以按斜率分组 最大的组大小加上 same 即可 考虑到精度问题，可以用最简分数来表示斜率，注意下不存在斜率的特殊情况即可。 ","date":"2015-05-29","objectID":"/leetcode/0149/:2:0","tags":null,"title":"0149：直线上最多的点数（★★）","uri":"/leetcode/0149/"},{"categories":null,"content":"解答 def maxPoints(self, points: List[List[int]]) -\u003e int: from fractions import Fraction res = 0 for p in points: d, same = defaultdict(int), 0 for q in points: if p==q: same += 1 else: key = str(Fraction(q[1]-p[1], q[0]-p[0])) if q[0]!=p[0] else '1/0' d[key] += 1 res = max(res, same+max(d.values(), d","date":"2015-05-29","objectID":"/leetcode/0149/:3:0","tags":null,"title":"0149：直线上最多的点数（★★）","uri":"/leetcode/0149/"},{"categories":null,"content":"题目 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 示例 1： 输入：head = [4,2,1,3]\r输出：[1,2,3,4]\r示例 2： 输入：head = [-1,5,3,4,0]\r输出：[-1,0,3,4,5]\r示例 3： 输入：head = []\r输出：[]\r提示： 链表中节点的数目在范围 [0, 5 * 10^4] 内 -10^5 \u003c= Node.val \u003c= 10^5 进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ ","date":"2015-05-28","objectID":"/leetcode/0148/:1:0","tags":null,"title":"0148：排序链表（★★）","uri":"/leetcode/0148/"},{"categories":null,"content":"分析 要求 O(n log n) 时间复杂度和常数级空间复杂度，马上想到快排和归并排序。 这里使用归并排序，用快慢指针找到中点，归并部分即问题 0021 。 ","date":"2015-05-28","objectID":"/leetcode/0148/:2:0","tags":null,"title":"0148：排序链表（★★）","uri":"/leetcode/0148/"},{"categories":null,"content":"解答 def sortList(self, head: ListNode) -\u003e ListNode: def merge(l1, l2): dummy = l3 = ListNode() while l1 and l2: if l1.val \u003c= l2.val: l3.next = l1 l1 = l1.next else: l3.next = l2 l2 = l2.next l3 = l3.next l3.next = l1 if l1 else l2 return dummy.next if not head or not head.next: return head slow = fas","date":"2015-05-28","objectID":"/leetcode/0148/:3:0","tags":null,"title":"0148：排序链表（★★）","uri":"/leetcode/0148/"},{"categories":null,"content":"题目 给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。 插入排序 算法的步骤: 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。 每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。 对链表进行插入排序。 示例 1： 输入: head = [4,2,1,3]\r输出: [1,2,3,4]\r示例","date":"2015-05-27","objectID":"/leetcode/0147/:1:0","tags":null,"title":"0147：对链表进行插入排序（★★）","uri":"/leetcode/0147/"},{"categories":null,"content":"分析 维护两个指针 tail，cur 分别指向 已排序的结尾节点 和 当前要排序的节点。 若 cur.val \u003e= tail.val，就无需插入了，否则要在前面找插入位置 p，改变几个节点的指向。 ","date":"2015-05-27","objectID":"/leetcode/0147/:2:0","tags":null,"title":"0147：对链表进行插入排序（★★）","uri":"/leetcode/0147/"},{"categories":null,"content":"解答 def insertionSortList(self, head: ListNode) -\u003e ListNode: dummy = ListNode(float('-inf'), next=head) tail, cur = dummy, head while cur: if tail.val \u003c= cur.val: tail = tail.next else: p = dummy while p.next.val \u003c= cur.val: p = p.next tail.next = cur.next cur.next = p.next p.next = cur cur = tail.ne","date":"2015-05-27","objectID":"/leetcode/0147/:3:0","tags":null,"title":"0147：对链表进行插入排序（★★）","uri":"/leetcode/0147/"},{"categories":null,"content":"题目 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ； 如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ， 则应该 逐出 最久未使用的关键字。 函数 get","date":"2015-05-26","objectID":"/leetcode/0146/:1:0","tags":null,"title":"0146：LRU 缓存机制（★★）","uri":"/leetcode/0146/"},{"categories":null,"content":"分析 ","date":"2015-05-26","objectID":"/leetcode/0146/:2:0","tags":null,"title":"0146：LRU 缓存机制（★★）","uri":"/leetcode/0146/"},{"categories":null,"content":"#1 先考虑最简单的方法，用数组维护关键字的顺序: get 和 put 时将对应关键字移到最后面 容量达到上限时，弹出数组首个元素即可 class LRUCache: def __init__(self, capacity: int): self.A = [] self.d = {} self.capacity = capacity def get(self, key: int) -\u003e int: if key not in self.d: return -1 self.A.remove(key) self.A.append(key) return self.d[key] def put(sel","date":"2015-05-26","objectID":"/leetcode/0146/:2:1","tags":null,"title":"0146：LRU 缓存机制（★★）","uri":"/leetcode/0146/"},{"categories":null,"content":"#2 要求 O(1) 时间完成 put() 和 get()，也就是 O(1) 时间内删除元素，在头部或尾部添加元素。 可以用双向链表+哈希表来实现。不过 python 有个更方便的 OrderedDict。 ","date":"2015-05-26","objectID":"/leetcode/0146/:2:2","tags":null,"title":"0146：LRU 缓存机制（★★）","uri":"/leetcode/0146/"},{"categories":null,"content":"解答 class LRUCache: def __init__(self, capacity: int): self.d = OrderedDict() self.capacity = capacity def get(self, key: int) -\u003e int: if key not in self.d: return -1 self.d.move_to_end(key) return self.d[key] def put(self, key: int, value: int) -\u003e None: if key in self.d: self.d.move_to_end(key) elif","date":"2015-05-26","objectID":"/leetcode/0146/:3:0","tags":null,"title":"0146：LRU 缓存机制（★★）","uri":"/leetcode/0146/"},{"categories":null,"content":"题目 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 示例 1： 输入：root = [1,null,2,3]\r输出：[3,2,1]\r示例 2： 输入：root = []\r输出：[]\r示例 3： 输入：root = [1]\r输出：[1]\r提示： 树中节点的数目在范围 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-05-25","objectID":"/leetcode/0145/:1:0","tags":null,"title":"0145：二叉树的后序遍历（★）","uri":"/leetcode/0145/"},{"categories":null,"content":"分析 ","date":"2015-05-25","objectID":"/leetcode/0145/:2:0","tags":null,"title":"0145：二叉树的后序遍历（★）","uri":"/leetcode/0145/"},{"categories":null,"content":"#1 先写出递归算法，显然，将左子树的后序遍历、右子树的后序遍历、根节点拼接起来即可。 def postorderTraversal(self, root: TreeNode) -\u003e List[int]: return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] 36 ms ","date":"2015-05-25","objectID":"/leetcode/0145/:2:1","tags":null,"title":"0145：二叉树的后序遍历（★）","uri":"/leetcode/0145/"},{"categories":null,"content":"#2 迭代算法类似 0094，入栈顺序换成 [节点值、右子树、左子树] 即可。 ","date":"2015-05-25","objectID":"/leetcode/0145/:2:2","tags":null,"title":"0145：二叉树的后序遍历（★）","uri":"/leetcode/0145/"},{"categories":null,"content":"解答 def postorderTraversal(self, root: TreeNode) -\u003e List[int]: res, stack = [], [root] while stack: node = stack.pop() if isinstance(node, int): res.append(node) elif node: stack.extend([node.val, node.right, node.left]) return res 40 ms ","date":"2015-05-25","objectID":"/leetcode/0145/:3:0","tags":null,"title":"0145：二叉树的后序遍历（★）","uri":"/leetcode/0145/"},{"categories":null,"content":"题目 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例 1： 输入：root = [1,null,2,3]\r输出：[1,2,3]\r示例 2： 输入：root = []\r输出：[]\r示例 3： 输入：root = [1]\r输出：[1]\r示例 4： 输入：root = [1,2]\r输出：[1,2]\r示例 5： 输入：root = [1,null,2]\r输出：[1,2]\r提示： 树中节点数目在范围 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-05-24","objectID":"/leetcode/0144/:1:0","tags":null,"title":"0144：二叉树的前序遍历（★）","uri":"/leetcode/0144/"},{"categories":null,"content":"分析 ","date":"2015-05-24","objectID":"/leetcode/0144/:2:0","tags":null,"title":"0144：二叉树的前序遍历（★）","uri":"/leetcode/0144/"},{"categories":null,"content":"#1 先写出递归算法，显然，将根节点、左子树的前序遍历、右子树的前序遍历拼接起来即可。 def preorderTraversal(self, root: TreeNode) -\u003e List[int]: return [root.val]+self.preorderTraversal(root.left)+self.preorderTraversal(root.right) if root else [] 40 ms ","date":"2015-05-24","objectID":"/leetcode/0144/:2:1","tags":null,"title":"0144：二叉树的前序遍历（★）","uri":"/leetcode/0144/"},{"categories":null,"content":"#2 迭代算法类似 0094，入栈顺序换成 [右子树、左子树] ，节点值不需入栈直接输出即可。 ","date":"2015-05-24","objectID":"/leetcode/0144/:2:2","tags":null,"title":"0144：二叉树的前序遍历（★）","uri":"/leetcode/0144/"},{"categories":null,"content":"解答 def preorderTraversal(self, root: TreeNode) -\u003e List[int]: res, stack = [], [root] while stack: node = stack.pop() if node: res.append(node.val) stack.extend([node.right, node.left]) return res 32 ms ","date":"2015-05-24","objectID":"/leetcode/0144/:3:0","tags":null,"title":"0144：二叉树的前序遍历（★）","uri":"/leetcode/0144/"},{"categories":null,"content":"题目 给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln - 1 → Ln\r请将其重新排列后变为： L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\r不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1： 输入：head = [1,2,3,4]\r输出：[1,4,2,3]\r示例 2： 输入：head = [1,2,3,4,5]\r输出：[1,5,2,4,3]\r提示： 链表的长度范围为 [1, 5 * 10^4] 1 \u003c= node.val \u003c= 1000 ","date":"2015-05-23","objectID":"/leetcode/0143/:1:0","tags":null,"title":"0143：重排链表（★★）","uri":"/leetcode/0143/"},{"categories":null,"content":"分析 先用快慢节点找到中点位置，截断为两部分，将后半部分链表反转后依次插入前半部分中即可。 反转链表即是问题 0206 。 ","date":"2015-05-23","objectID":"/leetcode/0143/:2:0","tags":null,"title":"0143：重排链表（★★）","uri":"/leetcode/0143/"},{"categories":null,"content":"解答 def reorderList(self, head: ListNode) -\u003e None: def reverse(head): tail = head while tail and tail.next: tmp = tail.next tail.next = tmp.next tmp.next = head head = tmp return head slow = fast = ListNode(next=head) while fast and fast.next: slow, fast = slow.next, fast.next.next q = slow.next slow","date":"2015-05-23","objectID":"/leetcode/0143/:3:0","tags":null,"title":"0143：重排链表（★★）","uri":"/leetcode/0143/"},{"categories":null,"content":"题目 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置 （索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递， 仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1\r输出：返回索引为 1 的链表节点\r解释：链表中有一个环，其尾部连接到第二个节点。\r示例 2： 输入：","date":"2015-05-22","objectID":"/leetcode/0142/:1:0","tags":null,"title":"0142：环形链表 II（★★★）","uri":"/leetcode/0142/"},{"categories":null,"content":"分析 0141 升级版，依然可以用快慢指针解决： 假如环的周长为 L，入环位置为 x 当慢节点达到 x 时，快节点走了 2*x 步，也就是说在环上走了 x 步 此时快节点距离慢节点 L-x%L，再经过 L-x%L 轮相遇 相遇时慢节点在环上走了 L-x%L 步 若慢节点再在换上走 x 步，即到达位置 x 于是有个巧妙的想法，令另一个慢节点从起点开始同步走，两个慢节点相遇位置即为位置 x ","date":"2015-05-22","objectID":"/leetcode/0142/:2:0","tags":null,"title":"0142：环形链表 II（★★★）","uri":"/leetcode/0142/"},{"categories":null,"content":"解答 def detectCycle(self, head: ListNode) -\u003e ListNode: slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next if slow == fast: slow2 = head while slow != slow2: slow, slow2 = slow.next, slow2.next return slow return None 44 ms ","date":"2015-05-22","objectID":"/leetcode/0142/:3:0","tags":null,"title":"0142：环形链表 II（★★★）","uri":"/leetcode/0142/"},{"categories":null,"content":"题目 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 示例 1： 输入：head = [3,2,0,-4], pos = 1\r输出：true\r解释：链表中有一个环，其尾部连接到第二个节点。\r示例 2： 输入：head = [1,2], pos = 0\r","date":"2015-05-21","objectID":"/leetcode/0141/:1:0","tags":null,"title":"0141：环形链表（★★）","uri":"/leetcode/0141/"},{"categories":null,"content":"分析 ","date":"2015-05-21","objectID":"/leetcode/0141/:2:0","tags":null,"title":"0141：环形链表（★★）","uri":"/leetcode/0141/"},{"categories":null,"content":"#1 最简单的就是哈希。 def hasCycle(self, head: ListNode) -\u003e bool: vis = set() while head: if head in vis: return True vis.add(head) head = head.next return False 48 ms ","date":"2015-05-21","objectID":"/leetcode/0141/:2:1","tags":null,"title":"0141：环形链表（★★）","uri":"/leetcode/0141/"},{"categories":null,"content":"#2 要求 O(1) 空间，本题有个经典的快慢指针解法： 初始快慢指针都指向表头 每轮快指针移动两步，慢指针移动一步 若链表无环，快指针先到达末尾，无法再移动 若链表有环，快慢指针将会在环中某节点相遇 ","date":"2015-05-21","objectID":"/leetcode/0141/:2:2","tags":null,"title":"0141：环形链表（★★）","uri":"/leetcode/0141/"},{"categories":null,"content":"解答 def hasCycle(self, head: ListNode) -\u003e bool: slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False 64 ms ","date":"2015-05-21","objectID":"/leetcode/0141/:3:0","tags":null,"title":"0141：环形链表（★★）","uri":"/leetcode/0141/"},{"categories":null,"content":"题目 给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子， 使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。 注意：词典中的同一个单词可能在分段中被重复使用多次。 示例 1： 输入:s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\r输出:[\"cats and dog\",\"cat sand dog\"]\r示例 2： 输入:s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",","date":"2015-05-20","objectID":"/leetcode/0140/:1:0","tags":null,"title":"0140：单词拆分 II（★★）","uri":"/leetcode/0140/"},{"categories":null,"content":"分析 0139 升级版，改下递归的返回值即可。 ","date":"2015-05-20","objectID":"/leetcode/0140/:2:0","tags":null,"title":"0140：单词拆分 II（★★）","uri":"/leetcode/0140/"},{"categories":null,"content":"解答 def wordBreak(self, s: str, wordDict: List[str]) -\u003e List[str]: @lru_cache(None) def dfs(s): if not s: return [[]] res = [] for i in range(len(s)): if s[:i+1] in W: res.extend([s[:i+1]]+sub for sub in dfs(s[i+1:])) return res W = set(wordDict) return [' '.join(sub) for sub in dfs(s)] 32 ms ","date":"2015-05-20","objectID":"/leetcode/0140/:3:0","tags":null,"title":"0140：单词拆分 II（★★）","uri":"/leetcode/0140/"},{"categories":null,"content":"题目 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。 请你判断是否可以利用字典中出现的单词拼接出 s 。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例 1： 输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\r输出: true\r解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\r示例 2： 输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\r输出: true\r解释: 返回 true 因为 \"app","date":"2015-05-19","objectID":"/leetcode/0139/:1:0","tags":null,"title":"0139：单词拆分（★）","uri":"/leetcode/0139/"},{"categories":null,"content":"分析 典型的单串 dp，按第一个单词长度即可递归。 ","date":"2015-05-19","objectID":"/leetcode/0139/:2:0","tags":null,"title":"0139：单词拆分（★）","uri":"/leetcode/0139/"},{"categories":null,"content":"解答 def wordBreak(self, s: str, wordDict: List[str]) -\u003e bool: @lru_cache(None) def dfs(s): return not s or any(s[:i+1] in W and dfs(s[i+1:]) for i in range(len(s))) W = set(wordDict) return dfs(s) 48 ms ","date":"2015-05-19","objectID":"/leetcode/0139/:3:0","tags":null,"title":"0139：单词拆分（★）","uri":"/leetcode/0139/"},{"categories":null,"content":"题目 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ， 该指针可以指向链表中的任何节点或空节点。 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成， 其中每个新节点的值都设为其对应的原节点的值。 新节点的 next 指针和 random 指针也都应指向复制链表中的新节点， 并使原链表和复制链表中的这些指针能够表示相同的链表状态。 复制链表中的指针都不应指向原链表中的节点 。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –\u003e Y 。那么在复制链表中对应的两个节点 x 和 y ， 同样有 x.random –\u003e y 。 返回","date":"2015-05-18","objectID":"/leetcode/0138/:1:0","tags":null,"title":"0138：复制带随机指针的链表（★★★）","uri":"/leetcode/0138/"},{"categories":null,"content":"分析 ","date":"2015-05-18","objectID":"/leetcode/0138/:2:0","tags":null,"title":"0138：复制带随机指针的链表（★★★）","uri":"/leetcode/0138/"},{"categories":null,"content":"#1 最直接的就是维护原节点和新节点的映射 d： 遍历节点 p，若 p 在 d 中就跳过 若 p 不在 d 中，只拷贝值得到节点 p’，保存映射 \u003cp,p’\u003e 到 d 中 p.next/random 遍历完后，将 p’ 的 next/random 指向 p.next/random 的拷贝节点即可 def copyRandomList(self, head: 'Optional[Node]') -\u003e 'Optional[Node]': d, p = {head: Node(head.val) if head else None}, head while p: d[p].next = d.setd","date":"2015-05-18","objectID":"/leetcode/0138/:2:1","tags":null,"title":"0138：复制带随机指针的链表（★★★）","uri":"/leetcode/0138/"},{"categories":null,"content":"#2 本题还有个非常巧妙的方法，不用额外空间。 先将新节点 new 依次插入到原节点 old 的后面 那么 old.random.next 就应该是 new.random 最后再按顺序拆分出新节点，即满足了 next 的正确指向 ","date":"2015-05-18","objectID":"/leetcode/0138/:2:2","tags":null,"title":"0138：复制带随机指针的链表（★★★）","uri":"/leetcode/0138/"},{"categories":null,"content":"解答 def copyRandomList(self, head: 'Node') -\u003e 'Node': p = head while p: p.next = Node(p.val, p.next) p = p.next.next p = head while p: p.next.random = p.random.next if p.random else None p = p.next.next p = head dummy = q = Node(0) while p: q.next = p.next p.next = p.next.next p = p.next q = q.next r","date":"2015-05-18","objectID":"/leetcode/0138/:3:0","tags":null,"title":"0138：复制带随机指针的链表（★★★）","uri":"/leetcode/0138/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。 请你找出并返回那个只出现了一次的元素。 示例 1： 输入：nums = [2,2,3,2]\r输出：3\r示例 2： 输入：nums = [0,1,0,1,0,1,99]\r输出：99\r提示： 1 \u003c= nums.length \u003c= 3 * 10^4 -2^31 \u003c= nums[i] \u003c= 2^31 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ ","date":"2015-05-17","objectID":"/leetcode/0137/:1:0","tags":null,"title":"0137：只出现一次的数字 II（★★★）","uri":"/leetcode/0137/"},{"categories":null,"content":"分析 ","date":"2015-05-17","objectID":"/leetcode/0137/:2:0","tags":null,"title":"0137：只出现一次的数字 II（★★★）","uri":"/leetcode/0137/"},{"categories":null,"content":"#1 最简单的依然是哈希表。 def singleNumber(self, nums: List[int]) -\u003e int: return [x for x,freq in Counter(nums).items() if freq==1].pop() 32 ms ","date":"2015-05-17","objectID":"/leetcode/0137/:2:1","tags":null,"title":"0137：只出现一次的数字 II（★★★）","uri":"/leetcode/0137/"},{"categories":null,"content":"#2 要不用额外空间实现，有个非常巧妙的位运算方法： https://leetcode-cn.com/problems/single-number-ii/solution/luo-ji-dian-lu-jiao-du-xiang-xi-fen-xi-gai-ti-si-l/。 ","date":"2015-05-17","objectID":"/leetcode/0137/:2:2","tags":null,"title":"0137：只出现一次的数字 II（★★★）","uri":"/leetcode/0137/"},{"categories":null,"content":"解答 def singleNumber(self, nums: List[int]) -\u003e int: X, Y = 0, 0 for Z in nums: Y = Y^Z \u0026 ~X X = X^Z \u0026 ~Y return Y 48 ms ","date":"2015-05-17","objectID":"/leetcode/0137/:3:0","tags":null,"title":"0137：只出现一次的数字 II（★★★）","uri":"/leetcode/0137/"},{"categories":null,"content":"题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。 找出那个只出现了一次的元素。 说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]\r输出: 1\r示例 2: 输入: [4,1,2,1,2]\r输出: 4\r","date":"2015-05-16","objectID":"/leetcode/0136/:1:0","tags":null,"title":"0136：只出现一次的数字（★）","uri":"/leetcode/0136/"},{"categories":null,"content":"分析 ","date":"2015-05-16","objectID":"/leetcode/0136/:2:0","tags":null,"title":"0136：只出现一次的数字（★）","uri":"/leetcode/0136/"},{"categories":null,"content":"#1 最简单的就是哈希表。 def singleNumber(self, nums: List[int]) -\u003e int: return [x for x,freq in Counter(nums).items() if freq==1].pop() 40 ms ","date":"2015-05-16","objectID":"/leetcode/0136/:2:1","tags":null,"title":"0136：只出现一次的数字（★）","uri":"/leetcode/0136/"},{"categories":null,"content":"#2 要求不用额外空间实现，有个非常巧妙的思路，利用了异或运算的特性。 满足交换律和结合律 x^x=0 x^0=x 可以推出：题目所给数组的所有元素的异或结果即为所求。 ","date":"2015-05-16","objectID":"/leetcode/0136/:2:2","tags":null,"title":"0136：只出现一次的数字（★）","uri":"/leetcode/0136/"},{"categories":null,"content":"解答 def singleNumber(self, nums: List[int]) -\u003e int: return reduce(xor, nums) 40 ms ","date":"2015-05-16","objectID":"/leetcode/0136/:3:0","tags":null,"title":"0136：只出现一次的数字（★）","uri":"/leetcode/0136/"},{"categories":null,"content":"题目 n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 示例 1： 输入：ratings = [1,0,2]\r输出：5\r解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。\r示例 2： 输入：ratings = [1,2,2]\r输出：4\r解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。\r第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。\r提示","date":"2015-05-15","objectID":"/leetcode/0135/:1:0","tags":null,"title":"0135：分发糖果（★★）","uri":"/leetcode/0135/"},{"categories":null,"content":"分析 考虑每个孩子最少多少颗： 对于孩子 i，假如左侧的严格递减序列长度为 left[i]，那么 i 至少 left[i] 颗 同理，假如右侧的严格递减序列长度为 right[i]，那么 i 至少 right[i] 颗 孩子 i 发 max(left[i],right[i]) 颗即可 left 和 right 数组可以一趟递推求出 ","date":"2015-05-15","objectID":"/leetcode/0135/:2:0","tags":null,"title":"0135：分发糖果（★★）","uri":"/leetcode/0135/"},{"categories":null,"content":"解答 def candy(self, ratings: List[int]) -\u003e int: n = len(ratings) left, right = [1] * n, [1] * n for i in range(1, n): left[i] = left[i-1] + 1 if ratings[i] \u003e ratings[i-1] else 1 for i in range(n-2, -1, -1): right[i] = right[i+1] + 1 if ratings[i] \u003e ratings[i+1] else 1 return sum(max(l, r) for l, r in","date":"2015-05-15","objectID":"/leetcode/0135/:3:0","tags":null,"title":"0135：分发糖果（★★）","uri":"/leetcode/0135/"},{"categories":null,"content":"题目 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。 你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号， 否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例 1: 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\r输出: 3\r解释:\r从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4","date":"2015-05-14","objectID":"/leetcode/0134/:1:0","tags":null,"title":"0134：加油站（★★）","uri":"/leetcode/0134/"},{"categories":null,"content":"分析 可以将 gas 和 cost 逐项相减得到数组 A，代表经过每段路的汽油变化。 问题等价于在 B=A+A 中找一个长度 len(A) 的子数组，其前缀和都非负。 具体实现时： 初始起点 i=0，从 i 开始遍历 j 遇到第一个 j 使得 sum(B[i:j])\u003c0 时： 对任意 (i,j) 范围内的 k，sum(B[i:k])\u003e=0 故 sum(B[k:j])=sum(B[i:j])-sum(B[i:k])\u003c0 k 不能作为起点 所以重置起点 i=j，开始遍历 否则，当 j-i==len(A) 时，即符合要求 ","date":"2015-05-14","objectID":"/leetcode/0134/:2:0","tags":null,"title":"0134：加油站（★★）","uri":"/leetcode/0134/"},{"categories":null,"content":"解答 def canCompleteCircuit(self, gas: List[int], cost: List[int]) -\u003e int: A = [g-c for g,c in zip(gas, cost)] pre, i = 0, 0 for j, x in enumerate(A+A): pre += x if pre\u003c0: pre, i = 0, j+1 if j-i==len(A)-1: return i return -1 136 ms ","date":"2015-05-14","objectID":"/leetcode/0134/:3:0","tags":null,"title":"0134：加油站（★★）","uri":"/leetcode/0134/"},{"categories":null,"content":"*附加 问题还可以转为：在 A+A 的前缀和数组 pre 中，找一个长度 len(A)+1 的子数组，满足其首位是最小元素。 容易想到直接找 pre 前半部分的最小位置 i 作为首位 注意 pre 的后半部分其实就是前半部分的元素分别加上 sum(A) 如果 sum(A)\u003c0，则 pre[i+len(A)]\u003cpre[i]，没有满足要求的 i 如果 sum(A)\u003e=0，那么 i 就是符合要求的位置 最后 (i+1)%len(A) 即为所求。 def canCompleteCircuit(self, gas: List[int], cost: List[int]) -\u003e int: pre = li","date":"2015-05-14","objectID":"/leetcode/0134/:4:0","tags":null,"title":"0134：加油站（★★）","uri":"/leetcode/0134/"},{"categories":null,"content":"题目 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 class Node {\rpublic int val;\rpublic List\u003cNode\u003e neighbors;\r}\r测试用例格式： 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2）， 以此类推。该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必","date":"2015-05-13","objectID":"/leetcode/0133/:1:0","tags":null,"title":"0133：克隆图（★★）","uri":"/leetcode/0133/"},{"categories":null,"content":"分析 考虑在遍历时维护 \u003c原节点,克隆节点\u003e 的映射 d，即可解决循环的问题： 遍历到节点 u ，若 u 在 d 中则跳过 若 u 不在 d 中，只克隆值得到节点 u’，保存映射 \u003cu,u’\u003e 到 d 当 u 的邻居 v 遍历完后，将 v 的克隆 v’ 添加到 u’ 的邻居列表中即可 遍历可以用 bfs，也可以用 dfs。用 bfs 时注意入队前就应克隆，防止重复入队。 用 dfs 时注意不能用 d.get(v, dfs(v)) 来简化。 即使元素在 dict 中，dict.get 的 default 也会执行，只不过不返回该值。 ","date":"2015-05-13","objectID":"/leetcode/0133/:2:0","tags":null,"title":"0133：克隆图（★★）","uri":"/leetcode/0133/"},{"categories":null,"content":"解答 def cloneGraph(self, node: 'Node') -\u003e 'Node': def dfs(u): d[u] = Node(u.val) d[u].neighbors = [d[v] if v in d else dfs(v) for v in u.neighbors] return d[u] d = {} return dfs(node) if node else None 40 ms ","date":"2015-05-13","objectID":"/leetcode/0133/:3:0","tags":null,"title":"0133：克隆图（★★）","uri":"/leetcode/0133/"},{"categories":null,"content":"题目 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。 返回符合要求的 最少分割次数 。 示例 1： 输入：s = \"aab\"\r输出：1\r解释：只需一次分割就可将 s 分割成 [\"aa\",\"b\"] 这样两个回文子串。\r示例 2： 输入：s = \"a\"\r输出：0\r示例 3： 输入：s = \"ab\"\r输出：1\r提示： 1 \u003c= s.length \u003c= 2000 s 仅由小写英文字母组成 ","date":"2015-05-12","objectID":"/leetcode/0132/:1:0","tags":null,"title":"0132：分割回文串II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"分析 ","date":"2015-05-12","objectID":"/leetcode/0132/:2:0","tags":null,"title":"0132：分割回文串II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"#1 类似 0131，可以递归。 要注意的是若本身就是回文串，应直接返回 0。 def minCut(self, s: str) -\u003e int: @lru_cache(None) def dfs(i): if s[i:] == s[i:][::-1]: return 0 res = float('inf') for j in range(i+1, len(s)): if s[i:j] == s[i:j][::-1]: res = min(res, 1+dfs(j)) return res return dfs(0) 1784 ms ","date":"2015-05-12","objectID":"/leetcode/0132/:2:1","tags":null,"title":"0132：分割回文串II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"#2 观察可发现，有很多重复判断 s 的子串是否回文。根据 0005，也可以用动态规划解决。 另外，求最小分割也可以改成动态规划的非递归形式，节省空间。 ","date":"2015-05-12","objectID":"/leetcode/0132/:2:2","tags":null,"title":"0132：分割回文串II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"解答 def minCut(self, s: str) -\u003e int: n = len(s) f = [[True]*n for _ in range(n)] for j in range(n): for i in range(j): f[i][j] = f[i+1][j-1] and s[i]==s[j] dp = [0]*n for i in range(n): dp[i] = 0 if f[0][i] else 1+min(dp[j] for j in range(i) if f[j+1][i]) return dp[-1] 时间复杂度 O(N^2)，572 ms ","date":"2015-05-12","objectID":"/leetcode/0132/:3:0","tags":null,"title":"0132：分割回文串II（★★）","uri":"/leetcode/0132/"},{"categories":null,"content":"题目 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。 返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 示例 1： 输入：s = \"aab\"\r输出：[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\r示例 2： 输入：s = \"a\"\r输出：[[\"a\"]]\r提示： 1 \u003c= s.length \u003c= 16 s 仅由小写英文字母组成 ","date":"2015-05-11","objectID":"/leetcode/0131/:1:0","tags":null,"title":"0131：分割回文串（★★）","uri":"/leetcode/0131/"},{"categories":null,"content":"分析 典型的单串 dp，按第一个回文子串的长度可以递归。 ","date":"2015-05-11","objectID":"/leetcode/0131/:2:0","tags":null,"title":"0131：分割回文串（★★）","uri":"/leetcode/0131/"},{"categories":null,"content":"解答 def partition(self, s: str) -\u003e List[List[str]]: @lru_cache(None) def dfs(i): if i==len(s): return [[]] res = [] for j in range(i+1, len(s)+1): pre = s[i:j] if pre == pre[::-1]: res.extend([pre]+sub for sub in dfs(j)) return res return dfs(0) 88 ms ","date":"2015-05-11","objectID":"/leetcode/0131/:3:0","tags":null,"title":"0131：分割回文串（★★）","uri":"/leetcode/0131/"},{"categories":null,"content":"题目 给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域， 并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例 1： 输入：board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\r输出：[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\r解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任","date":"2015-05-10","objectID":"/leetcode/0130/:1:0","tags":null,"title":"0130：被围绕的区域（★）","uri":"/leetcode/0130/"},{"categories":null,"content":"分析 本题可以用 dfs 或 bfs 遍历找到所有与边界外连通的 ‘O’，剩下的 ‘O’ 换成 ‘X’ 即可。 不过连通问题一般还是用并查集，方便进阶问题的解决。 并查集做法： 将边界上的 ‘O’ 都与哑节点 dummy 连通， 再将相邻的 ‘O’ 连通。 将不与 dummy 连通的 ‘O’ 换成 ‘X’ 即可 ","date":"2015-05-10","objectID":"/leetcode/0130/:2:0","tags":null,"title":"0130：被围绕的区域（★）","uri":"/leetcode/0130/"},{"categories":null,"content":"解答 def solve(self, board: List[List[str]]) -\u003e None: def find(x): if f.setdefault(x, x) != x: f[x] = find(f[x]) return f[x] def union(x, y): f[find(x)] = find(y) m, n = len(board), len(board[0]) f, dummy = {}, (-1, -1) for i, j in product(range(m), range(n)): if board[i][j] == 'O': if i in [0, m - 1]","date":"2015-05-10","objectID":"/leetcode/0130/:3:0","tags":null,"title":"0130：被围绕的区域（★）","uri":"/leetcode/0130/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。 每条从根节点到叶节点的路径都代表一个数字： 例如，从根节点到叶节点的路径 1 -\u003e 2 -\u003e 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。 叶节点 是指没有子节点的节点。 示例 1： 输入：root = [1,2,3]\r输出：25\r解释：\r从根到叶子节点路径 1-\u003e2 代表数字 12\r从根到叶子节点路径 1-\u003e3 代表数字 13\r因此，数字总和 = 12 + 13 = 25\r示例 2： 输入：root = [4,9,0,5,1]\r输出：1026\r解释：\r从根到叶子节点路径 4","date":"2015-05-09","objectID":"/leetcode/0129/:1:0","tags":null,"title":"0129：求根节点到叶节点数字之和（★）","uri":"/leetcode/0129/"},{"categories":null,"content":"分析 遍历时维护根节点到当前节点的路径数字，遇到叶子节点就加到结果中即可。 ","date":"2015-05-09","objectID":"/leetcode/0129/:2:0","tags":null,"title":"0129：求根节点到叶节点数字之和（★）","uri":"/leetcode/0129/"},{"categories":null,"content":"解答 def binaryTreePaths(self, root: Optional[TreeNode]) -\u003e List[str]: res, stack = [], [(root, '')] while stack: node, s = stack.pop() if node: s += ('-\u003e' if s else '') + str(node.val) if not node.left and not node.right: res.append(s) stack.extend([(node.right, s), (node.left, s)]) return res 32 ms ","date":"2015-05-09","objectID":"/leetcode/0129/:3:0","tags":null,"title":"0129：求根节点到叶节点数字之和（★）","uri":"/leetcode/0129/"},{"categories":null,"content":"题目 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1： 输入：nums = [100,4,200,1,3,2]\r输出：4\r解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\r示例 2： 输入：nums = [0,3,7,2,5,8,4,6,0,1]\r输出：9\r提示： 0 \u003c= nums.length \u003c= 10^5 -10^9 \u003c= nums[i] \u003c= 10^9 ","date":"2015-05-08","objectID":"/leetcode/0128/:1:0","tags":null,"title":"0128：最长连续序列(★★)","uri":"/leetcode/0128/"},{"categories":null,"content":"分析 ","date":"2015-05-08","objectID":"/leetcode/0128/:2:0","tags":null,"title":"0128：最长连续序列(★★)","uri":"/leetcode/0128/"},{"categories":null,"content":"#1 最简单的就是去重排序，然后遍历比较每条数字连续的序列即可。 def longestConsecutive(self, nums: List[int]) -\u003e int: nums = sorted(set(nums)) res, i = 0, 0 for j, num in enumerate(nums): if j == len(nums)-1 or num+1 != nums[j+1]: res = max(res, j-i+1) i = j+1 return res 32 ms ","date":"2015-05-08","objectID":"/leetcode/0128/:2:1","tags":null,"title":"0128：最长连续序列(★★)","uri":"/leetcode/0128/"},{"categories":null,"content":"#2 要求时间复杂度 O(n)，考虑找到每条序列的起点开始遍历。 有个巧妙的方法判断起点： 如果 x-1 在 nums 中，x 不是起点 如果 x-1 不在 nums 中，x 是起点 ","date":"2015-05-08","objectID":"/leetcode/0128/:2:2","tags":null,"title":"0128：最长连续序列(★★)","uri":"/leetcode/0128/"},{"categories":null,"content":"解答 def longestConsecutive(self, nums: List[int]) -\u003e int: res, nums = 0, set(nums) for num in nums: if num-1 not in nums: cnt = 0 while num in nums: num += 1 cnt += 1 res = max(res, cnt) return res 44 ms ","date":"2015-05-08","objectID":"/leetcode/0128/:3:0","tags":null,"title":"0128：最长连续序列(★★)","uri":"/leetcode/0128/"},{"categories":null,"content":"题目 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -\u003e s1 -\u003e s2 -\u003e … -\u003e sk： 每一对相邻的单词只差一个字母。 对于 1 \u003c= i \u003c= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。 sk == endWord 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。 示","date":"2015-05-07","objectID":"/leetcode/0127/:1:0","tags":null,"title":"0127：单词接龙（★★★）","uri":"/leetcode/0127/"},{"categories":null,"content":"分析 显然可以用 bfs，从 beginWord 开始，每一轮搜索能转换的单词，直到搜到 endWord 或没有能转换的单词。 搜索过程类似 0676： 将单词的某一位改为 ‘.’ 作为单词的 key 每个单词按所有的 key 存在哈希表中 搜索时，取所有 key 对应的列表即可 ","date":"2015-05-07","objectID":"/leetcode/0127/:2:0","tags":null,"title":"0127：单词接龙（★★★）","uri":"/leetcode/0127/"},{"categories":null,"content":"解答 def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -\u003e int: d = defaultdict(list) for w in wordList: for i in range(len(w)): d[w[:i]+'.'+w[i+1:]].append(w) Q, dis = deque([beginWord]), {beginWord: 1} while Q: u = Q.popleft() if u == endWord: return dis[u] for i in range(len(","date":"2015-05-07","objectID":"/leetcode/0127/:3:0","tags":null,"title":"0127：单词接龙（★★★）","uri":"/leetcode/0127/"},{"categories":null,"content":"题目 按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -\u003e s1 -\u003e s2 -\u003e … -\u003e sk 这样的单词序列，并满足： 每对相邻的单词之间仅有单个字母不同。 转换过程中的每个单词 si（1 \u003c= i \u003c= k）必须是字典 wordList 中的单词。 注意，beginWord 不必是字典 wordList 中的单词。 sk == endWord 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。 请你找出并返回所有从 beginWord 到 endW","date":"2015-05-06","objectID":"/leetcode/0126/:1:0","tags":null,"title":"0126：单词接龙 II（★★★）","uri":"/leetcode/0126/"},{"categories":null,"content":"分析 0127 升级版。 要求所有序列，考虑从 bfs 的路径中倒推： bfs 的过程中得到 dis 字典，保存了经过的每个单词到 beginWord 的距离 假设单词 w 和 endWord 相邻且 dis[w]==dis[endWord]-1，那么可以经过 w 来组成最短路径 依此类推，找到 beginWord 时，即得到一条最短路径 用回溯法可以搜索到所有最短路径 特别注意 beginWord 可能在 wordList 中，也可能不在，因此构建字典 d 时， 要遍历 set(wordList)|{beginWord}。 ","date":"2015-05-06","objectID":"/leetcode/0126/:2:0","tags":null,"title":"0126：单词接龙 II（★★★）","uri":"/leetcode/0126/"},{"categories":null,"content":"解答 def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -\u003e List[List[str]]: d = defaultdict(list) for w in set(wordList)|{beginWord}: for i in range(len(w)): d[w[:i]+'.'+w[i+1:]].append(w) Q, dis = deque([beginWord]), {beginWord: 1} while Q: u = Q.popleft() if u == endWord: break","date":"2015-05-06","objectID":"/leetcode/0126/:3:0","tags":null,"title":"0126：单词接龙 II（★★★）","uri":"/leetcode/0126/"},{"categories":null,"content":"题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: \"A man, a plan, a canal: Panama\"\r输出: true\r示例 2: 输入: \"race a car\"\r输出: false\r提示： 1 \u003c= s.length \u003c= 2 * 10^5 字符串 s 由 ASCII 字符组成 ","date":"2015-05-05","objectID":"/leetcode/0125/:1:0","tags":null,"title":"0125：验证回文串","uri":"/leetcode/0125/"},{"categories":null,"content":"分析 去除掉无关字符，判断正反序是否相同即可。 ","date":"2015-05-05","objectID":"/leetcode/0125/:2:0","tags":null,"title":"0125：验证回文串","uri":"/leetcode/0125/"},{"categories":null,"content":"解答 def isPalindrome(self, s: str) -\u003e bool: ss = ''.join(char for char in s if char.isalnum()).lower() return ss == ss[::-1] 36 ms ","date":"2015-05-05","objectID":"/leetcode/0125/:3:0","tags":null,"title":"0125：验证回文串","uri":"/leetcode/0125/"},{"categories":null,"content":"题目 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。 同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 示例 1： 输入：root = [1,2,3]\r输出：6\r解释：最优路径是 2 -\u003e 1 -\u003e 3 ，路径和为 2 + 1 + 3 = 6\r示例 2： 输入：root = [-10,9,20,null,null,15,7]\r输出：42\r解释：最优路径是 15 -\u003e 20 -\u003e 7 ，路径和为 15 + 20 + 7 = 4","date":"2015-05-04","objectID":"/leetcode/0124/:1:0","tags":null,"title":"0124：二叉树中的最大路径和（★★）","uri":"/leetcode/0124/"},{"categories":null,"content":"分析 用 dfs(node) 同时返回 node 的最大路径和，以 node 为起点的最大路径和，即可递归。 ","date":"2015-05-04","objectID":"/leetcode/0124/:2:0","tags":null,"title":"0124：二叉树中的最大路径和（★★）","uri":"/leetcode/0124/"},{"categories":null,"content":"解答 def maxPathSum(self, root: Optional[TreeNode]) -\u003e int: def dfs(node): if not node: return float('-inf'), float('-inf') l1, l2 = dfs(node.left) r1, r2 = dfs(node.right) l2, r2 = max(0, l2), max(0, r2) return max(l1, r1, node.val+l2+r2), node.val+max(l2, r2) return dfs(root)[0] 84 ms ","date":"2015-05-04","objectID":"/leetcode/0124/:3:0","tags":null,"title":"0124：二叉树中的最大路径和（★★）","uri":"/leetcode/0124/"},{"categories":null,"content":"题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入：prices = [3,3,5,0,0,3,1,4]\r输出：6\r解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，\r这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，\r在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\r示例 2： 输入：","date":"2015-05-03","objectID":"/leetcode/0123/:1:0","tags":null,"title":"0123：买卖股票的最佳时机 III（★★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"分析 ","date":"2015-05-03","objectID":"/leetcode/0123/:2:0","tags":null,"title":"0123：买卖股票的最佳时机 III（★★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"#1 0121 升级版，添加了次数限制，所以考虑加一个状态参数。 令 dp[i][j][0]、dp[i][j][1] 分别代表 prices[:i] 最多买过 j 支股票且手里有/无股票的最大利润，即可递推： dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j-1][1]-prices[i-1])\rdp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j][0]+prices[i-1])\rdef maxProfit(self, prices: List[int]) -\u003e int: n = len(prices) dp = [[[fl","date":"2015-05-03","objectID":"/leetcode/0123/:2:1","tags":null,"title":"0123：买卖股票的最佳时机 III（★★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"#2 可以用滚动数组优化空间。 ","date":"2015-05-03","objectID":"/leetcode/0123/:2:2","tags":null,"title":"0123：买卖股票的最佳时机 III（★★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"解答 def maxProfit(self, prices: List[int]) -\u003e int: n = len(prices) dp = [[float('-inf'), 0] for _ in range(3)] for x in prices: prev = dp[:] for j in range(1, 3): dp[j][0] = max(prev[j][0], prev[j-1][1]-x) dp[j][1] = max(prev[j][1], prev[j][0]+x) return dp[-1][-1] 692 ms ","date":"2015-05-03","objectID":"/leetcode/0123/:3:0","tags":null,"title":"0123：买卖股票的最佳时机 III（★★★）","uri":"/leetcode/0123/"},{"categories":null,"content":"题目 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。 你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1: 输入: prices = [7,1,5,3,6,4]\r输出: 7\r解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，\r在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 ","date":"2015-05-02","objectID":"/leetcode/0122/:1:0","tags":null,"title":"0122：买卖股票的最佳时机 II（★）","uri":"/leetcode/0122/"},{"categories":null,"content":"分析 类似 0121，区别在于可以多次买卖，dp[i][0] 的递推式有变化： dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i-1])\r","date":"2015-05-02","objectID":"/leetcode/0122/:2:0","tags":null,"title":"0122：买卖股票的最佳时机 II（★）","uri":"/leetcode/0122/"},{"categories":null,"content":"解答 def maxProfit(self, prices: List[int]) -\u003e int: a, b = float('-inf'), 0 for price in prices: a, b = max(a, b-price), max(b, a+price) return b 28 ms ","date":"2015-05-02","objectID":"/leetcode/0122/:3:0","tags":null,"title":"0122：买卖股票的最佳时机 II（★）","uri":"/leetcode/0122/"},{"categories":null,"content":"题目 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。 设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4]\r输出：5\r解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\r注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\r示例 2","date":"2015-05-01","objectID":"/leetcode/0121/:1:0","tags":null,"title":"0121：买卖股票的最佳时机（★）","uri":"/leetcode/0121/"},{"categories":null,"content":"分析 经典 dp 问题。 考虑最后一天的交易状态： 如果没有卖出，则转为 prices[:-1] 的递归子问题 如果卖了，则要求 prices[:-1] 有股票状态下的最大值 那么令 dp[i][0]、dp[i][1] 分别代表 prices[:i] 手里有/无股票的最大利润，即可递推： dp[i][0] = max(dp[i-1][0], -prices[i-1])\rdp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i-1])\r还可以优化为两个参数。 ","date":"2015-05-01","objectID":"/leetcode/0121/:2:0","tags":null,"title":"0121：买卖股票的最佳时机（★）","uri":"/leetcode/0121/"},{"categories":null,"content":"解答 def maxProfit(self, prices: List[int]) -\u003e int: a, b = float('-inf'), 0 for price in prices: a, b = max(a, -price), max(b, a+price) return b 188 ms ","date":"2015-05-01","objectID":"/leetcode/0121/:3:0","tags":null,"title":"0121：买卖股票的最佳时机（★）","uri":"/leetcode/0121/"},{"categories":null,"content":"题目 给定一个三角形 triangle ，找出自顶向下的最小路径和。 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ， 那么下一步可以移动到下一行的下标 i 或 i + 1 。 示例 1： 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\r输出：11\r解释：如下面简图所示：\r2\r3 4\r6 5 7\r4 1 8 3\r自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\r示例 2： 输入：triangle =","date":"2015-04-30","objectID":"/leetcode/0120/:1:0","tags":null,"title":"0120：三角形最小路径和（★）","uri":"/leetcode/0120/"},{"categories":null,"content":"分析 典型的 dp 问题。还可以直接用 triangle 保存结果，节省空间。 ","date":"2015-04-30","objectID":"/leetcode/0120/:2:0","tags":null,"title":"0120：三角形最小路径和（★）","uri":"/leetcode/0120/"},{"categories":null,"content":"解答 def minimumTotal(self, triangle: List[List[int]]) -\u003e int: n = len(triangle) for i in range(n-2, -1, -1): for j in range(i+1): triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]) return triangle[0][0] 36 ms ","date":"2015-04-30","objectID":"/leetcode/0120/:3:0","tags":null,"title":"0120：三角形最小路径和（★）","uri":"/leetcode/0120/"},{"categories":null,"content":"题目 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 输入: rowIndex = 3 输出: [1,3,3,1] 示例 2: 输入: rowIndex = 0 输出: [1] 示例 3: 输入: rowIndex = 1 输出: [1,1] 提示: 0 \u003c= rowIndex \u003c= 33 进阶：你可以优化你的算法到 O(rowIndex) 空间复杂度吗？ ","date":"2015-04-29","objectID":"/leetcode/0119/:1:0","tags":null,"title":"0119：杨辉三角 II","uri":"/leetcode/0119/"},{"categories":null,"content":"分析 迭代时覆盖上一层即可节省空间。 ","date":"2015-04-29","objectID":"/leetcode/0119/:2:0","tags":null,"title":"0119：杨辉三角 II","uri":"/leetcode/0119/"},{"categories":null,"content":"解答 def getRow(self, rowIndex: int) -\u003e List[int]: res = [1] for _ in range(rowIndex): res = [1] + [a+b for a,b in pairwise(res)] + [1] return res 32 ms ","date":"2015-04-29","objectID":"/leetcode/0119/:3:0","tags":null,"title":"0119：杨辉三角 II","uri":"/leetcode/0119/"},{"categories":null,"content":"*附加 也可以利用数学知识，杨辉三角的第 k 行其实就是： $$[ C_k^0, C_k^1, …, C_k^k ]$$ def getRow(self, rowIndex: int) -\u003e List[int]: return [comb(rowIndex, i) for i in range(rowIndex+1)] 40 ms ","date":"2015-04-29","objectID":"/leetcode/0119/:4:0","tags":null,"title":"0119：杨辉三角 II","uri":"/leetcode/0119/"},{"categories":null,"content":"题目 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2: 输入: numRows = 1 输出: [[1]] 提示: 1 \u003c= numRows \u003c= 30 ","date":"2015-04-28","objectID":"/leetcode/0118/:1:0","tags":null,"title":"0118：杨辉三角","uri":"/leetcode/0118/"},{"categories":null,"content":"分析 每层迭代即可。 ","date":"2015-04-28","objectID":"/leetcode/0118/:2:0","tags":null,"title":"0118：杨辉三角","uri":"/leetcode/0118/"},{"categories":null,"content":"解答 def generate(self, numRows: int) -\u003e List[List[int]]: res = [[1]] for _ in range(numRows-1): res.append([1]+[a+b for a,b in pairwise(res[-1])]+[1]) return res 32 ms ","date":"2015-04-28","objectID":"/leetcode/0118/:3:0","tags":null,"title":"0118：杨辉三角","uri":"/leetcode/0118/"},{"categories":null,"content":"题目 给定一个二叉树： struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 进阶： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例： 输入： root = [1,2,3,4,5,null,7] 输出： [1,#,2,3,#,4,5,7,#] 解释： 给定二叉树如图 A 所示，你的函","date":"2015-04-27","objectID":"/leetcode/0117/:1:0","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★★）","uri":"/leetcode/0117/"},{"categories":null,"content":"分析 ","date":"2015-04-27","objectID":"/leetcode/0117/:2:0","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★★）","uri":"/leetcode/0117/"},{"categories":null,"content":"#1 与 0116 的区别在于不是完美二叉树了。 层序遍历的代码相同。 def connect(self, root: 'Node') -\u003e 'Node': Q = [root] if root else [] while Q: for p, q in pairwise(Q): p.next = q Q = [child for p in Q for child in [p.left, p.right] if child] return root 52 ms ","date":"2015-04-27","objectID":"/leetcode/0117/:2:1","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★★）","uri":"/leetcode/0117/"},{"categories":null,"content":"#2 依然可以每层提前填充下一层的 next 指针。额外添加哑结点，并记录前置节点即可。 ","date":"2015-04-27","objectID":"/leetcode/0117/:2:2","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★★）","uri":"/leetcode/0117/"},{"categories":null,"content":"解答 def connect(self, root: 'Node') -\u003e 'Node': p = root while p: dummy = prev = Node() while p: for child in [p.left, p.right]: if child: prev.next = child prev = child p = p.next p = dummy.next return root 52 ms ","date":"2015-04-27","objectID":"/leetcode/0117/:3:0","tags":null,"title":"0117：填充每个节点的下一个右侧节点指针 II（★★）","uri":"/leetcode/0117/"},{"categories":null,"content":"题目 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点， 则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例 1： 输入： root = [1,2,3,4,5,6,7] 输出： [1,#,2,3,#,4,5,6,7,#] 解释： 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指","date":"2015-04-26","objectID":"/leetcode/0116/:1:0","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★★）","uri":"/leetcode/0116/"},{"categories":null,"content":"分析 ","date":"2015-04-26","objectID":"/leetcode/0116/:2:0","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★★）","uri":"/leetcode/0116/"},{"categories":null,"content":"#1 最简单的就是层序遍历，每一层填充即可。 def connect(self, root: 'Optional[Node]') -\u003e 'Optional[Node]': Q = [root] if root else [] while Q: for p, q in pairwise(Q): p.next = q Q = [child for p in Q for child in [p.left, p.right] if child] return root 56 ms ","date":"2015-04-26","objectID":"/leetcode/0116/:2:1","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★★）","uri":"/leetcode/0116/"},{"categories":null,"content":"#2 要求不用额外空间，有个巧妙的想法。 每层提前填充下一层的 next 指针，那么从每层最左边根据 next 指针就可以完成遍历，不需要存储其它节点。 ","date":"2015-04-26","objectID":"/leetcode/0116/:2:2","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★★）","uri":"/leetcode/0116/"},{"categories":null,"content":"解答 def connect(self, root: 'Optional[Node]') -\u003e 'Optional[Node]': cur = root while cur and cur.left: p = cur while p: p.left.next = p.right if p.next: p.right.next = p.next.left p = p.next cur = cur.left return root 60 ms ","date":"2015-04-26","objectID":"/leetcode/0116/:3:0","tags":null,"title":"0116：填充每个节点的下一个右侧节点指针（★★）","uri":"/leetcode/0116/"},{"categories":null,"content":"题目 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。 （例如，“ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是） 题目数据保证答案符合 32 位带符号整数范围。 示例 1： 输入：s = \"rabbbit\", t = \"rabbit\"\r输出：3\r解释：\r如下图所示, 有 3 种可以从 s 中得到 \"rabbit\" 的方案。\rrabbbit\rrabbbit\rrabbbit\r示例 2： 输入：s = \"babgbag\", t = \"bag\"\r输","date":"2015-04-25","objectID":"/leetcode/0115/:1:0","tags":null,"title":"0115：不同的子序列（★★★）","uri":"/leetcode/0115/"},{"categories":null,"content":"分析 典型的双串 dp，按是否由 s[-1] 拼成 t[-1] 即可递归。 ","date":"2015-04-25","objectID":"/leetcode/0115/:2:0","tags":null,"title":"0115：不同的子序列（★★★）","uri":"/leetcode/0115/"},{"categories":null,"content":"解答 def numDistinct(self, s: str, t: str) -\u003e int: @lru_cache(None) def dfs(s, t): if len(s) \u003c len(t): return 0 if not t: return 1 res = dfs(s[:-1], t) if s[-1]==t[-1]: res += dfs(s[:-1], t[:-1]) return res return dfs(s, t) 60 ms ","date":"2015-04-25","objectID":"/leetcode/0115/:3:0","tags":null,"title":"0115：不同的子序列（★★★）","uri":"/leetcode/0115/"},{"categories":null,"content":"题目 给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点， 而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 示例 1： 输入：root = [1,2,5,3,4,null,6]\r输出：[1,null,2,null,3,null,4,null,5,null,6]\r示例 2： 输入：root = []\r输出：[]\r示例 3： 输入：root = [0]\r输出：[0]\r提示： 树中结点数在范围 [0, 2000] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-04-24","objectID":"/leetcode/0114/:1:0","tags":null,"title":"0114：二叉树展开为链表（★）","uri":"/leetcode/0114/"},{"categories":null,"content":"分析 先序遍历 root，每次将上一个节点的 right 指向当前节点即可。 注意要去掉节点的 left 指针。 ","date":"2015-04-24","objectID":"/leetcode/0114/:2:0","tags":null,"title":"0114：二叉树展开为链表（★）","uri":"/leetcode/0114/"},{"categories":null,"content":"解答 def flatten(self, root: TreeNode) -\u003e None: stack, prev = [root], TreeNode() while stack: node = stack.pop() if node: stack.extend([node.right, node.left]) prev.right = node node.left = None prev = node 40 ms ","date":"2015-04-24","objectID":"/leetcode/0114/:3:0","tags":null,"title":"0114：二叉树展开为链表（★）","uri":"/leetcode/0114/"},{"categories":null,"content":"题目 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\r输出：[[5,4,11,2],[5,8,4,5]]\r示例 2： 输入：root = [1,2,3], targetSum = 5\r输出：[]\r示例 3： 输入：root = [1,2], targetSum = 0\r输出：[]\r提示： 树中节点总数在范围 [0, 5000] 内 -10","date":"2015-04-23","objectID":"/leetcode/0113/:1:0","tags":null,"title":"0113：路径总和 II（★）","uri":"/leetcode/0113/"},{"categories":null,"content":"分析 类似 0112，可以用递归或遍历，这里用递归。 ","date":"2015-04-23","objectID":"/leetcode/0113/:2:0","tags":null,"title":"0113：路径总和 II（★）","uri":"/leetcode/0113/"},{"categories":null,"content":"解答 def pathSum(self, root: TreeNode, targetSum: int) -\u003e List[List[int]]: def dfs(p, x): if not p: return [] if not p.left and not p.right and p.val==x: return [[x]] return [[p.val]+sub for sub in dfs(p.left, x-p.val) + dfs(p.right, x-p.val)] return dfs(root, targetSum) 60 ms ","date":"2015-04-23","objectID":"/leetcode/0113/:3:0","tags":null,"title":"0113：路径总和 II（★）","uri":"/leetcode/0113/"},{"categories":null,"content":"题目 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径， 这条路径上所有节点值相加等于目标和 targetSum 。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\r输出：true\r示例 2： 输入：root = [1,2,3], targetSum = 5\r输出：false\r示例 3： 输入：root = [1,2], targetSum = 0\r输出：false\r提示： 树中节点的数目在","date":"2015-04-22","objectID":"/leetcode/0112/:1:0","tags":null,"title":"0112：路径总和（★）","uri":"/leetcode/0112/"},{"categories":null,"content":"分析 ","date":"2015-04-22","objectID":"/leetcode/0112/:2:0","tags":null,"title":"0112：路径总和（★）","uri":"/leetcode/0112/"},{"categories":null,"content":"#1 令 dfs(p, x) 代表是否存在节点 p 到叶子节点的路径和为 x，即可递归。 def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u003e bool: def dfs(p, x): if not p: return False if not p.left and not p.right: return p.val == x return dfs(p.left, x-p.val) or dfs(p.right, x-p.val) return dfs(root, targetSum) 40 ms ","date":"2015-04-22","objectID":"/leetcode/0112/:2:1","tags":null,"title":"0112：路径总和（★）","uri":"/leetcode/0112/"},{"categories":null,"content":"#2 也可以遍历树，维护当前节点到根节点的路径和。遇到叶子节点时，判断是否满足即可。 ","date":"2015-04-22","objectID":"/leetcode/0112/:2:2","tags":null,"title":"0112：路径总和（★）","uri":"/leetcode/0112/"},{"categories":null,"content":"解答 def hasPathSum(self, root: TreeNode, targetSum: int) -\u003e bool: stack = [(root, 0)] while stack: node, val = stack.pop() if node: val += node.val if not node.left and not node.right and val == targetSum: return True stack.extend([(node.right, val), (node.left,val)]) return False 40 ms ","date":"2015-04-22","objectID":"/leetcode/0112/:3:0","tags":null,"title":"0112：路径总和（★）","uri":"/leetcode/0112/"},{"categories":null,"content":"题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例 1： 输入：root = [3,9,20,null,null,15,7]\r输出：2\r示例 2： 输入：root = [2,null,3,null,4,null,5,null,6]\r输出：5\r提示： 树中节点数的范围在 [0, 10^5] 内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2015-04-21","objectID":"/leetcode/0111/:1:0","tags":null,"title":"0111：二叉树的最小深度（★）","uri":"/leetcode/0111/"},{"categories":null,"content":"分析 ","date":"2015-04-21","objectID":"/leetcode/0111/:2:0","tags":null,"title":"0111：二叉树的最小深度（★）","uri":"/leetcode/0111/"},{"categories":null,"content":"#1 类似 0104 ，可以用递归。 def minDepth(self, root: TreeNode) -\u003e int: if not root: return 0 if not root.left or not root.right: return self.minDepth(root.right) + self.minDepth(root.left) + 1 return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 616 ms ","date":"2015-04-21","objectID":"/leetcode/0111/:2:1","tags":null,"title":"0111：二叉树的最小深度（★）","uri":"/leetcode/0111/"},{"categories":null,"content":"#2 也可以层序遍历，遇到第一个叶子节点即返回。 ","date":"2015-04-21","objectID":"/leetcode/0111/:2:2","tags":null,"title":"0111：二叉树的最小深度（★）","uri":"/leetcode/0111/"},{"categories":null,"content":"解答 def minDepth(self, root: TreeNode) -\u003e int: res, Q = 0, [root] if root else [] while Q: res += 1 if any(not node.left and not node.right for node in Q): break Q = [child for node in Q for child in [node.left, node.right] if child] return res 476 ms ","date":"2015-04-21","objectID":"/leetcode/0111/:3:0","tags":null,"title":"0111：二叉树的最小深度（★）","uri":"/leetcode/0111/"},{"categories":null,"content":"题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root = [3,9,20,null,null,15,7]\r输出：true\r示例 2： 输入：root = [1,2,2,3,3,null,null,4,4]\r输出：false\r示例 3： 输入：root = []\r输出：true\r提示： 树中的节点数在范围 [0, 5000] 内 -10^4 \u003c= Node.val \u003c= 10^4 ","date":"2015-04-20","objectID":"/leetcode/0110/:1:0","tags":null,"title":"0110：平衡二叉树（★）","uri":"/leetcode/0110/"},{"categories":null,"content":"分析 用 dfs(node) 同时返回 node 是否平衡、node 的深度，即可递归。 为了方便，可以用深度为 -1 来代表不平衡，dfs(node) 返回 node 的深度即可。 ","date":"2015-04-20","objectID":"/leetcode/0110/:2:0","tags":null,"title":"0110：平衡二叉树（★）","uri":"/leetcode/0110/"},{"categories":null,"content":"解答 def isBalanced(self, root: TreeNode) -\u003e bool: def dfs(root): if not root: return 0 l, r = dfs(root.left), dfs(root.right) return -1 if l==-1 or r==-1 or abs(l-r)\u003e1 else 1+max(l, r) return dfs(root) != -1 52 ms ","date":"2015-04-20","objectID":"/leetcode/0110/:3:0","tags":null,"title":"0110：平衡二叉树（★）","uri":"/leetcode/0110/"},{"categories":null,"content":"题目 给定一个单链表的头节点 head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。 示例 1: 输入: head = [-10,-3,0,5,9]\r输出: [0,-3,9,-10,null,5]\r解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\r示例 2: 输入: head = []\r输出: []\r提示: head 中的节点数在[0, 2 * 10^4] 范围内 -10^5 \u003c= Node.val \u003c= 10^5 ","date":"2015-04-19","objectID":"/leetcode/0109/:1:0","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"分析 ","date":"2015-04-19","objectID":"/leetcode/0109/:2:0","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"#1 0108 升级版。可以先将链表转为数组，再转换。 def sortedListToBST(self, head: Optional[ListNode]) -\u003e Optional[TreeNode]: def dfs(i, j): mid = (i + j) // 2 return None if i == j else TreeNode(nums[mid], dfs(i, mid), dfs(mid + 1, j)) nums = [] while head: nums.append(head.val) head = head.next return dfs(0, len(nums)) ","date":"2015-04-19","objectID":"/leetcode/0109/:2:1","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"#2 也可以直接用快慢指针在链表上找到中点，然后转为递归子问题。 ","date":"2015-04-19","objectID":"/leetcode/0109/:2:2","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"解答 def sortedListToBST(self, head: Optional[ListNode]) -\u003e Optional[TreeNode]: def findMid(head): slow = fast = ListNode(next=head) while fast.next and fast.next.next: slow, fast = slow.next, fast.next.next return slow def dfs(head): if not head: return None if not head.next: return TreeNode(head.val","date":"2015-04-19","objectID":"/leetcode/0109/:3:0","tags":null,"title":"0109：有序链表转换二叉搜索树（★）","uri":"/leetcode/0109/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 示例 1： 输入：nums = [-10,-3,0,5,9]\r输出：[0,-3,9,-10,null,5]\r解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\r示例 2： 输入：nums = [1,3]\r输出：[3,1]\r解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。\r提示： 1 \u003c= nums.length \u003c= 10^4 -10^4 \u003c= nums[i] ","date":"2015-04-18","objectID":"/leetcode/0108/:1:0","tags":null,"title":"0108：将有序数组转换为二叉搜索树（★）","uri":"/leetcode/0108/"},{"categories":null,"content":"分析 将中点作为根节点，前半部分和后半部分分别作为左子树和右子树，即可转为递归子问题。 ","date":"2015-04-18","objectID":"/leetcode/0108/:2:0","tags":null,"title":"0108：将有序数组转换为二叉搜索树（★）","uri":"/leetcode/0108/"},{"categories":null,"content":"解答 def sortedArrayToBST(self, nums: List[int]) -\u003e TreeNode: def dfs(i, j): mid = (i+j)//2 return None if i==j else TreeNode(nums[mid], dfs(i, mid), dfs(mid+1, j)) return dfs(0, len(nums)) 40 ms ","date":"2015-04-18","objectID":"/leetcode/0108/:3:0","tags":null,"title":"0108：将有序数组转换为二叉搜索树（★）","uri":"/leetcode/0108/"},{"categories":null,"content":"题目 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例 1： 输入：root = [3,9,20,null,null,15,7]\r输出：[[15,7],[9,20],[3]]\r示例 2： 输入：root = [1]\r输出：[[1]]\r示例 3： 输入：root = []\r输出：[]\r提示： 树中节点数目在范围 [0, 2000] 内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2015-04-17","objectID":"/leetcode/0107/:1:0","tags":null,"title":"0107：二叉树的层序遍历 II（★）","uri":"/leetcode/0107/"},{"categories":null,"content":"分析 将 0102 的结果反序即可。 ","date":"2015-04-17","objectID":"/leetcode/0107/:2:0","tags":null,"title":"0107：二叉树的层序遍历 II（★）","uri":"/leetcode/0107/"},{"categories":null,"content":"解答 def levelOrderBottom(self, root: TreeNode) -\u003e List[List[int]]: res, Q = [], [root] if root else [] while Q: res.append([node.val for node in Q]) Q = [child for node in Q for child in [node.left, node.right] if child] return res[::-1] 32 ms ","date":"2015-04-17","objectID":"/leetcode/0107/:3:0","tags":null,"title":"0107：二叉树的层序遍历 II（★）","uri":"/leetcode/0107/"},{"categories":null,"content":"题目 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例 1: 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\r输出：[3,9,20,null,null,15,7]\r示例 2: 输入：inorder = [-1], postorder = [-1]\r输出：[-1]\r提示: 1 \u003c= inorder.length \u003c= 3000 postorder.length == inorder.length -300","date":"2015-04-16","objectID":"/leetcode/0106/:1:0","tags":null,"title":"0106：从中序与后序遍历序列构造二叉树（★★）","uri":"/leetcode/0106/"},{"categories":null,"content":"分析 类似 0105，只是从找 preorder[0] 变成了找 postorder[-1]。 ","date":"2015-04-16","objectID":"/leetcode/0106/:2:0","tags":null,"title":"0106：从中序与后序遍历序列构造二叉树（★★）","uri":"/leetcode/0106/"},{"categories":null,"content":"解答 def buildTree(self, inorder: List[int], postorder: List[int]) -\u003e TreeNode: def dfs(io, po): if not po: return None i = io.index(po[-1]) return TreeNode(po[-1], dfs(io[:i], po[:i]), dfs(io[i+1:], po[i:-1])) return dfs(inorder, postorder) 112 ms ","date":"2015-04-16","objectID":"/leetcode/0106/:3:0","tags":null,"title":"0106：从中序与后序遍历序列构造二叉树（★★）","uri":"/leetcode/0106/"},{"categories":null,"content":"题目 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例 1: Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\rOutput: [3,9,20,null,null,15,7]\r示例 2: Input: preorder = [-1], inorder = [-1]\rOutput: [-1]\r提示: 1 \u003c= preorder.length \u003c= 3000 inorder.length == preorde","date":"2015-04-15","objectID":"/leetcode/0105/:1:0","tags":null,"title":"0105：从前序与中序遍历序列构造二叉树（★★）","uri":"/leetcode/0105/"},{"categories":null,"content":"分析 从上往下构造： 根节点即是 preorder[0] 在 inorder 中找到根节点位置 i，inorder[:i]、inorder[i+1:] 分别代表左/右子树 显然 preorder 和 inorder 中代表左子树的长度应该相等 那么 preorder[1:i+1]、preorder[i+1:] 分别代表左/右子树 然后可以对左/右子树递归 ","date":"2015-04-15","objectID":"/leetcode/0105/:2:0","tags":null,"title":"0105：从前序与中序遍历序列构造二叉树（★★）","uri":"/leetcode/0105/"},{"categories":null,"content":"解答 def buildTree(self, preorder: List[int], inorder: List[int]) -\u003e TreeNode: def dfs(po, io): if not po: return None i = io.index(po[0]) return TreeNode(po[0], dfs(po[1:i+1], io[:i]), dfs(po[i+1:], io[i+1:])) return dfs(preorder, inorder) 132 ms ","date":"2015-04-15","objectID":"/leetcode/0105/:3:0","tags":null,"title":"0105：从前序与中序遍历序列构造二叉树（★★）","uri":"/leetcode/0105/"},{"categories":null,"content":"题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3\r/ \\\r9 20\r/ \\\r15 7\r返回它的最大深度 3 。 ","date":"2015-04-14","objectID":"/leetcode/0104/:1:0","tags":null,"title":"0104：二叉树的最大深度（★）","uri":"/leetcode/0104/"},{"categories":null,"content":"分析 ","date":"2015-04-14","objectID":"/leetcode/0104/:2:0","tags":null,"title":"0104：二叉树的最大深度（★）","uri":"/leetcode/0104/"},{"categories":null,"content":"#1 层序遍历，记录有多少层即可。 def maxDepth(self, root: Optional[TreeNode]) -\u003e int: res, Q = 0, [root] if root else [] while Q: res += 1 Q = [child for node in Q for child in [node.left, node.right] if child] return res 44 ms ","date":"2015-04-14","objectID":"/leetcode/0104/:2:1","tags":null,"title":"0104：二叉树的最大深度（★）","uri":"/leetcode/0104/"},{"categories":null,"content":"#2 也可以用递归。 ","date":"2015-04-14","objectID":"/leetcode/0104/:2:2","tags":null,"title":"0104：二叉树的最大深度（★）","uri":"/leetcode/0104/"},{"categories":null,"content":"解答 def maxDepth(self, root: TreeNode) -\u003e int: return 0 if not root else max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 48 ms ","date":"2015-04-14","objectID":"/leetcode/0104/:3:0","tags":null,"title":"0104：二叉树的最大深度（★）","uri":"/leetcode/0104/"},{"categories":null,"content":"题目 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右， 再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例 1： 输入：root = [3,9,20,null,null,15,7]\r输出：[[3],[20,9],[15,7]]\r示例 2： 输入：root = [1]\r输出：[[1]]\r示例 3： 输入：root = []\r输出：[]\r提示： 树中节点数目在范围 [0, 2000] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-04-13","objectID":"/leetcode/0103/:1:0","tags":null,"title":"0103：二叉树的锯齿形层序遍历（★）","uri":"/leetcode/0103/"},{"categories":null,"content":"分析 0102 升级版，将奇数层的节点反序即可。 ","date":"2015-04-13","objectID":"/leetcode/0103/:2:0","tags":null,"title":"0103：二叉树的锯齿形层序遍历（★）","uri":"/leetcode/0103/"},{"categories":null,"content":"解答 def zigzagLevelOrder(self, root: TreeNode) -\u003e List[List[int]]: res, Q = [], [root] if root else [] while Q: A = [node.val for node in Q] res.append(A[::-1] if len(res)%2 else A) Q = [child for node in Q for child in [node.left, node.right] if child] return res 32 ms ","date":"2015-04-13","objectID":"/leetcode/0103/:3:0","tags":null,"title":"0103：二叉树的锯齿形层序遍历（★）","uri":"/leetcode/0103/"},{"categories":null,"content":"题目 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 输入：root = [3,9,20,null,null,15,7]\r输出：[[3],[9,20],[15,7]]\r示例 2： 输入：root = [1]\r输出：[[1]]\r示例 3： 输入：root = []\r输出：[]\r提示： 树中节点数目在范围 [0, 2000] 内 -1000 \u003c= Node.val \u003c= 1000 ","date":"2015-04-12","objectID":"/leetcode/0102/:1:0","tags":null,"title":"0102：二叉树的层序遍历（★）","uri":"/leetcode/0102/"},{"categories":null,"content":"分析 迭代保存每层的节点即可。 ","date":"2015-04-12","objectID":"/leetcode/0102/:2:0","tags":null,"title":"0102：二叉树的层序遍历（★）","uri":"/leetcode/0102/"},{"categories":null,"content":"解答 def levelOrder(self, root: TreeNode) -\u003e List[List[int]]: res, Q = [], [root] if root else [] while Q: res.append([node.val for node in Q]) Q = [child for node in Q for child in [node.left, node.right] if child] return res 36 ms ","date":"2015-04-12","objectID":"/leetcode/0102/:3:0","tags":null,"title":"0102：二叉树的层序遍历（★）","uri":"/leetcode/0102/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例 1： 输入：root = [1,2,2,3,4,4,3]\r输出：true\r示例 2： 输入：root = [1,2,2,null,3,null,3]\r输出：false\r提示： 树中节点数目在范围 [1, 1000] 内 -100 \u003c= Node.val \u003c= 100 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ ","date":"2015-04-11","objectID":"/leetcode/0101/:1:0","tags":null,"title":"0101：对称二叉树（★）","uri":"/leetcode/0101/"},{"categories":null,"content":"分析 ","date":"2015-04-11","objectID":"/leetcode/0101/:2:0","tags":null,"title":"0101：对称二叉树（★）","uri":"/leetcode/0101/"},{"categories":null,"content":"#1 0100 升级版，相当于判断左子树和右子树是否镜像对称。 令 dfs(p, q) 代表 p 和 q 是否镜像对称，即可递归。 def isSymmetric(self, root: Optional[TreeNode]) -\u003e bool: def dfs(p, q): if not p or not q: return not p and not q return p.val == q.val and dfs(p.left, q.right) and dfs(p.right, q.left) return dfs(root.left, root.right) 28 ms ","date":"2015-04-11","objectID":"/leetcode/0101/:2:1","tags":null,"title":"0101：对称二叉树（★）","uri":"/leetcode/0101/"},{"categories":null,"content":"#2 也可以用迭代。与 0100 类似，只是要交叉比较，入栈顺序处理下即可。 ","date":"2015-04-11","objectID":"/leetcode/0101/:2:2","tags":null,"title":"0101：对称二叉树（★）","uri":"/leetcode/0101/"},{"categories":null,"content":"解答 def isSymmetric(self, root: TreeNode) -\u003e bool: stack1, stack2 = [root], [root] while stack1: p, q = stack1.pop(), stack2.pop() if not p and not q: continue if not p or not q or p.val != q.val: return False stack1.extend([p.right, p.left]) stack2.extend([q.left, q.right]) return True 40 ms ","date":"2015-04-11","objectID":"/leetcode/0101/:3:0","tags":null,"title":"0101：对称二叉树（★）","uri":"/leetcode/0101/"},{"categories":null,"content":"题目 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1： 输入：p = [1,2,3], q = [1,2,3]\r输出：true\r示例 2： 输入：p = [1,2], q = [1,null,2]\r输出：false\r示例 3： 输入：p = [1,2,1], q = [1,1,2]\r输出：false\r提示： 两棵树上的节点数目都在范围 [0, 100] 内 -10^4 \u003c= Node.val \u003c= 10^4 ","date":"2015-04-10","objectID":"/leetcode/0100/:1:0","tags":null,"title":"0100：相同的树（★）","uri":"/leetcode/0100/"},{"categories":null,"content":"分析 ","date":"2015-04-10","objectID":"/leetcode/0100/:2:0","tags":null,"title":"0100：相同的树（★）","uri":"/leetcode/0100/"},{"categories":null,"content":"#1 显然两个二叉树相同等价于根节点、左子树、右子树都相同，容易写出递归解法。 def isSameTree(self, p: TreeNode, q: TreeNode) -\u003e bool: if not p or not q: return not p and not q return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) 28 ms ","date":"2015-04-10","objectID":"/leetcode/0100/:2:1","tags":null,"title":"0100：相同的树（★）","uri":"/leetcode/0100/"},{"categories":null,"content":"#2 也可以用迭代。 遍历一遍二叉树，如果每一步经过的节点都相同，那么两个二叉树相同。 为了方便，这里用前序遍历。 ","date":"2015-04-10","objectID":"/leetcode/0100/:2:2","tags":null,"title":"0100：相同的树（★）","uri":"/leetcode/0100/"},{"categories":null,"content":"解答 def isSameTree(self, p: TreeNode, q: TreeNode) -\u003e bool: stack1, stack2 = [p], [q] while stack1: p, q = stack1.pop(), stack2.pop() if not p and not q: continue if not p or not q or p.val != q.val: return False stack1.extend([p.right, p.left]) stack2.extend([q.right, q.left]) return True 28 ms ","date":"2015-04-10","objectID":"/leetcode/0100/:3:0","tags":null,"title":"0100：相同的树（★）","uri":"/leetcode/0100/"},{"categories":null,"content":"题目 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。 示例 1： 输入：root = [1,3,null,null,2]\r输出：[3,1,null,null,2]\r解释：3 不能是 1 左孩子，因为 3 \u003e 1 。交换 1 和 3 使二叉搜索树有效。\r示例 2： 输入：root = [3,1,4,null,null,2]\r输出：[2,1,4,null,null,3]\r解释：2 不能在 3 的右子树中，因为 2 \u003c 3 。交换 2 和 3 使二叉搜索树有效。\r提示： 树上节点的数目在范围 [2, 1000] 内 -2^31 ","date":"2015-04-09","objectID":"/leetcode/0099/:1:0","tags":null,"title":"0099：恢复二叉搜索树（★★★）","uri":"/leetcode/0099/"},{"categories":null,"content":"分析 二叉搜索树等价于其中序遍历的节点值是递增的，所以可以遍历找到两个错误的节点，然后交换。 第一个错误节点就是第一个大于后继节点的节点，第二个错误节点就是最后一个小于前面节点的节点。 ","date":"2015-04-09","objectID":"/leetcode/0099/:2:0","tags":null,"title":"0099：恢复二叉搜索树（★★★）","uri":"/leetcode/0099/"},{"categories":null,"content":"解答 def recoverTree(self, root: TreeNode) -\u003e None: stack, prev = [(root, 0)], None x, y = None, None while stack: node, flag = stack.pop() if flag: if prev and prev.val \u003e node.val: x, y = x if x else prev, node prev = node elif node: stack.extend([(node.right, 0), (node, 1), (node.left, 0)]) x.val, y","date":"2015-04-09","objectID":"/leetcode/0099/:3:0","tags":null,"title":"0099：恢复二叉搜索树（★★★）","uri":"/leetcode/0099/"},{"categories":null,"content":"*附加 要求 O(1) 空间，需要用 Morris 中序遍历 Morris 遍历减少了空间但也增加了时间，一般不用。 def recoverTree(self, root: TreeNode) -\u003e None: x, y, prev = None, None, None while root: if root.left: predecessor = root.left while predecessor.right and predecessor.right != root: predecessor = predecessor.right if not predecessor.right: p","date":"2015-04-09","objectID":"/leetcode/0099/:4:0","tags":null,"title":"0099：恢复二叉搜索树（★★★）","uri":"/leetcode/0099/"},{"categories":null,"content":"题目 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 输入：root = [2,1,3]\r输出：true\r示例 2： 输入：root = [5,1,4,null,null,3,6]\r输出：false\r解释：根节点的值是 5 ，但是右子节点的值是 4 。\r提示： 树中节点数目范围在[1, 10^4] 内 -2^31 \u003c= Node.val \u003c= 2^31 - 1 ","date":"2015-04-08","objectID":"/leetcode/0098/:1:0","tags":null,"title":"0098：验证二叉搜索树（★）","uri":"/leetcode/0098/"},{"categories":null,"content":"分析 有效的二叉搜索树等价于其中序遍历的节点值是递增的，所以中序遍历加个判断即可。 ","date":"2015-04-08","objectID":"/leetcode/0098/:2:0","tags":null,"title":"0098：验证二叉搜索树（★）","uri":"/leetcode/0098/"},{"categories":null,"content":"解答 def isValidBST(self, root: TreeNode) -\u003e bool: pre, stack = float('-inf'), [root] while stack: node = stack.pop() if isinstance(node, int): if node \u003c= pre: return False pre = node elif node: stack.extend([node.right, node.val, node.left]) return True 52 ms ","date":"2015-04-08","objectID":"/leetcode/0098/:3:0","tags":null,"title":"0098：验证二叉搜索树（★）","uri":"/leetcode/0098/"},{"categories":null,"content":"*附加 也可以用递归。 如果 node 的左子树和右子树都是二叉搜索树，且左子树的数都小于 node.val，右子树的数都大于 node.val， node 即为二叉搜索树 令 dfs(node, low, high) 代表 node 子树是否为 [low, high] 范围内的二叉搜索树，即可递归 初始无限制，所以 low/high 设为极小/大值 def isValidBST(self, root: TreeNode) -\u003e bool: def dfs(node, low, high): if not node: return True if not low\u003cnode.val\u003chigh: ","date":"2015-04-08","objectID":"/leetcode/0098/:4:0","tags":null,"title":"0098：验证二叉搜索树（★）","uri":"/leetcode/0098/"},{"categories":null,"content":"题目 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。 两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串： s = s1 + s2 + … + sn t = t1 + t2 + … + tm |n - m| \u003c= 1 交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + … 示例 1： 输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\r输出：true\r示例 2： 输入：s","date":"2015-04-07","objectID":"/leetcode/0097/:1:0","tags":null,"title":"0097：交错字符串（★★）","uri":"/leetcode/0097/"},{"categories":null,"content":"分析 典型的多串 dp，按 s3 的末尾由 s1/s2 末尾拼成，即可递归。 ","date":"2015-04-07","objectID":"/leetcode/0097/:2:0","tags":null,"title":"0097：交错字符串（★★）","uri":"/leetcode/0097/"},{"categories":null,"content":"解答 def isInterleave(self, s1: str, s2: str, s3: str) -\u003e bool: @lru_cache(None) def dfs(s1, s2, s3): if not s3: return True if s1 and s3[-1]==s1[-1] and dfs(s1[:-1], s2, s3[:-1]): return True return len(s2)\u003e0 and s3[-1]==s2[-1] and dfs(s1, s2[:-1], s3[:-1]) return len(s3) == len(s1) + len(s2) and dfs","date":"2015-04-07","objectID":"/leetcode/0097/:3:0","tags":null,"title":"0097：交错字符串（★★）","uri":"/leetcode/0097/"},{"categories":null,"content":"进入北宇治高中就读的主人公黄前久美子，在同班同学加藤叶月的热烈影响下加入了该校的吹奏部。北宇治高中吹奏部直到5年前还是关西大会的常客，并且过去还是全国大会出场过的强校代表，然而自从顾问换了之后，该吹奏部就再也没有挺进过关西大会。之后以新顾问的赴任为契机，怀揣着高远目标的部员们挥洒着奋斗的青春，过着波澜万丈的每一天。终于，比赛的日子也即将到来……","date":"2015-04-07","objectID":"/anime/hibike_euphonium/","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":"简介 进入北宇治高中就读的主人公黄前久美子，在同班同学加藤叶月的热烈影响下加入了该校的吹奏部。北宇治高中吹奏部直到5年前还是关西大会的常客，并且过去还是全国大会出场过的强校代表，然而自从顾问换了之后，该吹奏部就再也没有挺进过关西大会。之后以新顾问的赴任为契机，怀揣着高远目标的部员们挥洒着奋斗的青春，过着波澜万丈的每一天。终于，比赛的日子也即将到来…… 制作人员： 原作：武田绫乃 导演：石原立也 脚本：花田十辉 分镜：北之原孝将、河浪荣作、雪村爱、武本康弘、山村卓也 ","date":"2015-04-07","objectID":"/anime/hibike_euphonium/:1:0","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 黄前久美子 黄前 久美子、おうまえ くみこ、Oumae Kumiko 女 黒沢ともよ 2 加藤叶月 加藤葉月、かとう はづき、Katou Hazuki 女 朝井彩加 3 川岛绿辉 緑、Sapphire Kawashima、川島緑輝、かわしま さふぁいあ、Kawashima Safaia、みどり 女 豊田萌絵 4 高坂丽奈 高坂 麗奈、こうさか れいな、Kousaka Reina 女 安済知佳 5 田中明日香 たなか あすか、Tanaka Asuka 女 寿美菜子 6 小笠原晴香 おがさわら はるか、Ogasawara Haruka 女 早見沙織 7 中世古香","date":"2015-04-07","objectID":"/anime/hibike_euphonium/:2:0","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 吹响！悠风号 2015-04-07 14 bilibili 2 吹响！悠风号 第二季 2016-10-05 13 bilibili 3 莉兹与青鸟 2018-04-21 1 樱花 4 剧场版 吹响！悠风号～誓言的终章～ 2019-04-19 1 bilibili ","date":"2015-04-07","objectID":"/anime/hibike_euphonium/:3:0","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":"MAD ","date":"2015-04-07","objectID":"/anime/hibike_euphonium/:4:0","tags":null,"title":"吹响！悠风号","uri":"/anime/hibike_euphonium/"},{"categories":null,"content":"题目 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？ 返回满足题意的二叉搜索树的种数。 示例 1： 输入：n = 3\r输出：5\r示例 2： 输入：n = 1\r输出：1\r提示： 1 \u003c= n \u003c= 19 ","date":"2015-04-06","objectID":"/leetcode/0096/:1:0","tags":null,"title":"0096：不同的二叉搜索树（★★）","uri":"/leetcode/0096/"},{"categories":null,"content":"分析 按左右子树的节点数可以转为递归子问题。 显然有重复子问题，所以用动态规划。 ","date":"2015-04-06","objectID":"/leetcode/0096/:2:0","tags":null,"title":"0096：不同的二叉搜索树（★★）","uri":"/leetcode/0096/"},{"categories":null,"content":"解答 def numTrees(self, n: int) -\u003e int: dp = [1] * (n+1) for i in range(1, n+1): dp[i] = sum(dp[j]*dp[i-1-j] for j in range(i)) return dp[-1] 36 ms ","date":"2015-04-06","objectID":"/leetcode/0096/:3:0","tags":null,"title":"0096：不同的二叉搜索树（★★）","uri":"/leetcode/0096/"},{"categories":null,"content":"*附加 这个递推式得到的 dp[n] 在数学上被称为卡塔兰数，有个更简单的表达式： dp[n] = (2n)!/(n!*(n+1)!)\rdef numTrees(self, n: int) -\u003e int: res = 1 for i in range(1, n+1): res = res*(i+n)//i return res//(n+1) 32 ms ","date":"2015-04-06","objectID":"/leetcode/0096/:4:0","tags":null,"title":"0096：不同的二叉搜索树（★★）","uri":"/leetcode/0096/"},{"categories":null,"content":"题目 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。 可以按 任意顺序 返回答案。 示例 1： 输入：n = 3\r输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\r示例 2： 输入：n = 1\r输出：[[1]]\r提示： 1 \u003c= n \u003c= 8 ","date":"2015-04-05","objectID":"/leetcode/0095/:1:0","tags":null,"title":"0095：不同的二叉搜索树 II（★★）","uri":"/leetcode/0095/"},{"categories":null,"content":"分析 类似于 0096 ，不过需要生成所有实际的树。 令 dfs(i,j) 代表节点值 [i,j] 组成的不同二叉搜索树，即可递归。 ","date":"2015-04-05","objectID":"/leetcode/0095/:2:0","tags":null,"title":"0095：不同的二叉搜索树 II（★★）","uri":"/leetcode/0095/"},{"categories":null,"content":"解答 def generateTrees(self, n: int) -\u003e List[TreeNode]: def dfs(i, j): if i \u003e j: return [None] res = [] for k in range(i, j+1): for l in dfs(i, k-1): for r in dfs(k+1, j): res.append(TreeNode(k, l, r)) return res return dfs(1, n) 56 ms ","date":"2015-04-05","objectID":"/leetcode/0095/:3:0","tags":null,"title":"0095：不同的二叉搜索树 II（★★）","uri":"/leetcode/0095/"},{"categories":null,"content":"题目 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 示例 1： 输入：root = [1,null,2,3]\r输出：[1,3,2]\r示例 2： 输入：root = []\r输出：[]\r示例 3： 输入：root = [1]\r输出：[1]\r提示： 树中节点数目在范围 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 ","date":"2015-04-04","objectID":"/leetcode/0094/:1:0","tags":null,"title":"0094：二叉树的中序遍历（★）","uri":"/leetcode/0094/"},{"categories":null,"content":"分析 ","date":"2015-04-04","objectID":"/leetcode/0094/:2:0","tags":null,"title":"0094：二叉树的中序遍历（★）","uri":"/leetcode/0094/"},{"categories":null,"content":"#1 先写出递归算法，显然，将左子树的中序遍历、根节点、右子树的中序遍历拼接起来即可。 def inorderTraversal(self, root: TreeNode) -\u003e List[int]: return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else [] 40 ms ","date":"2015-04-04","objectID":"/leetcode/0094/:2:1","tags":null,"title":"0094：二叉树的中序遍历（★）","uri":"/leetcode/0094/"},{"categories":null,"content":"#2 可以借助栈改写成迭代算法。 初始栈保存根节点 每轮出栈，如果是节点，按 [右子树、节点值、左子树] 顺序入栈 如果出栈的是节点值，说明其左子树已经遍历完，将节点值添加到结果中 依此循环直到栈空即遍历完毕 ","date":"2015-04-04","objectID":"/leetcode/0094/:2:2","tags":null,"title":"0094：二叉树的中序遍历（★）","uri":"/leetcode/0094/"},{"categories":null,"content":"解答 def inorderTraversal(self, root: TreeNode) -\u003e List[int]: res, stack = [], [root] while stack: node = stack.pop() if isinstance(node, int): res.append(node) elif node: stack.extend([node.right, node.val, node.left]) return res 32 ms ","date":"2015-04-04","objectID":"/leetcode/0094/:3:0","tags":null,"title":"0094：二叉树的中序遍历（★）","uri":"/leetcode/0094/"},{"categories":null,"content":"题目 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。 例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址， 这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 示例 1： 输入：s = \"2552551","date":"2015-04-03","objectID":"/leetcode/0093/:1:0","tags":null,"title":"0093：复原IP地址（★★）","uri":"/leetcode/0093/"},{"categories":null,"content":"分析 典型的回溯问题，每步选择分割位置即可。 ","date":"2015-04-03","objectID":"/leetcode/0093/:2:0","tags":null,"title":"0093：复原IP地址（★★）","uri":"/leetcode/0093/"},{"categories":null,"content":"解答 def restoreIpAddresses(self, s: str) -\u003e List[str]: def dfs(s): if len(path) == 4: if not s: res.append('.'.join(path)) return for i in range(min(3, len(s))): if 0 \u003c= int(s[:i+1]) \u003c= 255 and not (i and s[0] == '0'): path.append(s[:i+1]) dfs(s[i+1:]) path.pop() res, path = [], [] dfs(s) return res ","date":"2015-04-03","objectID":"/leetcode/0093/:3:0","tags":null,"title":"0093：复原IP地址（★★）","uri":"/leetcode/0093/"},{"categories":null,"content":"题目 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left \u003c= right 。 请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1： 输入：head = [1,2,3,4,5], left = 2, right = 4\r输出：[1,4,3,2,5]\r示例 2： 输入：head = [5], left = 1, right = 1\r输出：[5]\r提示： 链表中节点数目为 n 1 \u003c= n \u003c= 500 -500 \u003c= Node.val \u003c= 500 1 \u003c= left \u003c= right \u003c= n ","date":"2015-04-02","objectID":"/leetcode/0092/:1:0","tags":null,"title":"0092：反转链表 II（★★）","uri":"/leetcode/0092/"},{"categories":null,"content":"分析 类似 0206 ，只不过表头从哑节点变为了第 left-1 个节点。 ","date":"2015-04-02","objectID":"/leetcode/0092/:2:0","tags":null,"title":"0092：反转链表 II（★★）","uri":"/leetcode/0092/"},{"categories":null,"content":"解答 def reverseBetween(self, head: ListNode, left: int, right: int) -\u003e ListNode: dummy = p = ListNode(next=head) for _ in range(left-1): p = p.next tail = p.next for _ in range(right-left): tmp = tail.next tail.next = tmp.next tmp.next = p.next p.next = tmp return dummy.next 40 ms ","date":"2015-04-02","objectID":"/leetcode/0092/:3:0","tags":null,"title":"0092：反转链表 II（★★）","uri":"/leetcode/0092/"},{"categories":null,"content":"题目 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： 'A' -\u003e 1\r'B' -\u003e 2\r...\r'Z' -\u003e 26\r要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，“11106” 可以映射为： “AAJF” ，将消息分组为 (1 1 10 6) “KJF” ，将消息分组为 (11 10 6) 注意，消息不能分组为 (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。 题目数据保证答案肯定是一个 32 ","date":"2015-04-01","objectID":"/leetcode/0091/:1:0","tags":null,"title":"0091：解码方法（★★）","uri":"/leetcode/0091/"},{"categories":null,"content":"分析 ","date":"2015-04-01","objectID":"/leetcode/0091/:2:0","tags":null,"title":"0091：解码方法（★★）","uri":"/leetcode/0091/"},{"categories":null,"content":"#1 典型的线性 dp 问题，令 dp[i] 代表 s[:i] 的解码总数，按 s[i-1] 和 s[i-2:i] 是否有效即可递推。 def numDecodings(self, s: str) -\u003e int: n = len(s) dp = [1]+[0]*n for i in range(1, n+1): if s[i-1]!='0': dp[i] += dp[i-1] if i\u003e=2 and 10\u003c=int(s[i-2:i])\u003c=26: dp[i] += dp[i-2] return dp[-1] 40 ms ","date":"2015-04-01","objectID":"/leetcode/0091/:2:1","tags":null,"title":"0091：解码方法（★★）","uri":"/leetcode/0091/"},{"categories":null,"content":"#2 递推过程只和前两个状态有关，可以优化为两个变量。 ","date":"2015-04-01","objectID":"/leetcode/0091/:2:2","tags":null,"title":"0091：解码方法（★★）","uri":"/leetcode/0091/"},{"categories":null,"content":"解答 def numDecodings(self, s: str) -\u003e int: a, b = 0, 1 for i in range(len(s)): a, b = b, b*(s[i]!='0')+a*(i and 10\u003c=int(s[i-1:i+1])\u003c=26) return b 40 ms ","date":"2015-04-01","objectID":"/leetcode/0091/:3:0","tags":null,"title":"0091：解码方法（★★）","uri":"/leetcode/0091/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 示例 1： 输入：nums = [1,2,2]\r输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\r示例 2： 输入：nums = [0]\r输出：[[],[0]]\r提示： 1 \u003c= nums.length \u003c= 10 -10 \u003c= nums[i] \u003c= 10 ","date":"2015-03-31","objectID":"/leetcode/0090/:1:0","tags":null,"title":"0090：子集 II（★★）","uri":"/leetcode/0090/"},{"categories":null,"content":"分析 0078 升级版，区别在于可能有重复数字，采用排序并跳过相同数字的通用方法即可。 ","date":"2015-03-31","objectID":"/leetcode/0090/:2:0","tags":null,"title":"0090：子集 II（★★）","uri":"/leetcode/0090/"},{"categories":null,"content":"解答 def subsetsWithDup(self, nums: List[int]) -\u003e List[List[int]]: def dfs(i): res.append(path[:]) for j in range(i, n): if j \u003e i and nums[j] == nums[j - 1]: continue path.append(nums[j]) dfs(j + 1) path.pop() res, path, n = [], [], len(nums) nums.sort() dfs(0) return res 28 ms ","date":"2015-03-31","objectID":"/leetcode/0090/:3:0","tags":null,"title":"0090：子集 II（★★）","uri":"/leetcode/0090/"},{"categories":null,"content":"题目 n 位格雷码序列 是一个由 2n 个整数组成的序列，其中： 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1） 第一个整数是 0 一个整数在序列中出现 不超过一次 每对 相邻 整数的二进制表示 恰好一位不同 ，且 第一个 和 最后一个 整数的二进制表示 恰好一位不同 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。 示例 1： 输入：n = 2\r输出：[0,1,3,2]\r解释：\r[0,1,3,2] 的二进制表示是 [00,01,11,10] 。\r- 00 和 01 有一位不同\r- 01 和 11 有一位不同\r- 11 和 10 有一位不同\r- 10 和 00","date":"2015-03-30","objectID":"/leetcode/0089/:1:0","tags":null,"title":"0089：格雷编码（★★）","uri":"/leetcode/0089/"},{"categories":null,"content":"分析 考虑能否递推。发现先排 0 加 n-1 位的格雷编码，再排 1 加 n-1 位的格雷编码反序即可。 ","date":"2015-03-30","objectID":"/leetcode/0089/:2:0","tags":null,"title":"0089：格雷编码（★★）","uri":"/leetcode/0089/"},{"categories":null,"content":"解答 def grayCode(self, n: int) -\u003e List[int]: res = [0] for i in range(n): res += [(1\u003c\u003ci)+x for x in res[::-1]] return res 44 ms ","date":"2015-03-30","objectID":"/leetcode/0089/:3:0","tags":null,"title":"0089：格雷编码（★★）","uri":"/leetcode/0089/"},{"categories":null,"content":"*附加 格雷码的生成有个公式，可以直接套用：第 i 个格雷码等于 i^(i»1)。 def grayCode(self, n: int) -\u003e List[int]: return [i^(i\u003e\u003e1) for i in range(1\u003c\u003cn)] 40 ms ","date":"2015-03-30","objectID":"/leetcode/0089/:4:0","tags":null,"title":"0089：格雷编码（★★）","uri":"/leetcode/0089/"},{"categories":null,"content":"题目 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ， 分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况， nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\r输出：","date":"2015-03-29","objectID":"/leetcode/0088/:1:0","tags":null,"title":"0088：合并两个有序数组（★）","uri":"/leetcode/0088/"},{"categories":null,"content":"分析 如果合并到新数组的话，遍历归并即可。 这里要求合并到 nums1 中，考虑赋值： 直接赋值可能会覆盖 nums1 的元素，丢失信息 有个巧妙的想法是倒序遍历，从大到小归并，就不会覆盖了 ","date":"2015-03-29","objectID":"/leetcode/0088/:2:0","tags":null,"title":"0088：合并两个有序数组（★）","uri":"/leetcode/0088/"},{"categories":null,"content":"解答 def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -\u003e None: i, j, k = m-1, n-1, m+n-1 while j \u003e= 0 and k \u003e= 0: if i \u003c 0 or nums1[i] \u003c= nums2[j]: nums1[k] = nums2[j] j -= 1 else: nums1[k] = nums1[i] i -= 1 k -= 1 32 ms ","date":"2015-03-29","objectID":"/leetcode/0088/:3:0","tags":null,"title":"0088：合并两个有序数组（★）","uri":"/leetcode/0088/"},{"categories":null,"content":"题目 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ： 如果字符串的长度为 1 ，算法停止 如果字符串的长度 \u003e 1 ，执行下述步骤： 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ， 则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。 随机决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。 即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。 在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的","date":"2015-03-28","objectID":"/leetcode/0087/:1:0","tags":null,"title":"0087：扰乱字符串（★★）","uri":"/leetcode/0087/"},{"categories":null,"content":"分析 假设 s2 是 s1 的扰乱字符串，对应的 s1 的第一个分割点在位置 i，那么有两种情况： 分割的两部分没有交换：s2[:i] 是 s1[:i] 的扰乱字符串，s2[i:] 是 s1[i:] 的扰乱字符串 分割开的两部分交换了：s2[-i:] 是 s1[:i] 的扰乱字符串，s2[:-i] 是 s1[i:] 的扰乱字符串 都可以转为递归子问题。显然有重复子问题，所以用记忆化递归。 ","date":"2015-03-28","objectID":"/leetcode/0087/:2:0","tags":null,"title":"0087：扰乱字符串（★★）","uri":"/leetcode/0087/"},{"categories":null,"content":"解答 def isScramble(self, s1: str, s2: str) -\u003e bool: @lru_cache(None) def dfs(s1, s2): if s1 == s2: return True if Counter(s1) != Counter(s2): return False for i in range(1, len(s1)): if dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:]): return True if dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i]): return T","date":"2015-03-28","objectID":"/leetcode/0087/:3:0","tags":null,"title":"0087：扰乱字符串（★★）","uri":"/leetcode/0087/"},{"categories":null,"content":"题目 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔， 使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 示例 1： 输入：head = [1,4,3,2,5,2], x = 3\r输出：[1,2,2,4,3,5]\r示例 2： 输入：head = [2,1], x = 2\r输出：[1,2]\r提示： 链表中节点的数目在范围 [0, 200] 内 -100 \u003c= Node.val \u003c= 100 -200 \u003c= x \u003c= 200 ","date":"2015-03-27","objectID":"/leetcode/0086/:1:0","tags":null,"title":"0086：分隔链表（★）","uri":"/leetcode/0086/"},{"categories":null,"content":"分析 遇到大于等于 x 的节点就先提出来，并按顺序链接，最后再跟到原链表的末尾即可。 ","date":"2015-03-27","objectID":"/leetcode/0086/:2:0","tags":null,"title":"0086：分隔链表（★）","uri":"/leetcode/0086/"},{"categories":null,"content":"解答 def partition(self, head: ListNode, x: int) -\u003e ListNode: dummy1 = p = ListNode(next=head) dummy2 = q = ListNode() while p.next: if p.next.val \u003e= x: q.next = p.next p.next = p.next.next q = q.next else: p = p.next q.next = None p.next = dummy2.next return dummy1.next 40 ms ","date":"2015-03-27","objectID":"/leetcode/0086/:3:0","tags":null,"title":"0086：分隔链表（★）","uri":"/leetcode/0086/"},{"categories":null,"content":"题目 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形， 并返回其面积。 示例 1： 输入：matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],\r[\"1\",\"0\",\"0\",\"1\",\"0\"]]\r输出：6\r解释：最大矩形如上图所示。\r示例 2： 输入：matrix = []\r输出：0\r示例 3： 输入：matrix = [[\"0\"]]\r输出：0\r示例 4： 输入：matrix = [[\"1\"]]\r输出：1\r示例 5： 输入：matrix = ","date":"2015-03-26","objectID":"/leetcode/0085/:1:0","tags":null,"title":"0085：最大矩形（★★★）","uri":"/leetcode/0085/"},{"categories":null,"content":"分析 固定矩形的底在第 i 行，求出每列的高度 H[i][j]，即转为问题 0084。 注意 H[i][j] 可以由 H[i-1][j] 递推得到，故总的时间复杂度 O(M*N)。 ","date":"2015-03-26","objectID":"/leetcode/0085/:2:0","tags":null,"title":"0085：最大矩形（★★★）","uri":"/leetcode/0085/"},{"categories":null,"content":"解答 def maximalRectangle(self, matrix: List[List[str]]) -\u003e int: def cal(H): res, stack = 0, [] for j, y in enumerate(H+[0]): while stack and stack[-1][1] \u003e= y: i, x = stack.pop() left = stack[-1][0] if stack else -1 res = max(res, x*(j-left-1)) stack.append((j, y)) return res m, n = len(matrix), len(","date":"2015-03-26","objectID":"/leetcode/0085/:3:0","tags":null,"title":"0085：最大矩形（★★★）","uri":"/leetcode/0085/"},{"categories":null,"content":"题目 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例 1: 输入：heights = [2,1,5,6,2,3]\r输出：10\r解释：最大的矩形为图中红色区域，面积为 10\r示例 2： 输入： heights = [2,4]\r输出： 4\r提示： 1 \u003c= heights.length \u003c=10^5 0 \u003c= heights[i] \u003c= 10^4 ","date":"2015-03-25","objectID":"/leetcode/0084/:1:0","tags":null,"title":"0084：柱状图中最大的矩形（★★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"分析 ","date":"2015-03-25","objectID":"/leetcode/0084/:2:0","tags":null,"title":"0084：柱状图中最大的矩形（★★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"#1 直接遍历矩形的底会超时，有个巧妙的想法是遍历矩形的高，因为最大矩形的高度必然是某个柱子的高度。 遍历每根柱子作为高，找左右能延伸的最大宽度即可，即找左右第一根更矮的柱子。 找每个位置的上/下一个更小元素，容易想到单调栈。 def largestRectangleArea(self, heights: List[int]) -\u003e int: n = len(heights) left, stack = [-1] * n, [] for i in range(n): while stack and heights[stack[-1]] \u003e= heights[i]: stack.pop() le","date":"2015-03-25","objectID":"/leetcode/0084/:2:1","tags":null,"title":"0084：柱状图中最大的矩形（★★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"#2 其实可以一趟解决： 令栈中严格递增 遍历到位置 j 且出栈位置 i 时，i 的上一个更小元素即为 stack[-1] 如果 heights[i]\u003eheights[j]，i 的下一个更小元素即为 j，即得到 i 对应的最大宽度 如果 heights[i]==heights[j]，i 和 j 对应的最大宽度相同，可以留给 j 来计算 注意最后栈中可能还有剩余元素，需要遍历计算。一个更简单的做法是在 heights 末尾加一个极小值，让所有元素都出栈。 ","date":"2015-03-25","objectID":"/leetcode/0084/:2:2","tags":null,"title":"0084：柱状图中最大的矩形（★★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"解答 def largestRectangleArea(self, heights: List[int]) -\u003e int: res, stack = 0, [] for j, y in enumerate(heights+[0]): while stack and stack[-1][1] \u003e= y: i, x = stack.pop() left = stack[-1][0] if stack else -1 res = max(res, x*(j-left-1)) stack.append((j, y)) return res 308 ms ","date":"2015-03-25","objectID":"/leetcode/0084/:3:0","tags":null,"title":"0084：柱状图中最大的矩形（★★★）","uri":"/leetcode/0084/"},{"categories":null,"content":"题目 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例 1： 输入：head = [1,1,2]\r输出：[1,2]\r示例 2： 输入：head = [1,1,2,3,3]\r输出：[1,2,3]\r提示： 链表中节点数目在范围 [0, 300] 内 -100 \u003c= Node.val \u003c= 100 题目数据保证链表已经按升序排列 ","date":"2015-03-24","objectID":"/leetcode/0083/:1:0","tags":null,"title":"0083：删除排序链表中的重复元素","uri":"/leetcode/0083/"},{"categories":null,"content":"分析 遇到相邻的数相等时跳过即可。 ","date":"2015-03-24","objectID":"/leetcode/0083/:2:0","tags":null,"title":"0083：删除排序链表中的重复元素","uri":"/leetcode/0083/"},{"categories":null,"content":"解答 def deleteDuplicates(self, head: ListNode) -\u003e ListNode: p = head while p and p.next: if p.val == p.next.val: p.next = p.next.next else: p = p.next return head 44 ms ","date":"2015-03-24","objectID":"/leetcode/0083/:3:0","tags":null,"title":"0083：删除排序链表中的重复元素","uri":"/leetcode/0083/"},{"categories":null,"content":"题目 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。 示例 1： 输入：head = [1,2,3,3,4,4,5]\r输出：[1,2,5]\r示例 2： 输入：head = [1,1,1,2,3]\r输出：[2,3]\r提示： 链表中节点数目在范围 [0, 300] 内 -100 \u003c= Node.val \u003c= 100 题目数据保证链表已经按升序 排列 ","date":"2015-03-23","objectID":"/leetcode/0082/:1:0","tags":null,"title":"0082：删除排序链表中的重复元素 II（★）","uri":"/leetcode/0082/"},{"categories":null,"content":"分析 0083 进阶版，当后面两个节点的值相等时，跳过所有等于该值的节点即可。 表头可能也要跳过，因此新建个哑结点。 ","date":"2015-03-23","objectID":"/leetcode/0082/:2:0","tags":null,"title":"0082：删除排序链表中的重复元素 II（★）","uri":"/leetcode/0082/"},{"categories":null,"content":"解答 def deleteDuplicates(self, head: ListNode) -\u003e ListNode: dummy = p = ListNode(next=head) while p.next and p.next.next: if p.next.val == p.next.next.val: val = p.next.val p.next = p.next.next.next while p.next and p.next.val == val: p.next = p.next.next else: p = p.next return dummy.next 36 ms ","date":"2015-03-23","objectID":"/leetcode/0082/:3:0","tags":null,"title":"0082：删除排序链表中的重复元素 II（★）","uri":"/leetcode/0082/"},{"categories":null,"content":"题目 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u003c= k \u003c nums.length）上进行了 旋转 ， 使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] （下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是","date":"2015-03-22","objectID":"/leetcode/0081/:1:0","tags":null,"title":"0081：搜索旋转排序数组 II（★★）","uri":"/leetcode/0081/"},{"categories":null,"content":"分析 由 0154 可以找到分割位置 x，然后在 nums[:x]，nums[x:] 中分别 二分查找 target 即可。 ","date":"2015-03-22","objectID":"/leetcode/0081/:2:0","tags":null,"title":"0081：搜索旋转排序数组 II（★★）","uri":"/leetcode/0081/"},{"categories":null,"content":"解答 def search(self, nums: List[int], target: int) -\u003e bool: while len(nums) \u003e 1 and nums[-1] == nums[0]: nums.pop() n = len(nums) self.__class__.__getitem__ = lambda self, x: nums[x] \u003c= nums[-1] x = bisect_left(self, True, 0, n - 1) i = bisect_left(nums, target, 0, x - 1) if x else 0 j = bisect_left(","date":"2015-03-22","objectID":"/leetcode/0081/:3:0","tags":null,"title":"0081：搜索旋转排序数组 II（★★）","uri":"/leetcode/0081/"},{"categories":null,"content":"题目 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1： 输入：nums = [1,1,1,2,2,3]\r输出：5, nums = [1,1,2,2,3]\r解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。\r示例 2： 输入：nums = [0,0,1,1,1,1,2,3,3]\r输出：7, nums = [0,0,1,1,2","date":"2015-03-21","objectID":"/leetcode/0080/:1:0","tags":null,"title":"0080：删除排序数组中的重复项 II（★）","uri":"/leetcode/0080/"},{"categories":null,"content":"分析 类似 0026，只是元素最多出现次数从一次变成两次。 ","date":"2015-03-21","objectID":"/leetcode/0080/:2:0","tags":null,"title":"0080：删除排序数组中的重复项 II（★）","uri":"/leetcode/0080/"},{"categories":null,"content":"解答 def removeDuplicates(self, nums: List[int]) -\u003e int: i = 0 for num in nums: if i \u003c 2 or num != nums[i-2]: nums[i] = num i += 1 return i 40 ms ","date":"2015-03-21","objectID":"/leetcode/0080/:3:0","tags":null,"title":"0080：删除排序数组中的重复项 II（★）","uri":"/leetcode/0080/"},{"categories":null,"content":"题目 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。 如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。 同一个单元格内的字母不允许被重复使用。 示例 1： 输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\r输出：true\r示例 2： 输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\"","date":"2015-03-20","objectID":"/leetcode/0079/:1:0","tags":null,"title":"0079：单词搜索（★★）","uri":"/leetcode/0079/"},{"categories":null,"content":"分析 典型的回溯法，依次找单词的每个字符即可。 ","date":"2015-03-20","objectID":"/leetcode/0079/:2:0","tags":null,"title":"0079：单词搜索（★★）","uri":"/leetcode/0079/"},{"categories":null,"content":"解答 def exist(self, board: List[List[str]], word: str) -\u003e bool: def dfs(k, i, j): if k==len(word): return True A = product(range(m),range(n)) if k==0 else [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] for x, y in A: if 0 \u003c=x\u003cm and 0\u003c=y\u003cn and board[x][y]==word[k]: c = board[x][y] board[x][y] = '0' if dfs(k+1, x, ","date":"2015-03-20","objectID":"/leetcode/0079/:3:0","tags":null,"title":"0079：单词搜索（★★）","uri":"/leetcode/0079/"},{"categories":null,"content":"*附加 针对本题有个优化： 当 word 某个字符数大于 board，显然不可能，可以直接返回 False 这种优化只适用于特定的测试用例，属于 trick，一般不需要 def exist(self, board: List[List[str]], word: str) -\u003e bool: def dfs(k, i, j): if k==len(word): return True A = product(range(m),range(n)) if k==0 else [(i+1,j),(i,j+1),(i-1,j),(i,j-1)] for x, y in A: if 0 \u003c=x\u003cm and ","date":"2015-03-20","objectID":"/leetcode/0079/:4:0","tags":null,"title":"0079：单词搜索（★★）","uri":"/leetcode/0079/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 输入：nums = [1,2,3]\r输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\r示例 2： 输入：nums = [0]\r输出：[[],[0]]\r提示： 1 \u003c= nums.length \u003c= 10 -10 \u003c= nums[i] \u003c= 10 nums 中的所有元素 互不相同 ","date":"2015-03-19","objectID":"/leetcode/0078/:1:0","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"分析 ","date":"2015-03-19","objectID":"/leetcode/0078/:2:0","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"#1 典型的回溯问题，遍历时有取或不取两种选择。 def subsets(self, nums: List[int]) -\u003e List[List[int]]: def dfs(i): res.append(path[:]) for j in range(i, n): path.append(nums[j]) dfs(j+1) path.pop() res, path, n = [], [], len(nums) dfs(0) return res 32 ms ","date":"2015-03-19","objectID":"/leetcode/0078/:2:1","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"#2 实际应用中常用递推式的写法。 令 dp[i] 代表 nums[:i] 的所有子集，则： dp[i] = dp[i-1]+[sub+[nums[i]] for sub in dp[i-1]]\r","date":"2015-03-19","objectID":"/leetcode/0078/:2:2","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"解答 def subsets(self, nums: List[int]) -\u003e List[List[int]]: res = [[]] for x in nums: res += [sub+[x] for sub in res] return res 40 ms ","date":"2015-03-19","objectID":"/leetcode/0078/:3:0","tags":null,"title":"0078：子集（★）","uri":"/leetcode/0078/"},{"categories":null,"content":"题目 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 示例 1： 输入：n = 4, k = 2\r输出：\r[\r[2,4],\r[3,4],\r[2,3],\r[1,2],\r[1,3],\r[1,4],\r]\r示例 2： 输入：n = 1, k = 1\r输出：[[1]]\r提示： 1 \u003c= n \u003c= 20 1 \u003c= k \u003c= n ","date":"2015-03-18","objectID":"/leetcode/0077/:1:0","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"分析 ","date":"2015-03-18","objectID":"/leetcode/0077/:2:0","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"#1 可以直接调库。 def combine(self, n: int, k: int) -\u003e List[List[int]]: return list(combinations(range(1, n+1), k)) 44 ms ","date":"2015-03-18","objectID":"/leetcode/0077/:2:1","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"#2 0078 升级版，添加了个数的限制。 ","date":"2015-03-18","objectID":"/leetcode/0077/:2:2","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"解答 def combine(self, n: int, k: int) -\u003e List[List[int]]: def dfs(i): if n + 1 - i + len(path) \u003c k: return if len(path) == k: res.append(path[:]) return for j in range(i, n + 1): path.append(j) dfs(j+1) path.pop() res, path = [], [] dfs(1) return res 44 ms ","date":"2015-03-18","objectID":"/leetcode/0077/:3:0","tags":null,"title":"0077：组合（★）","uri":"/leetcode/0077/"},{"categories":null,"content":"题目 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 输入：s = \"ADOBECODEBANC\", t = \"ABC\"\r输出：\"BANC\"\r示例 2： 输入：s = \"a\", t = \"a\"\r输出：\"a\"\r示例 3: 输入: s = \"a\", t = \"aa\"\r输出: \"\"\r解释: t 中两个字符 'a' 均应包含在 s 的子串中，","date":"2015-03-17","objectID":"/leetcode/0076/:1:0","tags":null,"title":"0076：最小覆盖子串（★★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"分析 ","date":"2015-03-17","objectID":"/leetcode/0076/:2:0","tags":null,"title":"0076：最小覆盖子串（★★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"#1 0209 升级版，遍历每个位置 j 作为结尾，找符合条件的最短子串 [i, j] 即可。 发现遍历中 i 必然是不动或向右移的，因此是滑动窗口，可以用 Counter 来判断是否符合。 def minWindow(self, s: str, t: str) -\u003e str: ct, ct2 = Counter(t), Counter() res, i = s+' ', 0 for j, char in enumerate(s): ct2[char] += 1 while not ct-ct2: res = res if len(res)\u003c=(j-i+1) else s[i:j+1] ct2","date":"2015-03-17","objectID":"/leetcode/0076/:2:1","tags":null,"title":"0076：最小覆盖子串（★★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"#2 显然每次用 ct-ct2 来判断是否符合比较耗时。 有个巧妙的方法是新加一个变量 valid 维护有用字符的个数。 移动 j 时，如果 ct2[s[j]] \u003c ct[s[j]]，s[j] 就是有用的，cnt 增 1 移动 i 时，如果 ct2[s[i]] \u003e ct[s[i]]，s[i] 就是无用的，可以移动 ","date":"2015-03-17","objectID":"/leetcode/0076/:2:2","tags":null,"title":"0076：最小覆盖子串（★★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"解答 def minWindow(self, s: str, t: str) -\u003e str: ct, ct2 = Counter(t), Counter() res, i, valid = s+' ', 0, 0 for j, char in enumerate(s): if ct2[char] \u003c ct[char]: valid += 1 ct2[char] += 1 if valid == len(t): while ct2[s[i]]\u003ect[s[i]]: ct2[s[i]] -= 1 i += 1 res = res if len(res)\u003c=(j-i+1) else s[i:j+1] ","date":"2015-03-17","objectID":"/leetcode/0076/:3:0","tags":null,"title":"0076：最小覆盖子串（★★★）","uri":"/leetcode/0076/"},{"categories":null,"content":"题目 给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序， 使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 必须在不使用库的sort函数的情况下解决这个问题。 示例 1： 输入：nums = [2,0,2,1,1,0]\r输出：[0,0,1,1,2,2]\r示例 2： 输入：nums = [2,0,1]\r输出：[0,1,2]\r提示： n == nums.length 1 \u003c= n \u003c= 300 nums[i] 为 0、1 或 2 ","date":"2015-03-16","objectID":"/leetcode/0075/:1:0","tags":null,"title":"0075：颜色分类（★★）","uri":"/leetcode/0075/"},{"categories":null,"content":"分析 ","date":"2015-03-16","objectID":"/leetcode/0075/:2:0","tags":null,"title":"0075：颜色分类（★★）","uri":"/leetcode/0075/"},{"categories":null,"content":"#1 最简单的就是直接排序。 def sortColors(self, nums: List[int]) -\u003e None: nums.sort() 时间复杂度 O(N*log N)，36 ms ","date":"2015-03-16","objectID":"/leetcode/0075/:2:1","tags":null,"title":"0075：颜色分类（★★）","uri":"/leetcode/0075/"},{"categories":null,"content":"#2 题目要求 O(1) 空间，只能考虑交换或赋值了。 有个巧妙的想法是将所有 0 放到头部，所有 2 放到尾部，剩下部分即为 1 本题不能直接赋值，可能会覆盖掉有用信息，所以考虑交换 特别注意，如果交换过来还是 0 或 2，应该循环操作 ","date":"2015-03-16","objectID":"/leetcode/0075/:2:2","tags":null,"title":"0075：颜色分类（★★）","uri":"/leetcode/0075/"},{"categories":null,"content":"解答 def sortColors(self, nums: List[int]) -\u003e None: i, l, r = 0, 0, len(nums)-1 while i \u003c= r: if nums[i] == 0 and i \u003e l: nums[l], nums[i] = nums[i], nums[l] l += 1 elif nums[i] == 2 and i \u003c r: nums[i], nums[r] = nums[r], nums[i] r -= 1 else: i += 1 时间复杂度 O(N)，28 ms ","date":"2015-03-16","objectID":"/leetcode/0075/:3:0","tags":null,"title":"0075：颜色分类（★★）","uri":"/leetcode/0075/"},{"categories":null,"content":"题目 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1： 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\r输出：true\r示例 2： 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\r输出：false\r提示： m == matrix.length n == matrix[i].length 1 \u003c= m, n \u003c","date":"2015-03-15","objectID":"/leetcode/0074/:1:0","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"分析 ","date":"2015-03-15","objectID":"/leetcode/0074/:2:0","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"#1 可以先二分查找定位是哪一行，再在该行中二分查找。 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: i = bisect_right(matrix, target, 1, key=lambda x: x[0])-1 j = bisect_right(matrix[i], target, 1)-1 return matrix[i][j]==target 时间复杂度 O(log(M*N))，40 ms ","date":"2015-03-15","objectID":"/leetcode/0074/:2:1","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"#2 也可以将 matrix 看作一维升序数组，进行二分查找。注意下标的转换即可。 ","date":"2015-03-15","objectID":"/leetcode/0074/:2:2","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"解答 def searchMatrix(self, matrix: List[List[int]], target: int) -\u003e bool: m, n = len(matrix), len(matrix[0]) x = bisect_left(range(m*n-1), target, key=lambda x: matrix[x//n][x%n]) return matrix[x//n][x%n] == target 时间复杂度 O(log(M*N))，40 ms ","date":"2015-03-15","objectID":"/leetcode/0074/:3:0","tags":null,"title":"0074：搜索二维矩阵（★）","uri":"/leetcode/0074/"},{"categories":null,"content":"题目 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。 示例 1： 输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]\r输出：[[1,0,1],[0,0,0],[1,0,1]]\r示例 2： 输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\r输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\r提示： m == matrix.length n == matrix[0].length 1 \u003c= m, n \u003c= 200 -2^31 \u003c= matrix[i][j","date":"2015-03-14","objectID":"/leetcode/0073/:1:0","tags":null,"title":"0073：矩阵置零（★★）","uri":"/leetcode/0073/"},{"categories":null,"content":"分析 ","date":"2015-03-14","objectID":"/leetcode/0073/:2:0","tags":null,"title":"0073：矩阵置零（★★）","uri":"/leetcode/0073/"},{"categories":null,"content":"#1 可以先遍历一趟记录有 0 的行和列，再遍历一趟将符合的元素置 0 即可。 def setZeroes(self, matrix: List[List[int]]) -\u003e None: row, col, m, n = set(), set(), len(matrix), len(matrix[0]) for i, j in product(range(m), range(n)): if matrix[i][j] == 0: row.add(i) col.add(j) for i, j in product(range(m), range(n)): if i in row or j in c","date":"2015-03-14","objectID":"/leetcode/0073/:2:1","tags":null,"title":"0073：矩阵置零（★★）","uri":"/leetcode/0073/"},{"categories":null,"content":"#2 要求只用常数空间，所以考虑用矩阵内的元素来标记： 为了方便，直接把行首和列首变为 0 来作为标记 第二趟遍历时先根据首行和首列的信息改变其它位置的元素，最后再改变首行和首列。 注意首行和首列的标记位都是 matrix[0][0]，冲突了，所以添加一个额外参数来标记首行 ","date":"2015-03-14","objectID":"/leetcode/0073/:2:2","tags":null,"title":"0073：矩阵置零（★★）","uri":"/leetcode/0073/"},{"categories":null,"content":"解答 def setZeroes(self, matrix: List[List[int]]) -\u003e None: m, n, first_row = len(matrix), len(matrix[0]), False for i, j in product(range(m), range(n)): if matrix[i][j] == 0: if i == 0: first_row = True else: matrix[i][0] = matrix[0][j] = 0 for i, j in product(range(1, m), range(1, n)): if matrix[i][0","date":"2015-03-14","objectID":"/leetcode/0073/:3:0","tags":null,"title":"0073：矩阵置零（★★）","uri":"/leetcode/0073/"},{"categories":null,"content":"题目 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 输入：word1 = \"horse\", word2 = \"ros\"\r输出：3\r解释：\rhorse -\u003e rorse (将 'h' 替换为 'r')\rrorse -\u003e rose (删除 'r')\rrose -\u003e ros (删除 'e')\r示例 2： 输入：word1 = \"intention\", word2 = \"execution\"\r输出：5\r解释：\rintention -\u003e inenti","date":"2015-03-13","objectID":"/leetcode/0072/:1:0","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"分析 ","date":"2015-03-13","objectID":"/leetcode/0072/:2:0","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"#1 典型的双串 dp，令 dp[i][j] 表示 word1[:i] 和 word2[:j] 的编辑距离，即可递推。 def minDistance(self, word1: str, word2: str) -\u003e int: m, n = len(word1), len(word2) dp = [[0]*(n+1) for _ in range(m+1)] for i in range(m+1): for j in range(n+1): if i==0 or j==0: dp[i][j] = i+j elif word1[i-1] == word2[j-1]: dp[i][j] = dp[","date":"2015-03-13","objectID":"/leetcode/0072/:2:1","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"#2 可以用滚动数组优化空间。 ","date":"2015-03-13","objectID":"/leetcode/0072/:2:2","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"解答 def minDistance(self, word1: str, word2: str) -\u003e int: m, n = len(word1), len(word2) dp = list(range(n+1)) for i in range(1, m+1): prev = dp[:] dp[0] = i for j in range(1, n+1): if word1[i-1] == word2[j-1]: dp[j] = prev[j-1] else: dp[j] = 1+ min(dp[j-1], prev[j], prev[j-1]) return dp[-1] 112 ms ","date":"2015-03-13","objectID":"/leetcode/0072/:3:0","tags":null,"title":"0072：编辑距离（★★）","uri":"/leetcode/0072/"},{"categories":null,"content":"题目 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/’ 开头）， 请你将其转化为更加简洁的规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到 上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’//’）都被 视为单个斜杠 ‘/’ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件/目录名称。 请注意，返回的 规范路径 必须遵循下述格式： 始终以斜杠 ‘/’ 开头。 两个目录名之间必须只有一个斜杠 ‘/’ 。 最后一个目录名（如果存在）不能 以 ‘","date":"2015-03-12","objectID":"/leetcode/0071/:1:0","tags":null,"title":"0071：简化路径（★）","uri":"/leetcode/0071/"},{"categories":null,"content":"分析 典型的栈应用。遍历 ‘/’ 隔开的元素，遇到目录名入栈，遇到 ‘..’ 出栈即可。 ","date":"2015-03-12","objectID":"/leetcode/0071/:2:0","tags":null,"title":"0071：简化路径（★）","uri":"/leetcode/0071/"},{"categories":null,"content":"解答 def simplifyPath(self, path: str) -\u003e str: stack = [] for word in path.split('/'): if word == '..' and stack: stack.pop() elif word not in ['..', '.', '']: stack.append(word) return '/' + '/'.join(stack) 28 ms ","date":"2015-03-12","objectID":"/leetcode/0071/:3:0","tags":null,"title":"0071：简化路径（★）","uri":"/leetcode/0071/"},{"categories":null,"content":"题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 提示： 1 \u003c= n \u003c= 45 ","date":"2015-03-11","objectID":"/leetcode/0070/:1:0","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"分析 ","date":"2015-03-11","objectID":"/leetcode/0070/:2:0","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"#1 很经典的递归问题，最后必然爬 1 或 2 个台阶，转为递归子问题。 显然有很多重复子问题，用动态规划。 def climbStairs(self, n: int) -\u003e int: dp = [1]*(n+1) for i in range(2, n+1): dp[i] = dp[i-1]+dp[i-2] return dp[-1] 40 ms ","date":"2015-03-11","objectID":"/leetcode/0070/:2:1","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"#2 dp[i] 只依赖 dp[i-1] 和 dp[i-2] ，可以优化为两个变量。 ","date":"2015-03-11","objectID":"/leetcode/0070/:2:2","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"解答 def climbStairs(self, n: int) -\u003e int: a, b = 1, 1 for _ in range(n-1): a, b = b, a+b return b 32 ms ","date":"2015-03-11","objectID":"/leetcode/0070/:3:0","tags":null,"title":"0070：爬楼梯","uri":"/leetcode/0070/"},{"categories":null,"content":"题目 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 示例 1： 输入：x = 4\r输出：2\r示例 2： 输入：x = 8\r输出：2\r解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\r提示： 0 \u003c= x \u003c= 2^31 - 1 ","date":"2015-03-10","objectID":"/leetcode/0069/:1:0","tags":null,"title":"0069：x 的平方根（★）","uri":"/leetcode/0069/"},{"categories":null,"content":"分析 ","date":"2015-03-10","objectID":"/leetcode/0069/:2:0","tags":null,"title":"0069：x 的平方根（★）","uri":"/leetcode/0069/"},{"categories":null,"content":"#1 就是求满足 y * y \u003c= x 的最大整数 y 。y * y 单调递增，因此可以用二分查找。 python 中借助 bisect 和魔法方法可以节省代码。 def mySqrt(self, x: int) -\u003e int: self.__class__.__getitem__ = lambda self, i: i*i \u003e x return bisect_left(self, True, 0, x+1) - 1 36 ms ","date":"2015-03-10","objectID":"/leetcode/0069/:2:1","tags":null,"title":"0069：x 的平方根（★）","uri":"/leetcode/0069/"},{"categories":null,"content":"#2 本题还可以用牛顿迭代法，对于初始较大的 n，迭代 $n=(n+x/n)/2$ 可以不断逼近 $\\sqrt x$。 注意若 n \u003e $\\sqrt x$，迭代后的 n 依然成立。所以对迭代后的 n 取整若得到 n’\u003c=$\\sqrt x$，n’ 即是所求。 ","date":"2015-03-10","objectID":"/leetcode/0069/:2:2","tags":null,"title":"0069：x 的平方根（★）","uri":"/leetcode/0069/"},{"categories":null,"content":"解答 def mySqrt(self, x: int) -\u003e int: n = x while n * n \u003e x: n = (n + x // n) // 2 return n 44 ms ","date":"2015-03-10","objectID":"/leetcode/0069/:3:0","tags":null,"title":"0069：x 的平方根（★）","uri":"/leetcode/0069/"},{"categories":null,"content":"题目 给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符， 且左右两端对齐的文本。 你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ’ ’ 填充， 使得每行恰好有 maxWidth 个字符。 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。 文本的最后一行应为左对齐，且单词之间不插入额外的空格。 注意: 单词是指由非空格字符组成的字符序列。 每个单词的长度大于 0，小于等于 maxWidth。 输入单词数组 wor","date":"2015-03-09","objectID":"/leetcode/0068/:1:0","tags":null,"title":"0068：文本左右对齐（★★）","uri":"/leetcode/0068/"},{"categories":null,"content":"分析 遍历单词放到第一行中，放不下了就调整第一行的空格分配，然后放到下一行。 具体分配空格时： 先得到空格总数 total 和单词数 n 求得平均空格数 q 和余数 r 前 r 个间隔分 q+1 个空格，后面的分 q 个空格即可 注意 n==1 和最后一行的特殊情况，在后面补空格即可 ","date":"2015-03-09","objectID":"/leetcode/0068/:2:0","tags":null,"title":"0068：文本左右对齐（★★）","uri":"/leetcode/0068/"},{"categories":null,"content":"解答 def fullJustify(self, words: List[str], maxWidth: int) -\u003e List[str]: res, row, s = [], [], 0 for word in words: if s + len(row) + len(word) \u003e maxWidth: if len(row) == 1: res.append(row[0].ljust(maxWidth)) else: q, r = divmod(maxWidth-s, len(row)-1) res.append(''.join(row[i]+' '*(q+(i\u003cr)) for i in","date":"2015-03-09","objectID":"/leetcode/0068/:3:0","tags":null,"title":"0068：文本左右对齐（★★）","uri":"/leetcode/0068/"},{"categories":null,"content":"题目 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = \"11\", b = \"1\"\r输出: \"100\"\r示例 2: 输入: a = \"1010\", b = \"1011\"\r输出: \"10101\"\r提示： 每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。 1 \u003c= a.length, b.length \u003c= 10^4 字符串如果不是 “0” ，就都不含前导零。 ","date":"2015-03-08","objectID":"/leetcode/0067/:1:0","tags":null,"title":"0067：二进制求和","uri":"/leetcode/0067/"},{"categories":null,"content":"分析 ","date":"2015-03-08","objectID":"/leetcode/0067/:2:0","tags":null,"title":"0067：二进制求和","uri":"/leetcode/0067/"},{"categories":null,"content":"#1 可以直接调库。 def addBinary(self, a: str, b: str) -\u003e str: return bin(int(a, 2)+int(b, 2))[2:] 40 ms ","date":"2015-03-08","objectID":"/leetcode/0067/:2:1","tags":null,"title":"0067：二进制求和","uri":"/leetcode/0067/"},{"categories":null,"content":"#2 也可以模拟进位加法，将除数换成 2 即可。 def addBinary(self, a: str, b: str) -\u003e str: res, carry, i, j = '', 0, len(a)-1, len(b)-1 while i\u003e=0 or j\u003e=0 or carry: x = int(a[i]) if i\u003e=0 else 0 y = int(b[j]) if j\u003e=0 else 0 s = x+y+carry res += str(s%2) carry = s//2 i -= 1 j -= 1 return res[::-1] 36 ms ","date":"2015-03-08","objectID":"/leetcode/0067/:2:2","tags":null,"title":"0067：二进制求和","uri":"/leetcode/0067/"},{"categories":null,"content":"题目 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1： 输入：digits = [1,2,3]\r输出：[1,2,4]\r解释：输入数组表示数字 123。\r示例 2： 输入：digits = [4,3,2,1]\r输出：[4,3,2,2]\r解释：输入数组表示数字 4321。\r示例 3： 输入：digits = [0]\r输出：[1]\r提示： 1 \u003c= digits.length \u003c= 100 0 \u003c= digits[i] \u003c= 9 ","date":"2015-03-07","objectID":"/leetcode/0066/:1:0","tags":null,"title":"0066：加一","uri":"/leetcode/0066/"},{"categories":null,"content":"分析 模拟进位加法即可，若最终还有进位，需要再加一位。 ","date":"2015-03-07","objectID":"/leetcode/0066/:2:0","tags":null,"title":"0066：加一","uri":"/leetcode/0066/"},{"categories":null,"content":"解答 def plusOne(self, digits: List[int]) -\u003e List[int]: res, carry = [], 1 for digit in digits[::-1]: s = digit + carry res.append(s % 10) carry = s//10 if carry: res.append(carry) return res[::-1] 36 ms ","date":"2015-03-07","objectID":"/leetcode/0066/:3:0","tags":null,"title":"0066：加一","uri":"/leetcode/0066/"},{"categories":null,"content":"题目 有效数字（按顺序）可以分成以下几个部分： 一个 小数 或者 整数 （可选）一个 ’e’ 或 ‘E’ ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-’） 下述格式之一： 至少一位数字，后面跟着一个点 ‘.’ 至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 一个点 ‘.’ ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-’） 至少一位数字 部分有效数字列举如下： [“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90","date":"2015-03-06","objectID":"/leetcode/0065/:1:0","tags":null,"title":"0065：有效数字（★★★）","uri":"/leetcode/0065/"},{"categories":null,"content":"分析 首先想到用正则： 有效整数很简单: \"[+-]?\\d+\"\r有效小数基于有效整数，考虑两种格式:\r'.' 之前至少一位数字 \"[+-]?\\d+\\.\\d*\"\r'.' 之前没有数字，之后至少一位 \"[+-]?\\.\\d+\"\r有效整数或小数整合为： \"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)\"\r有效数字基于有效整数和小数，考虑两种格式:\r不存在 \"eE\", 就是一个整数或小数 \"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)\"\r存在一个 \"eE\", 前面是整数或小数, 后面是整数 \"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)[eE][+-]?\\d+\"\r整合一下即得最终表达式。 ","date":"2015-03-06","objectID":"/leetcode/0065/:2:0","tags":null,"title":"0065：有效数字（★★★）","uri":"/leetcode/0065/"},{"categories":null,"content":"解答 def isNumber(self, s: str) -\u003e bool: return bool(re.match(r\"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?$\", s)) 40 ms ","date":"2015-03-06","objectID":"/leetcode/0065/:3:0","tags":null,"title":"0065：有效数字（★★★）","uri":"/leetcode/0065/"},{"categories":null,"content":"*附加 还有更加通用的 DFA（确定有限状态自动机）方法。 def isNumber(self, s: str) -\u003e bool: st = ['0_initial', '1_sign', '2_int', '3_dot', '4_dot_without_int', '5_decimal', '6_e', '7_e_sign', '8_e_int'] act = ['0_sign', '1_int', '2_dot', '3_e'] shift = {st[0]: {act[0]: st[1], act[1]: st[2], act[2]: st[4]}, st[1]: {act[1]: st","date":"2015-03-06","objectID":"/leetcode/0065/:4:0","tags":null,"title":"0065：有效数字（★★★）","uri":"/leetcode/0065/"},{"categories":null,"content":"题目 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\r输出：7\r解释：因为路径 1→3→1→1→1 的总和最小。\r示例 2： 输入：grid = [[1,2,3],[4,5,6]]\r输出：12\r提示： m == grid.length n == grid[i].length 1 \u003c= m, n \u003c= 200 0 \u003c= grid[i][j] \u003c= 100 ","date":"2015-03-05","objectID":"/leetcode/0064/:1:0","tags":null,"title":"0064：最小路径和（★）","uri":"/leetcode/0064/"},{"categories":null,"content":"分析 类似 0062，只是递推关系变成了： dp[i][j] = min(dp[-1][j], dp[i][j-1]) + grid[i][j]。\r","date":"2015-03-05","objectID":"/leetcode/0064/:2:0","tags":null,"title":"0064：最小路径和（★）","uri":"/leetcode/0064/"},{"categories":null,"content":"解答 def minPathSum(self, grid: List[List[int]]) -\u003e int: m, n = len(grid), len(grid[0]) dp = [float('inf')] * (n + 1) for i, j in product(range(1, m + 1), range(1, n + 1)): dp[j] = grid[i-1][j-1] + (0 if i==j==1 else min(dp[j], dp[j-1])) return dp[-1] 36 ms ","date":"2015-03-05","objectID":"/leetcode/0064/:3:0","tags":null,"title":"0064：最小路径和（★）","uri":"/leetcode/0064/"},{"categories":null,"content":"题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例 1: 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\r输出：2\r解释：\r3x3 网格的正中间有一个障碍物。\r从左上角到右下角一共有 2 条不同的路径：\r1. 向右 -\u003e 向右 -\u003e 向下 -\u003e 向下\r2. 向下 -\u003e 向下 -\u003e 向右 ","date":"2015-03-04","objectID":"/leetcode/0063/:1:0","tags":null,"title":"0063：不同路径 II（★）","uri":"/leetcode/0063/"},{"categories":null,"content":"分析 0062 进阶版，递推时注意障碍的特殊情况即可。 ","date":"2015-03-04","objectID":"/leetcode/0063/:2:0","tags":null,"title":"0063：不同路径 II（★）","uri":"/leetcode/0063/"},{"categories":null,"content":"解答 def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -\u003e int: m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [0] * (n+1) for i, j in product(range(1, m+1), range(1, n+1)): if obstacleGrid[i-1][j-1] == 1: dp[j] = 0 else: dp[j] = 1 if i == j == 1 else dp[j] + dp[j-1] return dp[-1] ","date":"2015-03-04","objectID":"/leetcode/0063/:3:0","tags":null,"title":"0063：不同路径 II（★）","uri":"/leetcode/0063/"},{"categories":null,"content":"题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1: 输入：m = 3, n = 7\r输出：28\r示例 2： 输入：m = 3, n = 2\r输出：3\r解释：\r从左上角开始，总共有 3 条路径可以到达右下角。\r1. 向右 -\u003e 向下 -\u003e 向下\r2. 向下 -\u003e 向下 -\u003e 向右\r3. 向下 -\u003e 向右 -\u003e 向下\r示例 3： 输入：m = 7, n = 3\r输出：28\r示例 4： 输入：m = 3, n =","date":"2015-03-03","objectID":"/leetcode/0062/:1:0","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"分析 ","date":"2015-03-03","objectID":"/leetcode/0062/:2:0","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"#1 要到达位置 (i, j)，只能从 (i-1, j) 或 (i, j-1) 到达，可以转为递归子问题。 显然有重复子问题，所以用动态规划。 def uniquePaths(self, m: int, n: int) -\u003e int: dp = [[0]*n for _ in range(m)] for i, j in product(range(m), range(n)): dp[i][j] = 1 if i==0 or j==0 else dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 36 ms ","date":"2015-03-03","objectID":"/leetcode/0062/:2:1","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"#2 dp[i][j] 只依赖于 dp[i-1][j] 和 dp[i][j-1]，可以优化为一维数组。 ","date":"2015-03-03","objectID":"/leetcode/0062/:2:2","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"解答 def uniquePaths(self, m: int, n: int) -\u003e int: dp = [1] * n for _, j in product(range(1, m), range(1, n)): dp[j] += dp[j-1] return dp[-1] 32 ms ","date":"2015-03-03","objectID":"/leetcode/0062/:3:0","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"*附加 还可以直接用排列组合解决： 机器人要到达右下角，要走 m+n-2 步，其中 m-1 步向下，n-1 步向右 路径一一对应于由 m-1 个’下’和 n-1 个’右’组成的序列 路径数即为 m+n-2 中选 m-1 个的方案数 def uniquePaths(self, m: int, n: int) -\u003e int: return comb(m+n-2, n-1) 32 ms ","date":"2015-03-03","objectID":"/leetcode/0062/:4:0","tags":null,"title":"0062：不同路径（★）","uri":"/leetcode/0062/"},{"categories":null,"content":"题目 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 示例 1： 输入：head = [1,2,3,4,5], k = 2\r输出：[4,5,1,2,3]\r示例 2： 输入：head = [0,1,2], k = 4\r输出：[2,0,1]\r提示： 链表中节点的数目在范围 [0, 500] 内 -100 \u003c= Node.val \u003c= 100 0 \u003c= k \u003c= 2 * 10^9 ","date":"2015-03-02","objectID":"/leetcode/0061/:1:0","tags":null,"title":"0061：旋转链表（★）","uri":"/leetcode/0061/"},{"categories":null,"content":"分析 这个旋转操作其实相当于在某位置将链表断开，再将前半部分接到后半部分后面。 观察可知新的表尾是第 n - k % n （n 是链表长度）个元素，所以： 先找到表尾 tail 并计算出链表长度 n 若 k 是 n 的倍数直接返回，否则找到新表尾 newtail，是第 n - k % n 个元素 新表头 newhead=newtail.next，断开新表尾，再将 head 接到 tail 后面即可 ","date":"2015-03-02","objectID":"/leetcode/0061/:2:0","tags":null,"title":"0061：旋转链表（★）","uri":"/leetcode/0061/"},{"categories":null,"content":"解答 def rotateRight(self, head: ListNode, k: int) -\u003e ListNode: if not head: return head tail, n = head, 1 while tail.next: tail = tail.next n += 1 k %= n if not k: return head newtail = head for _ in range(n-k-1): newtail = newtail.next newhead = newtail.next tail.next = head newtail.next = None retu","date":"2015-03-02","objectID":"/leetcode/0061/:3:0","tags":null,"title":"0061：旋转链表（★）","uri":"/leetcode/0061/"},{"categories":null,"content":"题目 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" 给定 n 和 k，返回第 k 个排列。 示例 1： 输入：n = 3, k = 3 输出：\"213\" 示例 2： 输入：n = 4, k = 9 输出：\"2314\" 示例 3： 输入：n = 3, k = 1 输出：\"123\" 提示： 1 \u003c= n \u003c= 9 1 \u003c= k \u003c= n! ","date":"2015-03-01","objectID":"/leetcode/0060/:1:0","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"分析 ","date":"2015-03-01","objectID":"/leetcode/0060/:2:0","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"#1 可以直接调包得到所有排列，返回第 k 个排列。 def getPermutation(self, n: int, k: int) -\u003e str: res = list(permutations(range(1, n+1)))[k-1] return ''.join(map(str, res)) 1908 ms ","date":"2015-03-01","objectID":"/leetcode/0060/:2:1","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"#2 也可以递推： 为了方便，令 x = k-1 使得从 0 开始 由排列组合知识可知，首位固定时有 (n-1)! 种情况，那么第 x 个排列的首位即为第 x//(n-1)! 个元素 确定首位元素后，转为求剩下元素的第 x%(n-1)! 个排列，后面依此类推 为了方便，维护还剩下的元素的有序数组 A，每次弹出即可 ","date":"2015-03-01","objectID":"/leetcode/0060/:2:2","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"解答 def getPermutation(self, n: int, k: int) -\u003e str: res, A, x = '', list(range(1, n+1)), k-1 for j in range(n): fac = factorial(n-1-j) res += str(A.pop(x//fac)) x %= fac return res 32 ms ","date":"2015-03-01","objectID":"/leetcode/0060/:3:0","tags":null,"title":"0060：排列序列（★★）","uri":"/leetcode/0060/"},{"categories":null,"content":"题目 给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 1： 输入：n = 3\r输出：[[1,2,3],[8,9,4],[7,6,5]]\r示例 2： 输入：n = 1\r输出：[[1]]\r提示： 1 \u003c= n \u003c= 20 ","date":"2015-02-28","objectID":"/leetcode/0059/:1:0","tags":null,"title":"0059：螺旋矩阵 II（★★）","uri":"/leetcode/0059/"},{"categories":null,"content":"分析 与 0054 类似，模拟过程： 初始位置 \u003cx=0,y=0\u003e，初始方向 \u003cdx=0,dy=1\u003e 到达边界位置则改变方向为 \u003cdy,-dx\u003e 为了方便，初始 matrix 的值都为 0 ，当 matrix[(x+dx)%m][(y+dy)%n]!=0 即代表到达边界 ","date":"2015-02-28","objectID":"/leetcode/0059/:2:0","tags":null,"title":"0059：螺旋矩阵 II（★★）","uri":"/leetcode/0059/"},{"categories":null,"content":"解答 def generateMatrix(self, n: int) -\u003e List[List[int]]: res = [[0]*n for _ in range(n)] x, y, dx, dy = 0, 0, 0, 1 for i in range(n*n): res[x][y] = i+1 if res[(x+dx)%n][(y+dy)%n]: dx, dy = dy, -dx x, y = x+dx, y+dy return res 28 ms ","date":"2015-02-28","objectID":"/leetcode/0059/:3:0","tags":null,"title":"0059：螺旋矩阵 II（★★）","uri":"/leetcode/0059/"},{"categories":null,"content":"题目 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。 示例 1： 输入：s = \"Hello World\"\r输出：5\r解释：最后一个单词是“World”，长度为5。\r示例 2： 输入：s = \" fly me to the moon \"\r输出：4\r解释：最后一个单词是“moon”，长度为4。\r示例 3： 输入：s = \"luffy is still joyboy\"\r输出：6\r解释：最后一个单词是长度为6的“joyboy”。\r提示： 1 \u003c= s.length \u003c= 10^4 s 仅","date":"2015-02-27","objectID":"/leetcode/0058/:1:0","tags":null,"title":"0058：最后一个单词的长度","uri":"/leetcode/0058/"},{"categories":null,"content":"分析 去掉末尾空格，按空格分隔即可。 ","date":"2015-02-27","objectID":"/leetcode/0058/:2:0","tags":null,"title":"0058：最后一个单词的长度","uri":"/leetcode/0058/"},{"categories":null,"content":"解答 def lengthOfLastWord(self, s: str) -\u003e int: return len(s.strip().split(' ')[-1]) 36 ms ","date":"2015-02-27","objectID":"/leetcode/0058/:3:0","tags":null,"title":"0058：最后一个单词的长度","uri":"/leetcode/0058/"},{"categories":null,"content":"题目 给你一个 无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1： 输入：intervals = [[1,3],[6,9]], newInterval = [2,5]\r输出：[[1,5],[6,9]]\r示例 2： 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\r输出：[[1,2],[3,10],[12,16]]\r解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。\r","date":"2015-02-26","objectID":"/leetcode/0057/:1:0","tags":null,"title":"0057：插入区间（★★）","uri":"/leetcode/0057/"},{"categories":null,"content":"分析 ","date":"2015-02-26","objectID":"/leetcode/0057/:2:0","tags":null,"title":"0057：插入区间（★★）","uri":"/leetcode/0057/"},{"categories":null,"content":"#1 区间列表有序，因此与新区间重叠的必然是连续的。 因此遍历找到第一个重叠的，开始合并，直到不重叠为止。所有重叠的一段合并为一个区间，而前后其它区间不变。 def insert(self, intervals: List[List[int]], newInterval: List[int]) -\u003e List[List[int]]: i, (s, e) = 0, newInterval while i \u003c len(intervals) and intervals[i][1] \u003c s: i += 1 j = i while j \u003c len(intervals) and intervals[j][","date":"2015-02-26","objectID":"/leetcode/0057/:2:1","tags":null,"title":"0057：插入区间（★★）","uri":"/leetcode/0057/"},{"categories":null,"content":"#2 也可以直接二分查找与新区间重叠的下标范围，替换为合并后的区间。 ","date":"2015-02-26","objectID":"/leetcode/0057/:2:2","tags":null,"title":"0057：插入区间（★★）","uri":"/leetcode/0057/"},{"categories":null,"content":"解答 def insert(self, intervals: List[List[int]], newInterval: List[int]) -\u003e List[List[int]]: L, R = newInterval i = bisect_left(intervals, L, key=lambda x: x[1]) j = bisect_right(intervals, R, key=lambda x: x[0]) if i\u003cj: L, R = min(L, intervals[i][0]), max(R, intervals[j-1][1]) intervals[i:j] = [[L, ","date":"2015-02-26","objectID":"/leetcode/0057/:3:0","tags":null,"title":"0057：插入区间（★★）","uri":"/leetcode/0057/"},{"categories":null,"content":"题目 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。 请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 示例 1： 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\r输出：[[1,6],[8,10],[15,18]]\r解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\r示例 2： 输入：intervals = [[1,4],[4,5]]\r输出：[[1,5]]\r解释：区间 [1,4] 和 [4,5] 可被视为重叠区间","date":"2015-02-25","objectID":"/leetcode/0056/:1:0","tags":null,"title":"0056：合并区间（★）","uri":"/leetcode/0056/"},{"categories":null,"content":"分析 显然能合并的区间范围必然相近，因此考虑先按起点排序，再遍历。 遍历过程中，如果当前区间的起点小于等于上一区间的终点，那么就可以合并；否则，就添加新区间。 ","date":"2015-02-25","objectID":"/leetcode/0056/:2:0","tags":null,"title":"0056：合并区间（★）","uri":"/leetcode/0056/"},{"categories":null,"content":"解答 def merge(self, intervals: List[List[int]]) -\u003e List[List[int]]: res = [] for s, e in sorted(intervals): if res and s \u003c= res[-1][1]: res[-1][1] = max(res[-1][1], e) else: res.append([s, e]) return res 56 ms ","date":"2015-02-25","objectID":"/leetcode/0056/:3:0","tags":null,"title":"0056：合并区间（★）","uri":"/leetcode/0056/"},{"categories":null,"content":"题目 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 输入：nums = [2,3,1,1,4]\r输出：true\r解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\r示例 2： 输入：nums = [3,2,1,0,4]\r输出：false\r解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\r提示： 1 \u003c= nums.length \u003c= 3 * 10^4 0 \u003c= num","date":"2015-02-24","objectID":"/leetcode/0055/:1:0","tags":null,"title":"0055：跳跃游戏（★）","uri":"/leetcode/0055/"},{"categories":null,"content":"分析 和 0045 类似，考虑跳不了的特殊情况即可。 ","date":"2015-02-24","objectID":"/leetcode/0055/:2:0","tags":null,"title":"0055：跳跃游戏（★）","uri":"/leetcode/0055/"},{"categories":null,"content":"解答 def canJump(self, nums: List[int]) -\u003e bool: s, e = 0, 1 while s \u003c e \u003c len(nums): s, e = e, max(i + nums[i] for i in range(s, e)) + 1 return e \u003e= len(nums) 92 ms ","date":"2015-02-24","objectID":"/leetcode/0055/:3:0","tags":null,"title":"0055：跳跃游戏（★）","uri":"/leetcode/0055/"},{"categories":null,"content":"题目 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\r输出：[1,2,3,6,9,8,7,4,5]\r示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\r输出：[1,2,3,4,8,12,11,10,9,5,6,7]\r提示： m == matrix.length n == matrix[i].length 1 \u003c= m, n \u003c= 10 -100 \u003c= matrix[i][j] \u003c= 100 ","date":"2015-02-23","objectID":"/leetcode/0054/:1:0","tags":null,"title":"0054：螺旋矩阵（★★）","uri":"/leetcode/0054/"},{"categories":null,"content":"分析 考虑模拟过程: 初始位置 \u003cx=0,y=0\u003e，初始方向 \u003cdx=0,dy=1\u003e 到达边界位置则改变方向为 \u003cdy,-dx\u003e 为了方便，可以将走过的地方置 0 ，当 matrix[(x+dx)%m][(y+dy)%n]==0 即代表到达边界 ","date":"2015-02-23","objectID":"/leetcode/0054/:2:0","tags":null,"title":"0054：螺旋矩阵（★★）","uri":"/leetcode/0054/"},{"categories":null,"content":"解答 def spiralOrder(self, matrix: List[List[int]]) -\u003e List[int]: res, m, n = [], len(matrix), len(matrix[0]) x, y, dx, dy = 0, 0, 0, 1 for _ in range(m*n): res.append(matrix[x][y]) matrix[x][y] = 0 if matrix[(x+dx)%m][(y+dy)%n] == 0: dx, dy = dy, -dx x, y = x+dx, y+dy return res 28 ms ","date":"2015-02-23","objectID":"/leetcode/0054/:3:0","tags":null,"title":"0054：螺旋矩阵（★★）","uri":"/leetcode/0054/"},{"categories":null,"content":"题目 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\r输出：6\r解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\r示例 2： 输入：nums = [1]\r输出：1\r示例 3： 输入：nums = [5,4,-1,7,8]\r输出：23\r提示： 1 \u003c= nums.length \u003c= 10^5 -10^4 \u003c= nums[i] \u003c= 10^4 ","date":"2015-02-22","objectID":"/leetcode/0053/:1:0","tags":null,"title":"0053：最大子数组和（★）","uri":"/leetcode/0053/"},{"categories":null,"content":"分析 令 dp[j] 表示以位置 j 结尾的最大和，则 dp[j] = max(0, dp[j-1]) + nums[j]。\r最后 max(dp) 即为所求。还可以优化为一个参数。 ","date":"2015-02-22","objectID":"/leetcode/0053/:2:0","tags":null,"title":"0053：最大子数组和（★）","uri":"/leetcode/0053/"},{"categories":null,"content":"解答 def maxSubArray(self, nums: List[int]) -\u003e int: res = dp = float('-inf') for num in nums: dp = max(0, dp) + num res = max(res, dp) return res 140 ms ","date":"2015-02-22","objectID":"/leetcode/0053/:3:0","tags":null,"title":"0053：最大子数组和（★）","uri":"/leetcode/0053/"},{"categories":null,"content":"题目 n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。 示例 1: 输入：n = 4\r输出：2\r解释：如上图所示，4 皇后问题存在两个不同的解法。\r示例 2： 输入：n = 1\r输出：1\r提示： 1 \u003c= n \u003c= 9 ","date":"2015-02-21","objectID":"/leetcode/0052/:1:0","tags":null,"title":"0052：N 皇后 II（★★）","uri":"/leetcode/0052/"},{"categories":null,"content":"分析 类似 0051 ，还更简单一点。 ","date":"2015-02-21","objectID":"/leetcode/0052/:2:0","tags":null,"title":"0052：N 皇后 II（★★）","uri":"/leetcode/0052/"},{"categories":null,"content":"解答 def totalNQueens(self, n: int) -\u003e int: def dfs(i): if i == n: return 1 res = 0 for j in range(n): if col[j] == dia1[i + j] == dia2[i - j] == 0: col[j] = dia1[i + j] = dia2[i - j] = 1 res += dfs(i + 1) col[j] = dia1[i + j] = dia2[i - j] = 0 return res col, dia1, dia2 = (defaultdict(int) for _ in r","date":"2015-02-21","objectID":"/leetcode/0052/:3:0","tags":null,"title":"0052：N 皇后 II（★★）","uri":"/leetcode/0052/"},{"categories":null,"content":"题目 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例 1: 输入：n = 4\r输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\r解释：如上图所示，4 皇后问题存在两个不同的解法。\r示例 2: 输入：n = 1\r输出：[[\"Q\"]]\r提示： 1 \u003c= n \u003c= 9 ","date":"2015-02-20","objectID":"/leetcode/0051/:1:0","tags":null,"title":"0051：N 皇后（★★）","uri":"/leetcode/0051/"},{"categories":null,"content":"分析 回溯法的典型应用。每一行只能有一个棋子，所以可以直接按行放，节省时间。 ","date":"2015-02-20","objectID":"/leetcode/0051/:2:0","tags":null,"title":"0051：N 皇后（★★）","uri":"/leetcode/0051/"},{"categories":null,"content":"解答 def solveNQueens(self, n: int) -\u003e List[List[str]]: def dfs(i): if i == n: res.append(['.'*j+'Q'+'.'*(n-j-1) for j in path]) return for j in range(n): if col[j] == dia1[i+j] == dia2[i-j] == 0: col[j] = dia1[i+j] = dia2[i-j] = 1 path.append(j) dfs(i + 1) path.pop() col[j] = dia1[i+j] = dia2[i-j] = ","date":"2015-02-20","objectID":"/leetcode/0051/:3:0","tags":null,"title":"0051：N 皇后（★★）","uri":"/leetcode/0051/"},{"categories":null,"content":"《花与爱丽丝杀人事件》是日本2015年2月20日上映的长篇动画电影，由岩井俊二导演并创作剧本，苍井优和铃木杏担任主要配音。该部作品是2004年电影《花与爱丽丝》的前传。\n影片中描述了少女时的两位女主角，转校生爱丽丝与不上学的花相识及被卷入一场神秘杀人事件当中的经过。 ","date":"2015-02-20","objectID":"/anime/hana_to_alice/","tags":null,"title":"花与爱丽丝杀人事件","uri":"/anime/hana_to_alice/"},{"categories":null,"content":"简介 《花与爱丽丝杀人事件》是日本2015年2月20日上映的长篇动画电影，由岩井俊二导演并创作剧本，苍井优和铃木杏担任主要配音。该部作品是2004年电影《花与爱丽丝》的前传。 影片中描述了少女时的两位女主角，转校生爱丽丝与不上学的花相识及被卷入一场神秘杀人事件当中的经过。 制作人员： 原作：岩井俊二 分镜：长滨博史 美术监督：泷口比吕志 色彩设计：片山由美子 原画：矶光雄 ","date":"2015-02-20","objectID":"/anime/hana_to_alice/:1:0","tags":null,"title":"花与爱丽丝杀人事件","uri":"/anime/hana_to_alice/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 有栖川彻子 Tetsuko Arisugawa、有栖川徹子、ありすがわ てつこ、Tetsuko \"Alice\" Arisugawa、爱丽丝 女 蒼井優 2 荒井花 Hana Arai、荒井花、あらい はな、花 女 鈴木杏 ","date":"2015-02-20","objectID":"/anime/hana_to_alice/:2:0","tags":null,"title":"花与爱丽丝杀人事件","uri":"/anime/hana_to_alice/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 花与爱丽丝杀人事件 2015-02-20 1 樱花 ","date":"2015-02-20","objectID":"/anime/hana_to_alice/:3:0","tags":null,"title":"花与爱丽丝杀人事件","uri":"/anime/hana_to_alice/"},{"categories":null,"content":"题目 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。 示例 1： 输入：x = 2.00000, n = 10\r输出：1024.00000\r示例 2： 输入：x = 2.10000, n = 3\r输出：9.26100\r示例 3： 输入：x = 2.00000, n = -2\r输出：0.25000\r解释：2-2 = 1/22 = 1/4 = 0.25\r提示： -100.0 \u003c x \u003c 100.0 -2^31 \u003c= n \u003c= 2^31-1 -10^4 \u003c= xn \u003c= 10^4 ","date":"2015-02-19","objectID":"/leetcode/0050/:1:0","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"分析 ","date":"2015-02-19","objectID":"/leetcode/0050/:2:0","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"#1 递归的典型应用，特别注意下 n 为负数、x 为 0 的边界情况。 def myPow(self, x: float, n: int) -\u003e float: if n == 0: return 1 if x == 0: return 0 if n \u003c 0: x, n = 1 / x, -n return self.myPow(x, n // 2) ** 2 * (x if n % 2 else 1) 28 ms ","date":"2015-02-19","objectID":"/leetcode/0050/:2:1","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"#2 还可以写成非递归形式。假设 n 的二进制字符串为 s，可以递推求得 pow(x, s[:i]对应的数)。 （也可以迭代 s 的后缀，递推求得 pow(x, int(s[i:], 2))） ","date":"2015-02-19","objectID":"/leetcode/0050/:2:2","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"解答 def myPow(self, x: float, n: int) -\u003e float: if n == 0: return 1 if x == 0: return 0 if n \u003c 0: x, n = 1 / x, -n res = 1 for bit in bin(n)[2:]: res *= res res *= x if bit == '1' else 1 return res 28 ms ","date":"2015-02-19","objectID":"/leetcode/0050/:3:0","tags":null,"title":"0050：Pow(x, n)（★）","uri":"/leetcode/0050/"},{"categories":null,"content":"题目 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。 示例 1: 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\r输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\r示例 2: 输入: strs = [\"\"]\r输出: [[\"\"]]\r示例 3: 输入: strs = [\"a\"]\r输出: [[\"a\"]]\r提示： 1 \u003c= strs.length \u003c= 10^4 0 \u003c= ","date":"2015-02-18","objectID":"/leetcode/0049/:1:0","tags":null,"title":"0049：字母异位词分组","uri":"/leetcode/0049/"},{"categories":null,"content":"分析 显然字母异位词排序后相同，所以将排序后的字符串作为键存到哈希表即可。 ","date":"2015-02-18","objectID":"/leetcode/0049/:2:0","tags":null,"title":"0049：字母异位词分组","uri":"/leetcode/0049/"},{"categories":null,"content":"解答 def groupAnagrams(self, strs: List[str]) -\u003e List[List[str]]: d = defaultdict(list) for s in strs: key = ''.join(sorted(s)) d[key].append(s) return list(d.values()) 60 ms ","date":"2015-02-18","objectID":"/leetcode/0049/:3:0","tags":null,"title":"0049：字母异位词分组","uri":"/leetcode/0049/"},{"categories":null,"content":"题目 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。 请不要 使用另一个矩阵来旋转图像。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\r输出：[[7,4,1],[8,5,2],[9,6,3]]\r示例 2： 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\r输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\r提示： n ","date":"2015-02-17","objectID":"/leetcode/0048/:1:0","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"分析 ","date":"2015-02-17","objectID":"/leetcode/0048/:2:0","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"#1 观察可知，这个旋转操作等价于按主对角线翻转，再左右翻转。 def rotate(self, matrix: List[List[int]]) -\u003e None: for i in range(1, len(matrix)): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for row in matrix: row.reverse() 32 ms ","date":"2015-02-17","objectID":"/leetcode/0048/:2:1","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"#2 可以用 zip 一行实现。 ","date":"2015-02-17","objectID":"/leetcode/0048/:2:2","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"解答 def rotate(self, matrix: List[List[int]]) -\u003e None: matrix[:] = zip(*matrix[::-1]) 36 ms ","date":"2015-02-17","objectID":"/leetcode/0048/:3:0","tags":null,"title":"0048：旋转图像（★）","uri":"/leetcode/0048/"},{"categories":null,"content":"题目 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例 1： 输入：nums = [1,1,2]\r输出：\r[[1,1,2],\r[1,2,1],\r[2,1,1]]\r示例 2： 输入：nums = [1,2,3]\r输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\r提示： 1 \u003c= nums.length \u003c= 8 -10 \u003c= nums[i] \u003c= 10 ","date":"2015-02-16","objectID":"/leetcode/0047/:1:0","tags":null,"title":"0047：全排列 II（★★）","uri":"/leetcode/0047/"},{"categories":null,"content":"分析 ","date":"2015-02-16","objectID":"/leetcode/0047/:2:0","tags":null,"title":"0047：全排列 II（★★）","uri":"/leetcode/0047/"},{"categories":null,"content":"#1 依然可以调库。 def permuteUnique(self, nums: List[int]) -\u003e List[List[int]]: return list(set(permutations(nums))) 64 ms ","date":"2015-02-16","objectID":"/leetcode/0047/:2:1","tags":null,"title":"0047：全排列 II（★★）","uri":"/leetcode/0047/"},{"categories":null,"content":"#2 与 0046 的区别是有重复数字。 所以把 nums 排序后再遍历。 每个位置选数字时，在未标记集合中选重复数字最前面的，从而保证排列不重复。 ","date":"2015-02-16","objectID":"/leetcode/0047/:2:2","tags":null,"title":"0047：全排列 II（★★）","uri":"/leetcode/0047/"},{"categories":null,"content":"解答 def permuteUnique(self, nums: List[int]) -\u003e List[List[int]]: def dfs(path): if len(path) == len(nums): res.append(path) return for i, num in enumerate(nums): if i and nums[i-1] == num and i-1 not in vis: continue if i not in vis: vis.add(i) dfs(path + [num]) vis.remove(i) res, vis = [], set() num","date":"2015-02-16","objectID":"/leetcode/0047/:3:0","tags":null,"title":"0047：全排列 II（★★）","uri":"/leetcode/0047/"},{"categories":null,"content":"题目 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 输入：nums = [1,2,3]\r输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\r示例 2： 输入：nums = [0,1]\r输出：[[0,1],[1,0]]\r示例 3： 输入：nums = [1]\r输出：[[1]]\r提示： 1 \u003c= nums.length \u003c= 6 -10 \u003c= nums[i] \u003c= 10 nums 中的所有整数 互不相同 ","date":"2015-02-15","objectID":"/leetcode/0046/:1:0","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"分析 ","date":"2015-02-15","objectID":"/leetcode/0046/:2:0","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"#1 python 里可以直接调库。 def permute(self, nums: List[int]) -\u003e List[List[int]]: return list(permutations(nums)) 40 ms ","date":"2015-02-15","objectID":"/leetcode/0046/:2:1","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"#2 自己实现可以用 dfs，依次选择数字即可。 注意标记选过的数字。 ","date":"2015-02-15","objectID":"/leetcode/0046/:2:2","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"解答 def permute(self, nums: List[int]) -\u003e List[List[int]]: def dfs(path): if len(path) == len(nums): res.append(path) for i, num in enumerate(nums): if i not in vis: vis.add(i) dfs(path+[num]) vis.remove(i) res, vis = [], set() dfs([]) return res 28 ms ","date":"2015-02-15","objectID":"/leetcode/0046/:3:0","tags":null,"title":"0046：全排列（★）","uri":"/leetcode/0046/"},{"categories":null,"content":"题目 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。 示例 1: 输入: nums = [2,3,1,1,4]\r输出: 2\r解释: 跳到最后一个位置的最小跳跃数是 2。\r从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\r示例 2: 输入: nums = [2,3,0,1,4]\r输出: 2\r提示: 1 \u003c= nums.length \u003c= 10^4 0 \u003c= nums[i] \u003c= 1000 ","date":"2015-02-14","objectID":"/leetcode/0045/:1:0","tags":null,"title":"0045：跳跃游戏 II（★）","uri":"/leetcode/0045/"},{"categories":null,"content":"分析 根据最少跳 k 步到达的位置可以递推出最少跳 k+1 步到达的位置。 循环递推直到到达末尾即可。 注意每轮能到达的位置必然是连续的，所以保存区间即可。为了方便，使用左闭右开的区间形式。 ","date":"2015-02-14","objectID":"/leetcode/0045/:2:0","tags":null,"title":"0045：跳跃游戏 II（★）","uri":"/leetcode/0045/"},{"categories":null,"content":"解答 def jump(self, nums: List[int]) -\u003e int: res, s, e = 0, 0, 1 while e \u003c len(nums): s, e = e, max(i+nums[i] for i in range(s, e))+1 res += 1 return res 32 ms ","date":"2015-02-14","objectID":"/leetcode/0045/:3:0","tags":null,"title":"0045：跳跃游戏 II（★）","uri":"/leetcode/0045/"},{"categories":null,"content":"题目 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。 ‘?’ 可以匹配任何单个字符。 ‘*’ 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1: 输入:\rs = \"aa\"\rp = \"a\"\r输出: false\r解释: \"a\" 无法匹配 \"aa\" 整个字符串。\r示例 2: 输入:\rs = \"aa\"\rp = \"*\"\r输出: true\r解释: '*' 可以匹配任意字符串。\r示例 3: 输入:\rs","date":"2015-02-13","objectID":"/leetcode/0044/:1:0","tags":null,"title":"0044：通配符匹配（★★★）","uri":"/leetcode/0044/"},{"categories":null,"content":"分析 类似 0010，区别在于星号和前一个字符无关了。 ","date":"2015-02-13","objectID":"/leetcode/0044/:2:0","tags":null,"title":"0044：通配符匹配（★★★）","uri":"/leetcode/0044/"},{"categories":null,"content":"解答 def isMatch(self, s: str, p: str) -\u003e bool: @lru_cache(None) def dfs(s, p): if not p: return not s if p[-1] == '*': return dfs(s, p[:-1]) or (bool(s) and dfs(s[:-1], p)) return bool(s) and p[-1] in [s[-1], '?'] and dfs(s[:-1], p[:-1]) return dfs(s, p) 1032 ms ","date":"2015-02-13","objectID":"/leetcode/0044/:3:0","tags":null,"title":"0044：通配符匹配（★★★）","uri":"/leetcode/0044/"},{"categories":null,"content":"*附加 本题也可以用正则解决。 观察发现，将 p 按星号分割为一些子串，问题就等价于在 s 中依次搜索这些子串。 注意第一个子串要和 s 开头匹配，最后一个子串要和 s 末尾匹配。 def isMatch(self, s: str, p: str) -\u003e bool: subs, pos = re.split(r'\\*+', p.replace('?', '.')), 0 for i, sub in enumerate(subs): tmp = re.compile('^'*(i==0)+sub+'$'*(i==len(subs)-1)).search(s, pos) if not tmp: r","date":"2015-02-13","objectID":"/leetcode/0044/:4:0","tags":null,"title":"0044：通配符匹配（★★★）","uri":"/leetcode/0044/"},{"categories":null,"content":"题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。 示例 1: 输入: num1 = \"2\", num2 = \"3\"\r输出: \"6\"\r示例 2: 输入: num1 = \"123\", num2 = \"456\"\r输出: \"56088\"\r提示： 1 \u003c= num1.length, num2.length \u003c= 200 num1 和 num2 只能由数字组成。 num1 和 num2 都不包含任何前导零，除了数字0本身。 ","date":"2015-02-12","objectID":"/leetcode/0043/:1:0","tags":null,"title":"0043：字符串相乘（★★）","uri":"/leetcode/0043/"},{"categories":null,"content":"分析 ","date":"2015-02-12","objectID":"/leetcode/0043/:2:0","tags":null,"title":"0043：字符串相乘（★★）","uri":"/leetcode/0043/"},{"categories":null,"content":"#1 虽然题目说不能直接转为整数，不过还是试下看看速度。 def multiply(self, num1: str, num2: str) -\u003e str: return str(int(num1)*int(num2)) 40 ms ","date":"2015-02-12","objectID":"/leetcode/0043/:2:1","tags":null,"title":"0043：字符串相乘（★★）","uri":"/leetcode/0043/"},{"categories":null,"content":"#2 考虑模拟竖式乘法： 为了从低到高计算，将 num1、num2 反序 结果最多 m * n 位，因此用 m * n 长度的数组 res 存储结果 对于每对 \u003cnums1[i], nums2[j]\u003e， 乘积结果对应第 i+j 和 i+j+1 位 遍历过程中注意进位，最后将 res 反序即为所求 注意最后要去掉前置 0。 ","date":"2015-02-12","objectID":"/leetcode/0043/:2:2","tags":null,"title":"0043：字符串相乘（★★）","uri":"/leetcode/0043/"},{"categories":null,"content":"解答 def multiply(self, num1: str, num2: str) -\u003e str: m, n = len(num1), len(num2) res, A, B = [0] * (m+n), num1[::-1], num2[::-1] for i, j in product(range(m), range(n)): s = int(A[i]) * int(B[j]) + res[i+j] res[i+j] = s % 10 res[i+j+1] += s // 10 return ''.join(map(str, res[::-1])).lstrip('0') or '0'","date":"2015-02-12","objectID":"/leetcode/0043/:3:0","tags":null,"title":"0043：字符串相乘（★★）","uri":"/leetcode/0043/"},{"categories":null,"content":"题目 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\r输出：6\r解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，\r可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 输入：height = [4,2,0,3,2,5]\r输出：9\r提示： n == height.length 1 \u003c= n \u003c= 2 * 10^4 0 \u003c= height[i] \u003c= 10^5 ","date":"2015-02-11","objectID":"/leetcode/0042/:1:0","tags":null,"title":"0042：接雨水（★★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"分析 ","date":"2015-02-11","objectID":"/leetcode/0042/:2:0","tags":null,"title":"0042：接雨水（★★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"#1 观察发现： 对于任一柱子，如果左右都有更高的柱子，那么该位置就能接到雨水。 设左右最高的柱子分别为 L, R, 该位置能接到的雨水数量为 min(L, R) - 柱子高度。 每根柱子对应的 L 和 R 可以一趟递推得到，优化为线性时间复杂度。 def trap(self, height: List[int]) -\u003e int: left = list(accumulate(height, max)) right = list(accumulate(height[::-1], max))[::-1] return sum(min(l, r)-h for h,l,r in zip(height","date":"2015-02-11","objectID":"/leetcode/0042/:2:1","tags":null,"title":"0042：接雨水（★★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"#2 还有个巧妙的双指针方法可以一趟解决。 初始 i、j 分别指向数组首尾 若 max(height[:i+1]) \u003c= max(height[j:])，可求得位置 i 处的雨水，然后移动 i 若 max(height[:i+1]) \u003e= max(height[j:])，可求得位置 j 处的雨水，然后移动 j 循环操作直到 i、j 相遇，即可得到每个位置处的雨水 ","date":"2015-02-11","objectID":"/leetcode/0042/:2:2","tags":null,"title":"0042：接雨水（★★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"解答 def trap(self, height: List[int]) -\u003e int: res, L, R = 0, 0, 0 i, j = 0, len(height)-1 while i \u003c= j: L, R = max(L, height[i]), max(R, height[j]) if L \u003c= R: res += L - height[i] i += 1 else: res += R - height[j] j -= 1 return res 时间复杂度 O(N)，64 ms ","date":"2015-02-11","objectID":"/leetcode/0042/:3:0","tags":null,"title":"0042：接雨水（★★★）","uri":"/leetcode/0042/"},{"categories":null,"content":"题目 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。 示例 1： 输入：nums = [1,2,0]\r输出：3\r示例 2： 输入：nums = [3,4,-1,1]\r输出：2\r示例 3： 输入：nums = [7,8,9,11,12]\r输出：1\r提示： 1 \u003c= nums.length \u003c= 5 * 10^5 -2^31 \u003c= nums[i] \u003c= 2^31 - 1 ","date":"2015-02-10","objectID":"/leetcode/0041/:1:0","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"分析 ","date":"2015-02-10","objectID":"/leetcode/0041/:2:0","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"#1 最简单地，遍历 1 到 max(nums)+1，没出现就返回。 def firstMissingPositive(self, nums: List[int]) -\u003e int: nums = set(nums) for x in range(1, max(0, max(nums, default=0))+2): if x not in nums: return x 84 ms ","date":"2015-02-10","objectID":"/leetcode/0041/:2:1","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"#2 不过题目要求 O(1) 空间，那么只能考虑交换或赋值了。 有个巧妙的想法是把正数都放在对应的位置上，比如 1 放在第 1 位，3 放在第 3 位， 那么再遍历就能发现缺的第一个正数了 本题不能直接赋值，可能会覆盖掉有用信息，所以考虑交换 如果交换过来还是范围内的正数，应该循环操作 为了防止死循环，当要交换的两个数相等时就应跳出 ","date":"2015-02-10","objectID":"/leetcode/0041/:2:2","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"解答 def firstMissingPositive(self, nums: List[int]) -\u003e int: n = len(nums) for i, x in enumerate(nums): while 1 \u003c= x \u003c= n and x != nums[x-1]: nums[i], nums[x-1] = nums[x-1], nums[i] x = nums[i] for i, x in enumerate(nums): if x != i + 1: return i + 1 return n + 1 228 ms ","date":"2015-02-10","objectID":"/leetcode/0041/:3:0","tags":null,"title":"0041：缺失的第一个正数（★★）","uri":"/leetcode/0041/"},{"categories":null,"content":"题目 给定一个数组 candidates 和一个目标数 target ， 找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 注意：解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,\r输出:\r[\r[1,1,6],\r[1,2,5],\r[1,7],\r[2,6]\r]\r示例 2: 输入: candidates = [2,5,2,1,2], target = 5,\r输出:\r[\r[1,2,2],\r[5]\r]\r提示: 1 \u003c= candidate","date":"2015-02-09","objectID":"/leetcode/0040/:1:0","tags":null,"title":"0040：组合总和 II（★★）","uri":"/leetcode/0040/"},{"categories":null,"content":"分析 0090 升级版，添加了和的限制。 ","date":"2015-02-09","objectID":"/leetcode/0040/:2:0","tags":null,"title":"0040：组合总和 II（★★）","uri":"/leetcode/0040/"},{"categories":null,"content":"解答 def combinationSum2(self, candidates: List[int], target: int) -\u003e List[List[int]]: def dfs(i, s): if s \u003e= target: if s == target: res.append(path[:]) return for j in range(i, n): if j \u003e i and candidates[j] == candidates[j - 1]: continue path.append(candidates[j]) dfs(j + 1, s + candidates[j]) path","date":"2015-02-09","objectID":"/leetcode/0040/:3:0","tags":null,"title":"0040：组合总和 II（★★）","uri":"/leetcode/0040/"},{"categories":null,"content":"题目 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例 1： 输入：candidates = [2,3,6,7], target = 7\r输出：[[2,2,3],[7]]\r解释：\r2 和 3 可以形成一组候选，2 + 2 ","date":"2015-02-08","objectID":"/leetcode/0039/:1:0","tags":null,"title":"0039：组合总和（★）","uri":"/leetcode/0039/"},{"categories":null,"content":"分析 0078 升级版，添加了和的限制。 ","date":"2015-02-08","objectID":"/leetcode/0039/:2:0","tags":null,"title":"0039：组合总和（★）","uri":"/leetcode/0039/"},{"categories":null,"content":"解答 def combinationSum(self, candidates: List[int], target: int) -\u003e List[List[int]]: def dfs(i, s): if s \u003e= target: if s == target: res.append(path[:]) return for j in range(i, n): path.append(candidates[j]) dfs(j, s+candidates[j]) path.pop() res, path, n = [], [], len(candidates) dfs(0, 0) return re","date":"2015-02-08","objectID":"/leetcode/0039/:3:0","tags":null,"title":"0039：组合总和（★）","uri":"/leetcode/0039/"},{"categories":null,"content":"题目 给定一个正整数 n ，输出外观数列的第 n 项。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 你可以将其视作是由递归公式定义的数字字符串序列： countAndSay(1) = “1” countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 前五项如下： 1. 1\r2. 11\r3. 21\r4. 1211\r5. 111221\r第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 \"11\"\r描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 \"21\"\r描述前一项，这个数是 2","date":"2015-02-07","objectID":"/leetcode/0038/:1:0","tags":null,"title":"0038：外观数列（★）","uri":"/leetcode/0038/"},{"categories":null,"content":"分析 迭代即可，可以用 itertools.groupby 简化。 ","date":"2015-02-07","objectID":"/leetcode/0038/:2:0","tags":null,"title":"0038：外观数列（★）","uri":"/leetcode/0038/"},{"categories":null,"content":"解答 def countAndSay(self, n: int) -\u003e str: s = '1' for _ in range(n-1): s = ''.join(str(len(list(g)))+x for x,g in groupby(s)) return s 48 ms ","date":"2015-02-07","objectID":"/leetcode/0038/:3:0","tags":null,"title":"0038：外观数列（★）","uri":"/leetcode/0038/"},{"categories":null,"content":"题目 编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例： 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\"","date":"2015-02-06","objectID":"/leetcode/0037/:1:0","tags":null,"title":"0037：解数独（★★）","uri":"/leetcode/0037/"},{"categories":null,"content":"分析 回溯法的典型应用。可以直接遍历空格位置，节省时间。 ","date":"2015-02-06","objectID":"/leetcode/0037/:2:0","tags":null,"title":"0037：解数独（★★）","uri":"/leetcode/0037/"},{"categories":null,"content":"解答 def solveSudoku(self, board: List[List[str]]) -\u003e None: def dfs(cnt): if cnt == len(A): return True i, j = A[cnt] k = i//3*3+j//3 for x in range(1, 10): if row[i][x] == col[j][x] == box[k][x] == 0: board[i][j] = str(x) row[i][x] = col[j][x] = box[k][x] = 1 if dfs(cnt + 1): return True row[i][x] = ","date":"2015-02-06","objectID":"/leetcode/0037/:3:0","tags":null,"title":"0037：解数独（★★）","uri":"/leetcode/0037/"},{"categories":null,"content":"题目 请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 空白格用 ‘.’ 表示。 示例 1： 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\r,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\r,[\".\",\"","date":"2015-02-05","objectID":"/leetcode/0036/:1:0","tags":null,"title":"0036：有效的数独（★）","uri":"/leetcode/0036/"},{"categories":null,"content":"分析 遍历判断数字在所属的行、列、宫中是否出现过即可。宫的序号可以由 i//3*3+j//3 得到。 ","date":"2015-02-05","objectID":"/leetcode/0036/:2:0","tags":null,"title":"0036：有效的数独（★）","uri":"/leetcode/0036/"},{"categories":null,"content":"解答 def isValidSudoku(self, board: List[List[str]]) -\u003e bool: row, col, box = ([[0]*9 for _ in range(9)] for _ in range(3)) for i, j in product(range(9), range(9)): x, k = board[i][j], i//3*3+j//3 if x != '.': x = int(x)-1 if row[i][x] or col[j][x] or box[k][x]: return False row[i][x] = col[j][x] = bo","date":"2015-02-05","objectID":"/leetcode/0036/:3:0","tags":null,"title":"0036：有效的数独（★）","uri":"/leetcode/0036/"},{"categories":null,"content":"题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5\r输出: 2\r示例 2: 输入: nums = [1,3,5,6], target = 2\r输出: 1\r示例 3: 输入: nums = [1,3,5,6], target = 7\r输出: 4\r提示: 1 \u003c= nums.length \u003c= 10^4 -10^4 \u003c= nums[i] \u003c= 10^4 nums 为 无重复元素 的 升序 排列数","date":"2015-02-04","objectID":"/leetcode/0035/:1:0","tags":null,"title":"0035：搜索插入位置","uri":"/leetcode/0035/"},{"categories":null,"content":"分析 典型的二分查找。 ","date":"2015-02-04","objectID":"/leetcode/0035/:2:0","tags":null,"title":"0035：搜索插入位置","uri":"/leetcode/0035/"},{"categories":null,"content":"解答 def searchInsert(self, nums: List[int], target: int) -\u003e int: return bisect_left(nums, target) 28 ms ","date":"2015-02-04","objectID":"/leetcode/0035/:3:0","tags":null,"title":"0035：搜索插入位置","uri":"/leetcode/0035/"},{"categories":null,"content":"题目 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8\r输出：[3,4]\r示例 2： 输入：nums = [5,7,7,8,8,10], target = 6\r输出：[-1,-1]\r示例 3： 输入：nums = [], target = 0\r输出：[-1,-1]\r提示： 0 \u003c= nums.length","date":"2015-02-03","objectID":"/leetcode/0034/:1:0","tags":null,"title":"0034：在排序数组中查找元素的第一个和最后一个位置（★）","uri":"/leetcode/0034/"},{"categories":null,"content":"分析 二分查找的典型应用。分别对应 bisect_left 和 bisect_right。 ","date":"2015-02-03","objectID":"/leetcode/0034/:2:0","tags":null,"title":"0034：在排序数组中查找元素的第一个和最后一个位置（★）","uri":"/leetcode/0034/"},{"categories":null,"content":"解答 def searchRange(self, nums: List[int], target: int) -\u003e List[int]: i, j = bisect_left(nums, target), bisect_right(nums, target) - 1 return [i, j] if i \u003c= j else [-1, -1] 24 ms ","date":"2015-02-03","objectID":"/leetcode/0034/:3:0","tags":null,"title":"0034：在排序数组中查找元素的第一个和最后一个位置（★）","uri":"/leetcode/0034/"},{"categories":null,"content":"题目 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u003c= k \u003c nums.length）上进行了 旋转， 使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] （下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ， 则返回它的下标，否则返回 ","date":"2015-02-02","objectID":"/leetcode/0033/:1:0","tags":null,"title":"0033：搜索旋转排序数组（★★）","uri":"/leetcode/0033/"},{"categories":null,"content":"分析 由 0153 可以找到最小值位置 i，然后在 nums[:i]，nums[i:] 中分别二分查找 target 即可。 ","date":"2015-02-02","objectID":"/leetcode/0033/:2:0","tags":null,"title":"0033：搜索旋转排序数组（★★）","uri":"/leetcode/0033/"},{"categories":null,"content":"解答 def search(self, nums: List[int], target: int) -\u003e int: n = len(nums) self.__class__.__getitem__ = lambda self, x: nums[x] \u003c= nums[-1] x = bisect_left(self, True, 0, n-1) i = bisect_left(nums, target, 0, x-1) if x else 0 j = bisect_left(nums, target, x, n-1) return i if nums[i] == target else j if","date":"2015-02-02","objectID":"/leetcode/0033/:3:0","tags":null,"title":"0033：搜索旋转排序数组（★★）","uri":"/leetcode/0033/"},{"categories":null,"content":"题目 给你一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 输入：s = \"(()\"\r输出：2\r解释：最长有效括号子串是 \"()\"\r示例 2： 输入：s = \")()())\"\r输出：4\r解释：最长有效括号子串是 \"()()\"\r示例 3： 输入：s = \"\"\r输出：0\r提示： 0 \u003c= s.length \u003c= 3 * 10^4 s[i] 为 ‘(’ 或 ‘)’ ","date":"2015-02-01","objectID":"/leetcode/0032/:1:0","tags":null,"title":"0032：最长有效括号（★★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"分析 ","date":"2015-02-01","objectID":"/leetcode/0032/:2:0","tags":null,"title":"0032：最长有效括号（★★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"#1 基于 1249 ，可以得到不属于有效子串的括号的位置，找出最大的间隔即可。 def longestValidParentheses(self, s: str) -\u003e int: stack, invalid = [], [] for i, char in enumerate(s): if char == '(': stack.append(i) elif stack: stack.pop() else: invalid.append(i) invalid = [-1] + invalid + stack + [len(s)] return max(invalid[i + 1] - inva","date":"2015-02-01","objectID":"/leetcode/0032/:2:1","tags":null,"title":"0032：最长有效括号（★★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"#2 也可以用动态规划解决。 令 dp[r] 代表右括号 r 结尾的最长有效子串长度，并假设 r 所对应的是左括号 l： 如果 l-1 是左括号， dp[r] = r-l+1 如果 l-1 是右括号， dp[r] = r-l+1+dp[l-1] max(dp) 即为所求。 ","date":"2015-02-01","objectID":"/leetcode/0032/:2:2","tags":null,"title":"0032：最长有效括号（★★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"解答 def longestValidParentheses(self, s: str) -\u003e int: stack, dp = [], {} for j, char in enumerate(s): if char == '(': stack.append(j) elif stack: i = stack.pop() dp[j] = j - i + 1 + dp.get(i-1, 0) return max(dp.values(), default=0) 时间复杂度 O(N)，28 ms ","date":"2015-02-01","objectID":"/leetcode/0032/:3:0","tags":null,"title":"0032：最长有效括号（★★★）","uri":"/leetcode/0032/"},{"categories":null,"content":"题目 整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地， 如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列， 那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,","date":"2015-01-31","objectID":"/leetcode/0031/:1:0","tags":null,"title":"0031：下一个排列（★★）","uri":"/leetcode/0031/"},{"categories":null,"content":"分析 ","date":"2015-01-31","objectID":"/leetcode/0031/:2:0","tags":null,"title":"0031：下一个排列（★★）","uri":"/leetcode/0031/"},{"categories":null,"content":"#1 下一个更大的排列就是增加得最小的排列。 若后缀 nums[i:] 能够增大，nums[:i] 就应该保持不变 从后往前，找到第一个能增大的后缀 nums[i:]，问题转为求 nums[i:] 的下一个排列 要让 nums[i] 增加得最小，应该从 nums[i+1:] 中找到比 nums[i] 大的最小数 nums[j]，替换到 nums[i] 然后重新排列 nums[i+1:] 使其最小即可 def nextPermutation(self, nums: List[int]) -\u003e None: n = len(nums) i = n-2 while i \u003e= 0 and nums[i]","date":"2015-01-31","objectID":"/leetcode/0031/:2:1","tags":null,"title":"0031：下一个排列（★★）","uri":"/leetcode/0031/"},{"categories":null,"content":"#2 观察发现： nums[i+1:] 不能增大，故 nums[i+1:] 单调递减 因此从后往前遍历，找到第一个满足 nums[j]\u003enums[i] 的 j 即可 替换后 nums[i+1:] 依然单调递减，因此反转即可 ","date":"2015-01-31","objectID":"/leetcode/0031/:2:2","tags":null,"title":"0031：下一个排列（★★）","uri":"/leetcode/0031/"},{"categories":null,"content":"解答 def nextPermutation(self, nums: List[int]) -\u003e None: n = len(nums) i = n-2 while i \u003e= 0 and nums[i] \u003e= nums[i+1]: i -= 1 if i \u003e= 0: j = n-1 while nums[j] \u003c= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] l, r = i+1, n-1 while l \u003c r: nums[l], nums[r] = nums[r], nums[l] l += 1 r -= 1 时间复杂度 O(N)","date":"2015-01-31","objectID":"/leetcode/0031/:3:0","tags":null,"title":"0031：下一个排列（★★）","uri":"/leetcode/0031/"},{"categories":null,"content":"题目 给定一个字符串 s 和一些 长度相同 的单词 words 。 找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。 示例 1： 输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\r输出：[0,9]\r解释：\r从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。\r输出的顺序不重要, [9,0] 也是有效答案。\r示例 2： 输入：s = \"wordgoodgoodgoodbestword","date":"2015-01-30","objectID":"/leetcode/0030/:1:0","tags":null,"title":"0030：串联所有单词的子串（★★★）","uri":"/leetcode/0030/"},{"categories":null,"content":"分析 0438 的升级版，遍历 sum(words) 长度的子串，用 Counter 判断是否符合即可。 设每个单词的长度为 x， 则子串 [i,j] 的 Counter 可以由子串 [i-x, j-x] 的递推得到。 ","date":"2015-01-30","objectID":"/leetcode/0030/:2:0","tags":null,"title":"0030：串联所有单词的子串（★★★）","uri":"/leetcode/0030/"},{"categories":null,"content":"解答 def findSubstring(self, s: str, words: List[str]) -\u003e List[int]: m, n, x = len(s), len(words), len(words[0]) res, ct0 = [], Counter(words) for start in range(x): ct = Counter() for j in range(start+x, m+1, x): ct[s[j-x:j]] += 1 if j \u003e start + n*x: old = s[j-(n+1)*x:j-n*x] ct[old] -= 1 if ct[old] =","date":"2015-01-30","objectID":"/leetcode/0030/:3:0","tags":null,"title":"0030：串联所有单词的子串（★★★）","uri":"/leetcode/0030/"},{"categories":null,"content":"题目 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 示例 1: 输入: dividend = 10, divisor = 3\r输出: 3\r解释: 10/3 = truncate(3.33333..) = truncate(3) = 3\r示例 2: 输入: dividend = 7, divisor = -3","date":"2015-01-29","objectID":"/leetcode/0029/:1:0","tags":null,"title":"0029：两数相除（★★）","uri":"/leetcode/0029/"},{"categories":null,"content":"分析 ","date":"2015-01-29","objectID":"/leetcode/0029/:2:0","tags":null,"title":"0029：两数相除（★★）","uri":"/leetcode/0029/"},{"categories":null,"content":"#1 最简单的想法就是把两个数都变成正的，然后被除数不断的减去除数直到小于除数为止，最后再加上正负号。 溢出的唯一可能是 −2^31 除以 -1 等于 2^31。 def divide(self, dividend: int, divisor: int) -\u003e int: res, flag = 0, int(dividend ^ divisor \u003e= 0) m, n = abs(dividend), abs(divisor) while m \u003e= n: m -= n res += 1 res = res if flag else -res return min(res, 2147483647)","date":"2015-01-29","objectID":"/leetcode/0029/:2:1","tags":null,"title":"0029：两数相除（★★）","uri":"/leetcode/0029/"},{"categories":null,"content":"#2 显然超时是因为两个数的逼近太慢。考虑将除数不断自加，相当于乘 2，就可以快速的逼近了。 以求 divide(100, 3) 为例，将 3 不断自加直到 96 （3 的 32 倍），即转化为求 32+divide(4, 3) 因此求 divide(m, n) 的过程就是每一轮求最接近 m 的 n*(2^k)， 并更新 m -= n*(2^k), res+=2^k 进一步地，0\u003c=k\u003c=31。因此直接遍历 k 从 31 到 0，判断是否减去 n*(2^k) 即可。 ","date":"2015-01-29","objectID":"/leetcode/0029/:2:2","tags":null,"title":"0029：两数相除（★★）","uri":"/leetcode/0029/"},{"categories":null,"content":"解答 def divide(self, dividend: int, divisor: int) -\u003e int: res, flag = 0, int(dividend ^ divisor \u003e= 0) m, n = abs(dividend), abs(divisor) A = [(n, 1)] for _ in range(31): A.append((A[-1][0]+A[-1][0], A[-1][1]+A[-1][1])) res = 0 for i in range(31, -1, -1): if m \u003e= A[i][0]: m -= A[i][0] res += A[i][1] r","date":"2015-01-29","objectID":"/leetcode/0029/:3:0","tags":null,"title":"0029：两数相除（★★）","uri":"/leetcode/0029/"},{"categories":null,"content":"题目 实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。 如果不存在，则返回 -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例 1： 输入：haystack = \"hello\", needle = \"ll\"\r输出：2\r示例 2： 输入：haystack =","date":"2015-01-28","objectID":"/leetcode/0028/:1:0","tags":null,"title":"0028：实现 strStr()（★★★）","uri":"/leetcode/0028/"},{"categories":null,"content":"分析 ","date":"2015-01-28","objectID":"/leetcode/0028/:2:0","tags":null,"title":"0028：实现 strStr()（★★★）","uri":"/leetcode/0028/"},{"categories":null,"content":"#1 实际应用中当然是直接调包。 def strStr(self, haystack: str, needle: str) -\u003e int: return haystack.find(needle) 40 ms ","date":"2015-01-28","objectID":"/leetcode/0028/:2:1","tags":null,"title":"0028：实现 strStr()（★★★）","uri":"/leetcode/0028/"},{"categories":null,"content":"#2 自己写，最简单的就是遍历所有 len(needle) 长度的子串，判断是否等于 needle。 ","date":"2015-01-28","objectID":"/leetcode/0028/:2:2","tags":null,"title":"0028：实现 strStr()（★★★）","uri":"/leetcode/0028/"},{"categories":null,"content":"解答 def strStr(self, haystack: str, needle: str) -\u003e int: m, n = len(haystack), len(needle) for i in range(m-n+1): if haystack[i:i+n] == needle: return i return -1 时间复杂度O(M*N), 40 ms ","date":"2015-01-28","objectID":"/leetcode/0028/:3:0","tags":null,"title":"0028：实现 strStr()（★★★）","uri":"/leetcode/0028/"},{"categories":null,"content":"*附加 本题有个经典的 KMP 算法， 能在 O(M) 时间内完成。 def strStr(self, haystack: str, needle: str) -\u003e int: if not needle: return 0 m, n = len(haystack), len(needle) nxt, j = [-1], -1 for i in range(n): while j \u003e= 0 and needle[i] != needle[j]: j = nxt[j] j += 1 nxt.append(j) j = 0 for i in range(m): while j \u003e= 0 and ha","date":"2015-01-28","objectID":"/leetcode/0028/:4:0","tags":null,"title":"0028：实现 strStr()（★★★）","uri":"/leetcode/0028/"},{"categories":null,"content":"题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1： 输入：nums = [3,2,2,3], val = 3\r输出：2, nums = [2,2]\r解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。\r例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，","date":"2015-01-27","objectID":"/leetcode/0027/:1:0","tags":null,"title":"0027：移除元素","uri":"/leetcode/0027/"},{"categories":null,"content":"分析 和 0026 的思路完全相同，还更简单一点。 ","date":"2015-01-27","objectID":"/leetcode/0027/:2:0","tags":null,"title":"0027：移除元素","uri":"/leetcode/0027/"},{"categories":null,"content":"解答 def removeElement(self, nums: List[int], val: int) -\u003e int: i = 0 for num in nums: if num != val: nums[i] = num i += 1 return i 32 ms ","date":"2015-01-27","objectID":"/leetcode/0027/:3:0","tags":null,"title":"0027：移除元素","uri":"/leetcode/0027/"},{"categories":null,"content":"题目 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ， 返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。 更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1： 输入：nums = [1,1,2]\r输出：2, nums = [1,2]\r解释：函数应该","date":"2015-01-26","objectID":"/leetcode/0026/:1:0","tags":null,"title":"0026：删除排序数组中的重复项","uri":"/leetcode/0026/"},{"categories":null,"content":"分析 先想想用额外数组怎么做，就是遍历到不重复的元素就添加到新数组。 不用额外数组的话，就将原数组的相应位置赋值即可。 ","date":"2015-01-26","objectID":"/leetcode/0026/:2:0","tags":null,"title":"0026：删除排序数组中的重复项","uri":"/leetcode/0026/"},{"categories":null,"content":"解答 def removeDuplicates(self, nums: List[int]) -\u003e int: i = 0 for num in nums: if i \u003c 1 or num != nums[i-1]: nums[i] = num i += 1 return i 32 ms ","date":"2015-01-26","objectID":"/leetcode/0026/:3:0","tags":null,"title":"0026：删除排序数组中的重复项","uri":"/leetcode/0026/"},{"categories":null,"content":"题目 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例 1： 输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5] 示例 2： 输入：head = [1,2,3,4,5], k = 3 输出：[3,2,1,4,5] 提示： 链表中的节点数目为 n 1 \u003c= k \u003c= n \u003c= 5000 0 \u003c= Node.val \u003c= 1000 进阶：你可以设计一个只用 O(1","date":"2015-01-25","objectID":"/leetcode/0025/:1:0","tags":null,"title":"0025：K 个一组翻转链表（★★★）","uri":"/leetcode/0025/"},{"categories":null,"content":"分析 0024 的升级版。 链表前新建一个哑节点，指针 p 初始指向哑节点 当 p 后面存在 k 个节点时，将这一段翻转 将 p 移动 k 步准备下一轮翻转，如此循环即可 反转某段链表的方法可以参考 0092。 ","date":"2015-01-25","objectID":"/leetcode/0025/:2:0","tags":null,"title":"0025：K 个一组翻转链表（★★★）","uri":"/leetcode/0025/"},{"categories":null,"content":"解答 def reverseKGroup(self, head: ListNode, k: int) -\u003e ListNode: dummy = p = ListNode(next=head) while True: fast = p for _ in range(k): fast = fast.next if not fast: return dummy.next tail = p.next for _ in range(k - 1): tmp = tail.next tail.next = tmp.next tmp.next = p.next p.next = tmp p = tail 44","date":"2015-01-25","objectID":"/leetcode/0025/:3:0","tags":null,"title":"0025：K 个一组翻转链表（★★★）","uri":"/leetcode/0025/"},{"categories":null,"content":"题目 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 \u003c= Node.val \u003c= 100 ","date":"2015-01-24","objectID":"/leetcode/0024/:1:0","tags":null,"title":"0024：两两交换链表中的节点（★）","uri":"/leetcode/0024/"},{"categories":null,"content":"分析 新建一个链表前的哑节点，指针 p 初始指向哑节点 当 p 后面存在至少两个节点时，改变 p 和两个节点的指向来交换节点 再把 p 移动两步准备下一轮交换，如此循环即可 ","date":"2015-01-24","objectID":"/leetcode/0024/:2:0","tags":null,"title":"0024：两两交换链表中的节点（★）","uri":"/leetcode/0024/"},{"categories":null,"content":"解答 def swapPairs(self, head: ListNode) -\u003e ListNode: dummy = p = ListNode(next=head) while p.next and p.next.next: q = p.next p.next = p.next.next q.next = q.next.next p.next.next = q p = q return dummy.next 28 ms ","date":"2015-01-24","objectID":"/leetcode/0024/:3:0","tags":null,"title":"0024：两两交换链表中的节点（★）","uri":"/leetcode/0024/"},{"categories":null,"content":"题目 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]]\r输出：[1,1,2,3,4,4,5,6]\r解释：链表数组如下：\r[\r1-\u003e4-\u003e5,\r1-\u003e3-\u003e4,\r2-\u003e6\r]\r将它们合并到一个有序链表中得到。\r1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6\r示例 2： 输入：lists = []\r输出：[]\r示例 3： 输入：lists = [[]]\r输出：[]\r提示： k == lists.length 0 \u003c= k \u003c= 10^4 0 \u003c= lists[i].l","date":"2015-01-23","objectID":"/leetcode/0023/:1:0","tags":null,"title":"0023：合并K个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"分析 ","date":"2015-01-23","objectID":"/leetcode/0023/:2:0","tags":null,"title":"0023：合并K个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"#1 本题类似于归并排序，可以用分治法。 def mergeKLists(self, lists: List[ListNode]) -\u003e ListNode: def merge(l1, l2): dummy = l3 = ListNode() while l1 and l2: if l1.val \u003c= l2.val: l3.next = l1 l1 = l1.next else: l3.next = l2 l2 = l2.next l3 = l3.next l3.next = l1 if l1 else l2 return dummy.next n = len(lists) if n \u003c 2:","date":"2015-01-23","objectID":"/leetcode/0023/:2:1","tags":null,"title":"0023：合并K个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"#2 也可以维护一个堆，初始将每个链表的头节点的值入堆，然后每轮弹出最小数， 将对应的链表前进一步，并将新的值入堆。 ","date":"2015-01-23","objectID":"/leetcode/0023/:2:2","tags":null,"title":"0023：合并K个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"解答 def mergeKLists(self, lists: List[ListNode]) -\u003e ListNode: pq = [(node.val, i) for i, node in enumerate(lists) if node] heapify(pq) dummy = p = ListNode(next=None) while pq: val, i = heappop(pq) p.next = ListNode(val) p = p.next if lists[i].next: lists[i] = lists[i].next heappush(pq, (lists[i].val","date":"2015-01-23","objectID":"/leetcode/0023/:3:0","tags":null,"title":"0023：合并K个升序链表（★★）","uri":"/leetcode/0023/"},{"categories":null,"content":"题目 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 输入：n = 3\r输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\r示例 2： 输入：n = 1\r输出：[\"()\"]\r提示： 1 \u003c= n \u003c= 8 ","date":"2015-01-22","objectID":"/leetcode/0022/:1:0","tags":null,"title":"0022：括号生成（★★）","uri":"/leetcode/0022/"},{"categories":null,"content":"分析 典型的回溯问题，每一步添加 ‘(’ 或 ‘)’，若无效则回到上一步。 ","date":"2015-01-22","objectID":"/leetcode/0022/:2:0","tags":null,"title":"0022：括号生成（★★）","uri":"/leetcode/0022/"},{"categories":null,"content":"解答 def generateParenthesis(self, n: int) -\u003e List[str]: def dfs(l, r, tmp): if l \u003e n or r \u003e l: return if r == n: res.append(tmp) return dfs(l + 1, r, tmp + '(') dfs(l, r + 1, tmp + ')') res = [] dfs(0, 0, '') return res 时间复杂度 O(N)，36 ms ","date":"2015-01-22","objectID":"/leetcode/0022/:3:0","tags":null,"title":"0022：括号生成（★★）","uri":"/leetcode/0022/"},{"categories":null,"content":"题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1: 输入：l1 = [1,2,4], l2 = [1,3,4]\r输出：[1,1,2,3,4,4]\r示例 2： 输入：l1 = [], l2 = []\r输出：[]\r示例 3： 输入：l1 = [], l2 = [0]\r输出：[0]\r提示： 两个链表的节点数目范围是 [0, 50] -100 \u003c= Node.val \u003c= 100 l1 和 l2 均按 非递减顺序 排列 ","date":"2015-01-21","objectID":"/leetcode/0021/:1:0","tags":null,"title":"0021：合并两个有序链表（★）","uri":"/leetcode/0021/"},{"categories":null,"content":"分析 与归并两个有序数组的思路一样，用双指针即可。 区别在于这里是拼接，所以不需要造一个新链表，只需要建一个哑结点即可。 ","date":"2015-01-21","objectID":"/leetcode/0021/:2:0","tags":null,"title":"0021：合并两个有序链表（★）","uri":"/leetcode/0021/"},{"categories":null,"content":"解答 def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -\u003e Optional[ListNode]: dummy = p = ListNode() while list1 and list2: if list1.val \u003c= list2.val: p.next = list1 list1 = list1.next else: p.next = list2 list2 = list2.next p = p.next p.next = list1 if list1 else list2 ret","date":"2015-01-21","objectID":"/leetcode/0021/:3:0","tags":null,"title":"0021：合并两个有序链表（★）","uri":"/leetcode/0021/"},{"categories":null,"content":"题目 给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1: 输入: \"()\"\r输出: true\r示例 2: 输入: \"()[]{}\"\r输出: true\r示例 3: 输入: \"(]\"\r输出: false\r示例 4: 输入: \"([)]\"\r输出: false\r示例 5: 输入: \"{[]}\"\r输出: true\r提示： 1 \u003c= s.length \u003c= 10^4 s 仅由括号 ‘()[]{}’ 组成 ","date":"2015-01-20","objectID":"/leetcode/0020/:1:0","tags":null,"title":"0020：有效的括号","uri":"/leetcode/0020/"},{"categories":null,"content":"分析 栈的典型应用，左括号入栈，右括号出栈栈顶。若栈顶不匹配或最终栈不空即返回 False。 ","date":"2015-01-20","objectID":"/leetcode/0020/:2:0","tags":null,"title":"0020：有效的括号","uri":"/leetcode/0020/"},{"categories":null,"content":"解答 def isValid(self, s: str) -\u003e bool: stack, d = [], dict(zip(')]}', '([{')) for char in s: if char not in d: stack.append(char) elif not stack or stack.pop() != d[char]: return False return not stack 时间复杂度 O(N)，32 ms ","date":"2015-01-20","objectID":"/leetcode/0020/:3:0","tags":null,"title":"0020：有效的括号","uri":"/leetcode/0020/"},{"categories":null,"content":"题目 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 输入：head = [1,2,3,4,5], n = 2\r输出：[1,2,3,5]\r示例 2： 输入：head = [1], n = 1\r输出：[]\r示例 3： 输入：head = [1,2], n = 1\r输出：[1]\r提示： 链表中结点的数目为 sz 1 \u003c= sz \u003c= 30 0 \u003c= Node.val \u003c= 100 1 \u003c= n \u003c= sz 进阶：你能尝试使用一趟扫描实现吗？ ","date":"2015-01-19","objectID":"/leetcode/0019/:1:0","tags":null,"title":"0019：删除链表的倒数第 N 个结点（★）","uri":"/leetcode/0019/"},{"categories":null,"content":"分析 可以用经典的快慢指针解法： 一开始快慢指针都指向哑结点 快指针先走 n 步 然后两个指针同时走直到快指针到尾部 这时慢指针指向的就是倒数第 n+1 个结点 ","date":"2015-01-19","objectID":"/leetcode/0019/:2:0","tags":null,"title":"0019：删除链表的倒数第 N 个结点（★）","uri":"/leetcode/0019/"},{"categories":null,"content":"解答 def removeNthFromEnd(self, head: ListNode, n: int) -\u003e ListNode: dummy = slow = fast = ListNode(next=head) for _ in range(n): fast = fast.next while fast.next: slow = slow.next fast = fast.next slow.next = slow.next.next return dummy.next 时间复杂度 O(N)，36 ms ","date":"2015-01-19","objectID":"/leetcode/0019/:3:0","tags":null,"title":"0019：删除链表的倒数第 N 个结点（★）","uri":"/leetcode/0019/"},{"categories":null,"content":"题目 你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 \u003c= a, b, c, d \u003c n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 输入：nums = [1,0,-1,0,-2,2], target = 0\r输出：[[-2,-1,1,2],[-2,0,0,2],[","date":"2015-01-18","objectID":"/leetcode/0018/:1:0","tags":null,"title":"0018：四数之和（★★）","uri":"/leetcode/0018/"},{"categories":null,"content":"分析 ","date":"2015-01-18","objectID":"/leetcode/0018/:2:0","tags":null,"title":"0018：四数之和（★★）","uri":"/leetcode/0018/"},{"categories":null,"content":"#1 类似 0015，不过是多加了一重循环。 def fourSum(self, nums: List[int], target: int) -\u003e List[List[int]]: nums.sort() d = {x: i for i, x in enumerate(nums)} res, n = [], len(nums) for i in range(n-3): if i and nums[i]==nums[i-1]: continue for j in range(i+1, n-2): if j\u003ei+1 and nums[j]==nums[j-1]: continue for k in","date":"2015-01-18","objectID":"/leetcode/0018/:2:1","tags":null,"title":"0018：四数之和（★★）","uri":"/leetcode/0018/"},{"categories":null,"content":"#2 本题的循环轮数较多，可以加强限制，例如： sum(nums[i:i+4])\u003etarget 时可以跳出循环 nums[i]+sum(nums[-3:])\u003ctarget 时，可以跳过 i ","date":"2015-01-18","objectID":"/leetcode/0018/:2:2","tags":null,"title":"0018：四数之和（★★）","uri":"/leetcode/0018/"},{"categories":null,"content":"解答 def fourSum(self, nums: List[int], target: int) -\u003e List[List[int]]: nums.sort() d = {x: i for i, x in enumerate(nums)} res, n = [], len(nums) for i in range(n-3): if sum(nums[i:i+4])\u003etarget: break if (i and nums[i]==nums[i-1]) or nums[i]+sum(nums[-3:])\u003ctarget: continue for j in range(i+1, n-2): i","date":"2015-01-18","objectID":"/leetcode/0018/:3:0","tags":null,"title":"0018：四数之和（★★）","uri":"/leetcode/0018/"},{"categories":null,"content":"题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 输入：digits = \"23\"\r输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\r示例 2： 输入：digits = \"\"\r输出：[]\r示例 3： 输入：digits = \"2\"\r输出：[\"a\",\"b\",\"c\"]\r提示： 0 \u003c= digits.length \u003c= 4 digits[i] 是范围 [‘2’, ‘9’] 的一个数字。 ","date":"2015-01-17","objectID":"/leetcode/0017/:1:0","tags":null,"title":"0017：电话号码的字母组合（★）","uri":"/leetcode/0017/"},{"categories":null,"content":"分析 可以递推前 i 个字符能代表的组合。 ","date":"2015-01-17","objectID":"/leetcode/0017/:2:0","tags":null,"title":"0017：电话号码的字母组合（★）","uri":"/leetcode/0017/"},{"categories":null,"content":"解答 def letterCombinations(self, digits: str) -\u003e List[str]: d = dict(zip('23456789', ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'])) res = [] for x in digits: res = [sub+c for c in d[x] for sub in res or ['']] return res 52 ms ","date":"2015-01-17","objectID":"/leetcode/0017/:3:0","tags":null,"title":"0017：电话号码的字母组合（★）","uri":"/leetcode/0017/"},{"categories":null,"content":"题目 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 示例 1： 输入：nums = [-1,2,1,-4], target = 1\r输出：2\r解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。\r示例 2： 输入：nums = [0,0,0], target = 1\r输出：0\r提示： 3 \u003c= nums.length \u003c= 1000 -1000 \u003c= nums[i] \u003c= 1000 -10^4 \u003c= target \u003c= ","date":"2015-01-16","objectID":"/leetcode/0016/:1:0","tags":null,"title":"0016：最接近的三数之和（★★）","uri":"/leetcode/0016/"},{"categories":null,"content":"分析 ","date":"2015-01-16","objectID":"/leetcode/0016/:2:0","tags":null,"title":"0016：最接近的三数之和（★★）","uri":"/leetcode/0016/"},{"categories":null,"content":"#1 类似 0015 ，可以先排序再取元组 \u003ca, b, c\u003e。 但本题最后一个数 c 不能直接用哈希表获得。 要查找一个最接近 target-a-b 的数，容易想到用二分查找。 def threeSumClosest(self, nums: List[int], target: int) -\u003e int: nums.sort() res, n = float('inf'), len(nums) for i in range(n-2): for j in range(i+1, n-1): t0 = target-nums[i]-nums[j] pos = bisect_left(nums, t0","date":"2015-01-16","objectID":"/leetcode/0016/:2:1","tags":null,"title":"0016：最接近的三数之和（★★）","uri":"/leetcode/0016/"},{"categories":null,"content":"#2 还有个更巧妙的双指针解法。 排序后先固定数 nums[i]，然后寻找 nums[j]、nums[k] 使得两数之和最接近 target-nums[i]。 初始指针 j、k 分别指向 i+1, n-1。 如果 nums[j]+nums[k]\u003ctarget-nums[i]，则 nums[j] 与任意 [j+1,k-1] 内的数相加都更小，离 target 更远， 故可以不再考虑 nums[j]，缩小查找范围为 [j+1,k] 同理，如果 nums[j]+nums[k]\u003ctarget-nums[i]，可以缩小查找范围为 [j, k-1] 循环操作直到 j、k 相遇，取过程中最接近的和即可 ","date":"2015-01-16","objectID":"/leetcode/0016/:2:2","tags":null,"title":"0016：最接近的三数之和（★★）","uri":"/leetcode/0016/"},{"categories":null,"content":"解答 def threeSumClosest(self, nums: List[int], target: int) -\u003e int: nums.sort() res, n = float('inf'), len(nums) for i in range(n - 2): j, k = i + 1, n - 1 while j \u003c k: s = nums[i] + nums[j] + nums[k] if abs(s - target) \u003c abs(res - target): res = s if s \u003c target: j += 1 else: k -= 1 return res 时间复杂度 ","date":"2015-01-16","objectID":"/leetcode/0016/:3:0","tags":null,"title":"0016：最接近的三数之和（★★）","uri":"/leetcode/0016/"},{"categories":null,"content":"题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？ 请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 输入：nums = [-1,0,1,2,-1,-4]\r输出：[[-1,-1,2],[-1,0,1]]\r示例 2： 输入：nums = []\r输出：[]\r示例 3： 输入：nums = [0]\r输出：[]\r提示： 0 \u003c= nums.length \u003c= 3000 -10^5 \u003c= nums[i] \u003c= 10^5 ","date":"2015-01-15","objectID":"/leetcode/0015/:1:0","tags":null,"title":"0015：三数之和（★★）","uri":"/leetcode/0015/"},{"categories":null,"content":"分析 取不重复元组的问题，采用排序并跳过相同数字的通用方法即可。 然后类似 0001 ，可以用哈希表优化最后一层的查找。 ","date":"2015-01-15","objectID":"/leetcode/0015/:2:0","tags":null,"title":"0015：三数之和（★★）","uri":"/leetcode/0015/"},{"categories":null,"content":"解答 def threeSum(self, nums: List[int]) -\u003e List[List[int]]: nums.sort() d = {num: i for i, num in enumerate(nums)} res, n = [], len(nums) for i in range(n - 2): if i and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 1): if j \u003e i + 1 and nums[j] == nums[j - 1]: continue k = d.get(-nums[i]","date":"2015-01-15","objectID":"/leetcode/0015/:3:0","tags":null,"title":"0015：三数之和（★★）","uri":"/leetcode/0015/"},{"categories":null,"content":"题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “\"。 示例 1： 输入：strs = [\"flower\",\"flow\",\"flight\"]\r输出：\"fl\"\r示例 2： 输入：strs = [\"dog\",\"racecar\",\"car\"]\r输出：\"\"\r解释：输入不存在公共前缀。\r提示： 0 \u003c= strs.length \u003c= 200 0 \u003c= strs[i].length \u003c= 200 strs[i] 仅由小写英文字母组成 ","date":"2015-01-14","objectID":"/leetcode/0014/:1:0","tags":null,"title":"0014：最长公共前缀","uri":"/leetcode/0014/"},{"categories":null,"content":"分析 遍历判断即可。 ","date":"2015-01-14","objectID":"/leetcode/0014/:2:0","tags":null,"title":"0014：最长公共前缀","uri":"/leetcode/0014/"},{"categories":null,"content":"解答 def longestCommonPrefix(self, strs: List[str]) -\u003e str: res = '' for row in zip(*strs): if len(set(row)) != 1: break res += row[0] return res 28 ms ","date":"2015-01-14","objectID":"/leetcode/0014/:3:0","tags":null,"title":"0014：最长公共前缀","uri":"/leetcode/0014/"},{"categories":null,"content":"题目 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值\rI 1\rV 5\rX 10\rL 50\rC 100\rD 500\rM 1000\r例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5","date":"2015-01-13","objectID":"/leetcode/0013/:1:0","tags":null,"title":"0013：罗马数字转整数（★）","uri":"/leetcode/0013/"},{"categories":null,"content":"分析 观察发现，如果小数字放在大数字左边，则小数字代表负数。因此遍历判断即可。 ","date":"2015-01-13","objectID":"/leetcode/0013/:2:0","tags":null,"title":"0013：罗马数字转整数（★）","uri":"/leetcode/0013/"},{"categories":null,"content":"解答 def romanToInt(self, s: str) -\u003e int: d = dict(zip('IVXLCDM', [1, 5, 10, 50, 100, 500, 1000])) A = list(map(d.get, s)) return sum(-A[i] if A[i]\u003cA[i+1] else A[i] for i in range(len(A)-1)) + A[-1] 32 ms ","date":"2015-01-13","objectID":"/leetcode/0013/:3:0","tags":null,"title":"0013：罗马数字转整数（★）","uri":"/leetcode/0013/"},{"categories":null,"content":"题目 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值\rI 1\rV 5\rX 10\rL 50\rC 100\rD 500\rM 1000\r例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。 数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。 这个特殊的规则只适用于以下六种情况： I 可以放在 V ","date":"2015-01-12","objectID":"/leetcode/0012/:1:0","tags":null,"title":"0012：整数转罗马数字（★）","uri":"/leetcode/0012/"},{"categories":null,"content":"分析 从大到小放字符，如果数字大于 1000，就先放 M 直到剩余数小于 1000，如果还大于 900，就放 CM，依此类推。 ","date":"2015-01-12","objectID":"/leetcode/0012/:2:0","tags":null,"title":"0012：整数转罗马数字（★）","uri":"/leetcode/0012/"},{"categories":null,"content":"解答 def intToRoman(self, num: int) -\u003e str: d = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")] res = '' for value, symbol in d: res += symbol * (num // value) num %= value return res 56 ms ","date":"2015-01-12","objectID":"/leetcode/0012/:3:0","tags":null,"title":"0012：整数转罗马数字（★）","uri":"/leetcode/0012/"},{"categories":null,"content":"题目 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 示例 1： 输入：[1,8,6,2,5,4,8,3,7]\r输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。\r在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\r示例 2： 输入：height = [1,1]\r输出：1\r提示： n == height.length 2 \u003c= n \u003c=","date":"2015-01-11","objectID":"/leetcode/0011/:1:0","tags":null,"title":"0011：盛最多水的容器（★★★）","uri":"/leetcode/0011/"},{"categories":null,"content":"分析 本题是经典的双指针问题。 初始指针 i、j 分别指向 height 的首尾，组成容器 C。 如果 height[i]\u003c=height[j]，则 i 与任意 [i+1,j-1] 内的线组成的容器都小于 C， 故可以不再考虑 height[i]，缩小查找范围为 [i+1,j] 同理，如果 height[i]\u003e=height[j]，可以缩小查找范围为 [i, j-1] 循环操作直到 i、j 相遇，取过程中的最大容器即可。 ","date":"2015-01-11","objectID":"/leetcode/0011/:2:0","tags":null,"title":"0011：盛最多水的容器（★★★）","uri":"/leetcode/0011/"},{"categories":null,"content":"解答 def maxArea(self, height: List[int]) -\u003e int: res, i, j = 0, 0, len(height)-1 while i \u003c j: res = max(res, (j-i)*min(height[i], height[j])) if height[i] \u003c= height[j]: i += 1 else: j -= 1 return res 236 ms ","date":"2015-01-11","objectID":"/leetcode/0011/:3:0","tags":null,"title":"0011：盛最多水的容器（★★★）","uri":"/leetcode/0011/"},{"categories":null,"content":"题目 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 ‘.’ 匹配任意单个字符 ‘*’ 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。 示例 1： 输入：s = \"aa\", p = \"a\"\r输出：false\r解释：\"a\" 无法匹配 \"aa\" 整个字符串。\r示例 2: 输入：s = \"aa\", p = \"a*\"\r输出：true\r解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。\r因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\r示例 3： 输入：s =","date":"2015-01-10","objectID":"/leetcode/0010/:1:0","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"分析 ","date":"2015-01-10","objectID":"/leetcode/0010/:2:0","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"#1 最简单的就是直接调用正则。 def isMatch(self, s: str, p: str) -\u003e bool: return bool(re.match(p+'$', s)) 68 ms ","date":"2015-01-10","objectID":"/leetcode/0010/:2:1","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"#2 尝试自己实现。因为 ‘*’ 与前一个字符相关，所以考虑从后往前看。 如果 p[-1] == ‘*’，那么 p 匹配 s 必然是两种情况之一： ‘*’ 代表零个，p[:-2] 匹配 s ‘*’ 代表多个，p[-2] 匹配 s[-1] 且 p 匹配 s[:-1] 如果 p[-1] != ‘*’，那么 p 匹配 s 必然是 p[-1] 匹配 s[-1] 且 p[:-1] 匹配 s[:-1]。 都能转成递归子问题。注意到有重复子问题，所以用记忆化递归。 ","date":"2015-01-10","objectID":"/leetcode/0010/:2:2","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"解答 def isMatch(self, s: str, p: str) -\u003e bool: @lru_cache(None) def dfs(s, p): if not p: return not s if p[-1] == '*': return dfs(s, p[:-2]) or (bool(s) and p[-2] in [s[-1],'.'] and dfs(s[:-1], p)) return bool(s) and p[-1] in [s[-1],'.'] and dfs(s[:-1], p[:-1]) return dfs(s, p) 40 ms ","date":"2015-01-10","objectID":"/leetcode/0010/:3:0","tags":null,"title":"0010：正则表达式匹配（★★）","uri":"/leetcode/0010/"},{"categories":null,"content":"题目 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 示例 1： 输入：x = 121\r输出：true\r示例 2： 输入：x = -121\r输出：false\r解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\r示例 3： 输入：x = 10\r输出：false\r解释：从右向左读, 为 01 。因此它不是一个回文数。\r提示： -2^31 \u003c= x \u003c= 2^31 - 1 进阶：你能不将整数转为字符串来解决这个问","date":"2015-01-09","objectID":"/leetcode/0009/:1:0","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"分析 ","date":"2015-01-09","objectID":"/leetcode/0009/:2:0","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"#1 最简单的就是转为字符串判断。 def isPalindrome(self, x: int) -\u003e bool: return str(x) == str(x)[::-1] 80 ms ","date":"2015-01-09","objectID":"/leetcode/0009/:2:1","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"#2 也可以类似 0007 将整数反转，判断是否相等。 注意负数必然不是回文数。 ","date":"2015-01-09","objectID":"/leetcode/0009/:2:2","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"解答 def isPalindrome(self, x: int) -\u003e bool: if x \u003c 0: return False y, tmp = 0, x while tmp: y = y * 10 + tmp % 10 tmp //= 10 return y == x 72 ms ","date":"2015-01-09","objectID":"/leetcode/0009/:3:0","tags":null,"title":"0009：回文数","uri":"/leetcode/0009/"},{"categories":null,"content":"题目 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，“123” -\u003e 123， “0032” -\u003e 32）。如果没有读入数字，则整数为 0 。 必要","date":"2015-01-08","objectID":"/leetcode/0008/:1:0","tags":null,"title":"0008：字符串转换整数 (atoi)（★）","uri":"/leetcode/0008/"},{"categories":null,"content":"分析 最直接的就是用正则提取出整数，再判断是否溢出。 ","date":"2015-01-08","objectID":"/leetcode/0008/:2:0","tags":null,"title":"0008：字符串转换整数 (atoi)（★）","uri":"/leetcode/0008/"},{"categories":null,"content":"解答 def myAtoi(self, s: str) -\u003e int: tmp = re.match('[+-]?\\d+', s.strip()) return max(min(int(tmp.group()), 2**31-1), -2**31) if tmp else 0 36 ms ","date":"2015-01-08","objectID":"/leetcode/0008/:3:0","tags":null,"title":"0008：字符串转换整数 (atoi)（★）","uri":"/leetcode/0008/"},{"categories":null,"content":"题目 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−2^31, 2^31 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123\r输出：321\r示例 2： 输入：x = -123\r输出：-321\r示例 3： 输入：x = 120\r输出：21\r示例 4： 输入：x = 0\r输出：0\r提示： -2^31 \u003c= x \u003c= 2^31 - 1 ","date":"2015-01-07","objectID":"/leetcode/0007/:1:0","tags":null,"title":"0007：整数反转","uri":"/leetcode/0007/"},{"categories":null,"content":"分析 ","date":"2015-01-07","objectID":"/leetcode/0007/:2:0","tags":null,"title":"0007：整数反转","uri":"/leetcode/0007/"},{"categories":null,"content":"#1 最直接的就是转为字符串反转，再判断是否溢出。 注意负数的负号。 def reverse(self, x: int) -\u003e int: y = int('-'*(x \u003c 0) + str(abs(x))[::-1]) return y if -2**31 \u003c= y \u003c2**31 else 0 40 ms ","date":"2015-01-07","objectID":"/leetcode/0007/:2:1","tags":null,"title":"0007：整数反转","uri":"/leetcode/0007/"},{"categories":null,"content":"#2 也可以按位依次构建，python 中不需要担心溢出。 ","date":"2015-01-07","objectID":"/leetcode/0007/:2:2","tags":null,"title":"0007：整数反转","uri":"/leetcode/0007/"},{"categories":null,"content":"解答 def reverse(self, x: int) -\u003e int: flag = -1 if x \u003c 0 else 1 x, y = abs(x), 0 while x: y = y * 10 + x % 10 x //= 10 return y*flag if -2**31 \u003c= y*flag \u003c 2**31 else 0 28 ms ","date":"2015-01-07","objectID":"/leetcode/0007/:3:0","tags":null,"title":"0007：整数反转","uri":"/leetcode/0007/"},{"categories":null,"content":"题目 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下： P A H N A P L S I I G Y I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“PAHNAPLSIIGYIR”。 请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows); 示例 1： 输入：s = \"PAYPALISHIRING\", numRows = 3 输出：\"PAHNAPLSIIGYIR\" 示例 2： ","date":"2015-01-06","objectID":"/leetcode/0006/:1:0","tags":null,"title":"0006：Z 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"分析 ","date":"2015-01-06","objectID":"/leetcode/0006/:2:0","tags":null,"title":"0006：Z 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"#1 最直接的就是模拟排列的过程。遍历 s，将每个字符添加到 Z 字形中对应的行，最后再拼接所有行即可。 判断字符所属行时，可以用 flag 标志方向，遇到边界时调转方向。 def convert(self, s: str, numRows: int) -\u003e str: if numRows \u003c 2: return s res = [''] * numRows row, flag = 0, 1 for char in s: res[row] += char row += flag flag *= -1 if row in [0, numRows-1] else 1 return ''.join(","date":"2015-01-06","objectID":"/leetcode/0006/:2:1","tags":null,"title":"0006：Z 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"#2 也可以用数学方法直接求出每个下标对应的行。 显然变换周期为 loop=max(1, 2*(numRows-1))，一个周期中的第 k 个字符属于第 min(k, loop-k) 行。 ","date":"2015-01-06","objectID":"/leetcode/0006/:2:2","tags":null,"title":"0006：Z 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"解答 def convert(self, s: str, numRows: int) -\u003e str: loop = max(1, (numRows-1)*2) A = ['']*numRows for i, c in enumerate(s): k = min(i%loop, loop-i%loop) A[k] += c return ''.join(A) 64 ms ","date":"2015-01-06","objectID":"/leetcode/0006/:3:0","tags":null,"title":"0006：Z 字形变换（★）","uri":"/leetcode/0006/"},{"categories":null,"content":"题目 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案。 示例 2： 输入：s = \"cbbd\" 输出：\"bb\" 提示： 1 \u003c= s.length \u003c= 1000 s 仅由数字和英文字母组成 ","date":"2015-01-05","objectID":"/leetcode/0005/:1:0","tags":null,"title":"0005：最长回文子串（★★★）","uri":"/leetcode/0005/"},{"categories":null,"content":"分析 ","date":"2015-01-05","objectID":"/leetcode/0005/:2:0","tags":null,"title":"0005：最长回文子串（★★★）","uri":"/leetcode/0005/"},{"categories":null,"content":"#1 暴力法是直接遍历所有子串，判断是否是回文。 显然有很多不必要的判断，观察发现回文子串是可以递推的。 s[i:j+1] 是回文等价于 s[i-1:j] 是回文且 s[i]==s[j]。 因此考虑从短到长递推判断所有子串，取最长的即可。 注意到递推中很多子串是重复使用的，因此可以保存中间结果，避免重复递推。 这种递推方式被称为区间 dp。 具体实现时，令 dp[i][j] 代表 s[i:j+1] 是否回文，递推式为： dp[i][j] = dp[i+1][j-1] and s[i]==s[j] dp[i][j] 依赖 dp[i+1][j-1]，要特别注意遍历顺序： 可以先遍历 j，再遍历 i","date":"2015-01-05","objectID":"/leetcode/0005/:2:1","tags":null,"title":"0005：最长回文子串（★★★）","uri":"/leetcode/0005/"},{"categories":null,"content":"#2 注意到递推过程中假如 dp[i+1][j-1] 非真，那么就没必要递推 dp[i][j] 了。 因此考虑从初始的 dp[i][i-1] 或 dp[i][i] 往两边递推，一旦非真，就无需考虑了。 于是得到中心扩展法： 遍历所有中心 (i, i-1) 或 (i, i) 对于每个中心，往两边扩展找到最长的回文子串 过程中找到的最长的即为所求 def longestPalindrome(self, s: str) -\u003e str: def expand(l, r): while l and r\u003cn-1 and s[l-1]==s[r+1]: l -= 1 r += 1 return l, r r","date":"2015-01-05","objectID":"/leetcode/0005/:2:2","tags":null,"title":"0005：最长回文子串（★★★）","uri":"/leetcode/0005/"},{"categories":null,"content":"#3 还有个更巧妙的想法。 令 dp[j] 代表 s[:j] 的最长回文子串长度。那么: s[:j] 的回文子串要么是 s[:j-1] 的回文子串，要么是某个 s[i:j] 如果 s[i:j] 是回文子串，其长度是 s[i+1:j-1] 的长度加 2 因此 dp[j] 不可能超过 dp[j-1]+2，也就是说 dp[j] 只有 3 种可能值，分别判断即可。 这种递推方式则被称为线性 dp。 特别的，因为 dp[j] 只依赖 dp[j-1]，所以可以只用一个变量。 ","date":"2015-01-05","objectID":"/leetcode/0005/:2:3","tags":null,"title":"0005：最长回文子串（★★★）","uri":"/leetcode/0005/"},{"categories":null,"content":"解答 def longestPalindrome(self, s: str) -\u003e str: res, dp = '', 0 for j in range(1, len(s)+1): for L in [dp+1, min(dp+2, j)]: tmp = s[j-L:j] if tmp == tmp[::-1]: res, dp = tmp, L return res 时间复杂度 $O(N^2)$，104 ms ","date":"2015-01-05","objectID":"/leetcode/0005/:3:0","tags":null,"title":"0005：最长回文子串（★★★）","uri":"/leetcode/0005/"},{"categories":null,"content":"*附加 此题还有一个经典的的 Manacher算法 。 它在 O(N) 时间内不仅能找到最长回文子串，而且能得到所有中心子串的扩展距离。 因此在与回文相关的问题中，都可以试试能否用 Manacher 算法解决。 def longestPalindrome(self, s: str) -\u003e str: def expand(l, r): while l and r\u003clen(ss)-1 and ss[l-1]==ss[r+1]: l -= 1 r += 1 return (r-l)//2 pair, ss = (0, 0), '#' + '#'.join(s) + '#' A, center, ri","date":"2015-01-05","objectID":"/leetcode/0005/:4:0","tags":null,"title":"0005：最长回文子串（★★★）","uri":"/leetcode/0005/"},{"categories":null,"content":"有一天，小行星熊玛利亚星在宇宙的某处爆发，成就一群坠落地球的流星，使地球各处的熊发生异变。熊大举进食人类，人类再报以还击，结果造成没有战果和充满仇恨的恶性循环，直至两边不约而同筑起断绝之墙，期望以后互不侵犯……一天早上，呼啸山庄学园的学生——椿辉红羽和泉乃纯花，在学园的百合花坛里一同看见百合之花。二人于是成就“既为朋友，亦为恋人”的关系，并将花坛视为最重要的地方。就在此时，熊警报突然响起，揭示对方再度入侵人类世界，准备陷入混战。揭示这些熊的真实身份和目的之时，新谜题的出现带来新一波的怒涛，揭开背后华丽的每一幕……","date":"2015-01-05","objectID":"/anime/yurikuma_arashi/","tags":null,"title":"百合熊风暴","uri":"/anime/yurikuma_arashi/"},{"categories":null,"content":"简介 有一天，小行星熊玛利亚星在宇宙的某处爆发，成就一群坠落地球的流星，使地球各处的熊发生异变。熊大举进食人类，人类再报以还击，结果造成没有战果和充满仇恨的恶性循环，直至两边不约而同筑起断绝之墙，期望以后互不侵犯……一天早上，呼啸山庄学园的学生——椿辉红羽和泉乃纯花，在学园的百合花坛里一同看见百合之花。二人于是成就“既为朋友，亦为恋人”的关系，并将花坛视为最重要的地方。就在此时，熊警报突然响起，揭示对方再度入侵人类世界，准备陷入混战。揭示这些熊的真实身份和目的之时，新谜题的出现带来新一波的怒涛，揭开背后华丽的每一幕…… 制作人员： 导演：几原邦彦 脚本：伊神贵世 分镜：黑泽雅之、柴田胜纪、酒井","date":"2015-01-05","objectID":"/anime/yurikuma_arashi/:1:0","tags":null,"title":"百合熊风暴","uri":"/anime/yurikuma_arashi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 百合城银子 百合城 銀子、ゆりしろ ぎんこ、Yurishiro Ginko 女 荒川美穂 2 百合咲露露 百合ヶ咲 るる、ゆりがさき るる、Yurigasaki Lulu 女 生田善子 3 椿辉红羽 椿輝 紅羽、つばき くれは、Tsubaki Kureha 女 山根希美 4 Life Sexy らいふ・せくしー、Raifu Sekushi- 男 諏訪部順一 5 Life Cool らいふ・くーる、Raifu Ku-ru 男 斎賀みつき 6 Life Beauty 一生·优雅、らいふ・びゅーてぃー、Raifu Byu-thi- 男 山本和臣 7 泉乃纯花 泉乃","date":"2015-01-05","objectID":"/anime/yurikuma_arashi/:2:0","tags":null,"title":"百合熊风暴","uri":"/anime/yurikuma_arashi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 百合熊风暴 2015-01-05 12 9anime ","date":"2015-01-05","objectID":"/anime/yurikuma_arashi/:3:0","tags":null,"title":"百合熊风暴","uri":"/anime/yurikuma_arashi/"},{"categories":null,"content":"题目 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 提示： nums1.length == m nums2.length == n 0","date":"2015-01-04","objectID":"/leetcode/0004/:1:0","tags":null,"title":"0004：寻找两个正序数组的中位数（★★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"分析 ","date":"2015-01-04","objectID":"/leetcode/0004/:2:0","tags":null,"title":"0004：寻找两个正序数组的中位数（★★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"#1 最直接的就是合并后排序得到中位数。 def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003e float: nums, m, n = sorted(nums1+nums2), len(nums1), len(nums2) return (nums[(m+n-1)//2] + nums[(m+n)//2]) / 2 时间复杂度 $O((M+N)*log(M+N))$，44 ms ","date":"2015-01-04","objectID":"/leetcode/0004/:2:1","tags":null,"title":"0004：寻找两个正序数组的中位数（★★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"#2 有个巧妙的想法: 假设 nums1[i-1]\u003c=nums2[j] 且 nums2[j-1]\u003c=nums1[i]，nums1[:i] 和 nums2[:j] 就是最小的 i+j 个数 当 i+j==(m+n)//2 时，即找到了最小的一半数，即可求出中位数 因此遍历和为 (m+n)//2 的 \u003ci, j\u003e 对，找到满足 nums1[i-1]\u003c=nums2[j] 且 nums2[j-1]\u003c=nums1[i] 的即可 注意 i 递增时，nums1[i-1]、nums1[i] 递增，nums2[j]、nums2[j-1] 递减，因此遍历找到第一个满足 nums2[j-1]\u003c=nums1[i] 的","date":"2015-01-04","objectID":"/leetcode/0004/:2:2","tags":null,"title":"0004：寻找两个正序数组的中位数（★★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"#3 注意到如果 nums1[i] \u003e= nums2[j-1]，必然有 nums1[i+1] \u003e= nums2[j-2]，符合单调性，因此可以二分查找 i。 ","date":"2015-01-04","objectID":"/leetcode/0004/:2:3","tags":null,"title":"0004：寻找两个正序数组的中位数（★★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"解答 def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003e float: m, n = len(nums1), len(nums2) if m \u003e n: return self.findMedianSortedArrays(nums2, nums1) self.__class__.__getitem__ = lambda self, i: i == m or nums1[i] \u003e= nums2[(m+n)//2-i-1] i = bisect_left(self, True, 0, m) j = (m+n","date":"2015-01-04","objectID":"/leetcode/0004/:3:0","tags":null,"title":"0004：寻找两个正序数组的中位数（★★★）","uri":"/leetcode/0004/"},{"categories":null,"content":"题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 示例 4: 输入: s = \"\" 输出: 0 提示： 0 \u003c= s.len","date":"2015-01-03","objectID":"/leetcode/0003/:1:0","tags":null,"title":"0003：无重复字符的最长子串（★★）","uri":"/leetcode/0003/"},{"categories":null,"content":"分析 遍历每个位置 j 作为结尾，找符合条件的最长子串 [i, j] 即可。 发现遍历中 i 必然是不动或向右移的，因此是滑动窗口。 还可以用哈希表记录字符的上一个位置，加速 i 的移动。 ","date":"2015-01-03","objectID":"/leetcode/0003/:2:0","tags":null,"title":"0003：无重复字符的最长子串（★★）","uri":"/leetcode/0003/"},{"categories":null,"content":"解答 def lengthOfLongestSubstring(self, s: str) -\u003e int: res, i, d = 0, 0, {} for j, char in enumerate(s): i = max(i, d.get(char, -1)+1) res = max(res, j-i+1) d[char] = j return res 52 ms ","date":"2015-01-03","objectID":"/leetcode/0003/:3:0","tags":null,"title":"0003：无重复字符的最长子串（★★）","uri":"/leetcode/0003/"},{"categories":null,"content":"题目 你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的， 并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的","date":"2015-01-02","objectID":"/leetcode/0002/:1:0","tags":null,"title":"0002：两数相加（★）","uri":"/leetcode/0002/"},{"categories":null,"content":"分析 链表是逆序存储，所以取到的数字依次是个十百千位。很自然的想到普通人算加法的方式，先算低位，再结合进位算高位。 要注意边界条件，两个链表长度可能不一样，结果可能比两个链表都长，需要再添加新节点。 ","date":"2015-01-02","objectID":"/leetcode/0002/:2:0","tags":null,"title":"0002：两数相加（★）","uri":"/leetcode/0002/"},{"categories":null,"content":"解答 def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u003e ListNode: dummy = p = ListNode() carry = 0 while l1 or l2: a = l1.val if l1 else 0 b = l2.val if l2 else 0 s = a + b + carry p.next = ListNode(s % 10) carry = s // 10 p = p.next l1 = l1.next if l1 else l1 l2 = l2.next if l2 else l2 p.next = L","date":"2015-01-02","objectID":"/leetcode/0002/:3:0","tags":null,"title":"0002：两数相加（★）","uri":"/leetcode/0002/"},{"categories":null,"content":"题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数， 并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target =","date":"2015-01-01","objectID":"/leetcode/0001/:1:0","tags":null,"title":"0001：两数之和（★）","uri":"/leetcode/0001/"},{"categories":null,"content":"分析 ","date":"2015-01-01","objectID":"/leetcode/0001/:2:0","tags":null,"title":"0001：两数之和（★）","uri":"/leetcode/0001/"},{"categories":null,"content":"#1 最直接的就是是两次遍历，找出答案。 def twoSum(self, nums: List[int], target: int) -\u003e List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i, j] 时间复杂度 O(N^2)，2860 ms ","date":"2015-01-01","objectID":"/leetcode/0001/:2:1","tags":null,"title":"0001：两数之和（★）","uri":"/leetcode/0001/"},{"categories":null,"content":"#2 注意到第二层遍历等价于查询一个数，所以可以用哈希表节省时间。 边遍历边用哈希存储元素位置，每轮查询前面是否有对应的数即可。 ","date":"2015-01-01","objectID":"/leetcode/0001/:2:2","tags":null,"title":"0001：两数之和（★）","uri":"/leetcode/0001/"},{"categories":null,"content":"解答 def twoSum(self, nums: List[int], target: int) -\u003e List[int]: d = {} for j, num in enumerate(nums): if target-num in d: return [d[target-num], j] d[num] = j 时间复杂度 O(N)，28 ms ","date":"2015-01-01","objectID":"/leetcode/0001/:3:0","tags":null,"title":"0001：两数之和（★）","uri":"/leetcode/0001/"},{"categories":null,"content":"“日本动画展会”，是一项短篇动画系列企划，将由动画制作公司Khara和NICONICO视频网站运营方DWANGO共同负责实施。\n在既定的预算和时间内，动画制作者可以自由制作各种不分类型的短篇动画，然后在每周的星期五公开一集。\n除了原创动画之外，还接受外传动画、宣传动画、音乐视频等作品类型的制作。DWANGO和Khara在谈及该企划的理念时表示：“我们将会提供一个不限制创作表现的\n‘自由的创作平台’，探索在日本动画制作过程中的企划开发、研究开发、人才培养等方面的可能性”。DWANGO的川上量生会长还说道：“我们没有考虑过要收支平衡”。","date":"2014-11-07","objectID":"/anime/japan_animator_expo/","tags":null,"title":"日本动画（人）博览会","uri":"/anime/japan_animator_expo/"},{"categories":null,"content":"简介 “日本动画展会”，是一项短篇动画系列企划，将由动画制作公司Khara和NICONICO视频网站运营方DWANGO共同负责实施。 在既定的预算和时间内，动画制作者可以自由制作各种不分类型的短篇动画，然后在每周的星期五公开一集。 除了原创动画之外，还接受外传动画、宣传动画、音乐视频等作品类型的制作。DWANGO和Khara在谈及该企划的理念时表示：“我们将会提供一个不限制创作表现的 ‘自由的创作平台’，探索在日本动画制作过程中的企划开发、研究开发、人才培养等方面的可能性”。DWANGO的川上量生会长还说道：“我们没有考虑过要收支平衡”。 制作人员： 原作：凯乐股份有限公司、庵野秀明、安野梦洋","date":"2014-11-07","objectID":"/anime/japan_animator_expo/:1:0","tags":null,"title":"日本动画（人）博览会","uri":"/anime/japan_animator_expo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 日本动画（人）博览会 2014-11-07 35 下方 ","date":"2014-11-07","objectID":"/anime/japan_animator_expo/:2:0","tags":null,"title":"日本动画（人）博览会","uri":"/anime/japan_animator_expo/"},{"categories":null,"content":"本作的故事主要围绕追逐梦想的五名女生——宫森葵、安原绘麻、坂木静香、藤堂美沙、今井绿展开，是一部描写以白箱的完成为目标而奋斗的她们，每天遇到的麻烦以及策划工作时碰到的纠葛与挫折，还有制作组在制作作品时的团结和冲突的动画业界的日常的群像剧作品。 ","date":"2014-10-09","objectID":"/anime/shirobako/","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"简介 本作的故事主要围绕追逐梦想的五名女生——宫森葵、安原绘麻、坂木静香、藤堂美沙、今井绿展开，是一部描写以白箱的完成为目标而奋斗的她们，每天遇到的麻烦以及策划工作时碰到的纠葛与挫折，还有制作组在制作作品时的团结和冲突的动画业界的日常的群像剧作品。 制作人员： 原作：武藏野Animation 导演：水岛努 脚本：浦畑达彦、横手美智子、吉田玲子 分镜：筱原俊哉、驹井一也、柿本广大、平井义通 ","date":"2014-10-09","objectID":"/anime/shirobako/:1:0","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫森葵 宮森 あおい、みやもり あおい、Miyamori Aoi、みゃーもり、喵森 女 木村珠莉 2 安原绘麻 安原 絵麻、やすはら えま、Yasuhara Ema 女 佳村はるか 3 坂木静香 坂木 しずか、さかき しずか、Sakaki Shizuka、ずかちゃん 女 千菅春香 4 藤堂美沙 藤堂 美沙、とうどう みさ 女 髙野麻美 5 今井绿 今井 みどり、いまい みどり、Imai Midori、ディーゼル 女 大和田仁美 6 本田丰 本田豊、ほんだ ゆたか、Honda Yutaka 男 西地修哉 7 高梨太郎 高梨 太郎、たかなし たろう、Takana","date":"2014-10-09","objectID":"/anime/shirobako/:2:0","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 白箱 2014-10-09 24 樱花 2 剧场版 白箱 2020-02-29 1 樱花 ","date":"2014-10-09","objectID":"/anime/shirobako/:3:0","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"MAD ","date":"2014-10-09","objectID":"/anime/shirobako/:4:0","tags":null,"title":"白箱","uri":"/anime/shirobako/"},{"categories":null,"content":"　　有马公生的母亲一心想把有马培育成举世闻名的钢琴家，而有马也不负母亲的期望，在念小学时就赢得许多钢琴比赛的大奖。11岁的秋天，有马的母亲过世，从此他再也听不见自己弹奏的钢琴声，沮丧的他也只好放弃演奏，但在14岁那年，经由儿时玩伴的介绍，有马认识了小提琴手宫园薰，并被薰的自由奔放吸引，没想到薰竟开口邀请公生在比赛时担任她的伴奏… ","date":"2014-10-09","objectID":"/anime/your_lie_in_april/","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"简介 有马公生的母亲一心想把有马培育成举世闻名的钢琴家，而有马也不负母亲的期望，在念小学时就赢得许多钢琴比赛的大奖。11岁的秋天，有马的母亲过世，从此他再也听不见自己弹奏的钢琴声，沮丧的他也只好放弃演奏，但在14岁那年，经由儿时玩伴的介绍，有马认识了小提琴手宫园薰，并被薰的自由奔放吸引，没想到薰竟开口邀请公生在比赛时担任她的伴奏… 制作人员： 原作：新川直司 导演：石黑恭平 脚本：吉冈孝夫 分镜：神户守、石滨真史、柴山智隆、仓田绫子、黑木美幸、后藤圭二 ","date":"2014-10-09","objectID":"/anime/your_lie_in_april/:1:0","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 有马公生 有馬 公生、ありま こうせい、arima kousei、有马公主 男 花江夏樹 2 宫园薰 宫园香织、みやぞの かをり、Miyazono Kaori 女 種田梨沙 3 泽部椿 澤部 椿、さわべ つばき、Sawabe Tsubaki 女 佐倉綾音 4 渡亮太 渡 亮太、わたり りょうた、watari ryouta 男 逢坂良太 5 相座武士 相座 武士、あいざ たけし、aiza takeshi 男 梶裕貴 6 井川绘见 井川 絵見、いがわ えみ、igawa emi 女 早見沙織 7 有马早希 有馬 早希、ありま さき、Arima Saki 女 能登麻","date":"2014-10-09","objectID":"/anime/your_lie_in_april/:2:0","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 四月是你的谎言 2014-10-09 22 bilibili 2 四月是你的谎言 OAD 2015-05-15 1 bilibili ","date":"2014-10-09","objectID":"/anime/your_lie_in_april/:3:0","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"MAD ","date":"2014-10-09","objectID":"/anime/your_lie_in_april/:4:0","tags":null,"title":"四月是你的谎言","uri":"/anime/your_lie_in_april/"},{"categories":null,"content":"原本宁静的阿尔特里亚大陆，被黑龙及其魔物追随者的势力所席卷。乱世下，民不聊生。\n绰号小鱼的兰伯特，是生活在小村庄里的普通少年，却为了保护村庄，在误打误撞中作为小跟班加入了为讨伐黑龙而建立的英雄联盟。这支由精灵、魔法师、游侠和传奇战士组成的临时杂牌联盟，踏上了失落已久的古道，翻越诡异的丛林和奇幻的雪山寻觅黑龙的巢穴。可前方，却有意想不到的危机等着他们的到来。\n　　旅程的艰辛和奇异的境遇让兰伯特迅速成长起来，可他最终能找到属于自己的战斗的意义吗？","date":"2014-07-31","objectID":"/anime/dragon_nest/","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"简介 原本宁静的阿尔特里亚大陆，被黑龙及其魔物追随者的势力所席卷。乱世下，民不聊生。 绰号小鱼的兰伯特，是生活在小村庄里的普通少年，却为了保护村庄，在误打误撞中作为小跟班加入了为讨伐黑龙而建立的英雄联盟。这支由精灵、魔法师、游侠和传奇战士组成的临时杂牌联盟，踏上了失落已久的古道，翻越诡异的丛林和奇幻的雪山寻觅黑龙的巢穴。可前方，却有意想不到的危机等着他们的到来。 旅程的艰辛和奇异的境遇让兰伯特迅速成长起来，可他最终能找到属于自己的战斗的意义吗？ 制作人员： 动画制作：苏州米粒影视文化传播有限公司 制作协力：盛趣游戏 ","date":"2014-07-31","objectID":"/anime/dragon_nest/:1:0","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 莉雅 Liya 女 徐娇 ","date":"2014-07-31","objectID":"/anime/dragon_nest/:2:0","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙之谷：破晓奇兵 2014-07-31 1 bilibili 2 精灵王座 2016-08-19 1 樱花 ","date":"2014-07-31","objectID":"/anime/dragon_nest/:3:0","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"MAD ","date":"2014-07-31","objectID":"/anime/dragon_nest/:4:0","tags":null,"title":"龙之谷：破晓奇兵","uri":"/anime/dragon_nest/"},{"categories":null,"content":"海边村庄的老夫妇收养了一个内向的女主人公安娜。少女安娜内心封闭，终日在村中孤独的生活。某一天安娜遇到了神秘少女玛妮，并与她成为了好朋友。然而村中除了安娜，谁都不知道玛妮的存在。\n","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"简介 海边村庄的老夫妇收养了一个内向的女主人公安娜。少女安娜内心封闭，终日在村中孤独的生活。某一天安娜遇到了神秘少女玛妮，并与她成为了好朋友。然而村中除了安娜，谁都不知道玛妮的存在。 制作人员： 原作：Joan Gale Robinson 导演：米林宏昌 脚本：安藤雅司、丹羽圭子 音乐：村松崇继 美术监督：种田阳平 作画监督：稻村武志 ","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/:1:0","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐佐木杏奈 ささき あんな、Sasaki Anna 女 高月彩良 2 玛妮 Marnie、マーニー、Mānī 女 有村架純 ","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/:2:0","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 回忆中的玛妮 2014-07-19 1 樱花 ","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/:3:0","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"MAD ","date":"2014-07-19","objectID":"/anime/when_marnie_was_there/:4:0","tags":null,"title":"回忆中的玛妮","uri":"/anime/when_marnie_was_there/"},{"categories":null,"content":"讨厌念书，对日本史毫无兴趣的高中生三郎，某一天突然时光穿越到了战国时代。他在那里见到体弱多病的织田信长本人，而信长的相貌竟然与三郎一模一样。信长拜托三郎代替体弱多病自己，以织田信长的身分活下去…！？用全新的手法诠释出来的织田信长，叫人出乎意料之外却又莫名地符合信长形象的三郎。对历史发展可说是毫无头绪的他，在战国时代会如何生存下去？","date":"2014-07-11","objectID":"/anime/oda_nobunaga_concerto/","tags":null,"title":"信长协奏曲","uri":"/anime/oda_nobunaga_concerto/"},{"categories":null,"content":"简介 讨厌念书，对日本史毫无兴趣的高中生三郎，某一天突然时光穿越到了战国时代。他在那里见到体弱多病的织田信长本人，而信长的相貌竟然与三郎一模一样。信长拜托三郎代替体弱多病自己，以织田信长的身分活下去…！？用全新的手法诠释出来的织田信长，叫人出乎意料之外却又莫名地符合信长形象的三郎。对历史发展可说是毫无头绪的他，在战国时代会如何生存下去？ 制作人员： 原作：石井步 导演：富士川佑辅 脚本：高桥奈津子 分镜：森田纯平 音乐：横山克 ","date":"2014-07-11","objectID":"/anime/oda_nobunaga_concerto/:1:0","tags":null,"title":"信长协奏曲","uri":"/anime/oda_nobunaga_concerto/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 三郎 男 宮野真守 2 织田信长 男 梶裕貴 3 归蝶 女 水樹奈々 4 木下藤吉郎 田原伝二郎、木下秀吉、羽柴秀吉 男 中村悠一 5 阿市 女 悠木碧 6 池田恒兴 男 興津和幸 7 柴田胜家 男 小山力也 8 前田利家 男 浅沼晋太郎 ","date":"2014-07-11","objectID":"/anime/oda_nobunaga_concerto/:2:0","tags":null,"title":"信长协奏曲","uri":"/anime/oda_nobunaga_concerto/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 信长协奏曲 2014-07-11 10 bilibili ","date":"2014-07-11","objectID":"/anime/oda_nobunaga_concerto/:3:0","tags":null,"title":"信长协奏曲","uri":"/anime/oda_nobunaga_concerto/"},{"categories":null,"content":"星野裕（阿扁）是乒乓球天才，月本诚（笑匠）则是极具天赋的乒乓球好手。他们俩从小一起长大，同为片濑高中乒乓球队队员。在高校联赛中，遇上来自中国上海的孔文革、上届冠军风间龙一，关于乒乓联赛的成长的故事拉开序幕……","date":"2014-04-10","objectID":"/anime/ping_pong/","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"简介 星野裕（阿扁）是乒乓球天才，月本诚（笑匠）则是极具天赋的乒乓球好手。他们俩从小一起长大，同为片濑高中乒乓球队队员。在高校联赛中，遇上来自中国上海的孔文革、上届冠军风间龙一，关于乒乓联赛的成长的故事拉开序幕…… 制作人员： 原作：松本大洋 导演：汤浅政明 演出：上野史博、伊藤良太、伊藤秀树、久保田雄大 ","date":"2014-04-10","objectID":"/anime/ping_pong/:1:0","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 星野裕 阿扁、ほしの ゆたか、Hoshino Yutaka、ペコ 男 片山福十郎 2 月本诚 笑爷、つきもと　まこと、Tsukimoto　Makoto、スマイル 男 内山昂輝 3 孔文革 コン・ウエンガ、チャイナ、辻堂文革 男 文晔星 4 佐久间学 さくま　まなぶ、Sakuma　Manabu、アクマ 男 木村昴 5 风间龙一 かざま　りゅういち、Kazama　Ryūichi、ドラゴン 男 咲野俊介 6 小泉丈 こいずみ じょう、バタフライジョー 男 屋良有作 7 田村 たむら、Tamura、オババ 女 野沢雅子 8 孔的教练 男 程波 ","date":"2014-04-10","objectID":"/anime/ping_pong/:2:0","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 乒乓 2014-04-10 11 bilibili ","date":"2014-04-10","objectID":"/anime/ping_pong/:3:0","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"MAD ","date":"2014-04-10","objectID":"/anime/ping_pong/:4:0","tags":null,"title":"乒乓","uri":"/anime/ping_pong/"},{"categories":null,"content":"被无法与人类沟通的异生物·奇居子破坏的太阳系，只剩下一小部分的人类尚存活。他们为了生存制作了如同小行星本巨大的宇宙播种船希德尼娅，并在宇宙中进行旅行。\n经过了1000年后，时值希德尼娅出航纪元1009年，由地下层部培育的少年谷风长道自祖父死后而来到上层市区。并入学巨大人型兵器「卫人」的操控师训练学校，这也是谷风长道首次与外界人接触。\n令谷风长道首次抱有异性意识的女性是——星白闲。\n谷风长道首次的友人是无性别的科戸濑伊佐奈。\n令谷风长道意识到挫折的少年是——岐神海苔夫。\n在和各式各样的训练师一同度过校园生活的谷风长道，获得了首次的任务。虽然不是非常艰难的任务，但在谷风长道和队友们面前，突然出现了奇居子！遭遇沉寂了100年后的突袭，作为人类的谷风长道将如何抉择？\n关乎人类存亡的战斗现在开始了！……","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"简介 被无法与人类沟通的异生物·奇居子破坏的太阳系，只剩下一小部分的人类尚存活。他们为了生存制作了如同小行星本巨大的宇宙播种船希德尼娅，并在宇宙中进行旅行。 经过了1000年后，时值希德尼娅出航纪元1009年，由地下层部培育的少年谷风长道自祖父死后而来到上层市区。并入学巨大人型兵器「卫人」的操控师训练学校，这也是谷风长道首次与外界人接触。 令谷风长道首次抱有异性意识的女性是——星白闲。 谷风长道首次的友人是无性别的科戸濑伊佐奈。 令谷风长道意识到挫折的少年是——岐神海苔夫。 在和各式各样的训练师一同度过校园生活的谷风长道，获得了首次的任务。虽然不是非常艰难的任务，但在谷风长道和队友们面前，突然","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/:1:0","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 谷风长道 谷風 長道、たにかぜ ながて、Tanikaze Nagate 男 逢坂良太 2 星白闲 星白 閑、ほしじろ しずか、Hoshijiro Shizuka 女 洲崎綾 3 科户濑伊扎那 科戸瀬 イザナ、しなとせ いざな、Shinatose Izana 中性 豊崎愛生 4 崎神海苔夫 岐神海苔夫、くなと のりお、Kunato Norio ♂ 櫻井孝宏 5 绿川缬 緑川 纈、みどりかわ ゆはた、Midorikawa Yuhata 金元寿子 6 小林艦長 小林艦長、こばやし　かんじょう ♀ 大原さやか 7 仄姉妹 仄　姉妹 喜多村英梨 8 莎玛莉·伊丹 沙万","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/:2:0","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 希德尼娅的骑士 2014-04-10 12 bilibili 2 希德尼娅的骑士 第九惑星战役 2015-04-10 12 bilibili 3 希德尼娅的骑士 编织爱的行星 2021-06-04 1 樱花 ","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/:3:0","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"MAD ","date":"2014-04-10","objectID":"/anime/knights_of_sidonia/:4:0","tags":null,"title":"希德尼娅的骑士","uri":"/anime/knights_of_sidonia/"},{"categories":null,"content":"宇宙浪子是宇宙中一位叫作丹迪的人。身为宇宙猎人的他积极寻找未知的外星物种、因此与搭档旧型清扫机器人QT以及长得像猫的外星人阿喵一起在宇宙中到处冒险，并又为此卷入一场即将发生的阴谋之中。","date":"2014-01-05","objectID":"/anime/space_dandy/","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"简介 宇宙浪子是宇宙中一位叫作丹迪的人。身为宇宙猎人的他积极寻找未知的外星物种、因此与搭档旧型清扫机器人QT以及长得像猫的外星人阿喵一起在宇宙中到处冒险，并又为此卷入一场即将发生的阴谋之中。 制作人员： 原作：骨头社 导演：夏目真悟 脚本：圆城塔、上野贵美子、渡边信一郎、佐藤大、大河内一楼、信本敬子 分镜：宫地昌幸 ","date":"2014-01-05","objectID":"/anime/space_dandy/:1:0","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 丹迪 Dandy、ダンディ 男 諏訪部順一 2 QT QT、QT 佐武宇綺 3 阿喵 喵呜、Meow、ミャウ 吉野裕行 4 格尔博士 男 石塚運昇 5 比 Bee 男 畠山航輔 6 哈妮 Honey 女 ユリン千晶 7 斯卡蕾特 女 桑島法子 8 玛米妲丝 女 竹達彩奈 ","date":"2014-01-05","objectID":"/anime/space_dandy/:2:0","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 太空丹迪 2014-01-05 13 樱花 2 太空丹迪 第二季 2014-07-06 13 樱花 ","date":"2014-01-05","objectID":"/anime/space_dandy/:3:0","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"MAD ","date":"2014-01-05","objectID":"/anime/space_dandy/:4:0","tags":null,"title":"太空丹迪","uri":"/anime/space_dandy/"},{"categories":null,"content":"　　天才兼疯子科学家Rick在失踪多年后突然回到女儿Beth的身边，并且在她的车库里搞了一个科学实验室。Rick有一把“传送门枪”，可以穿越到宇宙的各个次元。孙子Morty莫名其妙就成了他的助手，经常被拖进他的自制太空船内，跟他一同开展各种疯狂刺激的宇宙冒险。女儿女婿对他的疯狂行为感到不满，却又对这个天才科学家无可奈何。 ","date":"2013-12-02","objectID":"/anime/rick_and_morty/","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"简介 天才兼疯子科学家Rick在失踪多年后突然回到女儿Beth的身边，并且在她的车库里搞了一个科学实验室。Rick有一把“传送门枪”，可以穿越到宇宙的各个次元。孙子Morty莫名其妙就成了他的助手，经常被拖进他的自制太空船内，跟他一同开展各种疯狂刺激的宇宙冒险。女儿女婿对他的疯狂行为感到不满，却又对这个天才科学家无可奈何。 制作人员： 导演：丹 哈蒙、贾斯汀·罗伊兰 脚本：麦克·麦克马汉、汤姆·考夫曼、瑞安·里德利 演出：杰夫·迈尔斯、约翰·赖斯 ","date":"2013-12-02","objectID":"/anime/rick_and_morty/:1:0","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 瑞克·桑切斯 Rick Sanchez、Rick 男 Justin Roiland 2 莫蒂·史密斯 Morty Smith、Morty 男 Justin Roiland 3 贝丝·史密斯 Beth Sanchez、Beth Smith、Beth 女 Sarah Chalke 4 杰里·史密斯 Jerry Smith、Jerry 男 Chris Parnell 5 萨默·史密斯 Summer Smith、Summer 女 Spencer Grammer 6 Jessica 女 ","date":"2013-12-02","objectID":"/anime/rick_and_morty/:2:0","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 瑞克和莫蒂 第一季 2013-12-02 11 樱花 2 瑞克和莫蒂 第二季 2015-07-26 10 樱花 3 瑞克和莫蒂 第三季 2017-04-01 10 acfun 4 瑞克和莫蒂 第四季 2019-11-10 10 acfun 5 瑞克和莫蒂 第五季 2021-06-20 10 樱花 6 瑞克和莫蒂 第六季 2022-09-04 10 樱花 ","date":"2013-12-02","objectID":"/anime/rick_and_morty/:3:0","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"MAD ","date":"2013-12-02","objectID":"/anime/rick_and_morty/:4:0","tags":null,"title":"瑞克和莫蒂","uri":"/anime/rick_and_morty/"},{"categories":null,"content":"艾伦戴尔王国有着两位个性截然不同的公主-艾莎与安娜，姊姊艾莎冷若冰霜，举止优雅合宜，安娜生性活泼冲动，热爱冒险。艾莎拥有冷冻的魔法，小时候和妹妹安娜玩耍不小心击中妹妹，所以及后一直不敢接近人群，尤其是不敢靠近安娜，怕再次伤害到亲爱的妹妹。至艾莎成年后，必须接下统领王国的重任，故而闭关多年的城门再次开启。艾莎一直收藏拥有魔法的秘密，压力甚大。两相助的一场争吵让艾莎压抑的情绪爆发，愤而离家，但一时使出的魔法却让整个王国变成冰封的雪国。安娜为了解除魔法，只得冒着风雪寻找姊姊，在路上碰上喜爱冒险的登山人阿克与他如忠犬般个性的驯鹿以及天真搞笑的雪人雪宝，四人一同携手踏上伟大的旅程，它们必须挑战冷峻的雪山以及一路上种种险境才能拯救面临灭亡的王国……","date":"2013-11-27","objectID":"/anime/frozen/","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"简介 艾伦戴尔王国有着两位个性截然不同的公主-艾莎与安娜，姊姊艾莎冷若冰霜，举止优雅合宜，安娜生性活泼冲动，热爱冒险。艾莎拥有冷冻的魔法，小时候和妹妹安娜玩耍不小心击中妹妹，所以及后一直不敢接近人群，尤其是不敢靠近安娜，怕再次伤害到亲爱的妹妹。至艾莎成年后，必须接下统领王国的重任，故而闭关多年的城门再次开启。艾莎一直收藏拥有魔法的秘密，压力甚大。两相助的一场争吵让艾莎压抑的情绪爆发，愤而离家，但一时使出的魔法却让整个王国变成冰封的雪国。安娜为了解除魔法，只得冒着风雪寻找姊姊，在路上碰上喜爱冒险的登山人阿克与他如忠犬般个性的驯鹿以及天真搞笑的雪人雪宝，四人一同携手踏上伟大的旅程，它们必须挑战冷峻","date":"2013-11-27","objectID":"/anime/frozen/:1:0","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾莎 爱莎 女 Idina Menzel 2 安娜 女 諸星すみれ 3 雪宝 男 ピエール瀧 4 克里斯托夫 男 Jonathan Groff 5 汉斯·韦斯特加德 男 Santino Fontana 6 Duke of Weselton 男 Alan Tudyk 7 路人 モブ、モブキャラ、闲角、mob character、端役、エキストラ、extra Fred Tatasciore 8 乐佩 瑞普兹、蕾芬洁、萝庞柔、ラプンツェル 女 ","date":"2013-11-27","objectID":"/anime/frozen/:2:0","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 冰雪奇缘 2013-11-27 1 樱花 2 冰雪奇缘2 2019-11-22 1 樱花 ","date":"2013-11-27","objectID":"/anime/frozen/:3:0","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"MAD ","date":"2013-11-27","objectID":"/anime/frozen/:4:0","tags":null,"title":"冰雪奇缘","uri":"/anime/frozen/"},{"categories":null,"content":"《辉夜姬物语》（日语：かぐや姫の物語）是日本吉卜力工作室的动画导演高畑勋以日本古典文学《竹取物语》为蓝本所改编的动画电影。かぐや姬，汉译有不同写法，如“辉夜姬”、“赫映姬”、“竹取公主”等等。但据日本语言学家山田孝雄考证，此词源出汉语“赫奕”一词。","date":"2013-11-23","objectID":"/anime/kaguya_hime/","tags":null,"title":"辉夜姬物语","uri":"/anime/kaguya_hime/"},{"categories":null,"content":"简介 《辉夜姬物语》（日语：かぐや姫の物語）是日本吉卜力工作室的动画导演高畑勋以日本古典文学《竹取物语》为蓝本所改编的动画电影。かぐや姬，汉译有不同写法，如“辉夜姬”、“赫映姬”、“竹取公主”等等。但据日本语言学家山田孝雄考证，此词源出汉语“赫奕”一词。 制作人员： 导演：高畑勋 脚本：坂口理子 分镜：桥本晋治、佐藤雅子、笹木信作、百濑义行 音乐：久石让 人物设定：田边修 ","date":"2013-11-23","objectID":"/anime/kaguya_hime/:1:0","tags":null,"title":"辉夜姬物语","uri":"/anime/kaguya_hime/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 辉夜姬 竹子、かぐやひめ 女 朝倉あき 2 舍丸 Sutemaru 男 高良健吾 3 翁 男 4 媼 女 ","date":"2013-11-23","objectID":"/anime/kaguya_hime/:2:0","tags":null,"title":"辉夜姬物语","uri":"/anime/kaguya_hime/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 辉夜姬物语 2013-11-23 137min 樱花 ","date":"2013-11-23","objectID":"/anime/kaguya_hime/:3:0","tags":null,"title":"辉夜姬物语","uri":"/anime/kaguya_hime/"},{"categories":null,"content":"这是一个一个寻找快乐的故事。十年前，钢琴家Sergio与兄长Alfredo分道扬镳：两位都是热爱音乐的人，却无法在音乐事业上如愿发展。Alfredo遂决定抛开世俗的一切去寻找快乐，离家前住印度达兰萨拉出家修练成为和尚；Sergio则在拿破里当上的士司机。他日复日的听着收音机穿过大街小巷，遇上了不同的人，聆听不同的故事。导演以动画画出哲理与智慧，通过两兄弟的故事，探讨音乐、生命、以及快乐的真谛。你，快乐吗？","date":"2013-11-21","objectID":"/anime/the_art_of_happiness/","tags":null,"title":"寻找隐世快乐","uri":"/anime/the_art_of_happiness/"},{"categories":null,"content":"简介 这是一个一个寻找快乐的故事。十年前，钢琴家Sergio与兄长Alfredo分道扬镳：两位都是热爱音乐的人，却无法在音乐事业上如愿发展。Alfredo遂决定抛开世俗的一切去寻找快乐，离家前住印度达兰萨拉出家修练成为和尚；Sergio则在拿破里当上的士司机。他日复日的听着收音机穿过大街小巷，遇上了不同的人，聆听不同的故事。导演以动画画出哲理与智慧，通过两兄弟的故事，探讨音乐、生命、以及快乐的真谛。你，快乐吗？ ","date":"2013-11-21","objectID":"/anime/the_art_of_happiness/:1:0","tags":null,"title":"寻找隐世快乐","uri":"/anime/the_art_of_happiness/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 寻找隐世快乐 2013-11-21 1 其它 ","date":"2013-11-21","objectID":"/anime/the_art_of_happiness/:2:0","tags":null,"title":"寻找隐世快乐","uri":"/anime/the_art_of_happiness/"},{"categories":null,"content":"　　那个世界，无论到哪里都在预料之外 \n　　无论哪里，无论哪里都是由隧道连接着的地下世界。虽然那里的人住在黑暗封闭的空间里，但他们却穿着防护衣过着宁静快乐的日子。地底集落的公主——帕特玛是爱在地下隧道中到处探索的女孩。她最喜欢的地方是被当地人禁止进入的“危险地区”。即使挨骂也阻止 不了帕特玛的好奇心。毕竟从来没人说过那所谓的“危险”究竟是什么。有一天，在去“危险地区”探险的途中，帕特玛终于遇到难以想象的事件，一步步发现了惊人的秘密… ","date":"2013-11-09","objectID":"/anime/patema_inverted/","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"简介 那个世界，无论到哪里都在预料之外 无论哪里，无论哪里都是由隧道连接着的地下世界。虽然那里的人住在黑暗封闭的空间里，但他们却穿着防护衣过着宁静快乐的日子。地底集落的公主——帕特玛是爱在地下隧道中到处探索的女孩。她最喜欢的地方是被当地人禁止进入的“危险地区”。即使挨骂也阻止 不了帕特玛的好奇心。毕竟从来没人说过那所谓的“危险”究竟是什么。有一天，在去“危险地区”探险的途中，帕特玛终于遇到难以想象的事件，一步步发现了惊人的秘密… 制作人员： 原作：吉浦康裕 音乐：大岛满 人物原案：茶山隆介、杏仁豆腐 人物设定：又贺大介 美术监督：金子雄司 ","date":"2013-11-09","objectID":"/anime/patema_inverted/:1:0","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 帕特玛 Patema 女 藤井ゆきよ 2 英治 Age 男 岡本信彦 3 拉格斯 Lagos 男 加藤将之 4 波尔塔 Porta 大畑伸太郎 5 カホ Kaho 女 内田真礼 6 ジィ Jii 男 ふくまつ進紗 7 ジャク Jack 男 安元洋貴 8 イザムラ Izamura 男 土師孝也 ","date":"2013-11-09","objectID":"/anime/patema_inverted/:2:0","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 颠倒的帕特玛 2013-11-09 1 bilibili ","date":"2013-11-09","objectID":"/anime/patema_inverted/:3:0","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"MAD ","date":"2013-11-09","objectID":"/anime/patema_inverted/:4:0","tags":null,"title":"颠倒的帕特玛","uri":"/anime/patema_inverted/"},{"categories":null,"content":"作品舞台是一个挂著“牛经过注意”的看板，公车不等上5个小时不会来的乡下农村，而主角一条萤因父亲工作调职的关系从东京迁居此地，故事即是描写萤与越谷姐妹及宫内姐妹渡过的日常光景。","date":"2013-10-07","objectID":"/anime/non_non_biyori/","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"简介 作品舞台是一个挂著“牛经过注意”的看板，公车不等上5个小时不会来的乡下农村，而主角一条萤因父亲工作调职的关系从东京迁居此地，故事即是描写萤与越谷姐妹及宫内姐妹渡过的日常光景。 制作人员： 原作：あっと 导演：川面真也 脚本：吉田玲子、山田由香、志茂文彦 分镜：岩崎良明、锦织博、小柴纯弥 ","date":"2013-10-07","objectID":"/anime/non_non_biyori/:1:0","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫内莲华 宮内 れんげ、みやうち れんげ、Miyauchi Renge、れんちょん、喵帕斯 女 小岩井ことり 2 一条萤 一条虫、いちじょう　ほたる、Ichijou Hotaru、ほたるん 女 村川梨衣 3 越谷夏海 こしがや なつみ、Koshigaya Natsumi、なっつん 女 佐倉綾音 4 越谷小鞠 小小鞠、こしがや こまり、Koshigaya Komari、コマちゃん 女 阿澄佳奈 5 加贺山枫 かがやま かえで、Kagayama Kaede、卖零食的 (駄菓子屋/駄菓子屋さん) 女 佐藤利奈 6 宫内一穗 みやうち かずほ、Miyauchi Ka","date":"2013-10-07","objectID":"/anime/non_non_biyori/:2:0","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 悠哉日常大王 2013-10-07 12 樱花 2 悠哉日常大王 OAD 2014-07-23 1 bilibili 3 悠哉日常大王 Repeat 2015-07-06 12 樱花 4 悠哉日常大王 Repeat OAD 2016-09-23 1 bilibili 5 剧场版 悠哉日常大王 Vacation 2018-08-25 1 bilibili 6 悠哉日常大王 Nonstop 2021-01-10 12 bilibili 7 悠哉日常大王 Nonstop OAD 2022-03-23 1 樱花 ","date":"2013-10-07","objectID":"/anime/non_non_biyori/:3:0","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"MAD ","date":"2013-10-07","objectID":"/anime/non_non_biyori/:4:0","tags":null,"title":"悠哉日常大王","uri":"/anime/non_non_biyori/"},{"categories":null,"content":"故事发生在2007年秋季的东京都。峰城大附属3年级学生北原春希为了制造学生时代最后的回忆加入了轻音乐同好会，而乐队却因为感情的纠葛而崩溃。春希为了能够在学园祭上成功演出而开始召集成员，并成功劝诱了在屋顶唱歌的学院偶像小木曾雪菜。在发现了班级的问题儿童冬马和纱的天才般音乐才能之后，两人经过千辛万苦最终使她也加入了乐队。原本毫不相关的三个人经过全神贯注的、拼命的奋斗之后在学园祭上大获成功，三个人从心底结合了起来……虽然大家都是这样认为的，但从这以后各自的爱恋却走向了残酷的悲剧……","date":"2013-10-05","objectID":"/anime/white_album_2/","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"简介 故事发生在2007年秋季的东京都。峰城大附属3年级学生北原春希为了制造学生时代最后的回忆加入了轻音乐同好会，而乐队却因为感情的纠葛而崩溃。春希为了能够在学园祭上成功演出而开始召集成员，并成功劝诱了在屋顶唱歌的学院偶像小木曾雪菜。在发现了班级的问题儿童冬马和纱的天才般音乐才能之后，两人经过千辛万苦最终使她也加入了乐队。原本毫不相关的三个人经过全神贯注的、拼命的奋斗之后在学园祭上大获成功，三个人从心底结合了起来……虽然大家都是这样认为的，但从这以后各自的爱恋却走向了残酷的悲剧…… 制作人员： 原作：アクアプラス 导演：安藤正臣 脚本：丸户史明 分镜：小野胜巳、沼田诚也、渡边哲哉、大和直道、安","date":"2013-10-05","objectID":"/anime/white_album_2/:1:0","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小木曾雪菜 小木曽 雪菜、おぎそ せつな、Ogiso Setsuna 女 米澤円 2 冬马和纱 冬马和咲、冬馬 かずさ、とうま かずさ、Touma Kazusa 女 生天目仁美 3 北原春希 北原 春希、きたはら はるき、Kitahara Haruki 男 水島大宙 4 饭冢武也 飯塚 武也、いいづか たけや、Iizuka Takeya 男 寺島拓篤 5 水泽依绪 水沢 依緒、みずさわ いお、Mizusawa Io 女 中上育実 6 小木曽孝宏 Ogiso Takahiro 男 梶裕貴 7 早坂亲志 Hayasaka Chikashi 男 杉山紀彰 8 冬马","date":"2013-10-05","objectID":"/anime/white_album_2/:2:0","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 白色相簿2 2013-10-05 13 樱花 ","date":"2013-10-05","objectID":"/anime/white_album_2/:3:0","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"MAD ","date":"2013-10-05","objectID":"/anime/white_album_2/:4:0","tags":null,"title":"白色相簿2","uri":"/anime/white_album_2/"},{"categories":null,"content":"本故事以被武力和恐怖支配的本能字学院为舞台，以为父报仇的转校生少女为中心， 围绕着在学园中“执牛耳者”的学生及学生会四大天王间的激战故事展开。\n\n缠流子和鬼龙院皋月，两人为本作的主人公。在本作中，皋月用极制服的力量支配着学园， 而流子为查明父亲死亡的真相而与皋月对抗。\n\n在这由力量支配的学园中，由于手持片太刀铗的转校生的到来，引起了动乱， 这一场各个能力者均被打倒的故事因此而开始！","date":"2013-10-03","objectID":"/anime/kill_la_kill/","tags":null,"title":"斩服少女","uri":"/anime/kill_la_kill/"},{"categories":null,"content":"简介 本故事以被武力和恐怖支配的本能字学院为舞台，以为父报仇的转校生少女为中心， 围绕着在学园中“执牛耳者”的学生及学生会四大天王间的激战故事展开。 缠流子和鬼龙院皋月，两人为本作的主人公。在本作中，皋月用极制服的力量支配着学园， 而流子为查明父亲死亡的真相而与皋月对抗。 在这由力量支配的学园中，由于手持片太刀铗的转校生的到来，引起了动乱， 这一场各个能力者均被打倒的故事因此而开始！ 制作人员： 原作：中岛一基、TRIGGER 导演：今石洋之 脚本：若林广海、濑古浩司 分镜：横山彰利、吉成曜、立川让 ","date":"2013-10-03","objectID":"/anime/kill_la_kill/:1:0","tags":null,"title":"斩服少女","uri":"/anime/kill_la_kill/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 缠流子 纏 流子、まとい りゅうこ、Matoi Ryuuko 女 小清水亜美 2 鬼龙院皐月 鬼龍院 皐月、きりゅういん さつき、Kiryuuin Satsuki 女 柚木涼香 3 鲜血 せんけつ、senketsu 関俊彦 4 满舰饰真子 満艦飾 マコ、まんかんしょく まこ、Mankanshoku Mako 女 洲崎綾 5 猿投山涡 猿投山 渦、さなげやま うず、Sanageyama Uzu 男 檜山修之 6 蛇崩乃音 蛇崩 乃音、じゃくずれ ののん、Jakuzure Nonon 女 新谷真弓 7 犬牟田宝火 犬牟田 宝火、いぬむた ほうか、Inumuta ","date":"2013-10-03","objectID":"/anime/kill_la_kill/:2:0","tags":null,"title":"斩服少女","uri":"/anime/kill_la_kill/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 斩服少女 2013-10-03 24 bilibili ","date":"2013-10-03","objectID":"/anime/kill_la_kill/:3:0","tags":null,"title":"斩服少女","uri":"/anime/kill_la_kill/"},{"categories":null,"content":"在与外界隔绝，时间静止的镜都内，主角筝和不同势力的代表，为了寻找共同的目标——黑兔古都，而每天上演着奇幻缤纷的格斗。众人对自身过去的执著，以及对特殊现象的好奇，渐渐弄清世界的所有现象的前因后果。","date":"2013-10-02","objectID":"/anime/kyousogiga/","tags":null,"title":"京骚戏画","uri":"/anime/kyousogiga/"},{"categories":null,"content":"简介 在与外界隔绝，时间静止的镜都内，主角筝和不同势力的代表，为了寻找共同的目标——黑兔古都，而每天上演着奇幻缤纷的格斗。众人对自身过去的执著，以及对特殊现象的好奇，渐渐弄清世界的所有现象的前因后果。 制作人员： 原作：东堂泉 导演：松本理惠 脚本：丸尾未步、中濑理香 分镜：角铜博之、志水淳儿 ","date":"2013-10-02","objectID":"/anime/kyousogiga/:1:0","tags":null,"title":"京骚戏画","uri":"/anime/kyousogiga/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 筝 琴、琴子、Koto 女 釘宮理恵 2 明惠 药师丸、みょうえ 男 鈴村健一 3 古都 コト 女 久川綾 4 翔子 女 斎藤千和 5 八濑 Hachise 女 喜多村英梨 6 阿 A 男 日髙のり子 7 吽 Un 男 白石涼子 8 稻荷 いなりの、Inonari 男 石田彰 ","date":"2013-10-02","objectID":"/anime/kyousogiga/:2:0","tags":null,"title":"京骚戏画","uri":"/anime/kyousogiga/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 京骚戏画 2013-10-02 13 樱花 ","date":"2013-10-02","objectID":"/anime/kyousogiga/:3:0","tags":null,"title":"京骚戏画","uri":"/anime/kyousogiga/"},{"categories":null,"content":"想更加出人头地！为了实现这样的理想，黑白小姐以成为卖座偶像为目标开始活动，尽管天然性格的黑白小姐总是给周围带来麻烦，但还是每日奔走于偶像业界！","date":"2013-10-01","objectID":"/anime/miss_monochrome/","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"简介 想更加出人头地！为了实现这样的理想，黑白小姐以成为卖座偶像为目标开始活动，尽管天然性格的黑白小姐总是给周围带来麻烦，但还是每日奔走于偶像业界！ 制作人员： 导演：岩崎良明 脚本：笔安一幸 分镜：山下英美、臼井文明、大岛博之 ","date":"2013-10-01","objectID":"/anime/miss_monochrome/:1:0","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 黑白小姐 黑白姑娘、单色小姐、Miss Monochrome 女 堀江由衣 2 经纪夫 瑪莉歐、Maneo 男 藤原啓治 3 喜久子 女 井上喜久子 4 真奈 女 神田朱未 5 宇宙人 村田太志 6 露酱 Ruuchan 7 旁白 ナレーター、解説、Narration/Narrator、Nareeshon、天之声、páng bái 藤原啓治 8 路人 モブ、モブキャラ、闲角、mob character、端役、エキストラ、extra 大地葉 ","date":"2013-10-01","objectID":"/anime/miss_monochrome/:2:0","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 黑白小姐 2013-10-01 13 樱花 ","date":"2013-10-01","objectID":"/anime/miss_monochrome/:3:0","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"MAD ","date":"2013-10-01","objectID":"/anime/miss_monochrome/:4:0","tags":null,"title":"黑白小姐","uri":"/anime/miss_monochrome/"},{"categories":null,"content":"剧情为混合改编了零式舰上战斗机设计者堀越二郎的故事、以及小说家堀辰雄作品《风吹了》的内容，并预计2013年夏季上映。另外，男主角堀越二郎的配音，则由《新世纪福音战士》的导演庵野秀明出任。","date":"2013-07-20","objectID":"/anime/the_wind_rises/","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"简介 剧情为混合改编了零式舰上战斗机设计者堀越二郎的故事、以及小说家堀辰雄作品《风吹了》的内容，并预计2013年夏季上映。另外，男主角堀越二郎的配音，则由《新世纪福音战士》的导演庵野秀明出任。 制作人员： 原作：宫崎骏 音乐：久石让 美术监督：武重洋二 色彩设计：保田道世 作画监督：高坂希太郎 摄影监督：奥井敦 原画：山下明彦 ","date":"2013-07-20","objectID":"/anime/the_wind_rises/:1:0","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 堀越二郎 堀越 二郎、ほりこし じろう、Horikoshi Jirou 男 庵野秀明 2 里见菜穗子 里見菜穂子、さとみ なおこ、satomi naoko 女 瀧本美織 3 堀越加代 堀越加代、ほりこし かよ、Horikoshi Kayo 女 志田未来 4 二郎的母亲 二郎の母、Jirou no Haha 女 竹下景子 5 本庄季郎 本庄季郎、Honjou Kirou 男 西島秀俊 6 黑川 黒川、Kurokawa 男 西村雅彦 7 卡普罗尼 Caproni、カプローニ 男 野村萬斎 8 カストルプ Castorp、カストルプ 男 Steve Alpert ","date":"2013-07-20","objectID":"/anime/the_wind_rises/:2:0","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 起风了 2013-07-20 1 bilibili ","date":"2013-07-20","objectID":"/anime/the_wind_rises/:3:0","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"MAD ","date":"2013-07-20","objectID":"/anime/the_wind_rises/:4:0","tags":null,"title":"起风了","uri":"/anime/the_wind_rises/"},{"categories":null,"content":"故事发生在虚构的日本第二首都——2015年的东京都立川市，在高科技的应用下智能手机和社交网络已经成为和人们不可分割的一部分。不过在城市中出现了麻烦与骚乱的未知存在“MESS”，而主角一行则是作为解决此事的“Gatchaman”，利用特殊的笔记本“NOTE”将灵魂的特殊能力实体化为铠甲，并利用这种力量介入事件，维护城市的和平。但同时网络社交媒体“GALAX”也已经悄然对城市有所改变，而“GALAX”的一位名人“LOAD”并不认同“Gatchaman”为城市和带来的意义。\n通过“GALAX”，不同职业和身份的“GALAXER”——“GALAX”的用户可以各司其职的帮助周围的人，每当“GALAXER”遇到困难时，他们能受到软件自带的人工智能“X总裁”的指导，掌握紧急事件的状况、保持冷静并尝试通过自己和周围的人解决事态。“GALAX”称其为“更新”，GALAX的创立者想通过这个方式创立理想的横向社会。","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"简介 故事发生在虚构的日本第二首都——2015年的东京都立川市，在高科技的应用下智能手机和社交网络已经成为和人们不可分割的一部分。不过在城市中出现了麻烦与骚乱的未知存在“MESS”，而主角一行则是作为解决此事的“Gatchaman”，利用特殊的笔记本“NOTE”将灵魂的特殊能力实体化为铠甲，并利用这种力量介入事件，维护城市的和平。但同时网络社交媒体“GALAX”也已经悄然对城市有所改变，而“GALAX”的一位名人“LOAD”并不认同“Gatchaman”为城市和带来的意义。 通过“GALAX”，不同职业和身份的“GALAXER”——“GALAX”的用户可以各司其职的帮助周围的人，每当“GALA","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/:1:0","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 一之濑初 一ノ瀬 はじめ、いちのせ はじめ、Ichinose Hajime 女 内田真礼 2 橘清音 橘 清音、たちばな すがね、Tachibana Sugane 男 逢坂良太 3 枇枇木丈 Joe Hibiki、枇々木 丈、ひびき じょう、Hibiki Jō 男 浪川大輔 4 宫现 宮 うつつ、みや うつつ、Miya Utsutsu 女 小岩井ことり 5 派曼 平野綾 6 O·D オー・ディー 男 細見大輔 7 尔乃美家累 爾乃美家 累、にのみや るい、Ninomiya Rui 男 村瀬歩 8 皮尔·卡切 Berg-Katze 男 宮野真守 ","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/:2:0","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 科学小飞侠Crowds 2013-07-12 13 bilibili 2 科学小飞侠Crowds insight 2015-07-05 13 bilibili ","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/:3:0","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"MAD ","date":"2013-07-12","objectID":"/anime/gatchaman_crowds/:4:0","tags":null,"title":"科学小飞侠Crowds","uri":"/anime/gatchaman_crowds/"},{"categories":null,"content":"伊莉雅是一个就读穗群原学园的普通女孩子，在某天遇到了自称人工天然精灵的魔法露比万花筒之杖，并强制地被缔结契约，成为了魔法少女伊莉雅。而已是红宝石之星持有人的她，还变成了万花筒之杖原持有者的魔术师远坂凛的奴隶，在其的命令之下，被迫帮忙回收沉睡于冬木市的某危险的卡片……","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"简介 伊莉雅是一个就读穗群原学园的普通女孩子，在某天遇到了自称人工天然精灵的魔法露比万花筒之杖，并强制地被缔结契约，成为了魔法少女伊莉雅。而已是红宝石之星持有人的她，还变成了万花筒之杖原持有者的魔术师远坂凛的奴隶，在其的命令之下，被迫帮忙回收沉睡于冬木市的某危险的卡片…… 制作人员： 原作：广山弘、型月 导演：大沼心 脚本：水濑叶月、井上坚二 分镜：高桥贤、野田惠、二瓶勇一、川口敬一郎 ","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/:1:0","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 伊莉雅斯菲尔·冯·爱因兹贝伦 伊莉雅丝菲尔·冯·爱因兹贝伦、伊莉亚丝菲尔·冯·艾因兹贝伦、依莉雅苏菲尔·冯·爱因兹贝伦、伊莉雅、Illyasviel von Einzbern、イリヤ 女 門脇舞以 2 美游·艾德费尔特 朔月美游、美游、Miyu Edelfelt、美遊・エーデルフェルト、みゆ エーデルフェルト、Miyu Ēderuferuto、みゆきち 女 名塚佳織 3 阿尔托莉雅·潘德拉贡 Saber、呆毛王、吾王、青王、骑士王、棉被王、亚瑟王、蓝Saber、元祖Saber、Altria Pendragon、セイバー 女 川澄綾子 4 卫宫士郎 衛宮 士郎","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/:2:0","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Fate/kaleid liner 魔法少女☆伊莉雅 2013-07-12 10 樱花 2 Fate/kaleid liner 魔法少女☆伊莉雅 OAD 2014-03-07 1 bilibili 3 Fate/kaleid liner 魔法少女☆伊莉雅 2wei! 2014-07-09 10 bilibili 4 Fate/kaleid liner 魔法少女☆伊莉雅 2wei OAD 2015-07-25 1 樱花 5 Fate/kaleid liner 魔法少女☆伊莉雅 2wei Herz! 2015-07-24 10 樱花 6 Fate/","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/:3:0","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"MAD ","date":"2013-07-12","objectID":"/anime/fate_kaleid_liner_prisma_illya/:4:0","tags":null,"title":"魔法少女☆伊莉雅","uri":"/anime/fate_kaleid_liner_prisma_illya/"},{"categories":null,"content":"    大虾夷农业高等学校（通称：虾夷农高）是一所坐落于北海道的农业高中，校内学生多为以将从事农业当作目标的农家子女。这所拥有在全日本所有高中中最多的占地面积，被北海道壮丽的大自然和乡村风情环抱的虾夷农高，在新学年里迎来了一位特殊的学生——八轩勇吾。这位来自城市、毕业于升学初中的文弱学生，因发现在一年级的同学中只有他自己找不到明确的人生目标而开始焦躁不安。自此，写作“就读于农高的每一天”、读作“在青春岁月中找寻自己的梦想”的八轩勇吾的高中生活开始了。","date":"2013-07-11","objectID":"/anime/silver_spoon/","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"简介 大虾夷农业高等学校（通称：虾夷农高）是一所坐落于北海道的农业高中，校内学生多为以将从事农业当作目标的农家子女。这所拥有在全日本所有高中中最多的占地面积，被北海道壮丽的大自然和乡村风情环抱的虾夷农高，在新学年里迎来了一位特殊的学生——八轩勇吾。这位来自城市、毕业于升学初中的文弱学生，因发现在一年级的同学中只有他自己找不到明确的人生目标而开始焦躁不安。自此，写作“就读于农高的每一天”、读作“在青春岁月中找寻自己的梦想”的八轩勇吾的高中生活开始了。 制作人员： 原作：荒川弘 导演：伊藤智彦 脚本：岸本卓 分镜：许平康、柴山智隆、村山靖、室井康雄、藤森一真、冈村天斋 ","date":"2013-07-11","objectID":"/anime/silver_spoon/:1:0","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 八轩勇吾 八軒 勇吾、はちけん ゆうご、Hachiken Yuugo、ハチ 男 木村良平 2 御影秋 御影亚季、御影亚纪、みかげ アキ、Mikage Aki 女 三宅麻理恵 3 驹场一郎 駒場 一郎、こまば いちろう、Komaba Ichirou 男 櫻井トオル 4 常盘惠次 常盤 恵次、ときわ けいじ、Tokiwa Keiji 男 庄司将之 5 稻田多摩子 稲田 多摩子、いなだ たまこ、Inada Tamako、タマコ / 鸡蛋子 女 高垣彩陽 6 相川进之介 相川 進之介、あいかわ しんのすけ、Aikawa Shinnosike 男 島﨑信長 7 吉野真","date":"2013-07-11","objectID":"/anime/silver_spoon/:2:0","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 银之匙 Silver Spoon 2013-07-11 11 acfun 2 银之匙 Silver Spoon 第二季 2014-01-09 11 acfun ","date":"2013-07-11","objectID":"/anime/silver_spoon/:3:0","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"MAD ","date":"2013-07-11","objectID":"/anime/silver_spoon/:4:0","tags":null,"title":"银之匙 Silver Spoon","uri":"/anime/silver_spoon/"},{"categories":null,"content":"曾在英国寄住的忍，归国后开始了高中1年生的生活，然而某一天忍在英国的朋友爱丽丝竟然不远万里跑来日本了，说着“这次轮到我来日本了”的爱丽丝，将忍和同学绫与阳子，以及另一位英国少女九条可怜卷入了日本和英国美少女之间的休闲百合日常。","date":"2013-07-06","objectID":"/anime/kin-iro_mosaic/","tags":null,"title":"黄金拼图","uri":"/anime/kin-iro_mosaic/"},{"categories":null,"content":"简介 曾在英国寄住的忍，归国后开始了高中1年生的生活，然而某一天忍在英国的朋友爱丽丝竟然不远万里跑来日本了，说着“这次轮到我来日本了”的爱丽丝，将忍和同学绫与阳子，以及另一位英国少女九条可怜卷入了日本和英国美少女之间的休闲百合日常。 制作人员： 原作：原悠衣 导演：天冲 脚本：高桥龙也、浦畑达彦、绫奈由仁子 分镜：木宫茂、佐藤真二、安食圭 ","date":"2013-07-06","objectID":"/anime/kin-iro_mosaic/:1:0","tags":null,"title":"黄金拼图","uri":"/anime/kin-iro_mosaic/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 大宫忍 忍叔、おおみや しのぶ、Oomiya Shinobu、小忍 女 西明日香 2 爱丽丝·卡塔雷特 艾莉丝·卡达列特、Alice Cartelet 女 田中真奈美 3 小路绫 小路 綾、こみち あや、Komichi Aya、Ayaya 女 種田梨沙 4 猪熊阳子 猪熊 陽子、いのくま ようこ、Inokuma Youko 女 内山夕実 5 九条可怜 九条 カレン、くじょう カレン、Kujou Karen 女 東山奈央 6 大宫勇 大宮 勇、おおみや いさみ、Oomiya Isami 女 田村ゆかり 7 忍的妈妈 女 高橋美佳子 8 可怜的妈妈 女 木村亜希","date":"2013-07-06","objectID":"/anime/kin-iro_mosaic/:2:0","tags":null,"title":"黄金拼图","uri":"/anime/kin-iro_mosaic/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 黄金拼图 2013-07-06 12 bilibili ","date":"2013-07-06","objectID":"/anime/kin-iro_mosaic/:3:0","tags":null,"title":"黄金拼图","uri":"/anime/kin-iro_mosaic/"},{"categories":null,"content":"作品以爱情来临前的孤独——“孤悲”来呈现“恋爱”的主题。梅雨时节，以成为鞋匠为目标的高中生孝雄与神秘的女性百香里，在雨中的日本庭园中相遇。以女性留给少年的一篇万叶集为契机，故事就此开展……。","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"简介 作品以爱情来临前的孤独——“孤悲”来呈现“恋爱”的主题。梅雨时节，以成为鞋匠为目标的高中生孝雄与神秘的女性百香里，在雨中的日本庭园中相遇。以女性留给少年的一篇万叶集为契机，故事就此开展……。 制作人员： 原作：新海诚 音乐：柏 大辅 人物设定：土屋坚一 美术监督：泷口比吕志 色彩设计：三木阳子 ","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/:1:0","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 秋月孝雄 タカオ、あきづきたかお 男 入野自由 2 雪野百香里 ユキちゃん先生、ユキノ、雪野 百香里、ゆきの ゆかり、Yukino Yukari 女 花澤香菜 3 タカオの母 女 平野文 4 タカオの兄の彼女 女 寺崎裕香 5 タカオの兄 男 前田剛 6 松本 男 井上優 7 佐藤 女 潘めぐみ 8 相泽 あいざわ、Aizawa 女 小松未可子 ","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/:2:0","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 言叶之庭 2013-05-31 46min bilibili ","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/:3:0","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"MAD ","date":"2013-05-31","objectID":"/anime/kotonoha_no_niwa/:4:0","tags":null,"title":"言叶之庭","uri":"/anime/kotonoha_no_niwa/"},{"categories":null,"content":"刚升上高中一年级的佐藤一郎，某天在晚上潜入学校拿东西时，遇见了身穿蓝色斗篷，拿着金属杖的美少女。自从遇到她之后，佐藤期望的平稳学生生活渐渐的离他而去。","date":"2013-04-13","objectID":"/anime/aura/","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"简介 刚升上高中一年级的佐藤一郎，某天在晚上潜入学校拿东西时，遇见了身穿蓝色斗篷，拿着金属杖的美少女。自从遇到她之后，佐藤期望的平稳学生生活渐渐的离他而去。 制作人员： 原作：田中罗密欧 导演：岸诚二 脚本：熊谷纯 分镜：田口智久、斋藤久 演出：西本由纪夫、小坂春女 音乐：大岛满 ","date":"2013-04-13","objectID":"/anime/aura/:1:0","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐藤一郎 Men’s佐藤、魔龙院光牙、佐藤 一郎、さとう いちろう 男 島﨑信長 2 佐藤良子 佐藤　良子、さとう　りょうこ、Satou Ryouko 女 花澤香菜 ","date":"2013-04-13","objectID":"/anime/aura/:2:0","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 AURA ～魔龙院光牙最后的战斗～ 2013-04-13 83m bilibili ","date":"2013-04-13","objectID":"/anime/aura/:3:0","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"MAD ","date":"2013-04-13","objectID":"/anime/aura/:4:0","tags":null,"title":"AURA ～魔龙院光牙最后的战斗～","uri":"/anime/aura/"},{"categories":null,"content":"悠长的历史之中,人类曾一度因被巨人捕食而崩溃。幸存下来的人们建造了一面巨大的墙壁,防止了巨人的入侵。不过,作为“和平”的代价,人类失去了到墙壁的外面去这一“自由”。主人公艾伦·耶格尔对还没见过的外面的世界抱有兴趣。在他正做着到墙壁的外面去这个梦的时候,毁坏墙壁的大巨人出现了！","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"简介 悠长的历史之中,人类曾一度因被巨人捕食而崩溃。幸存下来的人们建造了一面巨大的墙壁,防止了巨人的入侵。不过,作为“和平”的代价,人类失去了到墙壁的外面去这一“自由”。主人公艾伦·耶格尔对还没见过的外面的世界抱有兴趣。在他正做着到墙壁的外面去这个梦的时候,毁坏墙壁的大巨人出现了！ 制作人员： 原作：谏山创 导演：荒木哲郎 脚本：高木登、小林靖子、濑古浩司 分镜：別所诚人、小松田大全、大原实 ","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/:1:0","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾伦·耶格尔 艾连・叶卡、Eren Yeager 男 梶裕貴 2 三笠·阿克曼 米卡莎・阿卡曼、Mikasa Ackerman 女 石川由依 3 阿明·阿诺德 阿尔敏·亚鲁雷特、艾尔敏·阿莱尔特、爱尔敏·亚鲁雷特、Armin Arlert 男？ 井上麻里奈 4 利威尔 利维尔、兵长、一米六、里维、Levi、李白 男 神谷浩史 5 让·基尔休坦 Jean Kirstein 男 谷山紀章 6 克里斯塔·连兹 Historia Reiss、ヒストリア・レイス、希斯特莉亚·雷斯、Krista Lenz 女 三上枝織 7 柯尼·史普林格 Connie Springer","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/:2:0","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 进击的巨人 2013-04-06 25 樱花 2 进击的巨人 第二季 2017-04-01 12 樱花 3 进击的巨人 第三季 2018-07-22 12 樱花 4 进击的巨人 第三季 Part.2 2019-04-28 10 樱花 5 进击的巨人 最终季 2020-12-06 16 樱花 6 进击的巨人 最终季 Part.2 2022-01-09 12 樱花 ","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/:3:0","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"MAD ","date":"2013-04-06","objectID":"/anime/shingeki_no_kyojin/:4:0","tags":null,"title":"进击的巨人","uri":"/anime/shingeki_no_kyojin/"},{"categories":null,"content":"　　别扭的，没有朋友，没有女朋友，对着那些讴歌青春的同学吐槽着“他们都是骗子，都在说谎，快点爆发把我”的男主角的爱情物语，将来的梦想是“不工作”——\n这样的高中生八幡被生活指导老师的带到了学校第一美少女雪乃所属的“侍奉部”，与美少女意想不到的相遇……怎么想都是恋爱故事的展开吧！？\n但是雪乃却无论如何都原谅不了八幡那令人残念的糟糕性格！\n不断轮回着的充满问题的青春——我的青春，到底怎么了！？","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"简介 别扭的，没有朋友，没有女朋友，对着那些讴歌青春的同学吐槽着“他们都是骗子，都在说谎，快点爆发把我”的男主角的爱情物语，将来的梦想是“不工作”—— 这样的高中生八幡被生活指导老师的带到了学校第一美少女雪乃所属的“侍奉部”，与美少女意想不到的相遇……怎么想都是恋爱故事的展开吧！？ 但是雪乃却无论如何都原谅不了八幡那令人残念的糟糕性格！ 不断轮回着的充满问题的青春——我的青春，到底怎么了！？ 制作人员： 原作：渡航 导演：吉村爱 脚本：高山克彦、待田堂子、菅正太郎 分镜：RoydenB、高桥秀弥、工藤利春 ","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/:1:0","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 比企谷八幡 大老师、比企谷 八幡、ひきがや はちまん、Hikigaya Hachiman、ヒッキー 男 江口拓也 2 雪之下雪乃 雪基百科、Yukino Yukinoshita、雪ノ下 雪乃、ゆきのした ゆきの、Yukinoshita Yukino、二小姐 女 早見沙織 3 由比滨结衣 ゆいがはま ゆい、Yuigahama Yui、团子 女 東山奈央 4 户冢彩加 戸塚 彩加、とつか さいか、Totsuka Saika 男 小松未可子 5 材木座义辉 材木座 義輝、Zaimokuza Yoshiteru 男 檜山修之 6 比企谷小町 ひきがや こまち、Hik","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/:2:0","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我的青春恋爱物语果然有问题 2013-04-04 13 bilibili 2 我的青春恋爱物语果然有问题 OVA 2013-09-19 1 bilibili 3 我的青春恋爱物语果然有问题 续 2015-04-02 13 bilibili 4 我的青春恋爱物语果然有问题 续 OVA 2016-10-27 1 bilibili 5 我的青春恋爱物语果然有问题 完 2020-07-09 12 bilibili ","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/:3:0","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"MAD ","date":"2013-04-04","objectID":"/anime/yahari_ore_no_seishun_love/:4:0","tags":null,"title":"我的青春恋爱物语果然有问题","uri":"/anime/yahari_ore_no_seishun_love/"},{"categories":null,"content":"RWBY，即红白黑黄，也被称作小红帽的逆袭。RWBY是红白黑黄的开头大写字母，代表的是红、白、黑、黄系列。\nRWBY是由外国知名同人（非职业）创作团队Monty Oum工作室制作。虽然在动画特效和声光处理方面，Monty Oum 的技术稍显业余，但他们对分镜和场面的用心度受到一致肯定，甚至能给观众带来超出好莱坞动作片的刺激临场感！","date":"2012-11-07","objectID":"/anime/rwby/","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"简介 RWBY，即红白黑黄，也被称作小红帽的逆袭。RWBY是红白黑黄的开头大写字母，代表的是红、白、黑、黄系列。 RWBY是由外国知名同人（非职业）创作团队Monty Oum工作室制作。虽然在动画特效和声光处理方面，Monty Oum 的技术稍显业余，但他们对分镜和场面的用心度受到一致肯定，甚至能给观众带来超出好莱坞动作片的刺激临场感！ 制作人员： 导演：蒙蒂·温 音乐：Jeff Williams 插入歌演出：Casey Lee Williams 动画制作：Rooster Teeth Productions ","date":"2012-11-07","objectID":"/anime/rwby/:1:0","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 露比·萝丝 小红帽、ルビー・ローズ 女 Lindsay Jones 2 怀丝·雪倪 ワイス・シュニー 女 Kara Eberle 3 布蕾克·贝拉多娜 ブレイク・ベラドンナ 女 Arryn Zech 4 阳小龙 ヤン・シャオロン 女 Barbara Dunkelman 5 亚当·托鲁斯 アダム・トーラス 男 Garrett Hunter 6 Roman Torchwick ローマン・トーチウィック 男 Gray G. Haddock 7 黑熊 Junior、ジュニア、Hei Xiong、ヘイ・ション 男 Jack Pattillo 8 Melanie Mal","date":"2012-11-07","objectID":"/anime/rwby/:2:0","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 RWBY预告片 2012-11-07 4 下方 2 红白黑黄 2013-07-18 16 bilibili 3 红白黑黄 第二季 2014-07-24 12 bilibili ","date":"2012-11-07","objectID":"/anime/rwby/:3:0","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"MAD ","date":"2012-11-07","objectID":"/anime/rwby/:4:0","tags":null,"title":"RWBY","uri":"/anime/rwby/"},{"categories":null,"content":"在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。\n\n时光飞逝，来到了19世纪末的英国。在这个人们的思想与生活产生激烈变化的时代，乔纳森·乔斯达与迪奥·布兰度相遇。二人一同渡过了少年时代到青年时代，最后因为「石鬼面」，而步上了奇特怪异的命运。\n\n以及在1938年的美国，乔纳森·乔斯达的孙子——乔瑟夫·乔斯达长大成人后的故事。为了守护他重视的人们，与苏醒的超级生物柱之男不停的战斗。","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"简介 在古代墨西哥繁盛一时的太阳的子民阿兹特克，他们流传着一枚奇妙的「石鬼面」。那是一枚奇迹的面具，能让人拥有一种力量，能获得永远的生命并成为真正的掌控者。然而从某个时候开始，就从历史中消失了踪影。 时光飞逝，来到了19世纪末的英国。在这个人们的思想与生活产生激烈变化的时代，乔纳森·乔斯达与迪奥·布兰度相遇。二人一同渡过了少年时代到青年时代，最后因为「石鬼面」，而步上了奇特怪异的命运。 以及在1938年的美国，乔纳森·乔斯达的孙子——乔瑟夫·乔斯达长大成人后的故事。为了守护他重视的人们，与苏醒的超级生物柱之男不停的战斗。 制作人员： 原作：荒木飞吕彦 导演：津田尚克 脚本：笔安一幸、小林靖子、","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/:1:0","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 乔纳森·乔斯达 ジョナサン・ジョースター、Jonathan Joestar、jojo 男 興津和幸 2 迪奥·布兰多 迪奥、DIO（3部）、Dio Brando、ディオ・ブランドー、屌爷，屌·不懒惰 男 子安武人 3 乔瑟夫·乔斯达 ジョセフ・ジョースター、Joseph Joestar、jojo 男 杉田智和 4 西撒·安东尼奥·齐佩利 Caesar Antonio Zeppeli 男 佐藤拓也 5 艾莉娜·班魯多 Erina Pendleton 女 川澄綾子 6 莉莎莉莎 エリザベス・ジョースター、伊丽莎白·乔斯达、Lisa Lisa 女 田中敦子 7 罗","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/:2:0","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 JOJO的奇妙冒险 2012-10-05 26 bilibili 2 JOJO的奇妙冒险 星尘斗士 2014-04-04 24 bilibili 3 JOJO的奇妙冒险 星尘斗士 埃及篇 2015-01-09 24 bilibili 4 JOJO的奇妙冒险 不灭钻石 2016-04-01 39 bilibili 5 JOJO的奇妙冒险 黄金之风 2018-10-05 39 bilibili 6 JOJO的奇妙冒险 石之海 2022-01-07 12 bilibili 7 JOJO的奇妙冒险 石之海 Part.2 2022-10-07 12 bi","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/:3:0","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"MAD ","date":"2012-10-05","objectID":"/anime/jojos_bizarre_adventure/:4:0","tags":null,"title":"JOJO的奇妙冒险","uri":"/anime/jojos_bizarre_adventure/"},{"categories":null,"content":"　　作品背景以1000年后的未来世界为基调，讲述了在1000年后日本的孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会「新世界」，是口吐真言凭藉「咒力」就能移动物体的人类，与有著等同于普通人智力的生物「妖鼠」共存的世界。乍看之下一切和平，但「新世界」的孩子们的行动被彻底地控制和管束著，不合适的记忆被消去，被认为有问题的孩子，如同不良产品般被分开处理。因为一些违反规则的小事而莫名地失去不少朋友的主人公早季，卷进了人类与妖鼠之间的战争。本作除了令人毛骨悚然的故事情节外，还对未来社会持续破坏自然环境所引发的一系列问题进行了一番探讨和思辨，也因此取得了08年的日本SF大赏殊荣。","date":"2012-09-28","objectID":"/anime/from_the_new_world/","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"简介 作品背景以1000年后的未来世界为基调，讲述了在1000年后日本的孩子们不断地消失，只存在想象中的恐怖动物与人类展开殊死战争。反乌托邦式的未来超级社会「新世界」，是口吐真言凭藉「咒力」就能移动物体的人类，与有著等同于普通人智力的生物「妖鼠」共存的世界。乍看之下一切和平，但「新世界」的孩子们的行动被彻底地控制和管束著，不合适的记忆被消去，被认为有问题的孩子，如同不良产品般被分开处理。因为一些违反规则的小事而莫名地失去不少朋友的主人公早季，卷进了人类与妖鼠之间的战争。本作除了令人毛骨悚然的故事情节外，还对未来社会持续破坏自然环境所引发的一系列问题进行了一番探讨和思辨，也因此取得了08年的日本","date":"2012-09-28","objectID":"/anime/from_the_new_world/:1:0","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 渡边早季 Saki Watanabe、渡辺 早季、わたなべ さき、Watanabe Saki 女 遠藤綾 2 朝比奈觉 あさひな さとる 男 梶裕貴 3 秋月真理亚 あきづき まりあ 女 花澤香菜 4 伊东守 いとうまもる 男 工藤晴香 5 青沼瞬 あおぬま しゅん 男 藤堂真衣 6 野狐丸 斯奎拉、野狐丸、やこまる 男 浪川大輔 7 奇狼丸 きろうまる 男 平田広明 8 天野丽子 あまの れいこ 女 堀江由衣 ","date":"2012-09-28","objectID":"/anime/from_the_new_world/:2:0","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 来自新世界 2012-09-28 25 bilibili ","date":"2012-09-28","objectID":"/anime/from_the_new_world/:3:0","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"MAD ","date":"2012-09-28","objectID":"/anime/from_the_new_world/:4:0","tags":null,"title":"来自新世界","uri":"/anime/from_the_new_world/"},{"categories":null,"content":"女大学生的花，与一个在大学教室认识的男子结婚，并成为两个孩子的母亲。\n\n不过，那个男子是“狼人”，姐姐“雪”和弟弟“雨”都是“狼的孩子”。即便如此，一家人还是在城市里过着幸福的生活。然而，在“雨”出生之后，男子却因为意外而去世。\n\n对于丈夫去世的悲伤，同时也为孩子未来“人·狼”抉择的担心。花决定带着孩子移居到深山的古居中，于是三人开始了新的生活……","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"简介 女大学生的花，与一个在大学教室认识的男子结婚，并成为两个孩子的母亲。 不过，那个男子是“狼人”，姐姐“雪”和弟弟“雨”都是“狼的孩子”。即便如此，一家人还是在城市里过着幸福的生活。然而，在“雨”出生之后，男子却因为意外而去世。 对于丈夫去世的悲伤，同时也为孩子未来“人·狼”抉择的担心。花决定带着孩子移居到深山的古居中，于是三人开始了新的生活…… 制作人员： 原作：细田守、MADHOUSE 脚本：奥寺佐渡子 音乐：高木正胜 人物设定：贞本义行 美术监督：大野广司 色彩设计：三笠修 作画监督：山下高明 ","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/:1:0","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 花 Hana、はな、Hana 女 宮﨑あおい 2 他 おおかみおとこ 男 大沢たかお 3 雪 ゆき、Yuki 女 黒木華 4 雨 あめ、Ame 男 5 庄子 Souko 女 春名風花 6 藤井草平 男 ","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/:2:0","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 狼的孩子雨和雪 2012-07-21 1 bilibili ","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/:3:0","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"MAD ","date":"2012-07-21","objectID":"/anime/okami_kodomo_no_ame_to_yuki/:4:0","tags":null,"title":"狼的孩子雨和雪","uri":"/anime/okami_kodomo_no_ame_to_yuki/"},{"categories":null,"content":"世界的人口因为不明原因而急降，逐渐步出历史的舞台，取而代之的是一种平均身高只有10公分、三头身的妖精。妖精的平均身高只有10公分，三头身的妖精们却拥有高度的智慧，而且非常喜欢吃糖果点心。主人公作为最后一届的毕业生毕业之后就回到故乡樟树之里去接续祖父的工作，成为负责斡旋在妖精与人类之间的重要国际公务员“调停官”。虽然如此，由于妖精很少跟人类接触，因此她根本没啥工作可作，因此她想要好好研究妖精的生态。","date":"2012-07-01","objectID":"/anime/humanity_has_declined/","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"简介 世界的人口因为不明原因而急降，逐渐步出历史的舞台，取而代之的是一种平均身高只有10公分、三头身的妖精。妖精的平均身高只有10公分，三头身的妖精们却拥有高度的智慧，而且非常喜欢吃糖果点心。主人公作为最后一届的毕业生毕业之后就回到故乡樟树之里去接续祖父的工作，成为负责斡旋在妖精与人类之间的重要国际公务员“调停官”。虽然如此，由于妖精很少跟人类接触，因此她根本没啥工作可作，因此她想要好好研究妖精的生态。 制作人员： 原作：田中罗密欧 导演：岸诚二 脚本：上江洲诚、绫奈由仁子、熊谷纯 分镜：森义博、大畑晃一、小坂春女、江上洁 ","date":"2012-07-01","objectID":"/anime/humanity_has_declined/:1:0","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 我 お菓子ちゃん、人类小姐 女 中原麻衣 2 助手 男 福山潤 3 爷爷 男 石塚運昇 4 友人Y 银发姑娘、丫、銀髪ちゃん、銀髪ちゃん/银发姑娘 女 沢城みゆき 5 P子 ぴおね、ピオン、PIONEER、パイオニア 女 水樹奈々 6 O太郎 おやげ、おやじ、VOYAGER、ボイジャー 男 檜山修之 7 一条先生 吐司 間宮くるみ 8 卷发 まきげ 女 金元寿子 ","date":"2012-07-01","objectID":"/anime/humanity_has_declined/:2:0","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 人类衰退之后 2012-07-01 12 bilibili ","date":"2012-07-01","objectID":"/anime/humanity_has_declined/:3:0","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"MAD ","date":"2012-07-01","objectID":"/anime/humanity_has_declined/:4:0","tags":null,"title":"人类衰退之后","uri":"/anime/humanity_has_declined/"},{"categories":null,"content":"以节能为座右铭的高中生折木奉太郎， 为一个小小的原因而加入了濒临废社的“古典文学部”。古典文学部的社员，包括他在社里认识的好奇宝宝，也就是女主角千反田爱瑠，还有他从国中就认识的伊原摩耶花和福部里志。这是他们四人以神山高中为舞台，对一桩桩事件展开推理的青春学园推理剧。“我很好奇！”奉太郎平静的灰色高中生活，因为千反田的这一句话而为之一变！","date":"2012-04-22","objectID":"/anime/hyouka/","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"简介 以节能为座右铭的高中生折木奉太郎， 为一个小小的原因而加入了濒临废社的“古典文学部”。古典文学部的社员，包括他在社里认识的好奇宝宝，也就是女主角千反田爱瑠，还有他从国中就认识的伊原摩耶花和福部里志。这是他们四人以神山高中为舞台，对一桩桩事件展开推理的青春学园推理剧。“我很好奇！”奉太郎平静的灰色高中生活，因为千反田的这一句话而为之一变！ 制作人员： 原作：米泽穗信 导演：武本康弘 脚本：贺东招二、村元克彦、江上美幸、西冈麻衣子 分镜：内海纮子、石立太一、河浪荣作 ","date":"2012-04-22","objectID":"/anime/hyouka/:1:0","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 折木奉太郎 折棒太郎、おれき ほうたろう、Oreki Houtarou、节能环保男 男 中村悠一 2 千反田爱瑠 吃蛋挞、千反田惠瑠、ちたんだ える、Chitanda Eru、L 女 佐藤聡美 3 福部里志 ふくべ さとし、Fukube Satoshi 男 阪口大助 4 伊原摩耶花 いばら まやか、Ibara Mayaka 女 茅野愛衣 5 远垣内将司 とうがいと まさし 男 置鮎龍太郎 6 折木供惠 折木 供恵、おれき ともえ、Oreki Tomoe 女 ゆきのさつき 7 糸鱼川养子 いといがわ ようこ 女 小山茉美 8 入须冬实 いりす ふゆみ 女 ゆか","date":"2012-04-22","objectID":"/anime/hyouka/:2:0","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 冰菓 2012-04-22 22 bilibili 2 冰菓 应该持有之物 2013-01-12 1 樱花 ","date":"2012-04-22","objectID":"/anime/hyouka/:3:0","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"MAD ","date":"2012-04-22","objectID":"/anime/hyouka/:4:0","tags":null,"title":"冰菓","uri":"/anime/hyouka/"},{"categories":null,"content":"近乎现实的世界中，有一位看似平凡的少女黑衣麻陶，于新一年展开其丰富璀璨的中学生活。这时，一位名为小鸟游优美的同班同学吸引了她的注意。起初对方不欲作深层交往，后来却因为彩虹小鸟的话题，而被麻陶见到小鸟游受到委屈的一面……\n充满怪异的世界中，一群人生活于如眼泪般蔚蓝的天空之下，每天都仿如战士般进行着明争暗斗，仿如正为他人承受遇到的苦恼和混乱不堪的思绪……","date":"2012-02-02","objectID":"/anime/black_rock_shooter/","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"简介 近乎现实的世界中，有一位看似平凡的少女黑衣麻陶，于新一年展开其丰富璀璨的中学生活。这时，一位名为小鸟游优美的同班同学吸引了她的注意。起初对方不欲作深层交往，后来却因为彩虹小鸟的话题，而被麻陶见到小鸟游受到委屈的一面…… 充满怪异的世界中，一群人生活于如眼泪般蔚蓝的天空之下，每天都仿如战士般进行着明争暗斗，仿如正为他人承受遇到的苦恼和混乱不堪的思绪…… 制作人员： 原作：B★RS Project 导演：吉冈忍 脚本：冈田麿里 分镜：江崎慎平、筱原俊哉、今石洋之、大州鹤太郎、雨宫哲 ","date":"2012-02-02","objectID":"/anime/black_rock_shooter/:1:0","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 黑衣麻陶 黑衣真透、黑衣真兔、黒衣 マト、くろい マト、Kuroi Mato 女 花澤香菜 2 小鸟游黄泉 小鸟游优美、小鳥遊 ヨミ、たかなし ヨミ、Takanashi Yomi 女 沢城みゆき 3 神足由宇 神足 ユウ、こうたり ユウ、Koutari Yu 女 阿澄佳奈 4 纳野沙耶 納野 サヤ、いりの サヤ、Irino Saya 女 能登麻美子 5 出灰篝 出灰加贺里、出灰 カガリ、いずりは カガリ、Izuriha Kagari 女 喜多村英梨 6 黑岩射手 BLACK★ROCK SHOOTER、ブラックロックシューター、B★RS、BRS 女 花澤香菜 ","date":"2012-02-02","objectID":"/anime/black_rock_shooter/:2:0","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 黑岩射手 2012-02-02 8 bilibili ","date":"2012-02-02","objectID":"/anime/black_rock_shooter/:3:0","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"MAD ","date":"2012-02-02","objectID":"/anime/black_rock_shooter/:4:0","tags":null,"title":"黑岩射手","uri":"/anime/black_rock_shooter/"},{"categories":null,"content":"　　26年前夜见山北中学的三年三班里，曾经有一位名叫「misaki」的学生。她不仅是位运动天才还是个优等生，个性平易近人广受众人喜爱的她却在某日突然猝死，极度悲伤的同班同学们无法接受这件事实，众人决定到毕业之前仍想像见崎还活著般度过每一天。因此见崎的座位就这样一大早上课会有人来打招呼，偶而还会有人藉机搭话——但这段美丽的插曲却对三年三班带来某种扭曲的现象。而在1998年春天，转到三年三班的榊原恒一，莫名感到班上的气氛持续著不安感。在这样的班级里，有位行事异于常人，孤高的美少女见崎鸣——一只眼睛遮著眼罩总是独自一人在画画，拥有不可思议的存在感让恒一不禁想试著接近她，但却就此陷入更深的谜团之中。\n　　随著故事的进展，班上的气氛越来越紧张，也有越来越多的人不知是巧合还是「诅咒」而意外生亡。在绫辻大师的笔触下，恐怖的气氛越发浓厚。","date":"2012-01-09","objectID":"/anime/another/","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"简介 26年前夜见山北中学的三年三班里，曾经有一位名叫「misaki」的学生。她不仅是位运动天才还是个优等生，个性平易近人广受众人喜爱的她却在某日突然猝死，极度悲伤的同班同学们无法接受这件事实，众人决定到毕业之前仍想像见崎还活著般度过每一天。因此见崎的座位就这样一大早上课会有人来打招呼，偶而还会有人藉机搭话——但这段美丽的插曲却对三年三班带来某种扭曲的现象。而在1998年春天，转到三年三班的榊原恒一，莫名感到班上的气氛持续著不安感。在这样的班级里，有位行事异于常人，孤高的美少女见崎鸣——一只眼睛遮著眼罩总是独自一人在画画，拥有不可思议的存在感让恒一不禁想试著接近她，但却就此陷入更深的谜团之中。","date":"2012-01-09","objectID":"/anime/another/:1:0","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 榊原恒一 さかきばら こういち、Sakakibara Koichi 男 阿部敦 2 见崎鸣 みさき めい、Misaki Mei 女 高森奈津美 3 敕使河原直哉 Naoya Teshigawara、敕使河原直哉、てしがわら なおや、炮哥 男 前野智昭 4 风见智彦 かざみともひこ 男 市来光弘 5 樱木由加利 樱木由香里、桜木ゆかり 女 野中藍 6 赤泽泉美 赤澤泉美、あかざわいずみ、Akazawa Izumi 女 米澤円 7 三神老师 三神先生、みかみ せんせい、Mikami Sensei 女 宮牧美沙代 8 怜子 女 榊原奈緒子 ","date":"2012-01-09","objectID":"/anime/another/:2:0","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Another 2012-01-09 12 樱花 2 Another 第0话 2012-05-25 1 bilibili ","date":"2012-01-09","objectID":"/anime/another/:3:0","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"MAD ","date":"2012-01-09","objectID":"/anime/another/:4:0","tags":null,"title":"Another","uri":"/anime/another/"},{"categories":null,"content":"天空湛蓝，万里无云。\n　　积雨云翻涌，仿佛要将彼岸的山隐藏。\n　　这是我们小镇上常见的风景。\n　　但是，也是无可替代的“盛夏”。\n　　那个男孩有一个模糊的想法“一无所有却想做点什么”，\n　　所以和同伴商量一起拍电影。\n　　就在那时，一个“特别”的女孩来到了这个小镇，\n　　然后将男孩的想法视为“特别”。\n　　男孩的名字是——雾岛海人。\n　　女孩的名字是——贵月一夏。\n　　他们的盛夏开始了。\n　　我们在那个盛夏等待——","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"简介 天空湛蓝，万里无云。 积雨云翻涌，仿佛要将彼岸的山隐藏。 这是我们小镇上常见的风景。 但是，也是无可替代的“盛夏”。 那个男孩有一个模糊的想法“一无所有却想做点什么”， 所以和同伴商量一起拍电影。 就在那时，一个“特别”的女孩来到了这个小镇， 然后将男孩的想法视为“特别”。 男孩的名字是——雾岛海人。 女孩的名字是——贵月一夏。 他们的盛夏开始了。 我们在那个盛夏等待—— 制作人员： 导演：长井龙雪 脚本：黑田洋介 分镜：铃木健太郎、樱井亲良、佐藤卓哉、樱美胜志、二瓶勇一、博史池畠 ","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/:1:0","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 贵月一夏 贵月一花、贵月一歌、貴月 イチカ、たかつき いちか、Takatsuki Ichika 女 戸松遥 2 雾岛海人 Kaito Kirishima、きりしま かいと、KIRISHIMA KAITO 男 島﨑信長 3 谷川柑菜 谷川柑菜、たにがわ かんな、TANIGAWA KANNA 女 石原夏織 4 石垣哲朗 石垣哲郎、石垣 哲朗、いしがき てつろう、Ishigaki Tetsurou 男 荻原秀樹 5 北原美樱 きたはら みお、Kitahara Mio 女 阿澄佳奈 6 山乃柠檬 やまの れもん、Yamano Remon、柠檬大魔王, Agent L","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/:2:0","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 在盛夏等待 2012-01-09 12 bilibili 2 在盛夏等待 特别篇 2014-08-29 1 bilibili ","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/:3:0","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"MAD ","date":"2012-01-09","objectID":"/anime/waiting_in_the_summer/:4:0","tags":null,"title":"在盛夏等待","uri":"/anime/waiting_in_the_summer/"},{"categories":null,"content":"故事讲述了活跃于宇宙快艇社团，并在高级咖啡厅打工的充满朝气的女子高中生茉莉香，某天在她的面前突然出现自称是已逝的父亲的部下的一男一女，还受到了担任宇宙海贼船“弁天丸”的船长的邀请。一个世纪以前，根据在独立战争中发行的私船免许证，船长死后所有的海贼船由其子孙接班。踏入无法预料的新生活的茉莉香，在前方等待她的究竟是……","date":"2012-01-07","objectID":"/anime/bodacious_space_pirates/","tags":null,"title":"暴力宇宙海贼","uri":"/anime/bodacious_space_pirates/"},{"categories":null,"content":"简介 故事讲述了活跃于宇宙快艇社团，并在高级咖啡厅打工的充满朝气的女子高中生茉莉香，某天在她的面前突然出现自称是已逝的父亲的部下的一男一女，还受到了担任宇宙海贼船“弁天丸”的船长的邀请。一个世纪以前，根据在独立战争中发行的私船免许证，船长死后所有的海贼船由其子孙接班。踏入无法预料的新生活的茉莉香，在前方等待她的究竟是…… 制作人员： 原作：笹本祐一 导演：佐藤龙雄 脚本：伊藤美智子、水野健太郎、宫崎真一 分镜：岛崎奈奈子、安田贤司、森健 ","date":"2012-01-07","objectID":"/anime/bodacious_space_pirates/:1:0","tags":null,"title":"暴力宇宙海贼","uri":"/anime/bodacious_space_pirates/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 格里埃尔·塞雷尼提 Gruier Serenity、グリューエル・セレニティ 女 戸松遥 2 加藤茉莉香 加藤 茉莉香、かとう まりか、Katou Marika 女 小松未可子 3 千秋·栗原 栗原千秋、栗原千明、チアキ・クリハラ、Chiaki Kurihara 女 花澤香菜 4 百眼 ひゃくめ 男 藤原啓治 5 加藤梨理香 かとう りりか 女 甲斐田裕子 6 库里尔 クーリエ 堀江由衣 7 远藤麻美 遠藤 マミ、えんどう マミ、Endou Mami 女 小見川千明 8 杰妮·德里特尔 女 佐藤利奈 ","date":"2012-01-07","objectID":"/anime/bodacious_space_pirates/:2:0","tags":null,"title":"暴力宇宙海贼","uri":"/anime/bodacious_space_pirates/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 暴力宇宙海贼 2012-01-07 26 bilibili ","date":"2012-01-07","objectID":"/anime/bodacious_space_pirates/:3:0","tags":null,"title":"暴力宇宙海贼","uri":"/anime/bodacious_space_pirates/"},{"categories":null,"content":"RPGMAKER引擎制作的角色扮演游戏。这虽然是个像素画微型游戏，流程只有几个小时并且没有真正的战斗；\n但是本作凭借精美细腻的演出效果，和感人的故事发展获得了许多好评。尤其是在2011年GameSpot的年度最佳游戏中，胜过凯瑟琳，\n传送门2等众多大作而获得了最佳剧本奖。","date":"2011-11-01","objectID":"/game/to_the_moon/","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"简介 RPGMAKER引擎制作的角色扮演游戏。这虽然是个像素画微型游戏，流程只有几个小时并且没有真正的战斗； 但是本作凭借精美细腻的演出效果，和感人的故事发展获得了许多好评。尤其是在2011年GameSpot的年度最佳游戏中，胜过凯瑟琳， 传送门2等众多大作而获得了最佳剧本奖。 制作人员： 开发：自由鸟工作室 发行：心动 遊戲設計師：高瞰 主题歌演出：劳拉·鴫原 ","date":"2011-11-01","objectID":"/game/to_the_moon/:1:0","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 Johnathan Wyles Johnny H. Wyles 男 2 River E. Wyles River Elisabeth Wyles 女 3 Neil Watts 男 4 Eva Rosalene 女 5 Robert Lin Rob 男 6 Roxanne Winters Roxie 女 ","date":"2011-11-01","objectID":"/game/to_the_moon/:2:0","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"系列 系列名 发行时间 1 去月球 2011-11-01 ","date":"2011-11-01","objectID":"/game/to_the_moon/:3:0","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"配乐 ","date":"2011-11-01","objectID":"/game/to_the_moon/:4:0","tags":null,"title":"去月球","uri":"/game/to_the_moon/"},{"categories":null,"content":"朝浦的日本轻小说作品，由柴乃棹人负责插画。\n走进宿舍附近超市的高中一年级学生佐藤洋，在将手伸向面前贴有半价标签的便当后立刻失去了意识，醒来后已经倒在肉品区前面，而半价便当早已失去踪影，剩下的配菜也几乎都被买光了。在他要拿剩下的梅子饭团时，遇到了同校女生白粉花，以及看着两人样子的女学生。\n隔天再次前往超商的佐藤，从人称“寒冰魔女”的女学生枪水仙处得知发生在超市的半价便当争夺战后，自己踏进了半价便当争夺战的世界。","date":"2011-10-08","objectID":"/anime/ben_to/","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"简介 朝浦的日本轻小说作品，由柴乃棹人负责插画。 走进宿舍附近超市的高中一年级学生佐藤洋，在将手伸向面前贴有半价标签的便当后立刻失去了意识，醒来后已经倒在肉品区前面，而半价便当早已失去踪影，剩下的配菜也几乎都被买光了。在他要拿剩下的梅子饭团时，遇到了同校女生白粉花，以及看着两人样子的女学生。 隔天再次前往超商的佐藤，从人称“寒冰魔女”的女学生枪水仙处得知发生在超市的半价便当争夺战后，自己踏进了半价便当争夺战的世界。 制作人员： 原作：朝浦 导演：板垣伸 脚本：安川正吾、岸本美雪、山田由香、笔安一幸 分镜：向井雅浩、加藤敏幸 ","date":"2011-10-08","objectID":"/anime/ben_to/:1:0","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐藤洋 さとうよう、satou you 男 下野紘 2 枪水仙 槍水 仙、やりずい せん、Yarizui Sen 女 伊瀬茉莉也 3 著莪菖蒲 しゃが あやめ、Shaga ayame 女 加藤英美里 4 白粉花 おしろい はな、Oshiroi Hana 女 悠木碧 5 白梅梅 しらうめうめ 女 茅野愛衣 6 金城优 かねしろ ゆう 男 宮野真守 7 井上马醉木 井ノ上 あせび、いのうえ あせび、Inoue Asebi 女 竹達彩奈 8 泽桔梗 沢桔梗、さわぎ きょう、Kyo Sawagi 女 田村ゆかり ","date":"2011-10-08","objectID":"/anime/ben_to/:2:0","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 便·当 2011-10-08 12 bilibili ","date":"2011-10-08","objectID":"/anime/ben_to/:3:0","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"MAD ","date":"2011-10-08","objectID":"/anime/ben_to/:4:0","tags":null,"title":"便·当","uri":"/anime/ben_to/"},{"categories":null,"content":"       从小时候起，绫濑千早的理想就只有一个——辅佐姐姐绫濑千岁称为日本第一的模特，为了实现这个理想，千早可谓是不择手段。但是，一个名为绵谷新的转学生彻底打碎了她的幻觉。“不是自己的事就不算梦想！”被绵谷一语点醒的千早决定将理想转移到绵谷教会她的“小仓百人一首竞技歌牌”上，一个全新的，为了自己的理想而不断奋斗的千早新鲜出炉了！\n作为青梅竹马，完美少年真岛太一一直暗恋着千早，可不知如何表达感情的他却总是忍不住的要欺负心爱着的千早。眼看着千早和绵谷因为歌牌越走越近，太一决定加入他们的“歌牌部”，同时也开始了千早的争夺战。时光飞逝，三人早已因为歌牌而结下了深厚的友谊，毕业在即，三人约定，只要歌牌存在一天，他们就终会再见面。","date":"2011-10-04","objectID":"/anime/chihaya_furu/","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"简介 从小时候起，绫濑千早的理想就只有一个——辅佐姐姐绫濑千岁称为日本第一的模特，为了实现这个理想，千早可谓是不择手段。但是，一个名为绵谷新的转学生彻底打碎了她的幻觉。“不是自己的事就不算梦想！”被绵谷一语点醒的千早决定将理想转移到绵谷教会她的“小仓百人一首竞技歌牌”上，一个全新的，为了自己的理想而不断奋斗的千早新鲜出炉了！ 作为青梅竹马，完美少年真岛太一一直暗恋着千早，可不知如何表达感情的他却总是忍不住的要欺负心爱着的千早。眼看着千早和绵谷因为歌牌越走越近，太一决定加入他们的“歌牌部”，同时也开始了千早的争夺战。时光飞逝，三人早已因为歌牌而结下了深厚的友谊，毕业在即，三人约定，只要歌牌存在一","date":"2011-10-04","objectID":"/anime/chihaya_furu/:1:0","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 绫濑千早 綾瀬 千早、あやせ ちはや、Ayase Chihaya 女 瀬戸麻沙美 2 绵谷新 わたや あらた、Wataya Arata、メガネくん 男 寺崎裕香 3 真岛太一 真島 太一、ましま たいち、Mashima Taichi 男 宮野真守 4 大江奏 大江 奏、おおえ かなで、Ooe Kanade 女 茅野愛衣 5 西田优征 西田 優征、にしだ ゆうせい、Nishida Yuusei 男 奈良徹 6 驹野勉 駒野 勉、こまの つとむ、Komano Tsutomu 男 代永翼 7 若宫诗畅 若宮 詩暢、わかみや しのぶ、wakamiya shinobu","date":"2011-10-04","objectID":"/anime/chihaya_furu/:2:0","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 歌牌情缘 2011-10-04 25 bilibili 2 歌牌情缘2 2013-01-11 25 bilibili 3 歌牌情缘3 2019-10-22 24 bilibili ","date":"2011-10-04","objectID":"/anime/chihaya_furu/:3:0","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"MAD ","date":"2011-10-04","objectID":"/anime/chihaya_furu/:4:0","tags":null,"title":"歌牌情缘","uri":"/anime/chihaya_furu/"},{"categories":null,"content":"被各国分割统治的中世纪的神州·日本。在那上空中由八艘船组成的都市舰“武藏”航行着……在遥远的未来。经过了“重奏统合争乱”，并把联繫着人类的命运的“圣谱”作为原本历史的再现而执行的各国。然后，是各式各样把迷惑与决意藏于胸口，前进开拓着未来的人们。把互相重合的中世纪世界作为舞台，学生们在学园国家间的抗争正式上演了！","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"简介 被各国分割统治的中世纪的神州·日本。在那上空中由八艘船组成的都市舰“武藏”航行着……在遥远的未来。经过了“重奏统合争乱”，并把联繫着人类的命运的“圣谱”作为原本历史的再现而执行的各国。然后，是各式各样把迷惑与决意藏于胸口，前进开拓着未来的人们。把互相重合的中世纪世界作为舞台，学生们在学园国家间的抗争正式上演了！ 制作人员： 原作：川上稔 导演：小野学 脚本：水上清资、富田赖子、浦畑达彦、砂山藏澄 分镜：京极尚彦、宅野诚起、田边泰裕 ","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/:1:0","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 葵·托利 Tori Aoi、あおい・トーリ、“不可能男” / 「インポッシブル」 男 福山潤 2 赫莱森·阿利亚达斯特 Horizon Ariadust、ホライゾン・アリアダスト、P-01s 女 茅原実里 3 本多·正纯 Honda Masazumi、ほんだ まさずみ 女 沢城みゆき 4 葵·喜美 Aoi Kimi、あおい・きみ 女 斎藤千和 5 点蔵・クロスユナイト てんぞう・クロスユナイト 男 小野大輔 6 マルゴット・ナイト 女 東山奈央 7 マルガ・ナルゼ 女 新田恵海 8 直政 なおまさ 女 真堂圭 ","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/:2:0","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 境界线上的地平线 2011-10-01 13 bilibili 2 境界线上的地平线 第二季 2012-07-07 13 樱花 3 境界线上的地平线 Blu-ray BOX 特典动画 2018-12-21 1 bilibili ","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/:3:0","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"MAD ","date":"2011-10-01","objectID":"/anime/kyoukai_senjou_no_horizon/:4:0","tags":null,"title":"境界线上的地平线","uri":"/anime/kyoukai_senjou_no_horizon/"},{"categories":null,"content":"《Fate/Zero》，2006年12月29日由TYPE-MOON与Nitro+合作发售的小说。为《Fate/stay night》的前传，以描述第四次圣杯之战为主，故事原著《Fate/stay night》则为第五次圣杯之战。\n\n这里是故事的原点（zero）---\n\n为了获得圣杯能实现奇迹的法力，七个魔术士召唤出七人的英灵，展开了一场直到剩下最后一个人为止的终极战争----圣杯战争。\n之前三次没有结果的战役不足以让这场战争结束，第四场战役如今有如弦上之箭，一触即发。\n寄托着必胜的信念，魔术师们来到了被称作「冬木」的战场。但是在他们当中有一个人却不知道自己是为何而战。他叫---言峰绮礼。\n命运的引导让绮礼逐渐失去了自己的判断力，他不明白为什么自己会被授予令咒。但是，命运很快地安排他遇到了一个命中注定的宿敌---卫宫切嗣。\n这个男人想要得到圣杯的欲望比任何人都要强烈，使用的手段也是最残忍的。\n在大人气游戏『Fate/stay night』中仅略有提到过的，十年前发生的「第四次圣杯战争」的真相。士郎的养父，凛的父亲，以及年轻气盛的言峰绮礼是如何参与这场战争的，真相即将浮出水面。","date":"2011-10-01","objectID":"/anime/fate_zero/","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"简介 《Fate/Zero》，2006年12月29日由TYPE-MOON与Nitro+合作发售的小说。为《Fate/stay night》的前传，以描述第四次圣杯之战为主， 故事原著《Fate/stay night》则为第五次圣杯之战。 这里是故事的原点（zero）— 为了获得圣杯能实现奇迹的法力，七个魔术士召唤出七人的英灵，展开了一场直到剩下最后一个人为止的终极战争—-圣杯战争。 之前三次没有结果的战役不足以让这场战争结束，第四场战役如今有如弦上之箭，一触即发。 寄托着必胜的信念，魔术师们来到了被称作「冬木」的战场。但是在他们当中有一个人却不知道自己是为何而战。他叫—言峰绮礼。 命运的引导让","date":"2011-10-01","objectID":"/anime/fate_zero/:1:0","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 卫宫切嗣 衛宮切嗣、えみや きりつぐ、Emiya Kiritsugu、アサシン / Assassin 男 小山力也 2 阿尔托莉雅·潘德拉贡 Saber、呆毛王、吾王、青王、骑士王、棉被王、亚瑟王、蓝Saber、元祖Saber、Altria Pendragon、セイバー 女 川澄綾子 3 爱丽丝菲尔·冯·爱因兹贝伦 Irisviel von Einzbern、アイリスフィール・フォン・アインツベルン、Airisufīru fon aintsuberun 女 大原さやか 4 远坂时臣 遠坂時臣、とおさか ときおみ、Tōsaka Tokiomi 男 速水奨 5 ","date":"2011-10-01","objectID":"/anime/fate_zero/:2:0","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Fate/Zero 2011-10-01 25 bilibili ","date":"2011-10-01","objectID":"/anime/fate_zero/:3:0","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"MAD ","date":"2011-10-01","objectID":"/anime/fate_zero/:4:0","tags":null,"title":"Fate/Zero","uri":"/anime/fate_zero/"},{"categories":null,"content":"某年夏天，6岁小女孩竹川萤来到爷爷家度假，她闯进了传说住满妖怪的山神森林。正当她因为迷路而焦急万分的时候，一个戴着狐狸面具的大男孩出现在她面前，并引领着萤找到回家的路。虽然萤分外感激，可是男孩却禁止她碰触自己的身体，原来这名叫银的男孩并非人类，他一旦被人类碰触就会烟消云散。在此后的日子里，萤和银成为好朋友，他们走遍了森林的每一个角落玩耍。日复一日，年复一年，每到夏天的时候萤就会如约来到森林和好朋友见面。她遵守着和银的约定，无论如何也不碰触银的身体。随着年龄的增长，萤和银对彼此的情感都悄悄发生了变化，他们共同期待相聚的日子，共同期待拥抱对方……","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"简介 某年夏天，6岁小女孩竹川萤来到爷爷家度假，她闯进了传说住满妖怪的山神森林。正当她因为迷路而焦急万分的时候，一个戴着狐狸面具的大男孩出现在她面前，并引领着萤找到回家的路。虽然萤分外感激，可是男孩却禁止她碰触自己的身体，原来这名叫银的男孩并非人类，他一旦被人类碰触就会烟消云散。在此后的日子里，萤和银成为好朋友，他们走遍了森林的每一个角落玩耍。日复一日，年复一年，每到夏天的时候萤就会如约来到森林和好朋友见面。她遵守着和银的约定，无论如何也不碰触银的身体。随着年龄的增长，萤和银对彼此的情感都悄悄发生了变化，他们共同期待相聚的日子，共同期待拥抱对方…… 制作人员： 原作：绿川幸 导演：大森贵弘 音","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/:1:0","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 银 男 内山昂輝 2 竹川萤 竹川 蛍、たけかわほたる 女 佐倉綾音 ","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/:2:0","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 萤火之森 2011-09-17 45m bilibili ","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/:3:0","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"MAD ","date":"2011-09-17","objectID":"/anime/into_the_forest_of_fireflies_light/:4:0","tags":null,"title":"萤火之森","uri":"/anime/into_the_forest_of_fireflies_light/"},{"categories":null,"content":"幾原邦彦所监督的原创动画，以高仓家的三兄妹——双子兄弟高仓冠叶和高仓晶马，以及体弱多病的妹妹高仓阳毬为中心展开的故事。\n某天兄弟二人带着时日无多的妹妹去水族馆游玩，久未外出的阳毬在人群中忽然倒下气绝。之后在停尸间，在绝望的兄弟二人面前，死去的妹妹又突然戴着企鹅帽子站起来，大喊道“生存战略！”“妾身已为此女续命！”然而当企鹅帽子掉落时，阳毬又恢复成了平常的样子。\n靠着不可思议的企鹅帽子，阳毬的生命得以延续。当戴着企鹅帽的阳毬再次出现时，她对高仓兄弟下令道：“去拿到企鹅罐！”","date":"2011-07-07","objectID":"/anime/penguin_drum/","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"简介 幾原邦彦所监督的原创动画，以高仓家的三兄妹——双子兄弟高仓冠叶和高仓晶马，以及体弱多病的妹妹高仓阳毬为中心展开的故事。 某天兄弟二人带着时日无多的妹妹去水族馆游玩，久未外出的阳毬在人群中忽然倒下气绝。之后在停尸间，在绝望的兄弟二人面前，死去的妹妹又突然戴着企鹅帽子站起来，大喊道“生存战略！”“妾身已为此女续命！”然而当企鹅帽子掉落时，阳毬又恢复成了平常的样子。 靠着不可思议的企鹅帽子，阳毬的生命得以延续。当戴着企鹅帽的阳毬再次出现时，她对高仓兄弟下令道：“去拿到企鹅罐！” 制作人员： 导演：几原邦彦 脚本：古川知宏、伊神贵世、金子伸吾 分镜：山崎光惠、后藤圭二 ","date":"2011-07-07","objectID":"/anime/penguin_drum/:1:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 高仓冠叶 たかくらかんば、Takakura Kanba 男 木村昴 2 高仓晶马 たかくら しょうま、Takakura Shouma 男 木村良平 3 高仓阳毬 たかくら ひまり、Takakura Himari 女 荒川美穂 4 荻野目苹果 おぎのめ りんご、Oginome Ringo 女 三宅麻理恵 5 多蕗桂树 たぶき　けいじゅ、Tabuki Keijyu 男 石田彰 6 时笼百合 女 能登麻美子 7 夏芽真砂子 なつめ まさこ、Natsume Masako、碾碎姐 女 堀江由衣 8 渡濑真悧 わたせ さねとし、沉醉哥 男 小泉豊 ","date":"2011-07-07","objectID":"/anime/penguin_drum/:2:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 回转企鹅罐 2011-07-07 24 樱花 ","date":"2011-07-07","objectID":"/anime/penguin_drum/:3:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"配乐 ","date":"2011-07-07","objectID":"/anime/penguin_drum/:4:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"MAD ","date":"2011-07-07","objectID":"/anime/penguin_drum/:5:0","tags":null,"title":"回转企鹅罐","uri":"/anime/penguin_drum/"},{"categories":null,"content":"　　偶像，是女孩子们一直以来的憧憬。但能站在顶点的，只有仅仅数人。13位少女，就此经她们所属的事务所“765 Prodution”，跨进了那个充满竞争的世界……出道约半年，事务所来了一位全新的制作人。他跟少女们都下定决心，向顶级偶像之路进发…… 本作是由『A-1 Pictures』改编同名游戏于2011年7月制作的最新版动画，讲述了『765production』所属的偶像们活跃与成长的物语。\n\n2011年1月10日，在“The Idolm@ster 2 765pro H@ppiness New Ye@r P@rty!! 2011”的现场活动中，隆重地隆动地宣布了一个使所有fans非常雀跃的消息——「THE IDOLM@STER(偶像大师)」的动画化计划正式启动了! 那时虽然已经宣布了动画化，但是以什么媒传播放则还没有公布，再次TV动画，还是直接剧场版，还是只推出OVA? 这些疑问都在最新一号的「Megami杂志 3月号」上得以解答了，「THE IDOLM@STER」TV动画化正式决定!! ","date":"2011-07-07","objectID":"/anime/the_idolmaster/","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"简介 偶像，是女孩子们一直以来的憧憬。但能站在顶点的，只有仅仅数人。13位少女，就此经她们所属的事务所“765 Prodution”，跨进了那个充满竞争的世界……出道约半年，事务所来了一位全新的制作人。他跟少女们都下定决心，向顶级偶像之路进发…… 本作是由『A-1 Pictures』改编同名游戏于2011年7月制作的最新版动画，讲述了『765production』所属的偶像们活跃与成长的物语。 2011年1月10日，在“The Idolm@ster 2 765pro H@ppiness New Ye@r P@rty!! 2011”的现场活动中，隆重地隆动地宣布了一个使所有fans非常雀跃的消息","date":"2011-07-07","objectID":"/anime/the_idolmaster/:1:0","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天海春香 あまみ はるか、Amami Haruka、阁下 女 中村繪里子 2 星井美希 ほしい みき、Hoshii Miki 女 長谷川明子 3 如月千早 きさらぎ ちはや、Kisaragi Chihaya、72, 歌神 女 今井麻美 4 高槻弥生 たかつき やよい、Takatsuki Yayoi、やよいっち 女 仁後真耶子 5 萩原雪步 萩原雪歩、はぎわら ゆきほ、Hagiwara Yukiho、ゆきぴょん 女 浅倉杏美 6 菊地真 菊地 真、きくち まこと、Kikuchi Makoto 女 平田宏美 7 双海亚美 Ami Futami、ふたみ あみ、Fu","date":"2011-07-07","objectID":"/anime/the_idolmaster/:2:0","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 偶像大师 2011-07-07 26 bilibili 2 偶像大师 闪耀祭典 2012-10-25 3 bilibili 3 偶像大师 剧场版 向着光辉的彼岸！ 2014-01-25 1 bilibili ","date":"2011-07-07","objectID":"/anime/the_idolmaster/:3:0","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"MAD ","date":"2011-07-07","objectID":"/anime/the_idolmaster/:4:0","tags":null,"title":"偶像大师","uri":"/anime/the_idolmaster/"},{"categories":null,"content":"原作是《百合姫》连载中的百合漫画。\n在七森中学的校园里，无所事事四人帮——女主角赤座灯里、暴走的岁纳京子、吐糟役的船见结衣，以及在人前会伪装成可爱女孩的吉川千夏，擅自把废了部的茶道社部室据为己用，并且自称地建立了娱乐部。什么是娱乐部，当然就如其名字般只供娱乐(玩乐)的一个社部，作为学生会当然不能坐视不理，所以又以学生会副会长杉浦绫为首的4名学生会成员誓要与这“邪恶”的娱乐部周旋到底。另外，娱乐部的4位主角今次全采用次世代新人声优。","date":"2011-07-04","objectID":"/anime/yuruyuri/","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"简介 原作是《百合姫》连载中的百合漫画。 在七森中学的校园里，无所事事四人帮——女主角赤座灯里、暴走的岁纳京子、吐糟役的船见结衣，以及在人前会伪装成可爱女孩的吉川千夏，擅自把废了部的茶道社部室据为己用，并且自称地建立了娱乐部。什么是娱乐部，当然就如其名字般只供娱乐(玩乐)的一个社部，作为学生会当然不能坐视不理，所以又以学生会副会长杉浦绫为首的4名学生会成员誓要与这“邪恶”的娱乐部周旋到底。另外，娱乐部的4位主角今次全采用次世代新人声优。 制作人员： 原作：なもり 导演：太田雅彦 脚本：鸿野贵光、子安秀明、青岛崇、杉原研二 分镜：中西伸彰、志村宏明 ","date":"2011-07-04","objectID":"/anime/yuruyuri/:1:0","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 赤座灯里 Akkariin、Akkarin、Akarin、あかざ あかり、Akaza Akari、阿卡林/アッカリ〜ン 女 三上枝織 2 岁纳京子 としのう きょうこ、Toshinou Kyouko 女 大坪由佳 3 船见结衣 ふなみ ゆい、Funami Yui 女 津田美波 4 吉川千夏 しかわ ちなつ、Yoshikawa Chinatsu、China-chan、Chinacchi(ゆるゆり♪♪ep.2自述)、China(ゆるゆり♪♪ep.2) 女 大久保瑠美 5 杉浦绫乃 すぎうら あやの、Sugiura Ayano 女 藤田咲 6 池田千岁 いけだ ち","date":"2011-07-04","objectID":"/anime/yuruyuri/:2:0","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 摇曳百合 2011-07-04 12 樱花 2 摇曳百合♪♪ 2012-07-02 12 樱花 3 摇曳百合 夏日时光！ 2015-02-18 1 bilibili 4 摇曳百合 夏日时光！+ 2015-08-20 2 bilibili 5 摇曳百合 3☆High! 2015-10-05 12 樱花 6 摇曳百合、 2019-11-13 1 樱花 ","date":"2011-07-04","objectID":"/anime/yuruyuri/:3:0","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"MAD ","date":"2011-07-04","objectID":"/anime/yuruyuri/:4:0","tags":null,"title":"摇曳百合","uri":"/anime/yuruyuri/"},{"categories":null,"content":"从小时候起一直青梅竹马的6人，却在升上高中之后彼此有了距离。不太与人们接触的主角宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道、只有幼年死去的本间芽衣子（灵魂，只有仁太能看见）还是一如从前。有一天，芽衣子对仁太说：“帮我实现一个愿望吧”。仁太虽然有点为难，却还是答应帮助面码实现愿望。以此为契机，为了实现芽衣子的愿望，分散在各处的大家又再次地聚集在一起。","date":"2011-04-14","objectID":"/anime/anohana/","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"简介 从小时候起一直青梅竹马的6人，却在升上高中之后彼此有了距离。不太与人们接触的主角宿海仁太、有点被小太妹熏染的安城鸣子、进入重点高中的松雪集与鹤见知利子、放弃读高中而展开旅行的久川铁道、只有幼年死去的本间芽衣子（灵魂，只有仁太能看见）还是一如从前。有一天，芽衣子对仁太说：“帮我实现一个愿望吧”。仁太虽然有点为难，却还是答应帮助面码实现愿望。以此为契机，为了实现芽衣子的愿望，分散在各处的大家又再次地聚集在一起。 制作人员： 原作：超和平Busters 导演：长井龙雪 脚本：冈田麿里 分镜：今泉贤一、吉村爱、森田宏幸、伊藤智彦、筱原俊哉 ","date":"2011-04-14","objectID":"/anime/anohana/:1:0","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 本间芽衣子 间芽、ほんま めいこ、Honma Meiko、めんま 女 茅野愛衣 2 宿海仁太 やどみ じんた、Yadomi Jinta、じんたん 男 入野自由 3 安城鸣子 安城 鳴子、あんじょう なるこ、Anjou Naruko、アナル,あなる 女 戸松遥 4 松雪集 松雪 集、まつゆき あつむ、Matsuyuki Atsumu、ゆきあつ 男 櫻井孝宏 5 鹤见知利子 つるみ ちりこ、Tsurumi Chiriko、つるこ 女 早見沙織 6 久川铁道 久川 鉄道、ひさかわ てつどう、Hisakawa Tetsudou、ぽっぽ 男 近藤孝行 7 本间伊伦 И","date":"2011-04-14","objectID":"/anime/anohana/:2:0","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我们仍未知道那天所看见的花的名字。 2011-04-14 11 bilibili ","date":"2011-04-14","objectID":"/anime/anohana/:3:0","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"MAD ","date":"2011-04-14","objectID":"/anime/anohana/:4:0","tags":null,"title":"我们仍未知道那天所看见的花的名字。","uri":"/anime/anohana/"},{"categories":null,"content":"       故事发生在「CHAOS;HEAD」的“涩谷崩坏”事件一年半之后的世界，而舞台则从涩谷转移到了秋叶原。主角冈部伦太郎是一位深度中二病的大学生，时常幻想自己身肩重任，并自称“狂气的疯狂科学家・凤凰院凶真”，不过说到底其作为不过就是在名为“未来道具研究所”中与两个伙伴开发着奇奇怪怪又不切实际的东西。然而，这样的他们却在偶然间发明出可以把电子讯息传送过去的时间机器。在他们对未来及过去知道得越多的同时，却不知道危难正渐渐临到自己身上……","date":"2011-04-06","objectID":"/anime/steins_gate/","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"简介 故事发生在「CHAOS;HEAD」的“涩谷崩坏”事件一年半之后的世界，而舞台则从涩谷转移到了秋叶原。主角冈部伦太郎是一位深度中二病的大学生，时常幻想自己身肩重任，并自称“狂气的疯狂科学家・凤凰院凶真”，不过说到底其作为不过就是在名为“未来道具研究所”中与两个伙伴开发着奇奇怪怪又不切实际的东西。然而，这样的他们却在偶然间发明出可以把电子讯息传送过去的时间机器。在他们对未来及过去知道得越多的同时，却不知道危难正渐渐临到自己身上…… 制作人员： 原作：5pb.、Nitro+ 导演：佐藤卓哉、滨崎博嗣、小林智树 脚本：横谷昌宏、花田十辉、根元岁三、林直孝 ","date":"2011-04-06","objectID":"/anime/steins_gate/:1:0","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 冈部伦太郎 岡部倫太郎、おかべ りんたろう、Okabe Rintarou、冈伦（真由理对冈部伦太郎的“爱称”），凤凰院变态凶真、狂气的疯狂科学家、凤凰院凶真(鳳凰院 凶真,ほうおういん きょうま,Hooin Kyoma) 男 宮野真守 2 牧濑红莉栖 Chris Makise、牧瀬 紅莉栖、まきせ くりす、Makise Kurisu、天才少女，THE ZOMBIE/复苏者，克里斯蒂娜，天才，天才变态少女，放荡天才变态少女，助手，变态，セレブ・セブンティーン/Celeb Seventeen/土豪十七，セレセブ/Celeb Sev/土七，最爱实验妹， 蒙古斑少女","date":"2011-04-06","objectID":"/anime/steins_gate/:2:0","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 命运石之门 2011-04-06 25 樱花 2 命运石之门 负荷领域的既视感 2013-04-20 1 bilibili 3 命运石之门 0 2018-04-11 24 樱花 ","date":"2011-04-06","objectID":"/anime/steins_gate/:3:0","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"MAD ","date":"2011-04-06","objectID":"/anime/steins_gate/:4:0","tags":null,"title":"命运石之门","uri":"/anime/steins_gate/"},{"categories":null,"content":"——大都市“柳木原”。巨大的繁华街道。\n——冬季。抬头，映入眼帘便是毫无表情的纯白天空。\n逃避现实的学生羽田隆；贫困自由业者千岁鹫介；还有无业游民成田隼人。\n各自怀抱着不同烦恼的年轻人们。他们也将与属于他们的恋爱相遇","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"简介 ——大都市“柳木原”。巨大的繁华街道。 ——冬季。抬头，映入眼帘便是毫无表情的纯白天空。 逃避现实的学生羽田隆；贫困自由业者千岁鹫介；还有无业游民成田隼人。 各自怀抱着不同烦恼的年轻人们。他们也将与属于他们的恋爱相遇 制作人员： 原作：Navel 导演：后信治 脚本：青岛崇、中村浩二郎、鸿野贵光、王雀孙 分镜：及川启、德本善信、星野真 ","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/:1:0","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 羽田鹰志 はねだ たかし、Haneda Takashi、ホーク、ホーク卿、汰架示、チェリーボーイ 男 下野紘 2 千岁鹫介 ちとせ しゅうすけ、Chitose Shusuke、イーグル、シュウちゃん、糞ワシ、チィ兄ちゃん 男 三浦祥朗 3 成田隼人 なりた はやと、Narita Hayato、ファルコン、ドラ、ハマユリ 男 諏訪部順一 4 伊丹伽楼罗 いたみ かるら、Itami Karura、ガルーダ、陛下 男 稲田徹 5 渡来明日香 超特急わたライナー、わたらい あすか、Watarai Asuka、渡らないさん 女 吉田真弓 6 玉泉日和子 細川玉木、细川","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/:2:0","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我们没有翅膀 2011-04-03 12 樱花 2 我们没有翅膀 OVA 2011-06-26 1 ","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/:3:0","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"MAD ","date":"2011-04-03","objectID":"/anime/oretachi_ni_tsubasa_wa_nai/:4:0","tags":null,"title":"我们没有翅膀","uri":"/anime/oretachi_ni_tsubasa_wa_nai/"},{"categories":null,"content":"故事的主角机器人——东云名乃，一直憧憬成为一名普通的女生，却因为背上的发条而感到自卑，在被自称为博士的8岁萝莉胡乱改造之后，每次都无可奈何地感到自己与“普通女生”的距离越来越远了。除了萝莉博士外，故事还出现了很多非日常角色，如年龄为20岁且戴上博士制作的项圈能说话的黑猫、活泼且天然呆的吐槽女、擅长绘画的腐女、黑发眼镜女、外表看似不良少年实质很乖巧的男生、热爱麻糬的爆炸头男、被枪或火箭炮打到都不会死的演剧社社长等等。","date":"2011-04-02","objectID":"/anime/nichijou/","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"简介 故事的主角机器人——东云名乃，一直憧憬成为一名普通的女生，却因为背上的发条而感到自卑，在被自称为博士的8岁萝莉胡乱改造之后，每次都无可奈何地感到自己与“普通女生”的距离越来越远了。除了萝莉博士外，故事还出现了很多非日常角色，如年龄为20岁且戴上博士制作的项圈能说话的黑猫、活泼且天然呆的吐槽女、擅长绘画的腐女、黑发眼镜女、外表看似不良少年实质很乖巧的男生、热爱麻糬的爆炸头男、被枪或火箭炮打到都不会死的演剧社社长等等。 制作人员： 原作：新井圭一 导演：石原立也 脚本：石立太一、伊藤敦、村元克彦、西冈麻衣子、花田十辉 ","date":"2011-04-02","objectID":"/anime/nichijou/:1:0","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 相生祐子 あいおい ゆうこ、Aioi Yuuko、小祐 女 本多真梨子 2 长野原美绪 ながのはら みお、Naganohara Mio 女 相沢舞 3 水上麻衣 みなかみ まい、Minakami Mai 女 富樫美鈴 4 东云名乃 しののめ なの、Shinonome Nano 女 古谷静佳 5 博士 Hakase 女 今野宏美 6 阪本先生 大將、さかもとさん、sakamotosan、阪本 雄 白石稔 7 立花美里 立花 みさと、たちばな みさと、Tachibana Misato 女 堀川千華 8 笹原幸治郎 笹原 幸治郎、ささはら こうじろう、Sasaha","date":"2011-04-02","objectID":"/anime/nichijou/:2:0","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 日常 2011-04-02 26 bilibili ","date":"2011-04-02","objectID":"/anime/nichijou/:3:0","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"MAD ","date":"2011-04-02","objectID":"/anime/nichijou/:4:0","tags":null,"title":"日常","uri":"/anime/nichijou/"},{"categories":null,"content":"这是讲述一个少女养猫的平淡故事。\n号称耗资三千元打造的中国动画癫疯之作。\n故事主要讲述一个少女养猫而发生的种种离奇事件，整个作品画面风格很“中国式”。故事情节搞笑！目前正在连载中。","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"简介 这是讲述一个少女养猫的平淡故事。 号称耗资三千元打造的中国动画癫疯之作。 故事主要讲述一个少女养猫而发生的种种离奇事件，整个作品画面风格很“中国式”。故事情节搞笑！目前正在连载中。 制作人员： 导演：章平 配音监督：北斗企鹅（北京）文化传播有限公司 动画制作：北京寒木春华动画技术有限公司 ","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/:1:0","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 罗小黑 Luo、小黑 男 山新 2 罗小白 小白 女 山新 3 谛听 男 皇贞季 4 阿根 玄离 男 山新 5 山新 女 山新 6 比丢 Biu 7 皇受 ♂ 8 老君 男 ","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/:2:0","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 罗小黑战记 2011-03-17 40 bilibili 2 罗小黑战记电影版 2019-09-07 1 bilibili ","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/:3:0","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"MAD ","date":"2011-03-17","objectID":"/anime/luo_xiao_hei/:4:0","tags":null,"title":"罗小黑战记","uri":"/anime/luo_xiao_hei/"},{"categories":null,"content":"出生良好家庭，亲朋好友团聚，时哭时笑，这是谁都拥有的日常生活。\n市立见泷原中学的平凡初二女生鹿目圆，就是其中一位。\n一天，一个不可思议的人出现在她眼前。\n不知是偶然抑或注定，可以肯定的是，这相遇改变了她的命运，一个新的魔法少女故事亦随即开始。","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"简介 出生良好家庭，亲朋好友团聚，时哭时笑，这是谁都拥有的日常生活。 市立见泷原中学的平凡初二女生鹿目圆，就是其中一位。 一天，一个不可思议的人出现在她眼前。 不知是偶然抑或注定，可以肯定的是，这相遇改变了她的命运，一个新的魔法少女故事亦随即开始。 制作人员： 原作：Magica Quartet 导演：新房昭之 脚本：虚渊玄 分镜：龙轮直征、芦野芳晴、西田正义、岩崎安利、笹木信作、伊藤智彦 ","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/:1:0","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鹿目圆 小圆、鹿目圆香、鹿目 まどか、かなめ まどか、Kaname Madoka、圆神、小圆、馒头卡 女 悠木碧 2 晓美焰 晓美炎、暁美 ほむら、あけみ ほむら、Akemi Homura、吼姆拉、吼姆辣酱、焰魔 女 斎藤千和 3 美树沙耶香 美树沙耶加、美樹 さやか、みき さやか、Miki Sayaka、蓝毛、美树爽 女 喜多村英梨 4 巴麻美 巴 マミ、ともえ マミ、Tomoe Mami、学姐 女 水橋かおり 5 佐仓杏子 佐倉 杏子、さくら きょうこ、Sakura Kyouko、红毛 女 野中藍 6 丘比 久兵衛（时女一族称）、淫兽、安利始祖、QB、Q","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/:2:0","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔法少女小圆 2011-01-07 12 bilibili 2 剧场版 魔法少女小圆 [新篇] 叛逆的物语 2013-10-26 1 bilibili ","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/:3:0","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"MAD ","date":"2011-01-07","objectID":"/anime/puella_magi_madoka_magica/:4:0","tags":null,"title":"魔法少女小圆","uri":"/anime/puella_magi_madoka_magica/"},{"categories":null,"content":"　　这是一个关于遥远未来的故事。\n五年一度的宇宙速度对决“REDLINE”马上就要开幕！\n表面上看起来很酷，梳着飞机头身穿夹克的JP实际上是一个非常害羞的男性，为了得到初恋女孩索诺西的眷顾，JP参加了“REDLINE”的速度盛宴。“REDLINE”的比赛没有规则，为了取得胜利参赛者可以随身装载武器，这是一场赌上性命的对决。最糟的还不仅于此，这次比赛的举办场地竟然是号称史上最恶的军事国家罗伯瓦尔特（机器人世界），参赛者得知消息后纷纷退出比赛。然而，JP和他心仪的女孩索诺西毅然决定参加比赛。在比赛当天，JP的儿时玩伴天才机械师弗里斯彼为JP准备了最棒的跑车。但是跑车上却被安装了炸弹。弗里斯彼因为某个原因与人合谋了这场比赛。知道真相的JP毅然决然踩下了跑车的油门。这个时候，罗伯瓦尔特下达了阻止“REDLINE”开赛的出击命令。对索诺西的爱恋，与弗里斯彼的纠葛以及罗伯瓦尔特的妨碍，JP要如何打破这纠缠交错的命运！","date":"2010-10-09","objectID":"/anime/redline/","tags":null,"title":"红线","uri":"/anime/redline/"},{"categories":null,"content":"简介 这是一个关于遥远未来的故事。 五年一度的宇宙速度对决“REDLINE”马上就要开幕！ 表面上看起来很酷，梳着飞机头身穿夹克的JP实际上是一个非常害羞的男性，为了得到初恋女孩索诺西的眷顾，JP参加了“REDLINE”的速度盛宴。“REDLINE”的比赛没有规则，为了取得胜利参赛者可以随身装载武器，这是一场赌上性命的对决。最糟的还不仅于此，这次比赛的举办场地竟然是号称史上最恶的军事国家罗伯瓦尔特（机器人世界），参赛者得知消息后纷纷退出比赛。然而，JP和他心仪的女孩索诺西毅然决定参加比赛。在比赛当天，JP的儿时玩伴天才机械师弗里斯彼为JP准备了最棒的跑车。但是跑车上却被安装了炸弹。弗里斯彼因为","date":"2010-10-09","objectID":"/anime/redline/:1:0","tags":null,"title":"红线","uri":"/anime/redline/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 JP Joshua·Punkhead 男 木村拓哉 2 索诺西·玛格雷 女 蒼井優 3 Trava Trava、Trava 男 津田寛治 ","date":"2010-10-09","objectID":"/anime/redline/:2:0","tags":null,"title":"红线","uri":"/anime/redline/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 红线 2010-10-09 1 bilibili ","date":"2010-10-09","objectID":"/anime/redline/:3:0","tags":null,"title":"红线","uri":"/anime/redline/"},{"categories":null,"content":"舞岛学园的桂木桂马是个喜欢玩恋爱模拟游戏——也就是Galgame——的高中生。他有着无论怎样的女性（限定Galgame中的二次元可攻略角色）都能攻略的技巧，在游戏界中被称为“攻陷之神”；而他本人也比谁都深爱着这些二次元美少女们。\n\n某日，桂马意外地与恶魔订下契约，眼前出现了一位从遥远的地狱来到这里的恶魔少女艾鲁西。她的目的是拜托桂马帮忙捕获从地狱逃走的“驱魂”。驱魂会躲藏在女性的内心空隙，而填满内心空隙、赶出驱魂的其中一个方法就是“恋爱”。在不履行契约就会身首异处的威胁下，二次元的攻陷之神开始了未曾挑战过的三次元女性攻略之路。","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"简介 舞岛学园的桂木桂马是个喜欢玩恋爱模拟游戏——也就是Galgame——的高中生。他有着无论怎样的女性（限定Galgame中的二次元可攻略角色）都能攻略的技巧，在游戏界中被称为“攻陷之神”；而他本人也比谁都深爱着这些二次元美少女们。 某日，桂马意外地与恶魔订下契约，眼前出现了一位从遥远的地狱来到这里的恶魔少女艾鲁西。她的目的是拜托桂马帮忙捕获从地狱逃走的“驱魂”。驱魂会躲藏在女性的内心空隙，而填满内心空隙、赶出驱魂的其中一个方法就是“恋爱”。在不履行契约就会身首异处的威胁下，二次元的攻陷之神开始了未曾挑战过的三次元女性攻略之路。 制作人员： 原作：若木民喜 导演：高柳滋仁 脚本：高桥龙也、仓","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/:1:0","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 桂木桂马 かつらぎ けいま、Katsuragi Keima 男 下野紘 2 中川奏音 中川花音、中川嘉音、中川加侬、Kanon Nakagawa、なかがわ かのん、Nakagawa Kanon 女 東山奈央 3 高原步美 たかはら あゆみ、takahara ayumi 女 竹達彩奈 4 汐宫栞 汐宫刊、しおみや しおり、shiomiya shiori 女 花澤香菜 5 青山美生 あおやま みお 女 悠木碧 6 艾利由西亚·D·鲁德·伊玛 艾鲁西、Elsea De Lute Irma、エルシィ 女 伊藤かな恵 7 飞鸟空 あすか そら 女 櫻井智 8 桂木麻里","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/:2:0","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 只有神知道的世界 2010-10-06 12 樱花 2 只有神知道的世界II 2011-04-11 12 樱花 3 只有神知道的世界 天理篇 2012-10-18 2 樱花 4 只有神知道的世界 女神篇 2013-07-08 12 樱花 ","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/:3:0","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"MAD ","date":"2010-10-06","objectID":"/anime/kami_no_mizu_shiru_sekai/:4:0","tags":null,"title":"只有神知道的世界","uri":"/anime/kami_no_mizu_shiru_sekai/"},{"categories":null,"content":"　　一个前世作恶多端、永世不得投胎的灵魂，却因天使的抽签活动，获得复活的机会。他借用了一位14岁的少年身体，展开一段奇妙的寄身生活。在守护天使的帮助下，他在生活中感受到酸甜苦辣，从开始的不甘情愿到体会活著的美妙。逐渐地他与家人、同学产生感情，并找到自己的生活目标。\n　　死后浮在天界与下界夹缝中的“我”的面前，出现了一名天使，他对“我”说，“犯下大过而死去的罪孽的灵魂，现在再给你一次机会回到下界，希望你能够明白你犯下的罪孽。”之后“我”进入了因为自杀刚刚死去的中学三年级生“小林真”的身体里，作为“小林真”活了过来……","date":"2010-08-21","objectID":"/anime/colorful/","tags":null,"title":"意外的幸运签","uri":"/anime/colorful/"},{"categories":null,"content":"简介 一个前世作恶多端、永世不得投胎的灵魂，却因天使的抽签活动，获得复活的机会。他借用了一位14岁的少年身体，展开一段奇妙的寄身生活。在守护天使的帮助下，他在生活中感受到酸甜苦辣，从开始的不甘情愿到体会活著的美妙。逐渐地他与家人、同学产生感情，并找到自己的生活目标。 死后浮在天界与下界夹缝中的“我”的面前，出现了一名天使，他对“我”说，“犯下大过而死去的罪孽的灵魂，现在再给你一次机会回到下界，希望你能够明白你犯下的罪孽。”之后“我”进入了因为自杀刚刚死去的中学三年级生“小林真”的身体里，作为“小林真”活了过来…… 制作人员： 原作：森绘都 导演：原惠一 脚本：丸尾未步 音乐：大谷幸 人物设定：","date":"2010-08-21","objectID":"/anime/colorful/:1:0","tags":null,"title":"意外的幸运签","uri":"/anime/colorful/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小林真 Kobayashi Makoto、こばやし まこと 男 冨澤風斗 2 佐野唱子 Shōko Sano、さの しょうこ、Sano Shouko 女 宮﨑あおい 3 桑原祐华 Kuwabara Hiroka、くわばら ひろか 女 南明奈 4 普拉普拉 Purapura 男 まいける 5 早乙女 Saotome、さおとめ 男 入江甚儀 ","date":"2010-08-21","objectID":"/anime/colorful/:2:0","tags":null,"title":"意外的幸运签","uri":"/anime/colorful/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 意外的幸运签 2010-08-21 1 樱花 ","date":"2010-08-21","objectID":"/anime/colorful/:3:0","tags":null,"title":"意外的幸运签","uri":"/anime/colorful/"},{"categories":null,"content":"初代作品《古剑奇谭：琴心剑魄今何在》于2010年7月10日发售，为中国首部全程配音的单机游戏，2014年被改编为同名电视剧。\n二代作品《古剑奇谭二：永夜初晗凝碧天》于2013年8月18日在两岸三地同步发售，该作放弃了回合制战斗方式而尝试即时制战斗，\n剧情方面则采用了电影化的表现手法。三代作品《古剑奇谭三：梦付千秋星垂野》于2018年11于23日上市，采用全即时制战斗。","date":"2010-07-10","objectID":"/game/gu_jian/","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"简介 初代作品《古剑奇谭：琴心剑魄今何在》于2010年7月10日发售，为中国首部全程配音的单机游戏，2014年被改编为同名电视剧。 二代作品《古剑奇谭二：永夜初晗凝碧天》于2013年8月18日在两岸三地同步发售，该作放弃了回合制战斗方式而尝试即时制战斗， 剧情方面则采用了电影化的表现手法。 三代作品《古剑奇谭三：梦付千秋星垂野》于2018年11于23日上市，采用全即时制战斗。 制作人员： 开发：上海烛龙信息科技有限公司 发行：北京网元圣唐娱乐科技有限公司 遊戲設計師：邵芸 剧本：张毅君 音乐：骆集益、周志华 人物设定：寸身言 ","date":"2010-07-10","objectID":"/game/gu_jian/:1:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 百里屠苏 韩云溪、苏苏 男 陈家恒 2 风晴雪 女 朱雀橙 3 襄铃 女 阎萌萌 4 尹千觞 风广陌 男 陆揆 5 欧阳少恭 男 彭尧 6 方兰生 男 7 红玉 女 8 陵越 大师兄 男 边江 ","date":"2010-07-10","objectID":"/game/gu_jian/:2:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"系列 系列名 发行时间 1 古剑奇谭 琴心剑魄今何在 2010-07-10 2 古剑奇谭二 永夜初晗凝碧天 2013-08-18 3 古剑奇谭三 梦付千秋星垂野 2018-11-23 ","date":"2010-07-10","objectID":"/game/gu_jian/:3:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"配乐 ","date":"2010-07-10","objectID":"/game/gu_jian/:4:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"MAD ","date":"2010-07-10","objectID":"/game/gu_jian/:5:0","tags":null,"title":"古剑系列","uri":"/game/gu_jian/"},{"categories":null,"content":"故事的舞台——私立樱才学园，原本是传统的女子高中，但因少子化问题影响，不得不改制为男女合校。作为改制后第一年入学的28名男性新生之一的津田隆利，偶然之下被拉入了学校的学生会。在外人看来，学生会是美女如云的天堂，但是津田身边的三位学生会女干部性格都非常独特，津田开始了他每天学生会的吐槽生活……","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"简介 故事的舞台——私立樱才学园，原本是传统的女子高中，但因少子化问题影响，不得不改制为男女合校。作为改制后第一年入学的28名男性新生之一的津田隆利，偶然之下被拉入了学校的学生会。在外人看来，学生会是美女如云的天堂，但是津田身边的三位学生会女干部性格都非常独特，津田开始了他每天学生会的吐槽生活…… 制作人员： 原作：氏家ト全 导演：金泽洪充 脚本：小山知子、中村诚 分镜：博史池畠、安川胜 演出：渡边哲哉 ","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/:1:0","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 津田隆利 つだ たかとし、Tsuda Takatoshi、烧棍、当代柳下惠 男 小林ゆう 2 天草筱 あまくさ しの、Amakusa Shino 女 日笠陽子 3 七条天空 しちじょう ありあ、Shichijou Aria、七条真空 女 佐藤聡美 4 萩村铃 はぎむら すず、Hagimura Suzu 女 矢作紗友里 5 津田琴美 つだ ことみ、Tsuda kotomi 女 下田麻美 6 五十岚枫 いがらし かえで、Igarashi Kaede 女 加藤英美里 7 道下老师 みちした 女 大山早稀 8 海辺ナナコ Umibe Nanako 女 安済知佳 ","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/:2:0","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 妄想学生会 2010-07-03 21 樱花 2 妄想学生会＊ 2014-01-04 23 樱花 3 剧场版 妄想学生会 2017-07-21 2 樱花 4 剧场版 妄想学生会2 2021-01-01 1 樱花 ","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/:3:0","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"MAD ","date":"2010-07-03","objectID":"/anime/seitokai_yakuindomo/:4:0","tags":null,"title":"妄想学生会","uri":"/anime/seitokai_yakuindomo/"},{"categories":null,"content":"橘纯一是一个高中二年级生，由于过去的经历变得不擅长应对恋爱和圣诞节这类事情，一直过着没女朋友的寂寞的校园生活。这样的纯一某一天突然想到：“直到高中毕业就这样什么都不做真的好吗？”于是，他克服自己的缺点，抱着今年的圣诞节要和女孩子过的想法，与不同的女孩子邂逅。纯一将会迎来一个怎么样的圣诞节……","date":"2010-07-01","objectID":"/anime/amagami/","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"简介 橘纯一是一个高中二年级生，由于过去的经历变得不擅长应对恋爱和圣诞节这类事情，一直过着没女朋友的寂寞的校园生活。这样的纯一某一天突然想到：“直到高中毕业就这样什么都不做真的好吗？”于是，他克服自己的缺点，抱着今年的圣诞节要和女孩子过的想法，与不同的女孩子邂逅。纯一将会迎来一个怎么样的圣诞节…… 制作人员： 原作：enterbrain 导演：平池芳正 脚本：待田堂子、木村畅 分镜：筱原俊哉、畑博之、金崎贵臣、木村真一郎 ","date":"2010-07-01","objectID":"/anime/amagami/:1:0","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 橘纯一 Junichi Tachibana、橘 純一、たちばな じゅんいち、Tachibana Junichi 男 斎藤桃子 2 森岛遥 森島・ラブリー・はるか、森島・L・はるか、森岛·L·遥、Haruka Lovely Morishima、森島 はるか、もりしま はるか、Morishima Haruka、学姐 女 伊藤静 3 棚町薰 Kaoru Tanamachi、棚町 薫、たなまち かおる、Tanamachi Kaoru 女 佐藤利奈 4 中多纱江 Sae Nakata、中多 紗江、なかた さえ、Nakata Sae 女 今野宏美 5 七咲逢 Ai Na","date":"2010-07-01","objectID":"/anime/amagami/:2:0","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 圣诞之吻SS 2010-07-01 26 bilibili 2 圣诞之吻SS+ plus 2012-01-05 13 bilibili ","date":"2010-07-01","objectID":"/anime/amagami/:3:0","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"MAD ","date":"2010-07-01","objectID":"/anime/amagami/:4:0","tags":null,"title":"圣诞之吻SS","uri":"/anime/amagami/"},{"categories":null,"content":"身为大三学生的“我”，梦想着多采多姿的校园生活却过了两年毫无意义的生活。虽然入学时在众多社团中选择了网球社，但是因为无法与人对话而失去容身之处。这时，他遇上有同样际遇的小津，两人组成了在社团内外四处妨碍人恋爱、恶名昭彰的“黑色丘比特”。没有遇到小津的话肯定能与黑发少女过着缤纷的人生！如果那时候选了其他社团……","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"简介 身为大三学生的“我”，梦想着多采多姿的校园生活却过了两年毫无意义的生活。虽然入学时在众多社团中选择了网球社，但是因为无法与人对话而失去容身之处。这时，他遇上有同样际遇的小津，两人组成了在社团内外四处妨碍人恋爱、恶名昭彰的“黑色丘比特”。没有遇到小津的话肯定能与黑发少女过着缤纷的人生！如果那时候选了其他社团…… 制作人员： 原作：森见登美彦 导演：汤浅政明 脚本：上田诚 分镜：牧原亮太郎、清水洋、三原三千夫、崔恩映 ","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/:1:0","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 我 男 浅沼晋太郎 2 小津 おづ 男 吉野裕行 3 明石 あかしさん 女 坂本真綾 4 樋口清太郎 樋口 清太郎、樋口師匠 男 藤原啓治 5 羽贯凉子 羽貫さん、羽貫 涼子 女 甲斐田裕子 6 城崎先辈 城崎学长、城崎 男 諏訪部順一 7 相岛 相岛学长 男 佐藤せつじ 8 香织 女 能登麻美子 ","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/:2:0","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 四叠半神话大系 2010-04-22 11 bilibili ","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/:3:0","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"MAD ","date":"2010-04-22","objectID":"/anime/the_tatami_galaxy/:4:0","tags":null,"title":"四叠半神话大系","uri":"/anime/the_tatami_galaxy/"},{"categories":null,"content":"在史克威尔艾尼克斯的漫画杂志YOUNG GANGAN2005年1号开始连载的四格漫画。以北海道某处被常客评论为“危险的感觉令人上瘾”的餐厅“瓦古娜利亚”为舞台，充满各种奇人异事的四格漫画。登场角色彼此间吐槽相当轻快。\n\n平时以六页为一个单位连载，有时一次刊登两话。有时也有不是四格漫画的短篇故事。四格漫画和后来的故事有巧妙的连结，节奏掌握良好。每回的第一页有一半的部分相当于扉页，刊登时为角色的独白或对话，但没有收录进漫画单行本中。\n\n原本是作者在自己的网站上不定期连载的网络四格漫画《WORKING!!》，为了杂志连载，将加入新的舞台设定与登场人物而成为本作。舞台是在和网络漫画不同的餐厅“瓦古娜利亚”，但具有共通的世界观。里面有店长的旧识与佐藤的乐团伙伴等，设定相联的角色存在。以下将网络连载的部分称为猫组，杂志连载称为犬组。登场人物也有一部分以打广告的名义在网站上登场，杂志连载人物还有在网站上出场次数比较多的角色。但因为权利的关系，猫组的人物并未在犬组登场。\n\n2006月30日开始也有手机发送的番外篇。2007年1月25日发售广播剧CD。2010年4月预定开始播放TV版动画。","date":"2010-04-04","objectID":"/anime/working/","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"简介 在史克威尔艾尼克斯的漫画杂志YOUNG GANGAN2005年1号开始连载的四格漫画。以北海道某处被常客评论为“危险的感觉令人上瘾”的餐厅“瓦古娜利亚”为舞台，充满各种奇人异事的四格漫画。登场角色彼此间吐槽相当轻快。 平时以六页为一个单位连载，有时一次刊登两话。有时也有不是四格漫画的短篇故事。四格漫画和后来的故事有巧妙的连结，节奏掌握良好。每回的第一页有一半的部分相当于扉页，刊登时为角色的独白或对话，但没有收录进漫画单行本中。 原本是作者在自己的网站上不定期连载的网络四格漫画《WORKING!!》，为了杂志连载，将加入新的舞台设定与登场人物而成为本作。舞台是在和网络漫画不同的餐厅“瓦古娜","date":"2010-04-04","objectID":"/anime/working/:1:0","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小鸟游宗太 たかなし そうた、Takanashi Souta 男 福山潤 2 佐藤润 さとうじゅん、Sato Jun 男 小野大輔 3 相马博臣 そうま ひろおみ、Soma Hiroomi 男 神谷浩史 4 种岛白杨 たねしま ぽぷら、Taneshima Popura 女 阿澄佳奈 5 伊波真昼 いなみ まひる、Inami Mahiru 女 藤田咲 6 轰八千代 Todorok Yachiyo 女 喜多村英梨 7 白藤杏子 白藤 杏子、しらふじ きょうこ、Shirafuji Kyouko 女 渡辺久美子 8 山田葵 やまだ あおい、Yamada Aoi 女 ","date":"2010-04-04","objectID":"/anime/working/:2:0","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 迷糊餐厅 2010-04-04 13 bilibili 2 迷糊餐厅 第二季 2011-10-01 13 bilibili 3 迷糊餐厅 第三季 2015-07-04 13 bilibili 4 WWW. 迷糊餐厅 2016-10-01 13 bilibili ","date":"2010-04-04","objectID":"/anime/working/:3:0","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"MAD ","date":"2010-04-04","objectID":"/anime/working/:4:0","tags":null,"title":"迷糊餐厅","uri":"/anime/working/"},{"categories":null,"content":"　　故事从男主角死亡之后从“死后的世界”醒来开始，在“死后的世界”中的学校里，他与一位名为由利(ゆり)、在“死后的世界”率领着一个名为“死んだ(Shinda)世界(Sekai)战线(Sensen)”简称“SSS”的组织的少女相遇了。“SSS”成立的主要目的是与赐予他们生前悲哀命运的神以及神之使者——天使交战，在天使超乎常理的异能面前，“SSS”只能用枪来反抗。就这样一场发生在“死后的世界”的学校里的超能大战物语开始了……\n\n","date":"2010-04-02","objectID":"/anime/angel_beats/","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"简介 故事从男主角死亡之后从“死后的世界”醒来开始，在“死后的世界”中的学校里，他与一位名为由利(ゆり)、在“死后的世界”率领着一个名为“死んだ(Shinda)世界(Sekai)战线(Sensen)”简称“SSS”的组织的少女相遇了。“SSS”成立的主要目的是与赐予他们生前悲哀命运的神以及神之使者——天使交战，在天使超乎常理的异能面前，“SSS”只能用枪来反抗。就这样一场发生在“死后的世界”的学校里的超能大战物语开始了…… 制作人员： 原作：Visual Art’s、Key、麻枝准 导演：岸诚二 分镜：平井义通、青木英、政木伸一 ","date":"2010-04-02","objectID":"/anime/angel_beats/:1:0","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 仲村由理 仲村百合、仲村 ゆり、なかむら ゆり、Nakamura Yuri、游离子、小百合、伪团长 女 櫻井浩美 2 音无结弦 音無 結弦、おとなし ゆづる、Otonashi Yuzuru 男 神谷浩史 3 立华奏 立花奏、橘奏、立華 かなで、たちばな かなで、Tachibana Kanade、天使 女 花澤香菜 4 日向秀树 ひなた ひでき、Hinada Hideki 男 木村良平 5 查 Chaa 男 東地宏樹 6 由依 结衣、唯、ユイ、Yui、由依喵、由依酱 女 喜多村英梨 7 岩泽雅美 岩泽正美、岩泽麻美（误译）、岩沢 雅美、いわさわ まさみ、Iwa","date":"2010-04-02","objectID":"/anime/angel_beats/:2:0","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天使的心跳！ 2010-04-02 13 bilibili ","date":"2010-04-02","objectID":"/anime/angel_beats/:3:0","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"MAD ","date":"2010-04-02","objectID":"/anime/angel_beats/:4:0","tags":null,"title":"天使的心跳！","uri":"/anime/angel_beats/"},{"categories":null,"content":"中学二年级的花咲蕾，在搬家的卡车上梦见心之大树被沙漠使徒袭击、Cure Moonlight被击败的场面。从镰仓移居到祖母所在的希望之花市、转入私立明堂学园的蕾希望借着搬家的机会改变内向的自己，却总被我行我素而爱管闲事的同学——来海绘理香牵着鼻子走。在面对新环境而不知所措的蕾面前，曾在梦中看到过的心之大树的妖精，Chypre和Coffret出现了。与此同时沙漠使徒中的一人，蝎子丽娜追赶他们而来，并夺走了绘理香的心之花。为了拯救她，蕾决定变身为Pretty Cure。","date":"2010-02-07","objectID":"/anime/heart_catch_precure/","tags":null,"title":"Heart Catch 光之美少女!","uri":"/anime/heart_catch_precure/"},{"categories":null,"content":"简介 中学二年级的花咲蕾，在搬家的卡车上梦见心之大树被沙漠使徒袭击、Cure Moonlight被击败的场面。从镰仓移居到祖母所在的希望之花市、转入私立明堂学园的蕾希望借着搬家的机会改变内向的自己，却总被我行我素而爱管闲事的同学——来海绘理香牵着鼻子走。在面对新环境而不知所措的蕾面前，曾在梦中看到过的心之大树的妖精，Chypre和Coffret出现了。与此同时沙漠使徒中的一人，蝎子丽娜追赶他们而来，并夺走了绘理香的心之花。为了拯救她，蕾决定变身为Pretty Cure。 制作人员： 原作：东堂泉 导演：长峰达也 脚本：井上美绪、米村正二、成田良美、伊藤睦美、山田隆司 演出：地冈公俊、志水淳儿 ","date":"2010-02-07","objectID":"/anime/heart_catch_precure/:1:0","tags":null,"title":"Heart Catch 光之美少女!","uri":"/anime/heart_catch_precure/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 花咲蕾／花蕾天使 Cure Blossom、花咲 つぼみ、はなさき つぼみ、Hanasaki Tsubomi 女 水樹奈々 2 来海绘里香／海洋天使 Cure Marine、くるみ えりか、Kurumi Erika、马琳 女 水沢史絵 3 明堂院树／阳光天使 Cure Sunshine、明堂院 いつき、みょうどういん いつき、Myōdōin Itsuki 女 桑島法子 4 月影百合／月光天使 Cure Moonlight、月影 ゆり、つきかげ ゆり、Tsukikage Yuri 女 久川綾 5 花咲薰子 花咲 薫子、はなさき かおるこ、Hanasaki Ka","date":"2010-02-07","objectID":"/anime/heart_catch_precure/:2:0","tags":null,"title":"Heart Catch 光之美少女!","uri":"/anime/heart_catch_precure/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Heart Catch 光之美少女! 2010-02-07 49 爱奇艺 ","date":"2010-02-07","objectID":"/anime/heart_catch_precure/:3:0","tags":null,"title":"Heart Catch 光之美少女!","uri":"/anime/heart_catch_precure/"},{"categories":null,"content":"在地图上没有记载的无人岛・不承岛，岛上生活着不使用刀的剑术・虚刀流第七代当家鑢七花与其姐姐鑢七实。\n幼年时随父亲漂流到此岛上，生活至今已经20年了。\n在父亲去世后，本以为在这个世上已经没有人记得他们了。某日，一位自称咎的奇策士突然来到岛上拜访。\n她是为了收集传说中的锻刀师・四季崎记纪终其一生冶炼的十二套变刀体，而来求助于虚刀流的当家七花。\n但是，在他们的交谈中突然遭到了袭击！袭击者是真庭忍军十二头领中的真庭蝙蝠。七花愤怒地追着蝙蝠而去……。\n在世外桃源之地长大、对外界一无所知的剑士鑢七花的旅途开始了。在前方等待他的究竟会是地狱般的决战抑或是命悬一线的……恋爱泥潭！？","date":"2010-01-25","objectID":"/anime/katanagatari/","tags":null,"title":"刀语","uri":"/anime/katanagatari/"},{"categories":null,"content":"简介 在地图上没有记载的无人岛・不承岛，岛上生活着不使用刀的剑术・虚刀流第七代当家鑢七花与其姐姐鑢七实。 幼年时随父亲漂流到此岛上，生活至今已经20年了。 在父亲去世后，本以为在这个世上已经没有人记得他们了。某日，一位自称咎的奇策士突然来到岛上拜访。 她是为了收集传说中的锻刀师・四季崎记纪终其一生冶炼的十二套变刀体，而来求助于虚刀流的当家七花。 但是，在他们的交谈中突然遭到了袭击！袭击者是真庭忍军十二头领中的真庭蝙蝠。七花愤怒地追着蝙蝠而去……。 在世外桃源之地长大、对外界一无所知的剑士鑢七花的旅途开始了。在前方等待他的究竟会是地狱般的决战抑或是命悬一线的……恋爱泥潭！？ 制作人员： 原作：西","date":"2010-01-25","objectID":"/anime/katanagatari/:1:0","tags":null,"title":"刀语","uri":"/anime/katanagatari/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鑢七花 鑢七花、やすり しちか、Yasuri Shichika 男 くまいもとこ 2 咎儿 咎、容赦姬、容赦姫、ようしゃひめ、Togame、奇策士 女 田村ゆかり 3 鑢七实 鑢七実、やすり ななみ、Yasuri Nanami 女 中原麻衣 4 锖白兵 錆 白兵、さび はくへい、Sabi hakuhei 男 緑川光 5 宇练银阁 宇練 銀閣、うねり ぎんかく、Uneri ginkaku 男 宮本充 6 否定姬 ひていひめ、Hiteihime 女 戸松遥 7 左右田右卫门左卫门 左右田右衛門左衛門、そうだ えもんざえもん、Souda emonzaemon 男 ","date":"2010-01-25","objectID":"/anime/katanagatari/:2:0","tags":null,"title":"刀语","uri":"/anime/katanagatari/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 刀语 2010-01-25 12 bilibili MAD ","date":"2010-01-25","objectID":"/anime/katanagatari/:3:0","tags":null,"title":"刀语","uri":"/anime/katanagatari/"},{"categories":null,"content":"被美丽的自然所包围的小镇，空美町。住在那里的樱井智树是一名将“和平第一”作为标语的普通学生。不过，自从某日从天空中掉下一位名为伊卡洛斯的女孩，他平静的日常生活开始脱轨了。自称“娱乐用万能天使”的她，将降落后见到的第一位人类，也就是智树称呼为“主人”，并有着能实现他一切愿望的不可思议的能力。入手一千亿现金，成为透明人，让时间停止，总之什么都可以！满足了一个健全男子的全部欲望的智树，最后的愿望是！？","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"简介 被美丽的自然所包围的小镇，空美町。住在那里的樱井智树是一名将“和平第一”作为标语的普通学生。不过，自从某日从天空中掉下一位名为伊卡洛斯的女孩，他平静的日常生活开始脱轨了。自称“娱乐用万能天使”的她，将降落后见到的第一位人类，也就是智树称呼为“主人”，并有着能实现他一切愿望的不可思议的能力。入手一千亿现金，成为透明人，让时间停止，总之什么都可以！满足了一个健全男子的全部欲望的智树，最后的愿望是！？ 制作人员： 原作：水无月嵩 导演：斋藤久 脚本：柿原优子 分镜：柳泽哲也、东海林真一、中村宪由、五十岚达也、古川顺康 ","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/:1:0","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 樱井智树 智神、桜井智樹、さくらい ともき、Sakurai tomoki、小智 男 保志総一朗 2 伊卡洛斯 Ikaros、イカロス、螺丝 女 早見沙織 3 妮姆芙 恁胡、Nymph、ニンフ 女 野水伊織 4 见月楚原 みつき そはら 女 美名 5 守形英四郎 守形英四郎、すがた えいしろう、Sugata Eishirou 男 鈴木達央 6 五月田根美香子 さつきたね みかこ、会长 女 高垣彩陽 7 圣光君 圣光、Holy Light 8 卡奥斯 Chaos、カオス 女 豊崎愛生 ","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/:2:0","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天降之物 2009-10-04 14 樱花 2 天降之物f 2010-10-01 12 樱花 3 天降之物 计时的悲伤女神 2011-06-25 1 樱花 4 天降之物Final 永远的我的鸟笼 2014-04-26 1 bilibili ","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/:3:0","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"MAD ","date":"2009-10-04","objectID":"/anime/sora_no_otoshimono/:4:0","tags":null,"title":"天降之物","uri":"/anime/sora_no_otoshimono/"},{"categories":null,"content":"故事发生在面积占据东京都的三分之一，居住着230万名人口且其中八成人口是学生的巨大都市“学园都市”。学园都市的所有学生均会接受超能力开发，借由药物、催眠术与通电刺激等方式取得超能力。能力者以范围和威力分为LV0至LV5。\n\n主角御坂美琴是学园都市中仅七位LV5（超能力者）的其中一人，排行第三。她是拥有操纵电击能力的“电击使”，站在电击能力的顶峰，因而被称为“超电磁炮”。\n\n本作不但通过美琴的视角来描绘学园都市的平常而不平凡的日常生活，也叙述了学园都市秘密进行非人道性质的实验，从而使大家对于本作及本篇《魔法禁书目录》的背景（世界观）的认识也慢慢变得清楚。","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"简介 故事发生在面积占据东京都的三分之一，居住着230万名人口且其中八成人口是学生的巨大都市“学园都市”。学园都市的所有学生均会接受超能力开发，借由药物、催眠术与通电刺激等方式取得超能力。能力者以范围和威力分为LV0至LV5。 主角御坂美琴是学园都市中仅七位LV5（超能力者）的其中一人，排行第三。她是拥有操纵电击能力的“电击使”，站在电击能力的顶峰，因而被称为“超电磁炮”。 本作不但通过美琴的视角来描绘学园都市的平常而不平凡的日常生活，也叙述了学园都市秘密进行非人道性质的实验，从而使大家对于本作及本篇《魔法禁书目录》的背景（世界观）的认识也慢慢变得清楚。 制作人员： 原作：镰池和马、冬川基 导","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/:1:0","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 御坂美琴 Mikoto Misaka、御坂美琴、みさかみこと、Misaka Mikoto、炮姐 / ビリビリ/Bilibili、超电磁炮/レールガン/Railgun 女 佐藤利奈 2 白井黑子 Teleport、白井 黒子、しらい くろこ、Shirai Kuroko、空间移动 女 新井里美 3 初春饰利 初春飾利、ういはる かざり、Uiharu Kazari 女 豊崎愛生 4 佐天泪子 佐天 涙子、さてん るいこ、Saten Ruiko 女 伊藤かな恵 5 上条当麻 上条当麻、かみじょとうま、Kamijou Touma、小上条，上条，当麻，大妈 男 阿部敦 ","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/:2:0","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 某科学的超电磁炮 2009-10-02 24 bilibili 2 某科学的超电磁炮 OVA 2010-10-29 1 bilibili 3 某科学的超电磁炮S 2013-04-12 24 bilibili 4 某科学的超电磁炮S OVA 2014-03-27 1 bilibili 5 某科学的超电磁炮T 2020-01-10 25 bilibili ","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/:3:0","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"MAD ","date":"2009-10-02","objectID":"/anime/toaru_kagaku_no_railgun/:4:0","tags":null,"title":"某科学的超电磁炮","uri":"/anime/toaru_kagaku_no_railgun/"},{"categories":null,"content":"《eden*》是由日本游戏公司minori于2009年所推出的一款恋爱冒险游戏。\n该作品是一款以恋爱为题材，架设在虚幻未来为背景下的交互式小说。eden*是minori的第6部作品，\n也是在继取得成功的《ef -a fairy tale of the two》（悠久之翼）之后的作品。","date":"2009-09-18","objectID":"/game/eden/","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"简介 《eden*》是由日本游戏公司minori于2009年所推出的一款恋爱冒险游戏。 该作品是一款以恋爱为题材，架设在虚幻未来为背景下的交互式小说。eden*是minori的第6部作品， 也是在继取得成功的《ef -a fairy tale of the two》（悠久之翼）之后的作品。 制作人员： 开发：minori 剧本：镜游 美工：结城辰也 音乐：柳英一郎、天门 主题歌作词：酒井伸和 主题歌演出：原田瞳 原画：ちこたむ ","date":"2009-09-18","objectID":"/game/eden/:1:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 榛名亮 はるな りょう 男 間島淳司 2 诗音 紫苑、Sion 女 志村由美 3 艾莉卡 Erica 女 中島裕美子 4 稻叶直人 いなば なおと 男 遠近孝一 5 浅井·F·拉维尼娅 あさい・えふ・らう゛ぃにあ、Asai･F･Lavinia 女 中村繪里子 6 塔野真夜 とうの まや 後藤麻衣 7 夏目 枣 岡田純子 ","date":"2009-09-18","objectID":"/game/eden/:2:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"系列 系列名 发行时间 1 伊甸园 2009-09-18 ","date":"2009-09-18","objectID":"/game/eden/:3:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"配乐 ","date":"2009-09-18","objectID":"/game/eden/:4:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"MAD ","date":"2009-09-18","objectID":"/game/eden/:5:0","tags":null,"title":"eden*","uri":"/game/eden/"},{"categories":null,"content":"所谓怪异——是因为世界上没有那种东西的存在。\n与生物有所不同——但与世界紧紧相连。\n故事主人公阿良良木历，因为知道了同班同学战场原的某个“秘密”，从此被卷入一连串的怪异事件中……。","date":"2009-07-03","objectID":"/anime/bakemonogatari/","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"简介 所谓怪异——是因为世界上没有那种东西的存在。 与生物有所不同——但与世界紧紧相连。 故事主人公阿良良木历，因为知道了同班同学战场原的某个“秘密”，从此被卷入一连串的怪异事件中……。 制作人员： 原作：西尾维新 导演：新房昭之 脚本：中本宗应、木泽行人 分镜：福田道生、铃木利正、杉山延宽、尾石达也 ","date":"2009-07-03","objectID":"/anime/bakemonogatari/:1:0","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿良良木历 あららぎ　こよみ、Araragi Koyomi、こよこよ、こよみん 男 神谷浩史 2 战场原黑仪 战场原绯多木、ツンデレちゃん、战场原荡漾、雅原小姐、がはらさん、战场原直木、せんじょうがはら ひたぎ、Senjougahara Hitagi 女 斎藤千和 3 八九寺真宵 はちくじ まよい、Hachikuji Mayoi 女 加藤英美里 4 神原骏河 かんばる するが、Kanbaru Suruga、臥煙駿河 女 沢城みゆき 5 千石抚子 千石 撫子、せんごく なでこ、Sengoku Nadeko 女 花澤香菜 6 羽川翼 羽川 翼、はねかわ つばさ、","date":"2009-07-03","objectID":"/anime/bakemonogatari/:2:0","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 化物语 2009-07-03 15 acfun 2 伪物语 2012-01-07 11 acfun 3 猫物语（黑） 2012-12-31 4 acfun 4 物语系列 第二季 2013-07-06 26 acfun 5 花物语 2014-08-16 5 acfun 6 凭物语 2014-12-31 4 acfun 7 终物语 2015-10-03 13 bilibili 8 历物语 2016-01-09 12 bilibili 9 终物语（下） 2017-08-12 7 bilibili 10 续·终物语 2018-11-10 6 bilib","date":"2009-07-03","objectID":"/anime/bakemonogatari/:3:0","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"MAD ","date":"2009-07-03","objectID":"/anime/bakemonogatari/:4:0","tags":null,"title":"化物语","uri":"/anime/bakemonogatari/"},{"categories":null,"content":"天才麻将少女宫永咲虽然还是一位刚升入高中一年级的学生，但是便能以正负0分的方式打完牌局从而创下赫赫威名。故事二号女主角原村和则是在全国中学生麻将大赛个人组中夺得冠军的少女，两人因缘而聚到了麻将部，并以高中校际比赛的顶点为目标展开一番自摸放炮的故事。","date":"2009-04-05","objectID":"/anime/saki/","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"简介 天才麻将少女宫永咲虽然还是一位刚升入高中一年级的学生，但是便能以正负0分的方式打完牌局从而创下赫赫威名。故事二号女主角原村和则是在全国中学生麻将大赛个人组中夺得冠军的少女，两人因缘而聚到了麻将部，并以高中校际比赛的顶点为目标展开一番自摸放炮的故事。 制作人员： 原作：小林立 导演：小野学 脚本：浦畑达彦 分镜：木村宽、濑藤健嗣、山本珠代、小泷礼、熊泽佑嗣 ","date":"2009-04-05","objectID":"/anime/saki/:1:0","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫永咲 宮永咲、みやなが さき、Miyanaga Saki、魔王，大魔王，清澄的岭上开花使者 女 植田佳奈 2 原村和 原村和、はらむら のどか、Haramura Nodoka、小和和，乳和，奶和，奶奶香 女 小清水亜美 3 片冈优希 Taco、かたおか ゆうき、Kataoka Yuuki、卷饼 女 釘宮理恵 4 竹井久 竹井久 / 上埜久、たけい ひさ / うえの ひさ、Takei Hisa / Ueno Hisa、久帝、渣久 女 伊藤静 5 染谷真子 そめや まこ、Someya Mako 女 白石涼子 6 须贺京太郎 須賀 京太郎、すが　きょうたろう、S","date":"2009-04-05","objectID":"/anime/saki/:2:0","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天才麻将少女 2009-04-05 25 樱花 2 天才麻将少女 阿知贺篇 2012-04-08 16 樱花 3 天才麻将少女 全国篇 2014-01-05 13 樱花 4 咲日和 OAD 2015-07-25 1 bilibili ","date":"2009-04-05","objectID":"/anime/saki/:3:0","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"MAD ","date":"2009-04-05","objectID":"/anime/saki/:4:0","tags":null,"title":"天才麻将少女","uri":"/anime/saki/"},{"categories":null,"content":"　　Leaf社於1998年發售的18X美少女PC用AVG「WHITE ALBUM」，就當時來說、該遊戲的情節性、音樂和人物刻畫可算是比較優秀的鎮社之作。其實這部作品提出要動畫化已經是多年前的事情了，而最近才終於被正式列入製作日程，預定於2009年1月開播。目前、其PS3移植版也在銳意製作中，TV版的故事將會與PS3版的不同，是一個只有TV版才能完美演繹出的故事。角色的基本定位和以演藝界為舞台的戀愛故事主題將不會改變，人氣聲優平野綾和水樹奈奈分別飾演兩位女主角森川由綺、緒方理奈。本次公開的是兩位女主角的人設。\n　　時間是1986年，被泡沫經濟侵襲的日本。出生在那個年代的青年籐井冬彌在度過平凡大學生活的同時與明星森川由綺交往著。工作與學習之餘，本以為已互相確定感情的兩人，因由綺的人氣上升，而使得距離越拉越遠。這樣一來，冬彌就和與由綺同屬一間演藝公司的當紅明星緒方理奈相遇了。這樣的相遇會給他帶來什麼樣的影響呢？","date":"2009-01-03","objectID":"/anime/white_album/","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"简介 Leaf社於1998年發售的18X美少女PC用AVG「WHITE ALBUM」，就當時來說、該遊戲的情節性、音樂和人物刻畫可算是比較優秀的鎮社之作。其實這部作品提出要動畫化已經是多年前的事情了，而最近才終於被正式列入製作日程，預定於2009年1月開播。目前、其PS3移植版也在銳意製作中，TV版的故事將會與PS3版的不同，是一個只有TV版才能完美演繹出的故事。角色的基本定位和以演藝界為舞台的戀愛故事主題將不會改變，人氣聲優平野綾和水樹奈奈分別飾演兩位女主角森川由綺、緒方理奈。本次公開的是兩位女主角的人設。 時間是1986年，被泡沫經濟侵襲的日本。出生在那個年代的青年籐井冬彌在度過平凡大學生","date":"2009-01-03","objectID":"/anime/white_album/:1:0","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤井冬弥 藤井 冬弥、ふじい とうや、Fujii Touya 男 木村はるか 2 森川由绮 森川由綺、もりかわ　ゆき、Morikawa Yuki 女 平野綾 3 绪方理奈 緒方 理奈、おがた りな、Ogata Rina 女 水樹奈々 4 泽仓美咲 澤倉 美咲、さわくら みさき、Sawakura Misaki 女 高本めぐみ 5 河岛遥 河島 はるか、かわしま はるか、Kawashima Haruka 女 升望 6 观月真名 観月 マナ、みづき マナ、Mizuki Mana 女 戸松遥 7 筱冢弥生 篠塚 弥生、しのづか やよい、Shinozuka Yayoi","date":"2009-01-03","objectID":"/anime/white_album/:2:0","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 白色相簿 2009-01-03 13 bilibili 2 白色相簿 下半编章 2009-10-02 13 bilibili ","date":"2009-01-03","objectID":"/anime/white_album/:3:0","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"MAD ","date":"2009-01-03","objectID":"/anime/white_album/:4:0","tags":null,"title":"白色相簿","uri":"/anime/white_album/"},{"categories":null,"content":"幻想乡\n那是隔了一层结界悄然存于现代的内侧的另一个世界\n那里是能够让人类与非人的妖精 妖怪 神明等和平共处的理想乡\n居住着守护结界的巫女博丽灵梦的神社——博丽神社\n每到夏天 那里会举办一场大宴会\n每逢宴会 神社就会因幻想乡的住民们的共聚一堂而热闹非凡\n今年的幻想乡也一如往常 迎来了夏天\n","date":"2008-12-30","objectID":"/anime/touhou_project/","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"简介 幻想乡 那是隔了一层结界悄然存于现代的内侧的另一个世界 那里是能够让人类与非人的妖精 妖怪 神明等和平共处的理想乡 居住着守护结界的巫女博丽灵梦的神社——博丽神社 每到夏天 那里会举办一场大宴会 每逢宴会 神社就会因幻想乡的住民们的共聚一堂而热闹非凡 今年的幻想乡也一如往常 迎来了夏天 制作人员： 原作：ZUN、上海爱丽丝幻乐团 导演：时音 ","date":"2008-12-30","objectID":"/anime/touhou_project/:1:0","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 博丽灵梦 博麗靈夢、はくれい れいむ、Hakurei Reimu、无节操，红白，露腋巫女，十万巫女，城管 女 中原麻衣 2 雾雨魔理沙 霧雨魔理沙、Kirisame Marisa、黑白、霧雨魔梨沙 女 沢城みゆき 3 射命丸文 しゃめいまる あや、Shameimaru Aya、文文 女 藤村歩 4 帕秋莉·诺蕾姬 知识与避世的少女、不动的大图书馆、不明的魔法之元、花昙的魔女、广藿香·知识、Patchouli Knowledge、香草、图书、帕琪、姆Q、一周少女 女 高橋美佳子 5 蕾米莉亚·斯卡蕾特 蕾米莉亚·斯卡雷特、红之恶魔、永远的红色幼月、红色的世界、","date":"2008-12-30","objectID":"/anime/touhou_project/:2:0","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 东方梦想夏乡 2008-12-30 00:20:30 bilibili 2 东方活动写真馆 2009-04-26 bilibili 3 东方PVD 2010-08-13 bilibili 4 幻想万华镜 春雪异变之章 2011-08-13 bilibili ","date":"2008-12-30","objectID":"/anime/touhou_project/:3:0","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"MAD ","date":"2008-12-30","objectID":"/anime/touhou_project/:4:0","tags":null,"title":"东方同人","uri":"/anime/touhou_project/"},{"categories":null,"content":"漫画版前传，讲述女主角土宫神乐与谏山黄泉相识之初的一段往事。\n土宫家是世世代代保护京都的家族，在一次与强大恶灵的战斗中，土宫家现任家主土宫雅乐的夫人因重伤不治去世。一心要继承夫人体内最强灵兽“白叡”的土宫雅乐，专心于法术的修炼与恶灵的退治，因此冷落了失去母亲后陷入悲伤中的女儿神乐。然而谏山家的养女谏山黄泉却以明朗的性格，逐渐感化了封闭内心的神乐，二人在朝夕相处中，姐妹之情日益加深。\n继承了谏山家祖传宝刀“狮子王”的黄泉，在她平时高中生身份之外，还身为环境省超自然灾害对策室的战斗主力，不断清除着各式各样的恶灵。怀着对黄泉的憧憬，以及对死去母亲的怀念，神乐也以实习生的身份加入了超自然灾害对策室，成为队伍里备受大家关爱的小妹妹。\n充满残酷战斗但也始终洋溢着温情的日子在一天天的延续，然而随着黄泉的姐姐谏山冥的登场，残酷的命运渐渐将二人卷入其中，走向注定的悲剧……","date":"2008-10-05","objectID":"/anime/ga_rei_zero/","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"简介 漫画版前传，讲述女主角土宫神乐与谏山黄泉相识之初的一段往事。 土宫家是世世代代保护京都的家族，在一次与强大恶灵的战斗中，土宫家现任家主土宫雅乐的夫人因重伤不治去世。一心要继承夫人体内最强灵兽“白叡”的土宫雅乐，专心于法术的修炼与恶灵的退治，因此冷落了失去母亲后陷入悲伤中的女儿神乐。然而谏山家的养女谏山黄泉却以明朗的性格，逐渐感化了封闭内心的神乐，二人在朝夕相处中，姐妹之情日益加深。 继承了谏山家祖传宝刀“狮子王”的黄泉，在她平时高中生身份之外，还身为环境省超自然灾害对策室的战斗主力，不断清除着各式各样的恶灵。怀着对黄泉的憧憬，以及对死去母亲的怀念，神乐也以实习生的身份加入了超自然灾害对策","date":"2008-10-05","objectID":"/anime/ga_rei_zero/:1:0","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 谏山黄泉 諫山 黄泉、いさやま よみ、Isayama Yomi、黄泉姐姐 女 水原薫 2 土宫神乐 土宮 神楽、つちみや かぐら、Tsuchimiya Kagura 女 茅原実里 3 饭纲纪之 飯綱 紀之、いづな のりゆき、Izuna Noriyuki 男 高橋伸也 4 樱庭一骑 桜庭 一騎、さくらば かずき、Sakuraba Kazuki 男 白石稔 5 岩端晃司 岩端 晃司、いわはた こうじ、Iwahata Kouji 男 稲田徹 6 纳布兄弟 なぶー きょうだい、Nabu Kyoudai 男 若本規夫 7 神宫寺菖蒲 神宮寺菖蒲、じんぐうじ あやめ、J","date":"2008-10-05","objectID":"/anime/ga_rei_zero/:2:0","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 食灵-零- 2008-10-05 12 樱花 ","date":"2008-10-05","objectID":"/anime/ga_rei_zero/:3:0","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"MAD ","date":"2008-10-05","objectID":"/anime/ga_rei_zero/:4:0","tags":null,"title":"食灵-零-","uri":"/anime/ga_rei_zero/"},{"categories":null,"content":"自己的阳台栏杆上出现了像被单一样挂在上面的少女，这种非现实的情节出现在了上条当麻的眼前。虽然在这个城市——最先进科学引导的学院都市中，超能力已经可以通过科学技术创造出来，但是眼前这位自称“茵蒂克丝”的少女还是把上条当麻吓了一条。茵蒂克丝自称因拥有十万三千本魔导书而被魔法师追杀，而上条当麻靠自己的超能力也认定了少女的魔法。少女以危险为由离开上条家，上条如往日一般去学校学习，但放学回家，却发现茵蒂克丝倒在血泊之中。在科学与魔术交叉的世界中，上条当麻与茵蒂克丝的故事开始了。","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"简介 自己的阳台栏杆上出现了像被单一样挂在上面的少女，这种非现实的情节出现在了上条当麻的眼前。虽然在这个城市——最先进科学引导的学院都市中，超能力已经可以通过科学技术创造出来，但是眼前这位自称“茵蒂克丝”的少女还是把上条当麻吓了一条。茵蒂克丝自称因拥有十万三千本魔导书而被魔法师追杀，而上条当麻靠自己的超能力也认定了少女的魔法。少女以危险为由离开上条家，上条如往日一般去学校学习，但放学回家，却发现茵蒂克丝倒在血泊之中。在科学与魔术交叉的世界中，上条当麻与茵蒂克丝的故事开始了。 制作人员： 原作：镰池和马 导演：锦织博 脚本：赤星政尚、谷崎晃、水上清资、西园悟 分镜：中津环、大原实、杉岛邦久 ","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/:1:0","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 茵蒂克斯 小黄书、Index Librorum Prohibitorum、indekkusu、Dedicatus545（献身的な子羊は強者の知識を守る） 女 井口裕香 2 上条当麻 上条当麻、かみじょとうま、Kamijou Touma、小上条，上条，当麻，大妈 男 阿部敦 3 御坂美琴 Mikoto Misaka、御坂美琴、みさかみこと、Misaka Mikoto、炮姐 / ビリビリ/Bilibili、超电磁炮/レールガン/Railgun 女 佐藤利奈 4 一方通行 Accelerator、アクセラレータ、Accelerator、铃科百合子 不明 岡本信彦 ","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/:2:0","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔法禁书目录 2008-10-04 24 bilibili 2 魔法禁书目录 第二季 2010-10-08 24 bilibili 3 魔法禁书目录 恩底弥翁的奇迹 2013-02-23 1 bilibili 4 魔法禁书目录 第三季 2018-10-05 26 bilibili ","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/:3:0","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"MAD ","date":"2008-10-04","objectID":"/anime/to_aru_majutsu_no_index/:4:0","tags":null,"title":"魔法禁书目录","uri":"/anime/to_aru_majutsu_no_index/"},{"categories":null,"content":"恍如世界末日一般，洪水一层席卷地球，世界变成一片汪洋，空旷而孤寂。一位老人孤独地生活在这个世上，或凭栏远眺，或看看电视消磨时光，几无可以交流之人。水位不断上涨，老人只能不断加盖房子，宛如摞积木一般，房子有如矗立在深海中的巨塔。在搬运家具时，老人的烟斗不慎掉落水中，更顺着层与层之间的通道掉落下去。烟斗有着他和老伴共同的回忆，老人决心潜水取回烟斗，但是这一举动似乎打开了记忆的闸门，往日的回忆不断涌现。老人无法自已，一层层向下沉去，寻找那些早已沉在海底的珍贵记忆……\n本片荣获2009年奥斯卡金像奖最佳动画短片奖","date":"2008-06-10","objectID":"/anime/piece_of_love/","tags":null,"title":"回忆积木小屋","uri":"/anime/piece_of_love/"},{"categories":null,"content":"简介 恍如世界末日一般，洪水一层席卷地球，世界变成一片汪洋，空旷而孤寂。一位老人孤独地生活在这个世上，或凭栏远眺，或看看电视消磨时光，几无可以交流之人。水位不断上涨，老人只能不断加盖房子，宛如摞积木一般，房子有如矗立在深海中的巨塔。在搬运家具时，老人的烟斗不慎掉落水中，更顺着层与层之间的通道掉落下去。烟斗有着他和老伴共同的回忆，老人决心潜水取回烟斗，但是这一举动似乎打开了记忆的闸门，往日的回忆不断涌现。老人无法自已，一层层向下沉去，寻找那些早已沉在海底的珍贵记忆…… 本片荣获2009年奥斯卡金像奖最佳动画短片奖 制作人员： 导演：加藤久仁生 脚本：平田研也 音乐：近藤研二 制作：ROBOT ","date":"2008-06-10","objectID":"/anime/piece_of_love/:1:0","tags":null,"title":"回忆积木小屋","uri":"/anime/piece_of_love/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 回忆积木小屋 2008-06-10 1 bilibili ","date":"2008-06-10","objectID":"/anime/piece_of_love/:2:0","tags":null,"title":"回忆积木小屋","uri":"/anime/piece_of_love/"},{"categories":null,"content":"《G线上的魔王》，是由AKABEiSOFT2研发的恋爱冒险游戏第9作。本作原计划于2007年11月29日发行，但由于开发延迟，正式发行一再推迟，最终于2008年5月29日在日本本土发行，比原计划发布日期晚了半年。2015年11月6日，Sekai Project代理发行Steam英文版《G-senjou no Maou》。\n\n喜欢古典音乐的普通少年浅井京介，与同学美轮椿姬、相泽荣一、义妹浅井花音熟识。而在夜晚，则是养父浅井权三的公司中的重要人物。在冬天，少女宇佐美春转校来到京介的学校，她就是以前和京介一起的“勇者”。在这时，“魔王”出现在这个城市，一连串事件亦开始出现。勇者与魔王间的心理战，斗智的纯爱故事就此揭幕。\n\n游戏宣传语为“赌上性命的、纯爱”（命をかけた、純愛）。","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"简介 《G线上的魔王》，是由AKABEiSOFT2研发的恋爱冒险游戏第9作。本作原计划于2007年11月29日发行，但由于开发延迟，正式发行一再推迟，最终于2008年5月29日在日本本土发行，比原计划发布日期晚了半年。2015年11月6日，Sekai Project代理发行Steam英文版《G-senjou no Maou》。 喜欢古典音乐的普通少年浅井京介，与同学美轮椿姬、相泽荣一、义妹浅井花音熟识。而在夜晚，则是养父浅井权三的公司中的重要人物。在冬天，少女宇佐美春转校来到京介的学校，她就是以前和京介一起的“勇者”。在这时，“魔王”出现在这个城市，一连串事件亦开始出现。勇者与魔王间的心理战，","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/:1:0","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 浅井京介 浅井 京介、あざい きょうすけ 男 2 宇佐美春 女 瑞沢渓 3 浅井花音 あざい かのん 女 こおろぎさとみ 4 美轮桩姬 みわ つばき 女 神崎ちろ 5 白鸟水羽 白鳥 水羽、しらとり みずは 女 氷青 6 时田雪 時田 ユキ、ときた ゆき 女 ひと美 7 浅井权三 浅井 権三、あざい ごんぞう 男 稲田徹 8 魔王 男 福山潤 ","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/:2:0","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"系列 系列名 发行时间 1 G线上的魔王 2008-05-29 ","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/:3:0","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"MAD ","date":"2008-05-29","objectID":"/game/g-senjou_no_maou/:4:0","tags":null,"title":"G线上的魔王","uri":"/game/g-senjou_no_maou/"},{"categories":null,"content":"由于记忆可以被储存，肉体的死亡不再具有意义。由于记忆可以在不同身体中转移，发生许多社会现象，像是记忆的买卖、违法的记忆改造、偷取他人的记忆。社会混乱，进步停滞。丧失自己记忆的主角凯巴在这样的社会里寻找自己原来的记忆。","date":"2008-04-10","objectID":"/anime/kaiba/","tags":null,"title":"海马","uri":"/anime/kaiba/"},{"categories":null,"content":"简介 由于记忆可以被储存，肉体的死亡不再具有意义。由于记忆可以在不同身体中转移，发生许多社会现象，像是记忆的买卖、违法的记忆改造、偷取他人的记忆。社会混乱，进步停滞。丧失自己记忆的主角凯巴在这样的社会里寻找自己原来的记忆。 制作人员： 原作：MADHOUSE、汤浅政明 脚本：三原三千夫、高桥知也、崔恩映、横山彰利 ","date":"2008-04-10","objectID":"/anime/kaiba/:1:0","tags":null,"title":"海马","uri":"/anime/kaiba/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 凯巴 海马、Kaiba 男 桑島法子 2 波波 Popo 男 朴璐美 3 内伊罗 Neiro 女 能登麻美子 4 クロニコ クロニコ、Chroniko 女 斎藤千和 5 バニラ バニラ、Vanilla 男 江川央生 6 キチ キチ、Kichi 男 岩永哲哉 7 カバ カバ、Kaba 男 ","date":"2008-04-10","objectID":"/anime/kaiba/:2:0","tags":null,"title":"海马","uri":"/anime/kaiba/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海马 2008-04-10 12 bilibili ","date":"2008-04-10","objectID":"/anime/kaiba/:3:0","tags":null,"title":"海马","uri":"/anime/kaiba/"},{"categories":null,"content":"到处旅行靠贩卖一些小商品为生的商人罗兰斯，从因为收获祭而沸腾的帕斯洛耶村回来后却发现自己的运货马车中貌似有什么东西在里面，罗兰斯把麦束拨开一看，里面却睡着一只长有狼耳和狼尾巴的少女。这位少女自称是“掌控丰收的贤狼——赫萝”，靠麦子为生的她如果脖子上挂的帕斯洛耶麦子遗失了就会死。赫萝死赖着劳伦斯希望他能够带她回到遥远的北方故乡，于是，狼女与商人“完全没有剑与魔法的”旅行由此展开……","date":"2008-01-08","objectID":"/anime/spice_and_wolf/","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"简介 到处旅行靠贩卖一些小商品为生的商人罗兰斯，从因为收获祭而沸腾的帕斯洛耶村回来后却发现自己的运货马车中貌似有什么东西在里面，罗兰斯把麦束拨开一看，里面却睡着一只长有狼耳和狼尾巴的少女。这位少女自称是“掌控丰收的贤狼——赫萝”，靠麦子为生的她如果脖子上挂的帕斯洛耶麦子遗失了就会死。赫萝死赖着劳伦斯希望他能够带她回到遥远的北方故乡，于是，狼女与商人“完全没有剑与魔法的”旅行由此展开…… 制作人员： 原作：支仓冻砂 导演：高桥丈夫 脚本：荒川稔久 分镜：矢吹勉、岛津裕行、高本宣弘、中山正惠 演出：古谷田顺久 ","date":"2008-01-08","objectID":"/anime/spice_and_wolf/:1:0","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 赫萝 Холо、赫罗、Holo、ホロ、Holo、贤狼 女 小清水亜美 2 克拉福·罗伦斯 克拉福·劳伦斯、クラフト・ロレンス、Kraft Lawrence、罗兰斯、Крафт Лоурэнс 男 福山潤 3 库洛艾 クロエ、Chloe 女 名塚佳織 4 诺儿菈·艾伦 Norah Arendt、Nora Arendt、ノーラ・アレント 女 中原麻衣 5 列支敦·马贺特 Richten Marlheit、リヒテン・マールハイト 男 大塚芳忠 6 杰廉 ゼーレン 男 浪川大輔 ","date":"2008-01-08","objectID":"/anime/spice_and_wolf/:2:0","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 狼与香辛料 2008-01-08 13 樱花 2 狼与香辛料 第二季 2009-07-08 13 bilibili ","date":"2008-01-08","objectID":"/anime/spice_and_wolf/:3:0","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"MAD ","date":"2008-01-08","objectID":"/anime/spice_and_wolf/:4:0","tags":null,"title":"狼与香辛料","uri":"/anime/spice_and_wolf/"},{"categories":null,"content":"剧场版《空之境界》改编自TYPE-MOON旗下作家奈须蘑菇的同名长篇小说。《空之境界》是著名作家、脚本家奈须蘑菇在\n1998年到1999年写作连载的轻小说， 插画由好友武内崇负责。那时的奈须与武内崇组成同人团体“竹帚”，后来随着TYPE-MOON的成立，\n著名作品《月姬》以及《Fate/stay night》引起巨大反响。 以这些为契机，《空之境界》推出了剧场版系列。\n作品以拥有直死之眼的两仪式与普通青年黑桐干也为中心，描绘了从两人高中邂逅开始的种种故事，\n在月世界的灰暗基调下，这残忍却又温馨的故事震撼了许多观众的心灵。","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"简介 剧场版《空之境界》改编自TYPE-MOON旗下作家奈须蘑菇的同名长篇小说。《空之境界》是著名作家、脚本家奈须蘑菇在 1998年到1999年写作连载的轻小说， 插画由好友武内崇负责。那时的奈须与武内崇组成同人团体“竹帚”，后来随着TYPE-MOON的成立， 著名作品《月姬》以及《Fate/stay night》引起巨大反响。 以这些为契机，《空之境界》推出了剧场版系列。 作品以拥有直死之眼的两仪式与普通青年黑桐干也为中心，描绘了从两人高中邂逅开始的种种故事， 在月世界的灰暗基调下，这残忍却又温馨的故事震撼了许多观众的心灵。 制作人员： 原作：奈须蘑菇 导演：青木英 脚本：平松正树 音乐：梶","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/:1:0","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 两仪式 兩儀 式、りょうぎ しき、Ryougi Shiki、214 女 坂本真綾 2 黑桐干也 Mikiya Kokutō、こくとう みきや、Kokutō Mikiya 男 鈴村健一 3 巫条雾绘 巫条霧絵、Fujou Kirie 女 田中理恵 4 苍崎橙子 あおざき とうこ、Aozaki Touko 女 本田貴子 5 荒耶宗莲 荒耶宗蓮、あらや そうれん、Araya Souren、大和尚 男 中田譲治 6 黑桐鲜花 こくとう あざか、Kokutou Azaka 女 藤村歩 ","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/:2:0","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 剧场版 空之境界 第一章 俯瞰风景 2007-12-01 1 bilibili 2 剧场版 空之境界 第二章 杀人考察（前） 2007-12-29 1 bilibili 3 剧场版 空之境界 第三章 痛觉残留 2008-02-09 1 bilibili 4 剧场版 空之境界 第四章 伽蓝之洞 2008-05-24 1 bilibili 5 剧场版 空之境界 第五章 矛盾螺旋 2008-08-16 1 bilibili 6 剧场版 空之境界 第六章 忘却录音 2008-12-20 1 bilibili 7 剧场版 空之境界 第七章 杀人考察（后）","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/:3:0","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"MAD ","date":"2007-12-01","objectID":"/anime/kara_no_kyoukai/:4:0","tags":null,"title":"空之境界","uri":"/anime/kara_no_kyoukai/"},{"categories":null,"content":"《Dead Fantasy》是由已故美籍亚裔动画制作师Monty Oum制作的系列同人3D动画， 片中角色主要来自角色扮演游戏《最终幻想》和格斗游戏《死或生》，\n本作品的名称也正来源于《Dead Or Alive》第一个单词和《Final Fantasy》的最后一个单词。 \n《Dead Fantasy》第一集发布于2007年10月15日，之后以“极其缓慢”的速度推出续集。\n\n2011年6月，网上已经出现了国外粉丝拍摄的《Dead Fantasy6》预览版，画质、人物效果都超越了前5集，相信不久6就与大众见面。\n在Monty的设想中，接下来的DF系列会有DF6、7、8、G、S。当然DF-G和DF-S被设想为一个分开的故事而非DF的主线。\nMonty之后在A-Kon 22上发表评论表示在DF10之前不会再提及莉诺雅的故事。然而随着Monty的过世，DF系列成为了真正的绝唱。","date":"2007-10-15","objectID":"/anime/dead_fantasy/","tags":null,"title":"死或生VS最终幻想","uri":"/anime/dead_fantasy/"},{"categories":null,"content":"简介 《Dead Fantasy》是由已故美籍亚裔动画制作师Monty Oum制作的系列同人3D动画， 片中角色主要来自角色扮演游戏《最终幻想》和格斗游戏《死或生》， 本作品的名称也正来源于《Dead Or Alive》第一个单词和《Final Fantasy》的最后一个单词。 《Dead Fantasy》第一集发布于2007年10月15日，之后以“极其缓慢”的速度推出续集。 2011年6月，网上已经出现了国外粉丝拍摄的《Dead Fantasy6》预览版，画质、人物效果都超越了前5集，相信不久6就与大众见面。 在Monty的设想中，接下来的DF系列会有DF6、7、8、G、S。当然DF-G和D","date":"2007-10-15","objectID":"/anime/dead_fantasy/:1:0","tags":null,"title":"死或生VS最终幻想","uri":"/anime/dead_fantasy/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 死或生VS最终幻想 2007-10-15 6 下方 ","date":"2007-10-15","objectID":"/anime/dead_fantasy/:2:0","tags":null,"title":"死或生VS最终幻想","uri":"/anime/dead_fantasy/"},{"categories":null,"content":"这是曾经因遭受地震和大火侵袭，而一度坍塌的街道——音羽。\n而这条街现在，犹如从欧洲的童话中飞出来一般，作为非常美丽的街景复苏了。\n就像是，将那不吉祥的灾难的记忆掩盖起来一般……。\n在这片重生的土地上，一个童话般的恋爱物语开始了…","date":"2007-10-06","objectID":"/anime/ef/","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"简介 这是曾经因遭受地震和大火侵袭，而一度坍塌的街道——音羽。 而这条街现在，犹如从欧洲的童话中飞出来一般，作为非常美丽的街景复苏了。 就像是，将那不吉祥的灾难的记忆掩盖起来一般……。 在这片重生的土地上，一个童话般的恋爱物语开始了… 制作人员： 原作：镜游、minori、御影 导演：大沼心 脚本：高山克彦 分镜：宫崎修治、石仓贤一、岛津裕行 ","date":"2007-10-06","objectID":"/anime/ef/:1:0","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫村宫子 宮村みやこ、みやむら みやこ、Miyamura Miyako 女 田口宏子 2 新藤景 Shindou Kei、新藤景、しんどう けい 女 岡田純子 3 新藤千寻 新藤 千尋、しんどう ちひろ、Shindou Chihiro 女 やなせなつみ 4 广野纮 Hirono Hiro、広野紘、ひろの ひろ 男 下野紘 5 堤京介 堤 京介、つつみ きょうすけ、Tsutsumi Kyousuke 男 泰勇気 6 麻生莲治 Asou Renji、麻生蓮治、あそう れんじ 男 高城元気 7 羽山瑞希 Hayama Mizuki、はやま みずき、未来 女 後藤麻","date":"2007-10-06","objectID":"/anime/ef/:2:0","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 悠久之翼 2007-10-06 12 bilibili 2 悠久之翼2 2008-10-06 12 bilibili ","date":"2007-10-06","objectID":"/anime/ef/:3:0","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"MAD ","date":"2007-10-06","objectID":"/anime/ef/:4:0","tags":null,"title":"悠久之翼","uri":"/anime/ef/"},{"categories":null,"content":"故事发生在一个小镇上，冈崎朋也是光坂高中在校生，因为家庭原因他一直过着浑浑噩噩的生活。他不参加任何社团活动，唯一的朋友是春原阳平。\n某天的上学途中，在樱花飞舞的坡道上，他邂逅了一名少女——古河渚，从此他的生活发生改变。渚因病休学一年，重返校园的她对周围环境感到相当不适应。她想加入戏剧部，然而戏剧部早已休部。朋也决定帮助她一起开展戏剧部的活动，二人关系变得越发亲密。随后不久朋也在图书馆中结识了一名天才少女一之濑琴美。","date":"2007-10-04","objectID":"/anime/clannad/","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"简介 故事发生在一个小镇上，冈崎朋也是光坂高中在校生，因为家庭原因他一直过着浑浑噩噩的生活。他不参加任何社团活动，唯一的朋友是春原阳平。 某天的上学途中，在樱花飞舞的坡道上，他邂逅了一名少女——古河渚，从此他的生活发生改变。渚因病休学一年，重返校园的她对周围环境感到相当不适应。她想加入戏剧部，然而戏剧部早已休部。朋也决定帮助她一起开展戏剧部的活动，二人关系变得越发亲密。随后不久朋也在图书馆中结识了一名天才少女一之濑琴美。 制作人员： 原作：Key、Visual Art’s 导演：石原立也 脚本：志茂文彦 分镜：武本康弘、高雄统子、米田光良、石立太一 ","date":"2007-10-04","objectID":"/anime/clannad/:1:0","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 冈崎朋也 岡崎朋也、Okazaki Tomoya 男 緒乃冬華 2 古河渚 冈崎渚、ふるかわ なぎさ、Furukawa Nagisa、小渚 女 中原麻衣 3 伊吹风子 いぶきふうこ、Ibuki Fuuko 女 野中藍 4 一之濑琴美 一ノ瀬 ことみ、いちのせ ことみ、Ichinose Kotomi 女 能登麻美子 5 藤林杏 ふじばやし きょう、Fujibayashi Kyou 女 広橋涼 6 坂上智代 さかがみともよ、Sakagami Tomoyo 女 桑島法子 7 藤林椋 ふじばやしりょう、Fujibayashi Ryou 女 神田朱未 8 春原阳平 春","date":"2007-10-04","objectID":"/anime/clannad/:2:0","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 CLANNAD 2007-10-04 23 bilibili 2 CLANNAD 另一个世界 智代篇 2008-07-16 1 bilibili 3 CLANNAD ～AFTER STORY～ 2008-10-02 24 bilibili 4 CLANNAD ～AFTER STORY～另一个世界 杏篇 2009-05-24 1 bilibili ","date":"2007-10-04","objectID":"/anime/clannad/:3:0","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"MAD ","date":"2007-10-04","objectID":"/anime/clannad/:4:0","tags":null,"title":"CLANNAD","uri":"/anime/clannad/"},{"categories":null,"content":"室江高中剑道社的指导老师石田虎侍是个为了明天伙食费而伤透脑筋，既没干劲又没钱的老师。有一天，因为答应和石桥前辈所带领的女子剑道社进行团体练习赛，而开始与剑道社社长千叶纪梨乃，以及新加入的男学员（中田勇次、荣花段十朗）一起力劝女生入社。\n经历了种种事件之后，出身剑道道场的独生女—实力不凡的川添珠姬、荣花的女友—初学者宫崎都加入剑道社，幽灵社员—桑原鞘子也回归社团，社员们开始了积极的赛前练习。即便如此，随着比赛日期一天天临近，剑道社仍然缺少一人，达不到五名参赛队员的要求。\n面对迫在眉睫的比赛，小次郎有什么妙计吗？而练习比赛的真正目的又是什么呢？\n这是一部以搞笑的笔调描绘女孩们通过社团活动而得以成长的青春系学园剑道故事。","date":"2007-10-01","objectID":"/anime/bamboo_blade/","tags":null,"title":"竹刀少女","uri":"/anime/bamboo_blade/"},{"categories":null,"content":"简介 室江高中剑道社的指导老师石田虎侍是个为了明天伙食费而伤透脑筋，既没干劲又没钱的老师。有一天，因为答应和石桥前辈所带领的女子剑道社进行团体练习赛，而开始与剑道社社长千叶纪梨乃，以及新加入的男学员（中田勇次、荣花段十朗）一起力劝女生入社。 经历了种种事件之后，出身剑道道场的独生女—实力不凡的川添珠姬、荣花的女友—初学者宫崎都加入剑道社，幽灵社员—桑原鞘子也回归社团，社员们开始了积极的赛前练习。即便如此，随着比赛日期一天天临近，剑道社仍然缺少一人，达不到五名参赛队员的要求。 面对迫在眉睫的比赛，小次郎有什么妙计吗？而练习比赛的真正目的又是什么呢？ 这是一部以搞笑的笔调描绘女孩们通过社团活动而得","date":"2007-10-01","objectID":"/anime/bamboo_blade/:1:0","tags":null,"title":"竹刀少女","uri":"/anime/bamboo_blade/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 川添珠姬 川添 珠姫、Kawazoe Tamaki 女 広橋涼 2 千叶纪梨乃 千葉 紀梨乃、ちば きりの、Chiba Kirino 女 豊口めぐみ 3 桑原鞘子 桑原 鞘子、Kuwahara Sayako 女 小島幸子 4 宫崎都 宮崎 都、みやざき みやこ、Miyazaki Miyako、MIYAMIYA 女 桑島法子 5 东聪莉 東 聡莉、Azuma Satori 女 佐藤利奈 6 石田虎侍 石田 虎侍、Ishida Toraji、コジロー 男 小西克幸 7 中田勇次 なかた ゆうじ、ユージ 男 阪口大助 8 荣花段十朗 栄花 段十朗、えいが だんじゅ","date":"2007-10-01","objectID":"/anime/bamboo_blade/:2:0","tags":null,"title":"竹刀少女","uri":"/anime/bamboo_blade/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 竹刀少女 2007-10-01 26 9anime ","date":"2007-10-01","objectID":"/anime/bamboo_blade/:3:0","tags":null,"title":"竹刀少女","uri":"/anime/bamboo_blade/"},{"categories":null,"content":"　　1711年在大西洋上，背井离乡的炼金术师们从恶魔手中得到了一样东西——那便是永生之酒。为了独占永生之酒的配方，在秘密之船上的众人开始互相残杀。1930年代的纽约的黑道中，年少有为的菲洛、傻瓜盗贼夫妇、200年老不死的炼金术士和他的助手，以及菲洛从小的玩伴、豪门千金、恐怖组织成员、年轻的列车长……这一群原本毫不相干的人却因永生之酒的复苏让他们的命运开始复杂交错起来。\n　　以纽约作为目的地，从芝加哥出发穿越美洲大陆的列车上，命运之轮将所有人聚集到了一起。而在这辆列车上的不仅仅是“人类”而已。传说中的幽灵再次出现，车上的旅客从最后一节车厢开始一个一个接连消失……","date":"2007-07-26","objectID":"/anime/baccano/","tags":null,"title":"永生之酒","uri":"/anime/baccano/"},{"categories":null,"content":"简介 1711年在大西洋上，背井离乡的炼金术师们从恶魔手中得到了一样东西——那便是永生之酒。为了独占永生之酒的配方，在秘密之船上的众人开始互相残杀。1930年代的纽约的黑道中，年少有为的菲洛、傻瓜盗贼夫妇、200年老不死的炼金术士和他的助手，以及菲洛从小的玩伴、豪门千金、恐怖组织成员、年轻的列车长……这一群原本毫不相干的人却因永生之酒的复苏让他们的命运开始复杂交错起来。 以纽约作为目的地，从芝加哥出发穿越美洲大陆的列车上，命运之轮将所有人聚集到了一起。而在这辆列车上的不仅仅是“人类”而已。传说中的幽灵再次出现，车上的旅客从最后一节车厢开始一个一个接连消失…… 制作人员： 原作：成田良悟 导演：","date":"2007-07-26","objectID":"/anime/baccano/:1:0","tags":null,"title":"永生之酒","uri":"/anime/baccano/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 克雷亚·斯坦菲尔德 フェリックス・ウォーケン、Claire Standfield 男 森田成一 2 艾萨克·迪安 Issac Dian、アイザック・ディアン、アイザック・ディアン 男 小野坂昌也 3 蜜莉亚·哈文德 Miria Harvent 女 あおきさやか 4 菲洛·普罗辛琪奥 费洛・普罗宣查、Firo Prochainezo、フィーロ・プロシェンツォ、フィーロ・プロシェンツォ、fiiro puroshyentsu、Firo 男 吉野裕行 5 修伊·拉弗雷特 Huey Laforet 男 千葉進歩 6 拉克.甘多鲁 Luck Gandor 男 子安武人 ","date":"2007-07-26","objectID":"/anime/baccano/:2:0","tags":null,"title":"永生之酒","uri":"/anime/baccano/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 永生之酒 2007-07-26 16 bilibili ","date":"2007-07-26","objectID":"/anime/baccano/:3:0","tags":null,"title":"永生之酒","uri":"/anime/baccano/"},{"categories":null,"content":"有一位在各地旅行并且携带斩魔剑斩除「妖怪」的卖药郎。\n\n只要在他以及剑的呼唤下，在卖药男的面前就会出现一个又一个妖怪。\n\n在那些因为恐惧而要求除去妖怪的人们的请求下，他会拿出这把剑并且告知人们，他需要清楚找出关于妖怪的三种要素：分别是因为人的因果，所形成的缘份（えにし）即是「形（かたち）」、事情的真相「真（まこと）」、心中的隐情「理（ことわり）」才能加以消灭。\n\n就在这个除妖之旅上，他前往的地方，也就是各式各样所谓的「人世」。并且在完成使命后，又忽然消失于大家眼前……。","date":"2007-07-12","objectID":"/anime/mononoke/","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"简介 有一位在各地旅行并且携带斩魔剑斩除「妖怪」的卖药郎。 只要在他以及剑的呼唤下，在卖药男的面前就会出现一个又一个妖怪。 在那些因为恐惧而要求除去妖怪的人们的请求下，他会拿出这把剑并且告知人们，他需要清楚找出关于妖怪的三种要素：分别是因为人的因果，所形成的缘份（えにし）即是「形（かたち）」、事情的真相「真（まこと）」、心中的隐情「理（ことわり）」才能加以消灭。 就在这个除妖之旅上，他前往的地方，也就是各式各样所谓的「人世」。并且在完成使命后，又忽然消失于大家眼前……。 制作人员： 导演：中村健治 脚本：小中千昭、横手美智子、石川学、高桥郁子 分镜：山崎浩司、石黑育、梅泽淳稔、植田秀仁 ","date":"2007-07-12","objectID":"/anime/mononoke/:1:0","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 卖药郎 Medicine Seller、Kusuriuri、薬売り 男 櫻井孝宏 2 加世 かよ 女 ゆかな ","date":"2007-07-12","objectID":"/anime/mononoke/:2:0","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 怪化猫 2007-07-12 12+3 bilibili ","date":"2007-07-12","objectID":"/anime/mononoke/:3:0","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"MAD ","date":"2007-07-12","objectID":"/anime/mononoke/:4:0","tags":null,"title":"怪化猫","uri":"/anime/mononoke/"},{"categories":null,"content":"著名动画制作公司STUDIO4℃的新作电影《GENIUS PARTY》，日前决定公映日为7月7日，放映剧场被安排在Cine Libre池袋、涩谷Cine Amuse等，日本全国依次预定展开。 《GENIUS PARTY》是由7个短篇组成的电影作品，福岛敦子、河森正治、木村真二、福山庸治、二村秀树、汤浅政明、渡边信一郎等人分别担任监督。 同时，音乐制片人由渡边信一郎先生担任。负责音乐的还有中川俊郎、山本精一、渡边琢磨、FENNESZ、竹村信和、菅野洋子等在娱乐领域一流的艺术家，这也让大家期待达到了前所未有的高度。 声优方面，在戛纳国际电影节获得最优秀奖的柳乐优也，凭借《巴别塔》被奥斯卡金像奖提名的菊池凛子，《蒙面超人响鬼》的栩原乐人、小仓久宽、三上博史等都将参加演出。 《GENIUS PARTY》的第2弹预定在2008年公开，同样仍将是由7位著名监督的短篇作品组成的形式。","date":"2007-07-07","objectID":"/anime/genius_party/","tags":null,"title":"天才嘉年华","uri":"/anime/genius_party/"},{"categories":null,"content":"简介 著名动画制作公司STUDIO4℃的新作电影《GENIUS PARTY》，日前决定公映日为7月7日，放映剧场被安排在Cine Libre池袋、涩谷Cine Amuse等，日本全国依次预定展开。 《GENIUS PARTY》是由7个短篇组成的电影作品，福岛敦子、河森正治、木村真二、福山庸治、二村秀树、汤浅政明、渡边信一郎等人分别担任监督。 同时，音乐制片人由渡边信一郎先生担任。负责音乐的还有中川俊郎、山本精一、渡边琢磨、FENNESZ、竹村信和、菅野洋子等在娱乐领域一流的艺术家，这也让大家期待达到了前所未有的高度。 声优方面，在戛纳国际电影节获得最优秀奖的柳乐优也，凭借《巴别塔》被奥斯卡金像","date":"2007-07-07","objectID":"/anime/genius_party/:1:0","tags":null,"title":"天才嘉年华","uri":"/anime/genius_party/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天才嘉年华 2007-07-07 7 bilibili 2 天才嘉年华BEYOND 2008-10-11 5 bilibili ","date":"2007-07-07","objectID":"/anime/genius_party/:2:0","tags":null,"title":"天才嘉年华","uri":"/anime/genius_party/"},{"categories":null,"content":"MAD ","date":"2007-07-07","objectID":"/anime/genius_party/:3:0","tags":null,"title":"天才嘉年华","uri":"/anime/genius_party/"},{"categories":null,"content":"身高172cm的高个女生小泉理沙，和身高156.2cm的可爱男生大谷敦士，从进入每户学园之后，就互相吐槽、彼此抬杠，是大家眼中的斗嘴好搭档。可是在高一那年的圣诞节，两人的关系却产生了微妙的变化。理沙发现自己渐渐爱上了大谷，会随着他的一言一行又喜又悲又生气。可是“像我这样的电线杆女生，为什么偏偏喜欢上娇小可爱的男生？”不知该如何是好的理沙，只好用搞笑来掩饰真心。","date":"2007-04-07","objectID":"/anime/lovely_complex/","tags":null,"title":"恋爱情结","uri":"/anime/lovely_complex/"},{"categories":null,"content":"简介 身高172cm的高个女生小泉理沙，和身高156.2cm的可爱男生大谷敦士，从进入每户学园之后，就互相吐槽、彼此抬杠，是大家眼中的斗嘴好搭档。可是在高一那年的圣诞节，两人的关系却产生了微妙的变化。理沙发现自己渐渐爱上了大谷，会随着他的一言一行又喜又悲又生气。可是“像我这样的电线杆女生，为什么偏偏喜欢上娇小可爱的男生？”不知该如何是好的理沙，只好用搞笑来掩饰真心。 制作人员： 原作：中原亚矢 导演：宇田钢之介 脚本：井上美绪、影山由美、山田隆司、高桥洋一、村山功 分镜：石平信司、深泽敏则 ","date":"2007-04-07","objectID":"/anime/lovely_complex/:1:0","tags":null,"title":"恋爱情结","uri":"/anime/lovely_complex/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 小泉理沙 小泉 リサ、こいずみ りさ、Koizumi Risa 女 岡村明美 2 大谷敦士 大谷 敦士、おおたに あつし、Ootani Atsushi 男 永田彬 3 石原信子 石原 信子、いしはら のぶこ、Ishihara Nobuko 女 東さおり 4 中尾平吉 中尾平吉、なかお へいきち、Nakao Heikichi 男 徳山靖彦 5 田中千春 たなか ちはる、Tanaka Chiharu、千春ちゃん 女 こじまかずこ 6 铃木凉二 鈴木涼二、すずき りょうじ、Suzuki Ryouji 男 津田健次郎 7 寿圣子郎 ことぶき せいしろう、Kotobu","date":"2007-04-07","objectID":"/anime/lovely_complex/:2:0","tags":null,"title":"恋爱情结","uri":"/anime/lovely_complex/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 恋爱情结 2007-04-07 24 bilibili ","date":"2007-04-07","objectID":"/anime/lovely_complex/:3:0","tags":null,"title":"恋爱情结","uri":"/anime/lovely_complex/"},{"categories":null,"content":"　　依人是个喜爱着天空的普通高中一年级学生。\n　　石月真名是个活泼开朗的少女，同时也是依人的同学。\n　　真名的妹妹こより是小学二年级的学生，但因为身体状况不是很好，所以一直在一家可以看到大海的医院中住院。\n　　在这家医院中，こより遇到了一个名叫森宫苍乃的女孩。森宫苍乃和依人的关系很好，类似于姐弟的存在。\n　　这一天，是苍乃的生日，依人和真名一起去医院探望苍乃和こより，四个人愉快的嬉戏着。\n　　正在此时，神秘男子佛堂刚史与身着歌特萝莉服装的少女神河茧子展开了共同旅行。\n　　少女四方茉莉在街道的教会中独自的生活。然后，某日的凌晨四点，在美丽的海滨自然公园中，茉莉与正准备拍摄天空照片的依人却偶然相遇了。少年与少女的相遇，拉开了不思议事件的序幕……。","date":"2007-04-06","objectID":"/anime/sola/","tags":null,"title":"sola","uri":"/anime/sola/"},{"categories":null,"content":"简介 依人是个喜爱着天空的普通高中一年级学生。 石月真名是个活泼开朗的少女，同时也是依人的同学。 真名的妹妹こより是小学二年级的学生，但因为身体状况不是很好，所以一直在一家可以看到大海的医院中住院。 在这家医院中，こより遇到了一个名叫森宫苍乃的女孩。森宫苍乃和依人的关系很好，类似于姐弟的存在。 这一天，是苍乃的生日，依人和真名一起去医院探望苍乃和こより，四个人愉快的嬉戏着。 正在此时，神秘男子佛堂刚史与身着歌特萝莉服装的少女神河茧子展开了共同旅行。 少女四方茉莉在街道的教会中独自的生活。然后，某日的凌晨四点，在美丽的海滨自然公园中，茉莉与正准备拍摄天空照片的依人却偶然相遇了。少年与少女的相遇，","date":"2007-04-06","objectID":"/anime/sola/:1:0","tags":null,"title":"sola","uri":"/anime/sola/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 森宫依人 森宮 依人、もりみや よりと、Morimiya Yorito 男 岡本信彦 2 四方茉莉 しほう まつり、Shihou Matsuri 女 能登麻美子 3 森宫苍乃 森宮 蒼乃、もりみや あおの、Morimiya Aono 女 中原麻衣 4 石月真名 石月 真名、いしづき まな、Ishizuki Mana 女 本多陽子 5 石月小依 石月 こより、いしづき こより、Ishizuki Koyori 女 清水愛 6 辻堂刚史 辻堂 剛史、つじどう たけし、Tsujidou Takeshi 男 藤原啓治 7 神河茧子 かみかわ まゆこ、Kamikawa ","date":"2007-04-06","objectID":"/anime/sola/:2:0","tags":null,"title":"sola","uri":"/anime/sola/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 sola 2007-04-06 13 bilibili MAD ","date":"2007-04-06","objectID":"/anime/sola/:3:0","tags":null,"title":"sola","uri":"/anime/sola/"},{"categories":null,"content":"       自古妖魔侵入人類的世界，化作人形並以啃食人類的內臟為生，對妖魔束手無策的人們唯有求助於有著半人半妖的身分，帶著巨劍且以斬殺妖魔為業的銀眼戰士，畏懼並害怕她們的人們將其稱為Claymore（大劍、銀眼魔女）。","date":"2007-04-03","objectID":"/anime/claymore/","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"简介 自古妖魔侵入人類的世界，化作人形並以啃食人類的內臟為生，對妖魔束手無策的人們唯有求助於有著半人半妖的身分，帶著巨劍且以斬殺妖魔為業的銀眼戰士，畏懼並害怕她們的人們將其稱為Claymore（大劍、銀眼魔女）。 制作人员： 原作：八木教广 导演：田中洋之 脚本：笔安一幸、小林靖子、西田大辅 分镜：芦野芳晴、山崎和男、滨崎博嗣、浅香守生 ","date":"2007-04-03","objectID":"/anime/claymore/:1:0","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 克蕾雅 Clare 女 桑島法子 2 拉基 ラキ、Raki 男 高城元気 3 オフィーリア 女 篠原恵美 4 ルヴル 男 平田広明 5 イレーネ 女 高山みなみ 6 ジーン 女 三石琴乃 7 泰莉莎 迪妮莎、特蕾莎、テレサ、Teresa、微笑のテレサ 女 朴璐美 8 普莉希拉 プリシラ、Priscilla 女 久川綾 ","date":"2007-04-03","objectID":"/anime/claymore/:2:0","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 大剑 2007-04-03 26 樱花 ","date":"2007-04-03","objectID":"/anime/claymore/:3:0","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"MAD ","date":"2007-04-03","objectID":"/anime/claymore/:4:0","tags":null,"title":"大剑","uri":"/anime/claymore/"},{"categories":null,"content":"       这是一个被命运背叛的男人，战斗、继续战斗、不断战斗的热血故事。\n日复一日，地下村庄基哈村的少年西蒙始终拿着钻头挖掘，并习以为常。但是，西蒙的好友，被称为“大哥”的卡米那终日叫嚣着所谓地上的世界。“穿破天际，到地上的世界去看一看吧”卡米那每日这样想着。但一直未能成功。直到一天，巨大的机械怪物——“颜面”打破村子的天井，进入村子破坏。确认了地上世界的存在，卡米那热情高涨，与地上来的少女优子、小弟西蒙三人一起对抗颜面，并驾驶西蒙意外挖出的机械——“螺岩”冲出了天井，达到了地上的世界！\n地球表面展现在少年少女面前，但其实地表上有更多的“颜面”，不断战斗的冒险故事就此展开。西蒙的未来，以任何人都无法想象的方向展开。","date":"2007-04-01","objectID":"/anime/tengen_toppa/","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"简介 这是一个被命运背叛的男人，战斗、继续战斗、不断战斗的热血故事。 日复一日，地下村庄基哈村的少年西蒙始终拿着钻头挖掘，并习以为常。但是，西蒙的好友，被称为“大哥”的卡米那终日叫嚣着所谓地上的世界。“穿破天际，到地上的世界去看一看吧”卡米那每日这样想着。但一直未能成功。直到一天，巨大的机械怪物——“颜面”打破村子的天井，进入村子破坏。确认了地上世界的存在，卡米那热情高涨，与地上来的少女优子、小弟西蒙三人一起对抗颜面，并驾驶西蒙意外挖出的机械——“螺岩”冲出了天井，达到了地上的世界！ 地球表面展现在少年少女面前，但其实地表上有更多的“颜面”，不断战斗的冒险故事就此展开。西蒙的未来，以任何人都无","date":"2007-04-01","objectID":"/anime/tengen_toppa/:1:0","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 西蒙 simon、シモン、Simon 男 菅生隆之 2 卡米那 カミナ、Kamina 男 小西克幸 3 优子 阳子、ヨーコ、Youko、夜子、よるこ 女 井上麻里奈 4 妮亚 ニア・テッペリン、Nia Teppelin 女 福井裕佳梨 5 卜塔 ブータ、Boota 男 伊藤静 6 利珑 リーロン・リットナー、Leeron 男 小野坂昌也 7 维拉鲁 ヴィラル、Viral 男 檜山修之 8 达雅卡 ダヤッカ・リットナー、Dayakka Littner 男 中村大樹 ","date":"2007-04-01","objectID":"/anime/tengen_toppa/:2:0","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 天元突破 红莲螺岩 2007-04-01 27 bilibili ","date":"2007-04-01","objectID":"/anime/tengen_toppa/:3:0","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"MAD ","date":"2007-04-01","objectID":"/anime/tengen_toppa/:4:0","tags":null,"title":"天元突破 红莲螺岩","uri":"/anime/tengen_toppa/"},{"categories":null,"content":"时间是1990年代的日本，远野贵树与筱原明里原本是同班同学的好朋友，自从小学毕业之后，两人都没有再见一次面。分隔两地的两个人，靠着书信往来保持联络，直到贵树知道即将跟随家人搬到鹿儿岛，距离明里更远的地方，于是两人约定了再见面的时间。计划好的行程，却遇上了暴风雪……。","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"简介 时间是1990年代的日本，远野贵树与筱原明里原本是同班同学的好朋友，自从小学毕业之后，两人都没有再见一次面。分隔两地的两个人，靠着书信往来保持联络，直到贵树知道即将跟随家人搬到鹿儿岛，距离明里更远的地方，于是两人约定了再见面的时间。计划好的行程，却遇上了暴风雪……。 制作人员： 原作：新海诚 音乐：天门 人物设定：西村贵世 ","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/:1:0","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 远野贵树 遠野 貴樹、Toono Takaki 男 水橋研二 2 澄田花苗 女 花村怜美 3 篠原明里 しのはら あかり、Shinohara Akari 女 近藤好美 4 水野理纱 みずの りさ、Mizuno Risa 女 水野理紗 5 卓比 Chobi 男 新海誠 ","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/:2:0","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 秒速5厘米 2007-03-03 01:02:44 bilibili ","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/:3:0","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"MAD ","date":"2007-03-03","objectID":"/anime/5_centimeters_per_second/:4:0","tags":null,"title":"秒速5厘米","uri":"/anime/5_centimeters_per_second/"},{"categories":null,"content":"　　梦。\n我做着一个悠远而长久的梦。\n从很久以前就一直在做着这个梦；\n在梦中我凝望四季的街道，\n期望与永远不会到来的人再度见面，\n找寻连自己也早已忘却的遗失的东西。\n多少时间、多少岁月从我身边流逝而过，\n在无尽的黑夜中，一直、一直都在孤单地等待着——\n等待着最后那必将到来的黎明。","date":"2006-10-05","objectID":"/anime/kanon/","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"简介 梦。 我做着一个悠远而长久的梦。 从很久以前就一直在做着这个梦； 在梦中我凝望四季的街道， 期望与永远不会到来的人再度见面， 找寻连自己也早已忘却的遗失的东西。 多少时间、多少岁月从我身边流逝而过， 在无尽的黑夜中，一直、一直都在孤单地等待着—— 等待着最后那必将到来的黎明。 制作人员： 原作：Visual Art’s、Key 导演：石原立也 脚本：志茂文彦 分镜：石立太一、武本康弘、木上益治、吉冈忍、山本宽 ","date":"2006-10-05","objectID":"/anime/kanon/:1:0","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 相泽祐一 相沢 祐一、あいざわ ゆういち、Aizawa Yuichi 男 杉田智和 2 月宫亚由 月宮 あゆ、つきみや あゆ、Tsukimiya Ayu 女 堀江由衣 3 水濑名雪 水瀬 名雪、みなせなゆき、Minase Nayuki 女 國府田マリ子 4 泽渡真琴 沢渡 真琴、さわたり まこと、Sawatari Makoto 女 飯塚雅弓 5 美坂栞 美坂刊、美坂 栞、みさか しおり、Misaka Shiori 女 佐藤朱 6 川澄舞 川澄 舞、かわすみ まい、Kawasumi Mai 女 田村ゆかり 7 仓田佐祐理 倉田 佐祐理、くらた さゆり、Kura","date":"2006-10-05","objectID":"/anime/kanon/:2:0","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Kanon 2006-10-05 24 bilibili 2 Kanon 东映版 2002-01-30 13 bilibili ","date":"2006-10-05","objectID":"/anime/kanon/:3:0","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"MAD ","date":"2006-10-05","objectID":"/anime/kanon/:4:0","tags":null,"title":"Kanon","uri":"/anime/kanon/"},{"categories":null,"content":"高三生夜神月意外捡到一本名《DEATH NOTE》的笔记本，并且发现只要写下想要杀死的人的名字，就会变成现实。\n月开始利用死亡笔记制裁那些他认为该死的人。接着，笔记的原主人：死神也以旁观者的姿态出现在月面前。\n另一方面越来越多的罪犯离奇死亡事件引起了各国政府的关注，在国际刑事警察机构会议（ICPO）上他们委托神秘人士L来调查此事。社会上则称这个神秘的杀手为“基拉”，不同的人有不同的反应。\n到底谁才是正义的一方，谁又会取得最后的胜利呢？一场斗智斗勇的较量就此展开…… ","date":"2006-10-04","objectID":"/anime/death_note/","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"简介 高三生夜神月意外捡到一本名《DEATH NOTE》的笔记本，并且发现只要写下想要杀死的人的名字，就会变成现实。 月开始利用死亡笔记制裁那些他认为该死的人。接着，笔记的原主人：死神也以旁观者的姿态出现在月面前。 另一方面越来越多的罪犯离奇死亡事件引起了各国政府的关注，在国际刑事警察机构会议（ICPO）上他们委托神秘人士L来调查此事。社会上则称这个神秘的杀手为“基拉”，不同的人有不同的反应。 到底谁才是正义的一方，谁又会取得最后的胜利呢？一场斗智斗勇的较量就此展开…… 制作人员： 原作：小畑健、大场鸫 导演：荒木哲郎 脚本：小林靖子、伊藤智彦、井上敏树、米村正二 分镜：笹木信作、山本沙代 ","date":"2006-10-04","objectID":"/anime/death_note/:1:0","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 夜神月 やがみ ライト、Yagami Light、Kami 男 宮野真守 2 L 流河旱树、龙崎、艾尔·罗莱特、L Lawliet、エル・ローライト、erurouraito 男 山口勝平 3 琉克 流愚、流克、Ryuk 男 中村獅童 4 弥海砂 Misa Amane、あまね みさ 女 平野綾 5 尼亚 N、Nate River、ネイト・リバー、Near 男 日髙のり子 6 梅洛 M、Mihael Keehl、ミハエル・ケール、Mello 男 佐々木望 7 魅上照 みかみ てる、Mikami Teru 男 松風雅也 8 高田清美 女 坂本真綾 ","date":"2006-10-04","objectID":"/anime/death_note/:2:0","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 死亡笔记 2006-10-04 37 樱花 ","date":"2006-10-04","objectID":"/anime/death_note/:3:0","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"MAD ","date":"2006-10-04","objectID":"/anime/death_note/:4:0","tags":null,"title":"死亡笔记","uri":"/anime/death_note/"},{"categories":null,"content":"　　17岁少女绀野真琴是一个活泼跳脱的少女。在一次普通值日工作中，真琴不小心摔倒了，自此她发现自己拥有了穿越时空的能力。她兴奋不已，掌握了穿越时空的方法后，她经常用这个方法去解决生活中许多令她困扰十分的事。\n　　喜欢棒球的真琴与同班的两名男生千昭与功介有着共同爱好。一天，与她本是好朋友的千昭突然向她表达爱意，手足无措了她再次穿越时空希望可以躲避这件事的发生。但没想到，千昭会跟同学友梨在一起了，而友梨也是一直喜欢千昭的。此时，暗恋功介的果穗误以为真琴是功介的女友。\n　　为了帮忙解决朋友的问题，真琴不断以同样的方法回到过去。她突然发现自己手臂上的数字原来是穿越时空的次数，次数变得越来越少，与此同时她也发现了千昭的秘密…… ","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"简介 17岁少女绀野真琴是一个活泼跳脱的少女。在一次普通值日工作中，真琴不小心摔倒了，自此她发现自己拥有了穿越时空的能力。她兴奋不已，掌握了穿越时空的方法后，她经常用这个方法去解决生活中许多令她困扰十分的事。 喜欢棒球的真琴与同班的两名男生千昭与功介有着共同爱好。一天，与她本是好朋友的千昭突然向她表达爱意，手足无措了她再次穿越时空希望可以躲避这件事的发生。但没想到，千昭会跟同学友梨在一起了，而友梨也是一直喜欢千昭的。此时，暗恋功介的果穗误以为真琴是功介的女友。 为了帮忙解决朋友的问题，真琴不断以同样的方法回到过去。她突然发现自己手臂上的数字原来是穿越时空的次数，次数变得越来越少，与此同时她也发","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/:1:0","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 绀野真琴 紺野 真琴、Konno Makoto 女 仲里依紗 2 间宫千昭 間宮 千昭、Mamiya Chiaki 男 石田卓也 3 津田功介 男 板倉光隆 4 芳山和子 女 原沙知絵 5 绀野美雪 紺野 美雪、Konno Miyuki 女 関戸優希 6 藤谷果穗 藤谷 果穂、Fujitani Kaho 女 谷村美月 ","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/:2:0","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 穿越时空的少女 2006-07-15 01:38:00 bilibili ","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/:3:0","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"MAD ","date":"2006-07-15","objectID":"/anime/the_girl_who_leapt_through_time/:4:0","tags":null,"title":"穿越时空的少女","uri":"/anime/the_girl_who_leapt_through_time/"},{"categories":null,"content":"大学退学第二年的春天，主角家里蹲废材佐藤达广在一事无成下，妄想认为自己的退学跟无职是NHK的全国性阴谋，就在这个时候在他面前出现了之前遇到过叫做中原岬的神秘美少女，并坚持达广一定要加入计划治好只会窝在家里的毛病……","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"简介 大学退学第二年的春天，主角家里蹲废材佐藤达广在一事无成下，妄想认为自己的退学跟无职是NHK的全国性阴谋，就在这个时候在他面前出现了之前遇到过叫做中原岬的神秘美少女，并坚持达广一定要加入计划治好只会窝在家里的毛病…… 制作人员： 原作：泷本龙彦、大岩贤次 导演：山本裕介 脚本：西园悟 分镜：镝木宏、大畑晃一、川畑荣郎、奥野浩行、熊泽佑嗣 ","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/:1:0","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 佐藤达广 男 小泉豊 2 中原岬 なかはら みさき、Nakahara Misaki 女 牧野由依 3 山崎薫 山崎薫、Yamazaki Kaoru 男 阪口大助 4 柏瞳 柏 瞳 女 小林沙苗 5 小林恵 小林恵、Kobayashi Megumi 女 早水リサ 6 绿川七菜子 緑川七菜子、Midorikawa Nanako 女 宍戸留美 7 城崎彰 じょうがさき あきら 男 飛田展男 8 废材星人 未知 ","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/:2:0","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 欢迎加入NHK！ 2006-07-09 24 樱花 ","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/:3:0","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"MAD ","date":"2006-07-09","objectID":"/anime/welcome_to_nhk/:4:0","tags":null,"title":"欢迎加入NHK！","uri":"/anime/welcome_to_nhk/"},{"categories":null,"content":"　　在异世界哈尔凯尼亚被当作“使魔”被召唤出来的高中生平贺才人卷入了一场满载这四种元素的幻想罗曼史大冒险中。将才人召唤至异世界的是长相可爱却没有丝毫魔法才能的主人样·露易丝。面对突然出现的迷之美少女，满心疑惑的才人在听她讲完契约内容之后，遭遇了突如其来的强吻……之后，他的手背上浮现出了不可思议的文字，才人就这样莫名其妙的成为了露易丝的使魔……\n　　以全寄宿制的托丽斯汀魔法学院为舞台，主人样美少女魔法使露易丝与使魔才人在争吵、责备、爱恋中开始了充满了勇气与屈辱的学园生活……在异世界波澜万丈的交流之中，露易丝和才人的命运会怎么样呢？","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"简介 在异世界哈尔凯尼亚被当作“使魔”被召唤出来的高中生平贺才人卷入了一场满载这四种元素的幻想罗曼史大冒险中。将才人召唤至异世界的是长相可爱却没有丝毫魔法才能的主人样·露易丝。面对突然出现的迷之美少女，满心疑惑的才人在听她讲完契约内容之后，遭遇了突如其来的强吻……之后，他的手背上浮现出了不可思议的文字，才人就这样莫名其妙的成为了露易丝的使魔…… 以全寄宿制的托丽斯汀魔法学院为舞台，主人样美少女魔法使露易丝与使魔才人在争吵、责备、爱恋中开始了充满了勇气与屈辱的学园生活……在异世界波澜万丈的交流之中，露易丝和才人的命运会怎么样呢？ 制作人员： 原作：山口升 导演：岩崎良明 脚本：吉冈孝夫 分镜：铃","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/:1:0","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 露易丝·法兰西斯·露·布朗·杜·拉·瓦利埃尔 Louise Françoise Le Blanc de La Vallière、Ruizu Fransowāzu ru Buran do ra Variēru、钉宫四萌 女 釘宮理恵 2 平贺才人 Хирага Сайто、才人·修瓦里埃·杜·平贺·杜·奥尔尼埃尔、平賀才人、ひらが さいと、Hiraga Saito 男 日野聡 3 谢斯塔 Сиеста、シエスタ、Siesta 女 堀江由衣 4 安丽埃塔·杜·托里斯汀 Генриетта де Тристейн、アンリエッタ・ド・トリステイン、Henrietta","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/:2:0","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 零之使魔 2006-07-02 13 bilibili 2 零之使魔 双月骑士 2007-07-08 12 bilibili 3 零之使魔 三美姬的轮舞 2008-07-06 12 bilibili 4 零之使魔F 2012-01-07 12 bilibili ","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/:3:0","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"MAD ","date":"2006-07-02","objectID":"/anime/zero_no_tsukaima/:4:0","tags":null,"title":"零之使魔","uri":"/anime/zero_no_tsukaima/"},{"categories":null,"content":"昭和58年的夏天，白天蝉的喧闹与傍晚茅蜩的合唱仿佛在欢迎今年早夏来临的6月，回荡在雏见泽。\n雏见泽是远离都会的深山中的一个穷乡僻壤。\n人口不足2千人的村子里，最近来了个从都会搬迁过来的少年前原圭一。性格开朗善于交际的圭一在学校里很快融入了周围的同学中。关系最好的喜欢照顾人的丽娜、具有领导才能的委员长魅音、盘球高手的低年级学生沙都子、古手神社千金且带来不可思议的气氛的梨花…\n他与伙伴们过着微不足道的日常生活，并以为会永远持续下去。\n每年6月举行的祭奠---绵流，没错，那一天也应该是快乐的一天的。\n然而在知道了一个关于雏见泽的谜之后，一切都改变了…\n在祭奠当日，惨剧再次发生。每年据说都会有一个人死亡，一个人行踪不明。自数年之前开始的连续怪死事件，其真相是？犯人是？圭一由于好奇心的驱使，步入了村子的黑暗之中。从那天起，圭一的周围发生了微妙但确实显而易见的变化。没错，所有一切都…\n只有茅蜩的鸣叫声一点未变，在雏见泽预告着早夏的来临。","date":"2006-04-04","objectID":"/anime/when_they_cry/","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"简介 昭和58年的夏天，白天蝉的喧闹与傍晚茅蜩的合唱仿佛在欢迎今年早夏来临的6月，回荡在雏见泽。 雏见泽是远离都会的深山中的一个穷乡僻壤。 人口不足2千人的村子里，最近来了个从都会搬迁过来的少年前原圭一。性格开朗善于交际的圭一在学校里很快融入了周围的同学中。关系最好的喜欢照顾人的丽娜、具有领导才能的委员长魅音、盘球高手的低年级学生沙都子、古手神社千金且带来不可思议的气氛的梨花… 他与伙伴们过着微不足道的日常生活，并以为会永远持续下去。 每年6月举行的祭奠—绵流，没错，那一天也应该是快乐的一天的。 然而在知道了一个关于雏见泽的谜之后，一切都改变了… 在祭奠当日，惨剧再次发生。每年据说都会有一个人","date":"2006-04-04","objectID":"/anime/when_they_cry/:1:0","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 前原圭一 越后屋、K、前原 圭一、まえばら けいいち、Maebara Keiichi 男 保志総一朗 2 龙宫礼奈 龙宫蕾娜、龙宫怜奈、竜宮レナ/竜宮礼奈、りゅうぐう れな/りゅうぐう れいな、Ryuuguu Rena/Ryuuguu Reina 女 中原麻衣 3 园崎魅音 そのざき みおん、Sonozaki Mion 女 ゆきのさつき 4 北条沙都子 北条 沙都子、ほうじょう さとこ、Houjou Satoko 女 かないみか 5 古手梨花 咪啪、ふるでりか、Furude Rika、魔法少女 御社神梨花 女 田村ゆかり 6 园崎诗音 そのざき しおん、So","date":"2006-04-04","objectID":"/anime/when_they_cry/:2:0","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 寒蝉鸣泣之时 2006-04-04 26 樱花 2 寒蝉鸣泣之时 解 2007-07-05 24 樱花 ","date":"2006-04-04","objectID":"/anime/when_they_cry/:3:0","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"MAD ","date":"2006-04-04","objectID":"/anime/when_they_cry/:4:0","tags":null,"title":"寒蝉鸣泣之时","uri":"/anime/when_they_cry/"},{"categories":null,"content":"　　舞台设定在了地球以外的其他星球。人们把自己所在的星球称为“大空陆”。在那里，人类一出生就必须以“女性”的身份生活。等到17岁的时候到“泉”那里，选择性别而成为大人的时刻。\n为了夺取主人公等所在的宫国所持有的珍贵引擎，邻国开始了日益激烈的侵略。为了迎击敌国，宫国被迫将仪式用复座式飞行艇“Simoun”改造成了战斗用战舰。还需要未性别化的“巫女”被派遣担任驾驶员，于是，她们成为了被称为“coru”的战斗小队成员。\n操纵“Simoun”的少数少女被称为了“Simoun·シヴュラ（西贝拉）”因为拥有着特殊能力，她们可以选择自己成为大人的时间。但是因为战争的爆发，她们的优秀才能不得不运用在“Simoun”的操作上，换句话说，她们被强迫保持在了“少女阶段”……","date":"2006-04-03","objectID":"/anime/simoun/","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"简介 舞台设定在了地球以外的其他星球。人们把自己所在的星球称为“大空陆”。在那里，人类一出生就必须以“女性”的身份生活。等到17岁的时候到“泉”那里，选择性别而成为大人的时刻。 为了夺取主人公等所在的宫国所持有的珍贵引擎，邻国开始了日益激烈的侵略。为了迎击敌国，宫国被迫将仪式用复座式飞行艇“Simoun”改造成了战斗用战舰。还需要未性别化的“巫女”被派遣担任驾驶员，于是，她们成为了被称为“coru”的战斗小队成员。 操纵“Simoun”的少数少女被称为了“Simoun·シヴュラ（西贝拉）”因为拥有着特殊能力，她们可以选择自己成为大人的时间。但是因为战争的爆发，她们的优秀才能不得不运用在“Sim","date":"2006-04-03","objectID":"/anime/simoun/:1:0","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿艾尔 アーエル、Aaeru 女 新野美知 2 奈比利尔 Neviril、ネヴィリル、Neviriru 女 高橋理恵子 3 芭拉耶特 パライエッタ、Paraietta 女 小清水亜美 4 凯姆 カイム、Kaimu 女 細越みちこ 5 阿尔提 アルティ 女 豊口めぐみ 6 芙罗耶 Furoe、フロエ、Furoe 女 相澤みちる 7 罗德雷亚蒙 ロードレアモン 女 高橋美佳子 8 里莫奈 リモネ、Rimone 女 能登麻美子 ","date":"2006-04-03","objectID":"/anime/simoun/:2:0","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 西蒙 2006-04-03 26 下方 ","date":"2006-04-03","objectID":"/anime/simoun/:3:0","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"配乐 ","date":"2006-04-03","objectID":"/anime/simoun/:4:0","tags":null,"title":"西蒙","uri":"/anime/simoun/"},{"categories":null,"content":"　　“我毕业于东中，叫做凉宫春日。我对普通的人类没有兴趣。你们之中要是有外星人、未来人、异世界人或者超能力者的话，就尽管来找我吧。”这是凉宫春日的宣言，也是她对于平庸生活的挑战。\n　　我们可能在很小时就不再相信圣诞老人的存在，也慢慢不会再对外星人，特异功能等等产生幻想。在生活的教化下习惯于平淡无奇的生活。可是不安于现状的凉宫同学却勇敢的建立起SOS团，用强烈的意志去试图改造这个了无新意的世界。她的忧郁，究竟从何而来，又将从何而去。","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"简介 “我毕业于东中，叫做凉宫春日。我对普通的人类没有兴趣。你们之中要是有外星人、未来人、异世界人或者超能力者的话，就尽管来找我吧。”这是凉宫春日的宣言，也是她对于平庸生活的挑战。 我们可能在很小时就不再相信圣诞老人的存在，也慢慢不会再对外星人，特异功能等等产生幻想。在生活的教化下习惯于平淡无奇的生活。可是不安于现状的凉宫同学却勇敢的建立起SOS团，用强烈的意志去试图改造这个了无新意的世界。她的忧郁，究竟从何而来，又将从何而去。 制作人员： 原作：谷川流 导演：石原立也 脚本：贺东招二、志茂文彦、山本宽、村元克彦、伊藤敦 ","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/:1:0","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿虚 约翰・史密斯（ジョン・スミス）、キョン、Kyon 男 杉田智和 2 凉宫春日 すずみや はるひ、Suzumiya Haruhi、团长 女 平野綾 3 长门有希 长门大明神、長門 有希、ながと ゆき、Nagato Yuki 女 茅原実里 4 朝比奈实玖瑠 あさひな みくる、Asahina Mikuru 女 後藤邑子 5 古泉一树 こいずみ いつき、Koizumi Itsuki 男 小野大輔 6 让世界变得更热闹的凉宫春日的团 Spreading Excitement all Over the World with Haruhi Suzumiya Brig","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/:2:0","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 凉宫春日的忧郁 2006-04-02 14 bilibili 2 凉宫春日的忧郁 2009 2009-04-02 28 bilibili 3 凉宫春日的消失 2010-02-06 1 bilibili ","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/:3:0","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"MAD ","date":"2006-04-02","objectID":"/anime/suzumiya_haruhi/:4:0","tags":null,"title":"凉宫春日的忧郁","uri":"/anime/suzumiya_haruhi/"},{"categories":null,"content":"传说中，圣杯是能够实现拥有者愿望的宝物。 为了让这圣杯出现必须要进行一项仪式 被圣杯所选的七位魔术师MASTER 将被赐与圣杯所选出的七位使魔SERVANT 剑士“SABER” 枪兵“LANCER” 弓兵“ARCHER” 骑兵“RIDER” 魔术师“CASTER” 暗杀者“ASSASSIN” 狂战士“BERSERKER” 魔术师必须与这七种类的使魔其中一位订下契约并证明自己是最适合圣杯的人 换言之，魔术师必须消去其它的魔术师来证明自己是最强的 这样一整个求取圣杯的仪式被称为 “圣杯战争……","date":"2006-01-06","objectID":"/anime/fate_stay_night/","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"简介 传说中，圣杯是能够实现拥有者愿望的宝物。 为了让这圣杯出现必须要进行一项仪式 被圣杯所选的七位魔术师MASTER 将被赐与圣杯所选出的七位使魔SERVANT 剑士“SABER” 枪兵“LANCER” 弓兵“ARCHER” 骑兵“RIDER” 魔术师“CASTER” 暗杀者“ASSASSIN” 狂战士“BERSERKER” 魔术师必须与这七种类的使魔其中一位订下契约并证明自己是最适合圣杯的人 换言之，魔术师必须消去其它的魔术师来证明自己是最强的 这样一整个求取圣杯的仪式被称为 “圣杯战争…… 制作人员： 原作：奈须蘑菇、型月 导演：山口祐司 脚本：志茂文彦、佐藤卓哉、花田十辉、冈田麿里 分","date":"2006-01-06","objectID":"/anime/fate_stay_night/:1:0","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿尔托莉雅·潘德拉贡 Saber、呆毛王、吾王、青王、骑士王、棉被王、亚瑟王、蓝Saber、元祖Saber、Altria Pendragon、セイバー 女 川澄綾子 2 卫宫士郎 衛宮 士郎、えみや しろう、Emiya Shirou 男 野田順子 3 吉尔伽美什 Gilgamesh、金皮卡、金闪闪、金A、英雄王、AUO 男 関智一 4 卫宫 红茶，红A，阿茶，背影侠、英灵卫宫、Emiya、英霊エミヤ、Archer、Faker 男 諏訪部順一 5 美狄亚 Μήδεια、Medea、C妈 女 田中敦子 6 伊莉雅斯菲尔·冯·爱因兹贝伦 伊莉雅丝菲尔·冯·爱因兹贝","date":"2006-01-06","objectID":"/anime/fate_stay_night/:2:0","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 Fate/stay night 2006-01-06 24 bilibili 2 Fate/stay night UNLIMITED BLADE WORKS 2010-01-23 1 bilibili 3 Fate/stay night [Unlimited Blade Works] 2014-10-04 13 bilibili 4 Fate/stay night [Unlimited Blade Works] 第二季 2015-04-04 13 bilibili 5 剧场版 Fate/stay night [Heaven’s Feel] I.","date":"2006-01-06","objectID":"/anime/fate_stay_night/:3:0","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"MAD ","date":"2006-01-06","objectID":"/anime/fate_stay_night/:4:0","tags":null,"title":"Fate/stay night","uri":"/anime/fate_stay_night/"},{"categories":null,"content":"2005年12月14日开始出版《I''ss Pure》的系列动画，共6集。动画采取从一贵圣诞节时和伊织约会为开始，以追忆的方式描述了他在中学期间对伊织的追求故事。与漫画不同的是，漫画中的心理描写和比较暴露的情色情节都被忽略或者简化，并采用《一贵的妄想日记》的方式与主情节分开来描述主人公的性幻想部分。","date":"2005-11-01","objectID":"/anime/i_s_pure/","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"简介 2005年12月14日开始出版《I\"s Pure》的系列动画，共6集。动画采取从一贵圣诞节时和伊织约会为开始，以追忆的方式描述了他在中学期间对伊织的追求故事。与漫画不同的是，漫画中的心理描写和比较暴露的情色情节都被忽略或者简化，并采用《一贵的妄想日记》的方式与主情节分开来描述主人公的性幻想部分。 制作人员： 原作：桂正和 导演：神户守 脚本：大石哲也 分镜：小高义规、岩永彰 音乐：小西香叶 ","date":"2005-11-01","objectID":"/anime/i_s_pure/:1:0","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 濑户一贵 瀬戸 一貴、せと いちたか、Seto Ichitaka 男 野村勝人 2 苇月伊织 葦月 伊織、よしづき いおり、Yoshizuki Iori 女 伊藤静 3 矶崎泉 磯崎 泉、いそざき　いずみ、Isozaki Izumi 女 門脇舞以 4 秋叶季子 秋葉 いつき、あきば いつき、Akiba Itsuki 女 中世明日香 5 寺谷靖雅 寺谷 靖雅、てらたに やすまさ、Teratani Yasumasa 男 こぶしのぶゆき 6 森崎祐加 森崎 祐加、もりさき ゆうか 女 後藤邑子 7 奈美 女 鈴木菜穂子 ","date":"2005-11-01","objectID":"/anime/i_s_pure/:2:0","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 I\"s Pure 2005-11-01 6 樱花 ","date":"2005-11-01","objectID":"/anime/i_s_pure/:3:0","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"MAD ","date":"2005-11-01","objectID":"/anime/i_s_pure/:4:0","tags":null,"title":"I''s Pure","uri":"/anime/i_s_pure/"},{"categories":null,"content":"这里的虫既不是动植物，也与微生物和菌类不同，是更接近生命原生态的东西。这些东西总称为“虫”。它们的形态和存在都很暧昧，当人与虫的世界重叠之时，发生了超越人类智慧的怪异现象，此时人类才开始知道它们的存在。\n所谓生命，并非为威胁异己而存在。只是，各自以各自的形态存在着——作为连接这样的”虫“与人类的”虫师“--主人公银古，在旅途中不断与各种各样的人及与其关联的虫相遇。绘就了每话登场人物各不相同，读不尽的画卷。","date":"2005-10-22","objectID":"/anime/mushishi/","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"简介 这里的虫既不是动植物，也与微生物和菌类不同，是更接近生命原生态的东西。这些东西总称为“虫”。它们的形态和存在都很暧昧，当人与虫的世界重叠之时，发生了超越人类智慧的怪异现象，此时人类才开始知道它们的存在。 所谓生命，并非为威胁异己而存在。只是，各自以各自的形态存在着——作为连接这样的”虫“与人类的”虫师“–主人公银古，在旅途中不断与各种各样的人及与其关联的虫相遇。绘就了每话登场人物各不相同，读不尽的画卷。 制作人员： 原作：漆原友纪 导演：长滨博史 脚本：桑畑绢子、山田由香、伊丹秋 分镜：成田岁法、宫下新平、岛村秀一、长峰达也 ","date":"2005-10-22","objectID":"/anime/mushishi/:1:0","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 银古 ヨキ、Ginko 男 沢城みゆき 2 奴伊 ぬい、Nui 女 土井美加 3 化野 Adashino、化野 男 うえだゆうじ 4 廉子 れんず、Renzu 女 伊瀬茉莉也 5 五百藏森罗 五百蔵しんら、Ioroi Shinra 男 三瓶由布子 6 翠 スイ、Sui 女 岡明子 7 齐 ビキ、Biki 男 國分優香里 8 真火 真火、Maho 男 本城雄太郎 ","date":"2005-10-22","objectID":"/anime/mushishi/:2:0","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 虫师 2005-10-22 26 bilibili 2 虫师 特別篇 蚀日之翳 2014-01-04 1 樱花 3 虫师 续章 2014-04-04 11 樱花 4 虫师 续章 第2期 2014-10-18 10 樱花 5 虫师 特别篇 铃之雫 2015-05-16 1 bilibili ","date":"2005-10-22","objectID":"/anime/mushishi/:3:0","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"MAD ","date":"2005-10-22","objectID":"/anime/mushishi/:4:0","tags":null,"title":"虫师","uri":"/anime/mushishi/"},{"categories":null,"content":"本故事的时代背景在24世纪。彼时人类在火星上进行行星地球化改造工程，由于两极冰帽融解的水量超乎预期，全星球有90%被海洋覆盖，因而被人称呼为「水星」（AQUA）。在此星球上有个以过去被称为水都的威尼斯为范本所建造的城市新威尼斯（Neo-Venezia），因其仿古的建筑与承袭传统的生活方式而广受观光客喜爱，而其中有一种驾驶小舟穿梭于运河之间，带领观光客游览整座城市的职业，被称为领航员（Undine）。\n出身于地球的水无灯里，以成为能独当一面的领航员为目标而来到新威尼斯，目前在艾莉西亚和亚利亚社长的Aria Company中见习。身为半熟手的她，每天都持续练习操控贡多拉及观光导览。《水星领航员》便是在描写灯里以及她身旁的朋友在一年四季中的日常生活点滴。","date":"2005-10-05","objectID":"/anime/aria/","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"简介 本故事的时代背景在24世纪。彼时人类在火星上进行行星地球化改造工程，由于两极冰帽融解的水量超乎预期，全星球有90%被海洋覆盖，因而被人称呼为「水星」（AQUA）。在此星球上有个以过去被称为水都的威尼斯为范本所建造的城市新威尼斯（Neo-Venezia），因其仿古的建筑与承袭传统的生活方式而广受观光客喜爱，而其中有一种驾驶小舟穿梭于运河之间，带领观光客游览整座城市的职业，被称为领航员（Undine）。 出身于地球的水无灯里，以成为能独当一面的领航员为目标而来到新威尼斯，目前在艾莉西亚和亚利亚社长的Aria Company中见习。身为半熟手的她，每天都持续练习操控贡多拉及观光导览。《水星领航","date":"2005-10-05","objectID":"/anime/aria/:1:0","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 水无灯里 遥阔湛蓝（Aquamarine）、遙かなる蒼（アクアマリン）、Akari Mizunashi、みずなし あかり、Mizunashi Akari 女 葉月絵理乃 2 蓝华·S·葛兰基斯塔 蔷薇女王（Rozen Queen）、薔薇の女王（ローゼン・クイーン）、Aika S. Granzchesta、藍華・S・グランチェスタ、あいか えす グランチェスタ、Aika Esu Guranchesuta、划二代 女 斎藤千和 3 爱丽丝·凯洛尔 黄昏的公主（Orange Princess）、黄昏の姫君（オレンジ・プリンセス）、爱莉丝·卡罗尔、爱理须·凯洛尔、A","date":"2005-10-05","objectID":"/anime/aria/:2:0","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 水星领航员 2005-10-05 13 樱花 2 水星领航员 第二季 2006-04-02 26 樱花 3 水星领航员 OVA ～ARIETTA～ 2007-09-21 1 樱花 4 水星领航员 第三季 2008-01-07 14 樱花 5 水星领航员 The AVVENIRE 2015-09-26 3 樱花 6 水星领航员 The CREPUSCOLO 2021-03-05 1 樱花 7 水星领航员 The BENEDIZIONE 2021-12-03 1 樱花 ","date":"2005-10-05","objectID":"/anime/aria/:3:0","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"MAD ","date":"2005-10-05","objectID":"/anime/aria/:4:0","tags":null,"title":"水星领航员","uri":"/anime/aria/"},{"categories":null,"content":"　某一天在平凡的高中生坂井悠二的身旁，出现了一位名叫“炎发灼眼的追踪者”夏娜的少女，她告诉悠二，说他的生命马上就要结束了——原来在这个世界之外，还有另一个被称作“红世”的世界，那里的人们为了实现他们的野心，将人类身上的世界本源之力“存在之力”陆续夺走。悠二就受害者之一。红世之徒将“存在”夺走之后，为了缓和现实中产生的扭曲，还会留下“Torch（烛火）”作为代替。然后随着时间的推移，“Torch（烛火）”也终将从人们的记忆中淡去。修二的命运究竟会怎样呢？\n","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"简介 某一天在平凡的高中生坂井悠二的身旁，出现了一位名叫“炎发灼眼的追踪者”夏娜的少女，她告诉悠二，说他的生命马上就要结束了——原来在这个世界之外，还有另一个被称作“红世”的世界，那里的人们为了实现他们的野心，将人类身上的世界本源之力“存在之力”陆续夺走。悠二就受害者之一。红世之徒将“存在”夺走之后，为了缓和现实中产生的扭曲，还会留下“Torch（烛火）”作为代替。然后随着时间的推移，“Torch（烛火）”也终将从人们的记忆中淡去。修二的命运究竟会怎样呢？ 制作人员： 原作：高桥弥七郎 导演：渡部高志 脚本：白根秀树、小林靖子、佐藤胜一 分镜：橘秀树、池端隆史、中村宪由、福田道生 ","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/:1:0","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 夏娜 炎发灼眼的杀手、Shana、シャナ、syana、钉宫四萌 女 釘宮理恵 2 坂井悠二 坂井 悠二、Sakai Yuuji 男 日野聡 3 吉田一美 吉田 一美、Yoshida Kazumi 女 川澄綾子 4 玛琼琳·朵 Margery Daw 女 生天目仁美 5 威尔艾米娜·卡梅尔 ヴィルヘルミナ・カルメル、Wilhelmina Carmel 女 伊藤静 6 亚拉斯特尔 Flame-Haired Burning-Eyed Hunter、えんぱつしゃくがんのうちて、Enpatsu Shakugan no Uchite ？ 江原正士 7 池速人 池 人、I","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/:2:0","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 灼眼的夏娜 2005-10-05 24 bilibili 2 灼眼的夏娜 恋爱和温泉校外学习 2006-12-08 1 bilibili 3 灼眼的夏娜 剧场版 2007-04-21 1 bilibili 4 灼眼的夏娜 第二季 2007-10-04 24 bilibili 5 灼眼的夏娜S 2009-10-23 4 bilibili 6 灼眼的夏娜 Final 2011-10-07 24 bilibili 7 灼眼的夏娜炭 2006-01-25 15 bilibili ","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/:3:0","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"MAD ","date":"2005-10-05","objectID":"/anime/shakugan_no_shana/:4:0","tags":null,"title":"灼眼的夏娜","uri":"/anime/shakugan_no_shana/"},{"categories":null,"content":"兰顿·萨斯顿（Renton Thurston）是一名看似普通的十四岁少年，他的父亲（阿德洛克·萨斯顿）是一名军队的研究人员，在第一次“爱之夏”之中牺牲自己拯救了地球而被世人称为英雄。然而兰顿对自己和作为机械工程师的祖父相依为命的生活现状却十分不满，流行的运动“滑空”（Lifting）成了他打发时间的唯一爱好。他最大的梦想是有一天能够加入传奇滑空天才霍兰德（Holland）的组织“月光洲”（Gekkostate），成为和他一样出色的滑空选手。可是他的祖父（阿克赛尔．萨斯顿）却希望他成为一名出色的机械工程师，继承家业。\n\n兰顿无聊的生活终于在某一天发生了改变，一架故障的神秘LFO 尼尔瓦修 零式（Nirvash TypeZERO）突然冲进了他祖父的仓库，LFO的驾驶员是一名叫做优莱卡（Eureka）的少女，她请求兰顿的祖父对她的LFO进行修理。兰顿对优莱卡一见钟情，而在与赶来追击的军部武装战斗的过程中，他惊人的表现击退了敌人，更让他得到了加入月光洲的机会。然而在进入月光号之后，他才发现舰船上的真实生活与他在 Ray=Out 杂志上所看到的光辉灿烂的一面完全不同，自己不但很难适应这种艰苦而危险的生活和战斗，更难以得到船上其他成员的认同。但是他想要保护和了解自己所爱慕的优莱卡的心却没有因此而动摇。\n\n交响诗篇的故事就围绕兰顿和优莱卡关系的发展而展开了，随着时间的推移，兰顿的心理和能力都得到了极大的成长，对船上各个成员的不为人知的往事都开始有了逐渐的了解，为了保护自己心爱的人和这个星球，他和敌人展开了一次又一次的战斗；而这颗星球的秘密，也在他眼前逐渐地展开……\n\n","date":"2005-04-17","objectID":"/anime/eureka_seven/","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"简介 兰顿·萨斯顿（Renton Thurston）是一名看似普通的十四岁少年，他的父亲（阿德洛克·萨斯顿）是一名军队的研究人员，在第一次“爱之夏”之中牺牲自己拯救了地球而被世人称为英雄。然而兰顿对自己和作为机械工程师的祖父相依为命的生活现状却十分不满，流行的运动“滑空”（Lifting）成了他打发时间的唯一爱好。他最大的梦想是有一天能够加入传奇滑空天才霍兰德（Holland）的组织“月光洲”（Gekkostate），成为和他一样出色的滑空选手。可是他的祖父（阿克赛尔．萨斯顿）却希望他成为一名出色的机械工程师，继承家业。 兰顿无聊的生活终于在某一天发生了改变，一架故障的神秘LFO 尼尔瓦修 零","date":"2005-04-17","objectID":"/anime/eureka_seven/:1:0","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 兰顿·萨斯顿 顿爷、レントン・サーストン、Renton Thurston 男 三瓶由布子 2 优莱卡 エウレカ・サーストン、艾蕾卡、Eureka 女 名塚佳織 3 安妮莫奈 石井・風花・アネモネ、石井·风花·安妮莫奈、アネモネ、Anemone 女 小清水亜美 4 塔荷 タルホ・ノヴァク、タルホ・ユーキ、Talho Yuuki 女 根谷美智子 5 霍兰德·诺瓦克 ホランド・ノヴァク、Holland Novak 男 藤原啓治 6 杜伊·诺瓦克 デューイ・ノヴァク、Dewey Novak 男 辻谷耕史 7 多米尼克·索莱尔 Dominic Sorel 男 山崎樹範","date":"2005-04-17","objectID":"/anime/eureka_seven/:2:0","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 交响诗篇 2005-04-17 50 bilibili ","date":"2005-04-17","objectID":"/anime/eureka_seven/:3:0","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"MAD ","date":"2005-04-17","objectID":"/anime/eureka_seven/:4:0","tags":null,"title":"交响诗篇","uri":"/anime/eureka_seven/"},{"categories":null,"content":"庆长19年，73岁高龄的德川家康为了第三代将军继承人人选的问题而烦恼。是愚笨的哥哥竹千代，还是天资聪慧的弟弟国千代。在这乱世里第三代将军的继承问题落到了两大忍术宗家——甲贺流和伊贺流的身上。家康决定由两家各派出10名最优秀的忍者，进行一场生死大对决，两派之中幸存下来的一方将得到千年的荣禄，并由其支持的一方继承人继承将军的名号。 \n甲贺首领甲贺弹正和伊贺首领阿幻，在家康的默许下亲手撕毁了两派在前代服部半藏调停下签订的“不战条约”。两派瞬间走向一场死斗。同时弹正的孙子弦之介，和阿幻的孙女胧，不得不放下婚约，为杀死自己的爱人而战……","date":"2005-04-12","objectID":"/anime/basilisk/","tags":null,"title":"甲贺忍法帖","uri":"/anime/basilisk/"},{"categories":null,"content":"简介 庆长19年，73岁高龄的德川家康为了第三代将军继承人人选的问题而烦恼。是愚笨的哥哥竹千代，还是天资聪慧的弟弟国千代。在这乱世里第三代将军的继承问题落到了两大忍术宗家——甲贺流和伊贺流的身上。家康决定由两家各派出10名最优秀的忍者，进行一场生死大对决，两派之中幸存下来的一方将得到千年的荣禄，并由其支持的一方继承人继承将军的名号。 甲贺首领甲贺弹正和伊贺首领阿幻，在家康的默许下亲手撕毁了两派在前代服部半藏调停下签订的“不战条约”。两派瞬间走向一场死斗。同时弹正的孙子弦之介，和阿幻的孙女胧，不得不放下婚约，为杀死自己的爱人而战…… 制作人员： 原作：山田风太郎 导演：木崎文智 脚本：冈田麿里、","date":"2005-04-12","objectID":"/anime/basilisk/:1:0","tags":null,"title":"甲贺忍法帖","uri":"/anime/basilisk/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 甲賀弦之介 甲賀弦之介、Kouga Gennosuke 男 鳥海浩輔 2 朧 朧、Oboro 女 水樹奈々 3 陽炎 陽炎、Kagerou 女 早水リサ 4 室賀豹馬 室賀豹馬、Muroga Hyouma 男 宮林康 5 霞刑部 霞刑部、Kasumi Gyoubu 男 北川勝博 6 地虫十兵衛 地虫十兵衛、Jimushi Juubee 男 伊丸岡篤 7 甲賀弾正 甲賀弾正、Kouga Danjou 男 小林清志 8 筑摩小四郎 筑摩小四郎、Chikuma Koshirou 男 羽多野渉 ","date":"2005-04-12","objectID":"/anime/basilisk/:2:0","tags":null,"title":"甲贺忍法帖","uri":"/anime/basilisk/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 甲贺忍法帖 2005-04-12 24 樱花 ","date":"2005-04-12","objectID":"/anime/basilisk/:3:0","tags":null,"title":"甲贺忍法帖","uri":"/anime/basilisk/"},{"categories":null,"content":"“二子魂川”小镇的居民大多是双胞胎。在二子魂川经营侦探事务所的双叶恋太郎，与两个性格截然不同的双胞胎助手，白钟沙罗和白钟双树，展开令人羡慕的三人恋爱生活。\n\n作品的中文名字容易让人理解为《双恋》的第二季作品，但实际上是另一部重新设定的作品。故事以白钟姊妹作女主角，而在前作中出场的其他双胞胎全部作为配角。作品获得第9回日本文化厅媒体艺术祭审查委员会推荐作品。作品中除第一话外，未有出现片头中女角手持武器的场面。而本作的DVD版与电视播放时的顺序有少许不同。","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"简介 “二子魂川”小镇的居民大多是双胞胎。在二子魂川经营侦探事务所的双叶恋太郎，与两个性格截然不同的双胞胎助手，白钟沙罗和白钟双树，展开令人羡慕的三人恋爱生活。 作品的中文名字容易让人理解为《双恋》的第二季作品，但实际上是另一部重新设定的作品。故事以白钟姊妹作女主角，而在前作中出场的其他双胞胎全部作为配角。作品获得第9回日本文化厅媒体艺术祭审查委员会推荐作品。作品中除第一话外，未有出现片头中女角手持武器的场面。而本作的DVD版与电视播放时的顺序有少许不同。 制作人员： 原作：双叶雏、佐佐木睦美 脚本：近藤光、寺东克己、金月龙之介、佐藤和治 分镜：野中卓也 ","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/:1:0","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 白钟沙罗 しろがね さら、Shirogane Sara 女 水橋かおり 2 白钟双树 しろがね そうじゅ、Shirogane Souju 女 門脇舞以 3 双叶恋太郎 ふたば れんたろう、Futaba Rentarou 男 関智一 4 一条薰子 いちじょう かおるこ、Ichijou Kaoruko 女 堀江由衣 5 一条堇子 いちじょう すみれこ、Ichijo Sumireko 女 小清水亜美 6 樱月绮罗 桜月キラ、さくらづき キラ、Sakurazuki Kira 女 伊月ゆい 7 樱月由罗 さくらづき ユラ、Sakurazuki Yura 女 綱掛裕美 ","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/:2:0","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 双恋 Alternative 2005-04-06 13 bilibili ","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/:3:0","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"MAD ","date":"2005-04-06","objectID":"/anime/futakoi_alternatvie/:4:0","tags":null,"title":"双恋 Alternative","uri":"/anime/futakoi_alternatvie/"},{"categories":null,"content":"我的孩子，仔细听好\n接下来我说的，是一件非常重要的事\n已经忘了从何时开始\n由上代讲给下代，代代传下来的故事\n一个关于长久的旅程的故事……\n\n夏天，在靠近海边小小的街道上\n一位青年从公共汽车站下车了\n青年一直在旅行中\n这样的小镇他无心久留\n在赚足了路费后，他会去那些更繁华的地方\n他的旅伴，是母亲留给他的小小的人偶\n他不用手接触，人偶就能动起来\n从母亲那里继承了这种魔法\n靠着表演人偶维生，他的旅途才一直能继续着\n青年给孩子们表演着人偶戏\n然而，简陋的人偶无法吸引孩子们\n没有得到报酬的他\n无力地站在夏天的烈日下\n迷迷糊糊地睡着了……\n就在这条海边的街上，青年和命运中的少女相遇了…… ","date":"2005-01-06","objectID":"/anime/air/","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"简介 我的孩子，仔细听好 接下来我说的，是一件非常重要的事 已经忘了从何时开始 由上代讲给下代，代代传下来的故事 一个关于长久的旅程的故事…… 夏天，在靠近海边小小的街道上 一位青年从公共汽车站下车了 青年一直在旅行中 这样的小镇他无心久留 在赚足了路费后，他会去那些更繁华的地方 他的旅伴，是母亲留给他的小小的人偶 他不用手接触，人偶就能动起来 从母亲那里继承了这种魔法 靠着表演人偶维生，他的旅途才一直能继续着 青年给孩子们表演着人偶戏 然而，简陋的人偶无法吸引孩子们 没有得到报酬的他 无力地站在夏天的烈日下 迷迷糊糊地睡着了…… 就在这条海边的街上，青年和命运中的少女相遇了…… 制作人员： ","date":"2005-01-06","objectID":"/anime/air/:1:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 国崎往人 くにさき ゆきと、Kunisaki Yukito 男 小野大輔 2 神尾观铃 かみお みすず、Kamio Misuzu 女 川上とも子 3 雾岛佳乃 きりしま かの、Kirishima Kano 女 岡本麻見 4 远野美凪 とおの みなぎ、Tohno Minagi 女 柚木涼香 5 神奈备命 かんなびのみこと、Kannabi no Mikoto 女 西村ちなみ 6 神尾晴子 かみお はるこ、Kamio Haruko 女 久川綾 7 雾岛圣 霧島 聖、きりしま ひじり、Kirishima Hijiri 女 冬馬由美 8 小满 みちる、Michiru ","date":"2005-01-06","objectID":"/anime/air/:2:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 AIR 2005-01-06 13 下方 01-13 2 AIR 夏季篇 2005-08-28 2 下方 14-15 3 AIR 剧场版 2005-02-05 1 bilibili ","date":"2005-01-06","objectID":"/anime/air/:3:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"配乐 ","date":"2005-01-06","objectID":"/anime/air/:4:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"MAD ","date":"2005-01-06","objectID":"/anime/air/:5:0","tags":null,"title":"AIR","uri":"/anime/air/"},{"categories":null,"content":"故事背景设定在以现实世界为基础所衍生的架空世界，叙述日本在津轻海峡另一侧的北海道遭到占领，形成南北两侧对立的舞台。\n\n1945年，苏联背弃日苏中立条约，于十月攻占北海道。日本恢复主权后，北海道也被改名为“虾夷”，归入苏联的体制之下。1965年赫鲁雪夫在第二十届共产党大会上宣布统合苏联、东欧与西亚所有共产主义国家的统一政体“联邦国”诞生。 1960年代后半，虾夷内部民族主义运动高涨，为了因应这个情势，联邦国于1975年与日本断交，使日本南北分裂情势延续至今。\n\n联邦国在虾夷上建造有着高度直达云端、被称为“联邦国巨塔”的神秘建筑物，该神秘巨塔因此造成美国与联邦国的军事冲突点。","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"简介 故事背景设定在以现实世界为基础所衍生的架空世界，叙述日本在津轻海峡另一侧的北海道遭到占领，形成南北两侧对立的舞台。 1945年，苏联背弃日苏中立条约，于十月攻占北海道。日本恢复主权后，北海道也被改名为“虾夷”，归入苏联的体制之下。1965年赫鲁雪夫在第二十届共产党大会上宣布统合苏联、东欧与西亚所有共产主义国家的统一政体“联邦国”诞生。 1960年代后半，虾夷内部民族主义运动高涨，为了因应这个情势，联邦国于1975年与日本断交，使日本南北分裂情势延续至今。 联邦国在虾夷上建造有着高度直达云端、被称为“联邦国巨塔”的神秘建筑物，该神秘巨塔因此造成美国与联邦国的军事冲突点。 制作人员： 原作：","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/:1:0","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤泽浩纪 藤沢浩紀、ふじさわ　ひろき、Fujisawa Hiroki 男 吉岡秀隆 2 泽渡佐由理 沢渡佐由理、さわたり　さゆり、Sayuri Sawatari 女 南里侑香 3 白川拓也 しらかわ　たくや、Takuya Shirakawa 男 萩原聖人 4 水野理佳 みずの りか 女 中川里江 5 笠原真希 かさはら まき 女 水野理紗 6 冈部 おかべ 男 石塚運昇 7 富泽常夫 とみさわ つねお 男 井上和彦 ","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/:2:0","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 云之彼端，约定的地方 2004-11-20 01:30:21 bilibili ","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/:3:0","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"MAD ","date":"2004-11-20","objectID":"/anime/the_place_promised_in_our_early_days/:4:0","tags":null,"title":"云之彼端，约定的地方","uri":"/anime/the_place_promised_in_our_early_days/"},{"categories":null,"content":"主角高町奈叶是个平凡的小学三年级女生，与好友在如同日常作息的前往补习途中，发现了从异世界米德其路达（又译米德芝尔达）来的雪貂尤诺·斯克莱亚。他利用心灵感应告诉奈叶，他来到这个世界的理由是为了回收他所挖掘到的太古遗产（平行次元中的高度文明的遗产）“宝石种子”。奈叶为了保护可能因为宝石种子暴走被破坏的城镇，决定代替尤诺出面回收。不料，这却只是一连串事件的开端。他们遇见，与他们一样目的，因为回收宝石种子而出现的谜样金发少女魔导师到底是……\n\n","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"简介 主角高町奈叶是个平凡的小学三年级女生，与好友在如同日常作息的前往补习途中，发现了从异世界米德其路达（又译米德芝尔达）来的雪貂尤诺·斯克莱亚。他利用心灵感应告诉奈叶，他来到这个世界的理由是为了回收他所挖掘到的太古遗产（平行次元中的高度文明的遗产）“宝石种子”。奈叶为了保护可能因为宝石种子暴走被破坏的城镇，决定代替尤诺出面回收。不料，这却只是一连串事件的开端。他们遇见，与他们一样目的，因为回收宝石种子而出现的谜样金发少女魔导师到底是…… 制作人员： 原作：ivory、都筑真纪 导演：新房昭之 分镜：田所修、阿部雅司、小寺胜之 演出：齐藤良成、秋田谷典昭 ","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/:1:0","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 高町奈叶 管理局の白い悪魔、白色恶魔、高町奈葉、Nanoha Takamachi、高町なのは、たかまち なのは、Takamachi Nanoha、暴君 女 田村ゆかり 2 菲特·泰斯特罗莎 菲特·泰斯特罗莎·哈拉温、菲特·泰斯塔罗莎·哈拉温、フェイト・テスタロッサ・ハラオウン、Fate T. Harlaown、菲特·T·哈拉温、Fate Testarossa Harlaown、フェイト・T・テスタロッサ、Feito Tesutarossa Haraoun、菲特、宠妃 女 水樹奈々 3 尤诺·斯克莱亚 ユーノ・スクライア、Yuuno Scrya 男 水橋かおり","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/:2:0","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 魔法少女奈叶 2004-10-01 13 bilibili 2 魔法少女奈叶A’s 2005-10-01 13 bilibili 3 魔法少女奈叶StrikerS 2007-04-01 26 bilibili 4 魔法少女奈叶ViVid 2015-04-03 12 bilibili 5 ViVid Strike! 2016-10-01 12 bilibili 6 魔法少女奈叶 The MOVIE 1st 2010-01-23 1 bilibili 7 魔法少女奈叶 The MOVIE 2nd A’s 2012-07-14 1 bilibili ","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/:3:0","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"MAD ","date":"2004-10-01","objectID":"/anime/mahou_shoujo_lyrical_nanoha/:4:0","tags":null,"title":"魔法少女奈叶","uri":"/anime/mahou_shoujo_lyrical_nanoha/"},{"categories":null,"content":"露西生来就与常人有异，她头上长着两个犄角，生有四只隐形的手，体内蕴藏着巨大的力量，人们管她这样的孩子叫作异种人。从小就被人抛弃排挤的露西一直非常孤独，直到她遇到浩太才渡过了非常愉快的几天。然而随着体内载体的呼唤，她渐渐还是显露出杀人魔的本性，并被研究所拘捕监禁。\n八年后，露西从研究所里逃出来，却由于脑部重创失忆，成为“白痴少女”。此时的浩太也由于儿时的重大打击选择性失忆，两人再次相遇，浩太把露西当作陌生人收留下来。穿插着两人断断续续的回忆，故事渐渐走向了两个极端。","date":"2004-07-25","objectID":"/anime/elfen_lied/","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"简介 露西生来就与常人有异，她头上长着两个犄角，生有四只隐形的手，体内蕴藏着巨大的力量，人们管她这样的孩子叫作异种人。从小就被人抛弃排挤的露西一直非常孤独，直到她遇到浩太才渡过了非常愉快的几天。然而随着体内载体的呼唤，她渐渐还是显露出杀人魔的本性，并被研究所拘捕监禁。 八年后，露西从研究所里逃出来，却由于脑部重创失忆，成为“白痴少女”。此时的浩太也由于儿时的重大打击选择性失忆，两人再次相遇，浩太把露西当作陌生人收留下来。穿插着两人断断续续的回忆，故事渐渐走向了两个极端。 制作人员： 原作：冈本伦 导演：神户守 脚本：吉冈孝夫 分镜：渡边纯央、阿部达也、岩永彰、佐土原武之 ","date":"2004-07-25","objectID":"/anime/elfen_lied/:1:0","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 耕太 耕太、Kouta 男 鈴木千尋 2 露西 にゅう、妮悠、Lucy 女 小林沙苗 3 由香 Yuka 女 能登麻美子 4 真由 マユ、mayu 女 萩原えみこ 5 娜娜 ナナ、Nana 女 松岡由貴 6 白河 白川、しらかわ、Shirakawa 女 生天目仁美 7 真理子 マリコ、Mariko 女 川上とも子 8 香苗 カナエ、Kanae 女 山本麻里安 ","date":"2004-07-25","objectID":"/anime/elfen_lied/:2:0","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 妖精的旋律 2004-07-25 14 樱花 ","date":"2004-07-25","objectID":"/anime/elfen_lied/:3:0","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"MAD ","date":"2004-07-25","objectID":"/anime/elfen_lied/:4:0","tags":null,"title":"妖精的旋律","uri":"/anime/elfen_lied/"},{"categories":null,"content":"游戏故事发生在利贝尔王国，玩家扮演隶属于民间机构——游击士协会的新人游击士艾丝蒂尔·布莱特和约修亚·布莱特。\n两位游击士新人为了磨练自我而踏上旅程，却在不经意间卷入震撼全王国乃至全大陆的重大事件之中。","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"简介 游戏故事发生在利贝尔王国，玩家扮演隶属于民间机构——游击士协会的新人游击士艾丝蒂尔·布莱特和约修亚·布莱特。 两位游击士新人为了磨练自我而踏上旅程，却在不经意间卷入震撼全王国乃至全大陆的重大事件之中。 制作人员： 开发：日本Falcom 发行：北京娱乐通科技发展有限公司 剧本：竹入久喜、近藤季洋 音乐：石桥渡、神藤由東大、Falcom Sound Team jdk、村山貴英 ","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/:1:0","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 艾丝蒂尔·布莱特 Estelle Bright 女 神田朱未 2 约修亚·布莱特 漆黑之牙、约修亚·阿斯特雷、Joshua Bright、ヨシュア・アストレイ、小约 男 斎賀みつき 3 亚妮拉丝·艾尔菲德 Anelace Elfead、萌主 女 大河内雅子 4 雪拉扎德·哈维 雪拉扎德·莱泽·亚诺尔、Scherazard Harvey 女 塩山由佳 5 奥利维特·莱泽·亚诺尔 奥利维尔·朗海姆、Olivier Lenheim、オリビエ・レンハイム、Olivert Reise Arnor 男 子安武人 6 提妲·拉赛尔 Tita Russell 女 今野宏美 ","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/:2:0","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"系列 系列名 发行时间 1 英雄传说6：空之轨迹FC 2004-06-24 2 英雄传说6：空之轨迹SC 2006-03-09 3 英雄传说6：空之轨迹 the 3rd 2007-06-28 4 英雄传说：零之轨迹 2010-09-30 5 英雄传说：碧之轨迹 2011-09-29 6 英雄传说 闪之轨迹 2013-09-26 7 英雄传说 闪之轨迹2 2014-09-25 8 英雄传说 闪之轨迹3 2017-09-28 9 英雄传说 闪之轨迹4 -THE END OF SAGA- 2018-09-27 10 英雄传说 创之轨迹 2020-08-27 11 英雄传说 黎之轨迹 2021-09-","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/:3:0","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"MAD ","date":"2004-06-24","objectID":"/game/the_legend_of_heroes/:4:0","tags":null,"title":"轨迹系列","uri":"/game/the_legend_of_heroes/"},{"categories":null,"content":"著名的設計師鷺月子在一天夜裏突然遭到神秘少年襲擊。在此之後接連出現新的受害者，城中一度陷入恐慌。事件的真相究竟是……","date":"2004-02-02","objectID":"/anime/paranoia_agent/","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"简介 著名的設計師鷺月子在一天夜裏突然遭到神秘少年襲擊。在此之後接連出現新的受害者，城中一度陷入恐慌。事件的真相究竟是…… 制作人员： 原作：今敏 脚本：水上清资、吉野智美 分镜：岛崎奈奈子、三原三千夫、林重行、滨崎博嗣 ","date":"2004-02-02","objectID":"/anime/paranoia_agent/:1:0","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 鹭月子 鷺 月子、さぎ つきこ 女 能登麻美子 2 麻洛美 桃井はるこ 3 猪狩庆一 いかり けいいち 男 飯塚昭三 4 马庭光弘 馬庭 光弘、まにわ みつひろ 男 関俊彦 5 川津明雄 Kawazu Akio 男 内海賢二 6 鯛良优一 Taira Yuuichi 男 山口眞弓 7 蛭川雅美 ひるかわ まさみ、Hirukawa Masami 男 中嶋聡彦 8 牛山尚吾 Ushiyama Shougo 男 津村まこと ","date":"2004-02-02","objectID":"/anime/paranoia_agent/:2:0","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 妄想代理人 2004-02-02 13 樱花 ","date":"2004-02-02","objectID":"/anime/paranoia_agent/:3:0","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"MAD ","date":"2004-02-02","objectID":"/anime/paranoia_agent/:4:0","tags":null,"title":"妄想代理人","uri":"/anime/paranoia_agent/"},{"categories":null,"content":"《Fate/stay night》是TYPE-MOON开发并最早于2004年1月30日在PC平台上发售的文字冒险游戏，也是TYPE-MOON公司商业化后初次亮相的作品，是Fate的系列作品之一。","date":"2004-01-30","objectID":"/game/fate_stay_night/","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"简介 《Fate/stay night》是TYPE-MOON开发并最早于2004年1月30日在PC平台上发售的文字冒险游戏，也是TYPE-MOON公司商业化后初次亮相的作品，是Fate的系列作品之一。 制作人员： 开发：型月 发行：Notes. 剧本：奈须蘑菇 音乐：芳贺敬太、永田大祐、石川敏 主题歌作曲：NUMBER 201 主题歌演出：M.H. 原画：武内崇 ","date":"2004-01-30","objectID":"/game/fate_stay_night/:1:0","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 卫宫士郎 衛宮 士郎、えみや しろう、Emiya Shirou 男 野田順子 2 阿尔托莉雅·潘德拉贡 Saber、呆毛王、吾王、青王、骑士王、棉被王、亚瑟王、蓝Saber、元祖Saber、Altria Pendragon、セイバー 女 川澄綾子 3 远坂凛 Rin Tohsaka、遠坂 凛、とおさか りん、Tohsaka Rin 女 植田佳奈 4 间桐樱 まとうさくら、Matou Sakura 女 下屋則子 5 伊莉雅斯菲尔·冯·爱因兹贝伦 伊莉雅丝菲尔·冯·爱因兹贝伦、伊莉亚丝菲尔·冯·艾因兹贝伦、依莉雅苏菲尔·冯·爱因兹贝伦、伊莉雅、Illyasvie","date":"2004-01-30","objectID":"/game/fate_stay_night/:2:0","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"系列 系列名 发行时间 1 Fate/stay night 2004-01-30 ","date":"2004-01-30","objectID":"/game/fate_stay_night/:3:0","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"配乐 ","date":"2004-01-30","objectID":"/game/fate_stay_night/:4:0","tags":null,"title":"Fate/stay night","uri":"/game/fate_stay_night/"},{"categories":null,"content":"　　爱德华德和他的弟弟阿尔芬斯十分思念在他们还小的时候亡故的母亲，实行了炼金术中最大的禁忌——可以将死者复活的人体炼成。 可是炼成失败，爱德华德失去了左腿，阿尔芬斯则失去了全身。爱德华德好不容易才以牺牲自己的右臂为代价将弟弟的灵魂炼成，并定着在一副铠甲上，可是其代价未免太大了。爱德华德和阿尔芬斯一起，为了找回所失去的一切，开始踏上了寻找拥有极大力量的“贤者之石”的旅程。 \n　　 \n　　右臂和左腿用钢制义肢“机械铠”来替代的他，被人们称为“钢之炼金术师”…","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"简介 爱德华德和他的弟弟阿尔芬斯十分思念在他们还小的时候亡故的母亲，实行了炼金术中最大的禁忌——可以将死者复活的人体炼成。 可是炼成失败，爱德华德失去了左腿，阿尔芬斯则失去了全身。爱德华德好不容易才以牺牲自己的右臂为代价将弟弟的灵魂炼成，并定着在一副铠甲上，可是其代价未免太大了。爱德华德和阿尔芬斯一起，为了找回所失去的一切，开始踏上了寻找拥有极大力量的“贤者之石”的旅程。 右臂和左腿用钢制义肢“机械铠”来替代的他，被人们称为“钢之炼金术师”… 制作人员： 原作：荒川弘 导演：水岛精二 脚本：高桥奈津子、吉永亚矢、会川升、大和屋晓、石川学、高山克彦、井上敏树 ","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/:1:0","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 爱德华·艾尔利克 Edward Elric、爱德 男 朴璐美 2 阿尔芬斯·艾尔利克 Alphonse Elric 男 釘宮理恵 3 温莉·洛克贝尔 Winry Rockbell 女 豊口めぐみ 4 キャスリン・エル・アームストロング Catherine Elle Armstrong 女 釘宮理恵 5 冯·霍恩海姆 ホーエンハイム・エルリック、班·賀恩漢、Van Hohenheim 男 江原正士 6 特蕾莎·艾尔利克 朵莉夏·爱力克、トリシャ・エルリック、Trisha Elric 女 鷹森淑乃 7 皮纳可·洛克贝尔 比拿可·洛克贝尔、ピナコ・ロックベル、Pi","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/:2:0","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 钢之炼金术师 2003-10-04 51 樱花 2 钢之炼金术师 香巴拉的征服者 2005-07-23 1 樱花 3 钢之炼金术师 FULLMETAL ALCHEMIST 2009-04-05 64 樱花 4 钢之炼金术师 叹息之丘的圣星 2011-07-02 1 樱花 ","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/:3:0","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"MAD ","date":"2003-10-04","objectID":"/anime/fullmetal_alchemist/:4:0","tags":null,"title":"钢之炼金术师","uri":"/anime/fullmetal_alchemist/"},{"categories":null,"content":"从很小的时候起，苗木野空就对卡莱多剧团的表演充满了憧憬之情。如今，已经长大的她终于有能力开始追逐自己的梦想了，信心满满的空踏上了前往美国的旅途，她发誓要成为剧团的一份子，给更多的孩子带去欢乐。可惜事与愿违，刚刚踏上美国的土地，空就迷失了方向，在经历了一系列波折之后，迷糊的她居然错过了剧团的选拔考试。\n就算无法成为剧团的一份子，也要亲眼看一看他们的表演。怀着这样的信念，空来到了剧团的后台，却在无意之中弄伤了马上就要上场表演的巨星蕾拉。无奈之下，经理只得让空代替蕾拉上台演出，没想到，初来乍到的空居然赢得了广大观众的喜爱。就这样，空被破格录取了，她在卡莱多剧团的表演生涯正式拉开了帷幕。面对强劲的竞争对手，空能够脱颖而出吗？","date":"2003-04-03","objectID":"/anime/kaleido_star/","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"简介 从很小的时候起，苗木野空就对卡莱多剧团的表演充满了憧憬之情。如今，已经长大的她终于有能力开始追逐自己的梦想了，信心满满的空踏上了前往美国的旅途，她发誓要成为剧团的一份子，给更多的孩子带去欢乐。可惜事与愿违，刚刚踏上美国的土地，空就迷失了方向，在经历了一系列波折之后，迷糊的她居然错过了剧团的选拔考试。 就算无法成为剧团的一份子，也要亲眼看一看他们的表演。怀着这样的信念，空来到了剧团的后台，却在无意之中弄伤了马上就要上场表演的巨星蕾拉。无奈之下，经理只得让空代替蕾拉上台演出，没想到，初来乍到的空居然赢得了广大观众的喜爱。就这样，空被破格录取了，她在卡莱多剧团的表演生涯正式拉开了帷幕。面对强劲","date":"2003-04-03","objectID":"/anime/kaleido_star/:1:0","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 苗木野空 苗木野そら、Naegino Sora、Наэгино Сора 女 広橋涼 2 蕾拉·汉密尔顿 レイラ・ハミルトン、Layla Hamilton 女 大原さやか 3 罗赛塔·帕赛尔 Rosetta Passel、ロゼッタ・パッセル 女 水橋かおり 4 王梅 メイ・ウォン 女 中原麻衣 5 莱昂·渥兹伍尔 Leon Oswald、レオン・オズワルド 男 櫻井孝宏 6 米娅·盖伦 Mia Guillem 女 西村ちなみ 7 安娜·哈特 アンナ・ハート 女 渡辺明乃 8 玛莉恩 マリオン 女 折笠富美子 ","date":"2003-04-03","objectID":"/anime/kaleido_star/:2:0","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 百变之星 2003-04-03 51 bilibili 2 百变之星 崭新之翼 EXTRA STAGE 不笑的公主 2004-10-22 1 bilibili 3 百变之星 不死鸟传说 ～蕾拉・汉密尔顿物语～ 2006-01-27 1 bilibili 4 百变之星 妙啊！妙！ 2006-09-27 1 bilibili ","date":"2003-04-03","objectID":"/anime/kaleido_star/:3:0","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"MAD ","date":"2003-04-03","objectID":"/anime/kaleido_star/:4:0","tags":null,"title":"百变之星","uri":"/anime/kaleido_star/"},{"categories":null,"content":"    在火影忍者正式故事展开的12年前，一只被称为九尾 妖狐的妖怪袭击木叶忍者村，传说它一挥动尾巴就会山崩海啸。当时的第四代火影“木叶黄色闪光”波风皆人牺牲自己的性命，把九尾封印在刚出生的孩子 漩涡鸣人身上。\n“第四代火影”被村里的人认为是英雄，但他更希望村里的人同样地将鸣人当作英雄看待。但村民认为鸣人就是妖狐的化身，而不是作为封印妖狐的幕后功臣，因此为鸣人自小就被人歧视。\n重新复出的“第三代火影”已经禁止村民和后代提到这次的九尾突袭事件，但是仍不能阻止人们排挤鸣人。就连他们不知情的后代，在父母的感染下，亦疏远鸣人。因此，鸣人从小倍受孤立。为了引起其他人注意经常恶作剧。但这种状况在他成功的通过“忍者学校”的毕业考试后逐渐改变，并以成为“火影”为目标努力。\n火影忍者故事既包含严肃和娱乐的情节，整个故事以鸣人及其朋友的成长为核心，并描绘他们在人生经历当中的相互感情。鸣人与两位好友 宇智波佐助和春野樱，和他们的导师“复制忍者”旗木卡卡西组成第七组执行各种任务。 ","date":"2002-10-03","objectID":"/anime/naruto/","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"简介 在火影忍者正式故事展开的12年前，一只被称为九尾 妖狐的妖怪袭击木叶忍者村，传说它一挥动尾巴就会山崩海啸。当时的第四代火影“木叶黄色闪光”波风皆人牺牲自己的性命，把九尾封印在刚出生的孩子 漩涡鸣人身上。 “第四代火影”被村里的人认为是英雄，但他更希望村里的人同样地将鸣人当作英雄看待。但村民认为鸣人就是妖狐的化身，而不是作为封印妖狐的幕后功臣，因此为鸣人自小就被人歧视。 重新复出的“第三代火影”已经禁止村民和后代提到这次的九尾突袭事件，但是仍不能阻止人们排挤鸣人。就连他们不知情的后代，在父母的感染下，亦疏远鸣人。因此，鸣人从小倍受孤立。为了引起其他人注意经常恶作剧。但这种状况在他成功的通过","date":"2002-10-03","objectID":"/anime/naruto/:1:0","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 漩涡鸣人 鳴門、渦卷鳴門、漩涡鸣门、Naruto Uzumaki、うずまきナルト、Uzumaki Naruto、鳴門 男 竹内順子 2 宇智波佐助 內輪佐助、内轮佐助、うちはサスケ、Uchiha Sasuke、佐助 男 杉山紀彰 3 春野樱 春野サクラ、Haruno Sakura、樱爷 女 中村千絵 4 旗木卡卡西 畑鹿驚、畑鹿惊、はたけカカシ、Hatake Kakashi 男 井上和彦 5 手鞠 女 朴璐美 6 自来也 Jiraiya 男 大塚芳忠 7 日向雏田 日向ヒナタ、Hyuuga Hinata 女 水樹奈々 8 我爱罗 我愛羅、Gaara 男 石田","date":"2002-10-03","objectID":"/anime/naruto/:2:0","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 火影忍者 2002-10-03 220 优酷 2 火影忍者疾风传 2007-02-15 500 樱花 3 火影忍者 剧场版 博人传 2015-08-07 1 樱花 ","date":"2002-10-03","objectID":"/anime/naruto/:3:0","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"MAD ","date":"2002-10-03","objectID":"/anime/naruto/:4:0","tags":null,"title":"火影忍者","uri":"/anime/naruto/"},{"categories":null,"content":"infinity系列第二部。本游戏分为两个主人公视点——仓成武和失忆少年，与小町月海，茜崎空，优，松永沙罗，八神可可几位少女编制一团迷离的故事，各女主角的剧情安排也因主人公的视点而有所变动未来海洋主题乐园内 演绎生离死别的悲喜剧","date":"2002-08-29","objectID":"/game/ever17/","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"简介 infinity系列第二部。本游戏分为两个主人公视点——仓成武和失忆少年，与小町月海，茜崎空，优， 松永沙罗， 八神可可几位少女编制一团迷离的故事，各女主角的剧情安排也因主人公的视点而有所变动未来海洋主题乐园 内演绎生离死别的悲喜剧。 制作人员： 开发：KID 发行：光谱资讯、赛科、サイバーフロント、北京娱乐通科技发展有限公司 剧本：打越钢太郎、中泽工、梅田伸明 ","date":"2002-08-29","objectID":"/game/ever17/:1:0","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 仓成武 くらなり たけし、Kuranari Takeshi、武 仓成先生 男 保志総一朗 2 少年 Shonen 男 ？？？ 3 小町月海 小町鸠（误译）、小町鸫、小町 つぐみ、こまち つぐみ、Komachi Tsugumi 女 浅川悠 4 茜崎空 あかねがさき そら、Akanegasaki Sora、空 女 笠原弘子 5 田中优美清春香菜 优春、たなか ゆうびせいはるかな、Tanaka Yubiseiharukana 女 下屋則子 6 松永沙罗 まつなが さら、Matsunaga Sara、沙罗 女 植田佳奈 7 八神可可 八神可可、やがみ ここ、Yaga","date":"2002-08-29","objectID":"/game/ever17/:2:0","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"系列 系列名 发行时间 1 时空轮回 2002-08-29 ","date":"2002-08-29","objectID":"/game/ever17/:3:0","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"配乐 ","date":"2002-08-29","objectID":"/game/ever17/:4:0","tags":null,"title":"ever17","uri":"/game/ever17/"},{"categories":null,"content":"在20世纪，世界格局比较稳定的时候，各大国都想增强自己的军事力量，从而称霸世界。而Whisper[耳语者]这种特殊的人类，自从出生开始就拥有特殊的能力，不用学习也能知道超越当时科技几十年的被称为黑科技的高科技手段。为了保护世界格局的稳定，神秘组织Mithril[米斯利尔]派出了相良中士等三人去保护一名已知的Whisper[耳语者]，即千鸟香奈。其中相良中士装成转校生随时跟踪保护，由于长期处于军队的生活，完全没有普通高中生的生活常识的相良中士在学校里闹了不少笑话。在学校期间也发生了不少恐怖的事情，如苏联为绑架香奈制造的劫机事件等。宗介和千鸟之间也因为发生的各种事件产生了特殊的感情。","date":"2002-01-15","objectID":"/anime/full_metal_panic/","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"简介 在20世纪，世界格局比较稳定的时候，各大国都想增强自己的军事力量，从而称霸世界。而Whisper[耳语者]这种特殊的人类，自从出生开始就拥有特殊的能力，不用学习也能知道超越当时科技几十年的被称为黑科技的高科技手段。为了保护世界格局的稳定，神秘组织Mithril[米斯利尔]派出了相良中士等三人去保护一名已知的Whisper[耳语者]，即千鸟香奈。其中相良中士装成转校生随时跟踪保护，由于长期处于军队的生活，完全没有普通高中生的生活常识的相良中士在学校里闹了不少笑话。在学校期间也发生了不少恐怖的事情，如苏联为绑架香奈制造的劫机事件等。宗介和千鸟之间也因为发生的各种事件产生了特殊的感情。 制作人","date":"2002-01-15","objectID":"/anime/full_metal_panic/:1:0","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 相良宗介 Sagara Sosuke、相良 宗介、さがら そうすけ、Sagara Sousuke、カシム / 卡西姆 男 関智一 2 千鸟要 Kaname Chidori、千鳥かなめ、Chidori Kaname 女 ゆきのさつき 3 泰蕾莎·泰斯塔罗莎 テレサ・テスタロッサ、Teletha Testarossa、泰莎 女 ゆかな 4 梅利莎·毛 Melissa Mao、メリッサ・マオ、Uruz 2 女 根谷美智子 5 克鲁兹·威巴 Kurz Weber、クルツ・ウェーバー、Uruz 6 男 三木眞一郎 6 理查德·马度卡斯 Richard Henry Ma","date":"2002-01-15","objectID":"/anime/full_metal_panic/:2:0","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 全金属狂潮 2002-01-15 24 bilibili 2 全金属狂潮 校园篇 2003-08-26 12 bilibili 3 全金属狂潮 The Second Raid 2005-07-13 13 bilibili 4 全金属狂潮 The Second Raid OVA 战队长悠闲的一天 2006-05-26 1 bilibili 5 全金属狂潮 Invisible Victory 2018-04-13 12 bilibili ","date":"2002-01-15","objectID":"/anime/full_metal_panic/:3:0","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"MAD ","date":"2002-01-15","objectID":"/anime/full_metal_panic/:4:0","tags":null,"title":"全金属狂潮","uri":"/anime/full_metal_panic/"},{"categories":null,"content":"自从汉堂在1999年夏天推出《天地劫：神魔至尊传》之后，制作小组在《神魔至尊传》之后，\n便立刻开始着手制作《天地劫》的系列作品《天地劫：幽城幻剑录》。《幽城幻剑录》的故事将以《神魔至尊传》中出身来历最神秘的\n金发邪道法师──夏侯仪为主角，以他少年时代不为人所知的冒险传奇，来交代他在《神魔至尊传》中的诸般出人意料的偏激言行，并连贯两个故事之间的前因后果。","date":"2001-11-18","objectID":"/game/you_cheng/","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"简介 自从汉堂在1999年夏天推出《天地劫：神魔至尊传》之后，制作小组在《神魔至尊传》之后， 便立刻开始着手制作《天地劫》的系列作品《天地劫：幽城幻剑录》。 《幽城幻剑录》的故事将以《神魔至尊传》中出身来历最神秘的 金发邪道法师──夏侯仪为主角，以他少年时代不为人所知的冒险传奇，来交代他在《神魔至尊传》中的 诸般出人意料的偏激言行，并连贯两个故事之间的前因后果。 制作人员： 开发：智乐堂 剧本：叶明璋 ","date":"2001-11-18","objectID":"/game/you_cheng/:1:0","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 夏侯仪 男 2 冰璃 女 3 封铃笙 女 4 慕容璇玑 女 5 古伦德 男 6 霍雍 男 7 皇甫申 男 8 葛云衣 女 ","date":"2001-11-18","objectID":"/game/you_cheng/:2:0","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"系列 系列名 发行时间 1 天地劫序传：幽城幻剑录 2001-11-18 ","date":"2001-11-18","objectID":"/game/you_cheng/:3:0","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"配乐 ","date":"2001-11-18","objectID":"/game/you_cheng/:4:0","tags":null,"title":"幽城幻剑录","uri":"/game/you_cheng/"},{"categories":null,"content":"       小学生进藤光在爷爷家的仓库玩耍时，邂逅了千年前的棋士藤原佐为的魂魄并被强行附体，对围棋原本毫无兴趣的他要如何与佐为相处？\n在佐为的帮助下进藤光意外打败了棋坛明日之星塔矢亮，受到众人关注的他要如何面对自己的人生之路？\n一段联结千年时光的围棋物语就此徐徐展开......","date":"2001-10-10","objectID":"/anime/hikaru_no_go/","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"简介 小学生进藤光在爷爷家的仓库玩耍时，邂逅了千年前的棋士藤原佐为的魂魄并被强行附体，对围棋原本毫无兴趣的他要如何与佐为相处？ 在佐为的帮助下进藤光意外打败了棋坛明日之星塔矢亮，受到众人关注的他要如何面对自己的人生之路？ 一段联结千年时光的围棋物语就此徐徐展开…… 制作人员： 原作：小畑健、堀田由美 导演：远藤彻哉、西泽晋、神谷纯 脚本：大桥志吉、富冈淳广、横手美智子 ","date":"2001-10-10","objectID":"/anime/hikaru_no_go/:1:0","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 进藤光 進藤 ヒカル、しんどう ひかる、Shindou Hikaru 男 川上とも子 2 藤原佐为 藤原佐為、ふじわら の さい、Fujiwara no Sai 男 千葉進歩 3 塔矢亮 塔矢 アキラ、とうや アキラ 男 小林沙苗 4 筒井公宏 筒井公宏、つつい きみひろ、Tsutsui Kimihiro 男 津村まこと 5 绪方精次 緒方精次、Ogata Seiji 男 藤原啓治 6 和谷义高 和谷義高、Waya Yoshitaka 男 高木礼子 7 岸本薰 岸本薫、Kishimoto Kaoru 男 櫻井孝宏 8 尹教练 尹先生、Yun-sensei 男","date":"2001-10-10","objectID":"/anime/hikaru_no_go/:2:0","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 棋魂 2001-10-10 75 樱花 2 棋魂特别篇 迈向北斗杯之路 2004-01-03 1 bilibili ","date":"2001-10-10","objectID":"/anime/hikaru_no_go/:3:0","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"MAD ","date":"2001-10-10","objectID":"/anime/hikaru_no_go/:4:0","tags":null,"title":"棋魂","uri":"/anime/hikaru_no_go/"},{"categories":null,"content":"风靡日本的女明星藤原千代子，三十年前当红之际，突然从银幕消声匿迹。\n三十年后，千代子的影迷费尽千辛万苦，终于在人烟稀少的寂静山庄中，找到了隐居数十年的她，并献上了一把千代子当年不慎遗失的神秘钥匙。\n神秘钥匙宛若开启了记忆之门，引领千代子划入回忆的大海，挖掘出一段她从不为人知的爱情故事。那故事像是从千代子辉煌年代的河流溢出，一路流向她无数的电影与映像汇集而成的海洋；也像从遥远的战国时代奔驰而来，再闯进无边无际的时空未来。\n而倾听入神的影迷，则随着千代子在记忆的逆流波谷间摆荡，体验她那令人怜惜的悲欢爱情；更在波涛汹涌的时空浪潮中，猛然惊觉到那股横亘千年的浓绵相思，神秘钥匙开启被千代子封锁隐藏了的记忆，解开了她的重要秘密。那正是在无情的时间洪流里，当记忆与爱情最灿烂交会时，所浮现出最真实且永恒的一代巨星千代子。","date":"2001-07-28","objectID":"/anime/millennium_actress/","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"简介 风靡日本的女明星藤原千代子，三十年前当红之际，突然从银幕消声匿迹。 三十年后，千代子的影迷费尽千辛万苦，终于在人烟稀少的寂静山庄中，找到了隐居数十年的她，并献上了一把千代子当年不慎遗失的神秘钥匙。 神秘钥匙宛若开启了记忆之门，引领千代子划入回忆的大海，挖掘出一段她从不为人知的爱情故事。那故事像是从千代子辉煌年代的河流溢出，一路流向她无数的电影与映像汇集而成的海洋；也像从遥远的战国时代奔驰而来，再闯进无边无际的时空未来。 而倾听入神的影迷，则随着千代子在记忆的逆流波谷间摆荡，体验她那令人怜惜的悲欢爱情；更在波涛汹涌的时空浪潮中，猛然惊觉到那股横亘千年的浓绵相思，神秘钥匙开启被千代子封锁隐藏","date":"2001-07-28","objectID":"/anime/millennium_actress/:1:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 藤原千代子 Fujiwara Chiyoko 女 折笠富美子 2 钥匙先生 男 山寺宏一 3 立花源也 男 佐藤政道 4 井田恭二 男 小野坂昌也 ","date":"2001-07-28","objectID":"/anime/millennium_actress/:2:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 千年女优 2001-07-28 01:26:26 bilibili ","date":"2001-07-28","objectID":"/anime/millennium_actress/:3:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"配乐 ","date":"2001-07-28","objectID":"/anime/millennium_actress/:4:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"MAD ","date":"2001-07-28","objectID":"/anime/millennium_actress/:5:0","tags":null,"title":"千年女优","uri":"/anime/millennium_actress/"},{"categories":null,"content":"年仅10岁的荻野千尋是一个看起来非常普通的四年级小学生，她随父母搬家来到一个陌生的城镇准备开始一个全新的生活。然而，因为途中迷路，她和父母误闯入了一个人类不应该进入的灵异小镇。小镇的主管是当地一家叫“油屋”的澡堂的巫婆：湯婆婆；而“油屋”则是为服侍日本八百万天神洗澡的地方。镇上有一条规定，在镇上凡是没有工作的人，都要被变成猪被吃掉。\n\n千尋的父母由于贪吃，未經過店員容許就隨便觸碰食物，而遭到惩罚变成了猪。千尋为了拯救父母，在汤婆婆的助手「珀」（ハク，台灣上映時譯為「白龍」）的帮助下，进入澡堂，并成功的获得了一份工作。作为代价，她的名字被汤婆婆拿掉了筆劃太多的名字，成了“千”（台灣片中稱為「小千」）。在澡堂工作的过程中，小千从一个娇生惯养，什么活都不会做的小女孩，逐渐成长，变得越来越坚强能干；同时，她善良的品格也开始得到了澡堂中其他的尊重，而她和白龙之间也萌生出一段纯真的感情。\n\n而为了拯救父母和对自己重要的人，面对各种困难和危险，千尋也一次次做出了自己的选择。而影片也随着她的心理变化历程而展开。\n\n简介来源于：http://zh.wikipedia.org/wiki/%E5%8D%83%E4%B8%8E%E5%8D%83%E5%AF%BB","date":"2001-07-20","objectID":"/anime/spirited_away/","tags":null,"title":"千与千寻","uri":"/anime/spirited_away/"},{"categories":null,"content":"简介 年仅10岁的荻野千尋是一个看起来非常普通的四年级小学生，她随父母搬家来到一个陌生的城镇准备开始一个全新的生活。然而，因为途中迷路，她和父母误闯入了一个人类不应该进入的灵异小镇。小镇的主管是当地一家叫“油屋”的澡堂的巫婆：湯婆婆；而“油屋”则是为服侍日本八百万天神洗澡的地方。镇上有一条规定，在镇上凡是没有工作的人，都要被变成猪被吃掉。 千尋的父母由于贪吃，未經過店員容許就隨便觸碰食物，而遭到惩罚变成了猪。千尋为了拯救父母，在汤婆婆的助手「珀」（ハク，台灣上映時譯為「白龍」）的帮助下，进入澡堂，并成功的获得了一份工作。作为代价，她的名字被汤婆婆拿掉了筆劃太多的名字，成了“千”（台灣片中稱為「","date":"2001-07-20","objectID":"/anime/spirited_away/:1:0","tags":null,"title":"千与千寻","uri":"/anime/spirited_away/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 白 白龙／赈早见琥珀主、Kohaku River、饒速水小白主、ニギハヤミコハクヌシ、Nigihayami Kohaku Nushi 男 入野自由 2 荻野千寻 Ogino Chihiro 女 柊瑠美 3 锅炉爷爷 釜爺、Kamajii 男 菅原文太 4 リン Lin、リン、Rin 女 玉井夕海 5 荻野悠子 おぎの ゆうこ 女 沢口靖子 6 坊 ぼう 男 神木隆之介 7 无脸男 カオナシ 中村彰男 8 汤婆婆 ゆばば 女 夏木マリ ","date":"2001-07-20","objectID":"/anime/spirited_away/:2:0","tags":null,"title":"千与千寻","uri":"/anime/spirited_away/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 千与千寻 2001-07-20 124m 樱花 ","date":"2001-07-20","objectID":"/anime/spirited_away/:3:0","tags":null,"title":"千与千寻","uri":"/anime/spirited_away/"},{"categories":null,"content":"日暮戈薇是就读于国中三年级的15岁普通小女生，某日，她偶然通过家中神社的枯井来到了500年前的战国时代。时狼烟四起，妖怪横行，世间大地生灵涂炭。戈薇在御神木那里邂逅了被封印的半妖犬夜叉。50年前，意欲变成真正妖怪的犬夜叉，为了得到四魂之玉结识拥有强大灵力的巫女桔梗。经过一段时间相处，两人之间产生了感情。犬夜叉因此希望变成人类，而桔梗也打算在净化完四魂之玉后过回普通人的生活。然而，对桔梗心存邪念的盗贼鬼蜘蛛将灵魂和肉体献给妖怪，继而转生变成邪恶的半妖奈落。在他的一番挑拨下，犬夜叉被桔梗封印在神木之上，重伤的桔梗也在悲伤绝望中死去。\n桔梗转生的戈薇解救了犬夜叉，却不慎将四魂之玉射成碎片。为了找回碎片，她和犬夜叉以及随后遇到的伙伴：七宝、弥勒、珊瑚踏上了充满艰难险阻的旅途…… ","date":"2000-10-16","objectID":"/anime/inuyasha/","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"简介 日暮戈薇是就读于国中三年级的15岁普通小女生，某日，她偶然通过家中神社的枯井来到了500年前的战国时代。时狼烟四起，妖怪横行，世间大地生灵涂炭。戈薇在御神木那里邂逅了被封印的半妖犬夜叉。50年前，意欲变成真正妖怪的犬夜叉，为了得到四魂之玉结识拥有强大灵力的巫女桔梗。经过一段时间相处，两人之间产生了感情。犬夜叉因此希望变成人类，而桔梗也打算在净化完四魂之玉后过回普通人的生活。然而，对桔梗心存邪念的盗贼鬼蜘蛛将灵魂和肉体献给妖怪，继而转生变成邪恶的半妖奈落。在他的一番挑拨下，犬夜叉被桔梗封印在神木之上，重伤的桔梗也在悲伤绝望中死去。 桔梗转生的戈薇解救了犬夜叉，却不慎将四魂之玉射成碎片。为了","date":"2000-10-16","objectID":"/anime/inuyasha/:1:0","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 犬夜叉 いぬやしゃ、Inuyasha 男 山口勝平 2 日暮戈薇 日暮笼目、日暮篱、日暮かごめ、ひぐらし かごめ、Higurashi Kagome 女 ゆきのさつき 3 桔梗 ききょう、Kikyou 女 日髙のり子 4 七宝 しっぽう、Shippou 男 渡辺久美子 5 弥勒 みろく、Miroku 男 辻谷耕史 6 珊瑚 さんご、Sango 女 桑島法子 7 杀生丸 せっしょうまる、Sesshoumaru 男 成田剣 8 奈落 ならく、Naraku 男 森川智之 ","date":"2000-10-16","objectID":"/anime/inuyasha/:2:0","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 犬夜叉 2000-10-16 167 bilibili 2 犬夜叉 完结篇 2009-10-03 26 bilibili 3 犬夜叉 穿越时空的思念 2001-12-15 1 bilibili 4 犬夜叉 镜中的梦幻城 2002-12-21 1 bilibili 5 犬夜叉 天下霸道之剑 2003-12-20 1 bilibili 6 犬夜叉 红莲之蓬莱岛 2004-12-23 1 樱花 7 犬夜叉 黑色铁碎牙 2008-07-30 1 优酷 ","date":"2000-10-16","objectID":"/anime/inuyasha/:3:0","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"MAD ","date":"2000-10-16","objectID":"/anime/inuyasha/:4:0","tags":null,"title":"犬夜叉","uri":"/anime/inuyasha/"},{"categories":null,"content":"《Air》是日本Key会社继《Kanon》后，所出品的第二款恋爱AVG（电子小说类游戏）游戏。\n\nAIR的标志是一个牵着男孩的手的女孩。故事主要以夏天为主基调，讲述了一个跨越千年的翼人传说。亦被视为Key社季节组曲中的“夏”。","date":"2000-09-08","objectID":"/game/air/","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"简介 《Air》是日本Key会社继《Kanon》后，所出品的第二款恋爱AVG（电子小说类游戏）游戏。 AIR的标志是一个牵着男孩的手的女孩。故事主要以夏天为主基调，讲述了一个跨越千年的翼人传说。 亦被视为Key社季节组曲中的“夏”。 制作人员： 开发：Key 剧本：云龙寺魁、丘野塔也、麻枝准、凉元悠一 音乐：折户伸治、戸越まごめ ","date":"2000-09-08","objectID":"/game/air/:1:0","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 神尾观铃 かみお みすず、Kamio Misuzu 女 川上とも子 2 雾岛佳乃 きりしま かの、Kirishima Kano 女 岡本麻見 3 远野美凪 とおの みなぎ、Tohno Minagi 女 柚木涼香 4 神奈备命 かんなびのみこと、Kannabi no Mikoto 女 西村ちなみ 5 国崎往人 くにさき ゆきと、Kunisaki Yukito 男 緑川光 6 柳也 りゅうや、Ryuuya 男 神奈延年 7 里叶 裏葉、うらは、Uraha 女 井上喜久子 8 神尾晴子 かみお はるこ、Kamio Haruko 女 久川綾 ","date":"2000-09-08","objectID":"/game/air/:2:0","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"系列 系列名 发行时间 1 AIR 2000-09-08 ","date":"2000-09-08","objectID":"/game/air/:3:0","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"配乐 ","date":"2000-09-08","objectID":"/game/air/:4:0","tags":null,"title":"air","uri":"/game/air/"},{"categories":null,"content":"也不知是过去还是未来的年代，“外星移民”早成了平凡的存在。贫穷考生真由子寄居在“荏之花”澡堂的阁楼，一天到晚三餐不继却还得养活个吃白食的外星懒虫。于是万丈波涛滚滚而来。外星小孩尼亚最大的爱好就是收集垃圾，从中回收剩余物资再造飞船。头上没有像其他外星人样生着天线，被蔑称为“低等外星人”却从未在意，在自己的曲调早活得悠哉游哉。真由子的认真清苦，真由子的胆小谨慎，在那外星小孩的心无城府面前，忽然变得意义不明。严肃刻板与大而化之的碰撞，带着轻捷的喜剧色彩，余音早又有些淡色水彩般的惆怅。 \n\n挂在空中像朵云的母船，是尼亚头脑中遥远模糊的，关于“故乡”的呼唤。它化成流黄飞去的那一天，一种最温柔的意象笼罩了“荏之花”的风物与居民。世界如此广阔，而这刻，我们为彼此驻足，这一分钟是准也改变不了，因为那已是过去，将成为回忆，在未来的时光里与我们作着推手，走出个饱满的弧形。所谓生命，所谓怀念，就是这样平平淡淡，生生不息。","date":"2000-04-26","objectID":"/anime/niea_7/","tags":null,"title":"我家也有外星人","uri":"/anime/niea_7/"},{"categories":null,"content":"简介 也不知是过去还是未来的年代，“外星移民”早成了平凡的存在。贫穷考生真由子寄居在“荏之花”澡堂的阁楼，一天到晚三餐不继却还得养活个吃白食的外星懒虫。于是万丈波涛滚滚而来。外星小孩尼亚最大的爱好就是收集垃圾，从中回收剩余物资再造飞船。头上没有像其他外星人样生着天线，被蔑称为“低等外星人”却从未在意，在自己的曲调早活得悠哉游哉。真由子的认真清苦，真由子的胆小谨慎，在那外星小孩的心无城府面前，忽然变得意义不明。严肃刻板与大而化之的碰撞，带着轻捷的喜剧色彩，余音早又有些淡色水彩般的惆怅。 挂在空中像朵云的母船，是尼亚头脑中遥远模糊的，关于“故乡”的呼唤。它化成流黄飞去的那一天，一种最温柔的意象笼罩","date":"2000-04-26","objectID":"/anime/niea_7/:1:0","tags":null,"title":"我家也有外星人","uri":"/anime/niea_7/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 ニア ニア、NieA 女 宮村優子 2 茅崎真由子 女 川澄綾子 3 广播 アナウンサー、Announcer、播音员、Announce 福島潤 ","date":"2000-04-26","objectID":"/anime/niea_7/:2:0","tags":null,"title":"我家也有外星人","uri":"/anime/niea_7/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 我家也有外星人 2000-04-26 13 bilibili ","date":"2000-04-26","objectID":"/anime/niea_7/:3:0","tags":null,"title":"我家也有外星人","uri":"/anime/niea_7/"},{"categories":null,"content":"　　传说中海贼王哥尔·D·罗杰在死前说出他留下了具有财富、名声、力量的宝藏「ONE PIECE」，许多人为了争夺ONE PIECE，争相出海，许多海贼开始树立霸权，而形成了大海贼时代。十年后，草帽小子 蒙其·D·路飞为了要实现与因救他而断臂的海贼红发香克斯的约定而出海，在遥远的路途上找寻着志同道合的伙伴，一起进入「伟大的航道」，目标当上海贼王。","date":"1999-10-20","objectID":"/anime/one_piece/","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"简介 传说中海贼王哥尔·D·罗杰在死前说出他留下了具有财富、名声、力量的宝藏「ONE PIECE」，许多人为了争夺ONE PIECE，争相出海，许多海贼开始树立霸权，而形成了大海贼时代。十年后，草帽小子 蒙其·D·路飞为了要实现与因救他而断臂的海贼红发香克斯的约定而出海，在遥远的路途上找寻着志同道合的伙伴，一起进入「伟大的航道」，目标当上海贼王。 制作人员： 原作：尾田荣一郎 导演：小牧文、暮田公平、深泽敏则、宇田钢之介、志水淳儿、长峰达也、境宗久、宮元宏彰 ","date":"1999-10-20","objectID":"/anime/one_piece/:1:0","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 蒙奇·D·路飞 蒙其·D·魯夫、Monkey D. Luffy 男 田中真弓 2 罗罗诺亚·索隆 罗罗亚·佐罗、ロロノア・ゾロ、Roronoa Zoro 男 中井和哉 3 娜美 奈美、ナミ、Nami、小贼猫娜美 女 岡村明美 4 乌索普 撒谎布、骗人布、ウソップ、Usopp、狙击王（そげキング，Sogeking） 男 山口勝平 5 文斯莫克·山智 Vinsmoke Sanji、黒足のサンジ （黑足山治）、文斯莫克·山治（港）、賓什莫克·香吉士（台湾东立） 男 大谷育江 6 托尼托尼·乔巴 东尼东尼·乔巴、トニートニー・チョッパー、Tony Tony Chop","date":"1999-10-20","objectID":"/anime/one_piece/:2:0","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 海贼王 1999-10-20 1040 樱花 ","date":"1999-10-20","objectID":"/anime/one_piece/:3:0","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"MAD ","date":"1999-10-20","objectID":"/anime/one_piece/:4:0","tags":null,"title":"海贼王","uri":"/anime/one_piece/"},{"categories":null,"content":"热血而耿直的少年修在放学路上遇见沉默的少女。在突如其来的变故中，为了保护向他呼救的少女，修被卷入了陌生的时空。在荒芜的世界里，生命将何去何从……\n","date":"1999-10-14","objectID":"/anime/now_and_then/","tags":null,"title":"此时此刻的我","uri":"/anime/now_and_then/"},{"categories":null,"content":"简介 热血而耿直的少年修在放学路上遇见沉默的少女。在突如其来的变故中，为了保护向他呼救的少女，修被卷入了陌生的时空。在荒芜的世界里，生命将何去何从…… 制作人员： 导演：大地丙太郎 脚本：仓田英之 分镜：山崎健志、佐山圣子、井硲清高、大桥誉志光、长滨博史、铃木行 ","date":"1999-10-14","objectID":"/anime/now_and_then/:1:0","tags":null,"title":"此时此刻的我","uri":"/anime/now_and_then/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 拉拉·露 Lala Ru 女 名塚佳織 2 松谷修造 シュウ、Matsutani Shuuzou 男 岡村明美 3 ハムド Hamdo 男 石井康嗣 4 阿贝利亚 ABELIA 安原麗子 5 莎拉 SALA 仲尾あづさ 6 纳布卡 NABUCA 今井由香 7 小布 BOO 小西寛子 8 西斯 SIS 松本梨香 ","date":"1999-10-14","objectID":"/anime/now_and_then/:2:0","tags":null,"title":"此时此刻的我","uri":"/anime/now_and_then/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 此时此刻的我 1999-10-14 13 bilibili ","date":"1999-10-14","objectID":"/anime/now_and_then/:3:0","tags":null,"title":"此时此刻的我","uri":"/anime/now_and_then/"},{"categories":null,"content":"讲述的是不同环境下成长的女孩们，蜕变与成熟的故事。天资聪颖的女高中生，却患有极度的男性恐惧症、从来不敢穿女装的运动健将，竟面临画家央求她当模特儿的难题——","date":"1999-10-06","objectID":"/anime/seraphim_call/","tags":null,"title":"六翼天使之声","uri":"/anime/seraphim_call/"},{"categories":null,"content":"简介 讲述的是不同环境下成长的女孩们，蜕变与成熟的故事。天资聪颖的女高中生，却患有极度的男性恐惧症、从来不敢穿女装的运动健将，竟面临画家央求她当模特儿的难题—— 该作不论是产生的背景或表现的型式，在日本动画界均是少见的案例，它本来只是日本‘电击G’s Magazine’的一个读者特别企划连载单元，刊登后赢得热烈的回响， 于是趁势推出系列周边商品，后来由日本SUNRISE公司制成动画。每一话的主角均不同，剧情也毫不相干（第5、6话例外），最后一话再让所有女主角来个大会串。 制作人员： 导演：望月智充 脚本：村井贞之、荒川稔久、荒木宪一 分镜：大森贵弘、原博、吉永尚之 ","date":"1999-10-06","objectID":"/anime/seraphim_call/:1:0","tags":null,"title":"六翼天使之声","uri":"/anime/seraphim_call/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 栗本雪菜 栗本雪菜、くりもと ゆきな、Kurimoto Yukina 女 笠原弘子 2 寺本蒲公英 寺本たんぽぽ、てらもと　たんぽぽ、Teramoto Tanpopo 女 川田妙子 3 樱濑千奈美 桜瀬ちなみ、おうせ ちなみ 女 矢島晶子 4 楠初摘 楠初摘、くすのき はつみ 女 伊東絵実 5 村雨紫苑 村雨紫苑、Murasame Shion 女 長沢美樹 6 村雨樱 村雨桜、むらさめ さくら 女 西村ちなみ 7 柊彩乃 柊彩乃、Hiiragi Saeno 女 石村知子 8 凛堂绚香 凛堂あやか、りんどう あやか 女 佐久間レイ ","date":"1999-10-06","objectID":"/anime/seraphim_call/:2:0","tags":null,"title":"六翼天使之声","uri":"/anime/seraphim_call/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 六翼天使之声 1999-10-06 12 bilibili ","date":"1999-10-06","objectID":"/anime/seraphim_call/:3:0","tags":null,"title":"六翼天使之声","uri":"/anime/seraphim_call/"},{"categories":null,"content":"　　八神太一、石田大和、武之内素娜、城户丈、泉光子郎、太刀川美美、高石武、八神嘉儿这八位小朋友，在夏令营中受到召唤而到进入数码世界进行冒险。\n1999年，由于数码世界资料异常增生，导致数码世界和现实世界的连接发生紊乱。地球上相应地出现奇怪的自然现象：东南亚没有下雨，池塘全部干涸；中东却因为连场大雨发生洪水,美国则遇到有史以来最寒冷的夏天，日本则突降大雪。\n11岁的少年八神太一和他的六个朋友一起参加了夏令营，却奇怪的被神秘地送到了一个多彩的数码世界。在那里，他们得到了叫做“数码宝贝”的搭档。这些孩子被认为是数字世界的未来，他们与数码宝贝们一起要解开控制这个可怕的数码世界之谜。当他们踏上这个伟大的征程时，因特网成了他们的战场……","date":"1999-03-07","objectID":"/anime/digimon_adventure/","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"简介 八神太一、石田大和、武之内素娜、城户丈、泉光子郎、太刀川美美、高石武、八神嘉儿这八位小朋友，在夏令营中受到召唤而到进入数码世界进行冒险。 1999年，由于数码世界资料异常增生，导致数码世界和现实世界的连接发生紊乱。地球上相应地出现奇怪的自然现象：东南亚没有下雨，池塘全部干涸；中东却因为连场大雨发生洪水,美国则遇到有史以来最寒冷的夏天，日本则突降大雪。 11岁的少年八神太一和他的六个朋友一起参加了夏令营，却奇怪的被神秘地送到了一个多彩的数码世界。在那里，他们得到了叫做“数码宝贝”的搭档。这些孩子被认为是数字世界的未来，他们与数码宝贝们一起要解开控制这个可怕的数码世界之谜。当他们踏上这个伟大","date":"1999-03-07","objectID":"/anime/digimon_adventure/:1:0","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 八神太一 やがみ たいち、Yagami Taichi 男 藤田淑子 2 亚古兽 Agumon、아구몬 坂本千夏 3 石田大和 いしだ やまと、Ishida Yamato 男 風間勇刀 4 加布兽 Gabumon、파피몬 山口眞弓 5 武之内空 武之内素娜、たけのうち そら、Takenouchi Sora 女 水谷優子 6 比丘兽 Piyomon、피요몬 重松花鳥 7 泉光子郎 いずみ こうしろう、Izumi Koushiro 男 天神有海 8 甲虫兽 Tentomon、텐토몬 櫻井孝宏 ","date":"1999-03-07","objectID":"/anime/digimon_adventure/:2:0","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 数码宝贝大冒险 1999-03-07 54 樱花 2 数码宝贝大冒险02 2000-04-02 50 樱花 3 数码宝贝驯兽师之王 2001-04-01 51 樱花 4 数码宝贝无限地带 2002-04-07 50 樱花 5 数码宝贝大冒险 滚球兽的诞生 1999-03-06 1 bilibili 6 数码宝贝大冒险 我们的战争游戏! 2000-03-04 1 acfun 7 数码宝贝X进化 2005-01-03 1 bilibili ","date":"1999-03-07","objectID":"/anime/digimon_adventure/:3:0","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"MAD ","date":"1999-03-07","objectID":"/anime/digimon_adventure/:4:0","tags":null,"title":"数码宝贝大冒险","uri":"/anime/digimon_adventure/"},{"categories":null,"content":"宫泽雪野是公认的模范优等生，无论是成绩、性格、还是外貌都无可挑剔。因此，同学们将她作为偶像一样崇拜。但是，真正的雪野是一个虚荣心极强的人，为了获得别人的赞赏，几乎什么事情都做得出来。好脾气是装出来的，好成绩是通宵学出来的，可爱的样子是对着镜子苦练的结果。只有在自己家中，雪野才会卸下那个假面具，变成一个不修边幅、任性的普通女孩。\n升入高中后，雪野命中的克星出现了，她的生活完全被破坏了。有马总一郎，出生于医生世家，学业、体育等各方面都非常出色，比雪野更十全十美，也是女生们心中百分百的白马王子。同学们的注意力渐渐集中在有马身上，雪野第一次尝到了被忽视的滋味。于是，雪野将有马作为头号敌人，开始制定打倒他的作战计划，决心重新成为学校的焦点。","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"简介 宫泽雪野是公认的模范优等生，无论是成绩、性格、还是外貌都无可挑剔。因此，同学们将她作为偶像一样崇拜。但是，真正的雪野是一个虚荣心极强的人，为了获得别人的赞赏，几乎什么事情都做得出来。好脾气是装出来的，好成绩是通宵学出来的，可爱的样子是对着镜子苦练的结果。只有在自己家中，雪野才会卸下那个假面具，变成一个不修边幅、任性的普通女孩。 升入高中后，雪野命中的克星出现了，她的生活完全被破坏了。有马总一郎，出生于医生世家，学业、体育等各方面都非常出色，比雪野更十全十美，也是女生们心中百分百的白马王子。同学们的注意力渐渐集中在有马身上，雪野第一次尝到了被忽视的滋味。于是，雪野将有马作为头号敌人，开始制","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/:1:0","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 宫泽雪野 宮沢雪野、みやざわ ゆきの、Miyazawa Yukino、ゆきのん 女 榎本温子 2 有马总一郎 有馬総一郎、ありま そういちろう、Arima Souichirou、ありま 男 小山裕香 3 浅叶秀明 浅葉秀明、あさば ひであき、Asaba Hideaki、あさば しゅうめい 男 私市淳 4 宫泽洋之 宮沢洋之、みやざわ ひろゆき、Miyazawa Hiroyuki 男 野田順子 5 宫泽月野 宮沢月野、みやざわ つきの、Miyazawa Tsukino 女 渡邉由紀 6 芝姫つばさ 芝姫つばさ 新谷真弓 7 井泽真秀 Izawa Maho 女 ","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/:2:0","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 他和她的故事 1998-10-02 26 bilibili ","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/:3:0","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"配乐 ","date":"1998-10-02","objectID":"/anime/his_and_her_circumstances/:4:0","tags":null,"title":"他和她的故事","uri":"/anime/his_and_her_circumstances/"},{"categories":null,"content":"岩仓玲音的同学四方田千砂自杀了。没有任何前兆的自杀事件让同学们不知所措，一周后，玲音收到了千砂的短信。明明已死的千砂居然以手机短信和玲音开始了交流。回到家，玲音用爸爸给她的电脑开始与千砂联系。当谈及为何自杀时，千砂回答说“因为我已经不需要身体了，没有身体，我可以在wired网络之间继续活着。”不解的玲音继续调查千砂的事件，发现wired网络之中隐藏的巨大秘密，玲音自己的身世也出现了谜团。玲音面对网络世界中的真相，耳边不断响起千砂的话“我生存在wired中，因为神在那里。”","date":"1998-07-06","objectID":"/anime/lain/","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"简介 岩仓玲音的同学四方田千砂自杀了。没有任何前兆的自杀事件让同学们不知所措，一周后，玲音收到了千砂的短信。明明已死的千砂居然以手机短信和玲音开始了交流。回到家，玲音用爸爸给她的电脑开始与千砂联系。当谈及为何自杀时，千砂回答说“因为我已经不需要身体了，没有身体，我可以在wired网络之间继续活着。”不解的玲音继续调查千砂的事件，发现wired网络之中隐藏的巨大秘密，玲音自己的身世也出现了谜团。玲音面对网络世界中的真相，耳边不断响起千砂的话“我生存在wired中，因为神在那里。” 制作人员： 导演：中村隆太郎 脚本：小中千昭 分镜：仁贺绿朗、佐藤卓哉、村田雅彦 演出：松浦锭平 ","date":"1998-07-06","objectID":"/anime/lain/:1:0","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 岩仓玲音 Lain Iwakura、岩倉 玲音、Iwakura Lain 女 清水香里 2 岩仓康男 岩倉 康男、Iwakura Yasuo 男 大林隆介 3 岩仓美香 岩倉 美香、Iwakura Mika 女 川澄綾子 4 岩仓美穗 岩倉 美穂、Iwakura Miho 女 五十嵐麗 5 英利政美 Eiri Masami 男 速水奨 6 瑞城爱丽丝 Mizuki Alice、みずき ありす、Mizuki Arisu 女 浅田葉子 ","date":"1998-07-06","objectID":"/anime/lain/:2:0","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 玲音 1998-07-06 13 bilibili ","date":"1998-07-06","objectID":"/anime/lain/:3:0","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"MAD ","date":"1998-07-06","objectID":"/anime/lain/:4:0","tags":null,"title":"玲音","uri":"/anime/lain/"},{"categories":null,"content":"雾越未麻是流行音乐偶像团体“CHAM!”中的成员之一，但是在公司的决策下，她开始转型为演员。但她却感觉内心有个声音在拒绝自己的选择，而未麻的一些歌迷也反对这个决定。随着越来越多电视剧的演出，未麻却觉得自己的头脑越来越奇怪，仿佛有“另一个自己”正在形成。这时，她身边的工作人员竟一个个接连被杀。在面对社会压力和疑云之际，未麻感到越来越混乱…","date":"1998-02-28","objectID":"/anime/perfect_blue/","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"简介 雾越未麻是流行音乐偶像团体“CHAM!”中的成员之一，但是在公司的决策下，她开始转型为演员。但她却感觉内心有个声音在拒绝自己的选择，而未麻的一些歌迷也反对这个决定。随着越来越多电视剧的演出，未麻却觉得自己的头脑越来越奇怪，仿佛有“另一个自己”正在形成。这时，她身边的工作人员竟一个个接连被杀。在面对社会压力和疑云之际，未麻感到越来越混乱… 制作人员： 原作：竹内义和 导演：今敏 脚本：村井贞之 演出：松尾衡 音乐：几见雅博 人物原案：江口寿史 人物设定：滨洲英喜 ","date":"1998-02-28","objectID":"/anime/perfect_blue/:1:0","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 雾越未麻 霧越未麻、Kirigoe Mima 女 岩男潤子 2 内田 Uchida、うちだ 男 大倉正章 3 留美 Rumi、るみ 女 松本梨香 ","date":"1998-02-28","objectID":"/anime/perfect_blue/:2:0","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 蓝色恐惧 1998-02-28 01:21:44 樱花 ","date":"1998-02-28","objectID":"/anime/perfect_blue/:3:0","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"MAD ","date":"1998-02-28","objectID":"/anime/perfect_blue/:4:0","tags":null,"title":"蓝色恐惧","uri":"/anime/perfect_blue/"},{"categories":null,"content":"大和王权时期蝦夷族末代王子阿席达卡，在保卫他的村庄时被一恶魔诅咒受不治创伤。村里的巫婆劝他前往西方，寻找恶魔的来源和解除诅咒的方法。在他的旅途中，他來到山獸神森林，认识了被称为“魔法公主”的、由犬神抚养大的小桑。\n\n在這個過程中，阿席達卡发现恶魔本来是一个山猪神，但体内中了一颗铁弹后，对人类憎恨无比，变成了恶魔。铁弹是工業之城達達拉的統治者幻姬领导的穷人在铁城里制造的，为了保护自己不被贪心的封建贵族吞并，幻姬使用火器和铁弹作为武器，而为了制造火器和铁弹，她又必须从大自然中开发木头和铁矿石，由此与原始森林中的兽神交恶。\n\n阿席达卡试图在双方调停，但却越来越深地被牵入了这场冲突。","date":"1997-07-12","objectID":"/anime/princess_mononoke/","tags":null,"title":"幽灵公主","uri":"/anime/princess_mononoke/"},{"categories":null,"content":"简介 大和王权时期蝦夷族末代王子阿席达卡，在保卫他的村庄时被一恶魔诅咒受不治创伤。村里的巫婆劝他前往西方，寻找恶魔的来源和解除诅咒的方法。在他的旅途中，他來到山獸神森林，认识了被称为“魔法公主”的、由犬神抚养大的小桑。 在這個過程中，阿席達卡发现恶魔本来是一个山猪神，但体内中了一颗铁弹后，对人类憎恨无比，变成了恶魔。铁弹是工業之城達達拉的統治者幻姬领导的穷人在铁城里制造的，为了保护自己不被贪心的封建贵族吞并，幻姬使用火器和铁弹作为武器，而为了制造火器和铁弹，她又必须从大自然中开发木头和铁矿石，由此与原始森林中的兽神交恶。 阿席达卡试图在双方调停，但却越来越深地被牵入了这场冲突。 制作人员： 原","date":"1997-07-12","objectID":"/anime/princess_mononoke/:1:0","tags":null,"title":"幽灵公主","uri":"/anime/princess_mononoke/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 阿席达卡 アシタカヒコ、Ashitaka、アシタカ、Ashitaka 男 松田洋治 2 珊 サン、San、幽灵公主 女 石田ゆり子 3 エボシ エボシ、Eboshi 女 田中裕子 4 乙事主 おっことぬし、Okkotonushi、乙事主 森繁久彌 5 甲六 Kouroku、甲六 男 西村雅彦 6 トキ トキ、Toki 女 島本須美 7 山兽神 シシ神、Shishigami ","date":"1997-07-12","objectID":"/anime/princess_mononoke/:2:0","tags":null,"title":"幽灵公主","uri":"/anime/princess_mononoke/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 幽灵公主 1997-07-12 1 樱花 ","date":"1997-07-12","objectID":"/anime/princess_mononoke/:3:0","tags":null,"title":"幽灵公主","uri":"/anime/princess_mononoke/"},{"categories":null,"content":"　　其內容主要描寫中國四川省的年輕廚師劉昴星（マオ，外號阿昴，台灣譯為小當家）學習廚藝，到廣州陽泉酒家修行，獲得特級廚師（漫畫中虛構的中國料理界的最高地位）資格，因為主角堅持一個信念－－料理是為人們帶來幸福的。結交許多對於廚藝有志一同的朋友，及最後與「黑暗料理界」（裏料理界）對抗過程的冒險歷程。\n\n漫畫（第1集～第17集完）、動畫有第1話～第52話，動畫的故事至此尚未完結，因為「傳說中的廚具」尚未取得，且尚沒有和黑暗料理界進行最後決戰，後續的劇情因動畫追上漫畫連載而就此打住。","date":"1997-04-27","objectID":"/anime/chuka_ichiban/","tags":null,"title":"中华小当家","uri":"/anime/chuka_ichiban/"},{"categories":null,"content":"简介 其內容主要描寫中國四川省的年輕廚師劉昴星（マオ，外號阿昴，台灣譯為小當家）學習廚藝，到廣州陽泉酒家修行，獲得特級廚師（漫畫中虛構的中國料理界的最高地位）資格，因為主角堅持一個信念－－料理是為人們帶來幸福的。結交許多對於廚藝有志一同的朋友，及最後與「黑暗料理界」（裏料理界）對抗過程的冒險歷程。 漫畫（第1集～第17集完）、動畫有第1話～第52話，動畫的故事至此尚未完結，因為「傳說中的廚具」尚未取得，且尚沒有和黑暗料理界進行最後決戰，後續的劇情因動畫追上漫畫連載而就此打住。 制作人员： 原作：小川悦司 导演：案纳正美 脚本：岸间信明、菅良幸、户田博史 分镜：西田健一、高村彰、渊上真、高木淳 ","date":"1997-04-27","objectID":"/anime/chuka_ichiban/:1:0","tags":null,"title":"中华小当家","uri":"/anime/chuka_ichiban/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 刘昴星 小当家、Liu Maoxing、リュウ・マオシン、マオ 男 田中真弓 2 周梅丽 梅丽、赵梅丽、赵美莉、嘟嘟、チョウ・メイリィ 女 ゆきのさつき 3 兰飞鸿 阿飞、Lan Fei Hong、ラン・フェイフォン、フェイ 男 置鮎龍太郎 4 四郎 シロウ、Shiro 男 坂本千夏 5 解鲁 鋼棍のシェル 男 家中宏 6 雷恩 七星刀のレオン 男 野田順子 7 周瑜 チョウユ 男 大塚明夫 8 罗鋈 ルオウ 男 石森達幸 ","date":"1997-04-27","objectID":"/anime/chuka_ichiban/:2:0","tags":null,"title":"中华小当家","uri":"/anime/chuka_ichiban/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 中华小当家 1997-04-27 52 樱花 ","date":"1997-04-27","objectID":"/anime/chuka_ichiban/:3:0","tags":null,"title":"中华小当家","uri":"/anime/chuka_ichiban/"},{"categories":null,"content":"天上欧蒂娜是一位穿着男生制服的性格少女。年幼时为一位王子所救，由于心怀憧憬而期望自己能成为王子。\n入读凤学园之后，欧蒂娜因为特立独行的作风而受到校方责难，但同时也成为了众人目光的焦点。这样的欧蒂娜遇到了被称为“蔷薇的新娘”的柔弱少女姬宫安希，同情安希的遭遇而决定保护她的欧蒂娜，被卷入了学生会争夺“改革世界的力量”的一系列决斗中，向“世界的尽头”发起挑战。\n\n少女革命的原作是以幾原邦彦为首的原创团队ビーパパス（Bepapas），团队成员包括榎户洋司、さいとうちほ(斋藤千穗)、長谷川眞也、小黒祐一郎等人。有些人以为由斋藤千穗执笔的漫画是《少女革命》的原作，这其实是误解，实际上少女漫画家出身的斋藤与幾原就《少女革命》的主题意见相左，这一点在漫画版《少女革命》中亦有所体现。而《少女革命》的TV动画由于其隐晦深刻的内涵和独特的世界观而与EVA、机动战舰并称为OTAKU三大经典。","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"简介 天上欧蒂娜是一位穿着男生制服的性格少女。年幼时为一位王子所救，由于心怀憧憬而期望自己能成为王子。 入读凤学园之后，欧蒂娜因为特立独行的作风而受到校方责难，但同时也成为了众人目光的焦点。这样的欧蒂娜遇到了被称为“蔷薇的新娘”的柔弱少女姬宫安希，同情安希的遭遇而决定保护她的欧蒂娜，被卷入了学生会争夺“改革世界的力量”的一系列决斗中，向“世界的尽头”发起挑战。 少女革命的原作是以幾原邦彦为首的原创团队ビーパパス（Bepapas），团队成员包括榎户洋司、さいとうちほ(斋藤千穗)、長谷川眞也、小黒祐一郎等人。有些人以为由斋藤千穗执笔的漫画是《少女革命》的原作，这其实是误解，实际上少女漫画家出身的斋","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/:1:0","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天上欧蒂娜 天上萼、Tenjou Utena 女 川上とも子 2 姬宫安希 姬宫安诗、Himemiya Anthy、ひめみや アンシー、Himemiya Anshii 女 渕崎ゆり子 3 桐生冬芽 桐生冬芽、きりゅう　とうが、Kiryuu Touga 男 子安武人 4 有栖川树璃 有栖川樹璃、ありすがわ　じゅり、Arisugawa Juri 女 三石琴乃 5 薰干 かおる みき、Kaoru Miki、ミッキー 男 久川綾 6 西园寺荚一 さいおんじ きょういち、Saionji Kyoichi 男 草尾毅 7 桐生七实 きりゅう ななみ、Kiryuu Nana","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/:2:0","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 少女革命 1997-04-02 39 bilibili 2 少女革命剧场版 思春期默示录 1999-08-14 1 bilibili ","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/:3:0","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"MAD ","date":"1997-04-02","objectID":"/anime/shoujo_kakumei_utena/:4:0","tags":null,"title":"少女革命","uri":"/anime/shoujo_kakumei_utena/"},{"categories":null,"content":"一个在学校教书的普通老师，常常生出些古古怪怪的想法，教些莫名其妙的东西。\n身体之所以会感受到温暖，是因为原子感受到了春的味道，从窗户里跳出去，感受春天吧。\n你们看这些石头，像不像一个个人，我们甚至能与之对谈，不信么，用锤子敲一下试试，叮叮咚咚，真的，每一块都不一样。\n尤其是那喵的一声，让人误会这是个温暖的小品。","date":"1996-12-14","objectID":"/anime/spring_and_chaos/","tags":null,"title":"贤治之春","uri":"/anime/spring_and_chaos/"},{"categories":null,"content":"简介 一个在学校教书的普通老师，常常生出些古古怪怪的想法，教些莫名其妙的东西。 身体之所以会感受到温暖，是因为原子感受到了春的味道，从窗户里跳出去，感受春天吧。 你们看这些石头，像不像一个个人，我们甚至能与之对谈，不信么，用锤子敲一下试试，叮叮咚咚，真的，每一块都不一样。 尤其是那喵的一声，让人误会这是个温暖的小品。 制作人员： 导演：河森正治 演出：佐藤英一 音乐：上上台风 人物设定：岸田隆宏 美术监督：大野广司 色彩设计：一濑美代子 摄影监督：野口肇 ","date":"1996-12-14","objectID":"/anime/spring_and_chaos/:1:0","tags":null,"title":"贤治之春","uri":"/anime/spring_and_chaos/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 贤治之春 1996-12-14 00:56:07 bilibili ","date":"1996-12-14","objectID":"/anime/spring_and_chaos/:2:0","tags":null,"title":"贤治之春","uri":"/anime/spring_and_chaos/"},{"categories":null,"content":"配乐 ","date":"1996-12-14","objectID":"/anime/spring_and_chaos/:3:0","tags":null,"title":"贤治之春","uri":"/anime/spring_and_chaos/"},{"categories":null,"content":"一共52集动画。由美国方面制作推出，采取革命性的3D动画模式，日本版本为美版的配音输出版本。美版动画将其划分为第一季26集（SEASON 1），第二季13集（SEASON 2），第三季13集（SEASON 3）。日版动画则把第二季和第三季一共26集称为“BEASWT WARS METALS”。国内引进时全部一起播出，翻译为“超能勇士”。\n　　汽车人后代巨无霸（港译：密斯姆）与霸天虎后代原始兽（港译：巴达乾）继续战斗着。巨无霸领袖黑猩猩（港译：奥迪武）率领分队追击原始兽的霸王龙（港译：麦卡顿），双方穿梭时空来到史前地球并坠毁在地球上。为了抵御地球的能量乾扰，他们都使自己变形为野兽，开始了一场野兽战争BEAST WARS。双方在地球上陆续发现外星人的机关，在与外星人较量中，部分变形金刚转化为恒定的金属变体（TRANS METALS），战斗异常激烈。霸王龙发现古老的战舰方舟号，并试图摧毁未苏醒的擎天柱而改变历史。黑猩猩在对战中吸收了擎天柱的力量而进化为TRANS METAL 2，霸王龙也通过吸收威震天的力量而进化成红色火龙。外星人介入，但被消灭。霸王龙最后找到了霸天虎的古老战舰报应号，并试图驾驶它摧毁方舟。最后报应号被击落，霸王龙被抓获，巨无霸返回塞伯坦　　 ","date":"1996-09-16","objectID":"/anime/beast_wars/","tags":null,"title":"超能勇士","uri":"/anime/beast_wars/"},{"categories":null,"content":"简介 一共52集动画。由美国方面制作推出，采取革命性的3D动画模式，日本版本为美版的配音输出版本。美版动画将其划分为第一季26集（SEASON 1），第二季13集（SEASON 2），第三季13集（SEASON 3）。日版动画则把第二季和第三季一共26集称为“BEASWT WARS METALS”。国内引进时全部一起播出，翻译为“超能勇士”。 汽车人后代巨无霸（港译：密斯姆）与霸天虎后代原始兽（港译：巴达乾）继续战斗着。巨无霸领袖黑猩猩（港译：奥迪武）率领分队追击原始兽的霸王龙（港译：麦卡顿），双方穿梭时空来到史前地球并坠毁在地球上。为了抵御地球的能量乾扰，他们都使自己变形为野兽，开始了一场野","date":"1996-09-16","objectID":"/anime/beast_wars/:1:0","tags":null,"title":"超能勇士","uri":"/anime/beast_wars/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 Airazor 女 2 擎天柱 柯柏文、柯博文 男 ","date":"1996-09-16","objectID":"/anime/beast_wars/:2:0","tags":null,"title":"超能勇士","uri":"/anime/beast_wars/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 超能勇士 1996-09-16 52 bilibili 2 猛兽侠 1999-09-18 26 bilibili ","date":"1996-09-16","objectID":"/anime/beast_wars/:3:0","tags":null,"title":"超能勇士","uri":"/anime/beast_wars/"},{"categories":null,"content":"　　2000年，一个科学探险队在南极洲针对被称作“第一使徒”亚当的“光之巨人”进行探险。在对其进行接触实验时，“光之巨人”自毁，从而发生了“第二次冲击”，进而导致世界大战。最后，人类人口减半，地轴偏转、气候改变。根据对“第二次冲击”的调查，联合国在日本箱根成立人工进化研究所（即 GEHIRN）从事EVA（指机器人）的发展研究，后GEHIRN利用在人工进化研究所下方发现的巨大空洞建造了总部。\n另一方面，联合国下属秘密组织SEELE为了使人类进化，开始实行人类补完计划，就是将所有人的灵魂汇集在一起，通过中和每个人的AT力场，使每个人回归LCL之海。\n2004年，EVA初号机进行启动试验时发生事故，碇真嗣的母亲碇唯消失，碇源渡开始执行“碇源渡版本的人类补完计划”。2010年，GEHIRN被改建成NERV。\n2015年开始，根据SEELE人类补完计划剧本的安排，一种巨型人形生物“使徒”开始在日本登陆，并向NERV总部进攻，NERV组织EVA消灭使徒。在NERV与使徒作战的同时，碇源渡秘密地执行它自己的计划。随着时间推移，碇源渡的计划逐渐被SEELE发现，NERV与SEELE产生了矛盾并不断恶化。\nDirector's Cut版本的第21～24集由剧场版《Death》篇剪辑而成，收录在20周年纪念版的蓝光中。","date":"1995-10-04","objectID":"/anime/evangelion/","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"简介 2000年，一个科学探险队在南极洲针对被称作“第一使徒”亚当的“光之巨人”进行探险。在对其进行接触实验时，“光之巨人”自毁，从而发生了“第二次冲击”，进而导致世界大战。最后，人类人口减半，地轴偏转、气候改变。根据对“第二次冲击”的调查，联合国在日本箱根成立人工进化研究所（即 GEHIRN）从事EVA（指机器人）的发展研究，后GEHIRN利用在人工进化研究所下方发现的巨大空洞建造了总部。 另一方面，联合国下属秘密组织SEELE为了使人类进化，开始实行人类补完计划，就是将所有人的灵魂汇集在一起，通过中和每个人的AT力场，使每个人回归LCL之海。 2004年，EVA初号机进行启动试验时发生事故","date":"1995-10-04","objectID":"/anime/evangelion/:1:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 碇真嗣 碇真治、いかり　しんじ、Ikari Shinji、笨蛋真嗣（バガシンジ），小鬼真嗣（ガキシンジ，剧场版Q） 男 緒方恵美 2 绫波丽 绫波零、あやなみ レイ、Ayanami Rei 女 林原めぐみ 3 惣流·明日香·兰格雷 Soryu Asuka Langley、そうりゅう・アスカ・ラングレー、Sōryū Asuka Rangurē、香香、式波・アスカ・ラングレー、式波·明日香·兰格雷、Shikinami Asuka Langley、しきなみ・アスカ・ラングレー、Shikinami Asuka Rangurē 女 宮村優子 4 葛城美里 葛城ミサト、","date":"1995-10-04","objectID":"/anime/evangelion/:2:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 新世纪福音战士 1995-10-04 26 bilibili 2 新世纪福音战士剧场版 死与新生 1997-03-15 2 bilibili 3 新世纪福音战士剧场版 Air/真心为你 1997-07-19 2 bilibili 4 福音战士新剧场版：序 2007-09-01 1 bilibili 5 福音战士新剧场版：破 2009-06-27 1 bilibili 6 福音战士新剧场版：Q 2012-11-17 1 bilibili 7 新・福音战士剧场版：终 2021-03-08 1 小兵看看 ","date":"1995-10-04","objectID":"/anime/evangelion/:3:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"配乐 ","date":"1995-10-04","objectID":"/anime/evangelion/:4:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"MAD ","date":"1995-10-04","objectID":"/anime/evangelion/:5:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"*同人 ","date":"1995-10-04","objectID":"/anime/evangelion/:6:0","tags":null,"title":"新世纪福音战士","uri":"/anime/evangelion/"},{"categories":null,"content":"在制作第一代游戏时之所以取名为《仙剑奇侠传》，姚壮宪解释是因为“仙”字代表像赵灵儿这样的人间仙女；\n“剑”代表江湖，代表武侠，也是代表李逍遥。但是觉得只有两个字不够，便继续取“奇”字，代表奇幻的元素，也是代表阿奴。\n“侠”便是侠义精神，最后加上后缀“传”字，于是就组成了《仙剑奇侠传》这一名称。\n初代暂以PAL作为“仙剑奇侠传”的英文缩写，源自于林坤信为姚壮宪作曲时所使用的目录名称“PAL”，意即“Paladin”\n（中文意为“骑士”、“游侠”等），并一直沿用至今。","date":"1995-07-07","objectID":"/game/xian_jian/","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"简介 在制作第一代游戏时之所以取名为《仙剑奇侠传》，姚壮宪解释是因为“仙”字代表像赵灵儿这样的人间仙女； “剑”代表江湖，代表武侠，也是代表李逍遥。但是觉得只有两个字不够，便继续取“奇”字，代表奇幻的元素，也是代表阿奴。 “侠”便是侠义精神，最后加上后缀“传”字，于是就组成了《仙剑奇侠传》这一名称。 初代暂以PAL作为“仙剑奇侠传”的英文缩写，源自于林坤信为姚壮宪作曲时所使用的目录名称“PAL”，意即“Paladin” （中文意为“骑士”、“游侠”等），并一直沿用至今。 制作人员： 开发：大宇资讯股份有限公司 遊戲設計師：姚壮宪 剧本：谢崇辉 音乐：林坤信 ","date":"1995-07-07","objectID":"/game/xian_jian/:1:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 李逍遥 一贫 男 2 赵灵儿 女 3 林月如 女 4 阿奴 海棠 女 5 酒剑仙 司徒钟 男 6 彩依 女 7 丁香兰 女 8 丁秀兰 女 ","date":"1995-07-07","objectID":"/game/xian_jian/:2:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"系列 系列名 发行时间 1 仙剑奇侠传 1995-07-07 2 新仙剑奇侠传 2001-07-21 3 仙剑奇侠传二 2003-01-23 4 仙剑奇侠传三 2003-07-31 5 仙剑奇侠传三外传·问情篇 2004-08-06 6 仙剑奇侠传四 2007-08-01 7 仙剑奇侠传五 2011-07-07 8 仙剑奇侠传五前传 2013-01-15 9 仙剑奇侠传六 2015-07-08 10 仙剑奇侠传七 2021-10-15 ","date":"1995-07-07","objectID":"/game/xian_jian/:3:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"配乐 ","date":"1995-07-07","objectID":"/game/xian_jian/:4:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"MAD ","date":"1995-07-07","objectID":"/game/xian_jian/:5:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"*同人 ","date":"1995-07-07","objectID":"/game/xian_jian/:6:0","tags":null,"title":"仙剑系列","uri":"/game/xian_jian/"},{"categories":null,"content":"很久很久以前……在原始的混沌之海中，从无边的黑暗中诞生了唯一一个纯真的意志……这个意志所产生的力量，让原本一片虛无的混沌之海发生变化。如造物主般分出了无数世界，这些世界是由无数石柱一般长杖支撑在混沌之海上。她，是这世间万物的母亲。因此，有了神、有了魔……也有了人类。神与魔不断地纷争，神为了保卫世界而战；魔为了争取长杖毀灭世界而战。造物主沉眠了……她被魔族奉为大王--金色魔王，也是帶來恶梦的魔王。在这个世界，赤眼魔王卢比埃和龙神史菲德为了各自的目的而战……龙神史菲德费劲心力将卢比埃击败，并将它分为七部份……但史菲德也累了，为了防范魔族的行动，他化为四个分身固守着四方。一千年前，魔王的一部份觉醒了。它率领着魔族们向史菲德的一個分身--水龙王挑战。魔王五个手下中的四个设下了结界，由它和魔龙王一起直接跟水龙王决斗。魔王的计划，宣告失败。卢比埃被打倒，魔龙王被封印。魔族的行动渐趋寂静……一千年后，一名天才美少女诞生了。她名叫莉娜·因巴斯（LinaInverse），和伙伴高里·布列夫（GourryGabriev）一起踏上旅程。但，魔族们仍不停止动作。它们期待着真正的王能回來，也就是--金色魔王，带来恶梦的魔王……","date":"1995-04-07","objectID":"/anime/slayers/","tags":null,"title":"秀逗魔导士","uri":"/anime/slayers/"},{"categories":null,"content":"简介 很久很久以前……在原始的混沌之海中，从无边的黑暗中诞生了唯一一个纯真的意志……这个意志所产生的力量，让原本一片虛无的混沌之海发生变化。如造物主般分出了无数世界，这些世界是由无数石柱一般长杖支撑在混沌之海上。她，是这世间万物的母亲。因此，有了神、有了魔……也有了人类。神与魔不断地纷争，神为了保卫世界而战；魔为了争取长杖毀灭世界而战。造物主沉眠了……她被魔族奉为大王–金色魔王，也是帶來恶梦的魔王。在这个世界，赤眼魔王卢比埃和龙神史菲德为了各自的目的而战……龙神史菲德费劲心力将卢比埃击败，并将它分为七部份……但史菲德也累了，为了防范魔族的行动，他化为四个分身固守着四方。一千年前，魔王的一部份觉","date":"1995-04-07","objectID":"/anime/slayers/:1:0","tags":null,"title":"秀逗魔导士","uri":"/anime/slayers/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 莉娜·因巴斯 Лина Инверс、Lina Inverse 女 林原めぐみ 2 高里·杰布列夫 Gourry Gabriev 男 松本保典 3 杰路刚帝士·克雷依威斯 Зелгадис Грейвардс、Zelgadiss Graywords 男 緑川光 4 加梅莉亚·威尔·迪斯拉·赛伦 Амелия Вил Тесла Сэйрун、Ameria Wil Tesla Saillune、Amelia Wil Tesla Seyruun 女 鈴木真仁 5 フィリオネル＝エル＝ディ＝セイルーン フィリオネル＝エル＝ディ＝セイルーン、Philionel El","date":"1995-04-07","objectID":"/anime/slayers/:2:0","tags":null,"title":"秀逗魔导士","uri":"/anime/slayers/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 秀逗魔导士 1995-04-07 26 bilibili 2 秀逗魔导士NEXT 1996-04-05 26 bilibili 3 秀逗魔导士TRY 1997-04-04 26 bilibili ","date":"1995-04-07","objectID":"/anime/slayers/:3:0","tags":null,"title":"秀逗魔导士","uri":"/anime/slayers/"},{"categories":null,"content":"63年后的未来世界由于人口过多，甚至订定了生2个小孩为死刑的法律。在这样的时代里被称为“超级花花公子（メガプレイボーイ”的男人拥有100人以上的小孩，而且其DNA被继承了下来。\n政府派出了“DNA操作者”葵华林（葵加玲）来到过去的时代，企图改变这个男人的DNA。然而这个男人桃生纯太却是个不受女性青睐、不可靠，离超级花花公子10万8千里的人。华林本来应该是依照预定达查成了任务，但却弄错了改写DNA的子弹（DCM弹），使得纯太开始出现觉醒为超级花花公子的征兆。","date":"1994-10-07","objectID":"/anime/dna2/","tags":null,"title":"再造基因","uri":"/anime/dna2/"},{"categories":null,"content":"简介 63年后的未来世界由于人口过多，甚至订定了生2个小孩为死刑的法律。在这样的时代里被称为“超级花花公子（メガプレイボーイ”的男人拥有100人以上的小孩，而且其DNA被继承了下来。 政府派出了“DNA操作者”葵华林（葵加玲）来到过去的时代，企图改变这个男人的DNA。然而这个男人桃生纯太却是个不受女性青睐、不可靠，离超级花花公子10万8千里的人。华林本来应该是依照预定达查成了任务，但却弄错了改写DNA的子弹（DCM弹），使得纯太开始出现觉醒为超级花花公子的征兆。 制作人员： 原作：桂正和 导演：坂田纯一 脚本：浦畑达彦 分镜：加濑充子、小寺胜之、阿部司、福富博、山内重保、菊池一仁 ","date":"1994-10-07","objectID":"/anime/dna2/:1:0","tags":null,"title":"再造基因","uri":"/anime/dna2/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 再造基因 1994-10-07 12 bilibili ","date":"1994-10-07","objectID":"/anime/dna2/:2:0","tags":null,"title":"再造基因","uri":"/anime/dna2/"},{"categories":null,"content":"东京私立贵大高等学校高一年级的学生弄内洋太追求同学早川然美，正当他准备告白时，却发现然美喜欢的是他的好友——同班同学新舞贵志，于是他陷入了无奈与失落。一个人走在回到家的路上，洋太的情绪十分低落，自己也不知道怎么就走到了一家名叫GOKURAU的出租录影带的商店前。洋太走过一排排录影带架后，在一盒录影带前停了下来：《安慰——天野爱》。借回家的录影带在播放过程中，天野爱居然从画面中走出！爱鼓励洋太要努力追求真爱，并以洋太妹妹的身份住在洋太家中。谁也没有想到，一段感人的恋爱故事就这样开始。","date":"1992-03-27","objectID":"/anime/video_girl/","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"简介 东京私立贵大高等学校高一年级的学生弄内洋太追求同学早川然美，正当他准备告白时，却发现然美喜欢的是他的好友——同班同学新舞贵志，于是他陷入了无奈与失落。一个人走在回到家的路上，洋太的情绪十分低落，自己也不知道怎么就走到了一家名叫GOKURAU的出租录影带的商店前。洋太走过一排排录影带架后，在一盒录影带前停了下来：《安慰——天野爱》。借回家的录影带在播放过程中，天野爱居然从画面中走出！爱鼓励洋太要努力追求真爱，并以洋太妹妹的身份住在洋太家中。谁也没有想到，一段感人的恋爱故事就这样开始。 制作人员： 原作：桂正和 导演：西久保瑞穗 脚本：关岛真赖、山下久仁明、赤堀悟 分镜：坂田纯一、望月智充 ","date":"1992-03-27","objectID":"/anime/video_girl/:1:0","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 天野爱 あまの　あい、amano ai 女 林原めぐみ 2 广播 アナウンサー、Announcer、播音员、Announce 池本小百合 ","date":"1992-03-27","objectID":"/anime/video_girl/:2:0","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 电影少女 1992-03-27 6 9anime ","date":"1992-03-27","objectID":"/anime/video_girl/:3:0","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"MAD ","date":"1992-03-27","objectID":"/anime/video_girl/:4:0","tags":null,"title":"电影少女","uri":"/anime/video_girl/"},{"categories":null,"content":"唐武皇时期，秀才唐敖科举失意，心怀抑郁。在妻兄林之洋的邀请下，他随船队出海经商，四海巡游。造访了君子国、女儿国、大人国、两面国、无肠国、穿胸国等民俗各异的国家，一路发生许多刺激和有趣的事情。\n\n改编自清小说家李汝珍的同名作品。影片第4集《两面国》获1991年度广播电影电视部优秀影片奖和1993年第二届中国影视动画展播荣誉奖。","date":"1991-12-01","objectID":"/anime/jing_hua_yuan/","tags":null,"title":"镜花缘","uri":"/anime/jing_hua_yuan/"},{"categories":null,"content":"简介 唐武皇时期，秀才唐敖科举失意，心怀抑郁。在妻兄林之洋的邀请下，他随船队出海经商，四海巡游。造访了君子国、女儿国、大人国、两面国、无肠国、穿胸国等民俗各异的国家，一路发生许多刺激和有趣的事情。 改编自清小说家李汝珍的同名作品。影片第4集《两面国》获1991年度广播电影电视部优秀影片奖和1993年第二届中国影视动画展播荣誉奖。 制作人员： 导演：胡兆洪、邹勤 背景美术：袁炽昌 剪辑：莫普忠 制作：上海美术电影制片厂 ","date":"1991-12-01","objectID":"/anime/jing_hua_yuan/:1:0","tags":null,"title":"镜花缘","uri":"/anime/jing_hua_yuan/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 镜花缘 1991-12 4 bilibili ","date":"1991-12-01","objectID":"/anime/jing_hua_yuan/:2:0","tags":null,"title":"镜花缘","uri":"/anime/jing_hua_yuan/"},{"categories":null,"content":"著名的中文角色扮演游戏，以独特的内涵和厚重的历史感在中文RPG游戏中自成一格，人气极高的《轩辕剑叁：云和山的彼端》\n与其外传《天之痕》是角色扮演游戏中的经典，随后的《苍之涛》更是感动了无数玩家。\n【主篇故事顺序】轩辕剑壹——轩辕剑贰——穹之扉（商代）——轩辕剑陆（商末周初）——苍之涛（春秋）——枫之舞（战国）——轩辕剑肆（秦代）——\n轩辕剑柒（西汉）——云之遥（三国·曹魏）——汉之云（三国·蜀汉）——轩辕剑伍——天之痕（隋代）——轩辕剑叁（安史之乱前后的欧洲、阿拉伯地区、唐帝国）","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"简介 著名的中文角色扮演游戏，以独特的内涵和厚重的历史感在中文RPG游戏中自成一格，人气极高的《轩辕剑叁：云和山的彼端》 与其外传《天之痕》是角色扮演游戏中的经典，随后的《苍之涛》更是感动了无数玩家。 【主篇故事顺序】轩辕剑壹——轩辕剑贰——穹之扉（商代）——轩辕剑陆（商末周初）——苍之涛（春秋）——枫之舞（战国）——轩辕剑肆（秦代）—— 轩辕剑柒（西汉）——云之遥（三国·曹魏）——汉之云（三国·蜀汉）——轩辕剑伍——天之痕（隋代）——轩辕剑叁（安史之乱前后的欧洲、阿拉伯地区、唐帝国） 制作人员： 开发：DOMO小组 发行：大宇资讯股份有限公司 遊戲設計師：蔡明宏 美工：郭炳宏 音乐：苏竑嶂 ","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/:1:0","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 何然 然翁、燕赤霞 男 2 杨坤硕 寧采臣、宁采臣 男 3 江如红 小倩 女 ","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/:2:0","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"系列 系列名 发行时间 1 轩辕剑 1990-10-13 2 轩辕剑二 1994-02-08 3 轩辕剑外传 枫之舞 1995-01-06 4 轩辕剑三 云和山的彼端 1999-12-15 5 轩辕剑三外传：天之痕 2000-12-02 6 轩辕剑四：黑龙舞兮云飞扬 2002-08-04 7 轩辕剑外传：苍之涛 2004-02-06 8 轩辕剑五：一剑凌云山海情 2006-10-16 9 轩辕剑外传：汉之云 2009-01-10 10 轩辕剑外传：云之遥 2010-01-12 11 轩辕剑外传：云之遥 兰茵篇 2010-04-27 ","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/:3:0","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"配乐 ","date":"1990-10-13","objectID":"/game/xuan_yuan_jian/:4:0","tags":null,"title":"轩辕剑系列","uri":"/game/xuan_yuan_jian/"},{"categories":null,"content":"《银河英雄传说》的时间设定约在距今一千六百年后，范围约扩及全银河系的五分之一。当时宇宙中存在着两大势力，分别是专制的“银河帝国”，\n和由逃出帝国的共和主义者建立的“自由行星同盟”。 帝国视同盟为“边境叛徒的根据地”，同盟则将帝国当作“邪恶的黑暗专制势力”，\n彼此水火不容，持续了长达二百多年的战争。在两国领域之间，充满了不利宇宙航行的异常重力场，使得两国间的通道，只有著名的“费沙回廊”和“伊谢尔伦回廊”。\n伊谢尔伦回廊有着难攻不落的强大军事要塞，而在费沙回廊中，是介于两大势力间的半独立国——“费沙自治领”。\n因此整个宇宙就在专制的高登巴姆王朝银河帝国和崇尚自由、自主、自尊、自律的自由行星同盟及以经济、情报生存的费沙三方平衡之下运转着。\n终于，双方各出现了一位年轻的英雄：帝国的莱因哈特·冯·罗严克拉姆，和同盟的杨威利。历史的车轮开始转动了。","date":"1988-01-08","objectID":"/anime/legend_of_galactic_heroes/","tags":null,"title":"银河英雄传说","uri":"/anime/legend_of_galactic_heroes/"},{"categories":null,"content":"简介 《银河英雄传说》的时间设定约在距今一千六百年后，范围约扩及全银河系的五分之一。当时宇宙中存在着两大势力，分别是专制的“银河帝国”， 和由逃出帝国的共和主义者建立的“自由行星同盟”。 帝国视同盟为“边境叛徒的根据地”，同盟则将帝国当作“邪恶的黑暗专制势力”， 彼此水火不容，持续了长达二百多年的战争。在两国领域之间，充满了不利宇宙航行的异常重力场，使得两国间的通道，只有著名的“费沙回廊”和“伊谢尔伦回廊”。 伊谢尔伦回廊有着难攻不落的强大军事要塞，而在费沙回廊中，是介于两大势力间的半独立国——“费沙自治领”。 因此整个宇宙就在专制的高登巴姆王朝银河帝国和崇尚自由、自主、自尊、自律的自由行星同","date":"1988-01-08","objectID":"/anime/legend_of_galactic_heroes/:1:0","tags":null,"title":"银河英雄传说","uri":"/anime/legend_of_galactic_heroes/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 莱因哈特·冯·罗严克拉姆 ラインハルト・フォン・ローエングラム、Reinhard von Lohengramm 男 堀川りょう 2 渥佛根·米达麦亚 大米、沃尔夫冈·米特迈尔、ウォルフガング・ミッターマイヤー、Wolfgang Mittermeyer、疾风之狼 男 森功至 3 奥斯卡·冯·罗严塔尔 Oskar von Reuentahl、オスカー・フォン・ロイエンタール、Oskar von Reuenthal、金银妖瞳 男 若本規夫 4 巴尔·冯·奥贝斯坦 保罗·冯·奥贝斯泰因、パウル・フォン・オーベルシュタイン、Paul von Oberstein、干冰、","date":"1988-01-08","objectID":"/anime/legend_of_galactic_heroes/:2:0","tags":null,"title":"银河英雄传说","uri":"/anime/legend_of_galactic_heroes/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 银河英雄传说 1988-01-08 110 樱花 2 银河英雄传说 我的征途是星辰大海 1988-02-06 1 bilibili 3 银河英雄传说 黄金之翼 1992-02-12 1 bilibili 4 银河英雄传说 新战争的序曲 1993-12-18 1 bilibili 5 银河英雄传说 Die Neue These 邂逅 2018-04-03 12 bilibili 6 银河英雄传说 Die Neue These 星乱 第1章 2019-09-27 12 bilibili 7 银河英雄传说 Die Neue These 激突 第1章 ","date":"1988-01-08","objectID":"/anime/legend_of_galactic_heroes/:3:0","tags":null,"title":"银河英雄传说","uri":"/anime/legend_of_galactic_heroes/"},{"categories":null,"content":"最终幻想（日语：ファイナルファンタジー，简称FF，台湾/香港：太空战士，中国大陆：最终幻想），\n1987年由日本当时的游戏软件公司史克威尔（SQUARE SOFT）（与ENIX艾尼克斯合并为：SQUARE-ENIX）开发的角色扮演游戏（RPG）游戏系列。\n\n在那个时候，正是FC红极一时的年代。充斥市场的是以《勇者斗恶龙》为代表的所谓“勇者派”RPG。那时的史克威尔公司还不过是一个小小的开发游戏的厂商。\n在做了几个游戏都没有轰动后，制作人坂口博信决定做完最后一个游戏改行。而那个游戏就被命名为《最终幻想》（多少有点悲壮的意味）。 \n不曾想，游戏一经推出就备受玩家的注目。由此开始，FF一代一代的伴着无数玩家走了过来……","date":"1987-12-18","objectID":"/game/final_fantasy/","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"简介 最终幻想（日语：ファイナルファンタジー，简称FF，台湾/香港：太空战士，中国大陆：最终幻想）， 1987年由日本当时的游戏软件公司史克威尔（SQUARE SOFT）（与ENIX艾尼克斯合并为：SQUARE-ENIX）开发的角色扮演游戏（RPG）游戏系列。 在那个时候，正是FC红极一时的年代。充斥市场的是以《勇者斗恶龙》为代表的所谓\"勇者派\"RPG。那时的史克威尔公司还不过是一个小小的开发游戏的厂商。 在做了几个游戏都没有轰动后，制作人坂口博信决定做完最后一个游戏改行。而那个游戏就被命名为《最终幻想》（多少有点悲壮的意味）。 不曾想，游戏一经推出就备受玩家的注目。由此开始，FF一代一代的伴","date":"1987-12-18","objectID":"/game/final_fantasy/:1:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 克劳德·斯特莱夫 クラウド・ストライフ、Cloud Strife 男 2 蒂法·洛克哈特 Tifa Lockhart、Tifa 女 3 艾瑞丝·盖恩斯巴勒 エアリス・ゲインズブール、Aerith Gainsborough 女 4 巴瑞特·华莱士 Barret Wallace 男 5 雷诺 レノ、Reno 男 6 扎克斯 菲尔 Zack Fair、ザックス・フェア 男 7 尤菲･如月 ユフィ・キサラギ、Yuffie Kisaragi 女 8 赤红13 Nanaki、レッドXIII、Red XIII 雄 ","date":"1987-12-18","objectID":"/game/final_fantasy/:2:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"系列 系列名 发行时间 1 最终幻想 1987-12-18 2 最终幻想5 1992-12-06 3 最终幻想6 1994-04-02 4 最终幻想7 1997-01-31 5 最终幻想8 1999-02-11 6 最终幻想9 2000-07-07 7 最终幻想10 2001-07-19 8 最终幻想12 2006-03-16 9 最终幻想7 重制版 2020-04-10 ","date":"1987-12-18","objectID":"/game/final_fantasy/:3:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"动画 系列名 首播时间 话数/时长 观看地址 1 最终幻想：灵魂深处 2001-07-11 01:46:00 bilibili 2 最终幻想VII：降临之子 2005-09-14 02:06:26 bilibili 3 最终幻想15 王者之剑 2016-07-09 01:55:33 bilibili ","date":"1987-12-18","objectID":"/game/final_fantasy/:4:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"MAD ","date":"1987-12-18","objectID":"/game/final_fantasy/:5:0","tags":null,"title":"最终幻想系列","uri":"/game/final_fantasy/"},{"categories":null,"content":"鸟山明最早在《少年JUMP》周刊连载《龙珠》时，该漫画早期（1-194篇）比较偏重于搞笑，而且打斗一般并不在这儿占主流，因此这个时期，鸟山明的画风对人物性格刻画得很精准，可以让人爆笑起来，因此东映动画公司决定把这个时期的漫画改成一部153集的动画，这也是中国内地在三部《龙珠》系列动画中唯一引进的一部，故也称龙珠TV。而且第一部有很多风格和人物剧情都根源于《西游记》，而且鸟山明的前作《阿拉蕾》中的人物也有客串。","date":"1986-02-26","objectID":"/anime/dragonball/","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"简介 鸟山明最早在《少年JUMP》周刊连载《龙珠》时，该漫画早期（1-194篇）比较偏重于搞笑，而且打斗一般并不在这儿占主流，因此这个时期，鸟山明的画风对人物性格刻画得很精准，可以让人爆笑起来，因此东映动画公司决定把这个时期的漫画改成一部153集的动画，这也是中国内地在三部《龙珠》系列动画中唯一引进的一部，故也称龙珠TV。而且第一部有很多风格和人物剧情都根源于《西游记》，而且鸟山明的前作《阿拉蕾》中的人物也有客串。 制作人员： 原作：鸟山明 脚本：出手敬、雪室俊一、丸尾未步、菅良幸、小黑祐一郎、宫崎博子、荒川稔久、由木义文 ","date":"1986-02-26","objectID":"/anime/dragonball/:1:0","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 孙悟空 Sangoku、孙悟空（成年）、Goku、孫悟空、Son Gokuu、卡卡罗特 男 野沢雅子 2 布尔玛 ブルマ、Bulma、布尔玛，布玛，庄子 女 鶴ひろみ 3 龟仙人 Tortue Géniale、Master Roshi、亀仙人、かめ せんにん、Kame Sennin、武天老師 男 宮内幸平 4 スノ Snow、スノ 女 渡辺菜生子 5 皮拉夫 ピラフ、Pilaf 男 千葉繁 6 海龟 カメ、Kame 男 郷里大輔 7 乌龙 ウーロン、Oolong 男 龍田直樹 8 阿修 シュウ、Shuu 男 玄田哲章 ","date":"1986-02-26","objectID":"/anime/dragonball/:2:0","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 龙珠 1986-02-26 153 樱花 2 龙珠Z 1989-04-26 291 樱花 3 龙珠GT 1996-02-07 64 樱花 4 龙珠改 2009-04-05 98 樱花 5 龙珠改 魔人布欧篇 2014-04-06 61 樱花 6 龙珠超 2015-07-05 131 樱花 7 龙珠Z 一夫当关的最后决战~挑战弗利萨的Z战士 孙悟空的父亲~ 1990-10-17 1 优酷 8 龙珠Z・绝望的反抗!!残留的超战士・悟饭和特兰克斯 1993-02-24 1 樱花 9 龙珠旧剧场版 1986-12-20 17 樱花 10 龙珠超 布罗利","date":"1986-02-26","objectID":"/anime/dragonball/:3:0","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"MAD ","date":"1986-02-26","objectID":"/anime/dragonball/:4:0","tags":null,"title":"龙珠","uri":"/anime/dragonball/"},{"categories":null,"content":"《哆啦A梦》（日语：ドラえもん；英语：Doraemon；旧译叮当 / 小叮当）是日本漫画家藤本弘（笔名藤子·F·不二雄）创作的漫画。\n漫画叙述了一只来自22世纪的猫型机器人——哆啦A梦，受主人野比世修的托付，回到20世纪，借助从四维口袋里拿出来的各种未来道具，\n来帮助世修的高祖父——小学生野比大雄化解身边的种种困难问题，以及生活中和妈妈野比玉子、身边的小伙伴静香、胖虎、小夫发生的轻松幽默搞笑感人的故事。","date":"1979-04-02","objectID":"/anime/doraemon/","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"简介 《哆啦A梦》（日语：ドラえもん；英语：Doraemon；旧译叮当 / 小叮当）是日本漫画家藤本弘（笔名藤子·F·不二雄）创作的漫画。 漫画叙述了一只来自22世纪的猫型机器人——哆啦A梦，受主人野比世修的托付，回到20世纪，借助从四维口袋里拿出来的各种未来道具， 来帮助世修的高祖父——小学生野比大雄化解身边的种种困难问题，以及生活中和妈妈野比玉子、身边的小伙伴静香、胖虎、小夫发生的轻松幽默搞笑感人的故事。 制作人员： 原作：藤子·F·不二雄 导演：芝山努、原平随了 脚本：神户一彦、加藤公平、川崎良、楠部工、岸间信明 ","date":"1979-04-02","objectID":"/anime/doraemon/:1:0","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 哆啦A梦 机器猫、多拉A梦、小叮当、叮当、阿蒙、Doraemon、ドラえもん、どらえもん、Doraemon 男 水田わさび 2 野比大雄 叶大雄、野比太、康夫、大宝、Nobita Nobi、野比 のび太、のび のびた、Nobi Nobita 男 大原めぐみ 3 源静香 陈静香、静怡、静儿、静子、宜静、静静、小静、Shizuka Minamoto、源 静香、みなもと しずか、Minamoto Shizuka 女 かかずゆみ 4 刚田武 刚田武志、刚田胖虎、Takeshi Goda、剛田 武、ごうだ たけし、Gouda Takeshi、ジャイアン／Giant／技","date":"1979-04-02","objectID":"/anime/doraemon/:2:0","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 哆啦A梦 大山版 1979-04-02 1787 bilibili 2 哆啦A梦 2005-04-15 * bilibili 3 哆啦A梦新剧场版 2006-03-04 10 bilibili 4 哆啦A梦：伴我同行 2014-08-08 1 bilibili ","date":"1979-04-02","objectID":"/anime/doraemon/:3:0","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"MAD ","date":"1979-04-02","objectID":"/anime/doraemon/:4:0","tags":null,"title":"哆啦A梦","uri":"/anime/doraemon/"},{"categories":null,"content":"《猫和老鼠》（Tom and Jerry）是米高梅电影公司于1939年制作的一部动画，该片由威廉·汉纳、约瑟夫·巴伯拉编写，\n弗雷德·昆比制作，首部剧集《甜蜜的家》于1940年2月10日在美国首播。\n\n\n《猫和老鼠》以闹剧为特色，描绘了一对水火不容的冤家：汤姆和杰瑞猫鼠之间的战争，片中的汤姆经常使用狡诈的诡计来对付杰瑞，\n而杰瑞则时常利用汤姆诡计中的漏洞逃脱他的迫害并给予报复。","date":"1940-02-10","objectID":"/anime/tom_and_jerry/","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"简介 《猫和老鼠》（Tom and Jerry）是米高梅电影公司于1939年制作的一部动画，该片由威廉·汉纳、约瑟夫·巴伯拉编写，弗雷德·昆比制作，首部剧集《甜蜜的家》于1940年2月10日在美国首播。 《猫和老鼠》以闹剧为特色，描绘了一对水火不容的冤家：汤姆和杰瑞猫鼠之间的战争，片中的汤姆经常使用狡诈的诡计来对付杰瑞，而杰瑞则时常利用汤姆诡计中的漏洞逃脱他的迫害并给予报复。 制作人员： 导演：威廉·汉纳、约瑟夫·巴伯拉 音乐：斯科特·布拉德利 製作：华纳兄弟动画 ","date":"1940-02-10","objectID":"/anime/tom_and_jerry/:1:0","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"角色 角色名 别名 性别 配音 1 汤姆 Jasper、Thomas、Tom、汤姆猫 男猫 William Hanna 2 杰瑞 Jerry、Jinx、杰瑞鼠 男鼠 3 斯派克 雄 4 泰克 雄 5 泰菲 塔菲、尼布斯、Nibbles Mouse 雄 ","date":"1940-02-10","objectID":"/anime/tom_and_jerry/:2:0","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 猫和老鼠 1940-02-10 164 下方 ","date":"1940-02-10","objectID":"/anime/tom_and_jerry/:3:0","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"MAD ","date":"1940-02-10","objectID":"/anime/tom_and_jerry/:4:0","tags":null,"title":"猫和老鼠","uri":"/anime/tom_and_jerry/"},{"categories":null,"content":"2006年法国昂西评选的100部短篇动画作品","date":"1908-08-17","objectID":"/anime/1908/","tags":null,"title":"动画的世纪·100 部作品","uri":"/anime/1908/"},{"categories":null,"content":"简介 2006年法国昂西评选的100部短篇动画作品。 ","date":"1908-08-17","objectID":"/anime/1908/:1:0","tags":null,"title":"动画的世纪·100 部作品","uri":"/anime/1908/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 动画的世纪·100 部作品 1908-08-17 100 下方 ","date":"1908-08-17","objectID":"/anime/1908/:2:0","tags":null,"title":"动画的世纪·100 部作品","uri":"/anime/1908/"},{"categories":null,"content":"早期的标志性动画作品，从 1892 第一部动画《可怜的比埃洛》到 1928 第一部有声动画《汽船威利号》。","date":"1892-10-28","objectID":"/anime/1892/","tags":null,"title":"动画的起源","uri":"/anime/1892/"},{"categories":null,"content":"简介 早期的标志性动画作品，从 1892 第一部动画《可怜的比埃洛》到 1928 第一部有声动画《汽船威利号》。 ","date":"1892-10-28","objectID":"/anime/1892/:1:0","tags":null,"title":"动画的起源","uri":"/anime/1892/"},{"categories":null,"content":"系列 系列名 首播时间 话数/时长 观看地址 1 动画的起源 1892-10-28 12 下方 ","date":"1892-10-28","objectID":"/anime/1892/:2:0","tags":null,"title":"动画的起源","uri":"/anime/1892/"}]